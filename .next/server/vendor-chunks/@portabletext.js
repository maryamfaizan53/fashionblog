/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@portabletext";
exports.ids = ["vendor-chunks/@portabletext"];
exports.modules = {

/***/ "(ssr)/./node_modules/@portabletext/editor/node_modules/react-compiler-runtime/dist/index.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/node_modules/react-compiler-runtime/dist/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @lightSyntaxTransform\n * @noflow\n * @nolint\n * @preventMunge\n * @preserve-invariant-messages\n */ \"use no memo\";\n\"use strict\";\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar React__namespace = /*#__PURE__*/ _interopNamespaceDefault(React);\nvar _a, _b;\nconst { useRef, useEffect, isValidElement } = React__namespace;\nconst ReactSecretInternals = (_a = React__namespace.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE) !== null && _a !== void 0 ? _a : React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nconst $empty = Symbol.for(\"react.memo_cache_sentinel\");\nconst c = typeof ((_b = React__namespace.__COMPILER_RUNTIME) === null || _b === void 0 ? void 0 : _b.c) === \"function\" ? React__namespace.__COMPILER_RUNTIME.c : function c(size) {\n    return React__namespace.useMemo(()=>{\n        const $ = new Array(size);\n        for(let ii = 0; ii < size; ii++){\n            $[ii] = $empty;\n        }\n        $[$empty] = true;\n        return $;\n    }, []);\n};\nconst LazyGuardDispatcher = {};\n[\n    \"readContext\",\n    \"useCallback\",\n    \"useContext\",\n    \"useEffect\",\n    \"useImperativeHandle\",\n    \"useInsertionEffect\",\n    \"useLayoutEffect\",\n    \"useMemo\",\n    \"useReducer\",\n    \"useRef\",\n    \"useState\",\n    \"useDebugValue\",\n    \"useDeferredValue\",\n    \"useTransition\",\n    \"useMutableSource\",\n    \"useSyncExternalStore\",\n    \"useId\",\n    \"unstable_isNewReconciler\",\n    \"getCacheSignal\",\n    \"getCacheForType\",\n    \"useCacheRefresh\"\n].forEach((name)=>{\n    LazyGuardDispatcher[name] = ()=>{\n        throw new Error(`[React] Unexpected React hook call (${name}) from a React compiled function. ` + \"Check that all hooks are called directly and named according to convention ('use[A-Z]') \");\n    };\n});\nlet originalDispatcher = null;\nLazyGuardDispatcher[\"useMemoCache\"] = (count)=>{\n    if (originalDispatcher == null) {\n        throw new Error(\"React Compiler internal invariant violation: unexpected null dispatcher\");\n    } else {\n        return originalDispatcher.useMemoCache(count);\n    }\n};\nvar GuardKind;\n(function(GuardKind) {\n    GuardKind[GuardKind[\"PushGuardContext\"] = 0] = \"PushGuardContext\";\n    GuardKind[GuardKind[\"PopGuardContext\"] = 1] = \"PopGuardContext\";\n    GuardKind[GuardKind[\"PushExpectHook\"] = 2] = \"PushExpectHook\";\n    GuardKind[GuardKind[\"PopExpectHook\"] = 3] = \"PopExpectHook\";\n})(GuardKind || (GuardKind = {}));\nfunction setCurrent(newDispatcher) {\n    ReactSecretInternals.ReactCurrentDispatcher.current = newDispatcher;\n    return ReactSecretInternals.ReactCurrentDispatcher.current;\n}\nconst guardFrames = [];\nfunction $dispatcherGuard(kind) {\n    const curr = ReactSecretInternals.ReactCurrentDispatcher.current;\n    if (kind === GuardKind.PushGuardContext) {\n        guardFrames.push(curr);\n        if (guardFrames.length === 1) {\n            originalDispatcher = curr;\n        }\n        if (curr === LazyGuardDispatcher) {\n            throw new Error(`[React] Unexpected call to custom hook or component from a React compiled function. ` + \"Check that (1) all hooks are called directly and named according to convention ('use[A-Z]') \" + \"and (2) components are returned as JSX instead of being directly invoked.\");\n        }\n        setCurrent(LazyGuardDispatcher);\n    } else if (kind === GuardKind.PopGuardContext) {\n        const lastFrame = guardFrames.pop();\n        if (lastFrame == null) {\n            throw new Error(\"React Compiler internal error: unexpected null in guard stack\");\n        }\n        if (guardFrames.length === 0) {\n            originalDispatcher = null;\n        }\n        setCurrent(lastFrame);\n    } else if (kind === GuardKind.PushExpectHook) {\n        guardFrames.push(curr);\n        setCurrent(originalDispatcher);\n    } else if (kind === GuardKind.PopExpectHook) {\n        const lastFrame = guardFrames.pop();\n        if (lastFrame == null) {\n            throw new Error(\"React Compiler internal error: unexpected null in guard stack\");\n        }\n        setCurrent(lastFrame);\n    } else {\n        throw new Error(\"React Compiler internal error: unreachable block\" + kind);\n    }\n}\nfunction $reset($) {\n    for(let ii = 0; ii < $.length; ii++){\n        $[ii] = $empty;\n    }\n}\nfunction $makeReadOnly() {\n    throw new Error(\"TODO: implement $makeReadOnly in react-compiler-runtime\");\n}\nconst renderCounterRegistry = new Map();\nfunction clearRenderCounterRegistry() {\n    for (const counters of renderCounterRegistry.values()){\n        counters.forEach((counter)=>{\n            counter.count = 0;\n        });\n    }\n}\nfunction registerRenderCounter(name, val) {\n    let counters = renderCounterRegistry.get(name);\n    if (counters == null) {\n        counters = new Set();\n        renderCounterRegistry.set(name, counters);\n    }\n    counters.add(val);\n}\nfunction removeRenderCounter(name, val) {\n    const counters = renderCounterRegistry.get(name);\n    if (counters == null) {\n        return;\n    }\n    counters.delete(val);\n}\nfunction useRenderCounter(name) {\n    const val = useRef(null);\n    if (val.current != null) {\n        val.current.count += 1;\n    }\n    useEffect(()=>{\n        if (val.current == null) {\n            const counter = {\n                count: 0\n            };\n            registerRenderCounter(name, counter);\n            val.current = counter;\n        }\n        return ()=>{\n            if (val.current !== null) {\n                removeRenderCounter(name, val.current);\n            }\n        };\n    });\n}\nconst seenErrors = new Set();\nfunction $structuralCheck(oldValue, newValue, variableName, fnName, kind, loc) {\n    function error(l, r, path, depth) {\n        const str = `${fnName}:${loc} [${kind}] ${variableName}${path} changed from ${l} to ${r} at depth ${depth}`;\n        if (seenErrors.has(str)) {\n            return;\n        }\n        seenErrors.add(str);\n        console.error(str);\n    }\n    const depthLimit = 2;\n    function recur(oldValue, newValue, path, depth) {\n        if (depth > depthLimit) {\n            return;\n        } else if (oldValue === newValue) {\n            return;\n        } else if (typeof oldValue !== typeof newValue) {\n            error(`type ${typeof oldValue}`, `type ${typeof newValue}`, path, depth);\n        } else if (typeof oldValue === \"object\") {\n            const oldArray = Array.isArray(oldValue);\n            const newArray = Array.isArray(newValue);\n            if (oldValue === null && newValue !== null) {\n                error(\"null\", `type ${typeof newValue}`, path, depth);\n            } else if (newValue === null) {\n                error(`type ${typeof oldValue}`, \"null\", path, depth);\n            } else if (oldValue instanceof Map) {\n                if (!(newValue instanceof Map)) {\n                    error(`Map instance`, `other value`, path, depth);\n                } else if (oldValue.size !== newValue.size) {\n                    error(`Map instance with size ${oldValue.size}`, `Map instance with size ${newValue.size}`, path, depth);\n                } else {\n                    for (const [k, v] of oldValue){\n                        if (!newValue.has(k)) {\n                            error(`Map instance with key ${k}`, `Map instance without key ${k}`, path, depth);\n                        } else {\n                            recur(v, newValue.get(k), `${path}.get(${k})`, depth + 1);\n                        }\n                    }\n                }\n            } else if (newValue instanceof Map) {\n                error(\"other value\", `Map instance`, path, depth);\n            } else if (oldValue instanceof Set) {\n                if (!(newValue instanceof Set)) {\n                    error(`Set instance`, `other value`, path, depth);\n                } else if (oldValue.size !== newValue.size) {\n                    error(`Set instance with size ${oldValue.size}`, `Set instance with size ${newValue.size}`, path, depth);\n                } else {\n                    for (const v of newValue){\n                        if (!oldValue.has(v)) {\n                            error(`Set instance without element ${v}`, `Set instance with element ${v}`, path, depth);\n                        }\n                    }\n                }\n            } else if (newValue instanceof Set) {\n                error(\"other value\", `Set instance`, path, depth);\n            } else if (oldArray || newArray) {\n                if (oldArray !== newArray) {\n                    error(`type ${oldArray ? \"array\" : \"object\"}`, `type ${newArray ? \"array\" : \"object\"}`, path, depth);\n                } else if (oldValue.length !== newValue.length) {\n                    error(`array with length ${oldValue.length}`, `array with length ${newValue.length}`, path, depth);\n                } else {\n                    for(let ii = 0; ii < oldValue.length; ii++){\n                        recur(oldValue[ii], newValue[ii], `${path}[${ii}]`, depth + 1);\n                    }\n                }\n            } else if (isValidElement(oldValue) || isValidElement(newValue)) {\n                if (isValidElement(oldValue) !== isValidElement(newValue)) {\n                    error(`type ${isValidElement(oldValue) ? \"React element\" : \"object\"}`, `type ${isValidElement(newValue) ? \"React element\" : \"object\"}`, path, depth);\n                } else if (oldValue.type !== newValue.type) {\n                    error(`React element of type ${oldValue.type}`, `React element of type ${newValue.type}`, path, depth);\n                } else {\n                    recur(oldValue.props, newValue.props, `[props of ${path}]`, depth + 1);\n                }\n            } else {\n                for(const key in newValue){\n                    if (!(key in oldValue)) {\n                        error(`object without key ${key}`, `object with key ${key}`, path, depth);\n                    }\n                }\n                for(const key in oldValue){\n                    if (!(key in newValue)) {\n                        error(`object with key ${key}`, `object without key ${key}`, path, depth);\n                    } else {\n                        recur(oldValue[key], newValue[key], `${path}.${key}`, depth + 1);\n                    }\n                }\n            }\n        } else if (typeof oldValue === \"function\") {\n            return;\n        } else if (isNaN(oldValue) || isNaN(newValue)) {\n            if (isNaN(oldValue) !== isNaN(newValue)) {\n                error(`${isNaN(oldValue) ? \"NaN\" : \"non-NaN value\"}`, `${isNaN(newValue) ? \"NaN\" : \"non-NaN value\"}`, path, depth);\n            }\n        } else if (oldValue !== newValue) {\n            error(oldValue, newValue, path, depth);\n        }\n    }\n    recur(oldValue, newValue, \"\", 0);\n}\nexports.$dispatcherGuard = $dispatcherGuard;\nexports.$makeReadOnly = $makeReadOnly;\nexports.$reset = $reset;\nexports.$structuralCheck = $structuralCheck;\nexports.c = c;\nexports.clearRenderCounterRegistry = clearRenderCounterRegistry;\nexports.renderCounterRegistry = renderCounterRegistry;\nexports.useRenderCounter = useRenderCounter; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3JlYWN0LWNvbXBpbGVyLXJ1bnRpbWUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUVEO0FBQWM7QUFFZCxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQixTQUFTQyx5QkFBeUJDLENBQUM7SUFDL0IsSUFBSUMsSUFBSUMsT0FBT0MsTUFBTSxDQUFDO0lBQ3RCLElBQUlILEdBQUc7UUFDSEUsT0FBT0UsSUFBSSxDQUFDSixHQUFHSyxPQUFPLENBQUMsU0FBVUMsQ0FBQztZQUM5QixJQUFJQSxNQUFNLFdBQVc7Z0JBQ2pCLElBQUlDLElBQUlMLE9BQU9NLHdCQUF3QixDQUFDUixHQUFHTTtnQkFDM0NKLE9BQU9PLGNBQWMsQ0FBQ1IsR0FBR0ssR0FBR0MsRUFBRUcsR0FBRyxHQUFHSCxJQUFJO29CQUNwQ0ksWUFBWTtvQkFDWkQsS0FBSzt3QkFBYyxPQUFPVixDQUFDLENBQUNNLEVBQUU7b0JBQUU7Z0JBQ3BDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FMLEVBQUVXLE9BQU8sR0FBR1o7SUFDWixPQUFPRSxPQUFPVyxNQUFNLENBQUNaO0FBQ3pCO0FBRUEsSUFBSWEsbUJBQW1CLFdBQVcsR0FBRWYseUJBQXlCRjtBQUU3RCxJQUFJa0IsSUFBSUM7QUFDUixNQUFNLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxjQUFjLEVBQUUsR0FBR0w7QUFDOUMsTUFBTU0sdUJBQXVCLENBQUNMLEtBQUtELGlCQUFpQk8sK0RBQStELE1BQU0sUUFBUU4sT0FBTyxLQUFLLElBQUlBLEtBQUtELGlCQUFpQlEsa0RBQWtEO0FBQ3pOLE1BQU1DLFNBQVNDLE9BQU9DLEdBQUcsQ0FBQztBQUMxQixNQUFNQyxJQUFJLE9BQVEsRUFBQ1YsS0FBS0YsaUJBQWlCYSxrQkFBa0IsTUFBTSxRQUFRWCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdB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QUFFLENBQUMsbUJBQW1CLEVBQUVBLElBQUksQ0FBQyxFQUFFYixNQUFNQztvQkFDdkUsT0FDSzt3QkFDREssTUFBTWQsUUFBUSxDQUFDcUIsSUFBSSxFQUFFcEIsUUFBUSxDQUFDb0IsSUFBSSxFQUFFLENBQUMsRUFBRWIsS0FBSyxDQUFDLEVBQUVhLElBQUksQ0FBQyxFQUFFWixRQUFRO29CQUNsRTtnQkFDSjtZQUNKO1FBQ0osT0FDSyxJQUFJLE9BQU9ULGFBQWEsWUFBWTtZQUNyQztRQUNKLE9BQ0ssSUFBSXNCLE1BQU10QixhQUFhc0IsTUFBTXJCLFdBQVc7WUFDekMsSUFBSXFCLE1BQU10QixjQUFjc0IsTUFBTXJCLFdBQVc7Z0JBQ3JDSSxNQUFNLENBQUMsRUFBRWlCLE1BQU10QixZQUFZLFFBQVEsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLEVBQUVzQixNQUFNckIsWUFBWSxRQUFRLGdCQUFnQixDQUFDLEVBQUVPLE1BQU1DO1lBQ2hIO1FBQ0osT0FDSyxJQUFJVCxhQUFhQyxVQUFVO1lBQzVCSSxNQUFNTCxVQUFVQyxVQUFVTyxNQUFNQztRQUNwQztJQUNKO0lBQ0FLLE1BQU1kLFVBQVVDLFVBQVUsSUFBSTtBQUNsQztBQUVBc0Isd0JBQXdCLEdBQUdwRDtBQUMzQm9ELHFCQUFxQixHQUFHeEM7QUFDeEJ3QyxjQUFjLEdBQUd6QztBQUNqQnlDLHdCQUF3QixHQUFHeEI7QUFDM0J3QixTQUFTLEdBQUd2RTtBQUNadUUsa0NBQWtDLEdBQUdyQztBQUNyQ3FDLDZCQUE2QixHQUFHdkM7QUFDaEN1Qyx3QkFBd0IsR0FBRzFCLGtCQUMzQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9ub2RlX21vZHVsZXMvcmVhY3QtY29tcGlsZXItcnVudGltZS9kaXN0L2luZGV4LmpzPzJmNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWdodFN5bnRheFRyYW5zZm9ybVxuICogQG5vZmxvd1xuICogQG5vbGludFxuICogQHByZXZlbnRNdW5nZVxuICogQHByZXNlcnZlLWludmFyaWFudC1tZXNzYWdlc1xuICovXG5cblwidXNlIG5vIG1lbW9cIjsndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuLmRlZmF1bHQgPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoUmVhY3QpO1xuXG52YXIgX2EsIF9iO1xuY29uc3QgeyB1c2VSZWYsIHVzZUVmZmVjdCwgaXNWYWxpZEVsZW1lbnQgfSA9IFJlYWN0X19uYW1lc3BhY2U7XG5jb25zdCBSZWFjdFNlY3JldEludGVybmFscyA9IChfYSA9IFJlYWN0X19uYW1lc3BhY2UuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBSZWFjdF9fbmFtZXNwYWNlLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuY29uc3QgJGVtcHR5ID0gU3ltYm9sLmZvcigncmVhY3QubWVtb19jYWNoZV9zZW50aW5lbCcpO1xuY29uc3QgYyA9IHR5cGVvZiAoKF9iID0gUmVhY3RfX25hbWVzcGFjZS5fX0NPTVBJTEVSX1JVTlRJTUUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jKSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID9cbiAgICAgICAgUmVhY3RfX25hbWVzcGFjZS5fX0NPTVBJTEVSX1JVTlRJTUUuY1xuICAgIDogZnVuY3Rpb24gYyhzaXplKSB7XG4gICAgICAgIHJldHVybiBSZWFjdF9fbmFtZXNwYWNlLnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgJCA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBzaXplOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgJFtpaV0gPSAkZW1wdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkWyRlbXB0eV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuICQ7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9O1xuY29uc3QgTGF6eUd1YXJkRGlzcGF0Y2hlciA9IHt9O1xuW1xuICAgICdyZWFkQ29udGV4dCcsXG4gICAgJ3VzZUNhbGxiYWNrJyxcbiAgICAndXNlQ29udGV4dCcsXG4gICAgJ3VzZUVmZmVjdCcsXG4gICAgJ3VzZUltcGVyYXRpdmVIYW5kbGUnLFxuICAgICd1c2VJbnNlcnRpb25FZmZlY3QnLFxuICAgICd1c2VMYXlvdXRFZmZlY3QnLFxuICAgICd1c2VNZW1vJyxcbiAgICAndXNlUmVkdWNlcicsXG4gICAgJ3VzZVJlZicsXG4gICAgJ3VzZVN0YXRlJyxcbiAgICAndXNlRGVidWdWYWx1ZScsXG4gICAgJ3VzZURlZmVycmVkVmFsdWUnLFxuICAgICd1c2VUcmFuc2l0aW9uJyxcbiAgICAndXNlTXV0YWJsZVNvdXJjZScsXG4gICAgJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJyxcbiAgICAndXNlSWQnLFxuICAgICd1bnN0YWJsZV9pc05ld1JlY29uY2lsZXInLFxuICAgICdnZXRDYWNoZVNpZ25hbCcsXG4gICAgJ2dldENhY2hlRm9yVHlwZScsXG4gICAgJ3VzZUNhY2hlUmVmcmVzaCcsXG5dLmZvckVhY2gobmFtZSA9PiB7XG4gICAgTGF6eUd1YXJkRGlzcGF0Y2hlcltuYW1lXSA9ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbUmVhY3RdIFVuZXhwZWN0ZWQgUmVhY3QgaG9vayBjYWxsICgke25hbWV9KSBmcm9tIGEgUmVhY3QgY29tcGlsZWQgZnVuY3Rpb24uIGAgK1xuICAgICAgICAgICAgXCJDaGVjayB0aGF0IGFsbCBob29rcyBhcmUgY2FsbGVkIGRpcmVjdGx5IGFuZCBuYW1lZCBhY2NvcmRpbmcgdG8gY29udmVudGlvbiAoJ3VzZVtBLVpdJykgXCIpO1xuICAgIH07XG59KTtcbmxldCBvcmlnaW5hbERpc3BhdGNoZXIgPSBudWxsO1xuTGF6eUd1YXJkRGlzcGF0Y2hlclsndXNlTWVtb0NhY2hlJ10gPSAoY291bnQpID0+IHtcbiAgICBpZiAob3JpZ2luYWxEaXNwYXRjaGVyID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBDb21waWxlciBpbnRlcm5hbCBpbnZhcmlhbnQgdmlvbGF0aW9uOiB1bmV4cGVjdGVkIG51bGwgZGlzcGF0Y2hlcicpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRGlzcGF0Y2hlci51c2VNZW1vQ2FjaGUoY291bnQpO1xuICAgIH1cbn07XG52YXIgR3VhcmRLaW5kO1xuKGZ1bmN0aW9uIChHdWFyZEtpbmQpIHtcbiAgICBHdWFyZEtpbmRbR3VhcmRLaW5kW1wiUHVzaEd1YXJkQ29udGV4dFwiXSA9IDBdID0gXCJQdXNoR3VhcmRDb250ZXh0XCI7XG4gICAgR3VhcmRLaW5kW0d1YXJkS2luZFtcIlBvcEd1YXJkQ29udGV4dFwiXSA9IDFdID0gXCJQb3BHdWFyZENvbnRleHRcIjtcbiAgICBHdWFyZEtpbmRbR3VhcmRLaW5kW1wiUHVzaEV4cGVjdEhvb2tcIl0gPSAyXSA9IFwiUHVzaEV4cGVjdEhvb2tcIjtcbiAgICBHdWFyZEtpbmRbR3VhcmRLaW5kW1wiUG9wRXhwZWN0SG9va1wiXSA9IDNdID0gXCJQb3BFeHBlY3RIb29rXCI7XG59KShHdWFyZEtpbmQgfHwgKEd1YXJkS2luZCA9IHt9KSk7XG5mdW5jdGlvbiBzZXRDdXJyZW50KG5ld0Rpc3BhdGNoZXIpIHtcbiAgICBSZWFjdFNlY3JldEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBuZXdEaXNwYXRjaGVyO1xuICAgIHJldHVybiBSZWFjdFNlY3JldEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG59XG5jb25zdCBndWFyZEZyYW1lcyA9IFtdO1xuZnVuY3Rpb24gJGRpc3BhdGNoZXJHdWFyZChraW5kKSB7XG4gICAgY29uc3QgY3VyciA9IFJlYWN0U2VjcmV0SW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgICBpZiAoa2luZCA9PT0gR3VhcmRLaW5kLlB1c2hHdWFyZENvbnRleHQpIHtcbiAgICAgICAgZ3VhcmRGcmFtZXMucHVzaChjdXJyKTtcbiAgICAgICAgaWYgKGd1YXJkRnJhbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgb3JpZ2luYWxEaXNwYXRjaGVyID0gY3VycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyciA9PT0gTGF6eUd1YXJkRGlzcGF0Y2hlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbUmVhY3RdIFVuZXhwZWN0ZWQgY2FsbCB0byBjdXN0b20gaG9vayBvciBjb21wb25lbnQgZnJvbSBhIFJlYWN0IGNvbXBpbGVkIGZ1bmN0aW9uLiBgICtcbiAgICAgICAgICAgICAgICBcIkNoZWNrIHRoYXQgKDEpIGFsbCBob29rcyBhcmUgY2FsbGVkIGRpcmVjdGx5IGFuZCBuYW1lZCBhY2NvcmRpbmcgdG8gY29udmVudGlvbiAoJ3VzZVtBLVpdJykgXCIgK1xuICAgICAgICAgICAgICAgICdhbmQgKDIpIGNvbXBvbmVudHMgYXJlIHJldHVybmVkIGFzIEpTWCBpbnN0ZWFkIG9mIGJlaW5nIGRpcmVjdGx5IGludm9rZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q3VycmVudChMYXp5R3VhcmREaXNwYXRjaGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2luZCA9PT0gR3VhcmRLaW5kLlBvcEd1YXJkQ29udGV4dCkge1xuICAgICAgICBjb25zdCBsYXN0RnJhbWUgPSBndWFyZEZyYW1lcy5wb3AoKTtcbiAgICAgICAgaWYgKGxhc3RGcmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBpbGVyIGludGVybmFsIGVycm9yOiB1bmV4cGVjdGVkIG51bGwgaW4gZ3VhcmQgc3RhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3VhcmRGcmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBvcmlnaW5hbERpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNldEN1cnJlbnQobGFzdEZyYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2luZCA9PT0gR3VhcmRLaW5kLlB1c2hFeHBlY3RIb29rKSB7XG4gICAgICAgIGd1YXJkRnJhbWVzLnB1c2goY3Vycik7XG4gICAgICAgIHNldEN1cnJlbnQob3JpZ2luYWxEaXNwYXRjaGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoa2luZCA9PT0gR3VhcmRLaW5kLlBvcEV4cGVjdEhvb2spIHtcbiAgICAgICAgY29uc3QgbGFzdEZyYW1lID0gZ3VhcmRGcmFtZXMucG9wKCk7XG4gICAgICAgIGlmIChsYXN0RnJhbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBDb21waWxlciBpbnRlcm5hbCBlcnJvcjogdW5leHBlY3RlZCBudWxsIGluIGd1YXJkIHN0YWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q3VycmVudChsYXN0RnJhbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBDb21waWxlciBpbnRlcm5hbCBlcnJvcjogdW5yZWFjaGFibGUgYmxvY2snICsga2luZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gJHJlc2V0KCQpIHtcbiAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgJC5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgJFtpaV0gPSAkZW1wdHk7XG4gICAgfVxufVxuZnVuY3Rpb24gJG1ha2VSZWFkT25seSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RPRE86IGltcGxlbWVudCAkbWFrZVJlYWRPbmx5IGluIHJlYWN0LWNvbXBpbGVyLXJ1bnRpbWUnKTtcbn1cbmNvbnN0IHJlbmRlckNvdW50ZXJSZWdpc3RyeSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGNsZWFyUmVuZGVyQ291bnRlclJlZ2lzdHJ5KCkge1xuICAgIGZvciAoY29uc3QgY291bnRlcnMgb2YgcmVuZGVyQ291bnRlclJlZ2lzdHJ5LnZhbHVlcygpKSB7XG4gICAgICAgIGNvdW50ZXJzLmZvckVhY2goY291bnRlciA9PiB7XG4gICAgICAgICAgICBjb3VudGVyLmNvdW50ID0gMDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJSZW5kZXJDb3VudGVyKG5hbWUsIHZhbCkge1xuICAgIGxldCBjb3VudGVycyA9IHJlbmRlckNvdW50ZXJSZWdpc3RyeS5nZXQobmFtZSk7XG4gICAgaWYgKGNvdW50ZXJzID09IG51bGwpIHtcbiAgICAgICAgY291bnRlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHJlbmRlckNvdW50ZXJSZWdpc3RyeS5zZXQobmFtZSwgY291bnRlcnMpO1xuICAgIH1cbiAgICBjb3VudGVycy5hZGQodmFsKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJlbmRlckNvdW50ZXIobmFtZSwgdmFsKSB7XG4gICAgY29uc3QgY291bnRlcnMgPSByZW5kZXJDb3VudGVyUmVnaXN0cnkuZ2V0KG5hbWUpO1xuICAgIGlmIChjb3VudGVycyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY291bnRlcnMuZGVsZXRlKHZhbCk7XG59XG5mdW5jdGlvbiB1c2VSZW5kZXJDb3VudGVyKG5hbWUpIHtcbiAgICBjb25zdCB2YWwgPSB1c2VSZWYobnVsbCk7XG4gICAgaWYgKHZhbC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgdmFsLmN1cnJlbnQuY291bnQgKz0gMTtcbiAgICB9XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHZhbC5jdXJyZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXIgPSB7IGNvdW50OiAwIH07XG4gICAgICAgICAgICByZWdpc3RlclJlbmRlckNvdW50ZXIobmFtZSwgY291bnRlcik7XG4gICAgICAgICAgICB2YWwuY3VycmVudCA9IGNvdW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWwuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZVJlbmRlckNvdW50ZXIobmFtZSwgdmFsLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuY29uc3Qgc2VlbkVycm9ycyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uICRzdHJ1Y3R1cmFsQ2hlY2sob2xkVmFsdWUsIG5ld1ZhbHVlLCB2YXJpYWJsZU5hbWUsIGZuTmFtZSwga2luZCwgbG9jKSB7XG4gICAgZnVuY3Rpb24gZXJyb3IobCwgciwgcGF0aCwgZGVwdGgpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gYCR7Zm5OYW1lfToke2xvY30gWyR7a2luZH1dICR7dmFyaWFibGVOYW1lfSR7cGF0aH0gY2hhbmdlZCBmcm9tICR7bH0gdG8gJHtyfSBhdCBkZXB0aCAke2RlcHRofWA7XG4gICAgICAgIGlmIChzZWVuRXJyb3JzLmhhcyhzdHIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VlbkVycm9ycy5hZGQoc3RyKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihzdHIpO1xuICAgIH1cbiAgICBjb25zdCBkZXB0aExpbWl0ID0gMjtcbiAgICBmdW5jdGlvbiByZWN1cihvbGRWYWx1ZSwgbmV3VmFsdWUsIHBhdGgsIGRlcHRoKSB7XG4gICAgICAgIGlmIChkZXB0aCA+IGRlcHRoTGltaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGRWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2xkVmFsdWUgIT09IHR5cGVvZiBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZXJyb3IoYHR5cGUgJHt0eXBlb2Ygb2xkVmFsdWV9YCwgYHR5cGUgJHt0eXBlb2YgbmV3VmFsdWV9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvbGRWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZEFycmF5ID0gQXJyYXkuaXNBcnJheShvbGRWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBuZXdBcnJheSA9IEFycmF5LmlzQXJyYXkobmV3VmFsdWUpO1xuICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09PSBudWxsICYmIG5ld1ZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ251bGwnLCBgdHlwZSAke3R5cGVvZiBuZXdWYWx1ZX1gLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVycm9yKGB0eXBlICR7dHlwZW9mIG9sZFZhbHVlfWAsICdudWxsJywgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIShuZXdWYWx1ZSBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoYE1hcCBpbnN0YW5jZWAsIGBvdGhlciB2YWx1ZWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUuc2l6ZSAhPT0gbmV3VmFsdWUuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgTWFwIGluc3RhbmNlIHdpdGggc2l6ZSAke29sZFZhbHVlLnNpemV9YCwgYE1hcCBpbnN0YW5jZSB3aXRoIHNpemUgJHtuZXdWYWx1ZS5zaXplfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1ZhbHVlLmhhcyhrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKGBNYXAgaW5zdGFuY2Ugd2l0aCBrZXkgJHtrfWAsIGBNYXAgaW5zdGFuY2Ugd2l0aG91dCBrZXkgJHtrfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3VyKHYsIG5ld1ZhbHVlLmdldChrKSwgYCR7cGF0aH0uZ2V0KCR7a30pYCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ290aGVyIHZhbHVlJywgYE1hcCBpbnN0YW5jZWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZFZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEobmV3VmFsdWUgaW5zdGFuY2VvZiBTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGBTZXQgaW5zdGFuY2VgLCBgb3RoZXIgdmFsdWVgLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9sZFZhbHVlLnNpemUgIT09IG5ld1ZhbHVlLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoYFNldCBpbnN0YW5jZSB3aXRoIHNpemUgJHtvbGRWYWx1ZS5zaXplfWAsIGBTZXQgaW5zdGFuY2Ugd2l0aCBzaXplICR7bmV3VmFsdWUuc2l6ZX1gLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkVmFsdWUuaGFzKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoYFNldCBpbnN0YW5jZSB3aXRob3V0IGVsZW1lbnQgJHt2fWAsIGBTZXQgaW5zdGFuY2Ugd2l0aCBlbGVtZW50ICR7dn1gLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdvdGhlciB2YWx1ZScsIGBTZXQgaW5zdGFuY2VgLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvbGRBcnJheSB8fCBuZXdBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRBcnJheSAhPT0gbmV3QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoYHR5cGUgJHtvbGRBcnJheSA/ICdhcnJheScgOiAnb2JqZWN0J31gLCBgdHlwZSAke25ld0FycmF5ID8gJ2FycmF5JyA6ICdvYmplY3QnfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUubGVuZ3RoICE9PSBuZXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoYGFycmF5IHdpdGggbGVuZ3RoICR7b2xkVmFsdWUubGVuZ3RofWAsIGBhcnJheSB3aXRoIGxlbmd0aCAke25ld1ZhbHVlLmxlbmd0aH1gLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgb2xkVmFsdWUubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cihvbGRWYWx1ZVtpaV0sIG5ld1ZhbHVlW2lpXSwgYCR7cGF0aH1bJHtpaX1dYCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG9sZFZhbHVlKSB8fCBpc1ZhbGlkRWxlbWVudChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQob2xkVmFsdWUpICE9PSBpc1ZhbGlkRWxlbWVudChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoYHR5cGUgJHtpc1ZhbGlkRWxlbWVudChvbGRWYWx1ZSkgPyAnUmVhY3QgZWxlbWVudCcgOiAnb2JqZWN0J31gLCBgdHlwZSAke2lzVmFsaWRFbGVtZW50KG5ld1ZhbHVlKSA/ICdSZWFjdCBlbGVtZW50JyA6ICdvYmplY3QnfWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2xkVmFsdWUudHlwZSAhPT0gbmV3VmFsdWUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihgUmVhY3QgZWxlbWVudCBvZiB0eXBlICR7b2xkVmFsdWUudHlwZX1gLCBgUmVhY3QgZWxlbWVudCBvZiB0eXBlICR7bmV3VmFsdWUudHlwZX1gLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWN1cihvbGRWYWx1ZS5wcm9wcywgbmV3VmFsdWUucHJvcHMsIGBbcHJvcHMgb2YgJHtwYXRofV1gLCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKGBvYmplY3Qgd2l0aG91dCBrZXkgJHtrZXl9YCwgYG9iamVjdCB3aXRoIGtleSAke2tleX1gLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoYG9iamVjdCB3aXRoIGtleSAke2tleX1gLCBgb2JqZWN0IHdpdGhvdXQga2V5ICR7a2V5fWAsIHBhdGgsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3VyKG9sZFZhbHVlW2tleV0sIG5ld1ZhbHVlW2tleV0sIGAke3BhdGh9LiR7a2V5fWAsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9sZFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOYU4ob2xkVmFsdWUpIHx8IGlzTmFOKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKG9sZFZhbHVlKSAhPT0gaXNOYU4obmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoYCR7aXNOYU4ob2xkVmFsdWUpID8gJ05hTicgOiAnbm9uLU5hTiB2YWx1ZSd9YCwgYCR7aXNOYU4obmV3VmFsdWUpID8gJ05hTicgOiAnbm9uLU5hTiB2YWx1ZSd9YCwgcGF0aCwgZGVwdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZXJyb3Iob2xkVmFsdWUsIG5ld1ZhbHVlLCBwYXRoLCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjdXIob2xkVmFsdWUsIG5ld1ZhbHVlLCAnJywgMCk7XG59XG5cbmV4cG9ydHMuJGRpc3BhdGNoZXJHdWFyZCA9ICRkaXNwYXRjaGVyR3VhcmQ7XG5leHBvcnRzLiRtYWtlUmVhZE9ubHkgPSAkbWFrZVJlYWRPbmx5O1xuZXhwb3J0cy4kcmVzZXQgPSAkcmVzZXQ7XG5leHBvcnRzLiRzdHJ1Y3R1cmFsQ2hlY2sgPSAkc3RydWN0dXJhbENoZWNrO1xuZXhwb3J0cy5jID0gYztcbmV4cG9ydHMuY2xlYXJSZW5kZXJDb3VudGVyUmVnaXN0cnkgPSBjbGVhclJlbmRlckNvdW50ZXJSZWdpc3RyeTtcbmV4cG9ydHMucmVuZGVyQ291bnRlclJlZ2lzdHJ5ID0gcmVuZGVyQ291bnRlclJlZ2lzdHJ5O1xuZXhwb3J0cy51c2VSZW5kZXJDb3VudGVyID0gdXNlUmVuZGVyQ291bnRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwicmVxdWlyZSIsIl9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdCIsImUiLCJuIiwiT2JqZWN0IiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImRlZmF1bHQiLCJmcmVlemUiLCJSZWFjdF9fbmFtZXNwYWNlIiwiX2EiLCJfYiIsInVzZVJlZiIsInVzZUVmZmVjdCIsImlzVmFsaWRFbGVtZW50IiwiUmVhY3RTZWNyZXRJbnRlcm5hbHMiLCJfX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIiRlbXB0eSIsIlN5bWJvbCIsImZvciIsImMiLCJfX0NPTVBJTEVSX1JVTlRJTUUiLCJzaXplIiwidXNlTWVtbyIsIiQiLCJBcnJheSIsImlpIiwiTGF6eUd1YXJkRGlzcGF0Y2hlciIsIm5hbWUiLCJFcnJvciIsIm9yaWdpbmFsRGlzcGF0Y2hlciIsImNvdW50IiwidXNlTWVtb0NhY2hlIiwiR3VhcmRLaW5kIiwic2V0Q3VycmVudCIsIm5ld0Rpc3BhdGNoZXIiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyIiwiY3VycmVudCIsImd1YXJkRnJhbWVzIiwiJGRpc3BhdGNoZXJHdWFyZCIsImtpbmQiLCJjdXJyIiwiUHVzaEd1YXJkQ29udGV4dCIsInB1c2giLCJsZW5ndGgiLCJQb3BHdWFyZENvbnRleHQiLCJsYXN0RnJhbWUiLCJwb3AiLCJQdXNoRXhwZWN0SG9vayIsIlBvcEV4cGVjdEhvb2siLCIkcmVzZXQiLCIkbWFrZVJlYWRPbmx5IiwicmVuZGVyQ291bnRlclJlZ2lzdHJ5IiwiTWFwIiwiY2xlYXJSZW5kZXJDb3VudGVyUmVnaXN0cnkiLCJjb3VudGVycyIsInZhbHVlcyIsImNvdW50ZXIiLCJyZWdpc3RlclJlbmRlckNvdW50ZXIiLCJ2YWwiLCJTZXQiLCJzZXQiLCJhZGQiLCJyZW1vdmVSZW5kZXJDb3VudGVyIiwiZGVsZXRlIiwidXNlUmVuZGVyQ291bnRlciIsInNlZW5FcnJvcnMiLCIkc3RydWN0dXJhbENoZWNrIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsInZhcmlhYmxlTmFtZSIsImZuTmFtZSIsImxvYyIsImVycm9yIiwibCIsInIiLCJwYXRoIiwiZGVwdGgiLCJzdHIiLCJoYXMiLCJjb25zb2xlIiwiZGVwdGhMaW1pdCIsInJlY3VyIiwib2xkQXJyYXkiLCJpc0FycmF5IiwibmV3QXJyYXkiLCJ2IiwidHlwZSIsInByb3BzIiwia2V5IiwiaXNOYU4iLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/node_modules/react-compiler-runtime/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/node_modules/slate-react/dist/index.es.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/node_modules/slate-react/dist/index.es.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultElement: () => (/* binding */ DefaultElement),\n/* harmony export */   DefaultLeaf: () => (/* binding */ DefaultLeaf),\n/* harmony export */   DefaultPlaceholder: () => (/* binding */ DefaultPlaceholder),\n/* harmony export */   Editable: () => (/* binding */ Editable),\n/* harmony export */   NODE_TO_INDEX: () => (/* reexport safe */ slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX),\n/* harmony export */   NODE_TO_PARENT: () => (/* reexport safe */ slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT),\n/* harmony export */   ReactEditor: () => (/* binding */ ReactEditor),\n/* harmony export */   Slate: () => (/* binding */ Slate),\n/* harmony export */   useComposing: () => (/* binding */ useComposing),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useFocused: () => (/* binding */ useFocused),\n/* harmony export */   useReadOnly: () => (/* binding */ useReadOnly),\n/* harmony export */   useSelected: () => (/* binding */ useSelected),\n/* harmony export */   useSlate: () => (/* binding */ useSlate),\n/* harmony export */   useSlateSelection: () => (/* binding */ useSlateSelection),\n/* harmony export */   useSlateSelector: () => (/* binding */ useSlateSelector),\n/* harmony export */   useSlateStatic: () => (/* binding */ useSlateStatic),\n/* harmony export */   useSlateWithV: () => (/* binding */ useSlateWithV),\n/* harmony export */   withReact: () => (/* binding */ withReact)\n/* harmony export */ });\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! direction */ \"(ssr)/./node_modules/direction/index.js\");\n/* harmony import */ var direction__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(direction__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/debounce */ \"(ssr)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/throttle */ \"(ssr)/./node_modules/lodash/throttle.js\");\n/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! scroll-into-view-if-needed */ \"(ssr)/./node_modules/scroll-into-view-if-needed/dist/index.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! slate-dom */ \"(ssr)/./node_modules/slate-dom/dist/index.es.js\");\n/* harmony import */ var _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @juggle/resize-observer */ \"(ssr)/./node_modules/@juggle/resize-observer/lib/exports/resize-observer.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _toPrimitive(input, hint) {\n    if (_typeof(input) !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n/**\n * A React context for sharing the editor object.\n */ var EditorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\n * Get the current editor object from the React context.\n */ var useSlateStatic = ()=>{\n    var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n    if (!editor) {\n        throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n    }\n    return editor;\n};\n// eslint-disable-next-line no-redeclare\nvar ReactEditor = slate_dom__WEBPACK_IMPORTED_MODULE_4__.DOMEditor;\nfunction ownKeys$5(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$5(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$5(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n// https://github.com/facebook/draft-js/blob/main/src/component/handlers/composition/DraftEditorCompositionHandler.js#L41\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\nvar RESOLVE_DELAY = 25;\n// Time with no user interaction before the current user action is considered as done.\nvar FLUSH_DELAY = 200;\n// Replace with `const debug = console.log` to debug\nvar debug = function debug() {};\n// Type guard to check if a value is a DataTransfer\nvar isDataTransfer = (value)=>(value === null || value === void 0 ? void 0 : value.constructor.name) === \"DataTransfer\";\nfunction createAndroidInputManager(_ref) {\n    var { editor, scheduleOnDOMSelectionChange, onDOMSelectionChange } = _ref;\n    var flushing = false;\n    var compositionEndTimeoutId = null;\n    var flushTimeoutId = null;\n    var actionTimeoutId = null;\n    var idCounter = 0;\n    var insertPositionHint = false;\n    var applyPendingSelection = ()=>{\n        var pendingSelection = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.get(editor);\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.delete(editor);\n        if (pendingSelection) {\n            var { selection } = editor;\n            var normalized = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizeRange)(editor, pendingSelection);\n            if (normalized && (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(normalized, selection))) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, normalized);\n            }\n        }\n    };\n    var performAction = ()=>{\n        var action = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.get(editor);\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.delete(editor);\n        if (!action) {\n            return;\n        }\n        if (action.at) {\n            var target = slate__WEBPACK_IMPORTED_MODULE_7__.Point.isPoint(action.at) ? (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizePoint)(editor, action.at) : (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizeRange)(editor, action.at);\n            if (!target) {\n                return;\n            }\n            var _targetRange = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, target);\n            if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, _targetRange)) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, target);\n            }\n        }\n        action.run();\n    };\n    var flush = ()=>{\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        if (actionTimeoutId) {\n            clearTimeout(actionTimeoutId);\n            actionTimeoutId = null;\n        }\n        if (!hasPendingDiffs() && !hasPendingAction()) {\n            applyPendingSelection();\n            return;\n        }\n        if (!flushing) {\n            flushing = true;\n            setTimeout(()=>flushing = false);\n        }\n        if (hasPendingAction()) {\n            flushing = \"action\";\n        }\n        var selectionRef = editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection, {\n            affinity: \"forward\"\n        });\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n        debug(\"flush\", slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.get(editor), slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor));\n        var scheduleSelectionChange = hasPendingDiffs();\n        var diff;\n        while(diff = (_EDITOR_TO_PENDING_DI = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]){\n            var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;\n            var pendingMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n            if (pendingMarks !== undefined) {\n                slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n                editor.marks = pendingMarks;\n            }\n            if (pendingMarks && insertPositionHint === false) {\n                insertPositionHint = null;\n            }\n            var range = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.targetRange)(diff);\n            if (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, range)) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n            }\n            if (diff.diff.text) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, diff.diff.text);\n            } else {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n            }\n            // Remove diff only after we have applied it to account for it when transforming\n            // pending ranges.\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter((_ref2)=>{\n                var { id } = _ref2;\n                return id !== diff.id;\n            }));\n            if (!(0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.verifyDiffState)(editor, diff)) {\n                scheduleSelectionChange = false;\n                slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.delete(editor);\n                slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.delete(editor);\n                flushing = \"action\";\n                // Ensure we don't restore the pending user (dom) selection\n                // since the document and dom state do not match.\n                slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.delete(editor);\n                scheduleOnDOMSelectionChange.cancel();\n                onDOMSelectionChange.cancel();\n                selectionRef === null || selectionRef === void 0 || selectionRef.unref();\n            }\n        }\n        var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n        if (selection && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, editor.selection))) {\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, selection);\n        }\n        if (hasPendingAction()) {\n            performAction();\n            return;\n        }\n        // COMPAT: The selectionChange event is fired after the action is performed,\n        // so we have to manually schedule it to ensure we don't 'throw away' the selection\n        // while rendering if we have pending changes.\n        if (scheduleSelectionChange) {\n            scheduleOnDOMSelectionChange();\n        }\n        scheduleOnDOMSelectionChange.flush();\n        onDOMSelectionChange.flush();\n        applyPendingSelection();\n        var userMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.get(editor);\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.delete(editor);\n        if (userMarks !== undefined) {\n            editor.marks = userMarks;\n            editor.onChange();\n        }\n    };\n    var handleCompositionEnd = (_event)=>{\n        if (compositionEndTimeoutId) {\n            clearTimeout(compositionEndTimeoutId);\n        }\n        compositionEndTimeoutId = setTimeout(()=>{\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n            flush();\n        }, RESOLVE_DELAY);\n    };\n    var handleCompositionStart = (_event)=>{\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, true);\n        if (compositionEndTimeoutId) {\n            clearTimeout(compositionEndTimeoutId);\n            compositionEndTimeoutId = null;\n        }\n    };\n    var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n        var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var placeholderElement = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n        if (!placeholderElement) {\n            return;\n        }\n        if (hasPendingDiffs() || forceHide) {\n            placeholderElement.style.display = \"none\";\n            return;\n        }\n        placeholderElement.style.removeProperty(\"display\");\n    };\n    var storeDiff = (path, diff)=>{\n        var _EDITOR_TO_PENDING_DI3;\n        var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n        var target = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, path);\n        var idx = pendingDiffs.findIndex((change)=>slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n        if (idx < 0) {\n            var normalized = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.normalizeStringDiff)(target.text, diff);\n            if (normalized) {\n                pendingDiffs.push({\n                    path,\n                    diff,\n                    id: idCounter++\n                });\n            }\n            updatePlaceholderVisibility();\n            return;\n        }\n        var merged = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.mergeStringDiffs)(target.text, pendingDiffs[idx].diff, diff);\n        if (!merged) {\n            pendingDiffs.splice(idx, 1);\n            updatePlaceholderVisibility();\n            return;\n        }\n        pendingDiffs[idx] = _objectSpread$5(_objectSpread$5({}, pendingDiffs[idx]), {}, {\n            diff: merged\n        });\n    };\n    var scheduleAction = function scheduleAction(run) {\n        var { at } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        insertPositionHint = false;\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        if (hasPendingAction()) {\n            flush();\n        }\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.set(editor, {\n            at,\n            run\n        });\n        // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n        // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n        // in this case and thus never actually perform the action.\n        actionTimeoutId = setTimeout(flush);\n    };\n    var handleDOMBeforeInput = (event)=>{\n        var _targetRange2;\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n            return;\n        }\n        var { inputType: type } = event;\n        var targetRange = null;\n        var data = event.dataTransfer || event.data || undefined;\n        if (insertPositionHint !== false && type !== \"insertText\" && type !== \"insertCompositionText\") {\n            insertPositionHint = false;\n        }\n        var [nativeTargetRange] = event.getTargetRanges();\n        if (nativeTargetRange) {\n            targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n                exactMatch: false,\n                suppressThrow: true\n            });\n        }\n        // COMPAT: SelectionChange event is fired after the action is performed, so we\n        // have to manually get the selection here to ensure it's up-to-date.\n        var window1 = ReactEditor.getWindow(editor);\n        var domSelection = window1.getSelection();\n        if (!targetRange && domSelection) {\n            nativeTargetRange = domSelection;\n            targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n                exactMatch: false,\n                suppressThrow: true\n            });\n        }\n        targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n        if (!targetRange) {\n            return;\n        }\n        // By default, the input manager tries to store text diffs so that we can\n        // defer flushing them at a later point in time. We don't want to flush\n        // for every input event as this can be expensive. However, there are some\n        // scenarios where we cannot safely store the text diff and must instead\n        // schedule an action to let Slate normalize the editor state.\n        var canStoreDiff = true;\n        if (type.startsWith(\"delete\")) {\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n                var [_start, _end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n                var _leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _start.path);\n                if (_leaf.text.length === _start.offset && _end.offset === 0) {\n                    var next = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.next(editor, {\n                        at: _start.path,\n                        match: slate__WEBPACK_IMPORTED_MODULE_7__.Text.isText\n                    });\n                    if (next && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(next[1], _end.path)) {\n                        targetRange = {\n                            anchor: _end,\n                            focus: _end\n                        };\n                    }\n                }\n            }\n            var direction = type.endsWith(\"Backward\") ? \"backward\" : \"forward\";\n            var [start, end] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n            var [leaf, path] = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.leaf(editor, start.path);\n            var diff = {\n                text: \"\",\n                start: start.offset,\n                end: end.offset\n            };\n            var pendingDiffs = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor);\n            var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((change)=>slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(change.path, path));\n            var diffs = relevantPendingDiffs ? [\n                relevantPendingDiffs.diff,\n                diff\n            ] : [\n                diff\n            ];\n            var text = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.applyStringDiff)(leaf.text, ...diffs);\n            if (text.length === 0) {\n                // Text leaf will be removed, so we need to schedule an\n                // action to remove it so that Slate can normalize instead\n                // of storing as a diff\n                canStoreDiff = false;\n            }\n            if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(targetRange)) {\n                if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n                    var point = {\n                        path: targetRange.anchor.path,\n                        offset: start.offset\n                    };\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, point, point);\n                    handleUserSelect(range);\n                    return storeDiff(targetRange.anchor.path, {\n                        text: \"\",\n                        end: end.offset,\n                        start: start.offset\n                    });\n                }\n                return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                        direction\n                    }), {\n                    at: targetRange\n                });\n            }\n        }\n        switch(type){\n            case \"deleteByComposition\":\n            case \"deleteByCut\":\n            case \"deleteByDrag\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteContent\":\n            case \"deleteContentForward\":\n                {\n                    var { anchor } = targetRange;\n                    if (canStoreDiff && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange)) {\n                        var targetNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n                        if (anchor.offset < targetNode.text.length) {\n                            return storeDiff(anchor.path, {\n                                text: \"\",\n                                start: anchor.offset,\n                                end: anchor.offset + 1\n                            });\n                        }\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteContentBackward\":\n                {\n                    var _nativeTargetRange;\n                    var { anchor: _anchor } = targetRange;\n                    // If we have a mismatch between the native and slate selection being collapsed\n                    // we are most likely deleting a zero-width placeholder and thus should perform it\n                    // as an action to ensure correct behavior (mostly happens with mark placeholders)\n                    var nativeCollapsed = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMSelection)(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n                    if (canStoreDiff && nativeCollapsed && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n                        return storeDiff(_anchor.path, {\n                            text: \"\",\n                            start: _anchor.offset - 1,\n                            end: _anchor.offset\n                        });\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteEntireSoftLine\":\n                {\n                    return scheduleAction(()=>{\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                    }, {\n                        at: targetRange\n                    });\n                }\n            case \"deleteHardLineBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"block\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteSoftLineBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteHardLineForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"block\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteSoftLineForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteWordBackward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"word\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"deleteWordForward\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"word\"\n                        }), {\n                        at: targetRange\n                    });\n                }\n            case \"insertLineBreak\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"insertParagraph\":\n                {\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor), {\n                        at: targetRange\n                    });\n                }\n            case \"insertCompositionText\":\n            case \"deleteCompositionText\":\n            case \"insertFromComposition\":\n            case \"insertFromDrop\":\n            case \"insertFromPaste\":\n            case \"insertFromYank\":\n            case \"insertReplacementText\":\n            case \"insertText\":\n                {\n                    if (isDataTransfer(data)) {\n                        return scheduleAction(()=>ReactEditor.insertData(editor, data), {\n                            at: targetRange\n                        });\n                    }\n                    var _text = data !== null && data !== void 0 ? data : \"\";\n                    // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n                    // the placeholder itself and thus includes the zero-width space inside edit events.\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n                        _text = _text.replace(\"\\uFEFF\", \"\");\n                    }\n                    // Pastes from the Android clipboard will generate `insertText` events.\n                    // If the copied text contains any newlines, Android will append an\n                    // extra newline to the end of the copied text.\n                    if (type === \"insertText\" && /.*\\n.*\\n$/.test(_text)) {\n                        _text = _text.slice(0, -1);\n                    }\n                    // If the text includes a newline, split it at newlines and paste each component\n                    // string, with soft breaks in between each.\n                    if (_text.includes(\"\\n\")) {\n                        return scheduleAction(()=>{\n                            var parts = _text.split(\"\\n\");\n                            parts.forEach((line, i)=>{\n                                if (line) {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, line);\n                                }\n                                if (i !== parts.length - 1) {\n                                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                                }\n                            });\n                        }, {\n                            at: targetRange\n                        });\n                    }\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n                        var [_start2, _end2] = slate__WEBPACK_IMPORTED_MODULE_7__.Range.edges(targetRange);\n                        var _diff = {\n                            start: _start2.offset,\n                            end: _end2.offset,\n                            text: _text\n                        };\n                        // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n                        // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n                        // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n                        // text events are fired with the correct target ranges, only the final 'insertComposition'\n                        // isn't, so we can adjust the target range start offset if we are confident this is the\n                        // swiftkey insert causing the issue.\n                        if (_text && insertPositionHint && type === \"insertCompositionText\") {\n                            var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n                            var diffPosition = _diff.start + _diff.text.search(/\\S|$/);\n                            if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                                _diff.start -= 1;\n                                insertPositionHint = null;\n                                scheduleFlush();\n                            } else {\n                                insertPositionHint = false;\n                            }\n                        } else if (type === \"insertText\") {\n                            if (insertPositionHint === null) {\n                                insertPositionHint = _diff;\n                            } else if (insertPositionHint && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                                insertPositionHint = _objectSpread$5(_objectSpread$5({}, insertPositionHint), {}, {\n                                    text: insertPositionHint.text + _text\n                                });\n                            } else {\n                                insertPositionHint = false;\n                            }\n                        } else {\n                            insertPositionHint = false;\n                        }\n                        if (canStoreDiff) {\n                            storeDiff(_start2.path, _diff);\n                            return;\n                        }\n                    }\n                    return scheduleAction(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text), {\n                        at: targetRange\n                    });\n                }\n        }\n    };\n    var hasPendingAction = ()=>{\n        return !!slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_ACTION.get(editor);\n    };\n    var hasPendingDiffs = ()=>{\n        var _EDITOR_TO_PENDING_DI4;\n        return !!((_EDITOR_TO_PENDING_DI4 = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);\n    };\n    var hasPendingChanges = ()=>{\n        return hasPendingAction() || hasPendingDiffs();\n    };\n    var isFlushing = ()=>{\n        return flushing;\n    };\n    var handleUserSelect = (range)=>{\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_SELECTION.set(editor, range);\n        if (flushTimeoutId) {\n            clearTimeout(flushTimeoutId);\n            flushTimeoutId = null;\n        }\n        var { selection } = editor;\n        if (!range) {\n            return;\n        }\n        var pathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path, range.anchor.path);\n        var parentPathChanged = !selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n        if (pathChanged && insertPositionHint || parentPathChanged) {\n            insertPositionHint = false;\n        }\n        if (pathChanged || hasPendingDiffs()) {\n            flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n        }\n    };\n    var handleInput = ()=>{\n        if (hasPendingAction() || !hasPendingDiffs()) {\n            flush();\n        }\n    };\n    var handleKeyDown = (_)=>{\n        // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n        // directly next to a non-contenteditable element (= the placeholder).\n        // The only event fired soon enough for us to allow hiding the placeholder\n        // without swiftkey picking it up is the keydown event, so we have to hide it\n        // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n        if (!hasPendingDiffs()) {\n            updatePlaceholderVisibility(true);\n            setTimeout(updatePlaceholderVisibility);\n        }\n    };\n    var scheduleFlush = ()=>{\n        if (!hasPendingAction()) {\n            actionTimeoutId = setTimeout(flush);\n        }\n    };\n    var handleDomMutations = (mutations)=>{\n        if (hasPendingDiffs() || hasPendingAction()) {\n            return;\n        }\n        if (mutations.some((mutation)=>(0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isTrackedMutation)(editor, mutation, mutations))) {\n            var _EDITOR_TO_FORCE_REND;\n            // Cause a re-render to restore the dom state if we encounter tracked mutations without\n            // a corresponding pending action.\n            (_EDITOR_TO_FORCE_REND = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 || _EDITOR_TO_FORCE_REND();\n        }\n    };\n    return {\n        flush,\n        scheduleFlush,\n        hasPendingDiffs,\n        hasPendingAction,\n        hasPendingChanges,\n        isFlushing,\n        handleUserSelect,\n        handleCompositionEnd,\n        handleCompositionStart,\n        handleDOMBeforeInput,\n        handleKeyDown,\n        handleDomMutations,\n        handleInput\n    };\n}\nfunction useIsMounted() {\n    var isMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    return isMountedRef.current;\n}\n/**\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\n */ var useIsomorphicLayoutEffect = slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\nfunction useMutationObserver(node, callback, options) {\n    var [mutationObserver] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(()=>new MutationObserver(callback));\n    useIsomorphicLayoutEffect(()=>{\n        // Discard mutations caused during render phase. This works due to react calling\n        // useLayoutEffect synchronously after the render phase before the next tick.\n        mutationObserver.takeRecords();\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (!node.current) {\n            throw new Error(\"Failed to attach MutationObserver, `node` is undefined\");\n        }\n        mutationObserver.observe(node.current, options);\n        return ()=>mutationObserver.disconnect();\n    }, [\n        mutationObserver,\n        node,\n        options\n    ]);\n}\nvar _excluded$2 = [\n    \"node\"\n];\nfunction ownKeys$4(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$4(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$4(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar MUTATION_OBSERVER_CONFIG$1 = {\n    subtree: true,\n    childList: true,\n    characterData: true\n};\nvar useAndroidInputManager = !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID ? ()=>null : (_ref)=>{\n    var { node } = _ref, options = _objectWithoutProperties(_ref, _excluded$2);\n    if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n        return null;\n    }\n    var editor = useSlateStatic();\n    var isMounted = useIsMounted();\n    var [inputManager] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(()=>createAndroidInputManager(_objectSpread$4({\n            editor\n        }, options)));\n    useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG$1);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n    if (isMounted) {\n        inputManager.flush();\n    }\n    return inputManager;\n};\nfunction ownKeys$3(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$3(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$3(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n/**\n * Leaf content strings.\n */ var String$1 = (props)=>{\n    var { isLast, leaf, parent, text } = props;\n    var editor = useSlateStatic();\n    var path = ReactEditor.findPath(editor, text);\n    var parentPath = slate__WEBPACK_IMPORTED_MODULE_7__.Path.parent(path);\n    var isMarkPlaceholder = Boolean(leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.MARK_PLACEHOLDER_SYMBOL]);\n    // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    if (editor.isVoid(parent)) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            length: slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(parent).length\n        });\n    }\n    // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    if (leaf.text === \"\" && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.string(editor, parentPath) === \"\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            isLineBreak: true,\n            isMarkPlaceholder: isMarkPlaceholder\n        });\n    }\n    // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    if (leaf.text === \"\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ZeroWidthString, {\n            isMarkPlaceholder: isMarkPlaceholder\n        });\n    }\n    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    if (isLast && leaf.text.slice(-1) === \"\\n\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n            isTrailing: true,\n            text: leaf.text\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(TextString, {\n        text: leaf.text\n    });\n};\n/**\n * Leaf strings with text in them.\n */ var TextString = (props)=>{\n    var { text, isTrailing = false } = props;\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var getTextContent = ()=>{\n        return \"\".concat(text !== null && text !== void 0 ? text : \"\").concat(isTrailing ? \"\\n\" : \"\");\n    };\n    var [initialText] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(getTextContent);\n    // This is the actual text rendering boundary where we interface with the DOM\n    // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n    // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n    // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n    // exactly if and only if its current content does not match our current virtual DOM.\n    // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n    // eg makes native spellcheck opt out from checking the text node.\n    // useLayoutEffect: updating our span before browser paint\n    useIsomorphicLayoutEffect(()=>{\n        // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n        var textWithTrailing = getTextContent();\n        if (ref.current && ref.current.textContent !== textWithTrailing) {\n            ref.current.textContent = textWithTrailing;\n        }\n    // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n    });\n    // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n    // We defer to the layout effect above to update the `textContent` of the span element when needed.\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText$1, {\n        ref: ref\n    }, initialText);\n};\nvar MemoizedText$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.memo)(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)((props, ref)=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n        \"data-slate-string\": true,\n        ref: ref\n    }, props.children);\n}));\n/**\n * Leaf strings without text, render as zero-width strings.\n */ var ZeroWidthString = (props)=>{\n    var { length = 0, isLineBreak = false, isMarkPlaceholder = false } = props;\n    var attributes = {\n        \"data-slate-zero-width\": isLineBreak ? \"n\" : \"z\",\n        \"data-slate-length\": length\n    };\n    if (isMarkPlaceholder) {\n        attributes[\"data-slate-mark-placeholder\"] = true;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", _objectSpread$3({}, attributes), !(slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_IOS) || !isLineBreak ? \"\\uFEFF\" : null, isLineBreak ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null) : null);\n};\nfunction ownKeys$2(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$2(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n// Delay the placeholder on Android to prevent the keyboard from closing.\n// (https://github.com/ianstormtaylor/slate/pull/5368)\nvar PLACEHOLDER_DELAY = slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID ? 300 : 0;\nfunction disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {\n    if (placeholderResizeObserver.current) {\n        placeholderResizeObserver.current.disconnect();\n        if (releaseObserver) {\n            placeholderResizeObserver.current = null;\n        }\n    }\n}\nfunction clearTimeoutRef(timeoutRef) {\n    if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n    }\n}\n/**\n * Individual leaves in a text node with unique formatting.\n */ var Leaf = (props)=>{\n    var { leaf, isLast, text, parent, renderPlaceholder, renderLeaf = (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultLeaf, _objectSpread$2({}, props)) } = props;\n    var editor = useSlateStatic();\n    var placeholderResizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var placeholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var [showPlaceholder, setShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    var showPlaceholderTimeoutRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var callbackPlaceholderRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((placeholderEl)=>{\n        disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);\n        if (placeholderEl == null) {\n            var _leaf$onPlaceholderRe;\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n            (_leaf$onPlaceholderRe = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 || _leaf$onPlaceholderRe.call(leaf, null);\n        } else {\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n            if (!placeholderResizeObserver.current) {\n                // Create a new observer and observe the placeholder element.\n                var ResizeObserver$1 = window.ResizeObserver || _juggle_resize_observer__WEBPACK_IMPORTED_MODULE_5__.ResizeObserver;\n                placeholderResizeObserver.current = new ResizeObserver$1(()=>{\n                    var _leaf$onPlaceholderRe2;\n                    (_leaf$onPlaceholderRe2 = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 || _leaf$onPlaceholderRe2.call(leaf, placeholderEl);\n                });\n            }\n            placeholderResizeObserver.current.observe(placeholderEl);\n            placeholderRef.current = placeholderEl;\n        }\n    }, [\n        placeholderRef,\n        leaf,\n        editor\n    ]);\n    var children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(String$1, {\n        isLast: isLast,\n        leaf: leaf,\n        parent: parent,\n        text: text\n    });\n    var leafIsPlaceholder = Boolean(leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (leafIsPlaceholder) {\n            if (!showPlaceholderTimeoutRef.current) {\n                // Delay the placeholder, so it will not render in a selection\n                showPlaceholderTimeoutRef.current = setTimeout(()=>{\n                    setShowPlaceholder(true);\n                    showPlaceholderTimeoutRef.current = null;\n                }, PLACEHOLDER_DELAY);\n            }\n        } else {\n            clearTimeoutRef(showPlaceholderTimeoutRef);\n            setShowPlaceholder(false);\n        }\n        return ()=>clearTimeoutRef(showPlaceholderTimeoutRef);\n    }, [\n        leafIsPlaceholder,\n        setShowPlaceholder\n    ]);\n    if (leafIsPlaceholder && showPlaceholder) {\n        var placeholderProps = {\n            children: leaf.placeholder,\n            attributes: {\n                \"data-slate-placeholder\": true,\n                style: {\n                    position: \"absolute\",\n                    top: 0,\n                    pointerEvents: \"none\",\n                    width: \"100%\",\n                    maxWidth: \"100%\",\n                    display: \"block\",\n                    opacity: \"0.333\",\n                    userSelect: \"none\",\n                    textDecoration: \"none\",\n                    // Fixes https://github.com/udecode/plate/issues/2315\n                    WebkitUserModify: slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT ? \"inherit\" : undefined\n                },\n                contentEditable: false,\n                ref: callbackPlaceholderRef\n            }\n        };\n        children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, renderPlaceholder(placeholderProps), children);\n    }\n    // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n    // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n    // contenteditable behaviors. (2019/05/08)\n    var attributes = {\n        \"data-slate-leaf\": true\n    };\n    return renderLeaf({\n        attributes,\n        children,\n        leaf,\n        text\n    });\n};\nvar MemoizedLeaf = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Leaf, (prev, next)=>{\n    return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(next.leaf, prev.leaf) && next.leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL] === prev.leaf[slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = (props)=>{\n    var { attributes, children } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", _objectSpread$2({}, attributes), children);\n};\n/**\n * Text.\n */ var Text = (props)=>{\n    var { decorations, isLast, parent, renderPlaceholder, renderLeaf, text } = props;\n    var editor = useSlateStatic();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var leaves = slate__WEBPACK_IMPORTED_MODULE_7__.Text.decorations(text, decorations);\n    var key = ReactEditor.findKey(editor, text);\n    var children = [];\n    for(var i = 0; i < leaves.length; i++){\n        var leaf = leaves[i];\n        children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedLeaf, {\n            isLast: isLast && i === leaves.length - 1,\n            key: \"\".concat(key.id, \"-\").concat(i),\n            renderPlaceholder: renderPlaceholder,\n            leaf: leaf,\n            text: text,\n            parent: parent,\n            renderLeaf: renderLeaf\n        }));\n    }\n    // Update element-related weak maps with the DOM element ref.\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((span)=>{\n        var KEY_TO_ELEMENT = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        if (span) {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, span);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.set(text, span);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.set(span, text);\n        } else {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(text);\n            if (ref.current) {\n                slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.delete(ref.current);\n            }\n        }\n        ref.current = span;\n    }, [\n        ref,\n        editor,\n        key,\n        text\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", {\n        \"data-slate-node\": \"text\",\n        ref: callbackRef\n    }, children);\n};\nvar MemoizedText = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Text, (prev, next)=>{\n    return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isTextDecorationsEqual)(next.decorations, prev.decorations);\n});\nfunction ownKeys$1(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$1(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$1(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n/**\n * Element.\n */ var Element = (props)=>{\n    var { decorations, element, renderElement = (p)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultElement, _objectSpread$1({}, p)), renderPlaceholder, renderLeaf, selection } = props;\n    var editor = useSlateStatic();\n    var readOnly = useReadOnly();\n    var isInline = editor.isInline(element);\n    var key = ReactEditor.findKey(editor, element);\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((ref)=>{\n        // Update element-related weak maps with the DOM element ref.\n        var KEY_TO_ELEMENT = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        if (ref) {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.set(key, ref);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.set(element, ref);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.set(ref, element);\n        } else {\n            KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 || KEY_TO_ELEMENT.delete(key);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(element);\n        }\n    }, [\n        editor,\n        key,\n        element\n    ]);\n    var children = useChildren({\n        decorations,\n        node: element,\n        renderElement,\n        renderPlaceholder,\n        renderLeaf,\n        selection\n    });\n    // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    var attributes = {\n        \"data-slate-node\": \"element\",\n        ref\n    };\n    if (isInline) {\n        attributes[\"data-slate-inline\"] = true;\n    }\n    // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (!isInline && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, element)) {\n        var text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element);\n        var dir = direction__WEBPACK_IMPORTED_MODULE_0___default()(text);\n        if (dir === \"rtl\") {\n            attributes.dir = dir;\n        }\n    }\n    // If it's a void node, wrap the children in extra void-specific elements.\n    if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, element)) {\n        attributes[\"data-slate-void\"] = true;\n        if (!readOnly && isInline) {\n            attributes.contentEditable = false;\n        }\n        var Tag = isInline ? \"span\" : \"div\";\n        var [[_text]] = slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(element);\n        children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, {\n            \"data-slate-spacer\": true,\n            style: {\n                height: \"0\",\n                color: \"transparent\",\n                outline: \"none\",\n                position: \"absolute\"\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n            renderPlaceholder: renderPlaceholder,\n            decorations: [],\n            isLast: false,\n            parent: element,\n            text: _text\n        }));\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX.set(_text, 0);\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT.set(_text, element);\n    }\n    return renderElement({\n        attributes,\n        children,\n        element\n    });\n};\nvar MemoizedElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().memo(Element, (prev, next)=>{\n    return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isElementDecorationsEqual)(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(prev.selection, next.selection));\n});\n/**\n * The default element renderer.\n */ var DefaultElement = (props)=>{\n    var { attributes, children, element } = props;\n    var editor = useSlateStatic();\n    var Tag = editor.isInline(element) ? \"span\" : \"div\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Tag, _objectSpread$1(_objectSpread$1({}, attributes), {}, {\n        style: {\n            position: \"relative\"\n        }\n    }), children);\n};\n/**\n * A React context for sharing the `decorate` prop of the editable.\n */ var DecorateContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(()=>[]);\n/**\n * Get the current `decorate` prop of the editable.\n */ var useDecorate = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(DecorateContext);\n};\n/**\n * A React context for sharing the `selected` state of an element.\n */ var SelectedContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `selected` state of an element.\n */ var useSelected = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SelectedContext);\n};\n/**\n * Children.\n */ var useChildren = (props)=>{\n    var { decorations, node, renderElement, renderPlaceholder, renderLeaf, selection } = props;\n    var decorate = useDecorate();\n    var editor = useSlateStatic();\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.set(editor, false);\n    var path = ReactEditor.findPath(editor, node);\n    var children = [];\n    var isLeafBlock = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isInline(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasInlines(editor, node);\n    for(var i = 0; i < node.children.length; i++){\n        var p = path.concat(i);\n        var n = node.children[i];\n        var key = ReactEditor.findKey(editor, n);\n        var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, p);\n        var sel = selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(range, selection);\n        var ds = decorate([\n            n,\n            p\n        ]);\n        for (var dec of decorations){\n            var d = slate__WEBPACK_IMPORTED_MODULE_7__.Range.intersection(dec, range);\n            if (d) {\n                ds.push(d);\n            }\n        }\n        if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n)) {\n            children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SelectedContext.Provider, {\n                key: \"provider-\".concat(key.id),\n                value: !!sel\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedElement, {\n                decorations: ds,\n                element: n,\n                key: key.id,\n                renderElement: renderElement,\n                renderPlaceholder: renderPlaceholder,\n                renderLeaf: renderLeaf,\n                selection: sel\n            })));\n        } else {\n            children.push(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(MemoizedText, {\n                decorations: ds,\n                key: key.id,\n                isLast: isLeafBlock && i === node.children.length - 1,\n                parent: node,\n                renderPlaceholder: renderPlaceholder,\n                renderLeaf: renderLeaf,\n                text: n\n            }));\n        }\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_INDEX.set(n, i);\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_PARENT.set(n, node);\n    }\n    return children;\n};\n/**\n * A React context for sharing the `readOnly` state of the editor.\n */ var ReadOnlyContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `readOnly` state of the editor.\n */ var useReadOnly = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ReadOnlyContext);\n};\nvar SlateContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(null);\n/**\n * Get the current editor object from the React context.\n */ var useSlate = ()=>{\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n    if (!context) {\n        throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n    }\n    var { editor } = context;\n    return editor;\n};\nvar useSlateWithV = ()=>{\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateContext);\n    if (!context) {\n        throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n    }\n    return context;\n};\nfunction useTrackUserInput() {\n    var editor = useSlateStatic();\n    var receivedUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    var animationFrameIdRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(0);\n    var onUserInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(()=>{\n        if (receivedUserInput.current) {\n            return;\n        }\n        receivedUserInput.current = true;\n        var window1 = ReactEditor.getWindow(editor);\n        window1.cancelAnimationFrame(animationFrameIdRef.current);\n        animationFrameIdRef.current = window1.requestAnimationFrame(()=>{\n            receivedUserInput.current = false;\n        });\n    }, [\n        editor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>()=>cancelAnimationFrame(animationFrameIdRef.current), []);\n    return {\n        receivedUserInput,\n        onUserInput\n    };\n}\nvar createRestoreDomManager = (editor, receivedUserInput)=>{\n    var bufferedMutations = [];\n    var clear = ()=>{\n        bufferedMutations = [];\n    };\n    var registerMutations = (mutations)=>{\n        if (!receivedUserInput.current) {\n            return;\n        }\n        var trackedMutations = mutations.filter((mutation)=>(0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isTrackedMutation)(editor, mutation, mutations));\n        bufferedMutations.push(...trackedMutations);\n    };\n    function restoreDOM() {\n        if (bufferedMutations.length > 0) {\n            bufferedMutations.reverse().forEach((mutation)=>{\n                if (mutation.type === \"characterData\") {\n                    // We don't want to restore the DOM for characterData mutations\n                    // because this interrupts the composition.\n                    return;\n                }\n                mutation.removedNodes.forEach((node)=>{\n                    mutation.target.insertBefore(node, mutation.nextSibling);\n                });\n                mutation.addedNodes.forEach((node)=>{\n                    mutation.target.removeChild(node);\n                });\n            });\n            // Clear buffered mutations to ensure we don't undo them twice\n            clear();\n        }\n    }\n    return {\n        registerMutations,\n        restoreDOM,\n        clear\n    };\n};\nvar MUTATION_OBSERVER_CONFIG = {\n    subtree: true,\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true\n};\n// We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\nclass RestoreDOMComponent extends react__WEBPACK_IMPORTED_MODULE_3__.Component {\n    constructor(){\n        super(...arguments);\n        _defineProperty(this, \"context\", null);\n        _defineProperty(this, \"manager\", null);\n        _defineProperty(this, \"mutationObserver\", null);\n    }\n    observe() {\n        var _this$mutationObserve;\n        var { node } = this.props;\n        if (!node.current) {\n            throw new Error(\"Failed to attach MutationObserver, `node` is undefined\");\n        }\n        (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 || _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG);\n    }\n    componentDidMount() {\n        var { receivedUserInput } = this.props;\n        var editor = this.context;\n        this.manager = createRestoreDomManager(editor, receivedUserInput);\n        this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n        this.observe();\n    }\n    getSnapshotBeforeUpdate() {\n        var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n        var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n        if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n            var _this$manager;\n            (_this$manager = this.manager) === null || _this$manager === void 0 || _this$manager.registerMutations(pendingMutations);\n        }\n        (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 || _this$mutationObserve3.disconnect();\n        (_this$manager2 = this.manager) === null || _this$manager2 === void 0 || _this$manager2.restoreDOM();\n        return null;\n    }\n    componentDidUpdate() {\n        var _this$manager3;\n        (_this$manager3 = this.manager) === null || _this$manager3 === void 0 || _this$manager3.clear();\n        this.observe();\n    }\n    componentWillUnmount() {\n        var _this$mutationObserve4;\n        (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 || _this$mutationObserve4.disconnect();\n    }\n    render() {\n        return this.props.children;\n    }\n}\n_defineProperty(RestoreDOMComponent, \"contextType\", EditorContext);\nvar RestoreDOM = slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID ? RestoreDOMComponent : (_ref)=>{\n    var { children } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, children);\n};\n/**\n * A React context for sharing the `composing` state of the editor.\n */ var ComposingContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `composing` state of the editor.\n */ var useComposing = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(ComposingContext);\n};\nvar _excluded$1 = [\n    \"autoFocus\",\n    \"decorate\",\n    \"onDOMBeforeInput\",\n    \"placeholder\",\n    \"readOnly\",\n    \"renderElement\",\n    \"renderLeaf\",\n    \"renderPlaceholder\",\n    \"scrollSelectionIntoView\",\n    \"style\",\n    \"as\",\n    \"disableDefaultStyles\"\n], _excluded2 = [\n    \"text\"\n];\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar Children = (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement((react__WEBPACK_IMPORTED_MODULE_3___default().Fragment), null, useChildren(props));\n/**\n * Editable.\n */ var Editable = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.forwardRef)((props, forwardedRef)=>{\n    var defaultRenderPlaceholder = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DefaultPlaceholder, _objectSpread({}, props)), []);\n    var { autoFocus, decorate = defaultDecorate, onDOMBeforeInput: propsOnDOMBeforeInput, placeholder, readOnly = false, renderElement, renderLeaf, renderPlaceholder = defaultRenderPlaceholder, scrollSelectionIntoView = defaultScrollSelectionIntoView, style: userStyle = {}, as: Component = \"div\", disableDefaultStyles = false } = props, attributes = _objectWithoutProperties(props, _excluded$1);\n    var editor = useSlate();\n    // Rerender editor when composition status changed\n    var [isComposing, setIsComposing] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var deferredOperations = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]);\n    var [placeholderHeight, setPlaceholderHeight] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)();\n    var processing = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(false);\n    var { onUserInput, receivedUserInput } = useTrackUserInput();\n    var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)((s)=>s + 1, 0);\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_FORCE_RENDER.set(editor, forceRender);\n    // Update internal state on each render.\n    slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_READ_ONLY.set(editor, readOnly);\n    // Keep track of some state for the event handler logic.\n    var state = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>({\n            isDraggingInternally: false,\n            isUpdatingSelection: false,\n            latestElement: null,\n            hasMarkPlaceholder: false\n        }), []);\n    // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n    // needs to be manually focused.\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        if (ref.current && autoFocus) {\n            ref.current.focus();\n        }\n    }, [\n        autoFocus\n    ]);\n    /**\n   * The AndroidInputManager object has a cyclical dependency on onDOMSelectionChange\n   *\n   * It is defined as a reference to simplify hook dependencies and clarify that\n   * it needs to be initialized.\n   */ var androidInputManagerRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    // Listen on the native `selectionchange` event to be able to update any time\n    // the selection changes. This is required because React's `onSelect` is leaky\n    // and non-standard so it doesn't fire until after a selection has been\n    // released. This causes issues in situations where another change happens\n    // while a selection is being dragged.\n    var onDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(()=>{\n            if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n                onDOMSelectionChange();\n                return;\n            }\n            var el = ReactEditor.toDOMNode(editor, editor);\n            var root = el.getRootNode();\n            if (!processing.current && slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT && root instanceof ShadowRoot) {\n                processing.current = true;\n                var active = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getActiveElement)();\n                if (active) {\n                    document.execCommand(\"indent\");\n                } else {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n                }\n                processing.current = false;\n                return;\n            }\n            var androidInputManager = androidInputManagerRef.current;\n            if ((slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n                var _root = ReactEditor.findDocumentOrShadowRoot(editor);\n                var { activeElement } = _root;\n                var _el = ReactEditor.toDOMNode(editor, editor);\n                var domSelection = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getSelection)(_root);\n                if (activeElement === _el) {\n                    state.latestElement = activeElement;\n                    slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.set(editor, true);\n                } else {\n                    slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.delete(editor);\n                }\n                if (!domSelection) {\n                    return slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n                }\n                var { anchorNode, focusNode } = domSelection;\n                var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n                var focusNodeInEditor = ReactEditor.hasTarget(editor, focusNode);\n                if (anchorNodeSelectable && focusNodeInEditor) {\n                    var range = ReactEditor.toSlateRange(editor, domSelection, {\n                        exactMatch: false,\n                        suppressThrow: true\n                    });\n                    if (range) {\n                        if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                        } else {\n                            androidInputManager === null || androidInputManager === void 0 || androidInputManager.handleUserSelect(range);\n                        }\n                    }\n                }\n                // Deselect the editor if the dom selection is not selectable in readonly mode\n                if (readOnly && (!anchorNodeSelectable || !focusNodeInEditor)) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.deselect(editor);\n                }\n            }\n        }, 100), [\n        editor,\n        readOnly,\n        state\n    ]);\n    var scheduleOnDOMSelectionChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(onDOMSelectionChange, 0), [\n        onDOMSelectionChange\n    ]);\n    androidInputManagerRef.current = useAndroidInputManager({\n        node: ref,\n        onDOMSelectionChange,\n        scheduleOnDOMSelectionChange\n    });\n    useIsomorphicLayoutEffect(()=>{\n        var _androidInputManagerR, _androidInputManagerR2;\n        // Update element-related weak maps with the DOM element ref.\n        var window1;\n        if (ref.current && (window1 = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getDefaultView)(ref.current))) {\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_WINDOW.set(editor, window1);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ELEMENT.set(editor, ref.current);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.set(editor, ref.current);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.ELEMENT_TO_NODE.set(ref.current, editor);\n        } else {\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(editor);\n        }\n        // Make sure the DOM selection state is in sync.\n        var { selection } = editor;\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        var domSelection = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getSelection)(root);\n        if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {\n            return;\n        }\n        var setDomSelection = (forceChange)=>{\n            var hasDomSelection = domSelection.type !== \"None\";\n            // If the DOM selection is properly unset, we're done.\n            if (!selection && !hasDomSelection) {\n                return;\n            }\n            // Get anchorNode and focusNode\n            var focusNode = domSelection.focusNode;\n            var anchorNode;\n            // COMPAT: In firefox the normal selection way does not work\n            // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n            if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FIREFOX && domSelection.rangeCount > 1) {\n                var firstRange = domSelection.getRangeAt(0);\n                var lastRange = domSelection.getRangeAt(domSelection.rangeCount - 1);\n                // Right to left\n                if (firstRange.startContainer === focusNode) {\n                    anchorNode = lastRange.endContainer;\n                } else {\n                    // Left to right\n                    anchorNode = firstRange.startContainer;\n                }\n            } else {\n                anchorNode = domSelection.anchorNode;\n            }\n            // verify that the dom selection is in the editor\n            var editorElement = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ELEMENT.get(editor);\n            var hasDomSelectionInEditor = false;\n            if (editorElement.contains(anchorNode) && editorElement.contains(focusNode)) {\n                hasDomSelectionInEditor = true;\n            }\n            // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n            if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n                var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n                    exactMatch: true,\n                    // domSelection is not necessarily a valid Slate range\n                    // (e.g. when clicking on contentEditable:false element)\n                    suppressThrow: true\n                });\n                if (slateRange && slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(slateRange, selection)) {\n                    var _anchorNode;\n                    if (!state.hasMarkPlaceholder) {\n                        return;\n                    }\n                    // Ensure selection is inside the mark placeholder\n                    if ((_anchorNode = anchorNode) !== null && _anchorNode !== void 0 && (_anchorNode = _anchorNode.parentElement) !== null && _anchorNode !== void 0 && _anchorNode.hasAttribute(\"data-slate-mark-placeholder\")) {\n                        return;\n                    }\n                }\n            }\n            // when <Editable/> is being controlled through external value\n            // then its children might just change - DOM responds to it on its own\n            // but Slate's value is not being updated through any operation\n            // and thus it doesn't transform selection on its own\n            if (selection && !ReactEditor.hasRange(editor, selection)) {\n                editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n                    exactMatch: false,\n                    suppressThrow: true\n                });\n                return;\n            }\n            // Otherwise the DOM selection is out of sync, so update it.\n            state.isUpdatingSelection = true;\n            var newDomRange = null;\n            try {\n                newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n            } catch (e) {\n            // Ignore, dom and state might be out of sync\n            }\n            if (newDomRange) {\n                if (ReactEditor.isComposing(editor) && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n                    domSelection.collapseToEnd();\n                } else if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isBackward(selection)) {\n                    domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n                } else {\n                    domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n                }\n                scrollSelectionIntoView(editor, newDomRange);\n            } else {\n                domSelection.removeAllRanges();\n            }\n            return newDomRange;\n        };\n        // In firefox if there is more then 1 range and we call setDomSelection we remove the ability to select more cells in a table\n        if (domSelection.rangeCount <= 1) {\n            setDomSelection();\n        }\n        var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === \"action\";\n        if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID || !ensureSelection) {\n            setTimeout(()=>{\n                state.isUpdatingSelection = false;\n            });\n            return;\n        }\n        var timeoutId = null;\n        var animationFrameId = requestAnimationFrame(()=>{\n            if (ensureSelection) {\n                var ensureDomSelection = (forceChange)=>{\n                    try {\n                        var el = ReactEditor.toDOMNode(editor, editor);\n                        el.focus();\n                        setDomSelection(forceChange);\n                    } catch (e) {\n                    // Ignore, dom and state might be out of sync\n                    }\n                };\n                // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n                // This essentially would make setting the slate selection during an update meaningless, so we force it\n                // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n                // visible flicker.\n                ensureDomSelection();\n                timeoutId = setTimeout(()=>{\n                    // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n                    // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n                    // the animation frame to ensure it displays the correct state.\n                    ensureDomSelection(true);\n                    state.isUpdatingSelection = false;\n                });\n            }\n        });\n        return ()=>{\n            cancelAnimationFrame(animationFrameId);\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n        };\n    });\n    // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n    // is required because React's `beforeinput` is fake and never really attaches\n    // to the real event sadly. (2019/11/01)\n    // https://github.com/facebook/react/issues/11211\n    var onDOMBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = el.getRootNode();\n        if (processing !== null && processing !== void 0 && processing.current && slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT && root instanceof ShadowRoot) {\n            var ranges = event.getTargetRanges();\n            var range = ranges[0];\n            var newRange = new window.Range();\n            newRange.setStart(range.startContainer, range.startOffset);\n            newRange.setEnd(range.endContainer, range.endOffset);\n            // Translate the DOM Range into a Slate Range\n            var slateRange = ReactEditor.toSlateRange(editor, newRange, {\n                exactMatch: false,\n                suppressThrow: false\n            });\n            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, slateRange);\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            return;\n        }\n        onUserInput();\n        if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n            var _EDITOR_TO_USER_SELEC;\n            // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n            if (androidInputManagerRef.current) {\n                return androidInputManagerRef.current.handleDOMBeforeInput(event);\n            }\n            // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n            // triggering a `beforeinput` expecting the change to be applied to the immediately before\n            // set selection.\n            scheduleOnDOMSelectionChange.flush();\n            onDOMSelectionChange.flush();\n            var { selection } = editor;\n            var { inputType: type } = event;\n            var data = event.dataTransfer || event.data || undefined;\n            var isCompositionChange = type === \"insertCompositionText\" || type === \"deleteCompositionText\";\n            // COMPAT: use composition change events as a hint to where we should insert\n            // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n            if (isCompositionChange && ReactEditor.isComposing(editor)) {\n                return;\n            }\n            var native = false;\n            if (type === \"insertText\" && selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.\n            // Long-press events (hold a + press 4 = ) to choose a special character otherwise\n            // causes duplicate inserts.\n            event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n            // When there is an inline element, e.g. a link, and you select\n            // right after it (the start of the next node).\n            selection.anchor.offset !== 0) {\n                native = true;\n                // Skip native if there are marks, as\n                // `insertText` will insert a node, not just text.\n                if (editor.marks) {\n                    native = false;\n                }\n                // If the NODE_MAP is dirty, we can't trust the selection anchor (eg ReactEditor.toDOMPoint)\n                if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n                    var _node$parentElement, _window$getComputedSt;\n                    // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n                    // Therefore we don't allow native events to insert text at the end of anchor nodes.\n                    var { anchor } = selection;\n                    var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n                    var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest(\"a\");\n                    var _window = ReactEditor.getWindow(editor);\n                    if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n                        var _lastText$textContent;\n                        // Find the last text node inside the anchor.\n                        var lastText = _window === null || _window === void 0 ? void 0 : _window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n                        if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n                            native = false;\n                        }\n                    }\n                    // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n                    // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n                    if (native && node.parentElement && (_window === null || _window === void 0 || (_window$getComputedSt = _window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === \"pre\") {\n                        var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                            at: anchor.path,\n                            match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n)\n                        });\n                        if (block && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(block[0]).includes(\"\t\")) {\n                            native = false;\n                        }\n                    }\n                }\n            }\n            // COMPAT: For the deleting forward/backward input types we don't want\n            // to change the selection because it is the range that will be deleted,\n            // and those commands determine that for themselves.\n            // If the NODE_MAP is dirty, we can't trust the selection anchor (eg ReactEditor.toDOMPoint via ReactEditor.toSlateRange)\n            if ((!type.startsWith(\"delete\") || type.startsWith(\"deleteBy\")) && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_NODE_MAP_DIRTY.get(editor)) {\n                var [targetRange] = event.getTargetRanges();\n                if (targetRange) {\n                    var _range = ReactEditor.toSlateRange(editor, targetRange, {\n                        exactMatch: false,\n                        suppressThrow: false\n                    });\n                    if (!selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(selection, _range)) {\n                        native = false;\n                        var selectionRef = !isCompositionChange && editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.rangeRef(editor, editor.selection);\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, _range);\n                        if (selectionRef) {\n                            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n                        }\n                    }\n                }\n            }\n            // Composition change types occur while a user is composing text and can't be\n            // cancelled. Let them through and wait for the composition to end.\n            if (isCompositionChange) {\n                return;\n            }\n            if (!native) {\n                event.preventDefault();\n            }\n            // COMPAT: If the selection is expanded, even if the command seems like\n            // a delete forward/backward command it should delete the selection.\n            if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection) && type.startsWith(\"delete\")) {\n                var direction = type.endsWith(\"Backward\") ? \"backward\" : \"forward\";\n                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                    direction\n                });\n                return;\n            }\n            switch(type){\n                case \"deleteByComposition\":\n                case \"deleteByCut\":\n                case \"deleteByDrag\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                        break;\n                    }\n                case \"deleteContent\":\n                case \"deleteContentForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n                        break;\n                    }\n                case \"deleteContentBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n                        break;\n                    }\n                case \"deleteEntireSoftLine\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteHardLineBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"block\"\n                        });\n                        break;\n                    }\n                case \"deleteSoftLineBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteHardLineForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"block\"\n                        });\n                        break;\n                    }\n                case \"deleteSoftLineForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"line\"\n                        });\n                        break;\n                    }\n                case \"deleteWordBackward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                            unit: \"word\"\n                        });\n                        break;\n                    }\n                case \"deleteWordForward\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                            unit: \"word\"\n                        });\n                        break;\n                    }\n                case \"insertLineBreak\":\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                    break;\n                case \"insertParagraph\":\n                    {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n                        break;\n                    }\n                case \"insertFromComposition\":\n                case \"insertFromDrop\":\n                case \"insertFromPaste\":\n                case \"insertFromYank\":\n                case \"insertReplacementText\":\n                case \"insertText\":\n                    {\n                        if (type === \"insertFromComposition\") {\n                            // COMPAT: in Safari, `compositionend` is dispatched after the\n                            // `beforeinput` for \"insertFromComposition\". But if we wait for it\n                            // then we will abort because we're still composing and the selection\n                            // won't be updated properly.\n                            // https://www.w3.org/TR/input-events-2/\n                            if (ReactEditor.isComposing(editor)) {\n                                setIsComposing(false);\n                                slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n                            }\n                        }\n                        // use a weak comparison instead of 'instanceof' to allow\n                        // programmatic access of paste events coming from external windows\n                        // like cypress where cy.window does not work realibly\n                        if ((data === null || data === void 0 ? void 0 : data.constructor.name) === \"DataTransfer\") {\n                            ReactEditor.insertData(editor, data);\n                        } else if (typeof data === \"string\") {\n                            // Only insertText operations use the native functionality, for now.\n                            // Potentially expand to single character deletes, as well.\n                            if (native) {\n                                deferredOperations.current.push(()=>slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data));\n                            } else {\n                                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, data);\n                            }\n                        }\n                        break;\n                    }\n            }\n            // Restore the actual user section if nothing manually set it.\n            var toRestore = (_EDITOR_TO_USER_SELEC = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_SELECTION.delete(editor);\n            if (toRestore && (!editor.selection || !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(editor.selection, toRestore))) {\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, toRestore);\n            }\n        }\n    }, [\n        editor,\n        onDOMSelectionChange,\n        onUserInput,\n        propsOnDOMBeforeInput,\n        readOnly,\n        scheduleOnDOMSelectionChange\n    ]);\n    var callbackRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((node)=>{\n        if (node == null) {\n            onDOMSelectionChange.cancel();\n            scheduleOnDOMSelectionChange.cancel();\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ELEMENT.delete(editor);\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.NODE_TO_ELEMENT.delete(editor);\n            if (ref.current && slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT) {\n                // @ts-ignore The `beforeinput` event isn't recognized.\n                ref.current.removeEventListener(\"beforeinput\", onDOMBeforeInput);\n            }\n        } else {\n            // Attach a native DOM event handler for `beforeinput` events, because React's\n            // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n            // real `beforeinput` events sadly... (2019/11/04)\n            // https://github.com/facebook/react/issues/11211\n            if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT) {\n                // @ts-ignore The `beforeinput` event isn't recognized.\n                node.addEventListener(\"beforeinput\", onDOMBeforeInput);\n            }\n        }\n        ref.current = node;\n        if (typeof forwardedRef === \"function\") {\n            forwardedRef(node);\n        } else if (forwardedRef) {\n            forwardedRef.current = node;\n        }\n    }, [\n        onDOMSelectionChange,\n        scheduleOnDOMSelectionChange,\n        editor,\n        onDOMBeforeInput,\n        forwardedRef\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        var window1 = ReactEditor.getWindow(editor);\n        // Attach a native DOM event handler for `selectionchange`, because React's\n        // built-in `onSelect` handler doesn't fire for all selection changes. It's\n        // a leaky polyfill that only fires on keypresses or clicks. Instead, we\n        // want to fire for any change to the selection inside the editor.\n        // (2019/11/04) https://github.com/facebook/react/issues/5785\n        window1.document.addEventListener(\"selectionchange\", scheduleOnDOMSelectionChange);\n        // Listen for dragend and drop globally. In Firefox, if a drop handler\n        // initiates an operation that causes the originally dragged element to\n        // unmount, that element will not emit a dragend event. (2024/06/21)\n        var stoppedDragging = ()=>{\n            state.isDraggingInternally = false;\n        };\n        window1.document.addEventListener(\"dragend\", stoppedDragging);\n        window1.document.addEventListener(\"drop\", stoppedDragging);\n        return ()=>{\n            window1.document.removeEventListener(\"selectionchange\", scheduleOnDOMSelectionChange);\n            window1.document.removeEventListener(\"dragend\", stoppedDragging);\n            window1.document.removeEventListener(\"drop\", stoppedDragging);\n        };\n    }, [\n        scheduleOnDOMSelectionChange,\n        state\n    ]);\n    var decorations = decorate([\n        editor,\n        []\n    ]);\n    var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(slate__WEBPACK_IMPORTED_MODULE_7__.Node.texts(editor)).length === 1 && slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(editor) === \"\" && !isComposing;\n    var placeHolderResizeHandler = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((placeholderEl)=>{\n        if (placeholderEl && showPlaceholder) {\n            var _placeholderEl$getBou;\n            setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);\n        } else {\n            setPlaceholderHeight(undefined);\n        }\n    }, [\n        showPlaceholder\n    ]);\n    if (showPlaceholder) {\n        var start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, []);\n        decorations.push({\n            [slate_dom__WEBPACK_IMPORTED_MODULE_4__.PLACEHOLDER_SYMBOL]: true,\n            placeholder,\n            onPlaceholderResize: placeHolderResizeHandler,\n            anchor: start,\n            focus: start\n        });\n    }\n    var { marks } = editor;\n    state.hasMarkPlaceholder = false;\n    if (editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection) && marks) {\n        var { anchor } = editor.selection;\n        var leaf = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, anchor.path);\n        var rest = _objectWithoutProperties(leaf, _excluded2);\n        // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(leaf, marks, {\n            loose: true\n        })) {\n            state.hasMarkPlaceholder = true;\n            var unset = Object.fromEntries(Object.keys(rest).map((mark)=>[\n                    mark,\n                    null\n                ]));\n            decorations.push(_objectSpread(_objectSpread(_objectSpread({\n                [slate_dom__WEBPACK_IMPORTED_MODULE_4__.MARK_PLACEHOLDER_SYMBOL]: true\n            }, unset), marks), {}, {\n                anchor,\n                focus: anchor\n            }));\n        }\n    }\n    // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n    // before we receive the composition end event.\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        setTimeout(()=>{\n            var { selection } = editor;\n            if (selection) {\n                var { anchor: _anchor } = selection;\n                var _text = slate__WEBPACK_IMPORTED_MODULE_7__.Node.leaf(editor, _anchor.path);\n                // While marks isn't a 'complete' text, we can still use loose Text.equals\n                // here which only compares marks anyway.\n                if (marks && !slate__WEBPACK_IMPORTED_MODULE_7__.Text.equals(_text, marks, {\n                    loose: true\n                })) {\n                    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n                    return;\n                }\n            }\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        });\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ReadOnlyContext.Provider, {\n        value: readOnly\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(ComposingContext.Provider, {\n        value: isComposing\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(DecorateContext.Provider, {\n        value: decorate\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(RestoreDOM, {\n        node: ref,\n        receivedUserInput: receivedUserInput\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Component, _objectSpread(_objectSpread({\n        role: readOnly ? undefined : \"textbox\",\n        \"aria-multiline\": readOnly ? undefined : true\n    }, attributes), {}, {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n        // have to use hacks to make these replacement-based features work.\n        // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n        // mismatch warning app moves to browser. Pass-through consumer props when\n        // not CAN_USE_DOM (SSR) and default to falsy value\n        spellCheck: slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || !slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? attributes.spellCheck : false,\n        autoCorrect: slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || !slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? attributes.autoCorrect : \"false\",\n        autoCapitalize: slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || !slate_dom__WEBPACK_IMPORTED_MODULE_4__.CAN_USE_DOM ? attributes.autoCapitalize : \"false\",\n        \"data-slate-editor\": true,\n        \"data-slate-node\": \"value\",\n        // explicitly set this\n        contentEditable: !readOnly,\n        // in some cases, a decoration needs access to the range / selection to decorate a text node,\n        // then you will select the whole text node when you select part the of text\n        // this magic zIndex=\"-1\" will fix it\n        zindex: -1,\n        suppressContentEditableWarning: true,\n        ref: callbackRef,\n        style: _objectSpread(_objectSpread({}, disableDefaultStyles ? {} : _objectSpread({\n            // Allow positioning relative to the editable element.\n            position: \"relative\",\n            // Preserve adjacent whitespace and new lines.\n            whiteSpace: \"pre-wrap\",\n            // Allow words to break if they are too long.\n            wordWrap: \"break-word\"\n        }, placeholderHeight ? {\n            minHeight: placeholderHeight\n        } : {})), userStyle),\n        onBeforeInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n            // fall back to React's leaky polyfill instead just for it. It\n            // only works for the `insertText` input type.\n            if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n                event.preventDefault();\n                if (!ReactEditor.isComposing(editor)) {\n                    var _text2 = event.data;\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, _text2);\n                }\n            }\n        }, [\n            attributes.onBeforeInput,\n            editor,\n            readOnly\n        ]),\n        onInput: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (isEventHandled(event, attributes.onInput)) {\n                return;\n            }\n            if (androidInputManagerRef.current) {\n                androidInputManagerRef.current.handleInput();\n                return;\n            }\n            // Flush native operations, as native events will have propogated\n            // and we can correctly compare DOM text values in components\n            // to stop rendering, so that browser functions like autocorrect\n            // and spellcheck work as expected.\n            for (var op of deferredOperations.current){\n                op();\n            }\n            deferredOperations.current = [];\n            // COMPAT: Since `beforeinput` doesn't fully `preventDefault`,\n            // there's a chance that content might be placed in the browser's undo stack.\n            // This means undo can be triggered even when the div is not focused,\n            // and it only triggers the input event for the node. (2024/10/09)\n            if (!ReactEditor.isFocused(editor)) {\n                var native = event.nativeEvent;\n                var maybeHistoryEditor = editor;\n                if (native.inputType === \"historyUndo\" && typeof maybeHistoryEditor.undo === \"function\") {\n                    maybeHistoryEditor.undo();\n                    return;\n                }\n                if (native.inputType === \"historyRedo\" && typeof maybeHistoryEditor.redo === \"function\") {\n                    maybeHistoryEditor.redo();\n                    return;\n                }\n            }\n        }, [\n            attributes.onInput,\n            editor\n        ]),\n        onBlur: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n                return;\n            }\n            // COMPAT: If the current `activeElement` is still the previous\n            // one, this is due to the window being blurred when the tab\n            // itself becomes unfocused, so we want to abort early to allow to\n            // editor to stay focused when the tab becomes focused again.\n            var root = ReactEditor.findDocumentOrShadowRoot(editor);\n            if (state.latestElement === root.activeElement) {\n                return;\n            }\n            var { relatedTarget } = event;\n            var el = ReactEditor.toDOMNode(editor, editor);\n            // COMPAT: The event should be ignored if the focus is returning\n            // to the editor from an embedded editable element (eg. an <input>\n            // element inside a void node).\n            if (relatedTarget === el) {\n                return;\n            }\n            // COMPAT: The event should be ignored if the focus is moving from\n            // the editor to inside a void node's spacer element.\n            if ((0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMElement)(relatedTarget) && relatedTarget.hasAttribute(\"data-slate-spacer\")) {\n                return;\n            }\n            // COMPAT: The event should be ignored if the focus is moving to a\n            // non- editable section of an element that isn't a void node (eg.\n            // a list item of the check list example).\n            if (relatedTarget != null && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMNode)(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n                var node = ReactEditor.toSlateNode(editor, relatedTarget);\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && !editor.isVoid(node)) {\n                    return;\n                }\n            }\n            // COMPAT: Safari doesn't always remove the selection even if the content-\n            // editable element no longer has focus. Refer to:\n            // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n            if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT) {\n                var domSelection = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.getSelection)(root);\n                domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n            }\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.delete(editor);\n        }, [\n            readOnly,\n            state.isUpdatingSelection,\n            state.latestElement,\n            editor,\n            attributes.onBlur\n        ]),\n        onClick: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMNode)(event.target)) {\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                var path = ReactEditor.findPath(editor, node);\n                // At this time, the Slate document may be arbitrarily different,\n                // because onClick handlers can change the document before we get here.\n                // Therefore we must check that this path actually exists,\n                // and that it still refers to the same node.\n                if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.hasPath(editor, path) || slate__WEBPACK_IMPORTED_MODULE_7__.Node.get(editor, path) !== node) {\n                    return;\n                }\n                if (event.detail === slate_dom__WEBPACK_IMPORTED_MODULE_4__.TRIPLE_CLICK && path.length >= 1) {\n                    var blockPath = path;\n                    if (!(slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, node))) {\n                        var _block$;\n                        var block = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.above(editor, {\n                            match: (n)=>slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, n),\n                            at: path\n                        });\n                        blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n                    }\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, blockPath);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                    return;\n                }\n                if (readOnly) {\n                    return;\n                }\n                var _start = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.start(editor, path);\n                var end = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.end(editor, path);\n                var startVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: _start\n                });\n                var endVoid = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: end\n                });\n                if (startVoid && endVoid && slate__WEBPACK_IMPORTED_MODULE_7__.Path.equals(startVoid[1], endVoid[1])) {\n                    var _range2 = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, _start);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, _range2);\n                }\n            }\n        }, [\n            editor,\n            attributes.onClick,\n            readOnly\n        ]),\n        onCompositionEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n                var _androidInputManagerR3;\n                if (ReactEditor.isComposing(editor)) {\n                    Promise.resolve().then(()=>{\n                        setIsComposing(false);\n                        slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n                    });\n                }\n                (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 || _androidInputManagerR3.handleCompositionEnd(event);\n                if (isEventHandled(event, attributes.onCompositionEnd) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n                    return;\n                }\n                // COMPAT: In Chrome, `beforeinput` events for compositions\n                // aren't correct and never fire the \"insertFromComposition\"\n                // type that we need. So instead, insert whenever a composition\n                // ends since it will already have been committed to the DOM.\n                if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FIREFOX_LEGACY && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_IOS && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WECHATBROWSER && !slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_UC_MOBILE && event.data) {\n                    var placeholderMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n                    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n                    // Ensure we insert text with the marks the user was actually seeing\n                    if (placeholderMarks !== undefined) {\n                        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n                        editor.marks = placeholderMarks;\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertText(editor, event.data);\n                    var userMarks = slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.get(editor);\n                    slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_USER_MARKS.delete(editor);\n                    if (userMarks !== undefined) {\n                        editor.marks = userMarks;\n                    }\n                }\n            }\n        }, [\n            attributes.onCompositionEnd,\n            editor\n        ]),\n        onCompositionUpdate: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n                if (!ReactEditor.isComposing(editor)) {\n                    setIsComposing(true);\n                    slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, true);\n                }\n            }\n        }, [\n            attributes.onCompositionUpdate,\n            editor\n        ]),\n        onCompositionStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n                var _androidInputManagerR4;\n                (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 || _androidInputManagerR4.handleCompositionStart(event);\n                if (isEventHandled(event, attributes.onCompositionStart) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID) {\n                    return;\n                }\n                setIsComposing(true);\n                var { selection } = editor;\n                if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                    return;\n                }\n            }\n        }, [\n            attributes.onCompositionStart,\n            editor\n        ]),\n        onCopy: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {\n                event.preventDefault();\n                ReactEditor.setFragmentData(editor, event.clipboardData, \"copy\");\n            }\n        }, [\n            attributes.onCopy,\n            editor\n        ]),\n        onCut: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {\n                event.preventDefault();\n                ReactEditor.setFragmentData(editor, event.clipboardData, \"cut\");\n                var { selection } = editor;\n                if (selection) {\n                    if (slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor);\n                    } else {\n                        var node = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n                        if (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor);\n                        }\n                    }\n                }\n            }\n        }, [\n            readOnly,\n            editor,\n            attributes.onCut\n        ]),\n        onDragOver: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n                // Only when the target is void, call `preventDefault` to signal\n                // that drops are allowed. Editable content is droppable by\n                // default, and calling `preventDefault` hides the cursor.\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node)) {\n                    event.preventDefault();\n                }\n            }\n        }, [\n            attributes.onDragOver,\n            editor\n        ]),\n        onDragStart: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n                var node = ReactEditor.toSlateNode(editor, event.target);\n                var path = ReactEditor.findPath(editor, node);\n                var voidMatch = slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, node) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                    at: path,\n                    voids: true\n                });\n                // If starting a drag on a void node, make sure it is selected\n                // so that it shows up in the selection's fragment.\n                if (voidMatch) {\n                    var range = slate__WEBPACK_IMPORTED_MODULE_7__.Editor.range(editor, path);\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                }\n                state.isDraggingInternally = true;\n                ReactEditor.setFragmentData(editor, event.dataTransfer, \"drag\");\n            }\n        }, [\n            readOnly,\n            editor,\n            attributes.onDragStart,\n            state\n        ]),\n        onDrop: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n                event.preventDefault();\n                // Keep a reference to the dragged range before updating selection\n                var draggedRange = editor.selection;\n                // Find the range where the drop happened\n                var range = ReactEditor.findEventRange(editor, event);\n                var data = event.dataTransfer;\n                slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.select(editor, range);\n                if (state.isDraggingInternally) {\n                    if (draggedRange && !slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(draggedRange, range) && !slate__WEBPACK_IMPORTED_MODULE_7__.Editor.void(editor, {\n                        at: range,\n                        voids: true\n                    })) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.delete(editor, {\n                            at: draggedRange\n                        });\n                    }\n                }\n                ReactEditor.insertData(editor, data);\n                // When dragging from another source into the editor, it's possible\n                // that the current editor does not have focus.\n                if (!ReactEditor.isFocused(editor)) {\n                    ReactEditor.focus(editor);\n                }\n            }\n        }, [\n            readOnly,\n            editor,\n            attributes.onDrop,\n            state\n        ]),\n        onDragEnd: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n                attributes.onDragEnd(event);\n            }\n        }, [\n            readOnly,\n            state,\n            attributes,\n            editor\n        ]),\n        onFocus: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n                var el = ReactEditor.toDOMNode(editor, editor);\n                var root = ReactEditor.findDocumentOrShadowRoot(editor);\n                state.latestElement = root.activeElement;\n                // COMPAT: If the editor has nested editable elements, the focus\n                // can go to them. In Firefox, this must be prevented because it\n                // results in issues with keyboard navigation. (2017/03/30)\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FIREFOX && event.target !== el) {\n                    el.focus();\n                    return;\n                }\n                slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_FOCUSED.set(editor, true);\n            }\n        }, [\n            readOnly,\n            state,\n            editor,\n            attributes.onFocus\n        ]),\n        onKeyDown: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n                var _androidInputManagerR5;\n                (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 || _androidInputManagerR5.handleKeyDown(event);\n                var { nativeEvent } = event;\n                // COMPAT: The composition end event isn't fired reliably in all browsers,\n                // so we sometimes might end up stuck in a composition state even though we\n                // aren't composing any more.\n                if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n                    slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_COMPOSING.set(editor, false);\n                    setIsComposing(false);\n                }\n                if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n                    return;\n                }\n                var { selection } = editor;\n                var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n                var isRTL = direction__WEBPACK_IMPORTED_MODULE_0___default()(slate__WEBPACK_IMPORTED_MODULE_7__.Node.string(element)) === \"rtl\";\n                // COMPAT: Since we prevent the default behavior on\n                // `beforeinput` events, the browser doesn't think there's ever\n                // any history stack to undo or redo, so we have to manage these\n                // hotkeys ourselves. (2019/11/06)\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isRedo(nativeEvent)) {\n                    event.preventDefault();\n                    var maybeHistoryEditor = editor;\n                    if (typeof maybeHistoryEditor.redo === \"function\") {\n                        maybeHistoryEditor.redo();\n                    }\n                    return;\n                }\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isUndo(nativeEvent)) {\n                    event.preventDefault();\n                    var _maybeHistoryEditor = editor;\n                    if (typeof _maybeHistoryEditor.undo === \"function\") {\n                        _maybeHistoryEditor.undo();\n                    }\n                    return;\n                }\n                // COMPAT: Certain browsers don't handle the selection updates\n                // properly. In Chrome, the selection isn't properly extended.\n                // And in Firefox, the selection isn't properly collapsed.\n                // (2017/10/17)\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveLineBackward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        reverse: true\n                    });\n                    return;\n                }\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveLineForward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\"\n                    });\n                    return;\n                }\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isExtendLineBackward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        edge: \"focus\",\n                        reverse: true\n                    });\n                    return;\n                }\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isExtendLineForward(nativeEvent)) {\n                    event.preventDefault();\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"line\",\n                        edge: \"focus\"\n                    });\n                    return;\n                }\n                // COMPAT: If a void node is selected, or a zero-width text node\n                // adjacent to an inline is selected, we need to handle these\n                // hotkeys manually because browsers won't be able to skip over\n                // the void node with the zero-width space not being an empty\n                // string.\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveBackward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                            reverse: !isRTL\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: isRTL ? \"end\" : \"start\"\n                        });\n                    }\n                    return;\n                }\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveForward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                            reverse: isRTL\n                        });\n                    } else {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: isRTL ? \"start\" : \"end\"\n                        });\n                    }\n                    return;\n                }\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveWordBackward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"focus\"\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"word\",\n                        reverse: !isRTL\n                    });\n                    return;\n                }\n                if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isMoveWordForward(nativeEvent)) {\n                    event.preventDefault();\n                    if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.collapse(editor, {\n                            edge: \"focus\"\n                        });\n                    }\n                    slate__WEBPACK_IMPORTED_MODULE_7__.Transforms.move(editor, {\n                        unit: \"word\",\n                        reverse: isRTL\n                    });\n                    return;\n                }\n                // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to guessing at the input intention for hotkeys.\n                // COMPAT: In iOS, some of these hotkeys are handled in the\n                if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT) {\n                    // We don't have a core behavior for these, but they change the\n                    // DOM if we don't prevent them, so we have to.\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isBold(nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isItalic(nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isTransposeCharacter(nativeEvent)) {\n                        event.preventDefault();\n                        return;\n                    }\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isSoftBreak(nativeEvent)) {\n                        event.preventDefault();\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertSoftBreak(editor);\n                        return;\n                    }\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isSplitBlock(nativeEvent)) {\n                        event.preventDefault();\n                        slate__WEBPACK_IMPORTED_MODULE_7__.Editor.insertBreak(editor);\n                        return;\n                    }\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor);\n                        }\n                        return;\n                    }\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor);\n                        }\n                        return;\n                    }\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteLineBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                unit: \"line\"\n                            });\n                        }\n                        return;\n                    }\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteLineForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                                unit: \"line\"\n                            });\n                        }\n                        return;\n                    }\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteWordBackward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"backward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                unit: \"word\"\n                            });\n                        }\n                        return;\n                    }\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteWordForward(nativeEvent)) {\n                        event.preventDefault();\n                        if (selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isExpanded(selection)) {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteFragment(editor, {\n                                direction: \"forward\"\n                            });\n                        } else {\n                            slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteForward(editor, {\n                                unit: \"word\"\n                            });\n                        }\n                        return;\n                    }\n                } else {\n                    if (slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_CHROME || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT) {\n                        // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n                        // an event when deleting backwards in a selected void inline node\n                        if (selection && (slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteBackward(nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.Hotkeys.isDeleteForward(nativeEvent)) && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(selection)) {\n                            var currentNode = slate__WEBPACK_IMPORTED_MODULE_7__.Node.parent(editor, selection.anchor.path);\n                            if (slate__WEBPACK_IMPORTED_MODULE_7__.Element.isElement(currentNode) && slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isVoid(editor, currentNode) && (slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isInline(editor, currentNode) || slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isBlock(editor, currentNode))) {\n                                event.preventDefault();\n                                slate__WEBPACK_IMPORTED_MODULE_7__.Editor.deleteBackward(editor, {\n                                    unit: \"block\"\n                                });\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }, [\n            readOnly,\n            editor,\n            attributes.onKeyDown\n        ]),\n        onPaste: (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((event)=>{\n            if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n                // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to React's `onPaste` here instead.\n                // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n                // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n                // COMPAT: Safari InputEvents generated by pasting won't include\n                // application/x-slate-fragment items, so use the\n                // ClipboardEvent here. (2023/03/15)\n                if (!slate_dom__WEBPACK_IMPORTED_MODULE_4__.HAS_BEFORE_INPUT_SUPPORT || (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isPlainTextOnlyPaste)(event.nativeEvent) || slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_WEBKIT) {\n                    event.preventDefault();\n                    ReactEditor.insertData(editor, event.clipboardData);\n                }\n            }\n        }, [\n            readOnly,\n            editor,\n            attributes.onPaste\n        ])\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(Children, {\n        decorations: decorations,\n        node: editor,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: editor.selection\n    }))))));\n});\n/**\n * The default placeholder element\n */ var DefaultPlaceholder = (_ref)=>{\n    var { attributes, children } = _ref;\n    return(/*#__PURE__*/ // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"span\", _objectSpread({}, attributes), children, slate_dom__WEBPACK_IMPORTED_MODULE_4__.IS_ANDROID && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(\"br\", null)));\n};\n/**\n * A default memoized decorate function.\n */ var defaultDecorate = ()=>[];\n/**\n * A default implement to scroll dom range into view.\n */ var defaultScrollSelectionIntoView = (editor, domRange)=>{\n    // This was affecting the selection of multiple blocks and dragging behavior,\n    // so enabled only if the selection has been collapsed.\n    if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && slate__WEBPACK_IMPORTED_MODULE_7__.Range.isCollapsed(editor.selection))) {\n        var leafEl = domRange.startContainer.parentElement;\n        leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n        (0,scroll_into_view_if_needed__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(leafEl, {\n            scrollMode: \"if-needed\"\n        });\n        // @ts-expect-error an unorthodox delete D:\n        delete leafEl.getBoundingClientRect;\n    }\n};\n/**\n * Check if an event is overrided by a handler.\n */ var isEventHandled = (event, handler)=>{\n    if (!handler) {\n        return false;\n    }\n    // The custom event handler may return a boolean to specify whether the event\n    // shall be treated as being handled or not.\n    var shouldTreatEventAsHandled = handler(event);\n    if (shouldTreatEventAsHandled != null) {\n        return shouldTreatEventAsHandled;\n    }\n    return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\n * Check if the event's target is an input element\n */ var isDOMEventTargetInput = (event)=>{\n    return (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.isDOMNode)(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);\n};\n/**\n * Check if a DOM event is overrided by a handler.\n */ var isDOMEventHandled = (event, handler)=>{\n    if (!handler) {\n        return false;\n    }\n    // The custom event handler may return a boolean to specify whether the event\n    // shall be treated as being handled or not.\n    var shouldTreatEventAsHandled = handler(event);\n    if (shouldTreatEventAsHandled != null) {\n        return shouldTreatEventAsHandled;\n    }\n    return event.defaultPrevented;\n};\n/**\n * A React context for sharing the `focused` state of the editor.\n */ var FocusedContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)(false);\n/**\n * Get the current `focused` state of the editor.\n */ var useFocused = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(FocusedContext);\n};\nfunction isError(error) {\n    return error instanceof Error;\n}\n/**\n * A React context for sharing the editor selector context in a way to control rerenders\n */ var SlateSelectorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createContext)({});\nvar refEquality = (a, b)=>a === b;\n/**\n * use redux style selectors to prevent rerendering on every keystroke.\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\n *\n * Example:\n * ```\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\n * ```\n */ function useSlateSelector(selector) {\n    var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n    var [, forceRender] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useReducer)((s)=>s + 1, 0);\n    var context = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(SlateSelectorContext);\n    if (!context) {\n        throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n    }\n    var { getSlate, addEventListener } = context;\n    var latestSubscriptionCallbackError = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)();\n    var latestSelector = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(()=>null);\n    var latestSelectedState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null);\n    var selectedState;\n    try {\n        if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n            selectedState = selector(getSlate());\n        } else {\n            selectedState = latestSelectedState.current;\n        }\n    } catch (err) {\n        if (latestSubscriptionCallbackError.current && isError(err)) {\n            err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n        }\n        throw err;\n    }\n    useIsomorphicLayoutEffect(()=>{\n        latestSelector.current = selector;\n        latestSelectedState.current = selectedState;\n        latestSubscriptionCallbackError.current = undefined;\n    });\n    useIsomorphicLayoutEffect(()=>{\n        function checkForUpdates() {\n            try {\n                var newSelectedState = latestSelector.current(getSlate());\n                if (equalityFn(newSelectedState, latestSelectedState.current)) {\n                    return;\n                }\n                latestSelectedState.current = newSelectedState;\n            } catch (err) {\n                // we ignore all errors here, since when the component\n                // is re-rendered, the selectors are called again, and\n                // will throw again, if neither props nor store state\n                // changed\n                if (err instanceof Error) {\n                    latestSubscriptionCallbackError.current = err;\n                } else {\n                    latestSubscriptionCallbackError.current = new Error(String(err));\n                }\n            }\n            forceRender();\n        }\n        var unsubscribe = addEventListener(checkForUpdates);\n        checkForUpdates();\n        return ()=>unsubscribe();\n    }, // don't rerender on equalityFn change since we want to be able to define it inline\n    [\n        addEventListener,\n        getSlate\n    ]);\n    return selectedState;\n}\n/**\n * Create selector context with editor updating on every editor change\n */ function useSelectorContext(editor) {\n    var eventListeners = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)([]).current;\n    var slateRef = (0,react__WEBPACK_IMPORTED_MODULE_3__.useRef)({\n        editor\n    }).current;\n    var onChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((editor)=>{\n        slateRef.editor = editor;\n        eventListeners.forEach((listener)=>listener(editor));\n    }, [\n        eventListeners,\n        slateRef\n    ]);\n    var selectorContext = (0,react__WEBPACK_IMPORTED_MODULE_3__.useMemo)(()=>{\n        return {\n            getSlate: ()=>slateRef.editor,\n            addEventListener: (callback)=>{\n                eventListeners.push(callback);\n                return ()=>{\n                    eventListeners.splice(eventListeners.indexOf(callback), 1);\n                };\n            }\n        };\n    }, [\n        eventListeners,\n        slateRef\n    ]);\n    return {\n        selectorContext,\n        onChange\n    };\n}\nvar REACT_MAJOR_VERSION = parseInt(react__WEBPACK_IMPORTED_MODULE_3___default().version.split(\".\")[0], 10);\nvar _excluded = [\n    \"editor\",\n    \"children\",\n    \"onChange\",\n    \"onSelectionChange\",\n    \"onValueChange\",\n    \"initialValue\"\n];\n/**\n * A wrapper around the provider to handle `onChange` events, because the editor\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\n */ var Slate = (props)=>{\n    var { editor, children, onChange, onSelectionChange, onValueChange, initialValue } = props, rest = _objectWithoutProperties(props, _excluded);\n    var [context, setContext] = react__WEBPACK_IMPORTED_MODULE_3___default().useState(()=>{\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Node.isNodeList(initialValue)) {\n            throw new Error(\"[Slate] initialValue is invalid! Expected a list of elements but got: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(initialValue)));\n        }\n        if (!slate__WEBPACK_IMPORTED_MODULE_7__.Editor.isEditor(editor)) {\n            throw new Error(\"[Slate] editor is invalid! You passed: \".concat(slate__WEBPACK_IMPORTED_MODULE_7__.Scrubber.stringify(editor)));\n        }\n        editor.children = initialValue;\n        Object.assign(editor, rest);\n        return {\n            v: 0,\n            editor\n        };\n    });\n    var { selectorContext, onChange: handleSelectorChange } = useSelectorContext(editor);\n    var onContextChange = (0,react__WEBPACK_IMPORTED_MODULE_3__.useCallback)((options)=>{\n        var _options$operation;\n        if (onChange) {\n            onChange(editor.children);\n        }\n        switch(options === null || options === void 0 || (_options$operation = options.operation) === null || _options$operation === void 0 ? void 0 : _options$operation.type){\n            case \"set_selection\":\n                onSelectionChange === null || onSelectionChange === void 0 || onSelectionChange(editor.selection);\n                break;\n            default:\n                onValueChange === null || onValueChange === void 0 || onValueChange(editor.children);\n        }\n        setContext((prevContext)=>({\n                v: prevContext.v + 1,\n                editor\n            }));\n        handleSelectorChange(editor);\n    }, [\n        editor,\n        handleSelectorChange,\n        onChange,\n        onSelectionChange,\n        onValueChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n        return ()=>{\n            slate_dom__WEBPACK_IMPORTED_MODULE_4__.EDITOR_TO_ON_CHANGE.set(editor, ()=>{});\n        };\n    }, [\n        editor,\n        onContextChange\n    ]);\n    var [isFocused, setIsFocused] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(ReactEditor.isFocused(editor));\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        setIsFocused(ReactEditor.isFocused(editor));\n    }, [\n        editor\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        var fn = ()=>setIsFocused(ReactEditor.isFocused(editor));\n        if (REACT_MAJOR_VERSION >= 17) {\n            // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n            // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n            // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n            document.addEventListener(\"focusin\", fn);\n            document.addEventListener(\"focusout\", fn);\n            return ()=>{\n                document.removeEventListener(\"focusin\", fn);\n                document.removeEventListener(\"focusout\", fn);\n            };\n        } else {\n            document.addEventListener(\"focus\", fn, true);\n            document.addEventListener(\"blur\", fn, true);\n            return ()=>{\n                document.removeEventListener(\"focus\", fn, true);\n                document.removeEventListener(\"blur\", fn, true);\n            };\n        }\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateSelectorContext.Provider, {\n        value: selectorContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(SlateContext.Provider, {\n        value: context\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(EditorContext.Provider, {\n        value: context.editor\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3___default().createElement(FocusedContext.Provider, {\n        value: isFocused\n    }, children))));\n};\n/**\n * Get the current editor object from the React context.\n * @deprecated Use useSlateStatic instead.\n */ var useEditor = ()=>{\n    var editor = (0,react__WEBPACK_IMPORTED_MODULE_3__.useContext)(EditorContext);\n    if (!editor) {\n        throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n    }\n    return editor;\n};\n/**\n * Get the current slate selection.\n * Only triggers a rerender when the selection actually changes\n */ var useSlateSelection = ()=>{\n    return useSlateSelector((editor)=>editor.selection, isSelectionEqual);\n};\nvar isSelectionEqual = (a, b)=>{\n    if (!a && !b) return true;\n    if (!a || !b) return false;\n    return slate__WEBPACK_IMPORTED_MODULE_7__.Range.equals(a, b);\n};\n/**\n * `withReact` adds React and DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */ var withReact = function withReact(editor) {\n    var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"x-slate-fragment\";\n    var e = editor;\n    e = (0,slate_dom__WEBPACK_IMPORTED_MODULE_4__.withDOM)(e, clipboardFormatKey);\n    var { onChange } = e;\n    e.onChange = (options)=>{\n        // COMPAT: React < 18 doesn't batch `setState` hook calls, which means\n        // that the children and selection can get out of sync for one render\n        // pass. So we have to use this unstable API to ensure it batches them.\n        // (2019/12/03)\n        // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n        var maybeBatchUpdates = REACT_MAJOR_VERSION < 18 ? (react_dom__WEBPACK_IMPORTED_MODULE_6___default().unstable_batchedUpdates) : (callback)=>callback();\n        maybeBatchUpdates(()=>{\n            onChange(options);\n        });\n    };\n    return e;\n};\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NsYXRlLXJlYWN0L2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0U7QUFDQTtBQUMrSDtBQUM5RztBQUM2RDtBQUM2M0I7QUFDeDdCO0FBQ0Q7QUFDeEI7QUFFakMsU0FBU29GLDhCQUE4QkMsTUFBTSxFQUFFQyxRQUFRO0lBQ3JELElBQUlELFVBQVUsTUFBTSxPQUFPLENBQUM7SUFDNUIsSUFBSUUsU0FBUyxDQUFDO0lBQ2QsSUFBSUMsYUFBYUMsT0FBT0MsSUFBSSxDQUFDTDtJQUM3QixJQUFJTSxLQUFLQztJQUNULElBQUtBLElBQUksR0FBR0EsSUFBSUosV0FBV0ssTUFBTSxFQUFFRCxJQUFLO1FBQ3RDRCxNQUFNSCxVQUFVLENBQUNJLEVBQUU7UUFDbkIsSUFBSU4sU0FBU1EsT0FBTyxDQUFDSCxRQUFRLEdBQUc7UUFDaENKLE1BQU0sQ0FBQ0ksSUFBSSxHQUFHTixNQUFNLENBQUNNLElBQUk7SUFDM0I7SUFDQSxPQUFPSjtBQUNUO0FBRUEsU0FBU1EseUJBQXlCVixNQUFNLEVBQUVDLFFBQVE7SUFDaEQsSUFBSUQsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJRSxTQUFTSCw4QkFBOEJDLFFBQVFDO0lBQ25ELElBQUlLLEtBQUtDO0lBQ1QsSUFBSUgsT0FBT08scUJBQXFCLEVBQUU7UUFDaEMsSUFBSUMsbUJBQW1CUixPQUFPTyxxQkFBcUIsQ0FBQ1g7UUFDcEQsSUFBS08sSUFBSSxHQUFHQSxJQUFJSyxpQkFBaUJKLE1BQU0sRUFBRUQsSUFBSztZQUM1Q0QsTUFBTU0sZ0JBQWdCLENBQUNMLEVBQUU7WUFDekIsSUFBSU4sU0FBU1EsT0FBTyxDQUFDSCxRQUFRLEdBQUc7WUFDaEMsSUFBSSxDQUFDRixPQUFPUyxTQUFTLENBQUNDLG9CQUFvQixDQUFDQyxJQUFJ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QyxHQUFHLE9BQU87SUFDckIsSUFBSSxDQUFDRCxLQUFLLENBQUNDLEdBQUcsT0FBTztJQUNyQixPQUFPbHFCLHdDQUFLQSxDQUFDa0osTUFBTSxDQUFDK2dCLEdBQUdDO0FBQ3pCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELElBQUk0QyxZQUFZLFNBQVNBLFVBQVVqbUIsTUFBTTtJQUN2QyxJQUFJa21CLHFCQUFxQnRsQixVQUFVOUMsTUFBTSxHQUFHLEtBQUs4QyxTQUFTLENBQUMsRUFBRSxLQUFLNUIsWUFBWTRCLFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDN0YsSUFBSVIsSUFBSUo7SUFDUkksSUFBSWxELGtEQUFPQSxDQUFDa0QsR0FBRzhsQjtJQUNmLElBQUksRUFDRjdoQixRQUFRLEVBQ1QsR0FBR2pFO0lBQ0pBLEVBQUVpRSxRQUFRLEdBQUd5RyxDQUFBQTtRQUNYLHNFQUFzRTtRQUN0RSxxRUFBcUU7UUFDckUsdUVBQXVFO1FBQ3ZFLGVBQWU7UUFDZix3RUFBd0U7UUFDeEUsSUFBSXFiLG9CQUFvQjFCLHNCQUFzQixLQUFLcm5CLDBFQUFnQyxHQUFHeU4sQ0FBQUEsV0FBWUE7UUFDbEdzYixrQkFBa0I7WUFDaEI5aEIsU0FBU3lHO1FBQ1g7SUFDRjtJQUNBLE9BQU8xSztBQUNUO0FBRWlQLENBQ2pQLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL25vZGVfbW9kdWxlcy9zbGF0ZS1yZWFjdC9kaXN0L2luZGV4LmVzLmpzPzI1N2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldERpcmVjdGlvbiBmcm9tICdkaXJlY3Rpb24nO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC9kZWJvdW5jZSc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoL3Rocm90dGxlJztcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSwgbWVtbywgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2ssIENvbXBvbmVudCwgdXNlUmVkdWNlciwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzY3JvbGxJbnRvVmlldyBmcm9tICdzY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZCc7XG5pbXBvcnQgeyBFZGl0b3IsIFJhbmdlLCBUcmFuc2Zvcm1zLCBOb2RlLCBUZXh0IGFzIFRleHQkMSwgUGF0aCwgUG9pbnQsIEVsZW1lbnQgYXMgRWxlbWVudCQxLCBTY3J1YmJlciB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IERPTUVkaXRvciwgRURJVE9SX1RPX1VTRVJfTUFSS1MsIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLCBFRElUT1JfVE9fUEVORElOR19BQ1RJT04sIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUywgdGFyZ2V0UmFuZ2UsIHZlcmlmeURpZmZTdGF0ZSwgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLCBJU19DT01QT1NJTkcsIElTX05PREVfTUFQX0RJUlRZLCBhcHBseVN0cmluZ0RpZmYsIGlzRE9NU2VsZWN0aW9uLCBpc1RyYWNrZWRNdXRhdGlvbiwgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUiwgbm9ybWFsaXplUmFuZ2UsIG5vcm1hbGl6ZVBvaW50LCBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVCwgbm9ybWFsaXplU3RyaW5nRGlmZiwgbWVyZ2VTdHJpbmdEaWZmcywgQ0FOX1VTRV9ET00sIElTX0FORFJPSUQsIEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSCwgTUFSS19QTEFDRUhPTERFUl9TWU1CT0wsIElTX0lPUywgUExBQ0VIT0xERVJfU1lNQk9MLCBJU19XRUJLSVQsIGlzVGV4dERlY29yYXRpb25zRXF1YWwsIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVCwgTk9ERV9UT19FTEVNRU5ULCBFTEVNRU5UX1RPX05PREUsIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwsIE5PREVfVE9fSU5ERVgsIE5PREVfVE9fUEFSRU5ULCBJU19SRUFEX09OTFksIGdldEFjdGl2ZUVsZW1lbnQsIGdldFNlbGVjdGlvbiwgSVNfRk9DVVNFRCwgZ2V0RGVmYXVsdFZpZXcsIEVESVRPUl9UT19XSU5ET1csIEVESVRPUl9UT19FTEVNRU5ULCBJU19GSVJFRk9YLCBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04sIEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCwgaXNET01FbGVtZW50LCBpc0RPTU5vZGUsIFRSSVBMRV9DTElDSywgSVNfRklSRUZPWF9MRUdBQ1ksIElTX1dFQ0hBVEJST1dTRVIsIElTX1VDX01PQklMRSwgSG90a2V5cywgSVNfQ0hST01FLCBpc1BsYWluVGV4dE9ubHlQYXN0ZSwgRURJVE9SX1RPX09OX0NIQU5HRSwgd2l0aERPTSB9IGZyb20gJ3NsYXRlLWRvbSc7XG5leHBvcnQgeyBOT0RFX1RPX0lOREVYLCBOT0RFX1RPX1BBUkVOVCB9IGZyb20gJ3NsYXRlLWRvbSc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlciB9IGZyb20gJ0BqdWdnbGUvcmVzaXplLW9ic2VydmVyJztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGVkaXRvciBvYmplY3QuXG4gKi9cbnZhciBFZGl0b3JDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXG4gKi9cbnZhciB1c2VTbGF0ZVN0YXRpYyA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG4gIGlmICghZWRpdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VTbGF0ZVN0YXRpY2AgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUmVhY3RFZGl0b3IgPSBET01FZGl0b3I7XG5cbmZ1bmN0aW9uIG93bktleXMkNShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ1KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ1KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZHJhZnQtanMvYmxvYi9tYWluL3NyYy9jb21wb25lbnQvaGFuZGxlcnMvY29tcG9zaXRpb24vRHJhZnRFZGl0b3JDb21wb3NpdGlvbkhhbmRsZXIuanMjTDQxXG4vLyBXaGVuIHVzaW5nIGtleWJvYXJkIEVuZ2xpc2ggYXNzb2NpYXRpb24gZnVuY3Rpb24sIGNvbnBvc2l0aW9uRW5kIHRyaWdnZXJlZCB0b28gZmFzdCwgcmVzdWx0aW5nIGluIGFmdGVyIGBpbnNlcnRUZXh0YCBzdGlsbCBtYWludGFpbiBhc3NvY2lhdGlvbiBzdGF0ZS5cbnZhciBSRVNPTFZFX0RFTEFZID0gMjU7XG4vLyBUaW1lIHdpdGggbm8gdXNlciBpbnRlcmFjdGlvbiBiZWZvcmUgdGhlIGN1cnJlbnQgdXNlciBhY3Rpb24gaXMgY29uc2lkZXJlZCBhcyBkb25lLlxudmFyIEZMVVNIX0RFTEFZID0gMjAwO1xuLy8gUmVwbGFjZSB3aXRoIGBjb25zdCBkZWJ1ZyA9IGNvbnNvbGUubG9nYCB0byBkZWJ1Z1xudmFyIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbi8vIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBhIERhdGFUcmFuc2ZlclxudmFyIGlzRGF0YVRyYW5zZmVyID0gdmFsdWUgPT4gKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSA9PT0gJ0RhdGFUcmFuc2Zlcic7XG5mdW5jdGlvbiBjcmVhdGVBbmRyb2lkSW5wdXRNYW5hZ2VyKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBlZGl0b3IsXG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSxcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZVxuICB9ID0gX3JlZjtcbiAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gIHZhciBjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCA9IG51bGw7XG4gIHZhciBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gIHZhciBhY3Rpb25UaW1lb3V0SWQgPSBudWxsO1xuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgdmFyIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICB2YXIgYXBwbHlQZW5kaW5nU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgIHZhciBwZW5kaW5nU2VsZWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlZGl0b3IpO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbikge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVSYW5nZShlZGl0b3IsIHBlbmRpbmdTZWxlY3Rpb24pO1xuICAgICAgaWYgKG5vcm1hbGl6ZWQgJiYgKCFzZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhub3JtYWxpemVkLCBzZWxlY3Rpb24pKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIG5vcm1hbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIHBlcmZvcm1BY3Rpb24gPSAoKSA9PiB7XG4gICAgdmFyIGFjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZWRpdG9yKTtcbiAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFjdGlvbi5hdCkge1xuICAgICAgdmFyIHRhcmdldCA9IFBvaW50LmlzUG9pbnQoYWN0aW9uLmF0KSA/IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgYWN0aW9uLmF0KSA6IG5vcm1hbGl6ZVJhbmdlKGVkaXRvciwgYWN0aW9uLmF0KTtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBfdGFyZ2V0UmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbiwgX3RhcmdldFJhbmdlKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGFjdGlvbi5ydW4oKTtcbiAgfTtcbiAgdmFyIGZsdXNoID0gKCkgPT4ge1xuICAgIGlmIChmbHVzaFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoVGltZW91dElkKTtcbiAgICAgIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGFjdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGFjdGlvblRpbWVvdXRJZCk7XG4gICAgICBhY3Rpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWhhc1BlbmRpbmdEaWZmcygpICYmICFoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGFwcGx5UGVuZGluZ1NlbGVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGZsdXNoaW5nID0gZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBmbHVzaGluZyA9ICdhY3Rpb24nO1xuICAgIH1cbiAgICB2YXIgc2VsZWN0aW9uUmVmID0gZWRpdG9yLnNlbGVjdGlvbiAmJiBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLCB7XG4gICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgfSk7XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1Muc2V0KGVkaXRvciwgZWRpdG9yLm1hcmtzKTtcbiAgICBkZWJ1ZygnZmx1c2gnLCBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGVkaXRvciksIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKTtcbiAgICB2YXIgc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UgPSBoYXNQZW5kaW5nRGlmZnMoKTtcbiAgICB2YXIgZGlmZjtcbiAgICB3aGlsZSAoZGlmZiA9IChfRURJVE9SX1RPX1BFTkRJTkdfREkgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19QRU5ESU5HX0RJID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1BFTkRJTkdfRElbMF0pIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREksIF9FRElUT1JfVE9fUEVORElOR19ESTI7XG4gICAgICB2YXIgcGVuZGluZ01hcmtzID0gRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpO1xuICAgICAgaWYgKHBlbmRpbmdNYXJrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0gcGVuZGluZ01hcmtzO1xuICAgICAgfVxuICAgICAgaWYgKHBlbmRpbmdNYXJrcyAmJiBpbnNlcnRQb3NpdGlvbkhpbnQgPT09IGZhbHNlKSB7XG4gICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcmFuZ2UgPSB0YXJnZXRSYW5nZShkaWZmKTtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKGVkaXRvci5zZWxlY3Rpb24sIHJhbmdlKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaWZmLmRpZmYudGV4dCkge1xuICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIGRpZmYuZGlmZi50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGRpZmYgb25seSBhZnRlciB3ZSBoYXZlIGFwcGxpZWQgaXQgdG8gYWNjb3VudCBmb3IgaXQgd2hlbiB0cmFuc2Zvcm1pbmdcbiAgICAgIC8vIHBlbmRpbmcgcmFuZ2VzLlxuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGVkaXRvciwgKF9FRElUT1JfVE9fUEVORElOR19ESTIgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19QRU5ESU5HX0RJMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19QRU5ESU5HX0RJMi5maWx0ZXIoX3JlZjIgPT4ge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGlkICE9PSBkaWZmLmlkO1xuICAgICAgfSkpO1xuICAgICAgaWYgKCF2ZXJpZnlEaWZmU3RhdGUoZWRpdG9yLCBkaWZmKSkge1xuICAgICAgICBzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBmbHVzaGluZyA9ICdhY3Rpb24nO1xuICAgICAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgcmVzdG9yZSB0aGUgcGVuZGluZyB1c2VyIChkb20pIHNlbGVjdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgZG9jdW1lbnQgYW5kIGRvbSBzdGF0ZSBkbyBub3QgbWF0Y2guXG4gICAgICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICAgICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgICAgIHNlbGVjdGlvblJlZiA9PT0gbnVsbCB8fCBzZWxlY3Rpb25SZWYgPT09IHZvaWQgMCB8fCBzZWxlY3Rpb25SZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvblJlZiA9PT0gbnVsbCB8fCBzZWxlY3Rpb25SZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvblJlZi51bnJlZigpO1xuICAgIGlmIChzZWxlY3Rpb24gJiYgIUVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5nZXQoZWRpdG9yKSAmJiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhzZWxlY3Rpb24sIGVkaXRvci5zZWxlY3Rpb24pKSkge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBwZXJmb3JtQWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENPTVBBVDogVGhlIHNlbGVjdGlvbkNoYW5nZSBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgYWN0aW9uIGlzIHBlcmZvcm1lZCxcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIG1hbnVhbGx5IHNjaGVkdWxlIGl0IHRvIGVuc3VyZSB3ZSBkb24ndCAndGhyb3cgYXdheScgdGhlIHNlbGVjdGlvblxuICAgIC8vIHdoaWxlIHJlbmRlcmluZyBpZiB3ZSBoYXZlIHBlbmRpbmcgY2hhbmdlcy5cbiAgICBpZiAoc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5mbHVzaCgpO1xuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgYXBwbHlQZW5kaW5nU2VsZWN0aW9uKCk7XG4gICAgdmFyIHVzZXJNYXJrcyA9IEVESVRPUl9UT19VU0VSX01BUktTLmdldChlZGl0b3IpO1xuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgIGlmICh1c2VyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWRpdG9yLm1hcmtzID0gdXNlck1hcmtzO1xuICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgfVxuICB9O1xuICB2YXIgaGFuZGxlQ29tcG9zaXRpb25FbmQgPSBfZXZlbnQgPT4ge1xuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICB9XG4gICAgY29tcG9zaXRpb25FbmRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICBmbHVzaCgpO1xuICAgIH0sIFJFU09MVkVfREVMQVkpO1xuICB9O1xuICB2YXIgaGFuZGxlQ29tcG9zaXRpb25TdGFydCA9IF9ldmVudCA9PiB7XG4gICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICAgIGNvbXBvc2l0aW9uRW5kVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIHZhciB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkoKSB7XG4gICAgdmFyIGZvcmNlSGlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIHBsYWNlaG9sZGVyRWxlbWVudCA9IEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgIGlmICghcGxhY2Vob2xkZXJFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBmb3JjZUhpZGUpIHtcbiAgICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwbGFjZWhvbGRlckVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2Rpc3BsYXknKTtcbiAgfTtcbiAgdmFyIHN0b3JlRGlmZiA9IChwYXRoLCBkaWZmKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTM7XG4gICAgdmFyIHBlbmRpbmdEaWZmcyA9IChfRURJVE9SX1RPX1BFTkRJTkdfREkzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTMgIT09IHZvaWQgMCA/IF9FRElUT1JfVE9fUEVORElOR19ESTMgOiBbXTtcbiAgICBFRElUT1JfVE9fUEVORElOR19ESUZGUy5zZXQoZWRpdG9yLCBwZW5kaW5nRGlmZnMpO1xuICAgIHZhciB0YXJnZXQgPSBOb2RlLmxlYWYoZWRpdG9yLCBwYXRoKTtcbiAgICB2YXIgaWR4ID0gcGVuZGluZ0RpZmZzLmZpbmRJbmRleChjaGFuZ2UgPT4gUGF0aC5lcXVhbHMoY2hhbmdlLnBhdGgsIHBhdGgpKTtcbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldC50ZXh0LCBkaWZmKTtcbiAgICAgIGlmIChub3JtYWxpemVkKSB7XG4gICAgICAgIHBlbmRpbmdEaWZmcy5wdXNoKHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgaWQ6IGlkQ291bnRlcisrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBtZXJnZWQgPSBtZXJnZVN0cmluZ0RpZmZzKHRhcmdldC50ZXh0LCBwZW5kaW5nRGlmZnNbaWR4XS5kaWZmLCBkaWZmKTtcbiAgICBpZiAoIW1lcmdlZCkge1xuICAgICAgcGVuZGluZ0RpZmZzLnNwbGljZShpZHgsIDEpO1xuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBlbmRpbmdEaWZmc1tpZHhdID0gX29iamVjdFNwcmVhZCQ1KF9vYmplY3RTcHJlYWQkNSh7fSwgcGVuZGluZ0RpZmZzW2lkeF0pLCB7fSwge1xuICAgICAgZGlmZjogbWVyZ2VkXG4gICAgfSk7XG4gIH07XG4gIHZhciBzY2hlZHVsZUFjdGlvbiA9IGZ1bmN0aW9uIHNjaGVkdWxlQWN0aW9uKHJ1bikge1xuICAgIHZhciB7XG4gICAgICBhdFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgIGlmIChoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGZsdXNoKCk7XG4gICAgfVxuICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5zZXQoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIHJ1blxuICAgIH0pO1xuICAgIC8vIENPTVBBVDogV2hlbiBkZWxldGluZyBiZWZvcmUgYSBub24tY29udGVudGVkaXRhYmxlIGVsZW1lbnQgY2hyb21lIG9ubHkgZmlyZXMgYSBiZWZvcmVpbnB1dCxcbiAgICAvLyAobm8gaW5wdXQpIGFuZCBkb2Vzbid0IHBlcmZvcm0gYW55IGRvbSBtdXRhdGlvbnMuIFdpdGhvdXQgYSBmbHVzaCB0aW1lb3V0IHdlIHdvdWxkIG5ldmVyIGZsdXNoXG4gICAgLy8gaW4gdGhpcyBjYXNlIGFuZCB0aHVzIG5ldmVyIGFjdHVhbGx5IHBlcmZvcm0gdGhlIGFjdGlvbi5cbiAgICBhY3Rpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZsdXNoKTtcbiAgfTtcbiAgdmFyIGhhbmRsZURPTUJlZm9yZUlucHV0ID0gZXZlbnQgPT4ge1xuICAgIHZhciBfdGFyZ2V0UmFuZ2UyO1xuICAgIGlmIChmbHVzaFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoVGltZW91dElkKTtcbiAgICAgIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKElTX05PREVfTUFQX0RJUlRZLmdldChlZGl0b3IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB7XG4gICAgICBpbnB1dFR5cGU6IHR5cGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgdmFyIHRhcmdldFJhbmdlID0gbnVsbDtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5kYXRhIHx8IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5zZXJ0UG9zaXRpb25IaW50ICE9PSBmYWxzZSAmJiB0eXBlICE9PSAnaW5zZXJ0VGV4dCcgJiYgdHlwZSAhPT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcpIHtcbiAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgW25hdGl2ZVRhcmdldFJhbmdlXSA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpO1xuICAgIGlmIChuYXRpdmVUYXJnZXRSYW5nZSkge1xuICAgICAgdGFyZ2V0UmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBuYXRpdmVUYXJnZXRSYW5nZSwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENPTVBBVDogU2VsZWN0aW9uQ2hhbmdlIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBhY3Rpb24gaXMgcGVyZm9ybWVkLCBzbyB3ZVxuICAgIC8vIGhhdmUgdG8gbWFudWFsbHkgZ2V0IHRoZSBzZWxlY3Rpb24gaGVyZSB0byBlbnN1cmUgaXQncyB1cC10by1kYXRlLlxuICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB2YXIgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghdGFyZ2V0UmFuZ2UgJiYgZG9tU2VsZWN0aW9uKSB7XG4gICAgICBuYXRpdmVUYXJnZXRSYW5nZSA9IGRvbVNlbGVjdGlvbjtcbiAgICAgIHRhcmdldFJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGFyZ2V0UmFuZ2UgPSAoX3RhcmdldFJhbmdlMiA9IHRhcmdldFJhbmdlKSAhPT0gbnVsbCAmJiBfdGFyZ2V0UmFuZ2UyICE9PSB2b2lkIDAgPyBfdGFyZ2V0UmFuZ2UyIDogZWRpdG9yLnNlbGVjdGlvbjtcbiAgICBpZiAoIXRhcmdldFJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSBpbnB1dCBtYW5hZ2VyIHRyaWVzIHRvIHN0b3JlIHRleHQgZGlmZnMgc28gdGhhdCB3ZSBjYW5cbiAgICAvLyBkZWZlciBmbHVzaGluZyB0aGVtIGF0IGEgbGF0ZXIgcG9pbnQgaW4gdGltZS4gV2UgZG9uJ3Qgd2FudCB0byBmbHVzaFxuICAgIC8vIGZvciBldmVyeSBpbnB1dCBldmVudCBhcyB0aGlzIGNhbiBiZSBleHBlbnNpdmUuIEhvd2V2ZXIsIHRoZXJlIGFyZSBzb21lXG4gICAgLy8gc2NlbmFyaW9zIHdoZXJlIHdlIGNhbm5vdCBzYWZlbHkgc3RvcmUgdGhlIHRleHQgZGlmZiBhbmQgbXVzdCBpbnN0ZWFkXG4gICAgLy8gc2NoZWR1bGUgYW4gYWN0aW9uIHRvIGxldCBTbGF0ZSBub3JtYWxpemUgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICB2YXIgY2FuU3RvcmVEaWZmID0gdHJ1ZTtcbiAgICBpZiAodHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQodGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIHZhciBbX3N0YXJ0LCBfZW5kXSA9IFJhbmdlLmVkZ2VzKHRhcmdldFJhbmdlKTtcbiAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKGVkaXRvciwgX3N0YXJ0LnBhdGgpO1xuICAgICAgICBpZiAoX2xlYWYudGV4dC5sZW5ndGggPT09IF9zdGFydC5vZmZzZXQgJiYgX2VuZC5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IEVkaXRvci5uZXh0KGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IF9zdGFydC5wYXRoLFxuICAgICAgICAgICAgbWF0Y2g6IFRleHQkMS5pc1RleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobmV4dCAmJiBQYXRoLmVxdWFscyhuZXh0WzFdLCBfZW5kLnBhdGgpKSB7XG4gICAgICAgICAgICB0YXJnZXRSYW5nZSA9IHtcbiAgICAgICAgICAgICAgYW5jaG9yOiBfZW5kLFxuICAgICAgICAgICAgICBmb2N1czogX2VuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlLmVuZHNXaXRoKCdCYWNrd2FyZCcpID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJztcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSk7XG4gICAgICB2YXIgW2xlYWYsIHBhdGhdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBzdGFydC5wYXRoKTtcbiAgICAgIHZhciBkaWZmID0ge1xuICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0Lm9mZnNldCxcbiAgICAgICAgZW5kOiBlbmQub2Zmc2V0XG4gICAgICB9O1xuICAgICAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICAgICAgdmFyIHJlbGV2YW50UGVuZGluZ0RpZmZzID0gcGVuZGluZ0RpZmZzID09PSBudWxsIHx8IHBlbmRpbmdEaWZmcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ0RpZmZzLmZpbmQoY2hhbmdlID0+IFBhdGguZXF1YWxzKGNoYW5nZS5wYXRoLCBwYXRoKSk7XG4gICAgICB2YXIgZGlmZnMgPSByZWxldmFudFBlbmRpbmdEaWZmcyA/IFtyZWxldmFudFBlbmRpbmdEaWZmcy5kaWZmLCBkaWZmXSA6IFtkaWZmXTtcbiAgICAgIHZhciB0ZXh0ID0gYXBwbHlTdHJpbmdEaWZmKGxlYWYudGV4dCwgLi4uZGlmZnMpO1xuICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFRleHQgbGVhZiB3aWxsIGJlIHJlbW92ZWQsIHNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgYW5cbiAgICAgICAgLy8gYWN0aW9uIHRvIHJlbW92ZSBpdCBzbyB0aGF0IFNsYXRlIGNhbiBub3JtYWxpemUgaW5zdGVhZFxuICAgICAgICAvLyBvZiBzdG9yaW5nIGFzIGEgZGlmZlxuICAgICAgICBjYW5TdG9yZURpZmYgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHRhcmdldFJhbmdlKSkge1xuICAgICAgICBpZiAoY2FuU3RvcmVEaWZmICYmIFBhdGguZXF1YWxzKHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLCB0YXJnZXRSYW5nZS5mb2N1cy5wYXRoKSkge1xuICAgICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICAgIHBhdGg6IHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydC5vZmZzZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBvaW50LCBwb2ludCk7XG4gICAgICAgICAgaGFuZGxlVXNlclNlbGVjdChyYW5nZSk7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlRGlmZih0YXJnZXRSYW5nZS5hbmNob3IucGF0aCwge1xuICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICBlbmQ6IGVuZC5vZmZzZXQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQub2Zmc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICBkaXJlY3Rpb25cbiAgICAgICAgfSksIHtcbiAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZGVsZXRlQnlDb21wb3NpdGlvbic6XG4gICAgICBjYXNlICdkZWxldGVCeUN1dCc6XG4gICAgICBjYXNlICdkZWxldGVCeURyYWcnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudCc6XG4gICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgYW5jaG9yXG4gICAgICAgICAgfSA9IHRhcmdldFJhbmdlO1xuICAgICAgICAgIGlmIChjYW5TdG9yZURpZmYgJiYgUmFuZ2UuaXNDb2xsYXBzZWQodGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIGFuY2hvci5wYXRoKTtcbiAgICAgICAgICAgIGlmIChhbmNob3Iub2Zmc2V0IDwgdGFyZ2V0Tm9kZS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gc3RvcmVEaWZmKGFuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGFuY2hvci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kOiBhbmNob3Iub2Zmc2V0ICsgMVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVDb250ZW50QmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9uYXRpdmVUYXJnZXRSYW5nZTtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgYW5jaG9yOiBfYW5jaG9yXG4gICAgICAgICAgfSA9IHRhcmdldFJhbmdlO1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBuYXRpdmUgYW5kIHNsYXRlIHNlbGVjdGlvbiBiZWluZyBjb2xsYXBzZWRcbiAgICAgICAgICAvLyB3ZSBhcmUgbW9zdCBsaWtlbHkgZGVsZXRpbmcgYSB6ZXJvLXdpZHRoIHBsYWNlaG9sZGVyIGFuZCB0aHVzIHNob3VsZCBwZXJmb3JtIGl0XG4gICAgICAgICAgLy8gYXMgYW4gYWN0aW9uIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yIChtb3N0bHkgaGFwcGVucyB3aXRoIG1hcmsgcGxhY2Vob2xkZXJzKVxuICAgICAgICAgIHZhciBuYXRpdmVDb2xsYXBzZWQgPSBpc0RPTVNlbGVjdGlvbihuYXRpdmVUYXJnZXRSYW5nZSkgPyBuYXRpdmVUYXJnZXRSYW5nZS5pc0NvbGxhcHNlZCA6ICEhKChfbmF0aXZlVGFyZ2V0UmFuZ2UgPSBuYXRpdmVUYXJnZXRSYW5nZSkgIT09IG51bGwgJiYgX25hdGl2ZVRhcmdldFJhbmdlICE9PSB2b2lkIDAgJiYgX25hdGl2ZVRhcmdldFJhbmdlLmNvbGxhcHNlZCk7XG4gICAgICAgICAgaWYgKGNhblN0b3JlRGlmZiAmJiBuYXRpdmVDb2xsYXBzZWQgJiYgUmFuZ2UuaXNDb2xsYXBzZWQodGFyZ2V0UmFuZ2UpICYmIF9hbmNob3Iub2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlRGlmZihfYW5jaG9yLnBhdGgsIHtcbiAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgIHN0YXJ0OiBfYW5jaG9yLm9mZnNldCAtIDEsXG4gICAgICAgICAgICAgIGVuZDogX2FuY2hvci5vZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVFbnRpcmVTb2Z0TGluZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4ge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lRm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVXb3JkRm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydExpbmVCcmVhayc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmluc2VydFNvZnRCcmVhayhlZGl0b3IpLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0UGFyYWdyYXBoJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydENvbXBvc2l0aW9uVGV4dCc6XG4gICAgICBjYXNlICdkZWxldGVDb21wb3NpdGlvblRleHQnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbUNvbXBvc2l0aW9uJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21Ecm9wJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21QYXN0ZSc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tWWFuayc6XG4gICAgICBjYXNlICdpbnNlcnRSZXBsYWNlbWVudFRleHQnOlxuICAgICAgY2FzZSAnaW5zZXJ0VGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaXNEYXRhVHJhbnNmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBSZWFjdEVkaXRvci5pbnNlcnREYXRhKGVkaXRvciwgZGF0YSksIHtcbiAgICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF90ZXh0ID0gZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB2b2lkIDAgPyBkYXRhIDogJyc7XG4gICAgICAgICAgLy8gQ09NUEFUOiBJZiB3ZSBhcmUgd3JpdGluZyBpbnNpZGUgYSBwbGFjZWhvbGRlciwgdGhlIGltZSBpbnNlcnRzIHRoZSB0ZXh0IGluc2lkZVxuICAgICAgICAgIC8vIHRoZSBwbGFjZWhvbGRlciBpdHNlbGYgYW5kIHRodXMgaW5jbHVkZXMgdGhlIHplcm8td2lkdGggc3BhY2UgaW5zaWRlIGVkaXQgZXZlbnRzLlxuICAgICAgICAgIGlmIChFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICAgIF90ZXh0ID0gX3RleHQucmVwbGFjZSgnXFx1RkVGRicsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUGFzdGVzIGZyb20gdGhlIEFuZHJvaWQgY2xpcGJvYXJkIHdpbGwgZ2VuZXJhdGUgYGluc2VydFRleHRgIGV2ZW50cy5cbiAgICAgICAgICAvLyBJZiB0aGUgY29waWVkIHRleHQgY29udGFpbnMgYW55IG5ld2xpbmVzLCBBbmRyb2lkIHdpbGwgYXBwZW5kIGFuXG4gICAgICAgICAgLy8gZXh0cmEgbmV3bGluZSB0byB0aGUgZW5kIG9mIHRoZSBjb3BpZWQgdGV4dC5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2luc2VydFRleHQnICYmIC8uKlxcbi4qXFxuJC8udGVzdChfdGV4dCkpIHtcbiAgICAgICAgICAgIF90ZXh0ID0gX3RleHQuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB0aGUgdGV4dCBpbmNsdWRlcyBhIG5ld2xpbmUsIHNwbGl0IGl0IGF0IG5ld2xpbmVzIGFuZCBwYXN0ZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHN0cmluZywgd2l0aCBzb2Z0IGJyZWFrcyBpbiBiZXR3ZWVuIGVhY2guXG4gICAgICAgICAgaWYgKF90ZXh0LmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIHBhcnRzID0gX3RleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKChsaW5lLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgbGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICBFZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLCB0YXJnZXRSYW5nZS5mb2N1cy5wYXRoKSkge1xuICAgICAgICAgICAgdmFyIFtfc3RhcnQyLCBfZW5kMl0gPSBSYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSk7XG4gICAgICAgICAgICB2YXIgX2RpZmYgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBfc3RhcnQyLm9mZnNldCxcbiAgICAgICAgICAgICAgZW5kOiBfZW5kMi5vZmZzZXQsXG4gICAgICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQ09NUEFUOiBTd2lmdGtleSBoYXMgYSB3ZWlyZCBidWcgd2hlcmUgdGhlIHRhcmdldCByYW5nZSBvZiB0aGUgMm5kIHdvcmRcbiAgICAgICAgICAgIC8vIGluc2VydGVkIGFmdGVyIGEgbWFyayBwbGFjZWhvbGRlciBpcyBpbnNlcnRlZCB3aXRoIGFuIGFuY2hvciBvZmZzZXQgb2ZmIGJ5IDEuXG4gICAgICAgICAgICAvLyBTbyB3cml0aW5nICdzb21lIHRleHQnIHdpbGwgcmVzdWx0IGluICdzb21lIHR0ZXh0Jy4gTHVja2lseSBhbGwgJ25vcm1hbCcgaW5zZXJ0XG4gICAgICAgICAgICAvLyB0ZXh0IGV2ZW50cyBhcmUgZmlyZWQgd2l0aCB0aGUgY29ycmVjdCB0YXJnZXQgcmFuZ2VzLCBvbmx5IHRoZSBmaW5hbCAnaW5zZXJ0Q29tcG9zaXRpb24nXG4gICAgICAgICAgICAvLyBpc24ndCwgc28gd2UgY2FuIGFkanVzdCB0aGUgdGFyZ2V0IHJhbmdlIHN0YXJ0IG9mZnNldCBpZiB3ZSBhcmUgY29uZmlkZW50IHRoaXMgaXMgdGhlXG4gICAgICAgICAgICAvLyBzd2lmdGtleSBpbnNlcnQgY2F1c2luZyB0aGUgaXNzdWUuXG4gICAgICAgICAgICBpZiAoX3RleHQgJiYgaW5zZXJ0UG9zaXRpb25IaW50ICYmIHR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnKSB7XG4gICAgICAgICAgICAgIHZhciBoaW50UG9zaXRpb24gPSBpbnNlcnRQb3NpdGlvbkhpbnQuc3RhcnQgKyBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dC5zZWFyY2goL1xcU3wkLyk7XG4gICAgICAgICAgICAgIHZhciBkaWZmUG9zaXRpb24gPSBfZGlmZi5zdGFydCArIF9kaWZmLnRleHQuc2VhcmNoKC9cXFN8JC8pO1xuICAgICAgICAgICAgICBpZiAoZGlmZlBvc2l0aW9uID09PSBoaW50UG9zaXRpb24gKyAxICYmIF9kaWZmLmVuZCA9PT0gaW5zZXJ0UG9zaXRpb25IaW50LnN0YXJ0ICsgaW5zZXJ0UG9zaXRpb25IaW50LnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgX2RpZmYuc3RhcnQgLT0gMTtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaW5zZXJ0VGV4dCcpIHtcbiAgICAgICAgICAgICAgaWYgKGluc2VydFBvc2l0aW9uSGludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IF9kaWZmO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluc2VydFBvc2l0aW9uSGludCAmJiBSYW5nZS5pc0NvbGxhcHNlZCh0YXJnZXRSYW5nZSkgJiYgaW5zZXJ0UG9zaXRpb25IaW50LmVuZCArIGluc2VydFBvc2l0aW9uSGludC50ZXh0Lmxlbmd0aCA9PT0gX3N0YXJ0Mi5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBfb2JqZWN0U3ByZWFkJDUoX29iamVjdFNwcmVhZCQ1KHt9LCBpbnNlcnRQb3NpdGlvbkhpbnQpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgdGV4dDogaW5zZXJ0UG9zaXRpb25IaW50LnRleHQgKyBfdGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5TdG9yZURpZmYpIHtcbiAgICAgICAgICAgICAgc3RvcmVEaWZmKF9zdGFydDIucGF0aCwgX2RpZmYpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIF90ZXh0KSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBoYXNQZW5kaW5nQWN0aW9uID0gKCkgPT4ge1xuICAgIHJldHVybiAhIUVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZWRpdG9yKTtcbiAgfTtcbiAgdmFyIGhhc1BlbmRpbmdEaWZmcyA9ICgpID0+IHtcbiAgICB2YXIgX0VESVRPUl9UT19QRU5ESU5HX0RJNDtcbiAgICByZXR1cm4gISEoKF9FRElUT1JfVE9fUEVORElOR19ESTQgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJNCAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESTQubGVuZ3RoKTtcbiAgfTtcbiAgdmFyIGhhc1BlbmRpbmdDaGFuZ2VzID0gKCkgPT4ge1xuICAgIHJldHVybiBoYXNQZW5kaW5nQWN0aW9uKCkgfHwgaGFzUGVuZGluZ0RpZmZzKCk7XG4gIH07XG4gIHZhciBpc0ZsdXNoaW5nID0gKCkgPT4ge1xuICAgIHJldHVybiBmbHVzaGluZztcbiAgfTtcbiAgdmFyIGhhbmRsZVVzZXJTZWxlY3QgPSByYW5nZSA9PiB7XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLnNldChlZGl0b3IsIHJhbmdlKTtcbiAgICBpZiAoZmx1c2hUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFRpbWVvdXRJZCk7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhdGhDaGFuZ2VkID0gIXNlbGVjdGlvbiB8fCAhUGF0aC5lcXVhbHMoc2VsZWN0aW9uLmFuY2hvci5wYXRoLCByYW5nZS5hbmNob3IucGF0aCk7XG4gICAgdmFyIHBhcmVudFBhdGhDaGFuZ2VkID0gIXNlbGVjdGlvbiB8fCAhUGF0aC5lcXVhbHMoc2VsZWN0aW9uLmFuY2hvci5wYXRoLnNsaWNlKDAsIC0xKSwgcmFuZ2UuYW5jaG9yLnBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBpZiAocGF0aENoYW5nZWQgJiYgaW5zZXJ0UG9zaXRpb25IaW50IHx8IHBhcmVudFBhdGhDaGFuZ2VkKSB7XG4gICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhdGhDaGFuZ2VkIHx8IGhhc1BlbmRpbmdEaWZmcygpKSB7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZmx1c2gsIEZMVVNIX0RFTEFZKTtcbiAgICB9XG4gIH07XG4gIHZhciBoYW5kbGVJbnB1dCA9ICgpID0+IHtcbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpIHx8ICFoYXNQZW5kaW5nRGlmZnMoKSkge1xuICAgICAgZmx1c2goKTtcbiAgICB9XG4gIH07XG4gIHZhciBoYW5kbGVLZXlEb3duID0gXyA9PiB7XG4gICAgLy8gQ09NUEFUOiBTd2lmdGtleSBjbG9zZXMgdGhlIGtleWJvYXJkIHdoZW4gdHlwaW5nIGluc2lkZSBhIGVtcHR5IG5vZGVcbiAgICAvLyBkaXJlY3RseSBuZXh0IHRvIGEgbm9uLWNvbnRlbnRlZGl0YWJsZSBlbGVtZW50ICg9IHRoZSBwbGFjZWhvbGRlcikuXG4gICAgLy8gVGhlIG9ubHkgZXZlbnQgZmlyZWQgc29vbiBlbm91Z2ggZm9yIHVzIHRvIGFsbG93IGhpZGluZyB0aGUgcGxhY2Vob2xkZXJcbiAgICAvLyB3aXRob3V0IHN3aWZ0a2V5IHBpY2tpbmcgaXQgdXAgaXMgdGhlIGtleWRvd24gZXZlbnQsIHNvIHdlIGhhdmUgdG8gaGlkZSBpdFxuICAgIC8vIGhlcmUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC80OTg4I2lzc3VlY29tbWVudC0xMjAxMDUwNTM1XG4gICAgaWYgKCFoYXNQZW5kaW5nRGlmZnMoKSkge1xuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KHRydWUpO1xuICAgICAgc2V0VGltZW91dCh1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkpO1xuICAgIH1cbiAgfTtcbiAgdmFyIHNjaGVkdWxlRmx1c2ggPSAoKSA9PiB7XG4gICAgaWYgKCFoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIGFjdGlvblRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZmx1c2gpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGhhbmRsZURvbU11dGF0aW9ucyA9IG11dGF0aW9ucyA9PiB7XG4gICAgaWYgKGhhc1BlbmRpbmdEaWZmcygpIHx8IGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobXV0YXRpb25zLnNvbWUobXV0YXRpb24gPT4gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBtdXRhdGlvbiwgbXV0YXRpb25zKSkpIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX0ZPUkNFX1JFTkQ7XG4gICAgICAvLyBDYXVzZSBhIHJlLXJlbmRlciB0byByZXN0b3JlIHRoZSBkb20gc3RhdGUgaWYgd2UgZW5jb3VudGVyIHRyYWNrZWQgbXV0YXRpb25zIHdpdGhvdXRcbiAgICAgIC8vIGEgY29ycmVzcG9uZGluZyBwZW5kaW5nIGFjdGlvbi5cbiAgICAgIChfRURJVE9SX1RPX0ZPUkNFX1JFTkQgPSBFRElUT1JfVE9fRk9SQ0VfUkVOREVSLmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX0ZPUkNFX1JFTkQgPT09IHZvaWQgMCB8fCBfRURJVE9SX1RPX0ZPUkNFX1JFTkQoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgZmx1c2gsXG4gICAgc2NoZWR1bGVGbHVzaCxcbiAgICBoYXNQZW5kaW5nRGlmZnMsXG4gICAgaGFzUGVuZGluZ0FjdGlvbixcbiAgICBoYXNQZW5kaW5nQ2hhbmdlcyxcbiAgICBpc0ZsdXNoaW5nLFxuICAgIGhhbmRsZVVzZXJTZWxlY3QsXG4gICAgaGFuZGxlQ29tcG9zaXRpb25FbmQsXG4gICAgaGFuZGxlQ29tcG9zaXRpb25TdGFydCxcbiAgICBoYW5kbGVET01CZWZvcmVJbnB1dCxcbiAgICBoYW5kbGVLZXlEb3duLFxuICAgIGhhbmRsZURvbU11dGF0aW9ucyxcbiAgICBoYW5kbGVJbnB1dFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VJc01vdW50ZWQoKSB7XG4gIHZhciBpc01vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBpc01vdW50ZWRSZWYuY3VycmVudDtcbn1cblxuLyoqXG4gKiBQcmV2ZW50IHdhcm5pbmcgb24gU1NSIGJ5IGZhbGxpbmcgYmFjayB0byB1c2VFZmZlY3Qgd2hlbiBET00gaXNuJ3QgYXZhaWxhYmxlXG4gKi9cbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIobm9kZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIFttdXRhdGlvbk9ic2VydmVyXSA9IHVzZVN0YXRlKCgpID0+IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIERpc2NhcmQgbXV0YXRpb25zIGNhdXNlZCBkdXJpbmcgcmVuZGVyIHBoYXNlLiBUaGlzIHdvcmtzIGR1ZSB0byByZWFjdCBjYWxsaW5nXG4gICAgLy8gdXNlTGF5b3V0RWZmZWN0IHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIHJlbmRlciBwaGFzZSBiZWZvcmUgdGhlIG5leHQgdGljay5cbiAgICBtdXRhdGlvbk9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbm9kZS5jdXJyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhdHRhY2ggTXV0YXRpb25PYnNlcnZlciwgYG5vZGVgIGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUobm9kZS5jdXJyZW50LCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFttdXRhdGlvbk9ic2VydmVyLCBub2RlLCBvcHRpb25zXSk7XG59XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcIm5vZGVcIl07XG5mdW5jdGlvbiBvd25LZXlzJDQoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyQxID0ge1xuICBzdWJ0cmVlOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWVcbn07XG52YXIgdXNlQW5kcm9pZElucHV0TWFuYWdlciA9ICFJU19BTkRST0lEID8gKCkgPT4gbnVsbCA6IF9yZWYgPT4ge1xuICB2YXIge1xuICAgICAgbm9kZVxuICAgIH0gPSBfcmVmLFxuICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDIpO1xuICBpZiAoIUlTX0FORFJPSUQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpO1xuICB2YXIgW2lucHV0TWFuYWdlcl0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVBbmRyb2lkSW5wdXRNYW5hZ2VyKF9vYmplY3RTcHJlYWQkNCh7XG4gICAgZWRpdG9yXG4gIH0sIG9wdGlvbnMpKSk7XG4gIHVzZU11dGF0aW9uT2JzZXJ2ZXIobm9kZSwgaW5wdXRNYW5hZ2VyLmhhbmRsZURvbU11dGF0aW9ucywgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHJDEpO1xuICBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0guc2V0KGVkaXRvciwgaW5wdXRNYW5hZ2VyLnNjaGVkdWxlRmx1c2gpO1xuICBpZiAoaXNNb3VudGVkKSB7XG4gICAgaW5wdXRNYW5hZ2VyLmZsdXNoKCk7XG4gIH1cbiAgcmV0dXJuIGlucHV0TWFuYWdlcjtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDMoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vKipcbiAqIExlYWYgY29udGVudCBzdHJpbmdzLlxuICovXG52YXIgU3RyaW5nJDEgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgaXNMYXN0LFxuICAgIGxlYWYsXG4gICAgcGFyZW50LFxuICAgIHRleHRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIHRleHQpO1xuICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICB2YXIgaXNNYXJrUGxhY2Vob2xkZXIgPSBCb29sZWFuKGxlYWZbTUFSS19QTEFDRUhPTERFUl9TWU1CT0xdKTtcbiAgLy8gQ09NUEFUOiBSZW5kZXIgdGV4dCBpbnNpZGUgdm9pZCBub2RlcyB3aXRoIGEgemVyby13aWR0aCBzcGFjZS5cbiAgLy8gU28gdGhlIG5vZGUgY2FuIGNvbnRhaW4gc2VsZWN0aW9uIGJ1dCB0aGUgdGV4dCBpcyBub3QgdmlzaWJsZS5cbiAgaWYgKGVkaXRvci5pc1ZvaWQocGFyZW50KSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGxlbmd0aDogTm9kZS5zdHJpbmcocGFyZW50KS5sZW5ndGhcbiAgICB9KTtcbiAgfVxuICAvLyBDT01QQVQ6IElmIHRoaXMgaXMgdGhlIGxhc3QgdGV4dCBub2RlIGluIGFuIGVtcHR5IGJsb2NrLCByZW5kZXIgYSB6ZXJvLVxuICAvLyB3aWR0aCBzcGFjZSB0aGF0IHdpbGwgY29udmVydCBpbnRvIGEgbGluZSBicmVhayB3aGVuIGNvcHlpbmcgYW5kIHBhc3RpbmdcbiAgLy8gdG8gc3VwcG9ydCBleHBlY3RlZCBwbGFpbiB0ZXh0LlxuICBpZiAobGVhZi50ZXh0ID09PSAnJyAmJiBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdID09PSB0ZXh0ICYmICFlZGl0b3IuaXNJbmxpbmUocGFyZW50KSAmJiBFZGl0b3Iuc3RyaW5nKGVkaXRvciwgcGFyZW50UGF0aCkgPT09ICcnKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywge1xuICAgICAgaXNMaW5lQnJlYWs6IHRydWUsXG4gICAgICBpc01hcmtQbGFjZWhvbGRlcjogaXNNYXJrUGxhY2Vob2xkZXJcbiAgICB9KTtcbiAgfVxuICAvLyBDT01QQVQ6IElmIHRoZSB0ZXh0IGlzIGVtcHR5LCBpdCdzIGJlY2F1c2UgaXQncyBvbiB0aGUgZWRnZSBvZiBhbiBpbmxpbmVcbiAgLy8gbm9kZSwgc28gd2UgcmVuZGVyIGEgemVyby13aWR0aCBzcGFjZSBzbyB0aGF0IHRoZSBzZWxlY3Rpb24gY2FuIGJlXG4gIC8vIGluc2VydGVkIG5leHQgdG8gaXQgc3RpbGwuXG4gIGlmIChsZWFmLnRleHQgPT09ICcnKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywge1xuICAgICAgaXNNYXJrUGxhY2Vob2xkZXI6IGlzTWFya1BsYWNlaG9sZGVyXG4gICAgfSk7XG4gIH1cbiAgLy8gQ09NUEFUOiBCcm93c2VycyB3aWxsIGNvbGxhcHNlIHRyYWlsaW5nIG5ldyBsaW5lcyBhdCB0aGUgZW5kIG9mIGJsb2NrcyxcbiAgLy8gc28gd2UgbmVlZCB0byBhZGQgYW4gZXh0cmEgdHJhaWxpbmcgbmV3IGxpbmVzIHRvIHByZXZlbnQgdGhhdC5cbiAgaWYgKGlzTGFzdCAmJiBsZWFmLnRleHQuc2xpY2UoLTEpID09PSAnXFxuJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0U3RyaW5nLCB7XG4gICAgICBpc1RyYWlsaW5nOiB0cnVlLFxuICAgICAgdGV4dDogbGVhZi50ZXh0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRleHRTdHJpbmcsIHtcbiAgICB0ZXh0OiBsZWFmLnRleHRcbiAgfSk7XG59O1xuLyoqXG4gKiBMZWFmIHN0cmluZ3Mgd2l0aCB0ZXh0IGluIHRoZW0uXG4gKi9cbnZhciBUZXh0U3RyaW5nID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIHRleHQsXG4gICAgaXNUcmFpbGluZyA9IGZhbHNlXG4gIH0gPSBwcm9wcztcbiAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGdldFRleHRDb250ZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0ZXh0ICE9PSBudWxsICYmIHRleHQgIT09IHZvaWQgMCA/IHRleHQgOiAnJykuY29uY2F0KGlzVHJhaWxpbmcgPyAnXFxuJyA6ICcnKTtcbiAgfTtcbiAgdmFyIFtpbml0aWFsVGV4dF0gPSB1c2VTdGF0ZShnZXRUZXh0Q29udGVudCk7XG4gIC8vIFRoaXMgaXMgdGhlIGFjdHVhbCB0ZXh0IHJlbmRlcmluZyBib3VuZGFyeSB3aGVyZSB3ZSBpbnRlcmZhY2Ugd2l0aCB0aGUgRE9NXG4gIC8vIFRoZSB0ZXh0IGlzIG5vdCByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSB2aXJ0dWFsIERPTSwgYXMgc2luY2Ugd2UgaGFuZGxlIGJhc2ljIGNoYXJhY3RlciBpbnNlcnRpb25zIG5hdGl2ZWx5LFxuICAvLyB1cGRhdGluZyB0aGUgRE9NIGlzIG5vdCBhIG9uZSB3YXkgZGF0YWZsb3cgYW55bW9yZS4gV2hhdCB3ZSBuZWVkIGhlcmUgaXMgbm90IHJlY29uY2lsaWF0aW9uIGFuZCBkaWZmaW5nXG4gIC8vIHdpdGggcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgdmlydHVhbCBET00sIGJ1dCByYXRoZXIgZGlmZmluZyB3aXRoIHRoZSBhY3R1YWwgRE9NIGVsZW1lbnQsIGFuZCByZXBsYWNlIHRoZSBET00gPHNwYW4+IGNvbnRlbnRcbiAgLy8gZXhhY3RseSBpZiBhbmQgb25seSBpZiBpdHMgY3VycmVudCBjb250ZW50IGRvZXMgbm90IG1hdGNoIG91ciBjdXJyZW50IHZpcnR1YWwgRE9NLlxuICAvLyBPdGhlcndpc2UgdGhlIERPTSBUZXh0Tm9kZSB3b3VsZCBhbHdheXMgYmUgcmVwbGFjZWQgYnkgUmVhY3QgYXMgdGhlIHVzZXIgdHlwZXMsIHdoaWNoIGludGVyZmVyZXMgd2l0aCBuYXRpdmUgdGV4dCBmZWF0dXJlcyxcbiAgLy8gZWcgbWFrZXMgbmF0aXZlIHNwZWxsY2hlY2sgb3B0IG91dCBmcm9tIGNoZWNraW5nIHRoZSB0ZXh0IG5vZGUuXG4gIC8vIHVzZUxheW91dEVmZmVjdDogdXBkYXRpbmcgb3VyIHNwYW4gYmVmb3JlIGJyb3dzZXIgcGFpbnRcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgLy8gbnVsbCBjb2FsZXNjaW5nIHRleHQgdG8gbWFrZSBzdXJlIHdlJ3JlIG5vdCBvdXRwdXRpbmcgXCJudWxsXCIgYXMgYSBzdHJpbmcgaW4gdGhlIGV4dHJlbWUgY2FzZSBpdCBpcyBudWxsaXNoIGF0IHJ1bnRpbWVcbiAgICB2YXIgdGV4dFdpdGhUcmFpbGluZyA9IGdldFRleHRDb250ZW50KCk7XG4gICAgaWYgKHJlZi5jdXJyZW50ICYmIHJlZi5jdXJyZW50LnRleHRDb250ZW50ICE9PSB0ZXh0V2l0aFRyYWlsaW5nKSB7XG4gICAgICByZWYuY3VycmVudC50ZXh0Q29udGVudCA9IHRleHRXaXRoVHJhaWxpbmc7XG4gICAgfVxuICAgIC8vIGludGVudGlvbmFsbHkgbm90IHNwZWNpZnlpbmcgZGVwZW5kZW5jaWVzLCBzbyB0aGF0IHRoaXMgZWZmZWN0IHJ1bnMgb24gZXZlcnkgcmVuZGVyXG4gICAgLy8gYXMgdGhpcyBlZmZlY3RpdmVseSByZXBsYWNlcyBcInNwZWNpZnlpbmcgdGhlIHRleHQgaW4gdGhlIHZpcnR1YWwgRE9NIHVuZGVyIHRoZSA8c3Bhbj4gYmVsb3dcIiBvbiBlYWNoIHJlbmRlclxuICB9KTtcbiAgLy8gV2UgaW50ZW50aW9uYWxseSByZW5kZXIgYSBtZW1vaXplZCA8c3Bhbj4gdGhhdCBvbmx5IHJlY2VpdmVzIHRoZSBpbml0aWFsIHRleHQgY29udGVudCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgLy8gV2UgZGVmZXIgdG8gdGhlIGxheW91dCBlZmZlY3QgYWJvdmUgdG8gdXBkYXRlIHRoZSBgdGV4dENvbnRlbnRgIG9mIHRoZSBzcGFuIGVsZW1lbnQgd2hlbiBuZWVkZWQuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZFRleHQkMSwge1xuICAgIHJlZjogcmVmXG4gIH0sIGluaXRpYWxUZXh0KTtcbn07XG52YXIgTWVtb2l6ZWRUZXh0JDEgPSAvKiNfX1BVUkVfXyovbWVtbyggLyojX19QVVJFX18qL2ZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJkYXRhLXNsYXRlLXN0cmluZ1wiOiB0cnVlLFxuICAgIHJlZjogcmVmXG4gIH0sIHByb3BzLmNoaWxkcmVuKTtcbn0pKTtcbi8qKlxuICogTGVhZiBzdHJpbmdzIHdpdGhvdXQgdGV4dCwgcmVuZGVyIGFzIHplcm8td2lkdGggc3RyaW5ncy5cbiAqL1xudmFyIFplcm9XaWR0aFN0cmluZyA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBsZW5ndGggPSAwLFxuICAgIGlzTGluZUJyZWFrID0gZmFsc2UsXG4gICAgaXNNYXJrUGxhY2Vob2xkZXIgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICdkYXRhLXNsYXRlLXplcm8td2lkdGgnOiBpc0xpbmVCcmVhayA/ICduJyA6ICd6JyxcbiAgICAnZGF0YS1zbGF0ZS1sZW5ndGgnOiBsZW5ndGhcbiAgfTtcbiAgaWYgKGlzTWFya1BsYWNlaG9sZGVyKSB7XG4gICAgYXR0cmlidXRlc1snZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJ10gPSB0cnVlO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgX29iamVjdFNwcmVhZCQzKHt9LCBhdHRyaWJ1dGVzKSwgIShJU19BTkRST0lEIHx8IElTX0lPUykgfHwgIWlzTGluZUJyZWFrID8gJ1xcdUZFRkYnIDogbnVsbCwgaXNMaW5lQnJlYWsgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpIDogbnVsbCk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDIoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gRGVsYXkgdGhlIHBsYWNlaG9sZGVyIG9uIEFuZHJvaWQgdG8gcHJldmVudCB0aGUga2V5Ym9hcmQgZnJvbSBjbG9zaW5nLlxuLy8gKGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9wdWxsLzUzNjgpXG52YXIgUExBQ0VIT0xERVJfREVMQVkgPSBJU19BTkRST0lEID8gMzAwIDogMDtcbmZ1bmN0aW9uIGRpc2Nvbm5lY3RQbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyKHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIsIHJlbGVhc2VPYnNlcnZlcikge1xuICBpZiAocGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50KSB7XG4gICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICBpZiAocmVsZWFzZU9ic2VydmVyKSB7XG4gICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJUaW1lb3V0UmVmKHRpbWVvdXRSZWYpIHtcbiAgaWYgKHRpbWVvdXRSZWYuY3VycmVudCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gIH1cbn1cbi8qKlxuICogSW5kaXZpZHVhbCBsZWF2ZXMgaW4gYSB0ZXh0IG5vZGUgd2l0aCB1bmlxdWUgZm9ybWF0dGluZy5cbiAqL1xudmFyIExlYWYgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgbGVhZixcbiAgICBpc0xhc3QsXG4gICAgdGV4dCxcbiAgICBwYXJlbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZiA9IHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRMZWFmLCBfb2JqZWN0U3ByZWFkJDIoe30sIHByb3BzKSlcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBwbGFjZWhvbGRlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIFtzaG93UGxhY2Vob2xkZXIsIHNldFNob3dQbGFjZWhvbGRlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIHZhciBzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmID0gdXNlUmVmKG51bGwpO1xuICB2YXIgY2FsbGJhY2tQbGFjZWhvbGRlclJlZiA9IHVzZUNhbGxiYWNrKHBsYWNlaG9sZGVyRWwgPT4ge1xuICAgIGRpc2Nvbm5lY3RQbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyKHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIsIHBsYWNlaG9sZGVyRWwgPT0gbnVsbCk7XG4gICAgaWYgKHBsYWNlaG9sZGVyRWwgPT0gbnVsbCkge1xuICAgICAgdmFyIF9sZWFmJG9uUGxhY2Vob2xkZXJSZTtcbiAgICAgIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgICAgKF9sZWFmJG9uUGxhY2Vob2xkZXJSZSA9IGxlYWYub25QbGFjZWhvbGRlclJlc2l6ZSkgPT09IG51bGwgfHwgX2xlYWYkb25QbGFjZWhvbGRlclJlID09PSB2b2lkIDAgfHwgX2xlYWYkb25QbGFjZWhvbGRlclJlLmNhbGwobGVhZiwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULnNldChlZGl0b3IsIHBsYWNlaG9sZGVyRWwpO1xuICAgICAgaWYgKCFwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9ic2VydmVyIGFuZCBvYnNlcnZlIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50LlxuICAgICAgICB2YXIgUmVzaXplT2JzZXJ2ZXIkMSA9IHdpbmRvdy5SZXNpemVPYnNlcnZlciB8fCBSZXNpemVPYnNlcnZlcjtcbiAgICAgICAgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50ID0gbmV3IFJlc2l6ZU9ic2VydmVyJDEoKCkgPT4ge1xuICAgICAgICAgIHZhciBfbGVhZiRvblBsYWNlaG9sZGVyUmUyO1xuICAgICAgICAgIChfbGVhZiRvblBsYWNlaG9sZGVyUmUyID0gbGVhZi5vblBsYWNlaG9sZGVyUmVzaXplKSA9PT0gbnVsbCB8fCBfbGVhZiRvblBsYWNlaG9sZGVyUmUyID09PSB2b2lkIDAgfHwgX2xlYWYkb25QbGFjZWhvbGRlclJlMi5jYWxsKGxlYWYsIHBsYWNlaG9sZGVyRWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudC5vYnNlcnZlKHBsYWNlaG9sZGVyRWwpO1xuICAgICAgcGxhY2Vob2xkZXJSZWYuY3VycmVudCA9IHBsYWNlaG9sZGVyRWw7XG4gICAgfVxuICB9LCBbcGxhY2Vob2xkZXJSZWYsIGxlYWYsIGVkaXRvcl0pO1xuICB2YXIgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTdHJpbmckMSwge1xuICAgIGlzTGFzdDogaXNMYXN0LFxuICAgIGxlYWY6IGxlYWYsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgdGV4dDogdGV4dFxuICB9KTtcbiAgdmFyIGxlYWZJc1BsYWNlaG9sZGVyID0gQm9vbGVhbihsZWFmW1BMQUNFSE9MREVSX1NZTUJPTF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChsZWFmSXNQbGFjZWhvbGRlcikge1xuICAgICAgaWYgKCFzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gRGVsYXkgdGhlIHBsYWNlaG9sZGVyLCBzbyBpdCB3aWxsIG5vdCByZW5kZXIgaW4gYSBzZWxlY3Rpb25cbiAgICAgICAgc2hvd1BsYWNlaG9sZGVyVGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgc2V0U2hvd1BsYWNlaG9sZGVyKHRydWUpO1xuICAgICAgICAgIHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH0sIFBMQUNFSE9MREVSX0RFTEFZKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJUaW1lb3V0UmVmKHNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYpO1xuICAgICAgc2V0U2hvd1BsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dFJlZihzaG93UGxhY2Vob2xkZXJUaW1lb3V0UmVmKTtcbiAgfSwgW2xlYWZJc1BsYWNlaG9sZGVyLCBzZXRTaG93UGxhY2Vob2xkZXJdKTtcbiAgaWYgKGxlYWZJc1BsYWNlaG9sZGVyICYmIHNob3dQbGFjZWhvbGRlcikge1xuICAgIHZhciBwbGFjZWhvbGRlclByb3BzID0ge1xuICAgICAgY2hpbGRyZW46IGxlYWYucGxhY2Vob2xkZXIsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICdkYXRhLXNsYXRlLXBsYWNlaG9sZGVyJzogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgIG9wYWNpdHk6ICcwLjMzMycsXG4gICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXG4gICAgICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3VkZWNvZGUvcGxhdGUvaXNzdWVzLzIzMTVcbiAgICAgICAgICBXZWJraXRVc2VyTW9kaWZ5OiBJU19XRUJLSVQgPyAnaW5oZXJpdCcgOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgY29udGVudEVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgcmVmOiBjYWxsYmFja1BsYWNlaG9sZGVyUmVmXG4gICAgICB9XG4gICAgfTtcbiAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCByZW5kZXJQbGFjZWhvbGRlcihwbGFjZWhvbGRlclByb3BzKSwgY2hpbGRyZW4pO1xuICB9XG4gIC8vIENPTVBBVDogSGF2aW5nIHRoZSBgZGF0YS1gIGF0dHJpYnV0ZXMgb24gdGhlc2UgbGVhZiBlbGVtZW50cyBlbnN1cmVzIHRoYXRcbiAgLy8gaW4gY2VydGFpbiBtaXNiZWhhdmluZyBicm93c2VycyB0aGV5IGFyZW4ndCB3ZWlyZGx5IGNsb25lZC9kZXN0cm95ZWQgYnlcbiAgLy8gY29udGVudGVkaXRhYmxlIGJlaGF2aW9ycy4gKDIwMTkvMDUvMDgpXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICdkYXRhLXNsYXRlLWxlYWYnOiB0cnVlXG4gIH07XG4gIHJldHVybiByZW5kZXJMZWFmKHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGxlYWYsXG4gICAgdGV4dFxuICB9KTtcbn07XG52YXIgTWVtb2l6ZWRMZWFmID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oTGVhZiwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIG5leHQucGFyZW50ID09PSBwcmV2LnBhcmVudCAmJiBuZXh0LmlzTGFzdCA9PT0gcHJldi5pc0xhc3QgJiYgbmV4dC5yZW5kZXJMZWFmID09PSBwcmV2LnJlbmRlckxlYWYgJiYgbmV4dC5yZW5kZXJQbGFjZWhvbGRlciA9PT0gcHJldi5yZW5kZXJQbGFjZWhvbGRlciAmJiBuZXh0LnRleHQgPT09IHByZXYudGV4dCAmJiBUZXh0JDEuZXF1YWxzKG5leHQubGVhZiwgcHJldi5sZWFmKSAmJiBuZXh0LmxlYWZbUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gcHJldi5sZWFmW1BMQUNFSE9MREVSX1NZTUJPTF07XG59KTtcbnZhciBEZWZhdWx0TGVhZiA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBwcm9wcztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfb2JqZWN0U3ByZWFkJDIoe30sIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbik7XG59O1xuXG4vKipcbiAqIFRleHQuXG4gKi9cbnZhciBUZXh0ID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGRlY29yYXRpb25zLFxuICAgIGlzTGFzdCxcbiAgICBwYXJlbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICB0ZXh0XG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBsZWF2ZXMgPSBUZXh0JDEuZGVjb3JhdGlvbnModGV4dCwgZGVjb3JhdGlvbnMpO1xuICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIHRleHQpO1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZWF2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGVhZiA9IGxlYXZlc1tpXTtcbiAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZExlYWYsIHtcbiAgICAgIGlzTGFzdDogaXNMYXN0ICYmIGkgPT09IGxlYXZlcy5sZW5ndGggLSAxLFxuICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXkuaWQsIFwiLVwiKS5jb25jYXQoaSksXG4gICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICBsZWFmOiBsZWFmLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZlxuICAgIH0pKTtcbiAgfVxuICAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG4gIHZhciBjYWxsYmFja1JlZiA9IHVzZUNhbGxiYWNrKHNwYW4gPT4ge1xuICAgIHZhciBLRVlfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICBpZiAoc3Bhbikge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCB8fCBLRVlfVE9fRUxFTUVOVC5zZXQoa2V5LCBzcGFuKTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5zZXQodGV4dCwgc3Bhbik7XG4gICAgICBFTEVNRU5UX1RPX05PREUuc2V0KHNwYW4sIHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwIHx8IEtFWV9UT19FTEVNRU5ULmRlbGV0ZShrZXkpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZSh0ZXh0KTtcbiAgICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgICBFTEVNRU5UX1RPX05PREUuZGVsZXRlKHJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVmLmN1cnJlbnQgPSBzcGFuO1xuICB9LCBbcmVmLCBlZGl0b3IsIGtleSwgdGV4dF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImRhdGEtc2xhdGUtbm9kZVwiOiBcInRleHRcIixcbiAgICByZWY6IGNhbGxiYWNrUmVmXG4gIH0sIGNoaWxkcmVuKTtcbn07XG52YXIgTWVtb2l6ZWRUZXh0ID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oVGV4dCwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIG5leHQucGFyZW50ID09PSBwcmV2LnBhcmVudCAmJiBuZXh0LmlzTGFzdCA9PT0gcHJldi5pc0xhc3QgJiYgbmV4dC5yZW5kZXJMZWFmID09PSBwcmV2LnJlbmRlckxlYWYgJiYgbmV4dC5yZW5kZXJQbGFjZWhvbGRlciA9PT0gcHJldi5yZW5kZXJQbGFjZWhvbGRlciAmJiBuZXh0LnRleHQgPT09IHByZXYudGV4dCAmJiBpc1RleHREZWNvcmF0aW9uc0VxdWFsKG5leHQuZGVjb3JhdGlvbnMsIHByZXYuZGVjb3JhdGlvbnMpO1xufSk7XG5cbmZ1bmN0aW9uIG93bktleXMkMShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQxKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQxKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vKipcbiAqIEVsZW1lbnQuXG4gKi9cbnZhciBFbGVtZW50ID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGRlY29yYXRpb25zLFxuICAgIGVsZW1lbnQsXG4gICAgcmVuZGVyRWxlbWVudCA9IHAgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdEVsZW1lbnQsIF9vYmplY3RTcHJlYWQkMSh7fSwgcCkpLFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uXG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciByZWFkT25seSA9IHVzZVJlYWRPbmx5KCk7XG4gIHZhciBpc0lubGluZSA9IGVkaXRvci5pc0lubGluZShlbGVtZW50KTtcbiAgdmFyIGtleSA9IFJlYWN0RWRpdG9yLmZpbmRLZXkoZWRpdG9yLCBlbGVtZW50KTtcbiAgdmFyIHJlZiA9IHVzZUNhbGxiYWNrKHJlZiA9PiB7XG4gICAgLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuICAgIHZhciBLRVlfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICBpZiAocmVmKSB7XG4gICAgICBLRVlfVE9fRUxFTUVOVCA9PT0gbnVsbCB8fCBLRVlfVE9fRUxFTUVOVCA9PT0gdm9pZCAwIHx8IEtFWV9UT19FTEVNRU5ULnNldChrZXksIHJlZik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuc2V0KGVsZW1lbnQsIHJlZik7XG4gICAgICBFTEVNRU5UX1RPX05PREUuc2V0KHJlZiwgZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgfHwgS0VZX1RPX0VMRU1FTlQuZGVsZXRlKGtleSk7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKGVsZW1lbnQpO1xuICAgIH1cbiAgfSwgW2VkaXRvciwga2V5LCBlbGVtZW50XSk7XG4gIHZhciBjaGlsZHJlbiA9IHVzZUNoaWxkcmVuKHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBub2RlOiBlbGVtZW50LFxuICAgIHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb25cbiAgfSk7XG4gIC8vIEF0dHJpYnV0ZXMgdGhhdCB0aGUgZGV2ZWxvcGVyIG11c3QgbWl4IGludG8gdGhlIGVsZW1lbnQgaW4gdGhlaXJcbiAgLy8gY3VzdG9tIG5vZGUgcmVuZGVyZXIgY29tcG9uZW50LlxuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS1ub2RlJzogJ2VsZW1lbnQnLFxuICAgIHJlZlxuICB9O1xuICBpZiAoaXNJbmxpbmUpIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNsYXRlLWlubGluZSddID0gdHJ1ZTtcbiAgfVxuICAvLyBJZiBpdCdzIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZSBjaGlsZHJlbiwgYWRkIHRoZSBwcm9wZXIgYGRpcmAgYXR0cmlidXRlXG4gIC8vIGZvciB0ZXh0IGRpcmVjdGlvbi5cbiAgaWYgKCFpc0lubGluZSAmJiBFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpKSB7XG4gICAgdmFyIHRleHQgPSBOb2RlLnN0cmluZyhlbGVtZW50KTtcbiAgICB2YXIgZGlyID0gZ2V0RGlyZWN0aW9uKHRleHQpO1xuICAgIGlmIChkaXIgPT09ICdydGwnKSB7XG4gICAgICBhdHRyaWJ1dGVzLmRpciA9IGRpcjtcbiAgICB9XG4gIH1cbiAgLy8gSWYgaXQncyBhIHZvaWQgbm9kZSwgd3JhcCB0aGUgY2hpbGRyZW4gaW4gZXh0cmEgdm9pZC1zcGVjaWZpYyBlbGVtZW50cy5cbiAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBlbGVtZW50KSkge1xuICAgIGF0dHJpYnV0ZXNbJ2RhdGEtc2xhdGUtdm9pZCddID0gdHJ1ZTtcbiAgICBpZiAoIXJlYWRPbmx5ICYmIGlzSW5saW5lKSB7XG4gICAgICBhdHRyaWJ1dGVzLmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgVGFnID0gaXNJbmxpbmUgPyAnc3BhbicgOiAnZGl2JztcbiAgICB2YXIgW1tfdGV4dF1dID0gTm9kZS50ZXh0cyhlbGVtZW50KTtcbiAgICBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRhZywge1xuICAgICAgXCJkYXRhLXNsYXRlLXNwYWNlclwiOiB0cnVlLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgaGVpZ2h0OiAnMCcsXG4gICAgICAgIGNvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICB9XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRUZXh0LCB7XG4gICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICBkZWNvcmF0aW9uczogW10sXG4gICAgICBpc0xhc3Q6IGZhbHNlLFxuICAgICAgcGFyZW50OiBlbGVtZW50LFxuICAgICAgdGV4dDogX3RleHRcbiAgICB9KSk7XG4gICAgTk9ERV9UT19JTkRFWC5zZXQoX3RleHQsIDApO1xuICAgIE5PREVfVE9fUEFSRU5ULnNldChfdGV4dCwgZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlckVsZW1lbnQoe1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudFxuICB9KTtcbn07XG52YXIgTWVtb2l6ZWRFbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oRWxlbWVudCwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIHByZXYuZWxlbWVudCA9PT0gbmV4dC5lbGVtZW50ICYmIHByZXYucmVuZGVyRWxlbWVudCA9PT0gbmV4dC5yZW5kZXJFbGVtZW50ICYmIHByZXYucmVuZGVyTGVhZiA9PT0gbmV4dC5yZW5kZXJMZWFmICYmIHByZXYucmVuZGVyUGxhY2Vob2xkZXIgPT09IG5leHQucmVuZGVyUGxhY2Vob2xkZXIgJiYgaXNFbGVtZW50RGVjb3JhdGlvbnNFcXVhbChwcmV2LmRlY29yYXRpb25zLCBuZXh0LmRlY29yYXRpb25zKSAmJiAocHJldi5zZWxlY3Rpb24gPT09IG5leHQuc2VsZWN0aW9uIHx8ICEhcHJldi5zZWxlY3Rpb24gJiYgISFuZXh0LnNlbGVjdGlvbiAmJiBSYW5nZS5lcXVhbHMocHJldi5zZWxlY3Rpb24sIG5leHQuc2VsZWN0aW9uKSk7XG59KTtcbi8qKlxuICogVGhlIGRlZmF1bHQgZWxlbWVudCByZW5kZXJlci5cbiAqL1xudmFyIERlZmF1bHRFbGVtZW50ID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgZWxlbWVudFxuICB9ID0gcHJvcHM7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgVGFnID0gZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpID8gJ3NwYW4nIDogJ2Rpdic7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIGF0dHJpYnV0ZXMpLCB7fSwge1xuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgIH1cbiAgfSksIGNoaWxkcmVuKTtcbn07XG5cbi8qKlxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgZGVjb3JhdGVgIHByb3Agb2YgdGhlIGVkaXRhYmxlLlxuICovXG52YXIgRGVjb3JhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoKCkgPT4gW10pO1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgYGRlY29yYXRlYCBwcm9wIG9mIHRoZSBlZGl0YWJsZS5cbiAqL1xudmFyIHVzZURlY29yYXRlID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChEZWNvcmF0ZUNvbnRleHQpO1xufTtcblxuLyoqXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGBzZWxlY3RlZGAgc3RhdGUgb2YgYW4gZWxlbWVudC5cbiAqL1xudmFyIFNlbGVjdGVkQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGBzZWxlY3RlZGAgc3RhdGUgb2YgYW4gZWxlbWVudC5cbiAqL1xudmFyIHVzZVNlbGVjdGVkID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChTZWxlY3RlZENvbnRleHQpO1xufTtcblxuLyoqXG4gKiBDaGlsZHJlbi5cbiAqL1xudmFyIHVzZUNoaWxkcmVuID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGRlY29yYXRpb25zLFxuICAgIG5vZGUsXG4gICAgcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmLFxuICAgIHNlbGVjdGlvblxuICB9ID0gcHJvcHM7XG4gIHZhciBkZWNvcmF0ZSA9IHVzZURlY29yYXRlKCk7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICBJU19OT0RFX01BUF9ESVJUWS5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgdmFyIGNoaWxkcmVuID0gW107XG4gIHZhciBpc0xlYWZCbG9jayA9IEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSAmJiBFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcCA9IHBhdGguY29uY2F0KGkpO1xuICAgIHZhciBuID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIG4pO1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHApO1xuICAgIHZhciBzZWwgPSBzZWxlY3Rpb24gJiYgUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBzZWxlY3Rpb24pO1xuICAgIHZhciBkcyA9IGRlY29yYXRlKFtuLCBwXSk7XG4gICAgZm9yICh2YXIgZGVjIG9mIGRlY29yYXRpb25zKSB7XG4gICAgICB2YXIgZCA9IFJhbmdlLmludGVyc2VjdGlvbihkZWMsIHJhbmdlKTtcbiAgICAgIGlmIChkKSB7XG4gICAgICAgIGRzLnB1c2goZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG4pKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTZWxlY3RlZENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAga2V5OiBcInByb3ZpZGVyLVwiLmNvbmNhdChrZXkuaWQpLFxuICAgICAgICB2YWx1ZTogISFzZWxcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkRWxlbWVudCwge1xuICAgICAgICBkZWNvcmF0aW9uczogZHMsXG4gICAgICAgIGVsZW1lbnQ6IG4sXG4gICAgICAgIGtleToga2V5LmlkLFxuICAgICAgICByZW5kZXJFbGVtZW50OiByZW5kZXJFbGVtZW50LFxuICAgICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgICAgIHNlbGVjdGlvbjogc2VsXG4gICAgICB9KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZFRleHQsIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IGRzLFxuICAgICAgICBrZXk6IGtleS5pZCxcbiAgICAgICAgaXNMYXN0OiBpc0xlYWZCbG9jayAmJiBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEsXG4gICAgICAgIHBhcmVudDogbm9kZSxcbiAgICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmLFxuICAgICAgICB0ZXh0OiBuXG4gICAgICB9KSk7XG4gICAgfVxuICAgIE5PREVfVE9fSU5ERVguc2V0KG4sIGkpO1xuICAgIE5PREVfVE9fUEFSRU5ULnNldChuLCBub2RlKTtcbiAgfVxuICByZXR1cm4gY2hpbGRyZW47XG59O1xuXG4vKipcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYHJlYWRPbmx5YCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuICovXG52YXIgUmVhZE9ubHlDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgYHJlYWRPbmx5YCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuICovXG52YXIgdXNlUmVhZE9ubHkgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KFJlYWRPbmx5Q29udGV4dCk7XG59O1xuXG52YXIgU2xhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXG4gKi9cbnZhciB1c2VTbGF0ZSA9ICgpID0+IHtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNsYXRlQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuICB2YXIge1xuICAgIGVkaXRvclxuICB9ID0gY29udGV4dDtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG52YXIgdXNlU2xhdGVXaXRoViA9ICgpID0+IHtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNsYXRlQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbmZ1bmN0aW9uIHVzZVRyYWNrVXNlcklucHV0KCkge1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHJlY2VpdmVkVXNlcklucHV0ID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIGFuaW1hdGlvbkZyYW1lSWRSZWYgPSB1c2VSZWYoMCk7XG4gIHZhciBvblVzZXJJbnB1dCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB2YXIgd2luZG93ID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KGVkaXRvcik7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWRSZWYuY3VycmVudCk7XG4gICAgYW5pbWF0aW9uRnJhbWVJZFJlZi5jdXJyZW50ID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICByZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgdXNlRWZmZWN0KCgpID0+ICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lSWRSZWYuY3VycmVudCksIFtdKTtcbiAgcmV0dXJuIHtcbiAgICByZWNlaXZlZFVzZXJJbnB1dCxcbiAgICBvblVzZXJJbnB1dFxuICB9O1xufVxuXG52YXIgY3JlYXRlUmVzdG9yZURvbU1hbmFnZXIgPSAoZWRpdG9yLCByZWNlaXZlZFVzZXJJbnB1dCkgPT4ge1xuICB2YXIgYnVmZmVyZWRNdXRhdGlvbnMgPSBbXTtcbiAgdmFyIGNsZWFyID0gKCkgPT4ge1xuICAgIGJ1ZmZlcmVkTXV0YXRpb25zID0gW107XG4gIH07XG4gIHZhciByZWdpc3Rlck11dGF0aW9ucyA9IG11dGF0aW9ucyA9PiB7XG4gICAgaWYgKCFyZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0cmFja2VkTXV0YXRpb25zID0gbXV0YXRpb25zLmZpbHRlcihtdXRhdGlvbiA9PiBpc1RyYWNrZWRNdXRhdGlvbihlZGl0b3IsIG11dGF0aW9uLCBtdXRhdGlvbnMpKTtcbiAgICBidWZmZXJlZE11dGF0aW9ucy5wdXNoKC4uLnRyYWNrZWRNdXRhdGlvbnMpO1xuICB9O1xuICBmdW5jdGlvbiByZXN0b3JlRE9NKCkge1xuICAgIGlmIChidWZmZXJlZE11dGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBidWZmZXJlZE11dGF0aW9ucy5yZXZlcnNlKCkuZm9yRWFjaChtdXRhdGlvbiA9PiB7XG4gICAgICAgIGlmIChtdXRhdGlvbi50eXBlID09PSAnY2hhcmFjdGVyRGF0YScpIHtcbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJlc3RvcmUgdGhlIERPTSBmb3IgY2hhcmFjdGVyRGF0YSBtdXRhdGlvbnNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMgaW50ZXJydXB0cyB0aGUgY29tcG9zaXRpb24uXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG11dGF0aW9uLnJlbW92ZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLnRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgbXV0YXRpb24ubmV4dFNpYmxpbmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgbXV0YXRpb24uYWRkZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgIG11dGF0aW9uLnRhcmdldC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIENsZWFyIGJ1ZmZlcmVkIG11dGF0aW9ucyB0byBlbnN1cmUgd2UgZG9uJ3QgdW5kbyB0aGVtIHR3aWNlXG4gICAgICBjbGVhcigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlZ2lzdGVyTXV0YXRpb25zLFxuICAgIHJlc3RvcmVET00sXG4gICAgY2xlYXJcbiAgfTtcbn07XG5cbnZhciBNVVRBVElPTl9PQlNFUlZFUl9DT05GSUcgPSB7XG4gIHN1YnRyZWU6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlXG59O1xuLy8gV2UgaGF2ZSB0byB1c2UgYSBjbGFzcyBjb21wb25lbnQgaGVyZSBzaW5jZSB3ZSByZWx5IG9uIGBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZWAgd2hpY2ggaGFzIG5vIEZDIGVxdWl2YWxlbnRcbi8vIHRvIHJ1biBjb2RlIHN5bmNocm9ub3VzbHkgaW1tZWRpYXRlbHkgYmVmb3JlIHJlYWN0IGNvbW1pdHMgdGhlIGNvbXBvbmVudCB1cGRhdGUgdG8gdGhlIERPTS5cbmNsYXNzIFJlc3RvcmVET01Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRleHRcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWFuYWdlclwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJtdXRhdGlvbk9ic2VydmVyXCIsIG51bGwpO1xuICB9XG4gIG9ic2VydmUoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTtcbiAgICB2YXIge1xuICAgICAgbm9kZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghbm9kZS5jdXJyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhdHRhY2ggTXV0YXRpb25PYnNlcnZlciwgYG5vZGVgIGlzIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlID0gdGhpcy5tdXRhdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmUgPT09IHZvaWQgMCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmUub2JzZXJ2ZShub2RlLmN1cnJlbnQsIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIHtcbiAgICAgIHJlY2VpdmVkVXNlcklucHV0XG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGVkaXRvciA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLm1hbmFnZXIgPSBjcmVhdGVSZXN0b3JlRG9tTWFuYWdlcihlZGl0b3IsIHJlY2VpdmVkVXNlcklucHV0KTtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLm1hbmFnZXIucmVnaXN0ZXJNdXRhdGlvbnMpO1xuICAgIHRoaXMub2JzZXJ2ZSgpO1xuICB9XG4gIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkge1xuICAgIHZhciBfdGhpcyRtdXRhdGlvbk9ic2VydmUyLCBfdGhpcyRtdXRhdGlvbk9ic2VydmUzLCBfdGhpcyRtYW5hZ2VyMjtcbiAgICB2YXIgcGVuZGluZ011dGF0aW9ucyA9IChfdGhpcyRtdXRhdGlvbk9ic2VydmUyID0gdGhpcy5tdXRhdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtdXRhdGlvbk9ic2VydmUyLnRha2VSZWNvcmRzKCk7XG4gICAgaWYgKHBlbmRpbmdNdXRhdGlvbnMgIT09IG51bGwgJiYgcGVuZGluZ011dGF0aW9ucyAhPT0gdm9pZCAwICYmIHBlbmRpbmdNdXRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICB2YXIgX3RoaXMkbWFuYWdlcjtcbiAgICAgIChfdGhpcyRtYW5hZ2VyID0gdGhpcy5tYW5hZ2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRtYW5hZ2VyID09PSB2b2lkIDAgfHwgX3RoaXMkbWFuYWdlci5yZWdpc3Rlck11dGF0aW9ucyhwZW5kaW5nTXV0YXRpb25zKTtcbiAgICB9XG4gICAgKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMgPT09IHZvaWQgMCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmUzLmRpc2Nvbm5lY3QoKTtcbiAgICAoX3RoaXMkbWFuYWdlcjIgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIyID09PSB2b2lkIDAgfHwgX3RoaXMkbWFuYWdlcjIucmVzdG9yZURPTSgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkbWFuYWdlcjM7XG4gICAgKF90aGlzJG1hbmFnZXIzID0gdGhpcy5tYW5hZ2VyKSA9PT0gbnVsbCB8fCBfdGhpcyRtYW5hZ2VyMyA9PT0gdm9pZCAwIHx8IF90aGlzJG1hbmFnZXIzLmNsZWFyKCk7XG4gICAgdGhpcy5vYnNlcnZlKCk7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQ7XG4gICAgKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQgPT09IHZvaWQgMCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmU0LmRpc2Nvbm5lY3QoKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShSZXN0b3JlRE9NQ29tcG9uZW50LCBcImNvbnRleHRUeXBlXCIsIEVkaXRvckNvbnRleHQpO1xudmFyIFJlc3RvcmVET00gPSBJU19BTkRST0lEID8gUmVzdG9yZURPTUNvbXBvbmVudCA6IF9yZWYgPT4ge1xuICB2YXIge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn07XG5cbi8qKlxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgY29tcG9zaW5nYCBzdGF0ZSBvZiB0aGUgZWRpdG9yLlxuICovXG52YXIgQ29tcG9zaW5nQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGBjb21wb3NpbmdgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gKi9cbnZhciB1c2VDb21wb3NpbmcgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KENvbXBvc2luZ0NvbnRleHQpO1xufTtcblxudmFyIF9leGNsdWRlZCQxID0gW1wiYXV0b0ZvY3VzXCIsIFwiZGVjb3JhdGVcIiwgXCJvbkRPTUJlZm9yZUlucHV0XCIsIFwicGxhY2Vob2xkZXJcIiwgXCJyZWFkT25seVwiLCBcInJlbmRlckVsZW1lbnRcIiwgXCJyZW5kZXJMZWFmXCIsIFwicmVuZGVyUGxhY2Vob2xkZXJcIiwgXCJzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1wiLCBcInN0eWxlXCIsIFwiYXNcIiwgXCJkaXNhYmxlRGVmYXVsdFN0eWxlc1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcInRleHRcIl07XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBDaGlsZHJlbiA9IHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCB1c2VDaGlsZHJlbihwcm9wcykpO1xuLyoqXG4gKiBFZGl0YWJsZS5cbiAqL1xudmFyIEVkaXRhYmxlID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgdmFyIGRlZmF1bHRSZW5kZXJQbGFjZWhvbGRlciA9IHVzZUNhbGxiYWNrKHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRQbGFjZWhvbGRlciwgX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpKSwgW10pO1xuICB2YXIge1xuICAgICAgYXV0b0ZvY3VzLFxuICAgICAgZGVjb3JhdGUgPSBkZWZhdWx0RGVjb3JhdGUsXG4gICAgICBvbkRPTUJlZm9yZUlucHV0OiBwcm9wc09uRE9NQmVmb3JlSW5wdXQsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2UsXG4gICAgICByZW5kZXJFbGVtZW50LFxuICAgICAgcmVuZGVyTGVhZixcbiAgICAgIHJlbmRlclBsYWNlaG9sZGVyID0gZGVmYXVsdFJlbmRlclBsYWNlaG9sZGVyLFxuICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcgPSBkZWZhdWx0U2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcsXG4gICAgICBzdHlsZTogdXNlclN0eWxlID0ge30sXG4gICAgICBhczogQ29tcG9uZW50ID0gJ2RpdicsXG4gICAgICBkaXNhYmxlRGVmYXVsdFN0eWxlcyA9IGZhbHNlXG4gICAgfSA9IHByb3BzLFxuICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCQxKTtcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlKCk7XG4gIC8vIFJlcmVuZGVyIGVkaXRvciB3aGVuIGNvbXBvc2l0aW9uIHN0YXR1cyBjaGFuZ2VkXG4gIHZhciBbaXNDb21wb3NpbmcsIHNldElzQ29tcG9zaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGRlZmVycmVkT3BlcmF0aW9ucyA9IHVzZVJlZihbXSk7XG4gIHZhciBbcGxhY2Vob2xkZXJIZWlnaHQsIHNldFBsYWNlaG9sZGVySGVpZ2h0XSA9IHVzZVN0YXRlKCk7XG4gIHZhciBwcm9jZXNzaW5nID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIHtcbiAgICBvblVzZXJJbnB1dCxcbiAgICByZWNlaXZlZFVzZXJJbnB1dFxuICB9ID0gdXNlVHJhY2tVc2VySW5wdXQoKTtcbiAgdmFyIFssIGZvcmNlUmVuZGVyXSA9IHVzZVJlZHVjZXIocyA9PiBzICsgMSwgMCk7XG4gIEVESVRPUl9UT19GT1JDRV9SRU5ERVIuc2V0KGVkaXRvciwgZm9yY2VSZW5kZXIpO1xuICAvLyBVcGRhdGUgaW50ZXJuYWwgc3RhdGUgb24gZWFjaCByZW5kZXIuXG4gIElTX1JFQURfT05MWS5zZXQoZWRpdG9yLCByZWFkT25seSk7XG4gIC8vIEtlZXAgdHJhY2sgb2Ygc29tZSBzdGF0ZSBmb3IgdGhlIGV2ZW50IGhhbmRsZXIgbG9naWMuXG4gIHZhciBzdGF0ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBpc0RyYWdnaW5nSW50ZXJuYWxseTogZmFsc2UsXG4gICAgaXNVcGRhdGluZ1NlbGVjdGlvbjogZmFsc2UsXG4gICAgbGF0ZXN0RWxlbWVudDogbnVsbCxcbiAgICBoYXNNYXJrUGxhY2Vob2xkZXI6IGZhbHNlXG4gIH0pLCBbXSk7XG4gIC8vIFRoZSBhdXRvRm9jdXMgVGV4dGFyZWFIVE1MQXR0cmlidXRlIGRvZXNuJ3QgZG8gYW55dGhpbmcgb24gYSBkaXYsIHNvIGl0XG4gIC8vIG5lZWRzIHRvIGJlIG1hbnVhbGx5IGZvY3VzZWQuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlZi5jdXJyZW50ICYmIGF1dG9Gb2N1cykge1xuICAgICAgcmVmLmN1cnJlbnQuZm9jdXMoKTtcbiAgICB9XG4gIH0sIFthdXRvRm9jdXNdKTtcbiAgLyoqXG4gICAqIFRoZSBBbmRyb2lkSW5wdXRNYW5hZ2VyIG9iamVjdCBoYXMgYSBjeWNsaWNhbCBkZXBlbmRlbmN5IG9uIG9uRE9NU2VsZWN0aW9uQ2hhbmdlXG4gICAqXG4gICAqIEl0IGlzIGRlZmluZWQgYXMgYSByZWZlcmVuY2UgdG8gc2ltcGxpZnkgaG9vayBkZXBlbmRlbmNpZXMgYW5kIGNsYXJpZnkgdGhhdFxuICAgKiBpdCBuZWVkcyB0byBiZSBpbml0aWFsaXplZC5cbiAgICovXG4gIHZhciBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmID0gdXNlUmVmKCk7XG4gIC8vIExpc3RlbiBvbiB0aGUgbmF0aXZlIGBzZWxlY3Rpb25jaGFuZ2VgIGV2ZW50IHRvIGJlIGFibGUgdG8gdXBkYXRlIGFueSB0aW1lXG4gIC8vIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIFJlYWN0J3MgYG9uU2VsZWN0YCBpcyBsZWFreVxuICAvLyBhbmQgbm9uLXN0YW5kYXJkIHNvIGl0IGRvZXNuJ3QgZmlyZSB1bnRpbCBhZnRlciBhIHNlbGVjdGlvbiBoYXMgYmVlblxuICAvLyByZWxlYXNlZC4gVGhpcyBjYXVzZXMgaXNzdWVzIGluIHNpdHVhdGlvbnMgd2hlcmUgYW5vdGhlciBjaGFuZ2UgaGFwcGVuc1xuICAvLyB3aGlsZSBhIHNlbGVjdGlvbiBpcyBiZWluZyBkcmFnZ2VkLlxuICB2YXIgb25ET01TZWxlY3Rpb25DaGFuZ2UgPSB1c2VNZW1vKCgpID0+IHRocm90dGxlKCgpID0+IHtcbiAgICBpZiAoSVNfTk9ERV9NQVBfRElSVFkuZ2V0KGVkaXRvcikpIHtcbiAgICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBlbC5nZXRSb290Tm9kZSgpO1xuICAgIGlmICghcHJvY2Vzc2luZy5jdXJyZW50ICYmIElTX1dFQktJVCAmJiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgcHJvY2Vzc2luZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHZhciBhY3RpdmUgPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbmRlbnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3NpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYW5kcm9pZElucHV0TWFuYWdlciA9IGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudDtcbiAgICBpZiAoKElTX0FORFJPSUQgfHwgIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpICYmICghc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmlzRmx1c2hpbmcoKSkgJiYgIXN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5KSB7XG4gICAgICB2YXIgX3Jvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICAgIHZhciB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICAgIH0gPSBfcm9vdDtcbiAgICAgIHZhciBfZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgdmFyIGRvbVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihfcm9vdCk7XG4gICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gX2VsKSB7XG4gICAgICAgIHN0YXRlLmxhdGVzdEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50O1xuICAgICAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSVNfRk9DVVNFRC5kZWxldGUoZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG4gICAgICB2YXIge1xuICAgICAgICBhbmNob3JOb2RlLFxuICAgICAgICBmb2N1c05vZGVcbiAgICAgIH0gPSBkb21TZWxlY3Rpb247XG4gICAgICB2YXIgYW5jaG9yTm9kZVNlbGVjdGFibGUgPSBSZWFjdEVkaXRvci5oYXNFZGl0YWJsZVRhcmdldChlZGl0b3IsIGFuY2hvck5vZGUpIHx8IFJlYWN0RWRpdG9yLmlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkKGVkaXRvciwgYW5jaG9yTm9kZSk7XG4gICAgICB2YXIgZm9jdXNOb2RlSW5FZGl0b3IgPSBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBmb2N1c05vZGUpO1xuICAgICAgaWYgKGFuY2hvck5vZGVTZWxlY3RhYmxlICYmIGZvY3VzTm9kZUluRWRpdG9yKSB7XG4gICAgICAgIHZhciByYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSAmJiAhKGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IG51bGwgJiYgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gdm9pZCAwICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIuaGFzUGVuZGluZ0NoYW5nZXMoKSkgJiYgIShhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmlzRmx1c2hpbmcoKSkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSBudWxsIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IHZvaWQgMCB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhbmRsZVVzZXJTZWxlY3QocmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRGVzZWxlY3QgdGhlIGVkaXRvciBpZiB0aGUgZG9tIHNlbGVjdGlvbiBpcyBub3Qgc2VsZWN0YWJsZSBpbiByZWFkb25seSBtb2RlXG4gICAgICBpZiAocmVhZE9ubHkgJiYgKCFhbmNob3JOb2RlU2VsZWN0YWJsZSB8fCAhZm9jdXNOb2RlSW5FZGl0b3IpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIDEwMCksIFtlZGl0b3IsIHJlYWRPbmx5LCBzdGF0ZV0pO1xuICB2YXIgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSA9IHVzZU1lbW8oKCkgPT4gZGVib3VuY2Uob25ET01TZWxlY3Rpb25DaGFuZ2UsIDApLCBbb25ET01TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50ID0gdXNlQW5kcm9pZElucHV0TWFuYWdlcih7XG4gICAgbm9kZTogcmVmLFxuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLFxuICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2VcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBfYW5kcm9pZElucHV0TWFuYWdlclIsIF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjI7XG4gICAgLy8gVXBkYXRlIGVsZW1lbnQtcmVsYXRlZCB3ZWFrIG1hcHMgd2l0aCB0aGUgRE9NIGVsZW1lbnQgcmVmLlxuICAgIHZhciB3aW5kb3c7XG4gICAgaWYgKHJlZi5jdXJyZW50ICYmICh3aW5kb3cgPSBnZXREZWZhdWx0VmlldyhyZWYuY3VycmVudCkpKSB7XG4gICAgICBFRElUT1JfVE9fV0lORE9XLnNldChlZGl0b3IsIHdpbmRvdyk7XG4gICAgICBFRElUT1JfVE9fRUxFTUVOVC5zZXQoZWRpdG9yLCByZWYuY3VycmVudCk7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuc2V0KGVkaXRvciwgcmVmLmN1cnJlbnQpO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChyZWYuY3VycmVudCwgZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgTk9ERV9UT19FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgdGhlIERPTSBzZWxlY3Rpb24gc3RhdGUgaXMgaW4gc3luYy5cbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24ocm9vdCk7XG4gICAgaWYgKCFkb21TZWxlY3Rpb24gfHwgIVJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpIHx8IChfYW5kcm9pZElucHV0TWFuYWdlclIgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpICE9PSBudWxsICYmIF9hbmRyb2lkSW5wdXRNYW5hZ2VyUiAhPT0gdm9pZCAwICYmIF9hbmRyb2lkSW5wdXRNYW5hZ2VyUi5oYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNldERvbVNlbGVjdGlvbiA9IGZvcmNlQ2hhbmdlID0+IHtcbiAgICAgIHZhciBoYXNEb21TZWxlY3Rpb24gPSBkb21TZWxlY3Rpb24udHlwZSAhPT0gJ05vbmUnO1xuICAgICAgLy8gSWYgdGhlIERPTSBzZWxlY3Rpb24gaXMgcHJvcGVybHkgdW5zZXQsIHdlJ3JlIGRvbmUuXG4gICAgICBpZiAoIXNlbGVjdGlvbiAmJiAhaGFzRG9tU2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEdldCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGVcbiAgICAgIHZhciBmb2N1c05vZGUgPSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlO1xuICAgICAgdmFyIGFuY2hvck5vZGU7XG4gICAgICAvLyBDT01QQVQ6IEluIGZpcmVmb3ggdGhlIG5vcm1hbCBzZWxlY3Rpb24gd2F5IGRvZXMgbm90IHdvcmtcbiAgICAgIC8vIChodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC81NDg2I2lzc3VlLTE4MjA3MjAyMjMpXG4gICAgICBpZiAoSVNfRklSRUZPWCAmJiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgdmFyIGZpcnN0UmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgdmFyIGxhc3RSYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50IC0gMSk7XG4gICAgICAgIC8vIFJpZ2h0IHRvIGxlZnRcbiAgICAgICAgaWYgKGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXIgPT09IGZvY3VzTm9kZSkge1xuICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0UmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExlZnQgdG8gcmlnaHRcbiAgICAgICAgICBhbmNob3JOb2RlID0gZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgfVxuICAgICAgLy8gdmVyaWZ5IHRoYXQgdGhlIGRvbSBzZWxlY3Rpb24gaXMgaW4gdGhlIGVkaXRvclxuICAgICAgdmFyIGVkaXRvckVsZW1lbnQgPSBFRElUT1JfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICAgIHZhciBoYXNEb21TZWxlY3Rpb25JbkVkaXRvciA9IGZhbHNlO1xuICAgICAgaWYgKGVkaXRvckVsZW1lbnQuY29udGFpbnMoYW5jaG9yTm9kZSkgJiYgZWRpdG9yRWxlbWVudC5jb250YWlucyhmb2N1c05vZGUpKSB7XG4gICAgICAgIGhhc0RvbVNlbGVjdGlvbkluRWRpdG9yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBET00gc2VsZWN0aW9uIGlzIGluIHRoZSBlZGl0b3IgYW5kIHRoZSBlZGl0b3Igc2VsZWN0aW9uIGlzIGFscmVhZHkgY29ycmVjdCwgd2UncmUgZG9uZS5cbiAgICAgIGlmIChoYXNEb21TZWxlY3Rpb24gJiYgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgJiYgc2VsZWN0aW9uICYmICFmb3JjZUNoYW5nZSkge1xuICAgICAgICB2YXIgc2xhdGVSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICAgIGV4YWN0TWF0Y2g6IHRydWUsXG4gICAgICAgICAgLy8gZG9tU2VsZWN0aW9uIGlzIG5vdCBuZWNlc3NhcmlseSBhIHZhbGlkIFNsYXRlIHJhbmdlXG4gICAgICAgICAgLy8gKGUuZy4gd2hlbiBjbGlja2luZyBvbiBjb250ZW50RWRpdGFibGU6ZmFsc2UgZWxlbWVudClcbiAgICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2xhdGVSYW5nZSAmJiBSYW5nZS5lcXVhbHMoc2xhdGVSYW5nZSwgc2VsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBfYW5jaG9yTm9kZTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmhhc01hcmtQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFbnN1cmUgc2VsZWN0aW9uIGlzIGluc2lkZSB0aGUgbWFyayBwbGFjZWhvbGRlclxuICAgICAgICAgIGlmICgoX2FuY2hvck5vZGUgPSBhbmNob3JOb2RlKSAhPT0gbnVsbCAmJiBfYW5jaG9yTm9kZSAhPT0gdm9pZCAwICYmIChfYW5jaG9yTm9kZSA9IF9hbmNob3JOb2RlLnBhcmVudEVsZW1lbnQpICE9PSBudWxsICYmIF9hbmNob3JOb2RlICE9PSB2b2lkIDAgJiYgX2FuY2hvck5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW1hcmstcGxhY2Vob2xkZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gd2hlbiA8RWRpdGFibGUvPiBpcyBiZWluZyBjb250cm9sbGVkIHRocm91Z2ggZXh0ZXJuYWwgdmFsdWVcbiAgICAgIC8vIHRoZW4gaXRzIGNoaWxkcmVuIG1pZ2h0IGp1c3QgY2hhbmdlIC0gRE9NIHJlc3BvbmRzIHRvIGl0IG9uIGl0cyBvd25cbiAgICAgIC8vIGJ1dCBTbGF0ZSdzIHZhbHVlIGlzIG5vdCBiZWluZyB1cGRhdGVkIHRocm91Z2ggYW55IG9wZXJhdGlvblxuICAgICAgLy8gYW5kIHRodXMgaXQgZG9lc24ndCB0cmFuc2Zvcm0gc2VsZWN0aW9uIG9uIGl0cyBvd25cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgIVJlYWN0RWRpdG9yLmhhc1JhbmdlKGVkaXRvciwgc2VsZWN0aW9uKSkge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBET00gc2VsZWN0aW9uIGlzIG91dCBvZiBzeW5jLCBzbyB1cGRhdGUgaXQuXG4gICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBuZXdEb21SYW5nZSA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICBuZXdEb21SYW5nZSA9IHNlbGVjdGlvbiAmJiBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWdub3JlLCBkb20gYW5kIHN0YXRlIG1pZ2h0IGJlIG91dCBvZiBzeW5jXG4gICAgICB9XG4gICAgICBpZiAobmV3RG9tUmFuZ2UpIHtcbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgIUlTX0FORFJPSUQpIHtcbiAgICAgICAgICBkb21TZWxlY3Rpb24uY29sbGFwc2VUb0VuZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KG5ld0RvbVJhbmdlLmVuZENvbnRhaW5lciwgbmV3RG9tUmFuZ2UuZW5kT2Zmc2V0LCBuZXdEb21SYW5nZS5zdGFydENvbnRhaW5lciwgbmV3RG9tUmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KG5ld0RvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLCBuZXdEb21SYW5nZS5zdGFydE9mZnNldCwgbmV3RG9tUmFuZ2UuZW5kQ29udGFpbmVyLCBuZXdEb21SYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3KGVkaXRvciwgbmV3RG9tUmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RvbVJhbmdlO1xuICAgIH07XG4gICAgLy8gSW4gZmlyZWZveCBpZiB0aGVyZSBpcyBtb3JlIHRoZW4gMSByYW5nZSBhbmQgd2UgY2FsbCBzZXREb21TZWxlY3Rpb24gd2UgcmVtb3ZlIHRoZSBhYmlsaXR5IHRvIHNlbGVjdCBtb3JlIGNlbGxzIGluIGEgdGFibGVcbiAgICBpZiAoZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPD0gMSkge1xuICAgICAgc2V0RG9tU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHZhciBlbnN1cmVTZWxlY3Rpb24gPSAoKF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjIgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjIuaXNGbHVzaGluZygpKSA9PT0gJ2FjdGlvbic7XG4gICAgaWYgKCFJU19BTkRST0lEIHx8ICFlbnN1cmVTZWxlY3Rpb24pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgdmFyIGFuaW1hdGlvbkZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKGVuc3VyZVNlbGVjdGlvbikge1xuICAgICAgICB2YXIgZW5zdXJlRG9tU2VsZWN0aW9uID0gZm9yY2VDaGFuZ2UgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIHNldERvbVNlbGVjdGlvbihmb3JjZUNoYW5nZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWdub3JlLCBkb20gYW5kIHN0YXRlIG1pZ2h0IGJlIG91dCBvZiBzeW5jXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDb21wYXQ6IEFuZHJvaWQgSU1FcyB0cnkgdG8gZm9yY2UgdGhlaXIgc2VsZWN0aW9uIGJ5IG1hbnVhbGx5IHJlLWFwcGx5aW5nIGl0IGV2ZW4gYWZ0ZXIgd2Ugc2V0IGl0LlxuICAgICAgICAvLyBUaGlzIGVzc2VudGlhbGx5IHdvdWxkIG1ha2Ugc2V0dGluZyB0aGUgc2xhdGUgc2VsZWN0aW9uIGR1cmluZyBhbiB1cGRhdGUgbWVhbmluZ2xlc3MsIHNvIHdlIGZvcmNlIGl0XG4gICAgICAgIC8vIGFnYWluIGhlcmUuIFdlIGNhbid0IG9ubHkgZG8gaXQgaW4gdGhlIHNldFRpbWVvdXQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBmcmFtZSBzaW5jZSB0aGF0IHdvdWxkIGNhdXNlIGFcbiAgICAgICAgLy8gdmlzaWJsZSBmbGlja2VyLlxuICAgICAgICBlbnN1cmVEb21TZWxlY3Rpb24oKTtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgLy8gQ09NUEFUOiBXaGlsZSBzZXR0aW5nIHRoZSBzZWxlY3Rpb24gaW4gYW4gYW5pbWF0aW9uIGZyYW1lIHZpc3VhbGx5IGNvcnJlY3RseSBzZXRzIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgICAgLy8gaXQgZG9lc24ndCB1cGRhdGUgR0JvYXJkcyBzcGVsbGNoZWNrZXIgc3RhdGUuIFdlIGhhdmUgdG8gbWFudWFsbHkgdHJpZ2dlciBhIHNlbGVjdGlvbiBjaGFuZ2UgYWZ0ZXJcbiAgICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIGZyYW1lIHRvIGVuc3VyZSBpdCBkaXNwbGF5cyB0aGUgY29ycmVjdCBzdGF0ZS5cbiAgICAgICAgICBlbnN1cmVEb21TZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZCk7XG4gICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICAvLyBMaXN0ZW4gb24gdGhlIG5hdGl2ZSBgYmVmb3JlaW5wdXRgIGV2ZW50IHRvIGdldCByZWFsIFwiTGV2ZWwgMlwiIGV2ZW50cy4gVGhpc1xuICAvLyBpcyByZXF1aXJlZCBiZWNhdXNlIFJlYWN0J3MgYGJlZm9yZWlucHV0YCBpcyBmYWtlIGFuZCBuZXZlciByZWFsbHkgYXR0YWNoZXNcbiAgLy8gdG8gdGhlIHJlYWwgZXZlbnQgc2FkbHkuICgyMDE5LzExLzAxKVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExMjExXG4gIHZhciBvbkRPTUJlZm9yZUlucHV0ID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBlbC5nZXRSb290Tm9kZSgpO1xuICAgIGlmIChwcm9jZXNzaW5nICE9PSBudWxsICYmIHByb2Nlc3NpbmcgIT09IHZvaWQgMCAmJiBwcm9jZXNzaW5nLmN1cnJlbnQgJiYgSVNfV0VCS0lUICYmIHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICB2YXIgcmFuZ2VzID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICB2YXIgbmV3UmFuZ2UgPSBuZXcgd2luZG93LlJhbmdlKCk7XG4gICAgICBuZXdSYW5nZS5zZXRTdGFydChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgbmV3UmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgRE9NIFJhbmdlIGludG8gYSBTbGF0ZSBSYW5nZVxuICAgICAgdmFyIHNsYXRlUmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBuZXdSYW5nZSwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzbGF0ZVJhbmdlKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb25Vc2VySW5wdXQoKTtcbiAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNET01FdmVudEhhbmRsZWQoZXZlbnQsIHByb3BzT25ET01CZWZvcmVJbnB1dCkpIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX1VTRVJfU0VMRUM7XG4gICAgICAvLyBDT01QQVQ6IEJlZm9yZUlucHV0IGV2ZW50cyBhcmVuJ3QgY2FuY2VsYWJsZSBvbiBhbmRyb2lkLCBzbyB3ZSBoYXZlIHRvIGhhbmRsZSB0aGVtIGRpZmZlcmVudGx5IHVzaW5nIHRoZSBhbmRyb2lkIGlucHV0IG1hbmFnZXIuXG4gICAgICBpZiAoYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQuaGFuZGxlRE9NQmVmb3JlSW5wdXQoZXZlbnQpO1xuICAgICAgfVxuICAgICAgLy8gU29tZSBJTUVzL0Nocm9tZSBleHRlbnNpb25zIGxpa2UgZS5nLiBHcmFtbWFybHkgc2V0IHRoZSBzZWxlY3Rpb24gaW1tZWRpYXRlbHkgYmVmb3JlXG4gICAgICAvLyB0cmlnZ2VyaW5nIGEgYGJlZm9yZWlucHV0YCBleHBlY3RpbmcgdGhlIGNoYW5nZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBpbW1lZGlhdGVseSBiZWZvcmVcbiAgICAgIC8vIHNldCBzZWxlY3Rpb24uXG4gICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5mbHVzaCgpO1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuICAgICAgdmFyIHtcbiAgICAgICAgaW5wdXRUeXBlOiB0eXBlXG4gICAgICB9ID0gZXZlbnQ7XG4gICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5kYXRhIHx8IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpc0NvbXBvc2l0aW9uQ2hhbmdlID0gdHlwZSA9PT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcgfHwgdHlwZSA9PT0gJ2RlbGV0ZUNvbXBvc2l0aW9uVGV4dCc7XG4gICAgICAvLyBDT01QQVQ6IHVzZSBjb21wb3NpdGlvbiBjaGFuZ2UgZXZlbnRzIGFzIGEgaGludCB0byB3aGVyZSB3ZSBzaG91bGQgaW5zZXJ0XG4gICAgICAvLyBjb21wb3NpdGlvbiB0ZXh0IGlmIHdlIGFyZW4ndCBjb21wb3NpbmcgdG8gd29yayBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy81MDM4XG4gICAgICBpZiAoaXNDb21wb3NpdGlvbkNoYW5nZSAmJiBSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuYXRpdmUgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0VGV4dCcgJiYgc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiZcbiAgICAgIC8vIE9ubHkgdXNlIG5hdGl2ZSBjaGFyYWN0ZXIgaW5zZXJ0aW9uIGZvciBzaW5nbGUgY2hhcmFjdGVycyBhLXogb3Igc3BhY2UgZm9yIG5vdy5cbiAgICAgIC8vIExvbmctcHJlc3MgZXZlbnRzIChob2xkIGEgKyBwcmVzcyA0ID0gw6QpIHRvIGNob29zZSBhIHNwZWNpYWwgY2hhcmFjdGVyIG90aGVyd2lzZVxuICAgICAgLy8gY2F1c2VzIGR1cGxpY2F0ZSBpbnNlcnRzLlxuICAgICAgZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLmxlbmd0aCA9PT0gMSAmJiAvW2EteiBdL2kudGVzdChldmVudC5kYXRhKSAmJlxuICAgICAgLy8gQ2hyb21lIGhhcyBpc3N1ZXMgY29ycmVjdGx5IGVkaXRpbmcgdGhlIHN0YXJ0IG9mIG5vZGVzOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjQ5NDA1XG4gICAgICAvLyBXaGVuIHRoZXJlIGlzIGFuIGlubGluZSBlbGVtZW50LCBlLmcuIGEgbGluaywgYW5kIHlvdSBzZWxlY3RcbiAgICAgIC8vIHJpZ2h0IGFmdGVyIGl0ICh0aGUgc3RhcnQgb2YgdGhlIG5leHQgbm9kZSkuXG4gICAgICBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCAhPT0gMCkge1xuICAgICAgICBuYXRpdmUgPSB0cnVlO1xuICAgICAgICAvLyBTa2lwIG5hdGl2ZSBpZiB0aGVyZSBhcmUgbWFya3MsIGFzXG4gICAgICAgIC8vIGBpbnNlcnRUZXh0YCB3aWxsIGluc2VydCBhIG5vZGUsIG5vdCBqdXN0IHRleHQuXG4gICAgICAgIGlmIChlZGl0b3IubWFya3MpIHtcbiAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgTk9ERV9NQVAgaXMgZGlydHksIHdlIGNhbid0IHRydXN0IHRoZSBzZWxlY3Rpb24gYW5jaG9yIChlZyBSZWFjdEVkaXRvci50b0RPTVBvaW50KVxuICAgICAgICBpZiAoIUlTX05PREVfTUFQX0RJUlRZLmdldChlZGl0b3IpKSB7XG4gICAgICAgICAgdmFyIF9ub2RlJHBhcmVudEVsZW1lbnQsIF93aW5kb3ckZ2V0Q29tcHV0ZWRTdDtcbiAgICAgICAgICAvLyBDaHJvbWUgYWxzbyBoYXMgaXNzdWVzIGNvcnJlY3RseSBlZGl0aW5nIHRoZSBlbmQgb2YgYW5jaG9yIGVsZW1lbnRzOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMjU5MTAwXG4gICAgICAgICAgLy8gVGhlcmVmb3JlIHdlIGRvbid0IGFsbG93IG5hdGl2ZSBldmVudHMgdG8gaW5zZXJ0IHRleHQgYXQgdGhlIGVuZCBvZiBhbmNob3Igbm9kZXMuXG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIGFuY2hvclxuICAgICAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgdmFyIFtub2RlLCBvZmZzZXRdID0gUmVhY3RFZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGFuY2hvcik7XG4gICAgICAgICAgdmFyIGFuY2hvck5vZGUgPSAoX25vZGUkcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX25vZGUkcGFyZW50RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkcGFyZW50RWxlbWVudC5jbG9zZXN0KCdhJyk7XG4gICAgICAgICAgdmFyIF93aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICAgICAgICBpZiAobmF0aXZlICYmIGFuY2hvck5vZGUgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgX2xhc3RUZXh0JHRleHRDb250ZW50O1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgbGFzdCB0ZXh0IG5vZGUgaW5zaWRlIHRoZSBhbmNob3IuXG4gICAgICAgICAgICB2YXIgbGFzdFRleHQgPSBfd2luZG93ID09PSBudWxsIHx8IF93aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF93aW5kb3cuZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihhbmNob3JOb2RlLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCkubGFzdENoaWxkKCk7XG4gICAgICAgICAgICBpZiAobGFzdFRleHQgPT09IG5vZGUgJiYgKChfbGFzdFRleHQkdGV4dENvbnRlbnQgPSBsYXN0VGV4dC50ZXh0Q29udGVudCkgPT09IG51bGwgfHwgX2xhc3RUZXh0JHRleHRDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbGFzdFRleHQkdGV4dENvbnRlbnQubGVuZ3RoKSA9PT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDaHJvbWUgaGFzIGlzc3VlcyB3aXRoIHRoZSBwcmVzZW5jZSBvZiB0YWIgY2hhcmFjdGVycyBpbnNpZGUgZWxlbWVudHMgd2l0aCB3aGl0ZVNwYWNlID0gJ3ByZSdcbiAgICAgICAgICAvLyBjYXVzaW5nIGFibm9ybWFsIGluc2VydCBiZWhhdmlvcjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTIxOTEzOVxuICAgICAgICAgIGlmIChuYXRpdmUgJiYgbm9kZS5wYXJlbnRFbGVtZW50ICYmIChfd2luZG93ID09PSBudWxsIHx8IF93aW5kb3cgPT09IHZvaWQgMCB8fCAoX3dpbmRvdyRnZXRDb21wdXRlZFN0ID0gX3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUucGFyZW50RWxlbWVudCkpID09PSBudWxsIHx8IF93aW5kb3ckZ2V0Q29tcHV0ZWRTdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvdyRnZXRDb21wdXRlZFN0LndoaXRlU3BhY2UpID09PSAncHJlJykge1xuICAgICAgICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogYW5jaG9yLnBhdGgsXG4gICAgICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYmxvY2sgJiYgTm9kZS5zdHJpbmcoYmxvY2tbMF0pLmluY2x1ZGVzKCdcXHQnKSkge1xuICAgICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENPTVBBVDogRm9yIHRoZSBkZWxldGluZyBmb3J3YXJkL2JhY2t3YXJkIGlucHV0IHR5cGVzIHdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIGJlY2F1c2UgaXQgaXMgdGhlIHJhbmdlIHRoYXQgd2lsbCBiZSBkZWxldGVkLFxuICAgICAgLy8gYW5kIHRob3NlIGNvbW1hbmRzIGRldGVybWluZSB0aGF0IGZvciB0aGVtc2VsdmVzLlxuICAgICAgLy8gSWYgdGhlIE5PREVfTUFQIGlzIGRpcnR5LCB3ZSBjYW4ndCB0cnVzdCB0aGUgc2VsZWN0aW9uIGFuY2hvciAoZWcgUmVhY3RFZGl0b3IudG9ET01Qb2ludCB2aWEgUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKVxuICAgICAgaWYgKCghdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSB8fCB0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZUJ5JykpICYmICFJU19OT0RFX01BUF9ESVJUWS5nZXQoZWRpdG9yKSkge1xuICAgICAgICB2YXIgW3RhcmdldFJhbmdlXSA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpO1xuICAgICAgICBpZiAodGFyZ2V0UmFuZ2UpIHtcbiAgICAgICAgICB2YXIgX3JhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgdGFyZ2V0UmFuZ2UsIHtcbiAgICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKHNlbGVjdGlvbiwgX3JhbmdlKSkge1xuICAgICAgICAgICAgbmF0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uUmVmID0gIWlzQ29tcG9zaXRpb25DaGFuZ2UgJiYgZWRpdG9yLnNlbGVjdGlvbiAmJiBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3JhbmdlKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25SZWYpIHtcbiAgICAgICAgICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLnNldChlZGl0b3IsIHNlbGVjdGlvblJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NpdGlvbiBjaGFuZ2UgdHlwZXMgb2NjdXIgd2hpbGUgYSB1c2VyIGlzIGNvbXBvc2luZyB0ZXh0IGFuZCBjYW4ndCBiZVxuICAgICAgLy8gY2FuY2VsbGVkLiBMZXQgdGhlbSB0aHJvdWdoIGFuZCB3YWl0IGZvciB0aGUgY29tcG9zaXRpb24gdG8gZW5kLlxuICAgICAgaWYgKGlzQ29tcG9zaXRpb25DaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFuYXRpdmUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIC8vIENPTVBBVDogSWYgdGhlIHNlbGVjdGlvbiBpcyBleHBhbmRlZCwgZXZlbiBpZiB0aGUgY29tbWFuZCBzZWVtcyBsaWtlXG4gICAgICAvLyBhIGRlbGV0ZSBmb3J3YXJkL2JhY2t3YXJkIGNvbW1hbmQgaXQgc2hvdWxkIGRlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikgJiYgdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdHlwZS5lbmRzV2l0aCgnQmFja3dhcmQnKSA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCc7XG4gICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICBkaXJlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgICBjYXNlICdkZWxldGVCeURyYWcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50JzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RlbGV0ZUVudGlyZVNvZnRMaW5lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZGVsZXRlV29yZEJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnaW5zZXJ0TGluZUJyZWFrJzpcbiAgICAgICAgICBFZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luc2VydFBhcmFncmFwaCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmluc2VydEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21Db21wb3NpdGlvbic6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21Ecm9wJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVlhbmsnOlxuICAgICAgICBjYXNlICdpbnNlcnRSZXBsYWNlbWVudFRleHQnOlxuICAgICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2luc2VydEZyb21Db21wb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQ09NUEFUOiBpbiBTYWZhcmksIGBjb21wb3NpdGlvbmVuZGAgaXMgZGlzcGF0Y2hlZCBhZnRlciB0aGVcbiAgICAgICAgICAgICAgLy8gYGJlZm9yZWlucHV0YCBmb3IgXCJpbnNlcnRGcm9tQ29tcG9zaXRpb25cIi4gQnV0IGlmIHdlIHdhaXQgZm9yIGl0XG4gICAgICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBhYm9ydCBiZWNhdXNlIHdlJ3JlIHN0aWxsIGNvbXBvc2luZyBhbmQgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAvLyB3b24ndCBiZSB1cGRhdGVkIHByb3Blcmx5LlxuICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaW5wdXQtZXZlbnRzLTIvXG4gICAgICAgICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVzZSBhIHdlYWsgY29tcGFyaXNvbiBpbnN0ZWFkIG9mICdpbnN0YW5jZW9mJyB0byBhbGxvd1xuICAgICAgICAgICAgLy8gcHJvZ3JhbW1hdGljIGFjY2VzcyBvZiBwYXN0ZSBldmVudHMgY29taW5nIGZyb20gZXh0ZXJuYWwgd2luZG93c1xuICAgICAgICAgICAgLy8gbGlrZSBjeXByZXNzIHdoZXJlIGN5LndpbmRvdyBkb2VzIG5vdCB3b3JrIHJlYWxpYmx5XG4gICAgICAgICAgICBpZiAoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb25zdHJ1Y3Rvci5uYW1lKSA9PT0gJ0RhdGFUcmFuc2ZlcicpIHtcbiAgICAgICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gT25seSBpbnNlcnRUZXh0IG9wZXJhdGlvbnMgdXNlIHRoZSBuYXRpdmUgZnVuY3Rpb25hbGl0eSwgZm9yIG5vdy5cbiAgICAgICAgICAgICAgLy8gUG90ZW50aWFsbHkgZXhwYW5kIHRvIHNpbmdsZSBjaGFyYWN0ZXIgZGVsZXRlcywgYXMgd2VsbC5cbiAgICAgICAgICAgICAgaWYgKG5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkT3BlcmF0aW9ucy5jdXJyZW50LnB1c2goKCkgPT4gRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSB0aGUgYWN0dWFsIHVzZXIgc2VjdGlvbiBpZiBub3RoaW5nIG1hbnVhbGx5IHNldCBpdC5cbiAgICAgIHZhciB0b1Jlc3RvcmUgPSAoX0VESVRPUl9UT19VU0VSX1NFTEVDID0gRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1VTRVJfU0VMRUMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fVVNFUl9TRUxFQy51bnJlZigpO1xuICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgaWYgKHRvUmVzdG9yZSAmJiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhlZGl0b3Iuc2VsZWN0aW9uLCB0b1Jlc3RvcmUpKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHRvUmVzdG9yZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbZWRpdG9yLCBvbkRPTVNlbGVjdGlvbkNoYW5nZSwgb25Vc2VySW5wdXQsIHByb3BzT25ET01CZWZvcmVJbnB1dCwgcmVhZE9ubHksIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2VdKTtcbiAgdmFyIGNhbGxiYWNrUmVmID0gdXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuY2FuY2VsKCk7XG4gICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgRURJVE9SX1RPX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgICBpZiAocmVmLmN1cnJlbnQgJiYgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgVGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQgaXNuJ3QgcmVjb2duaXplZC5cbiAgICAgICAgcmVmLmN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBvbkRPTUJlZm9yZUlucHV0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXR0YWNoIGEgbmF0aXZlIERPTSBldmVudCBoYW5kbGVyIGZvciBgYmVmb3JlaW5wdXRgIGV2ZW50cywgYmVjYXVzZSBSZWFjdCdzXG4gICAgICAvLyBidWlsdC1pbiBgb25CZWZvcmVJbnB1dGAgaXMgYWN0dWFsbHkgYSBsZWFreSBwb2x5ZmlsbCB0aGF0IGRvZXNuJ3QgZXhwb3NlXG4gICAgICAvLyByZWFsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIHNhZGx5Li4uICgyMDE5LzExLzA0KVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTIxMVxuICAgICAgaWYgKEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlIFRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50IGlzbid0IHJlY29nbml6ZWQuXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JlaW5wdXQnLCBvbkRPTUJlZm9yZUlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmb3J3YXJkZWRSZWYobm9kZSk7XG4gICAgfSBlbHNlIGlmIChmb3J3YXJkZWRSZWYpIHtcbiAgICAgIGZvcndhcmRlZFJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICB9XG4gIH0sIFtvbkRPTVNlbGVjdGlvbkNoYW5nZSwgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSwgZWRpdG9yLCBvbkRPTUJlZm9yZUlucHV0LCBmb3J3YXJkZWRSZWZdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIC8vIEF0dGFjaCBhIG5hdGl2ZSBET00gZXZlbnQgaGFuZGxlciBmb3IgYHNlbGVjdGlvbmNoYW5nZWAsIGJlY2F1c2UgUmVhY3Qnc1xuICAgIC8vIGJ1aWx0LWluIGBvblNlbGVjdGAgaGFuZGxlciBkb2Vzbid0IGZpcmUgZm9yIGFsbCBzZWxlY3Rpb24gY2hhbmdlcy4gSXQnc1xuICAgIC8vIGEgbGVha3kgcG9seWZpbGwgdGhhdCBvbmx5IGZpcmVzIG9uIGtleXByZXNzZXMgb3IgY2xpY2tzLiBJbnN0ZWFkLCB3ZVxuICAgIC8vIHdhbnQgdG8gZmlyZSBmb3IgYW55IGNoYW5nZSB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSB0aGUgZWRpdG9yLlxuICAgIC8vICgyMDE5LzExLzA0KSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzU3ODVcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSk7XG4gICAgLy8gTGlzdGVuIGZvciBkcmFnZW5kIGFuZCBkcm9wIGdsb2JhbGx5LiBJbiBGaXJlZm94LCBpZiBhIGRyb3AgaGFuZGxlclxuICAgIC8vIGluaXRpYXRlcyBhbiBvcGVyYXRpb24gdGhhdCBjYXVzZXMgdGhlIG9yaWdpbmFsbHkgZHJhZ2dlZCBlbGVtZW50IHRvXG4gICAgLy8gdW5tb3VudCwgdGhhdCBlbGVtZW50IHdpbGwgbm90IGVtaXQgYSBkcmFnZW5kIGV2ZW50LiAoMjAyNC8wNi8yMSlcbiAgICB2YXIgc3RvcHBlZERyYWdnaW5nID0gKCkgPT4ge1xuICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSBmYWxzZTtcbiAgICB9O1xuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgc3RvcHBlZERyYWdnaW5nKTtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHN0b3BwZWREcmFnZ2luZyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgc3RvcHBlZERyYWdnaW5nKTtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgc3RvcHBlZERyYWdnaW5nKTtcbiAgICB9O1xuICB9LCBbc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSwgc3RhdGVdKTtcbiAgdmFyIGRlY29yYXRpb25zID0gZGVjb3JhdGUoW2VkaXRvciwgW11dKTtcbiAgdmFyIHNob3dQbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyICYmIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgQXJyYXkuZnJvbShOb2RlLnRleHRzKGVkaXRvcikpLmxlbmd0aCA9PT0gMSAmJiBOb2RlLnN0cmluZyhlZGl0b3IpID09PSAnJyAmJiAhaXNDb21wb3Npbmc7XG4gIHZhciBwbGFjZUhvbGRlclJlc2l6ZUhhbmRsZXIgPSB1c2VDYWxsYmFjayhwbGFjZWhvbGRlckVsID0+IHtcbiAgICBpZiAocGxhY2Vob2xkZXJFbCAmJiBzaG93UGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciBfcGxhY2Vob2xkZXJFbCRnZXRCb3U7XG4gICAgICBzZXRQbGFjZWhvbGRlckhlaWdodCgoX3BsYWNlaG9sZGVyRWwkZ2V0Qm91ID0gcGxhY2Vob2xkZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgPT09IG51bGwgfHwgX3BsYWNlaG9sZGVyRWwkZ2V0Qm91ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGxhY2Vob2xkZXJFbCRnZXRCb3UuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0UGxhY2Vob2xkZXJIZWlnaHQodW5kZWZpbmVkKTtcbiAgICB9XG4gIH0sIFtzaG93UGxhY2Vob2xkZXJdKTtcbiAgaWYgKHNob3dQbGFjZWhvbGRlcikge1xuICAgIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKTtcbiAgICBkZWNvcmF0aW9ucy5wdXNoKHtcbiAgICAgIFtQTEFDRUhPTERFUl9TWU1CT0xdOiB0cnVlLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBvblBsYWNlaG9sZGVyUmVzaXplOiBwbGFjZUhvbGRlclJlc2l6ZUhhbmRsZXIsXG4gICAgICBhbmNob3I6IHN0YXJ0LFxuICAgICAgZm9jdXM6IHN0YXJ0XG4gICAgfSk7XG4gIH1cbiAgdmFyIHtcbiAgICBtYXJrc1xuICB9ID0gZWRpdG9yO1xuICBzdGF0ZS5oYXNNYXJrUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikgJiYgbWFya3MpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yXG4gICAgfSA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYoZWRpdG9yLCBhbmNob3IucGF0aCk7XG4gICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobGVhZiwgX2V4Y2x1ZGVkMik7XG4gICAgLy8gV2hpbGUgbWFya3MgaXNuJ3QgYSAnY29tcGxldGUnIHRleHQsIHdlIGNhbiBzdGlsbCB1c2UgbG9vc2UgVGV4dC5lcXVhbHNcbiAgICAvLyBoZXJlIHdoaWNoIG9ubHkgY29tcGFyZXMgbWFya3MgYW55d2F5LlxuICAgIGlmICghVGV4dCQxLmVxdWFscyhsZWFmLCBtYXJrcywge1xuICAgICAgbG9vc2U6IHRydWVcbiAgICB9KSkge1xuICAgICAgc3RhdGUuaGFzTWFya1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHZhciB1bnNldCA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhyZXN0KS5tYXAobWFyayA9PiBbbWFyaywgbnVsbF0pKTtcbiAgICAgIGRlY29yYXRpb25zLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBbTUFSS19QTEFDRUhPTERFUl9TWU1CT0xdOiB0cnVlXG4gICAgICB9LCB1bnNldCksIG1hcmtzKSwge30sIHtcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmb2N1czogYW5jaG9yXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIC8vIFVwZGF0ZSBFRElUT1JfVE9fTUFSS19QTEFDRUhPTERFUl9NQVJLUyBpbiBzZXRUaW1lb3V0IHVzZUVmZmVjdCB0byBlbnN1cmUgd2UgZG9uJ3Qgc2V0IGl0XG4gIC8vIGJlZm9yZSB3ZSByZWNlaXZlIHRoZSBjb21wb3NpdGlvbiBlbmQgZXZlbnQuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgYW5jaG9yOiBfYW5jaG9yXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIHZhciBfdGV4dCA9IE5vZGUubGVhZihlZGl0b3IsIF9hbmNob3IucGF0aCk7XG4gICAgICAgIC8vIFdoaWxlIG1hcmtzIGlzbid0IGEgJ2NvbXBsZXRlJyB0ZXh0LCB3ZSBjYW4gc3RpbGwgdXNlIGxvb3NlIFRleHQuZXF1YWxzXG4gICAgICAgIC8vIGhlcmUgd2hpY2ggb25seSBjb21wYXJlcyBtYXJrcyBhbnl3YXkuXG4gICAgICAgIGlmIChtYXJrcyAmJiAhVGV4dCQxLmVxdWFscyhfdGV4dCwgbWFya3MsIHtcbiAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZWRpdG9yLCBtYXJrcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZGVsZXRlKGVkaXRvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhZE9ubHlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlYWRPbmx5XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvc2luZ0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaXNDb21wb3NpbmdcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVjb3JhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRlY29yYXRlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlc3RvcmVET00sIHtcbiAgICBub2RlOiByZWYsXG4gICAgcmVjZWl2ZWRVc2VySW5wdXQ6IHJlY2VpdmVkVXNlcklucHV0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICByb2xlOiByZWFkT25seSA/IHVuZGVmaW5lZCA6ICd0ZXh0Ym94JyxcbiAgICBcImFyaWEtbXVsdGlsaW5lXCI6IHJlYWRPbmx5ID8gdW5kZWZpbmVkIDogdHJ1ZVxuICB9LCBhdHRyaWJ1dGVzKSwge30sIHtcbiAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2UnZFxuICAgIC8vIGhhdmUgdG8gdXNlIGhhY2tzIHRvIG1ha2UgdGhlc2UgcmVwbGFjZW1lbnQtYmFzZWQgZmVhdHVyZXMgd29yay5cbiAgICAvLyBGb3IgU1NSIHNpdHVhdGlvbnMgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIGlzIGZhbHNlIGFuZCByZXN1bHRzIGluIHByb3BcbiAgICAvLyBtaXNtYXRjaCB3YXJuaW5nIGFwcCBtb3ZlcyB0byBicm93c2VyLiBQYXNzLXRocm91Z2ggY29uc3VtZXIgcHJvcHMgd2hlblxuICAgIC8vIG5vdCBDQU5fVVNFX0RPTSAoU1NSKSBhbmQgZGVmYXVsdCB0byBmYWxzeSB2YWx1ZVxuICAgIHNwZWxsQ2hlY2s6IEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCAhQ0FOX1VTRV9ET00gPyBhdHRyaWJ1dGVzLnNwZWxsQ2hlY2sgOiBmYWxzZSxcbiAgICBhdXRvQ29ycmVjdDogSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8ICFDQU5fVVNFX0RPTSA/IGF0dHJpYnV0ZXMuYXV0b0NvcnJlY3QgOiAnZmFsc2UnLFxuICAgIGF1dG9DYXBpdGFsaXplOiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgIUNBTl9VU0VfRE9NID8gYXR0cmlidXRlcy5hdXRvQ2FwaXRhbGl6ZSA6ICdmYWxzZScsXG4gICAgXCJkYXRhLXNsYXRlLWVkaXRvclwiOiB0cnVlLFxuICAgIFwiZGF0YS1zbGF0ZS1ub2RlXCI6IFwidmFsdWVcIixcbiAgICAvLyBleHBsaWNpdGx5IHNldCB0aGlzXG4gICAgY29udGVudEVkaXRhYmxlOiAhcmVhZE9ubHksXG4gICAgLy8gaW4gc29tZSBjYXNlcywgYSBkZWNvcmF0aW9uIG5lZWRzIGFjY2VzcyB0byB0aGUgcmFuZ2UgLyBzZWxlY3Rpb24gdG8gZGVjb3JhdGUgYSB0ZXh0IG5vZGUsXG4gICAgLy8gdGhlbiB5b3Ugd2lsbCBzZWxlY3QgdGhlIHdob2xlIHRleHQgbm9kZSB3aGVuIHlvdSBzZWxlY3QgcGFydCB0aGUgb2YgdGV4dFxuICAgIC8vIHRoaXMgbWFnaWMgekluZGV4PVwiLTFcIiB3aWxsIGZpeCBpdFxuICAgIHppbmRleDogLTEsXG4gICAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiB0cnVlLFxuICAgIHJlZjogY2FsbGJhY2tSZWYsXG4gICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGlzYWJsZURlZmF1bHRTdHlsZXMgPyB7fSA6IF9vYmplY3RTcHJlYWQoe1xuICAgICAgLy8gQWxsb3cgcG9zaXRpb25pbmcgcmVsYXRpdmUgdG8gdGhlIGVkaXRhYmxlIGVsZW1lbnQuXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIC8vIFByZXNlcnZlIGFkamFjZW50IHdoaXRlc3BhY2UgYW5kIG5ldyBsaW5lcy5cbiAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAvLyBBbGxvdyB3b3JkcyB0byBicmVhayBpZiB0aGV5IGFyZSB0b28gbG9uZy5cbiAgICAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCdcbiAgICB9LCBwbGFjZWhvbGRlckhlaWdodCA/IHtcbiAgICAgIG1pbkhlaWdodDogcGxhY2Vob2xkZXJIZWlnaHRcbiAgICB9IDoge30pKSwgdXNlclN0eWxlKSxcbiAgICBvbkJlZm9yZUlucHV0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgIC8vIGZhbGwgYmFjayB0byBSZWFjdCdzIGxlYWt5IHBvbHlmaWxsIGluc3RlYWQganVzdCBmb3IgaXQuIEl0XG4gICAgICAvLyBvbmx5IHdvcmtzIGZvciB0aGUgYGluc2VydFRleHRgIGlucHV0IHR5cGUuXG4gICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCAmJiAhcmVhZE9ubHkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQmVmb3JlSW5wdXQpICYmIFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSkge1xuICAgICAgICAgIHZhciBfdGV4dDIgPSBldmVudC5kYXRhO1xuICAgICAgICAgIEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgX3RleHQyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQmVmb3JlSW5wdXQsIGVkaXRvciwgcmVhZE9ubHldKSxcbiAgICBvbklucHV0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25JbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGFuZHJvaWRJbnB1dE1hbmFnZXJSZWYuY3VycmVudCkge1xuICAgICAgICBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQuaGFuZGxlSW5wdXQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gRmx1c2ggbmF0aXZlIG9wZXJhdGlvbnMsIGFzIG5hdGl2ZSBldmVudHMgd2lsbCBoYXZlIHByb3BvZ2F0ZWRcbiAgICAgIC8vIGFuZCB3ZSBjYW4gY29ycmVjdGx5IGNvbXBhcmUgRE9NIHRleHQgdmFsdWVzIGluIGNvbXBvbmVudHNcbiAgICAgIC8vIHRvIHN0b3AgcmVuZGVyaW5nLCBzbyB0aGF0IGJyb3dzZXIgZnVuY3Rpb25zIGxpa2UgYXV0b2NvcnJlY3RcbiAgICAgIC8vIGFuZCBzcGVsbGNoZWNrIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICBmb3IgKHZhciBvcCBvZiBkZWZlcnJlZE9wZXJhdGlvbnMuY3VycmVudCkge1xuICAgICAgICBvcCgpO1xuICAgICAgfVxuICAgICAgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQgPSBbXTtcbiAgICAgIC8vIENPTVBBVDogU2luY2UgYGJlZm9yZWlucHV0YCBkb2Vzbid0IGZ1bGx5IGBwcmV2ZW50RGVmYXVsdGAsXG4gICAgICAvLyB0aGVyZSdzIGEgY2hhbmNlIHRoYXQgY29udGVudCBtaWdodCBiZSBwbGFjZWQgaW4gdGhlIGJyb3dzZXIncyB1bmRvIHN0YWNrLlxuICAgICAgLy8gVGhpcyBtZWFucyB1bmRvIGNhbiBiZSB0cmlnZ2VyZWQgZXZlbiB3aGVuIHRoZSBkaXYgaXMgbm90IGZvY3VzZWQsXG4gICAgICAvLyBhbmQgaXQgb25seSB0cmlnZ2VycyB0aGUgaW5wdXQgZXZlbnQgZm9yIHRoZSBub2RlLiAoMjAyNC8xMC8wOSlcbiAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpIHtcbiAgICAgICAgdmFyIG5hdGl2ZSA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgICAgICB2YXIgbWF5YmVIaXN0b3J5RWRpdG9yID0gZWRpdG9yO1xuICAgICAgICBpZiAobmF0aXZlLmlucHV0VHlwZSA9PT0gJ2hpc3RvcnlVbmRvJyAmJiB0eXBlb2YgbWF5YmVIaXN0b3J5RWRpdG9yLnVuZG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBtYXliZUhpc3RvcnlFZGl0b3IudW5kbygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF0aXZlLmlucHV0VHlwZSA9PT0gJ2hpc3RvcnlSZWRvJyAmJiB0eXBlb2YgbWF5YmVIaXN0b3J5RWRpdG9yLnJlZG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBtYXliZUhpc3RvcnlFZGl0b3IucmVkbygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uSW5wdXQsIGVkaXRvcl0pLFxuICAgIG9uQmx1cjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKHJlYWRPbmx5IHx8IHN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gfHwgIVJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpIHx8IGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQmx1cikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ09NUEFUOiBJZiB0aGUgY3VycmVudCBgYWN0aXZlRWxlbWVudGAgaXMgc3RpbGwgdGhlIHByZXZpb3VzXG4gICAgICAvLyBvbmUsIHRoaXMgaXMgZHVlIHRvIHRoZSB3aW5kb3cgYmVpbmcgYmx1cnJlZCB3aGVuIHRoZSB0YWJcbiAgICAgIC8vIGl0c2VsZiBiZWNvbWVzIHVuZm9jdXNlZCwgc28gd2Ugd2FudCB0byBhYm9ydCBlYXJseSB0byBhbGxvdyB0b1xuICAgICAgLy8gZWRpdG9yIHRvIHN0YXkgZm9jdXNlZCB3aGVuIHRoZSB0YWIgYmVjb21lcyBmb2N1c2VkIGFnYWluLlxuICAgICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICAgIGlmIChzdGF0ZS5sYXRlc3RFbGVtZW50ID09PSByb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgIC8vIENPTVBBVDogVGhlIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkIGlmIHRoZSBmb2N1cyBpcyByZXR1cm5pbmdcbiAgICAgIC8vIHRvIHRoZSBlZGl0b3IgZnJvbSBhbiBlbWJlZGRlZCBlZGl0YWJsZSBlbGVtZW50IChlZy4gYW4gPGlucHV0PlxuICAgICAgLy8gZWxlbWVudCBpbnNpZGUgYSB2b2lkIG5vZGUpLlxuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgPT09IGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIENPTVBBVDogVGhlIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkIGlmIHRoZSBmb2N1cyBpcyBtb3ZpbmcgZnJvbVxuICAgICAgLy8gdGhlIGVkaXRvciB0byBpbnNpZGUgYSB2b2lkIG5vZGUncyBzcGFjZXIgZWxlbWVudC5cbiAgICAgIGlmIChpc0RPTUVsZW1lbnQocmVsYXRlZFRhcmdldCkgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtc3BhY2VyJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIG1vdmluZyB0byBhXG4gICAgICAvLyBub24tIGVkaXRhYmxlIHNlY3Rpb24gb2YgYW4gZWxlbWVudCB0aGF0IGlzbid0IGEgdm9pZCBub2RlIChlZy5cbiAgICAgIC8vIGEgbGlzdCBpdGVtIG9mIHRoZSBjaGVjayBsaXN0IGV4YW1wbGUpLlxuICAgICAgaWYgKHJlbGF0ZWRUYXJnZXQgIT0gbnVsbCAmJiBpc0RPTU5vZGUocmVsYXRlZFRhcmdldCkgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc1ZvaWQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENPTVBBVDogU2FmYXJpIGRvZXNuJ3QgYWx3YXlzIHJlbW92ZSB0aGUgc2VsZWN0aW9uIGV2ZW4gaWYgdGhlIGNvbnRlbnQtXG4gICAgICAvLyBlZGl0YWJsZSBlbGVtZW50IG5vIGxvbmdlciBoYXMgZm9jdXMuIFJlZmVyIHRvOlxuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIzNTMyNDcvZm9yY2UtY29udGVudGVkaXRhYmxlLWRpdi10by1zdG9wLWFjY2VwdGluZy1pbnB1dC1hZnRlci1pdC1sb3Nlcy1mb2N1cy11bmRlci13ZWJcbiAgICAgIGlmIChJU19XRUJLSVQpIHtcbiAgICAgICAgdmFyIGRvbVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihyb290KTtcbiAgICAgICAgZG9tU2VsZWN0aW9uID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gdm9pZCAwIHx8IGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICAgIElTX0ZPQ1VTRUQuZGVsZXRlKGVkaXRvcik7XG4gICAgfSwgW3JlYWRPbmx5LCBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uLCBzdGF0ZS5sYXRlc3RFbGVtZW50LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25CbHVyXSksXG4gICAgb25DbGljazogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ2xpY2spICYmIGlzRE9NTm9kZShldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgICAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIC8vIEF0IHRoaXMgdGltZSwgdGhlIFNsYXRlIGRvY3VtZW50IG1heSBiZSBhcmJpdHJhcmlseSBkaWZmZXJlbnQsXG4gICAgICAgIC8vIGJlY2F1c2Ugb25DbGljayBoYW5kbGVycyBjYW4gY2hhbmdlIHRoZSBkb2N1bWVudCBiZWZvcmUgd2UgZ2V0IGhlcmUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhpcyBwYXRoIGFjdHVhbGx5IGV4aXN0cyxcbiAgICAgICAgLy8gYW5kIHRoYXQgaXQgc3RpbGwgcmVmZXJzIHRvIHRoZSBzYW1lIG5vZGUuXG4gICAgICAgIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBwYXRoKSB8fCBOb2RlLmdldChlZGl0b3IsIHBhdGgpICE9PSBub2RlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5kZXRhaWwgPT09IFRSSVBMRV9DTElDSyAmJiBwYXRoLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgdmFyIGJsb2NrUGF0aCA9IHBhdGg7XG4gICAgICAgICAgaWYgKCEoRWxlbWVudCQxLmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG5vZGUpKSkge1xuICAgICAgICAgICAgdmFyIF9ibG9jayQ7XG4gICAgICAgICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQkMS5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmxvY2tQYXRoID0gKF9ibG9jayQgPSBibG9jayA9PT0gbnVsbCB8fCBibG9jayA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmxvY2tbMV0pICE9PSBudWxsICYmIF9ibG9jayQgIT09IHZvaWQgMCA/IF9ibG9jayQgOiBwYXRoLnNsaWNlKDAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZE9ubHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9zdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgc3RhcnRWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IF9zdGFydFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGVuZFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RhcnRWb2lkICYmIGVuZFZvaWQgJiYgUGF0aC5lcXVhbHMoc3RhcnRWb2lkWzFdLCBlbmRWb2lkWzFdKSkge1xuICAgICAgICAgIHZhciBfcmFuZ2UyID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgX3N0YXJ0KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9yYW5nZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2VkaXRvciwgYXR0cmlidXRlcy5vbkNsaWNrLCByZWFkT25seV0pLFxuICAgIG9uQ29tcG9zaXRpb25FbmQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICB2YXIgX2FuZHJvaWRJbnB1dE1hbmFnZXJSMztcbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHNldElzQ29tcG9zaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjMgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjMgPT09IHZvaWQgMCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclIzLmhhbmRsZUNvbXBvc2l0aW9uRW5kKGV2ZW50KTtcbiAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25FbmQpIHx8IElTX0FORFJPSUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09NUEFUOiBJbiBDaHJvbWUsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIGZvciBjb21wb3NpdGlvbnNcbiAgICAgICAgLy8gYXJlbid0IGNvcnJlY3QgYW5kIG5ldmVyIGZpcmUgdGhlIFwiaW5zZXJ0RnJvbUNvbXBvc2l0aW9uXCJcbiAgICAgICAgLy8gdHlwZSB0aGF0IHdlIG5lZWQuIFNvIGluc3RlYWQsIGluc2VydCB3aGVuZXZlciBhIGNvbXBvc2l0aW9uXG4gICAgICAgIC8vIGVuZHMgc2luY2UgaXQgd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBjb21taXR0ZWQgdG8gdGhlIERPTS5cbiAgICAgICAgaWYgKCFJU19XRUJLSVQgJiYgIUlTX0ZJUkVGT1hfTEVHQUNZICYmICFJU19JT1MgJiYgIUlTX1dFQ0hBVEJST1dTRVIgJiYgIUlTX1VDX01PQklMRSAmJiBldmVudC5kYXRhKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyTWFya3MgPSBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICAgIC8vIEVuc3VyZSB3ZSBpbnNlcnQgdGV4dCB3aXRoIHRoZSBtYXJrcyB0aGUgdXNlciB3YXMgYWN0dWFsbHkgc2VlaW5nXG4gICAgICAgICAgaWYgKHBsYWNlaG9sZGVyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1Muc2V0KGVkaXRvciwgZWRpdG9yLm1hcmtzKTtcbiAgICAgICAgICAgIGVkaXRvci5tYXJrcyA9IHBsYWNlaG9sZGVyTWFya3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgdmFyIHVzZXJNYXJrcyA9IEVESVRPUl9UT19VU0VSX01BUktTLmdldChlZGl0b3IpO1xuICAgICAgICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICAgIGlmICh1c2VyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdG9yLm1hcmtzID0gdXNlck1hcmtzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25FbmQsIGVkaXRvcl0pLFxuICAgIG9uQ29tcG9zaXRpb25VcGRhdGU6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Db21wb3NpdGlvblVwZGF0ZSkpIHtcbiAgICAgICAgaWYgKCFSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgc2V0SXNDb21wb3NpbmcodHJ1ZSk7XG4gICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvblVwZGF0ZSwgZWRpdG9yXSksXG4gICAgb25Db21wb3NpdGlvblN0YXJ0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgdmFyIF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjQ7XG4gICAgICAgIChfYW5kcm9pZElucHV0TWFuYWdlclI0ID0gYW5kcm9pZElucHV0TWFuYWdlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclI0ID09PSB2b2lkIDAgfHwgX2FuZHJvaWRJbnB1dE1hbmFnZXJSNC5oYW5kbGVDb21wb3NpdGlvblN0YXJ0KGV2ZW50KTtcbiAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25TdGFydCkgfHwgSVNfQU5EUk9JRCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc0NvbXBvc2luZyh0cnVlKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uU3RhcnQsIGVkaXRvcl0pLFxuICAgIG9uQ29weTogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvcHkpICYmICFpc0RPTUV2ZW50VGFyZ2V0SW5wdXQoZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEsICdjb3B5Jyk7XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db3B5LCBlZGl0b3JdKSxcbiAgICBvbkN1dDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25DdXQpICYmICFpc0RPTUV2ZW50VGFyZ2V0SW5wdXQoZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEsICdjdXQnKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IE5vZGUucGFyZW50KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvci5wYXRoKTtcbiAgICAgICAgICAgIGlmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGVkaXRvciwgYXR0cmlidXRlcy5vbkN1dF0pLFxuICAgIG9uRHJhZ092ZXI6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkRyYWdPdmVyKSkge1xuICAgICAgICAvLyBPbmx5IHdoZW4gdGhlIHRhcmdldCBpcyB2b2lkLCBjYWxsIGBwcmV2ZW50RGVmYXVsdGAgdG8gc2lnbmFsXG4gICAgICAgIC8vIHRoYXQgZHJvcHMgYXJlIGFsbG93ZWQuIEVkaXRhYmxlIGNvbnRlbnQgaXMgZHJvcHBhYmxlIGJ5XG4gICAgICAgIC8vIGRlZmF1bHQsIGFuZCBjYWxsaW5nIGBwcmV2ZW50RGVmYXVsdGAgaGlkZXMgdGhlIGN1cnNvci5cbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkRyYWdPdmVyLCBlZGl0b3JdKSxcbiAgICBvbkRyYWdTdGFydDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkRyYWdTdGFydCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgdmFyIHZvaWRNYXRjaCA9IEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiBzdGFydGluZyBhIGRyYWcgb24gYSB2b2lkIG5vZGUsIG1ha2Ugc3VyZSBpdCBpcyBzZWxlY3RlZFxuICAgICAgICAvLyBzbyB0aGF0IGl0IHNob3dzIHVwIGluIHRoZSBzZWxlY3Rpb24ncyBmcmFnbWVudC5cbiAgICAgICAgaWYgKHZvaWRNYXRjaCkge1xuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZXZlbnQuZGF0YVRyYW5zZmVyLCAnZHJhZycpO1xuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uRHJhZ1N0YXJ0LCBzdGF0ZV0pLFxuICAgIG9uRHJvcDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkRyb3ApKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGRyYWdnZWQgcmFuZ2UgYmVmb3JlIHVwZGF0aW5nIHNlbGVjdGlvblxuICAgICAgICB2YXIgZHJhZ2dlZFJhbmdlID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgICAgLy8gRmluZCB0aGUgcmFuZ2Ugd2hlcmUgdGhlIGRyb3AgaGFwcGVuZWRcbiAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IuZmluZEV2ZW50UmFuZ2UoZWRpdG9yLCBldmVudCk7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVRyYW5zZmVyO1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgaWYgKHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5KSB7XG4gICAgICAgICAgaWYgKGRyYWdnZWRSYW5nZSAmJiAhUmFuZ2UuZXF1YWxzKGRyYWdnZWRSYW5nZSwgcmFuZ2UpICYmICFFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogZHJhZ2dlZFJhbmdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpO1xuICAgICAgICAvLyBXaGVuIGRyYWdnaW5nIGZyb20gYW5vdGhlciBzb3VyY2UgaW50byB0aGUgZWRpdG9yLCBpdCdzIHBvc3NpYmxlXG4gICAgICAgIC8vIHRoYXQgdGhlIGN1cnJlbnQgZWRpdG9yIGRvZXMgbm90IGhhdmUgZm9jdXMuXG4gICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpIHtcbiAgICAgICAgICBSZWFjdEVkaXRvci5mb2N1cyhlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBlZGl0b3IsIGF0dHJpYnV0ZXMub25Ecm9wLCBzdGF0ZV0pLFxuICAgIG9uRHJhZ0VuZDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSAmJiBhdHRyaWJ1dGVzLm9uRHJhZ0VuZCAmJiBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMub25EcmFnRW5kKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIHN0YXRlLCBhdHRyaWJ1dGVzLCBlZGl0b3JdKSxcbiAgICBvbkZvY3VzOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmICFzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25Gb2N1cykpIHtcbiAgICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICAgICAgc3RhdGUubGF0ZXN0RWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gQ09NUEFUOiBJZiB0aGUgZWRpdG9yIGhhcyBuZXN0ZWQgZWRpdGFibGUgZWxlbWVudHMsIHRoZSBmb2N1c1xuICAgICAgICAvLyBjYW4gZ28gdG8gdGhlbS4gSW4gRmlyZWZveCwgdGhpcyBtdXN0IGJlIHByZXZlbnRlZCBiZWNhdXNlIGl0XG4gICAgICAgIC8vIHJlc3VsdHMgaW4gaXNzdWVzIHdpdGgga2V5Ym9hcmQgbmF2aWdhdGlvbi4gKDIwMTcvMDMvMzApXG4gICAgICAgIGlmIChJU19GSVJFRk9YICYmIGV2ZW50LnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgc3RhdGUsIGVkaXRvciwgYXR0cmlidXRlcy5vbkZvY3VzXSksXG4gICAgb25LZXlEb3duOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICB2YXIgX2FuZHJvaWRJbnB1dE1hbmFnZXJSNTtcbiAgICAgICAgKF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjUgPSBhbmRyb2lkSW5wdXRNYW5hZ2VyUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hbmRyb2lkSW5wdXRNYW5hZ2VyUjUgPT09IHZvaWQgMCB8fCBfYW5kcm9pZElucHV0TWFuYWdlclI1LmhhbmRsZUtleURvd24oZXZlbnQpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgLy8gQ09NUEFUOiBUaGUgY29tcG9zaXRpb24gZW5kIGV2ZW50IGlzbid0IGZpcmVkIHJlbGlhYmx5IGluIGFsbCBicm93c2VycyxcbiAgICAgICAgLy8gc28gd2Ugc29tZXRpbWVzIG1pZ2h0IGVuZCB1cCBzdHVjayBpbiBhIGNvbXBvc2l0aW9uIHN0YXRlIGV2ZW4gdGhvdWdoIHdlXG4gICAgICAgIC8vIGFyZW4ndCBjb21wb3NpbmcgYW55IG1vcmUuXG4gICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpICYmIG5hdGl2ZUV2ZW50LmlzQ29tcG9zaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbktleURvd24pIHx8IFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBlZGl0b3IuY2hpbGRyZW5bc2VsZWN0aW9uICE9PSBudWxsID8gc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0gOiAwXTtcbiAgICAgICAgdmFyIGlzUlRMID0gZ2V0RGlyZWN0aW9uKE5vZGUuc3RyaW5nKGVsZW1lbnQpKSA9PT0gJ3J0bCc7XG4gICAgICAgIC8vIENPTVBBVDogU2luY2Ugd2UgcHJldmVudCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvblxuICAgICAgICAvLyBgYmVmb3JlaW5wdXRgIGV2ZW50cywgdGhlIGJyb3dzZXIgZG9lc24ndCB0aGluayB0aGVyZSdzIGV2ZXJcbiAgICAgICAgLy8gYW55IGhpc3Rvcnkgc3RhY2sgdG8gdW5kbyBvciByZWRvLCBzbyB3ZSBoYXZlIHRvIG1hbmFnZSB0aGVzZVxuICAgICAgICAvLyBob3RrZXlzIG91cnNlbHZlcy4gKDIwMTkvMTEvMDYpXG4gICAgICAgIGlmIChIb3RrZXlzLmlzUmVkbyhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHZhciBtYXliZUhpc3RvcnlFZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXliZUhpc3RvcnlFZGl0b3IucmVkbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVIaXN0b3J5RWRpdG9yLnJlZG8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChIb3RrZXlzLmlzVW5kbyhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHZhciBfbWF5YmVIaXN0b3J5RWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgIGlmICh0eXBlb2YgX21heWJlSGlzdG9yeUVkaXRvci51bmRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBfbWF5YmVIaXN0b3J5RWRpdG9yLnVuZG8oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBoYW5kbGUgdGhlIHNlbGVjdGlvbiB1cGRhdGVzXG4gICAgICAgIC8vIHByb3Blcmx5LiBJbiBDaHJvbWUsIHRoZSBzZWxlY3Rpb24gaXNuJ3QgcHJvcGVybHkgZXh0ZW5kZWQuXG4gICAgICAgIC8vIEFuZCBpbiBGaXJlZm94LCB0aGUgc2VsZWN0aW9uIGlzbid0IHByb3Blcmx5IGNvbGxhcHNlZC5cbiAgICAgICAgLy8gKDIwMTcvMTAvMTcpXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUxpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhvdGtleXMuaXNFeHRlbmRMaW5lQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnbGluZScsXG4gICAgICAgICAgICBlZGdlOiAnZm9jdXMnLFxuICAgICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSG90a2V5cy5pc0V4dGVuZExpbmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDT01QQVQ6IElmIGEgdm9pZCBub2RlIGlzIHNlbGVjdGVkLCBvciBhIHplcm8td2lkdGggdGV4dCBub2RlXG4gICAgICAgIC8vIGFkamFjZW50IHRvIGFuIGlubGluZSBpcyBzZWxlY3RlZCwgd2UgbmVlZCB0byBoYW5kbGUgdGhlc2VcbiAgICAgICAgLy8gaG90a2V5cyBtYW51YWxseSBiZWNhdXNlIGJyb3dzZXJzIHdvbid0IGJlIGFibGUgdG8gc2tpcCBvdmVyXG4gICAgICAgIC8vIHRoZSB2b2lkIG5vZGUgd2l0aCB0aGUgemVyby13aWR0aCBzcGFjZSBub3QgYmVpbmcgYW4gZW1wdHlcbiAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICByZXZlcnNlOiAhaXNSVExcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiBpc1JUTCA/ICdlbmQnIDogJ3N0YXJ0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHJldmVyc2U6IGlzUlRMXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogaXNSVEwgPyAnc3RhcnQnIDogJ2VuZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlV29yZEJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuY29sbGFwc2UoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGVkZ2U6ICdmb2N1cydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnd29yZCcsXG4gICAgICAgICAgICByZXZlcnNlOiAhaXNSVExcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlV29yZEZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJyxcbiAgICAgICAgICAgIHJldmVyc2U6IGlzUlRMXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZVxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gZ3Vlc3NpbmcgYXQgdGhlIGlucHV0IGludGVudGlvbiBmb3IgaG90a2V5cy5cbiAgICAgICAgLy8gQ09NUEFUOiBJbiBpT1MsIHNvbWUgb2YgdGhlc2UgaG90a2V5cyBhcmUgaGFuZGxlZCBpbiB0aGVcbiAgICAgICAgaWYgKCFIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQpIHtcbiAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGEgY29yZSBiZWhhdmlvciBmb3IgdGhlc2UsIGJ1dCB0aGV5IGNoYW5nZSB0aGVcbiAgICAgICAgICAvLyBET00gaWYgd2UgZG9uJ3QgcHJldmVudCB0aGVtLCBzbyB3ZSBoYXZlIHRvLlxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzQm9sZChuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc0l0YWxpYyhuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc1RyYW5zcG9zZUNoYXJhY3RlcihuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzU29mdEJyZWFrKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNTcGxpdEJsb2NrKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIEVkaXRvci5pbnNlcnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUxpbmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVXb3JkQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlV29yZEZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoSVNfQ0hST01FIHx8IElTX1dFQktJVCkge1xuICAgICAgICAgICAgLy8gQ09NUEFUOiBDaHJvbWUgYW5kIFNhZmFyaSBzdXBwb3J0IGBiZWZvcmVpbnB1dGAgZXZlbnQgYnV0IGRvIG5vdCBmaXJlXG4gICAgICAgICAgICAvLyBhbiBldmVudCB3aGVuIGRlbGV0aW5nIGJhY2t3YXJkcyBpbiBhIHNlbGVjdGVkIHZvaWQgaW5saW5lIG5vZGVcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgKEhvdGtleXMuaXNEZWxldGVCYWNrd2FyZChuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc0RlbGV0ZUZvcndhcmQobmF0aXZlRXZlbnQpKSAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IE5vZGUucGFyZW50KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvci5wYXRoKTtcbiAgICAgICAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQoY3VycmVudE5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBjdXJyZW50Tm9kZSkgJiYgKEVkaXRvci5pc0lubGluZShlZGl0b3IsIGN1cnJlbnROb2RlKSB8fCBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIGN1cnJlbnROb2RlKSkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHksIGVkaXRvciwgYXR0cmlidXRlcy5vbktleURvd25dKSxcbiAgICBvblBhc3RlOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25QYXN0ZSkpIHtcbiAgICAgICAgLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQsIHNvIHdlXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBSZWFjdCdzIGBvblBhc3RlYCBoZXJlIGluc3RlYWQuXG4gICAgICAgIC8vIENPTVBBVDogRmlyZWZveCwgQ2hyb21lIGFuZCBTYWZhcmkgZG9uJ3QgZW1pdCBgYmVmb3JlaW5wdXRgIGV2ZW50c1xuICAgICAgICAvLyB3aGVuIFwicGFzdGUgd2l0aG91dCBmb3JtYXR0aW5nXCIgaXMgdXNlZCwgc28gZmFsbGJhY2suICgyMDIwLzAyLzIwKVxuICAgICAgICAvLyBDT01QQVQ6IFNhZmFyaSBJbnB1dEV2ZW50cyBnZW5lcmF0ZWQgYnkgcGFzdGluZyB3b24ndCBpbmNsdWRlXG4gICAgICAgIC8vIGFwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQgaXRlbXMsIHNvIHVzZSB0aGVcbiAgICAgICAgLy8gQ2xpcGJvYXJkRXZlbnQgaGVyZS4gKDIwMjMvMDMvMTUpXG4gICAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8IGlzUGxhaW5UZXh0T25seVBhc3RlKGV2ZW50Lm5hdGl2ZUV2ZW50KSB8fCBJU19XRUJLSVQpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBldmVudC5jbGlwYm9hcmREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgZWRpdG9yLCBhdHRyaWJ1dGVzLm9uUGFzdGVdKVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpbGRyZW4sIHtcbiAgICBkZWNvcmF0aW9uczogZGVjb3JhdGlvbnMsXG4gICAgbm9kZTogZWRpdG9yLFxuICAgIHJlbmRlckVsZW1lbnQ6IHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uOiBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0pKSkpKSk7XG59KTtcbi8qKlxuICogVGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgZWxlbWVudFxuICovXG52YXIgRGVmYXVsdFBsYWNlaG9sZGVyID0gX3JlZiA9PiB7XG4gIHZhciB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgLy8gQ09NUEFUOiBBcnRpZmljaWFsbHkgYWRkIGEgbGluZS1icmVhayB0byB0aGUgZW5kIG9uIHRoZSBwbGFjZWhvbGRlciBlbGVtZW50XG4gICAgLy8gdG8gcHJldmVudCBBbmRyb2lkIElNRXMgdG8gcGljayB1cCBpdHMgY29udGVudCBpbiBhdXRvY29ycmVjdCBhbmQgdG8gYXV0by1jYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXJcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfb2JqZWN0U3ByZWFkKHt9LCBhdHRyaWJ1dGVzKSwgY2hpbGRyZW4sIElTX0FORFJPSUQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKSlcbiAgKTtcbn07XG4vKipcbiAqIEEgZGVmYXVsdCBtZW1vaXplZCBkZWNvcmF0ZSBmdW5jdGlvbi5cbiAqL1xudmFyIGRlZmF1bHREZWNvcmF0ZSA9ICgpID0+IFtdO1xuLyoqXG4gKiBBIGRlZmF1bHQgaW1wbGVtZW50IHRvIHNjcm9sbCBkb20gcmFuZ2UgaW50byB2aWV3LlxuICovXG52YXIgZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID0gKGVkaXRvciwgZG9tUmFuZ2UpID0+IHtcbiAgLy8gVGhpcyB3YXMgYWZmZWN0aW5nIHRoZSBzZWxlY3Rpb24gb2YgbXVsdGlwbGUgYmxvY2tzIGFuZCBkcmFnZ2luZyBiZWhhdmlvcixcbiAgLy8gc28gZW5hYmxlZCBvbmx5IGlmIHRoZSBzZWxlY3Rpb24gaGFzIGJlZW4gY29sbGFwc2VkLlxuICBpZiAoZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSkge1xuICAgIHZhciBsZWFmRWwgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgIGxlYWZFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QuYmluZChkb21SYW5nZSk7XG4gICAgc2Nyb2xsSW50b1ZpZXcobGVhZkVsLCB7XG4gICAgICBzY3JvbGxNb2RlOiAnaWYtbmVlZGVkJ1xuICAgIH0pO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYW4gdW5vcnRob2RveCBkZWxldGUgRDpcbiAgICBkZWxldGUgbGVhZkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgfVxufTtcbi8qKlxuICogQ2hlY2sgaWYgYW4gZXZlbnQgaXMgb3ZlcnJpZGVkIGJ5IGEgaGFuZGxlci5cbiAqL1xudmFyIGlzRXZlbnRIYW5kbGVkID0gKGV2ZW50LCBoYW5kbGVyKSA9PiB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgY3VzdG9tIGV2ZW50IGhhbmRsZXIgbWF5IHJldHVybiBhIGJvb2xlYW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZSBldmVudFxuICAvLyBzaGFsbCBiZSB0cmVhdGVkIGFzIGJlaW5nIGhhbmRsZWQgb3Igbm90LlxuICB2YXIgc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCA9IGhhbmRsZXIoZXZlbnQpO1xuICBpZiAoc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQ7XG4gIH1cbiAgcmV0dXJuIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZXZlbnQncyB0YXJnZXQgaXMgYW4gaW5wdXQgZWxlbWVudFxuICovXG52YXIgaXNET01FdmVudFRhcmdldElucHV0ID0gZXZlbnQgPT4ge1xuICByZXR1cm4gaXNET01Ob2RlKGV2ZW50LnRhcmdldCkgJiYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHwgZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCk7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIERPTSBldmVudCBpcyBvdmVycmlkZWQgYnkgYSBoYW5kbGVyLlxuICovXG52YXIgaXNET01FdmVudEhhbmRsZWQgPSAoZXZlbnQsIGhhbmRsZXIpID0+IHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSBjdXN0b20gZXZlbnQgaGFuZGxlciBtYXkgcmV0dXJuIGEgYm9vbGVhbiB0byBzcGVjaWZ5IHdoZXRoZXIgdGhlIGV2ZW50XG4gIC8vIHNoYWxsIGJlIHRyZWF0ZWQgYXMgYmVpbmcgaGFuZGxlZCBvciBub3QuXG4gIHZhciBzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkID0gaGFuZGxlcihldmVudCk7XG4gIGlmIChzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkICE9IG51bGwpIHtcbiAgICByZXR1cm4gc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZDtcbiAgfVxuICByZXR1cm4gZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbn07XG5cbi8qKlxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgZm9jdXNlZGAgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAqL1xudmFyIEZvY3VzZWRDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgYGZvY3VzZWRgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gKi9cbnZhciB1c2VGb2N1c2VkID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChGb2N1c2VkQ29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBpc0Vycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yO1xufVxuLyoqXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGVkaXRvciBzZWxlY3RvciBjb250ZXh0IGluIGEgd2F5IHRvIGNvbnRyb2wgcmVyZW5kZXJzXG4gKi9cbnZhciBTbGF0ZVNlbGVjdG9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHt9KTtcbnZhciByZWZFcXVhbGl0eSA9IChhLCBiKSA9PiBhID09PSBiO1xuLyoqXG4gKiB1c2UgcmVkdXggc3R5bGUgc2VsZWN0b3JzIHRvIHByZXZlbnQgcmVyZW5kZXJpbmcgb24gZXZlcnkga2V5c3Ryb2tlLlxuICogQmVhciBpbiBtaW5kIHJlcmVuZGVyaW5nIGNhbiBvbmx5IHByZXZlbnRlZCBpZiB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgYSB2YWx1ZSB0eXBlIG9yIGZvciByZWZlcmVuY2UgdHlwZXMgKGUuZy4gb2JqZWN0cyBhbmQgYXJyYXlzKSBhZGQgYSBjdXN0b20gZXF1YWxpdHkgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYFxuICogIGNvbnN0IGlzU2VsZWN0aW9uQWN0aXZlID0gdXNlU2xhdGVTZWxlY3RvcihlZGl0b3IgPT4gQm9vbGVhbihlZGl0b3Iuc2VsZWN0aW9uKSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlU2xhdGVTZWxlY3RvcihzZWxlY3Rvcikge1xuICB2YXIgZXF1YWxpdHlGbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcmVmRXF1YWxpdHk7XG4gIHZhciBbLCBmb3JjZVJlbmRlcl0gPSB1c2VSZWR1Y2VyKHMgPT4gcyArIDEsIDApO1xuICB2YXIgY29udGV4dCA9IHVzZUNvbnRleHQoU2xhdGVTZWxlY3RvckNvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlU2VsZWN0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuICB2YXIge1xuICAgIGdldFNsYXRlLFxuICAgIGFkZEV2ZW50TGlzdGVuZXJcbiAgfSA9IGNvbnRleHQ7XG4gIHZhciBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yID0gdXNlUmVmKCk7XG4gIHZhciBsYXRlc3RTZWxlY3RvciA9IHVzZVJlZigoKSA9PiBudWxsKTtcbiAgdmFyIGxhdGVzdFNlbGVjdGVkU3RhdGUgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBzZWxlY3RlZFN0YXRlO1xuICB0cnkge1xuICAgIGlmIChzZWxlY3RvciAhPT0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudCB8fCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQpIHtcbiAgICAgIHNlbGVjdGVkU3RhdGUgPSBzZWxlY3RvcihnZXRTbGF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWRTdGF0ZSA9IGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgJiYgaXNFcnJvcihlcnIpKSB7XG4gICAgICBlcnIubWVzc2FnZSArPSBcIlxcblRoZSBlcnJvciBtYXkgYmUgY29ycmVsYXRlZCB3aXRoIHRoaXMgcHJldmlvdXMgZXJyb3I6XFxuXCIuY29uY2F0KGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudC5zdGFjaywgXCJcXG5cXG5cIik7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBsYXRlc3RTZWxlY3Rvci5jdXJyZW50ID0gc2VsZWN0b3I7XG4gICAgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50ID0gc2VsZWN0ZWRTdGF0ZTtcbiAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBmdW5jdGlvbiBjaGVja0ZvclVwZGF0ZXMoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbmV3U2VsZWN0ZWRTdGF0ZSA9IGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQoZ2V0U2xhdGUoKSk7XG4gICAgICAgIGlmIChlcXVhbGl0eUZuKG5ld1NlbGVjdGVkU3RhdGUsIGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50ID0gbmV3U2VsZWN0ZWRTdGF0ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyB3ZSBpZ25vcmUgYWxsIGVycm9ycyBoZXJlLCBzaW5jZSB3aGVuIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaXMgcmUtcmVuZGVyZWQsIHRoZSBzZWxlY3RvcnMgYXJlIGNhbGxlZCBhZ2FpbiwgYW5kXG4gICAgICAgIC8vIHdpbGwgdGhyb3cgYWdhaW4sIGlmIG5laXRoZXIgcHJvcHMgbm9yIHN0b3JlIHN0YXRlXG4gICAgICAgIC8vIGNoYW5nZWRcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gZXJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgfVxuICAgIHZhciB1bnN1YnNjcmliZSA9IGFkZEV2ZW50TGlzdGVuZXIoY2hlY2tGb3JVcGRhdGVzKTtcbiAgICBjaGVja0ZvclVwZGF0ZXMoKTtcbiAgICByZXR1cm4gKCkgPT4gdW5zdWJzY3JpYmUoKTtcbiAgfSxcbiAgLy8gZG9uJ3QgcmVyZW5kZXIgb24gZXF1YWxpdHlGbiBjaGFuZ2Ugc2luY2Ugd2Ugd2FudCB0byBiZSBhYmxlIHRvIGRlZmluZSBpdCBpbmxpbmVcbiAgW2FkZEV2ZW50TGlzdGVuZXIsIGdldFNsYXRlXSk7XG4gIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuLyoqXG4gKiBDcmVhdGUgc2VsZWN0b3IgY29udGV4dCB3aXRoIGVkaXRvciB1cGRhdGluZyBvbiBldmVyeSBlZGl0b3IgY2hhbmdlXG4gKi9cbmZ1bmN0aW9uIHVzZVNlbGVjdG9yQ29udGV4dChlZGl0b3IpIHtcbiAgdmFyIGV2ZW50TGlzdGVuZXJzID0gdXNlUmVmKFtdKS5jdXJyZW50O1xuICB2YXIgc2xhdGVSZWYgPSB1c2VSZWYoe1xuICAgIGVkaXRvclxuICB9KS5jdXJyZW50O1xuICB2YXIgb25DaGFuZ2UgPSB1c2VDYWxsYmFjayhlZGl0b3IgPT4ge1xuICAgIHNsYXRlUmVmLmVkaXRvciA9IGVkaXRvcjtcbiAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGVkaXRvcikpO1xuICB9LCBbZXZlbnRMaXN0ZW5lcnMsIHNsYXRlUmVmXSk7XG4gIHZhciBzZWxlY3RvckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U2xhdGU6ICgpID0+IHNsYXRlUmVmLmVkaXRvcixcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGNhbGxiYWNrID0+IHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGV2ZW50TGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZXZlbnRMaXN0ZW5lcnMsIHNsYXRlUmVmXSk7XG4gIHJldHVybiB7XG4gICAgc2VsZWN0b3JDb250ZXh0LFxuICAgIG9uQ2hhbmdlXG4gIH07XG59XG5cbnZhciBSRUFDVF9NQUpPUl9WRVJTSU9OID0gcGFyc2VJbnQoUmVhY3QudmVyc2lvbi5zcGxpdCgnLicpWzBdLCAxMCk7XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJlZGl0b3JcIiwgXCJjaGlsZHJlblwiLCBcIm9uQ2hhbmdlXCIsIFwib25TZWxlY3Rpb25DaGFuZ2VcIiwgXCJvblZhbHVlQ2hhbmdlXCIsIFwiaW5pdGlhbFZhbHVlXCJdO1xuLyoqXG4gKiBBIHdyYXBwZXIgYXJvdW5kIHRoZSBwcm92aWRlciB0byBoYW5kbGUgYG9uQ2hhbmdlYCBldmVudHMsIGJlY2F1c2UgdGhlIGVkaXRvclxuICogaXMgYSBtdXRhYmxlIHNpbmdsZXRvbiBzbyBpdCB3b24ndCBldmVyIHJlZ2lzdGVyIGFzIFwiY2hhbmdlZFwiIG90aGVyd2lzZS5cbiAqL1xudmFyIFNsYXRlID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgICAgZWRpdG9yLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlLFxuICAgICAgb25WYWx1ZUNoYW5nZSxcbiAgICAgIGluaXRpYWxWYWx1ZVxuICAgIH0gPSBwcm9wcyxcbiAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuICB2YXIgW2NvbnRleHQsIHNldENvbnRleHRdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIGlmICghTm9kZS5pc05vZGVMaXN0KGluaXRpYWxWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltTbGF0ZV0gaW5pdGlhbFZhbHVlIGlzIGludmFsaWQhIEV4cGVjdGVkIGEgbGlzdCBvZiBlbGVtZW50cyBidXQgZ290OiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KGluaXRpYWxWYWx1ZSkpKTtcbiAgICB9XG4gICAgaWYgKCFFZGl0b3IuaXNFZGl0b3IoZWRpdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW1NsYXRlXSBlZGl0b3IgaXMgaW52YWxpZCEgWW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShlZGl0b3IpKSk7XG4gICAgfVxuICAgIGVkaXRvci5jaGlsZHJlbiA9IGluaXRpYWxWYWx1ZTtcbiAgICBPYmplY3QuYXNzaWduKGVkaXRvciwgcmVzdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHY6IDAsXG4gICAgICBlZGl0b3JcbiAgICB9O1xuICB9KTtcbiAgdmFyIHtcbiAgICBzZWxlY3RvckNvbnRleHQsXG4gICAgb25DaGFuZ2U6IGhhbmRsZVNlbGVjdG9yQ2hhbmdlXG4gIH0gPSB1c2VTZWxlY3RvckNvbnRleHQoZWRpdG9yKTtcbiAgdmFyIG9uQ29udGV4dENoYW5nZSA9IHVzZUNhbGxiYWNrKG9wdGlvbnMgPT4ge1xuICAgIHZhciBfb3B0aW9ucyRvcGVyYXRpb247XG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICBvbkNoYW5nZShlZGl0b3IuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwIHx8IChfb3B0aW9ucyRvcGVyYXRpb24gPSBvcHRpb25zLm9wZXJhdGlvbikgPT09IG51bGwgfHwgX29wdGlvbnMkb3BlcmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlID09PSBudWxsIHx8IG9uU2VsZWN0aW9uQ2hhbmdlID09PSB2b2lkIDAgfHwgb25TZWxlY3Rpb25DaGFuZ2UoZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgb25WYWx1ZUNoYW5nZSA9PT0gbnVsbCB8fCBvblZhbHVlQ2hhbmdlID09PSB2b2lkIDAgfHwgb25WYWx1ZUNoYW5nZShlZGl0b3IuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBzZXRDb250ZXh0KHByZXZDb250ZXh0ID0+ICh7XG4gICAgICB2OiBwcmV2Q29udGV4dC52ICsgMSxcbiAgICAgIGVkaXRvclxuICAgIH0pKTtcbiAgICBoYW5kbGVTZWxlY3RvckNoYW5nZShlZGl0b3IpO1xuICB9LCBbZWRpdG9yLCBoYW5kbGVTZWxlY3RvckNoYW5nZSwgb25DaGFuZ2UsIG9uU2VsZWN0aW9uQ2hhbmdlLCBvblZhbHVlQ2hhbmdlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgRURJVE9SX1RPX09OX0NIQU5HRS5zZXQoZWRpdG9yLCBvbkNvbnRleHRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBFRElUT1JfVE9fT05fQ0hBTkdFLnNldChlZGl0b3IsICgpID0+IHt9KTtcbiAgICB9O1xuICB9LCBbZWRpdG9yLCBvbkNvbnRleHRDaGFuZ2VdKTtcbiAgdmFyIFtpc0ZvY3VzZWQsIHNldElzRm9jdXNlZF0gPSB1c2VTdGF0ZShSZWFjdEVkaXRvci5pc0ZvY3VzZWQoZWRpdG9yKSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SXNGb2N1c2VkKFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKTtcbiAgfSwgW2VkaXRvcl0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2YXIgZm4gPSAoKSA9PiBzZXRJc0ZvY3VzZWQoUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpO1xuICAgIGlmIChSRUFDVF9NQUpPUl9WRVJTSU9OID49IDE3KSB7XG4gICAgICAvLyBJbiBSZWFjdCA+PSAxNyBvbkZvY3VzIGFuZCBvbkJsdXIgbGlzdGVuIHRvIHRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgZHVyaW5nIHRoZSBidWJibGluZyBwaGFzZS5cbiAgICAgIC8vIFRoZXJlZm9yZSBpbiBvcmRlciBmb3IgPEVkaXRhYmxlIC8+J3MgaGFuZGxlcnMgdG8gcnVuIGZpcnN0LCB3aGljaCBpcyBuZWNlc3NhcnkgZm9yIFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpXG4gICAgICAvLyB0byByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWUsIHdlIGhhdmUgdG8gbGlzdGVuIHRvIHRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgd2l0aG91dCB1c2VDYXB0dXJlIGhlcmUuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgZm4pO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBmbik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgZm4pO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZm4sIHRydWUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZuLCB0cnVlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZm4sIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgZm4sIHRydWUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNsYXRlU2VsZWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHNlbGVjdG9yQ29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTbGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHQuZWRpdG9yXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzZWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGlzRm9jdXNlZFxuICB9LCBjaGlsZHJlbikpKSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBlZGl0b3Igb2JqZWN0IGZyb20gdGhlIFJlYWN0IGNvbnRleHQuXG4gKiBAZGVwcmVjYXRlZCBVc2UgdXNlU2xhdGVTdGF0aWMgaW5zdGVhZC5cbiAqL1xudmFyIHVzZUVkaXRvciA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHVzZUNvbnRleHQoRWRpdG9yQ29udGV4dCk7XG4gIGlmICghZWRpdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VFZGl0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuICByZXR1cm4gZWRpdG9yO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgc2xhdGUgc2VsZWN0aW9uLlxuICogT25seSB0cmlnZ2VycyBhIHJlcmVuZGVyIHdoZW4gdGhlIHNlbGVjdGlvbiBhY3R1YWxseSBjaGFuZ2VzXG4gKi9cbnZhciB1c2VTbGF0ZVNlbGVjdGlvbiA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZVNsYXRlU2VsZWN0b3IoZWRpdG9yID0+IGVkaXRvci5zZWxlY3Rpb24sIGlzU2VsZWN0aW9uRXF1YWwpO1xufTtcbnZhciBpc1NlbGVjdGlvbkVxdWFsID0gKGEsIGIpID0+IHtcbiAgaWYgKCFhICYmICFiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCFhIHx8ICFiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBSYW5nZS5lcXVhbHMoYSwgYik7XG59O1xuXG4vKipcbiAqIGB3aXRoUmVhY3RgIGFkZHMgUmVhY3QgYW5kIERPTSBzcGVjaWZpYyBiZWhhdmlvcnMgdG8gdGhlIGVkaXRvci5cbiAqXG4gKiBJZiB5b3UgYXJlIHVzaW5nIFR5cGVTY3JpcHQsIHlvdSBtdXN0IGV4dGVuZCBTbGF0ZSdzIEN1c3RvbVR5cGVzIHRvIHVzZVxuICogdGhpcyBwbHVnaW4uXG4gKlxuICogU2VlIGh0dHBzOi8vZG9jcy5zbGF0ZWpzLm9yZy9jb25jZXB0cy8xMS10eXBlc2NyaXB0IHRvIGxlYXJuIGhvdy5cbiAqL1xudmFyIHdpdGhSZWFjdCA9IGZ1bmN0aW9uIHdpdGhSZWFjdChlZGl0b3IpIHtcbiAgdmFyIGNsaXBib2FyZEZvcm1hdEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3gtc2xhdGUtZnJhZ21lbnQnO1xuICB2YXIgZSA9IGVkaXRvcjtcbiAgZSA9IHdpdGhET00oZSwgY2xpcGJvYXJkRm9ybWF0S2V5KTtcbiAgdmFyIHtcbiAgICBvbkNoYW5nZVxuICB9ID0gZTtcbiAgZS5vbkNoYW5nZSA9IG9wdGlvbnMgPT4ge1xuICAgIC8vIENPTVBBVDogUmVhY3QgPCAxOCBkb2Vzbid0IGJhdGNoIGBzZXRTdGF0ZWAgaG9vayBjYWxscywgd2hpY2ggbWVhbnNcbiAgICAvLyB0aGF0IHRoZSBjaGlsZHJlbiBhbmQgc2VsZWN0aW9uIGNhbiBnZXQgb3V0IG9mIHN5bmMgZm9yIG9uZSByZW5kZXJcbiAgICAvLyBwYXNzLiBTbyB3ZSBoYXZlIHRvIHVzZSB0aGlzIHVuc3RhYmxlIEFQSSB0byBlbnN1cmUgaXQgYmF0Y2hlcyB0aGVtLlxuICAgIC8vICgyMDE5LzEyLzAzKVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQyNTkjaXNzdWVjb21tZW50LTQzOTcwMjM2N1xuICAgIHZhciBtYXliZUJhdGNoVXBkYXRlcyA9IFJFQUNUX01BSk9SX1ZFUlNJT04gPCAxOCA/IFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIDogY2FsbGJhY2sgPT4gY2FsbGJhY2soKTtcbiAgICBtYXliZUJhdGNoVXBkYXRlcygoKSA9PiB7XG4gICAgICBvbkNoYW5nZShvcHRpb25zKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIGU7XG59O1xuXG5leHBvcnQgeyBEZWZhdWx0RWxlbWVudCwgRGVmYXVsdExlYWYsIERlZmF1bHRQbGFjZWhvbGRlciwgRWRpdGFibGUsIFJlYWN0RWRpdG9yLCBTbGF0ZSwgdXNlQ29tcG9zaW5nLCB1c2VFZGl0b3IsIHVzZUZvY3VzZWQsIHVzZVJlYWRPbmx5LCB1c2VTZWxlY3RlZCwgdXNlU2xhdGUsIHVzZVNsYXRlU2VsZWN0aW9uLCB1c2VTbGF0ZVNlbGVjdG9yLCB1c2VTbGF0ZVN0YXRpYywgdXNlU2xhdGVXaXRoViwgd2l0aFJlYWN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZXREaXJlY3Rpb24iLCJkZWJvdW5jZSIsInRocm90dGxlIiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZVN0YXRlIiwibWVtbyIsImZvcndhcmRSZWYiLCJ1c2VDYWxsYmFjayIsIkNvbXBvbmVudCIsInVzZVJlZHVjZXIiLCJ1c2VNZW1vIiwic2Nyb2xsSW50b1ZpZXciLCJFZGl0b3IiLCJSYW5nZSIsIlRyYW5zZm9ybXMiLCJOb2RlIiwiVGV4dCIsIlRleHQkMSIsIlBhdGgiLCJQb2ludCIsIkVsZW1lbnQiLCJFbGVtZW50JDEiLCJTY3J1YmJlciIsIkRPTUVkaXRvciIsIkVESVRPUl9UT19VU0VSX01BUktTIiwiRURJVE9SX1RPX1BFTkRJTkdfRElGRlMiLCJFRElUT1JfVE9fUEVORElOR19BQ1RJT04iLCJFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MiLCJ0YXJnZXRSYW5nZSIsInZlcmlmeURpZmZTdGF0ZSIsIkVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiIsIklTX0NPTVBPU0lORyIsIklTX05PREVfTUFQX0RJUlRZIiwiYXBwbHlTdHJpbmdEaWZmIiwiaXNET01TZWxlY3Rpb24iLCJpc1RyYWNrZWRNdXRhdGlvbiIsIkVESVRPUl9UT19GT1JDRV9SRU5ERVIiLCJub3JtYWxpemVSYW5nZSIsIm5vcm1hbGl6ZVBvaW50IiwiRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQiLCJub3JtYWxpemVTdHJpbmdEaWZmIiwibWVyZ2VTdHJpbmdEaWZmcyIsIkNBTl9VU0VfRE9NIiwiSVNfQU5EUk9JRCIsIkVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSCIsIk1BUktfUExBQ0VIT0xERVJfU1lNQk9MIiwiSVNfSU9TIiwiUExBQ0VIT0xERVJfU1lNQk9MIiwiSVNfV0VCS0lUIiwiaXNUZXh0RGVjb3JhdGlvbnNFcXVhbCIsIkVESVRPUl9UT19LRVlfVE9fRUxFTUVOVCIsIk5PREVfVE9fRUxFTUVOVCIsIkVMRU1FTlRfVE9fTk9ERSIsImlzRWxlbWVudERlY29yYXRpb25zRXF1YWwiLCJOT0RFX1RPX0lOREVYIiwiTk9ERV9UT19QQVJFTlQiLCJJU19SRUFEX09OTFkiLCJnZXRBY3RpdmVFbGVtZW50IiwiZ2V0U2VsZWN0aW9uIiwiSVNfRk9DVVNFRCIsImdldERlZmF1bHRWaWV3IiwiRURJVE9SX1RPX1dJTkRPVyIsIkVESVRPUl9UT19FTEVNRU5UIiwiSVNfRklSRUZPWCIsIkVESVRPUl9UT19VU0VSX1NFTEVDVElPTiIsIkhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCIsImlzRE9NRWxlbWVudCIsImlzRE9NTm9kZSIsIlRSSVBMRV9DTElDSyIsIklTX0ZJUkVGT1hfTEVHQUNZIiwiSVNfV0VDSEFUQlJPV1NFUiIsIklTX1VDX01PQklMRSIsIkhvdGtleXMiLCJJU19DSFJPTUUiLCJpc1BsYWluVGV4dE9ubHlQYXN0ZSIsIkVESVRPUl9UT19PTl9DSEFOR0UiLCJ3aXRoRE9NIiwiUmVzaXplT2JzZXJ2ZXIiLCJSZWFjdERPTSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJ0YXJnZXQiLCJzb3VyY2VLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsImkiLCJsZW5ndGgiLCJpbmRleE9mIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3RvdHlwZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY2FsbCIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsIl90b1ByaW1pdGl2ZSIsImlucHV0IiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl90b1Byb3BlcnR5S2V5IiwiYXJnIiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwidmFsdWUiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkVkaXRvckNvbnRleHQiLCJ1c2VTbGF0ZVN0YXRpYyIsImVkaXRvciIsIkVycm9yIiwiUmVhY3RFZGl0b3IiLCJvd25LZXlzJDUiLCJlIiwiciIsInQiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkJDUiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJSRVNPTFZFX0RFTEFZIiwiRkxVU0hfREVMQVkiLCJkZWJ1ZyIsImlzRGF0YVRyYW5zZmVyIiwibmFtZSIsImNyZWF0ZUFuZHJvaWRJbnB1dE1hbmFnZXIiLCJfcmVmIiwic2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZSIsIm9uRE9NU2VsZWN0aW9uQ2hhbmdlIiwiZmx1c2hpbmciLCJjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCIsImZsdXNoVGltZW91dElkIiwiYWN0aW9uVGltZW91dElkIiwiaWRDb3VudGVyIiwiaW5zZXJ0UG9zaXRpb25IaW50IiwiYXBwbHlQZW5kaW5nU2VsZWN0aW9uIiwicGVuZGluZ1NlbGVjdGlvbiIsImdldCIsImRlbGV0ZSIsInNlbGVjdGlvbiIsIm5vcm1hbGl6ZWQiLCJlcXVhbHMiLCJzZWxlY3QiLCJwZXJmb3JtQWN0aW9uIiwiYWN0aW9uIiwiYXQiLCJpc1BvaW50IiwiX3RhcmdldFJhbmdlIiwicmFuZ2UiLCJydW4iLCJmbHVzaCIsImNsZWFyVGltZW91dCIsImhhc1BlbmRpbmdEaWZmcyIsImhhc1BlbmRpbmdBY3Rpb24iLCJzZXRUaW1lb3V0Iiwic2VsZWN0aW9uUmVmIiwicmFuZ2VSZWYiLCJhZmZpbml0eSIsInNldCIsIm1hcmtzIiwic2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UiLCJkaWZmIiwiX0VESVRPUl9UT19QRU5ESU5HX0RJIiwiX0VESVRPUl9UT19QRU5ESU5HX0RJMiIsInBlbmRpbmdNYXJrcyIsInRleHQiLCJpbnNlcnRUZXh0IiwiZGVsZXRlRnJhZ21lbnQiLCJfcmVmMiIsImlkIiwiY2FuY2VsIiwidW5yZWYiLCJ1c2VyTWFya3MiLCJvbkNoYW5nZSIsImhhbmRsZUNvbXBvc2l0aW9uRW5kIiwiX2V2ZW50IiwiaGFuZGxlQ29tcG9zaXRpb25TdGFydCIsInVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSIsImZvcmNlSGlkZSIsInBsYWNlaG9sZGVyRWxlbWVudCIsInN0eWxlIiwiZGlzcGxheSIsInJlbW92ZVByb3BlcnR5Iiwic3RvcmVEaWZmIiwicGF0aCIsIl9FRElUT1JfVE9fUEVORElOR19ESTMiLCJwZW5kaW5nRGlmZnMiLCJsZWFmIiwiaWR4IiwiZmluZEluZGV4IiwiY2hhbmdlIiwibWVyZ2VkIiwic3BsaWNlIiwic2NoZWR1bGVBY3Rpb24iLCJoYW5kbGVET01CZWZvcmVJbnB1dCIsImV2ZW50IiwiX3RhcmdldFJhbmdlMiIsImlucHV0VHlwZSIsInR5cGUiLCJkYXRhIiwiZGF0YVRyYW5zZmVyIiwibmF0aXZlVGFyZ2V0UmFuZ2UiLCJnZXRUYXJnZXRSYW5nZXMiLCJ0b1NsYXRlUmFuZ2UiLCJleGFjdE1hdGNoIiwic3VwcHJlc3NUaHJvdyIsIndpbmRvdyIsImdldFdpbmRvdyIsImRvbVNlbGVjdGlvbiIsImNhblN0b3JlRGlmZiIsInN0YXJ0c1dpdGgiLCJpc0V4cGFuZGVkIiwiX3N0YXJ0IiwiX2VuZCIsImVkZ2VzIiwiX2xlYWYiLCJvZmZzZXQiLCJuZXh0IiwibWF0Y2giLCJpc1RleHQiLCJhbmNob3IiLCJmb2N1cyIsImRpcmVjdGlvbiIsImVuZHNXaXRoIiwic3RhcnQiLCJlbmQiLCJyZWxldmFudFBlbmRpbmdEaWZmcyIsImZpbmQiLCJkaWZmcyIsInBvaW50IiwiaGFuZGxlVXNlclNlbGVjdCIsImlzQ29sbGFwc2VkIiwidGFyZ2V0Tm9kZSIsImRlbGV0ZUZvcndhcmQiLCJfbmF0aXZlVGFyZ2V0UmFuZ2UiLCJfYW5jaG9yIiwibmF0aXZlQ29sbGFwc2VkIiwiY29sbGFwc2VkIiwiZGVsZXRlQmFja3dhcmQiLCJ1bml0IiwiaW5zZXJ0U29mdEJyZWFrIiwiaW5zZXJ0QnJlYWsiLCJpbnNlcnREYXRhIiwiX3RleHQiLCJyZXBsYWNlIiwidGVzdCIsInNsaWNlIiwiaW5jbHVkZXMiLCJwYXJ0cyIsInNwbGl0IiwibGluZSIsIl9zdGFydDIiLCJfZW5kMiIsIl9kaWZmIiwiaGludFBvc2l0aW9uIiwic2VhcmNoIiwiZGlmZlBvc2l0aW9uIiwic2NoZWR1bGVGbHVzaCIsIl9FRElUT1JfVE9fUEVORElOR19ESTQiLCJoYXNQZW5kaW5nQ2hhbmdlcyIsImlzRmx1c2hpbmciLCJwYXRoQ2hhbmdlZCIsInBhcmVudFBhdGhDaGFuZ2VkIiwiaGFuZGxlSW5wdXQiLCJoYW5kbGVLZXlEb3duIiwiXyIsImhhbmRsZURvbU11dGF0aW9ucyIsIm11dGF0aW9ucyIsInNvbWUiLCJtdXRhdGlvbiIsIl9FRElUT1JfVE9fRk9SQ0VfUkVORCIsInVzZUlzTW91bnRlZCIsImlzTW91bnRlZFJlZiIsImN1cnJlbnQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTXV0YXRpb25PYnNlcnZlciIsIm5vZGUiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJtdXRhdGlvbk9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsInRha2VSZWNvcmRzIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJfZXhjbHVkZWQkMiIsIm93bktleXMkNCIsIl9vYmplY3RTcHJlYWQkNCIsIk1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyQxIiwic3VidHJlZSIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJ1c2VBbmRyb2lkSW5wdXRNYW5hZ2VyIiwiaXNNb3VudGVkIiwiaW5wdXRNYW5hZ2VyIiwib3duS2V5cyQzIiwiX29iamVjdFNwcmVhZCQzIiwiU3RyaW5nJDEiLCJwcm9wcyIsImlzTGFzdCIsInBhcmVudCIsImZpbmRQYXRoIiwicGFyZW50UGF0aCIsImlzTWFya1BsYWNlaG9sZGVyIiwiQm9vbGVhbiIsImlzVm9pZCIsImNyZWF0ZUVsZW1lbnQiLCJaZXJvV2lkdGhTdHJpbmciLCJzdHJpbmciLCJjaGlsZHJlbiIsImlzSW5saW5lIiwiaXNMaW5lQnJlYWsiLCJUZXh0U3RyaW5nIiwiaXNUcmFpbGluZyIsInJlZiIsImdldFRleHRDb250ZW50IiwiY29uY2F0IiwiaW5pdGlhbFRleHQiLCJ0ZXh0V2l0aFRyYWlsaW5nIiwidGV4dENvbnRlbnQiLCJNZW1vaXplZFRleHQkMSIsImF0dHJpYnV0ZXMiLCJvd25LZXlzJDIiLCJfb2JqZWN0U3ByZWFkJDIiLCJQTEFDRUhPTERFUl9ERUxBWSIsImRpc2Nvbm5lY3RQbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyIiwicGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlciIsInJlbGVhc2VPYnNlcnZlciIsImNsZWFyVGltZW91dFJlZiIsInRpbWVvdXRSZWYiLCJMZWFmIiwicmVuZGVyUGxhY2Vob2xkZXIiLCJyZW5kZXJMZWFmIiwiRGVmYXVsdExlYWYiLCJwbGFjZWhvbGRlclJlZiIsInNob3dQbGFjZWhvbGRlciIsInNldFNob3dQbGFjZWhvbGRlciIsInNob3dQbGFjZWhvbGRlclRpbWVvdXRSZWYiLCJjYWxsYmFja1BsYWNlaG9sZGVyUmVmIiwicGxhY2Vob2xkZXJFbCIsIl9sZWFmJG9uUGxhY2Vob2xkZXJSZSIsIm9uUGxhY2Vob2xkZXJSZXNpemUiLCJSZXNpemVPYnNlcnZlciQxIiwiX2xlYWYkb25QbGFjZWhvbGRlclJlMiIsImxlYWZJc1BsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJQcm9wcyIsInBsYWNlaG9sZGVyIiwicG9zaXRpb24iLCJ0b3AiLCJwb2ludGVyRXZlbnRzIiwid2lkdGgiLCJtYXhXaWR0aCIsIm9wYWNpdHkiLCJ1c2VyU2VsZWN0IiwidGV4dERlY29yYXRpb24iLCJXZWJraXRVc2VyTW9kaWZ5IiwiY29udGVudEVkaXRhYmxlIiwiRnJhZ21lbnQiLCJNZW1vaXplZExlYWYiLCJwcmV2IiwiZGVjb3JhdGlvbnMiLCJsZWF2ZXMiLCJmaW5kS2V5IiwiY2FsbGJhY2tSZWYiLCJzcGFuIiwiS0VZX1RPX0VMRU1FTlQiLCJNZW1vaXplZFRleHQiLCJvd25LZXlzJDEiLCJfb2JqZWN0U3ByZWFkJDEiLCJlbGVtZW50IiwicmVuZGVyRWxlbWVudCIsInAiLCJEZWZhdWx0RWxlbWVudCIsInJlYWRPbmx5IiwidXNlUmVhZE9ubHkiLCJ1c2VDaGlsZHJlbiIsImhhc0lubGluZXMiLCJkaXIiLCJUYWciLCJ0ZXh0cyIsImhlaWdodCIsImNvbG9yIiwib3V0bGluZSIsIk1lbW9pemVkRWxlbWVudCIsIkRlY29yYXRlQ29udGV4dCIsInVzZURlY29yYXRlIiwiU2VsZWN0ZWRDb250ZXh0IiwidXNlU2VsZWN0ZWQiLCJkZWNvcmF0ZSIsImlzTGVhZkJsb2NrIiwiaXNFbGVtZW50IiwibiIsInNlbCIsImludGVyc2VjdGlvbiIsImRzIiwiZGVjIiwiZCIsIlByb3ZpZGVyIiwiUmVhZE9ubHlDb250ZXh0IiwiU2xhdGVDb250ZXh0IiwidXNlU2xhdGUiLCJjb250ZXh0IiwidXNlU2xhdGVXaXRoViIsInVzZVRyYWNrVXNlcklucHV0IiwicmVjZWl2ZWRVc2VySW5wdXQiLCJhbmltYXRpb25GcmFtZUlkUmVmIiwib25Vc2VySW5wdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNyZWF0ZVJlc3RvcmVEb21NYW5hZ2VyIiwiYnVmZmVyZWRNdXRhdGlvbnMiLCJjbGVhciIsInJlZ2lzdGVyTXV0YXRpb25zIiwidHJhY2tlZE11dGF0aW9ucyIsInJlc3RvcmVET00iLCJyZXZlcnNlIiwicmVtb3ZlZE5vZGVzIiwiaW5zZXJ0QmVmb3JlIiwibmV4dFNpYmxpbmciLCJhZGRlZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJNVVRBVElPTl9PQlNFUlZFUl9DT05GSUciLCJjaGFyYWN0ZXJEYXRhT2xkVmFsdWUiLCJSZXN0b3JlRE9NQ29tcG9uZW50IiwiX3RoaXMkbXV0YXRpb25PYnNlcnZlIiwiY29tcG9uZW50RGlkTW91bnQiLCJtYW5hZ2VyIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJfdGhpcyRtdXRhdGlvbk9ic2VydmUyIiwiX3RoaXMkbXV0YXRpb25PYnNlcnZlMyIsIl90aGlzJG1hbmFnZXIyIiwicGVuZGluZ011dGF0aW9ucyIsIl90aGlzJG1hbmFnZXIiLCJjb21wb25lbnREaWRVcGRhdGUiLCJfdGhpcyRtYW5hZ2VyMyIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiX3RoaXMkbXV0YXRpb25PYnNlcnZlNCIsInJlbmRlciIsIlJlc3RvcmVET00iLCJDb21wb3NpbmdDb250ZXh0IiwidXNlQ29tcG9zaW5nIiwiX2V4Y2x1ZGVkJDEiLCJfZXhjbHVkZWQyIiwib3duS2V5cyIsIl9vYmplY3RTcHJlYWQiLCJDaGlsZHJlbiIsIkVkaXRhYmxlIiwiZm9yd2FyZGVkUmVmIiwiZGVmYXVsdFJlbmRlclBsYWNlaG9sZGVyIiwiRGVmYXVsdFBsYWNlaG9sZGVyIiwiYXV0b0ZvY3VzIiwiZGVmYXVsdERlY29yYXRlIiwib25ET01CZWZvcmVJbnB1dCIsInByb3BzT25ET01CZWZvcmVJbnB1dCIsInNjcm9sbFNlbGVjdGlvbkludG9WaWV3IiwiZGVmYXVsdFNjcm9sbFNlbGVjdGlvbkludG9WaWV3IiwidXNlclN0eWxlIiwiYXMiLCJkaXNhYmxlRGVmYXVsdFN0eWxlcyIsImlzQ29tcG9zaW5nIiwic2V0SXNDb21wb3NpbmciLCJkZWZlcnJlZE9wZXJhdGlvbnMiLCJwbGFjZWhvbGRlckhlaWdodCIsInNldFBsYWNlaG9sZGVySGVpZ2h0IiwicHJvY2Vzc2luZyIsImZvcmNlUmVuZGVyIiwicyIsInN0YXRlIiwiaXNEcmFnZ2luZ0ludGVybmFsbHkiLCJpc1VwZGF0aW5nU2VsZWN0aW9uIiwibGF0ZXN0RWxlbWVudCIsImhhc01hcmtQbGFjZWhvbGRlciIsImFuZHJvaWRJbnB1dE1hbmFnZXJSZWYiLCJlbCIsInRvRE9NTm9kZSIsInJvb3QiLCJnZXRSb290Tm9kZSIsIlNoYWRvd1Jvb3QiLCJhY3RpdmUiLCJkb2N1bWVudCIsImV4ZWNDb21tYW5kIiwiZGVzZWxlY3QiLCJhbmRyb2lkSW5wdXRNYW5hZ2VyIiwiX3Jvb3QiLCJmaW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QiLCJhY3RpdmVFbGVtZW50IiwiX2VsIiwiYW5jaG9yTm9kZSIsImZvY3VzTm9kZSIsImFuY2hvck5vZGVTZWxlY3RhYmxlIiwiaGFzRWRpdGFibGVUYXJnZXQiLCJpc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZCIsImZvY3VzTm9kZUluRWRpdG9yIiwiaGFzVGFyZ2V0IiwiX2FuZHJvaWRJbnB1dE1hbmFnZXJSIiwiX2FuZHJvaWRJbnB1dE1hbmFnZXJSMiIsImlzRm9jdXNlZCIsInNldERvbVNlbGVjdGlvbiIsImZvcmNlQ2hhbmdlIiwiaGFzRG9tU2VsZWN0aW9uIiwicmFuZ2VDb3VudCIsImZpcnN0UmFuZ2UiLCJnZXRSYW5nZUF0IiwibGFzdFJhbmdlIiwic3RhcnRDb250YWluZXIiLCJlbmRDb250YWluZXIiLCJlZGl0b3JFbGVtZW50IiwiaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IiLCJjb250YWlucyIsInNsYXRlUmFuZ2UiLCJfYW5jaG9yTm9kZSIsInBhcmVudEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJoYXNSYW5nZSIsIm5ld0RvbVJhbmdlIiwidG9ET01SYW5nZSIsImNvbGxhcHNlVG9FbmQiLCJpc0JhY2t3YXJkIiwic2V0QmFzZUFuZEV4dGVudCIsImVuZE9mZnNldCIsInN0YXJ0T2Zmc2V0IiwicmVtb3ZlQWxsUmFuZ2VzIiwiZW5zdXJlU2VsZWN0aW9uIiwidGltZW91dElkIiwiYW5pbWF0aW9uRnJhbWVJZCIsImVuc3VyZURvbVNlbGVjdGlvbiIsInJhbmdlcyIsIm5ld1JhbmdlIiwic2V0U3RhcnQiLCJzZXRFbmQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImlzRE9NRXZlbnRIYW5kbGVkIiwiX0VESVRPUl9UT19VU0VSX1NFTEVDIiwiaXNDb21wb3NpdGlvbkNoYW5nZSIsIm5hdGl2ZSIsIl9ub2RlJHBhcmVudEVsZW1lbnQiLCJfd2luZG93JGdldENvbXB1dGVkU3QiLCJ0b0RPTVBvaW50IiwiY2xvc2VzdCIsIl93aW5kb3ciLCJoYXNET01Ob2RlIiwiX2xhc3RUZXh0JHRleHRDb250ZW50IiwibGFzdFRleHQiLCJjcmVhdGVUcmVlV2Fsa2VyIiwiTm9kZUZpbHRlciIsIlNIT1dfVEVYVCIsImxhc3RDaGlsZCIsImdldENvbXB1dGVkU3R5bGUiLCJ3aGl0ZVNwYWNlIiwiYmxvY2siLCJhYm92ZSIsImlzQmxvY2siLCJfcmFuZ2UiLCJ0b1Jlc3RvcmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInN0b3BwZWREcmFnZ2luZyIsIkFycmF5IiwiZnJvbSIsInBsYWNlSG9sZGVyUmVzaXplSGFuZGxlciIsIl9wbGFjZWhvbGRlckVsJGdldEJvdSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInJlc3QiLCJsb29zZSIsInVuc2V0IiwiZnJvbUVudHJpZXMiLCJtYXAiLCJtYXJrIiwicm9sZSIsInNwZWxsQ2hlY2siLCJhdXRvQ29ycmVjdCIsImF1dG9DYXBpdGFsaXplIiwiemluZGV4Iiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwid29yZFdyYXAiLCJtaW5IZWlnaHQiLCJvbkJlZm9yZUlucHV0IiwiaXNFdmVudEhhbmRsZWQiLCJoYXNTZWxlY3RhYmxlVGFyZ2V0IiwiX3RleHQyIiwib25JbnB1dCIsIm9wIiwibmF0aXZlRXZlbnQiLCJtYXliZUhpc3RvcnlFZGl0b3IiLCJ1bmRvIiwicmVkbyIsIm9uQmx1ciIsInJlbGF0ZWRUYXJnZXQiLCJ0b1NsYXRlTm9kZSIsIm9uQ2xpY2siLCJoYXNQYXRoIiwiZGV0YWlsIiwiYmxvY2tQYXRoIiwiX2Jsb2NrJCIsInN0YXJ0Vm9pZCIsInZvaWQiLCJlbmRWb2lkIiwiX3JhbmdlMiIsIm9uQ29tcG9zaXRpb25FbmQiLCJfYW5kcm9pZElucHV0TWFuYWdlclIzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicGxhY2Vob2xkZXJNYXJrcyIsIm9uQ29tcG9zaXRpb25VcGRhdGUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJfYW5kcm9pZElucHV0TWFuYWdlclI0Iiwib25Db3B5IiwiaXNET01FdmVudFRhcmdldElucHV0Iiwic2V0RnJhZ21lbnREYXRhIiwiY2xpcGJvYXJkRGF0YSIsIm9uQ3V0Iiwib25EcmFnT3ZlciIsIm9uRHJhZ1N0YXJ0Iiwidm9pZE1hdGNoIiwidm9pZHMiLCJvbkRyb3AiLCJkcmFnZ2VkUmFuZ2UiLCJmaW5kRXZlbnRSYW5nZSIsIm9uRHJhZ0VuZCIsIm9uRm9jdXMiLCJvbktleURvd24iLCJfYW5kcm9pZElucHV0TWFuYWdlclI1IiwiaXNSVEwiLCJpc1JlZG8iLCJpc1VuZG8iLCJfbWF5YmVIaXN0b3J5RWRpdG9yIiwiaXNNb3ZlTGluZUJhY2t3YXJkIiwibW92ZSIsImlzTW92ZUxpbmVGb3J3YXJkIiwiaXNFeHRlbmRMaW5lQmFja3dhcmQiLCJlZGdlIiwiaXNFeHRlbmRMaW5lRm9yd2FyZCIsImlzTW92ZUJhY2t3YXJkIiwiY29sbGFwc2UiLCJpc01vdmVGb3J3YXJkIiwiaXNNb3ZlV29yZEJhY2t3YXJkIiwiaXNNb3ZlV29yZEZvcndhcmQiLCJpc0JvbGQiLCJpc0l0YWxpYyIsImlzVHJhbnNwb3NlQ2hhcmFjdGVyIiwiaXNTb2Z0QnJlYWsiLCJpc1NwbGl0QmxvY2siLCJpc0RlbGV0ZUJhY2t3YXJkIiwiaXNEZWxldGVGb3J3YXJkIiwiaXNEZWxldGVMaW5lQmFja3dhcmQiLCJpc0RlbGV0ZUxpbmVGb3J3YXJkIiwiaXNEZWxldGVXb3JkQmFja3dhcmQiLCJpc0RlbGV0ZVdvcmRGb3J3YXJkIiwiY3VycmVudE5vZGUiLCJvblBhc3RlIiwiZG9tUmFuZ2UiLCJsZWFmRWwiLCJiaW5kIiwic2Nyb2xsTW9kZSIsImhhbmRsZXIiLCJzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJIVE1MSW5wdXRFbGVtZW50IiwiSFRNTFRleHRBcmVhRWxlbWVudCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJGb2N1c2VkQ29udGV4dCIsInVzZUZvY3VzZWQiLCJpc0Vycm9yIiwiZXJyb3IiLCJTbGF0ZVNlbGVjdG9yQ29udGV4dCIsInJlZkVxdWFsaXR5IiwiYSIsImIiLCJ1c2VTbGF0ZVNlbGVjdG9yIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwiZ2V0U2xhdGUiLCJsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yIiwibGF0ZXN0U2VsZWN0b3IiLCJsYXRlc3RTZWxlY3RlZFN0YXRlIiwic2VsZWN0ZWRTdGF0ZSIsImVyciIsIm1lc3NhZ2UiLCJzdGFjayIsImNoZWNrRm9yVXBkYXRlcyIsIm5ld1NlbGVjdGVkU3RhdGUiLCJ1bnN1YnNjcmliZSIsInVzZVNlbGVjdG9yQ29udGV4dCIsImV2ZW50TGlzdGVuZXJzIiwic2xhdGVSZWYiLCJsaXN0ZW5lciIsInNlbGVjdG9yQ29udGV4dCIsIlJFQUNUX01BSk9SX1ZFUlNJT04iLCJwYXJzZUludCIsInZlcnNpb24iLCJfZXhjbHVkZWQiLCJTbGF0ZSIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwib25WYWx1ZUNoYW5nZSIsImluaXRpYWxWYWx1ZSIsInNldENvbnRleHQiLCJpc05vZGVMaXN0Iiwic3RyaW5naWZ5IiwiaXNFZGl0b3IiLCJhc3NpZ24iLCJ2IiwiaGFuZGxlU2VsZWN0b3JDaGFuZ2UiLCJvbkNvbnRleHRDaGFuZ2UiLCJfb3B0aW9ucyRvcGVyYXRpb24iLCJvcGVyYXRpb24iLCJwcmV2Q29udGV4dCIsInNldElzRm9jdXNlZCIsImZuIiwidXNlRWRpdG9yIiwidXNlU2xhdGVTZWxlY3Rpb24iLCJpc1NlbGVjdGlvbkVxdWFsIiwid2l0aFJlYWN0IiwiY2xpcGJvYXJkRm9ybWF0S2V5IiwibWF5YmVCYXRjaFVwZGF0ZXMiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/node_modules/slate-react/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockOffsetToSpanSelectionPoint: () => (/* binding */ blockOffsetToSpanSelectionPoint),\n/* harmony export */   coreBehavior: () => (/* binding */ coreBehavior),\n/* harmony export */   coreBehaviors: () => (/* binding */ coreBehaviors),\n/* harmony export */   defineBehavior: () => (/* binding */ defineBehavior),\n/* harmony export */   getTextBlockText: () => (/* binding */ getTextBlockText),\n/* harmony export */   isHotkey: () => (/* binding */ isHotkey),\n/* harmony export */   spanSelectionPointToBlockOffset: () => (/* binding */ spanSelectionPointToBlockOffset)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var _selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selector.is-selection-collapsed.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js\");\n\n\nfunction blockOffsetToSpanSelectionPoint({ value, blockOffset }) {\n    let offsetLeft = blockOffset.offset, selectionPoint;\n    for (const block of value)if (block._key === blockOffset.path[0]._key && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block)) {\n        for (const child of block.children)if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n            if (offsetLeft === 0) {\n                selectionPoint = {\n                    path: [\n                        ...blockOffset.path,\n                        \"children\",\n                        {\n                            _key: child._key\n                        }\n                    ],\n                    offset: 0\n                };\n                break;\n            }\n            if (offsetLeft <= child.text.length) {\n                selectionPoint = {\n                    path: [\n                        ...blockOffset.path,\n                        \"children\",\n                        {\n                            _key: child._key\n                        }\n                    ],\n                    offset: offsetLeft\n                };\n                break;\n            }\n            offsetLeft -= child.text.length;\n        }\n    }\n    return selectionPoint;\n}\nfunction spanSelectionPointToBlockOffset({ value, selectionPoint }) {\n    let offset = 0;\n    for (const block of value)if (block._key === selectionPoint.path[0]._key && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block)) {\n        for (const child of block.children)if ((0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(child)) {\n            if (child._key === selectionPoint.path[2]._key) return {\n                path: [\n                    {\n                        _key: block._key\n                    }\n                ],\n                offset: offset + selectionPoint.offset\n            };\n            offset += child.text.length;\n        }\n    }\n}\nfunction isEmptyTextBlock(block) {\n    if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block)) return !1;\n    const onlyText = block.children.every(_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan), blockText = getTextBlockText(block);\n    return onlyText && blockText === \"\";\n}\nfunction getTextBlockText(block) {\n    return block.children.map((child)=>child.text ?? \"\").join(\"\");\n}\nconst IS_MAC =  false && 0, modifiers = {\n    alt: \"altKey\",\n    control: \"ctrlKey\",\n    meta: \"metaKey\",\n    shift: \"shiftKey\"\n}, aliases = {\n    add: \"+\",\n    break: \"pause\",\n    cmd: \"meta\",\n    command: \"meta\",\n    ctl: \"control\",\n    ctrl: \"control\",\n    del: \"delete\",\n    down: \"arrowdown\",\n    esc: \"escape\",\n    ins: \"insert\",\n    left: \"arrowleft\",\n    mod: IS_MAC ? \"meta\" : \"control\",\n    opt: \"alt\",\n    option: \"alt\",\n    return: \"enter\",\n    right: \"arrowright\",\n    space: \" \",\n    spacebar: \" \",\n    up: \"arrowup\",\n    win: \"meta\",\n    windows: \"meta\"\n}, keyCodes = {\n    backspace: 8,\n    tab: 9,\n    enter: 13,\n    shift: 16,\n    control: 17,\n    alt: 18,\n    pause: 19,\n    capslock: 20,\n    escape: 27,\n    \" \": 32,\n    pageup: 33,\n    pagedown: 34,\n    end: 35,\n    home: 36,\n    arrowleft: 37,\n    arrowup: 38,\n    arrowright: 39,\n    arrowdown: 40,\n    insert: 45,\n    delete: 46,\n    meta: 91,\n    numlock: 144,\n    scrolllock: 145,\n    \";\": 186,\n    \"=\": 187,\n    \",\": 188,\n    \"-\": 189,\n    \".\": 190,\n    \"/\": 191,\n    \"`\": 192,\n    \"[\": 219,\n    \"\\\\\": 220,\n    \"]\": 221,\n    \"'\": 222,\n    f1: 112,\n    f2: 113,\n    f3: 114,\n    f4: 115,\n    f5: 116,\n    f6: 117,\n    f7: 118,\n    f8: 119,\n    f9: 120,\n    f10: 121,\n    f11: 122,\n    f12: 123,\n    f13: 124,\n    f14: 125,\n    f15: 126,\n    f16: 127,\n    f17: 128,\n    f18: 129,\n    f19: 130,\n    f20: 131\n};\nfunction isHotkey(hotkey, event) {\n    return compareHotkey(parseHotkey(hotkey), event);\n}\nfunction parseHotkey(hotkey) {\n    const parsedHotkey = {\n        altKey: !1,\n        ctrlKey: !1,\n        metaKey: !1,\n        shiftKey: !1\n    }, hotkeySegments = hotkey.replace(\"++\", \"+add\").split(\"+\");\n    for (const rawHotkeySegment of hotkeySegments){\n        const optional = rawHotkeySegment.endsWith(\"?\") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code = keyCodes[keyName];\n        if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code === void 0) throw new TypeError(`Unknown modifier: \"${hotkeySegment}\"`);\n        (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);\n    }\n    return parsedHotkey;\n}\nfunction compareHotkey(parsedHotkey, event) {\n    return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;\n}\nfunction toKeyCode(name) {\n    const keyName = toKeyName(name);\n    return keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0);\n}\nfunction toKeyName(name) {\n    const keyName = name.toLowerCase();\n    return aliases[keyName] ?? keyName;\n}\nfunction defineBehavior(behavior) {\n    return behavior;\n}\nconst arrowDownOnLonelyBlockObject = {\n    on: \"key.down\",\n    guard: ({ context, event })=>{\n        const isArrowDown = isHotkey(\"ArrowDown\", event.keyboardEvent), focusBlockObject = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusBlockObject)({\n            context\n        }), nextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getNextBlock)({\n            context\n        });\n        return isArrowDown && focusBlockObject && !nextBlock;\n    },\n    actions: [\n        ()=>[\n                {\n                    type: \"insert.text block\",\n                    placement: \"after\"\n                }\n            ]\n    ]\n}, arrowUpOnLonelyBlockObject = {\n    on: \"key.down\",\n    guard: ({ context, event })=>{\n        const isArrowUp = isHotkey(\"ArrowUp\", event.keyboardEvent), focusBlockObject = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusBlockObject)({\n            context\n        }), previousBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getPreviousBlock)({\n            context\n        });\n        return isArrowUp && focusBlockObject && !previousBlock;\n    },\n    actions: [\n        ()=>[\n                {\n                    type: \"insert.text block\",\n                    placement: \"before\"\n                },\n                {\n                    type: \"select.previous block\"\n                }\n            ]\n    ]\n}, breakingBlockObject = {\n    on: \"insert.break\",\n    guard: ({ context })=>{\n        const focusBlockObject = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusBlockObject)({\n            context\n        });\n        return (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n            context\n        }) && focusBlockObject !== void 0;\n    },\n    actions: [\n        ()=>[\n                {\n                    type: \"insert.text block\",\n                    placement: \"after\"\n                }\n            ]\n    ]\n}, deletingEmptyTextBlockAfterBlockObject = {\n    on: \"delete.backward\",\n    guard: ({ context })=>{\n        const focusTextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n            context\n        }), selectionCollapsed = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n            context\n        }), previousBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getPreviousBlock)({\n            context\n        });\n        return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : isEmptyTextBlock(focusTextBlock.node) && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(previousBlock.node) ? {\n            focusTextBlock,\n            previousBlock\n        } : !1;\n    },\n    actions: [\n        (_, { focusTextBlock, previousBlock })=>[\n                {\n                    type: \"delete.block\",\n                    blockPath: focusTextBlock.path\n                },\n                {\n                    type: \"select\",\n                    selection: {\n                        anchor: {\n                            path: previousBlock.path,\n                            offset: 0\n                        },\n                        focus: {\n                            path: previousBlock.path,\n                            offset: 0\n                        }\n                    }\n                }\n            ]\n    ]\n}, deletingEmptyTextBlockBeforeBlockObject = {\n    on: \"delete.forward\",\n    guard: ({ context })=>{\n        const focusTextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n            context\n        }), selectionCollapsed = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n            context\n        }), nextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getNextBlock)({\n            context\n        });\n        return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : isEmptyTextBlock(focusTextBlock.node) && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(nextBlock.node) ? {\n            focusTextBlock,\n            nextBlock\n        } : !1;\n    },\n    actions: [\n        (_, { focusTextBlock, nextBlock })=>[\n                {\n                    type: \"delete.block\",\n                    blockPath: focusTextBlock.path\n                },\n                {\n                    type: \"select\",\n                    selection: {\n                        anchor: {\n                            path: nextBlock.path,\n                            offset: 0\n                        },\n                        focus: {\n                            path: nextBlock.path,\n                            offset: 0\n                        }\n                    }\n                }\n            ]\n    ]\n}, coreBlockObjectBehaviors = {\n    arrowDownOnLonelyBlockObject,\n    arrowUpOnLonelyBlockObject,\n    breakingBlockObject,\n    deletingEmptyTextBlockAfterBlockObject,\n    deletingEmptyTextBlockBeforeBlockObject\n}, decoratorAdd = {\n    on: \"decorator.add\",\n    actions: [\n        ({ event })=>[\n                event,\n                {\n                    type: \"reselect\"\n                }\n            ]\n    ]\n}, decoratorRemove = {\n    on: \"decorator.remove\",\n    guard: ({ event })=>({\n            decorator: event.decorator\n        }),\n    actions: [\n        ({ event })=>[\n                event,\n                {\n                    type: \"reselect\"\n                }\n            ]\n    ]\n}, decoratorToggle = {\n    on: \"decorator.toggle\",\n    guard: ({ event })=>({\n            decorator: event.decorator\n        }),\n    actions: [\n        ({ event })=>[\n                event,\n                {\n                    type: \"reselect\"\n                }\n            ]\n    ]\n}, coreDecoratorBehaviors = {\n    decoratorAdd,\n    decoratorRemove,\n    decoratorToggle\n}, MAX_LIST_LEVEL = 10, clearListOnBackspace = {\n    on: \"delete.backward\",\n    guard: ({ context })=>{\n        const selectionCollapsed = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n            context\n        }), focusTextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n            context\n        }), focusSpan = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)({\n            context\n        });\n        return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection?.focus.offset === 0 && focusTextBlock.node.level === 1 ? {\n            focusTextBlock\n        } : !1;\n    },\n    actions: [\n        (_, { focusTextBlock })=>[\n                {\n                    type: \"text block.unset\",\n                    props: [\n                        \"listItem\",\n                        \"level\"\n                    ],\n                    at: focusTextBlock.path\n                }\n            ]\n    ]\n}, unindentListOnBackspace = {\n    on: \"delete.backward\",\n    guard: ({ context })=>{\n        const selectionCollapsed = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n            context\n        }), focusTextBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusTextBlock)({\n            context\n        }), focusSpan = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusSpan)({\n            context\n        });\n        return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && context.selection?.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {\n            focusTextBlock,\n            level: focusTextBlock.node.level - 1\n        } : !1;\n    },\n    actions: [\n        (_, { focusTextBlock, level })=>[\n                {\n                    type: \"text block.set\",\n                    level,\n                    at: focusTextBlock.path\n                }\n            ]\n    ]\n}, clearListOnEnter = {\n    on: \"insert.break\",\n    guard: ({ context })=>{\n        const selectionCollapsed = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.isSelectionCollapsed)({\n            context\n        }), focusListBlock = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getFocusListBlock)({\n            context\n        });\n        return !selectionCollapsed || !focusListBlock || !isEmptyTextBlock(focusListBlock.node) ? !1 : {\n            focusListBlock\n        };\n    },\n    actions: [\n        (_, { focusListBlock })=>[\n                {\n                    type: \"text block.unset\",\n                    props: [\n                        \"listItem\",\n                        \"level\"\n                    ],\n                    at: focusListBlock.path\n                }\n            ]\n    ]\n}, indentListOnTab = {\n    on: \"key.down\",\n    guard: ({ context, event })=>{\n        if (!isHotkey(\"Tab\", event.keyboardEvent)) return !1;\n        const selectedBlocks = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)({\n            context\n        }), guards = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.createGuards)(context), selectedListBlocks = selectedBlocks.flatMap((block)=>guards.isListBlock(block.node) ? [\n                {\n                    node: block.node,\n                    path: block.path\n                }\n            ] : []);\n        return selectedListBlocks.length === selectedBlocks.length ? {\n            selectedListBlocks\n        } : !1;\n    },\n    actions: [\n        (_, { selectedListBlocks })=>selectedListBlocks.map((selectedListBlock)=>({\n                    type: \"text block.set\",\n                    level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level + 1)),\n                    at: selectedListBlock.path\n                }))\n    ]\n}, unindentListOnShiftTab = {\n    on: \"key.down\",\n    guard: ({ context, event })=>{\n        if (!isHotkey(\"Shift+Tab\", event.keyboardEvent)) return !1;\n        const selectedBlocks = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.getSelectedBlocks)({\n            context\n        }), guards = (0,_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_1__.createGuards)(context), selectedListBlocks = selectedBlocks.flatMap((block)=>guards.isListBlock(block.node) ? [\n                {\n                    node: block.node,\n                    path: block.path\n                }\n            ] : []);\n        return selectedListBlocks.length === selectedBlocks.length ? {\n            selectedListBlocks\n        } : !1;\n    },\n    actions: [\n        (_, { selectedListBlocks })=>selectedListBlocks.map((selectedListBlock)=>({\n                    type: \"text block.set\",\n                    level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level - 1)),\n                    at: selectedListBlock.path\n                }))\n    ]\n}, coreListBehaviors = {\n    clearListOnBackspace,\n    unindentListOnBackspace,\n    clearListOnEnter,\n    indentListOnTab,\n    unindentListOnShiftTab\n}, softReturn = {\n    on: \"insert.soft break\",\n    actions: [\n        ()=>[\n                {\n                    type: \"insert.text\",\n                    text: `\n`\n                }\n            ]\n    ]\n}, coreBehaviors = [\n    softReturn,\n    coreDecoratorBehaviors.decoratorAdd,\n    coreDecoratorBehaviors.decoratorRemove,\n    coreDecoratorBehaviors.decoratorToggle,\n    coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject,\n    coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject,\n    coreBlockObjectBehaviors.breakingBlockObject,\n    coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject,\n    coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject,\n    coreListBehaviors.clearListOnBackspace,\n    coreListBehaviors.unindentListOnBackspace,\n    coreListBehaviors.clearListOnEnter,\n    coreListBehaviors.indentListOnTab,\n    coreListBehaviors.unindentListOnShiftTab\n], coreBehavior = {\n    softReturn,\n    decorators: coreDecoratorBehaviors,\n    blockObjects: coreBlockObjectBehaviors,\n    lists: coreListBehaviors\n};\n //# sourceMappingURL=behavior.core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvYmVoYXZpb3IuY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBNEU7QUFDMEk7QUFDdE4sU0FBU1csZ0NBQWdDLEVBQ3ZDQyxLQUFLLEVBQ0xDLFdBQVcsRUFDWjtJQUNDLElBQUlDLGFBQWFELFlBQVlFLE1BQU0sRUFBRUM7SUFDckMsS0FBSyxNQUFNQyxTQUFTTCxNQUNsQixJQUFJSyxNQUFNQyxJQUFJLEtBQUtMLFlBQVlNLElBQUksQ0FBQyxFQUFFLENBQUNELElBQUksSUFBSWxCLHNFQUF1QkEsQ0FBQ2lCLFFBQVE7UUFDN0UsS0FBSyxNQUFNRyxTQUFTSCxNQUFNSSxRQUFRLENBQ2hDLElBQUlwQixpRUFBa0JBLENBQUNtQixRQUFRO1lBQzdCLElBQUlOLGVBQWUsR0FBRztnQkFDcEJFLGlCQUFpQjtvQkFDZkcsTUFBTTsyQkFBSU4sWUFBWU0sSUFBSTt3QkFBRTt3QkFBWTs0QkFDdENELE1BQU1FLE1BQU1GLElBQUk7d0JBQ2xCO3FCQUFFO29CQUNGSCxRQUFRO2dCQUNWO2dCQUNBO1lBQ0Y7WUFDQSxJQUFJRCxjQUFjTSxNQUFNRSxJQUFJLENBQUNDLE1BQU0sRUFBRTtnQkFDbkNQLGlCQUFpQjtvQkFDZkcsTUFBTTsyQkFBSU4sWUFBWU0sSUFBSTt3QkFBRTt3QkFBWTs0QkFDdENELE1BQU1FLE1BQU1GLElBQUk7d0JBQ2xCO3FCQUFFO29CQUNGSCxRQUFRRDtnQkFDVjtnQkFDQTtZQUNGO1lBQ0FBLGNBQWNNLE1BQU1FLElBQUksQ0FBQ0MsTUFBTTtRQUNqQztJQUNKO0lBQ0YsT0FBT1A7QUFDVDtBQUNBLFNBQVNRLGdDQUFnQyxFQUN2Q1osS0FBSyxFQUNMSSxjQUFjLEVBQ2Y7SUFDQyxJQUFJRCxTQUFTO0lBQ2IsS0FBSyxNQUFNRSxTQUFTTCxNQUNsQixJQUFJSyxNQUFNQyxJQUFJLEtBQUtGLGVBQWVHLElBQUksQ0FBQyxFQUFF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QUFDO0FBQ0wsR0FBR3VLLGdCQUFnQjtJQUFDRDtJQUFZdEIsdUJBQXVCSixZQUFZO0lBQUVJLHVCQUF1QkgsZUFBZTtJQUFFRyx1QkFBdUJELGVBQWU7SUFBRUoseUJBQXlCekIsNEJBQTRCO0lBQUV5Qix5QkFBeUJkLDBCQUEwQjtJQUFFYyx5QkFBeUJYLG1CQUFtQjtJQUFFVyx5QkFBeUJWLHNDQUFzQztJQUFFVSx5QkFBeUJELHVDQUF1QztJQUFFMkIsa0JBQWtCbkIsb0JBQW9CO0lBQUVtQixrQkFBa0JkLHVCQUF1QjtJQUFFYyxrQkFBa0JiLGdCQUFnQjtJQUFFYSxrQkFBa0JYLGVBQWU7SUFBRVcsa0JBQWtCRCxzQkFBc0I7Q0FBQyxFQUFFSSxlQUFlO0lBQ3BvQkY7SUFDQUcsWUFBWXpCO0lBQ1owQixjQUFjL0I7SUFDZGdDLE9BQU9OO0FBQ1Q7QUFTRSxDQUNGLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL2JlaGF2aW9yLmNvcmUuanM/YTUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BvcnRhYmxlVGV4dFRleHRCbG9jaywgaXNQb3J0YWJsZVRleHRTcGFuIH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmltcG9ydCB7IGdldEZvY3VzQmxvY2tPYmplY3QsIGdldE5leHRCbG9jaywgZ2V0UHJldmlvdXNCbG9jaywgaXNTZWxlY3Rpb25Db2xsYXBzZWQsIGdldEZvY3VzVGV4dEJsb2NrLCBnZXRGb2N1c1NwYW4sIGdldEZvY3VzTGlzdEJsb2NrLCBnZXRTZWxlY3RlZEJsb2NrcywgY3JlYXRlR3VhcmRzIH0gZnJvbSBcIi4vc2VsZWN0b3IuaXMtc2VsZWN0aW9uLWNvbGxhcHNlZC5qc1wiO1xuZnVuY3Rpb24gYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCh7XG4gIHZhbHVlLFxuICBibG9ja09mZnNldFxufSkge1xuICBsZXQgb2Zmc2V0TGVmdCA9IGJsb2NrT2Zmc2V0Lm9mZnNldCwgc2VsZWN0aW9uUG9pbnQ7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgdmFsdWUpXG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IGJsb2NrT2Zmc2V0LnBhdGhbMF0uX2tleSAmJiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhibG9jaykpIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYmxvY2suY2hpbGRyZW4pXG4gICAgICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oY2hpbGQpKSB7XG4gICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGVjdGlvblBvaW50ID0ge1xuICAgICAgICAgICAgICBwYXRoOiBbLi4uYmxvY2tPZmZzZXQucGF0aCwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvZmZzZXRMZWZ0IDw9IGNoaWxkLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25Qb2ludCA9IHtcbiAgICAgICAgICAgICAgcGF0aDogWy4uLmJsb2NrT2Zmc2V0LnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0TGVmdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXRMZWZ0IC09IGNoaWxkLnRleHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICByZXR1cm4gc2VsZWN0aW9uUG9pbnQ7XG59XG5mdW5jdGlvbiBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0KHtcbiAgdmFsdWUsXG4gIHNlbGVjdGlvblBvaW50XG59KSB7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGJsb2NrIG9mIHZhbHVlKVxuICAgIGlmIChibG9jay5fa2V5ID09PSBzZWxlY3Rpb25Qb2ludC5wYXRoWzBdLl9rZXkgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soYmxvY2spKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGJsb2NrLmNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSkge1xuICAgICAgICAgIGlmIChjaGlsZC5fa2V5ID09PSBzZWxlY3Rpb25Qb2ludC5wYXRoWzJdLl9rZXkpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0ICsgc2VsZWN0aW9uUG9pbnQub2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIG9mZnNldCArPSBjaGlsZC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRW1wdHlUZXh0QmxvY2soYmxvY2spIHtcbiAgaWYgKCFpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhibG9jaykpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBvbmx5VGV4dCA9IGJsb2NrLmNoaWxkcmVuLmV2ZXJ5KGlzUG9ydGFibGVUZXh0U3BhbiksIGJsb2NrVGV4dCA9IGdldFRleHRCbG9ja1RleHQoYmxvY2spO1xuICByZXR1cm4gb25seVRleHQgJiYgYmxvY2tUZXh0ID09PSBcIlwiO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEJsb2NrVGV4dChibG9jaykge1xuICByZXR1cm4gYmxvY2suY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQudGV4dCA/PyBcIlwiKS5qb2luKFwiXCIpO1xufVxuY29uc3QgSVNfTUFDID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCksIG1vZGlmaWVycyA9IHtcbiAgYWx0OiBcImFsdEtleVwiLFxuICBjb250cm9sOiBcImN0cmxLZXlcIixcbiAgbWV0YTogXCJtZXRhS2V5XCIsXG4gIHNoaWZ0OiBcInNoaWZ0S2V5XCJcbn0sIGFsaWFzZXMgPSB7XG4gIGFkZDogXCIrXCIsXG4gIGJyZWFrOiBcInBhdXNlXCIsXG4gIGNtZDogXCJtZXRhXCIsXG4gIGNvbW1hbmQ6IFwibWV0YVwiLFxuICBjdGw6IFwiY29udHJvbFwiLFxuICBjdHJsOiBcImNvbnRyb2xcIixcbiAgZGVsOiBcImRlbGV0ZVwiLFxuICBkb3duOiBcImFycm93ZG93blwiLFxuICBlc2M6IFwiZXNjYXBlXCIsXG4gIGluczogXCJpbnNlcnRcIixcbiAgbGVmdDogXCJhcnJvd2xlZnRcIixcbiAgbW9kOiBJU19NQUMgPyBcIm1ldGFcIiA6IFwiY29udHJvbFwiLFxuICBvcHQ6IFwiYWx0XCIsXG4gIG9wdGlvbjogXCJhbHRcIixcbiAgcmV0dXJuOiBcImVudGVyXCIsXG4gIHJpZ2h0OiBcImFycm93cmlnaHRcIixcbiAgc3BhY2U6IFwiIFwiLFxuICBzcGFjZWJhcjogXCIgXCIsXG4gIHVwOiBcImFycm93dXBcIixcbiAgd2luOiBcIm1ldGFcIixcbiAgd2luZG93czogXCJtZXRhXCJcbn0sIGtleUNvZGVzID0ge1xuICBiYWNrc3BhY2U6IDgsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzaGlmdDogMTYsXG4gIGNvbnRyb2w6IDE3LFxuICBhbHQ6IDE4LFxuICBwYXVzZTogMTksXG4gIGNhcHNsb2NrOiAyMCxcbiAgZXNjYXBlOiAyNyxcbiAgXCIgXCI6IDMyLFxuICBwYWdldXA6IDMzLFxuICBwYWdlZG93bjogMzQsXG4gIGVuZDogMzUsXG4gIGhvbWU6IDM2LFxuICBhcnJvd2xlZnQ6IDM3LFxuICBhcnJvd3VwOiAzOCxcbiAgYXJyb3dyaWdodDogMzksXG4gIGFycm93ZG93bjogNDAsXG4gIGluc2VydDogNDUsXG4gIGRlbGV0ZTogNDYsXG4gIG1ldGE6IDkxLFxuICBudW1sb2NrOiAxNDQsXG4gIHNjcm9sbGxvY2s6IDE0NSxcbiAgXCI7XCI6IDE4NixcbiAgXCI9XCI6IDE4NyxcbiAgXCIsXCI6IDE4OCxcbiAgXCItXCI6IDE4OSxcbiAgXCIuXCI6IDE5MCxcbiAgXCIvXCI6IDE5MSxcbiAgXCJgXCI6IDE5MixcbiAgXCJbXCI6IDIxOSxcbiAgXCJcXFxcXCI6IDIyMCxcbiAgXCJdXCI6IDIyMSxcbiAgXCInXCI6IDIyMixcbiAgZjE6IDExMixcbiAgZjI6IDExMyxcbiAgZjM6IDExNCxcbiAgZjQ6IDExNSxcbiAgZjU6IDExNixcbiAgZjY6IDExNyxcbiAgZjc6IDExOCxcbiAgZjg6IDExOSxcbiAgZjk6IDEyMCxcbiAgZjEwOiAxMjEsXG4gIGYxMTogMTIyLFxuICBmMTI6IDEyMyxcbiAgZjEzOiAxMjQsXG4gIGYxNDogMTI1LFxuICBmMTU6IDEyNixcbiAgZjE2OiAxMjcsXG4gIGYxNzogMTI4LFxuICBmMTg6IDEyOSxcbiAgZjE5OiAxMzAsXG4gIGYyMDogMTMxXG59O1xuZnVuY3Rpb24gaXNIb3RrZXkoaG90a2V5LCBldmVudCkge1xuICByZXR1cm4gY29tcGFyZUhvdGtleShwYXJzZUhvdGtleShob3RrZXkpLCBldmVudCk7XG59XG5mdW5jdGlvbiBwYXJzZUhvdGtleShob3RrZXkpIHtcbiAgY29uc3QgcGFyc2VkSG90a2V5ID0ge1xuICAgIGFsdEtleTogITEsXG4gICAgY3RybEtleTogITEsXG4gICAgbWV0YUtleTogITEsXG4gICAgc2hpZnRLZXk6ICExXG4gIH0sIGhvdGtleVNlZ21lbnRzID0gaG90a2V5LnJlcGxhY2UoXCIrK1wiLCBcIithZGRcIikuc3BsaXQoXCIrXCIpO1xuICBmb3IgKGNvbnN0IHJhd0hvdGtleVNlZ21lbnQgb2YgaG90a2V5U2VnbWVudHMpIHtcbiAgICBjb25zdCBvcHRpb25hbCA9IHJhd0hvdGtleVNlZ21lbnQuZW5kc1dpdGgoXCI/XCIpICYmIHJhd0hvdGtleVNlZ21lbnQubGVuZ3RoID4gMSwgaG90a2V5U2VnbWVudCA9IG9wdGlvbmFsID8gcmF3SG90a2V5U2VnbWVudC5zbGljZSgwLCAtMSkgOiByYXdIb3RrZXlTZWdtZW50LCBrZXlOYW1lID0gdG9LZXlOYW1lKGhvdGtleVNlZ21lbnQpLCBtb2RpZmllciA9IG1vZGlmaWVyc1trZXlOYW1lXSwgYWxpYXMgPSBhbGlhc2VzW2hvdGtleVNlZ21lbnRdLCBjb2RlID0ga2V5Q29kZXNba2V5TmFtZV07XG4gICAgaWYgKGhvdGtleVNlZ21lbnQubGVuZ3RoID4gMSAmJiBtb2RpZmllciA9PT0gdm9pZCAwICYmIGFsaWFzID09PSB2b2lkIDAgJiYgY29kZSA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5rbm93biBtb2RpZmllcjogXCIke2hvdGtleVNlZ21lbnR9XCJgKTtcbiAgICAoaG90a2V5U2VnbWVudHMubGVuZ3RoID09PSAxIHx8IG1vZGlmaWVyID09PSB2b2lkIDApICYmIChwYXJzZWRIb3RrZXkua2V5ID0ga2V5TmFtZSwgcGFyc2VkSG90a2V5LmtleUNvZGUgPSB0b0tleUNvZGUoaG90a2V5U2VnbWVudCkpLCBtb2RpZmllciAhPT0gdm9pZCAwICYmIChwYXJzZWRIb3RrZXlbbW9kaWZpZXJdID0gb3B0aW9uYWwgPyBudWxsIDogITApO1xuICB9XG4gIHJldHVybiBwYXJzZWRIb3RrZXk7XG59XG5mdW5jdGlvbiBjb21wYXJlSG90a2V5KHBhcnNlZEhvdGtleSwgZXZlbnQpIHtcbiAgcmV0dXJuIChwYXJzZWRIb3RrZXkuYWx0S2V5ID09IG51bGwgfHwgcGFyc2VkSG90a2V5LmFsdEtleSA9PT0gZXZlbnQuYWx0S2V5KSAmJiAocGFyc2VkSG90a2V5LmN0cmxLZXkgPT0gbnVsbCB8fCBwYXJzZWRIb3RrZXkuY3RybEtleSA9PT0gZXZlbnQuY3RybEtleSkgJiYgKHBhcnNlZEhvdGtleS5tZXRhS2V5ID09IG51bGwgfHwgcGFyc2VkSG90a2V5Lm1ldGFLZXkgPT09IGV2ZW50Lm1ldGFLZXkpICYmIChwYXJzZWRIb3RrZXkuc2hpZnRLZXkgPT0gbnVsbCB8fCBwYXJzZWRIb3RrZXkuc2hpZnRLZXkgPT09IGV2ZW50LnNoaWZ0S2V5KSA/IHBhcnNlZEhvdGtleS5rZXlDb2RlICE9PSB2b2lkIDAgJiYgZXZlbnQua2V5Q29kZSAhPT0gdm9pZCAwID8gcGFyc2VkSG90a2V5LmtleUNvZGUgPT09IDkxICYmIGV2ZW50LmtleUNvZGUgPT09IDkzID8gITAgOiBwYXJzZWRIb3RrZXkua2V5Q29kZSA9PT0gZXZlbnQua2V5Q29kZSA6IHBhcnNlZEhvdGtleS5rZXlDb2RlID09PSBldmVudC5rZXlDb2RlIHx8IHBhcnNlZEhvdGtleS5rZXkgPT09IGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpIDogITE7XG59XG5mdW5jdGlvbiB0b0tleUNvZGUobmFtZSkge1xuICBjb25zdCBrZXlOYW1lID0gdG9LZXlOYW1lKG5hbWUpO1xuICByZXR1cm4ga2V5Q29kZXNba2V5TmFtZV0gPz8ga2V5TmFtZS50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCk7XG59XG5mdW5jdGlvbiB0b0tleU5hbWUobmFtZSkge1xuICBjb25zdCBrZXlOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gYWxpYXNlc1trZXlOYW1lXSA/PyBrZXlOYW1lO1xufVxuZnVuY3Rpb24gZGVmaW5lQmVoYXZpb3IoYmVoYXZpb3IpIHtcbiAgcmV0dXJuIGJlaGF2aW9yO1xufVxuY29uc3QgYXJyb3dEb3duT25Mb25lbHlCbG9ja09iamVjdCA9IHtcbiAgb246IFwia2V5LmRvd25cIixcbiAgZ3VhcmQ6ICh7XG4gICAgY29udGV4dCxcbiAgICBldmVudFxuICB9KSA9PiB7XG4gICAgY29uc3QgaXNBcnJvd0Rvd24gPSBpc0hvdGtleShcIkFycm93RG93blwiLCBldmVudC5rZXlib2FyZEV2ZW50KSwgZm9jdXNCbG9ja09iamVjdCA9IGdldEZvY3VzQmxvY2tPYmplY3Qoe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBuZXh0QmxvY2sgPSBnZXROZXh0QmxvY2soe1xuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIHJldHVybiBpc0Fycm93RG93biAmJiBmb2N1c0Jsb2NrT2JqZWN0ICYmICFuZXh0QmxvY2s7XG4gIH0sXG4gIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgIHR5cGU6IFwiaW5zZXJ0LnRleHQgYmxvY2tcIixcbiAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICB9XV1cbn0sIGFycm93VXBPbkxvbmVseUJsb2NrT2JqZWN0ID0ge1xuICBvbjogXCJrZXkuZG93blwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBjb25zdCBpc0Fycm93VXAgPSBpc0hvdGtleShcIkFycm93VXBcIiwgZXZlbnQua2V5Ym9hcmRFdmVudCksIGZvY3VzQmxvY2tPYmplY3QgPSBnZXRGb2N1c0Jsb2NrT2JqZWN0KHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSwgcHJldmlvdXNCbG9jayA9IGdldFByZXZpb3VzQmxvY2soe1xuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIHJldHVybiBpc0Fycm93VXAgJiYgZm9jdXNCbG9ja09iamVjdCAmJiAhcHJldmlvdXNCbG9jaztcbiAgfSxcbiAgYWN0aW9uczogWygpID0+IFt7XG4gICAgdHlwZTogXCJpbnNlcnQudGV4dCBibG9ja1wiLFxuICAgIHBsYWNlbWVudDogXCJiZWZvcmVcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzZWxlY3QucHJldmlvdXMgYmxvY2tcIlxuICB9XV1cbn0sIGJyZWFraW5nQmxvY2tPYmplY3QgPSB7XG4gIG9uOiBcImluc2VydC5icmVha1wiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c0Jsb2NrT2JqZWN0ID0gZ2V0Rm9jdXNCbG9ja09iamVjdCh7XG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzU2VsZWN0aW9uQ29sbGFwc2VkKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSAmJiBmb2N1c0Jsb2NrT2JqZWN0ICE9PSB2b2lkIDA7XG4gIH0sXG4gIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgIHR5cGU6IFwiaW5zZXJ0LnRleHQgYmxvY2tcIixcbiAgICBwbGFjZW1lbnQ6IFwiYWZ0ZXJcIlxuICB9XV1cbn0sIGRlbGV0aW5nRW1wdHlUZXh0QmxvY2tBZnRlckJsb2NrT2JqZWN0ID0ge1xuICBvbjogXCJkZWxldGUuYmFja3dhcmRcIixcbiAgZ3VhcmQ6ICh7XG4gICAgY29udGV4dFxuICB9KSA9PiB7XG4gICAgY29uc3QgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayh7XG4gICAgICBjb250ZXh0XG4gICAgfSksIHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSwgcHJldmlvdXNCbG9jayA9IGdldFByZXZpb3VzQmxvY2soe1xuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIHJldHVybiAhZm9jdXNUZXh0QmxvY2sgfHwgIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhcHJldmlvdXNCbG9jayA/ICExIDogaXNFbXB0eVRleHRCbG9jayhmb2N1c1RleHRCbG9jay5ub2RlKSAmJiAhaXNQb3J0YWJsZVRleHRUZXh0QmxvY2socHJldmlvdXNCbG9jay5ub2RlKSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgcHJldmlvdXNCbG9ja1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgcHJldmlvdXNCbG9ja1xuICB9KSA9PiBbe1xuICAgIHR5cGU6IFwiZGVsZXRlLmJsb2NrXCIsXG4gICAgYmxvY2tQYXRoOiBmb2N1c1RleHRCbG9jay5wYXRoXG4gIH0sIHtcbiAgICB0eXBlOiBcInNlbGVjdFwiLFxuICAgIHNlbGVjdGlvbjoge1xuICAgICAgYW5jaG9yOiB7XG4gICAgICAgIHBhdGg6IHByZXZpb3VzQmxvY2sucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgZm9jdXM6IHtcbiAgICAgICAgcGF0aDogcHJldmlvdXNCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9XG4gIH1dXVxufSwgZGVsZXRpbmdFbXB0eVRleHRCbG9ja0JlZm9yZUJsb2NrT2JqZWN0ID0ge1xuICBvbjogXCJkZWxldGUuZm9yd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBmb2N1c1RleHRCbG9jayA9IGdldEZvY3VzVGV4dEJsb2NrKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSwgc2VsZWN0aW9uQ29sbGFwc2VkID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQoe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBuZXh0QmxvY2sgPSBnZXROZXh0QmxvY2soe1xuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIHJldHVybiAhZm9jdXNUZXh0QmxvY2sgfHwgIXNlbGVjdGlvbkNvbGxhcHNlZCB8fCAhbmV4dEJsb2NrID8gITEgOiBpc0VtcHR5VGV4dEJsb2NrKGZvY3VzVGV4dEJsb2NrLm5vZGUpICYmICFpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhuZXh0QmxvY2subm9kZSkgPyB7XG4gICAgICBmb2N1c1RleHRCbG9jayxcbiAgICAgIG5leHRCbG9ja1xuICAgIH0gOiAhMTtcbiAgfSxcbiAgYWN0aW9uczogWyhfLCB7XG4gICAgZm9jdXNUZXh0QmxvY2ssXG4gICAgbmV4dEJsb2NrXG4gIH0pID0+IFt7XG4gICAgdHlwZTogXCJkZWxldGUuYmxvY2tcIixcbiAgICBibG9ja1BhdGg6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgfSwge1xuICAgIHR5cGU6IFwic2VsZWN0XCIsXG4gICAgc2VsZWN0aW9uOiB7XG4gICAgICBhbmNob3I6IHtcbiAgICAgICAgcGF0aDogbmV4dEJsb2NrLnBhdGgsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IG5leHRCbG9jay5wYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9XG4gIH1dXVxufSwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzID0ge1xuICBhcnJvd0Rvd25PbkxvbmVseUJsb2NrT2JqZWN0LFxuICBhcnJvd1VwT25Mb25lbHlCbG9ja09iamVjdCxcbiAgYnJlYWtpbmdCbG9ja09iamVjdCxcbiAgZGVsZXRpbmdFbXB0eVRleHRCbG9ja0FmdGVyQmxvY2tPYmplY3QsXG4gIGRlbGV0aW5nRW1wdHlUZXh0QmxvY2tCZWZvcmVCbG9ja09iamVjdFxufSwgZGVjb3JhdG9yQWRkID0ge1xuICBvbjogXCJkZWNvcmF0b3IuYWRkXCIsXG4gIGFjdGlvbnM6IFsoe1xuICAgIGV2ZW50XG4gIH0pID0+IFtldmVudCwge1xuICAgIHR5cGU6IFwicmVzZWxlY3RcIlxuICB9XV1cbn0sIGRlY29yYXRvclJlbW92ZSA9IHtcbiAgb246IFwiZGVjb3JhdG9yLnJlbW92ZVwiLFxuICBndWFyZDogKHtcbiAgICBldmVudFxuICB9KSA9PiAoe1xuICAgIGRlY29yYXRvcjogZXZlbnQuZGVjb3JhdG9yXG4gIH0pLFxuICBhY3Rpb25zOiBbKHtcbiAgICBldmVudFxuICB9KSA9PiBbZXZlbnQsIHtcbiAgICB0eXBlOiBcInJlc2VsZWN0XCJcbiAgfV1dXG59LCBkZWNvcmF0b3JUb2dnbGUgPSB7XG4gIG9uOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgZ3VhcmQ6ICh7XG4gICAgZXZlbnRcbiAgfSkgPT4gKHtcbiAgICBkZWNvcmF0b3I6IGV2ZW50LmRlY29yYXRvclxuICB9KSxcbiAgYWN0aW9uczogWyh7XG4gICAgZXZlbnRcbiAgfSkgPT4gW2V2ZW50LCB7XG4gICAgdHlwZTogXCJyZXNlbGVjdFwiXG4gIH1dXVxufSwgY29yZURlY29yYXRvckJlaGF2aW9ycyA9IHtcbiAgZGVjb3JhdG9yQWRkLFxuICBkZWNvcmF0b3JSZW1vdmUsXG4gIGRlY29yYXRvclRvZ2dsZVxufSwgTUFYX0xJU1RfTEVWRUwgPSAxMCwgY2xlYXJMaXN0T25CYWNrc3BhY2UgPSB7XG4gIG9uOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCh7XG4gICAgICBjb250ZXh0XG4gICAgfSksIGZvY3VzVGV4dEJsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBmb2N1c1NwYW4gPSBnZXRGb2N1c1NwYW4oe1xuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIHJldHVybiAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFmb2N1c1RleHRCbG9jayB8fCAhZm9jdXNTcGFuID8gITEgOiBmb2N1c1RleHRCbG9jay5ub2RlLmNoaWxkcmVuWzBdLl9rZXkgPT09IGZvY3VzU3Bhbi5ub2RlLl9rZXkgJiYgY29udGV4dC5zZWxlY3Rpb24/LmZvY3VzLm9mZnNldCA9PT0gMCAmJiBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsID09PSAxID8ge1xuICAgICAgZm9jdXNUZXh0QmxvY2tcbiAgICB9IDogITE7XG4gIH0sXG4gIGFjdGlvbnM6IFsoXywge1xuICAgIGZvY3VzVGV4dEJsb2NrXG4gIH0pID0+IFt7XG4gICAgdHlwZTogXCJ0ZXh0IGJsb2NrLnVuc2V0XCIsXG4gICAgcHJvcHM6IFtcImxpc3RJdGVtXCIsIFwibGV2ZWxcIl0sXG4gICAgYXQ6IGZvY3VzVGV4dEJsb2NrLnBhdGhcbiAgfV1dXG59LCB1bmluZGVudExpc3RPbkJhY2tzcGFjZSA9IHtcbiAgb246IFwiZGVsZXRlLmJhY2t3YXJkXCIsXG4gIGd1YXJkOiAoe1xuICAgIGNvbnRleHRcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSwgZm9jdXNUZXh0QmxvY2sgPSBnZXRGb2N1c1RleHRCbG9jayh7XG4gICAgICBjb250ZXh0XG4gICAgfSksIGZvY3VzU3BhbiA9IGdldEZvY3VzU3Bhbih7XG4gICAgICBjb250ZXh0XG4gICAgfSk7XG4gICAgcmV0dXJuICFzZWxlY3Rpb25Db2xsYXBzZWQgfHwgIWZvY3VzVGV4dEJsb2NrIHx8ICFmb2N1c1NwYW4gPyAhMSA6IGZvY3VzVGV4dEJsb2NrLm5vZGUuY2hpbGRyZW5bMF0uX2tleSA9PT0gZm9jdXNTcGFuLm5vZGUuX2tleSAmJiBjb250ZXh0LnNlbGVjdGlvbj8uZm9jdXMub2Zmc2V0ID09PSAwICYmIGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWwgIT09IHZvaWQgMCAmJiBmb2N1c1RleHRCbG9jay5ub2RlLmxldmVsID4gMSA/IHtcbiAgICAgIGZvY3VzVGV4dEJsb2NrLFxuICAgICAgbGV2ZWw6IGZvY3VzVGV4dEJsb2NrLm5vZGUubGV2ZWwgLSAxXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c1RleHRCbG9jayxcbiAgICBsZXZlbFxuICB9KSA9PiBbe1xuICAgIHR5cGU6IFwidGV4dCBibG9jay5zZXRcIixcbiAgICBsZXZlbCxcbiAgICBhdDogZm9jdXNUZXh0QmxvY2sucGF0aFxuICB9XV1cbn0sIGNsZWFyTGlzdE9uRW50ZXIgPSB7XG4gIG9uOiBcImluc2VydC5icmVha1wiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0XG4gIH0pID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb25Db2xsYXBzZWQgPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCh7XG4gICAgICBjb250ZXh0XG4gICAgfSksIGZvY3VzTGlzdEJsb2NrID0gZ2V0Rm9jdXNMaXN0QmxvY2soe1xuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIHJldHVybiAhc2VsZWN0aW9uQ29sbGFwc2VkIHx8ICFmb2N1c0xpc3RCbG9jayB8fCAhaXNFbXB0eVRleHRCbG9jayhmb2N1c0xpc3RCbG9jay5ub2RlKSA/ICExIDoge1xuICAgICAgZm9jdXNMaXN0QmxvY2tcbiAgICB9O1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBmb2N1c0xpc3RCbG9ja1xuICB9KSA9PiBbe1xuICAgIHR5cGU6IFwidGV4dCBibG9jay51bnNldFwiLFxuICAgIHByb3BzOiBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLFxuICAgIGF0OiBmb2N1c0xpc3RCbG9jay5wYXRoXG4gIH1dXVxufSwgaW5kZW50TGlzdE9uVGFiID0ge1xuICBvbjogXCJrZXkuZG93blwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoIWlzSG90a2V5KFwiVGFiXCIsIGV2ZW50LmtleWJvYXJkRXZlbnQpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBndWFyZHMgPSBjcmVhdGVHdWFyZHMoY29udGV4dCksIHNlbGVjdGVkTGlzdEJsb2NrcyA9IHNlbGVjdGVkQmxvY2tzLmZsYXRNYXAoKGJsb2NrKSA9PiBndWFyZHMuaXNMaXN0QmxvY2soYmxvY2subm9kZSkgPyBbe1xuICAgICAgbm9kZTogYmxvY2subm9kZSxcbiAgICAgIHBhdGg6IGJsb2NrLnBhdGhcbiAgICB9XSA6IFtdKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRMaXN0QmxvY2tzLmxlbmd0aCA9PT0gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID8ge1xuICAgICAgc2VsZWN0ZWRMaXN0QmxvY2tzXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBzZWxlY3RlZExpc3RCbG9ja3NcbiAgfSkgPT4gc2VsZWN0ZWRMaXN0QmxvY2tzLm1hcCgoc2VsZWN0ZWRMaXN0QmxvY2spID0+ICh7XG4gICAgdHlwZTogXCJ0ZXh0IGJsb2NrLnNldFwiLFxuICAgIGxldmVsOiBNYXRoLm1pbihNQVhfTElTVF9MRVZFTCwgTWF0aC5tYXgoMSwgc2VsZWN0ZWRMaXN0QmxvY2subm9kZS5sZXZlbCArIDEpKSxcbiAgICBhdDogc2VsZWN0ZWRMaXN0QmxvY2sucGF0aFxuICB9KSldXG59LCB1bmluZGVudExpc3RPblNoaWZ0VGFiID0ge1xuICBvbjogXCJrZXkuZG93blwiLFxuICBndWFyZDogKHtcbiAgICBjb250ZXh0LFxuICAgIGV2ZW50XG4gIH0pID0+IHtcbiAgICBpZiAoIWlzSG90a2V5KFwiU2hpZnQrVGFiXCIsIGV2ZW50LmtleWJvYXJkRXZlbnQpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHNlbGVjdGVkQmxvY2tzID0gZ2V0U2VsZWN0ZWRCbG9ja3Moe1xuICAgICAgY29udGV4dFxuICAgIH0pLCBndWFyZHMgPSBjcmVhdGVHdWFyZHMoY29udGV4dCksIHNlbGVjdGVkTGlzdEJsb2NrcyA9IHNlbGVjdGVkQmxvY2tzLmZsYXRNYXAoKGJsb2NrKSA9PiBndWFyZHMuaXNMaXN0QmxvY2soYmxvY2subm9kZSkgPyBbe1xuICAgICAgbm9kZTogYmxvY2subm9kZSxcbiAgICAgIHBhdGg6IGJsb2NrLnBhdGhcbiAgICB9XSA6IFtdKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRMaXN0QmxvY2tzLmxlbmd0aCA9PT0gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID8ge1xuICAgICAgc2VsZWN0ZWRMaXN0QmxvY2tzXG4gICAgfSA6ICExO1xuICB9LFxuICBhY3Rpb25zOiBbKF8sIHtcbiAgICBzZWxlY3RlZExpc3RCbG9ja3NcbiAgfSkgPT4gc2VsZWN0ZWRMaXN0QmxvY2tzLm1hcCgoc2VsZWN0ZWRMaXN0QmxvY2spID0+ICh7XG4gICAgdHlwZTogXCJ0ZXh0IGJsb2NrLnNldFwiLFxuICAgIGxldmVsOiBNYXRoLm1pbihNQVhfTElTVF9MRVZFTCwgTWF0aC5tYXgoMSwgc2VsZWN0ZWRMaXN0QmxvY2subm9kZS5sZXZlbCAtIDEpKSxcbiAgICBhdDogc2VsZWN0ZWRMaXN0QmxvY2sucGF0aFxuICB9KSldXG59LCBjb3JlTGlzdEJlaGF2aW9ycyA9IHtcbiAgY2xlYXJMaXN0T25CYWNrc3BhY2UsXG4gIHVuaW5kZW50TGlzdE9uQmFja3NwYWNlLFxuICBjbGVhckxpc3RPbkVudGVyLFxuICBpbmRlbnRMaXN0T25UYWIsXG4gIHVuaW5kZW50TGlzdE9uU2hpZnRUYWJcbn0sIHNvZnRSZXR1cm4gPSB7XG4gIG9uOiBcImluc2VydC5zb2Z0IGJyZWFrXCIsXG4gIGFjdGlvbnM6IFsoKSA9PiBbe1xuICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICB0ZXh0OiBgXG5gXG4gIH1dXVxufSwgY29yZUJlaGF2aW9ycyA9IFtzb2Z0UmV0dXJuLCBjb3JlRGVjb3JhdG9yQmVoYXZpb3JzLmRlY29yYXRvckFkZCwgY29yZURlY29yYXRvckJlaGF2aW9ycy5kZWNvcmF0b3JSZW1vdmUsIGNvcmVEZWNvcmF0b3JCZWhhdmlvcnMuZGVjb3JhdG9yVG9nZ2xlLCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuYXJyb3dEb3duT25Mb25lbHlCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmFycm93VXBPbkxvbmVseUJsb2NrT2JqZWN0LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuYnJlYWtpbmdCbG9ja09iamVjdCwgY29yZUJsb2NrT2JqZWN0QmVoYXZpb3JzLmRlbGV0aW5nRW1wdHlUZXh0QmxvY2tBZnRlckJsb2NrT2JqZWN0LCBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMuZGVsZXRpbmdFbXB0eVRleHRCbG9ja0JlZm9yZUJsb2NrT2JqZWN0LCBjb3JlTGlzdEJlaGF2aW9ycy5jbGVhckxpc3RPbkJhY2tzcGFjZSwgY29yZUxpc3RCZWhhdmlvcnMudW5pbmRlbnRMaXN0T25CYWNrc3BhY2UsIGNvcmVMaXN0QmVoYXZpb3JzLmNsZWFyTGlzdE9uRW50ZXIsIGNvcmVMaXN0QmVoYXZpb3JzLmluZGVudExpc3RPblRhYiwgY29yZUxpc3RCZWhhdmlvcnMudW5pbmRlbnRMaXN0T25TaGlmdFRhYl0sIGNvcmVCZWhhdmlvciA9IHtcbiAgc29mdFJldHVybixcbiAgZGVjb3JhdG9yczogY29yZURlY29yYXRvckJlaGF2aW9ycyxcbiAgYmxvY2tPYmplY3RzOiBjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMsXG4gIGxpc3RzOiBjb3JlTGlzdEJlaGF2aW9yc1xufTtcbmV4cG9ydCB7XG4gIGJsb2NrT2Zmc2V0VG9TcGFuU2VsZWN0aW9uUG9pbnQsXG4gIGNvcmVCZWhhdmlvcixcbiAgY29yZUJlaGF2aW9ycyxcbiAgZGVmaW5lQmVoYXZpb3IsXG4gIGdldFRleHRCbG9ja1RleHQsXG4gIGlzSG90a2V5LFxuICBzcGFuU2VsZWN0aW9uUG9pbnRUb0Jsb2NrT2Zmc2V0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVoYXZpb3IuY29yZS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc1BvcnRhYmxlVGV4dFRleHRCbG9jayIsImlzUG9ydGFibGVUZXh0U3BhbiIsImdldEZvY3VzQmxvY2tPYmplY3QiLCJnZXROZXh0QmxvY2siLCJnZXRQcmV2aW91c0Jsb2NrIiwiaXNTZWxlY3Rpb25Db2xsYXBzZWQiLCJnZXRGb2N1c1RleHRCbG9jayIsImdldEZvY3VzU3BhbiIsImdldEZvY3VzTGlzdEJsb2NrIiwiZ2V0U2VsZWN0ZWRCbG9ja3MiLCJjcmVhdGVHdWFyZHMiLCJibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50IiwidmFsdWUiLCJibG9ja09mZnNldCIsIm9mZnNldExlZnQiLCJvZmZzZXQiLCJzZWxlY3Rpb25Qb2ludCIsImJsb2NrIiwiX2tleSIsInBhdGgiLCJjaGlsZCIsImNoaWxkcmVuIiwidGV4dCIsImxlbmd0aCIsInNwYW5TZWxlY3Rpb25Qb2ludFRvQmxvY2tPZmZzZXQiLCJpc0VtcHR5VGV4dEJsb2NrIiwib25seVRleHQiLCJldmVyeSIsImJsb2NrVGV4dCIsImdldFRleHRCbG9ja1RleHQiLCJtYXAiLCJqb2luIiwiSVNfTUFDIiwidGVzdCIsIndpbmRvdyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm1vZGlmaWVycyIsImFsdCIsImNvbnRyb2wiLCJtZXRhIiwic2hpZnQiLCJhbGlhc2VzIiwiYWRkIiwiYnJlYWsiLCJjbWQiLCJjb21tYW5kIiwiY3RsIiwiY3RybCIsImRlbCIsImRvd24iLCJlc2MiLCJpbnMiLCJsZWZ0IiwibW9kIiwib3B0Iiwib3B0aW9uIiwicmV0dXJuIiwicmlnaHQiLCJzcGFjZSIsInNwYWNlYmFyIiwidXAiLCJ3aW4iLCJ3aW5kb3dzIiwia2V5Q29kZXMiLCJiYWNrc3BhY2UiLCJ0YWIiLCJlbnRlciIsInBhdXNlIiwiY2Fwc2xvY2siLCJlc2NhcGUiLCJwYWdldXAiLCJwYWdlZG93biIsImVuZCIsImhvbWUiLCJhcnJvd2xlZnQiLCJhcnJvd3VwIiwiYXJyb3dyaWdodCIsImFycm93ZG93biIsImluc2VydCIsImRlbGV0ZSIsIm51bWxvY2siLCJzY3JvbGxsb2NrIiwiZjEiLCJmMiIsImYzIiwiZjQiLCJmNSIsImY2IiwiZjciLCJmOCIsImY5IiwiZjEwIiwiZjExIiwiZjEyIiwiZjEzIiwiZjE0IiwiZjE1IiwiZjE2IiwiZjE3IiwiZjE4IiwiZjE5IiwiZjIwIiwiaXNIb3RrZXkiLCJob3RrZXkiLCJldmVudCIsImNvbXBhcmVIb3RrZXkiLCJwYXJzZUhvdGtleSIsInBhcnNlZEhvdGtleSIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJob3RrZXlTZWdtZW50cyIsInJlcGxhY2UiLCJzcGxpdCIsInJhd0hvdGtleVNlZ21lbnQiLCJvcHRpb25hbCIsImVuZHNXaXRoIiwiaG90a2V5U2VnbWVudCIsInNsaWNlIiwia2V5TmFtZSIsInRvS2V5TmFtZSIsIm1vZGlmaWVyIiwiYWxpYXMiLCJjb2RlIiwiVHlwZUVycm9yIiwia2V5Iiwia2V5Q29kZSIsInRvS2V5Q29kZSIsInRvTG93ZXJDYXNlIiwibmFtZSIsInRvVXBwZXJDYXNlIiwiY2hhckNvZGVBdCIsImRlZmluZUJlaGF2aW9yIiwiYmVoYXZpb3IiLCJhcnJvd0Rvd25PbkxvbmVseUJsb2NrT2JqZWN0Iiwib24iLCJndWFyZCIsImNvbnRleHQiLCJpc0Fycm93RG93biIsImtleWJvYXJkRXZlbnQiLCJmb2N1c0Jsb2NrT2JqZWN0IiwibmV4dEJsb2NrIiwiYWN0aW9ucyIsInR5cGUiLCJwbGFjZW1lbnQiLCJhcnJvd1VwT25Mb25lbHlCbG9ja09iamVjdCIsImlzQXJyb3dVcCIsInByZXZpb3VzQmxvY2siLCJicmVha2luZ0Jsb2NrT2JqZWN0IiwiZGVsZXRpbmdFbXB0eVRleHRCbG9ja0FmdGVyQmxvY2tPYmplY3QiLCJmb2N1c1RleHRCbG9jayIsInNlbGVjdGlvbkNvbGxhcHNlZCIsIm5vZGUiLCJfIiwiYmxvY2tQYXRoIiwic2VsZWN0aW9uIiwiYW5jaG9yIiwiZm9jdXMiLCJkZWxldGluZ0VtcHR5VGV4dEJsb2NrQmVmb3JlQmxvY2tPYmplY3QiLCJjb3JlQmxvY2tPYmplY3RCZWhhdmlvcnMiLCJkZWNvcmF0b3JBZGQiLCJkZWNvcmF0b3JSZW1vdmUiLCJkZWNvcmF0b3IiLCJkZWNvcmF0b3JUb2dnbGUiLCJjb3JlRGVjb3JhdG9yQmVoYXZpb3JzIiwiTUFYX0xJU1RfTEVWRUwiLCJjbGVhckxpc3RPbkJhY2tzcGFjZSIsImZvY3VzU3BhbiIsImxldmVsIiwicHJvcHMiLCJhdCIsInVuaW5kZW50TGlzdE9uQmFja3NwYWNlIiwiY2xlYXJMaXN0T25FbnRlciIsImZvY3VzTGlzdEJsb2NrIiwiaW5kZW50TGlzdE9uVGFiIiwic2VsZWN0ZWRCbG9ja3MiLCJndWFyZHMiLCJzZWxlY3RlZExpc3RCbG9ja3MiLCJmbGF0TWFwIiwiaXNMaXN0QmxvY2siLCJzZWxlY3RlZExpc3RCbG9jayIsIk1hdGgiLCJtaW4iLCJtYXgiLCJ1bmluZGVudExpc3RPblNoaWZ0VGFiIiwiY29yZUxpc3RCZWhhdmlvcnMiLCJzb2Z0UmV0dXJuIiwiY29yZUJlaGF2aW9ycyIsImNvcmVCZWhhdmlvciIsImRlY29yYXRvcnMiLCJibG9ja09iamVjdHMiLCJsaXN0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createGuards: () => (/* binding */ createGuards),\n/* harmony export */   getFirstBlock: () => (/* binding */ getFirstBlock),\n/* harmony export */   getFocusBlock: () => (/* binding */ getFocusBlock),\n/* harmony export */   getFocusBlockObject: () => (/* binding */ getFocusBlockObject),\n/* harmony export */   getFocusChild: () => (/* binding */ getFocusChild),\n/* harmony export */   getFocusListBlock: () => (/* binding */ getFocusListBlock),\n/* harmony export */   getFocusSpan: () => (/* binding */ getFocusSpan),\n/* harmony export */   getFocusTextBlock: () => (/* binding */ getFocusTextBlock),\n/* harmony export */   getLastBlock: () => (/* binding */ getLastBlock),\n/* harmony export */   getNextBlock: () => (/* binding */ getNextBlock),\n/* harmony export */   getPreviousBlock: () => (/* binding */ getPreviousBlock),\n/* harmony export */   getSelectedBlocks: () => (/* binding */ getSelectedBlocks),\n/* harmony export */   getSelectionEndBlock: () => (/* binding */ getSelectionEndBlock),\n/* harmony export */   getSelectionStartBlock: () => (/* binding */ getSelectionStartBlock),\n/* harmony export */   isSelectionCollapsed: () => (/* binding */ isSelectionCollapsed)\n/* harmony export */ });\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n\nfunction createGuards({ schema }) {\n    function isListBlock(block) {\n        return (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextListBlock)(block) && block._type === schema.block.name;\n    }\n    function isTextBlock(block) {\n        return (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(block) && block._type === schema.block.name;\n    }\n    return {\n        isListBlock,\n        isTextBlock\n    };\n}\nconst getFocusBlock = ({ context })=>{\n    const key = context.selection && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block)=>block._key === key) : void 0;\n    return node && key ? {\n        node,\n        path: [\n            {\n                _key: key\n            }\n        ]\n    } : void 0;\n}, getFocusListBlock = ({ context })=>{\n    const guards = createGuards(context), focusBlock = getFocusBlock({\n        context\n    });\n    return focusBlock && guards.isListBlock(focusBlock.node) ? {\n        node: focusBlock.node,\n        path: focusBlock.path\n    } : void 0;\n}, getFocusTextBlock = ({ context })=>{\n    const focusBlock = getFocusBlock({\n        context\n    });\n    return focusBlock && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(focusBlock.node) ? {\n        node: focusBlock.node,\n        path: focusBlock.path\n    } : void 0;\n}, getFocusBlockObject = ({ context })=>{\n    const focusBlock = getFocusBlock({\n        context\n    });\n    return focusBlock && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextTextBlock)(focusBlock.node) ? {\n        node: focusBlock.node,\n        path: focusBlock.path\n    } : void 0;\n}, getFocusChild = ({ context })=>{\n    const focusBlock = getFocusTextBlock({\n        context\n    });\n    if (!focusBlock) return;\n    const key = context.selection && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[2]) ? context.selection.focus.path[2]._key : void 0, node = key ? focusBlock.node.children.find((span)=>span._key === key) : void 0;\n    return node && key ? {\n        node,\n        path: [\n            ...focusBlock.path,\n            \"children\",\n            {\n                _key: key\n            }\n        ]\n    } : void 0;\n}, getFocusSpan = ({ context })=>{\n    const focusChild = getFocusChild({\n        context\n    });\n    return focusChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isPortableTextSpan)(focusChild.node) ? {\n        node: focusChild.node,\n        path: focusChild.path\n    } : void 0;\n}, getFirstBlock = ({ context })=>{\n    const node = context.value[0];\n    return node ? {\n        node,\n        path: [\n            {\n                _key: node._key\n            }\n        ]\n    } : void 0;\n}, getLastBlock = ({ context })=>{\n    const node = context.value[context.value.length - 1] ? context.value[context.value.length - 1] : void 0;\n    return node ? {\n        node,\n        path: [\n            {\n                _key: node._key\n            }\n        ]\n    } : void 0;\n}, getSelectedBlocks = ({ context })=>{\n    if (!context.selection) return [];\n    const selectedBlocks = [], startKey = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, endKey = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0;\n    if (!startKey || !endKey) return selectedBlocks;\n    for (const block of context.value){\n        if (block._key === startKey) {\n            if (selectedBlocks.push({\n                node: block,\n                path: [\n                    {\n                        _key: block._key\n                    }\n                ]\n            }), startKey === endKey) break;\n            continue;\n        }\n        if (block._key === endKey) {\n            selectedBlocks.push({\n                node: block,\n                path: [\n                    {\n                        _key: block._key\n                    }\n                ]\n            });\n            break;\n        }\n        selectedBlocks.length > 0 && selectedBlocks.push({\n            node: block,\n            path: [\n                {\n                    _key: block._key\n                }\n            ]\n        });\n    }\n    return selectedBlocks;\n}, getSelectionStartBlock = ({ context })=>{\n    if (!context.selection) return;\n    const key = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, node = key ? context.value.find((block)=>block._key === key) : void 0;\n    return node && key ? {\n        node,\n        path: [\n            {\n                _key: key\n            }\n        ]\n    } : void 0;\n}, getSelectionEndBlock = ({ context })=>{\n    if (!context.selection) return;\n    const key = context.selection.backward ? (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0 : (0,_sanity_types__WEBPACK_IMPORTED_MODULE_0__.isKeySegment)(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block)=>block._key === key) : void 0;\n    return node && key ? {\n        node,\n        path: [\n            {\n                _key: key\n            }\n        ]\n    } : void 0;\n}, getPreviousBlock = ({ context })=>{\n    let previousBlock;\n    const selectionStartBlock = getSelectionStartBlock({\n        context\n    });\n    if (!selectionStartBlock) return;\n    let foundSelectionStartBlock = !1;\n    for (const block of context.value){\n        if (block._key === selectionStartBlock.node._key) {\n            foundSelectionStartBlock = !0;\n            break;\n        }\n        previousBlock = {\n            node: block,\n            path: [\n                {\n                    _key: block._key\n                }\n            ]\n        };\n    }\n    if (foundSelectionStartBlock && previousBlock) return previousBlock;\n}, getNextBlock = ({ context })=>{\n    let nextBlock;\n    const selectionEndBlock = getSelectionEndBlock({\n        context\n    });\n    if (!selectionEndBlock) return;\n    let foundSelectionEndBlock = !1;\n    for (const block of context.value){\n        if (block._key === selectionEndBlock.node._key) {\n            foundSelectionEndBlock = !0;\n            continue;\n        }\n        if (foundSelectionEndBlock) {\n            nextBlock = {\n                node: block,\n                path: [\n                    {\n                        _key: block._key\n                    }\n                ]\n            };\n            break;\n        }\n    }\n    if (foundSelectionEndBlock && nextBlock) return nextBlock;\n}, isSelectionCollapsed = ({ context })=>JSON.stringify(context.selection?.anchor.path) === JSON.stringify(context.selection?.focus.path) && context.selection?.anchor.offset === context.selection?.focus.offset;\n //# sourceMappingURL=selector.is-selection-collapsed.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtc2VsZWN0aW9uLWNvbGxhcHNlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1IO0FBQ25ILFNBQVNJLGFBQWEsRUFDcEJDLE1BQU0sRUFDUDtJQUNDLFNBQVNDLFlBQVlDLEtBQUs7UUFDeEIsT0FBT1Asc0VBQXVCQSxDQUFDTyxVQUFVQSxNQUFNQyxLQUFLLEtBQUtILE9BQU9FLEtBQUssQ0FBQ0UsSUFBSTtJQUM1RTtJQUNBLFNBQVNDLFlBQVlILEtBQUs7UUFDeEIsT0FBT04sc0VBQXVCQSxDQUFDTSxVQUFVQSxNQUFNQyxLQUFLLEtBQUtILE9BQU9FLEtBQUssQ0FBQ0UsSUFBSTtJQUM1RTtJQUNBLE9BQU87UUFDTEg7UUFDQUk7SUFDRjtBQUNGO0FBQ0EsTUFBTUMsZ0JBQWdCLENBQUMsRUFDckJDLE9BQU8sRUFDUjtJQUNDLE1BQU1DLE1BQU1ELFFBQVFFLFNBQVMsSUFBSVosMkRBQVlBLENBQUNVLFFBQVFFLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUMsRUFBRSxJQUFJSixRQUFRRSxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDLEVBQUUsQ0FBQ0MsSUFBSSxHQUFHLEtBQUssR0FBR0MsT0FBT0wsTUFBTUQsUUFBUU8sS0FBSyxDQUFDQyxJQUFJLENBQUMsQ0FBQ2IsUUFBVUEsTUFBTVUsSUFBSSxLQUFLSixPQUFPLEtBQUs7SUFDdE0sT0FBT0ssUUFBUUwsTUFBTTtRQUNuQks7UUFDQUYsTUFBTTtZQUFDO2dCQUNMQyxNQUFNSjtZQUNSO1NBQUU7SUFDSixJQUFJLEtBQUs7QUFDWCxHQUFHUSxvQkFBb0IsQ0FBQyxFQUN0QlQsT0FBTyxFQUNSO0lBQ0MsTUFBTVUsU0FBU2xCLGFBQWFRLFVBQVVXLGFBQWFaLGNBQWM7UUFDL0RDO0lBQ0Y7SUFDQSxPQUFPVyxjQUFjRCxPQUFPaEIs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QUFJLENBQUNELElBQUksRUFBRTtZQUM5Q2lDLHlCQUF5QixDQUFDO1lBQzFCO1FBQ0Y7UUFDQSxJQUFJQSx3QkFBd0I7WUFDMUJGLFlBQVk7Z0JBQ1Y5QixNQUFNWDtnQkFDTlMsTUFBTTtvQkFBQzt3QkFDTEMsTUFBTVYsTUFBTVUsSUFBSTtvQkFDbEI7aUJBQUU7WUFDSjtZQUNBO1FBQ0Y7SUFDRjtJQUNBLElBQUlpQywwQkFBMEJGLFdBQzVCLE9BQU9BO0FBQ1gsR0FBR0csdUJBQXVCLENBQUMsRUFDekJ2QyxPQUFPLEVBQ1IsR0FBS3dDLEtBQUtDLFNBQVMsQ0FBQ3pDLFFBQVFFLFNBQVMsRUFBRXdCLE9BQU90QixVQUFVb0MsS0FBS0MsU0FBUyxDQUFDekMsUUFBUUUsU0FBUyxFQUFFQyxNQUFNQyxTQUFTSixRQUFRRSxTQUFTLEVBQUV3QixPQUFPZ0IsV0FBVzFDLFFBQVFFLFNBQVMsRUFBRUMsTUFBTXVDO0FBaUJ0SyxDQUNGLDJEQUEyRCIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9fY2h1bmtzLWVzL3NlbGVjdG9yLmlzLXNlbGVjdGlvbi1jb2xsYXBzZWQuanM/MzQ1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BvcnRhYmxlVGV4dExpc3RCbG9jaywgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2ssIGlzS2V5U2VnbWVudCwgaXNQb3J0YWJsZVRleHRTcGFuIH0gZnJvbSBcIkBzYW5pdHkvdHlwZXNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUd1YXJkcyh7XG4gIHNjaGVtYVxufSkge1xuICBmdW5jdGlvbiBpc0xpc3RCbG9jayhibG9jaykge1xuICAgIHJldHVybiBpc1BvcnRhYmxlVGV4dExpc3RCbG9jayhibG9jaykgJiYgYmxvY2suX3R5cGUgPT09IHNjaGVtYS5ibG9jay5uYW1lO1xuICB9XG4gIGZ1bmN0aW9uIGlzVGV4dEJsb2NrKGJsb2NrKSB7XG4gICAgcmV0dXJuIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5fdHlwZSA9PT0gc2NoZW1hLmJsb2NrLm5hbWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpc0xpc3RCbG9jayxcbiAgICBpc1RleHRCbG9ja1xuICB9O1xufVxuY29uc3QgZ2V0Rm9jdXNCbG9jayA9ICh7XG4gIGNvbnRleHRcbn0pID0+IHtcbiAgY29uc3Qga2V5ID0gY29udGV4dC5zZWxlY3Rpb24gJiYgaXNLZXlTZWdtZW50KGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwLCBub2RlID0ga2V5ID8gY29udGV4dC52YWx1ZS5maW5kKChibG9jaykgPT4gYmxvY2suX2tleSA9PT0ga2V5KSA6IHZvaWQgMDtcbiAgcmV0dXJuIG5vZGUgJiYga2V5ID8ge1xuICAgIG5vZGUsXG4gICAgcGF0aDogW3tcbiAgICAgIF9rZXk6IGtleVxuICAgIH1dXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGb2N1c0xpc3RCbG9jayA9ICh7XG4gIGNvbnRleHRcbn0pID0+IHtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNCbG9jayh7XG4gICAgY29udGV4dFxuICB9KTtcbiAgcmV0dXJuIGZvY3VzQmxvY2sgJiYgZ3VhcmRzLmlzTGlzdEJsb2NrKGZvY3VzQmxvY2subm9kZSkgPyB7XG4gICAgbm9kZTogZm9jdXNCbG9jay5ub2RlLFxuICAgIHBhdGg6IGZvY3VzQmxvY2sucGF0aFxuICB9IDogdm9pZCAwO1xufSwgZ2V0Rm9jdXNUZXh0QmxvY2sgPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGNvbnN0IGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKHtcbiAgICBjb250ZXh0XG4gIH0pO1xuICByZXR1cm4gZm9jdXNCbG9jayAmJiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhmb2N1c0Jsb2NrLm5vZGUpID8ge1xuICAgIG5vZGU6IGZvY3VzQmxvY2subm9kZSxcbiAgICBwYXRoOiBmb2N1c0Jsb2NrLnBhdGhcbiAgfSA6IHZvaWQgMDtcbn0sIGdldEZvY3VzQmxvY2tPYmplY3QgPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGNvbnN0IGZvY3VzQmxvY2sgPSBnZXRGb2N1c0Jsb2NrKHtcbiAgICBjb250ZXh0XG4gIH0pO1xuICByZXR1cm4gZm9jdXNCbG9jayAmJiAhaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soZm9jdXNCbG9jay5ub2RlKSA/IHtcbiAgICBub2RlOiBmb2N1c0Jsb2NrLm5vZGUsXG4gICAgcGF0aDogZm9jdXNCbG9jay5wYXRoXG4gIH0gOiB2b2lkIDA7XG59LCBnZXRGb2N1c0NoaWxkID0gKHtcbiAgY29udGV4dFxufSkgPT4ge1xuICBjb25zdCBmb2N1c0Jsb2NrID0gZ2V0Rm9jdXNUZXh0QmxvY2soe1xuICAgIGNvbnRleHRcbiAgfSk7XG4gIGlmICghZm9jdXNCbG9jaylcbiAgICByZXR1cm47XG4gIGNvbnN0IGtleSA9IGNvbnRleHQuc2VsZWN0aW9uICYmIGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzJdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMl0uX2tleSA6IHZvaWQgMCwgbm9kZSA9IGtleSA/IGZvY3VzQmxvY2subm9kZS5jaGlsZHJlbi5maW5kKChzcGFuKSA9PiBzcGFuLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIHJldHVybiBub2RlICYmIGtleSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFsuLi5mb2N1c0Jsb2NrLnBhdGgsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleToga2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn0sIGdldEZvY3VzU3BhbiA9ICh7XG4gIGNvbnRleHRcbn0pID0+IHtcbiAgY29uc3QgZm9jdXNDaGlsZCA9IGdldEZvY3VzQ2hpbGQoe1xuICAgIGNvbnRleHRcbiAgfSk7XG4gIHJldHVybiBmb2N1c0NoaWxkICYmIGlzUG9ydGFibGVUZXh0U3Bhbihmb2N1c0NoaWxkLm5vZGUpID8ge1xuICAgIG5vZGU6IGZvY3VzQ2hpbGQubm9kZSxcbiAgICBwYXRoOiBmb2N1c0NoaWxkLnBhdGhcbiAgfSA6IHZvaWQgMDtcbn0sIGdldEZpcnN0QmxvY2sgPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBjb250ZXh0LnZhbHVlWzBdO1xuICByZXR1cm4gbm9kZSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBub2RlLl9rZXlcbiAgICB9XVxuICB9IDogdm9pZCAwO1xufSwgZ2V0TGFzdEJsb2NrID0gKHtcbiAgY29udGV4dFxufSkgPT4ge1xuICBjb25zdCBub2RlID0gY29udGV4dC52YWx1ZVtjb250ZXh0LnZhbHVlLmxlbmd0aCAtIDFdID8gY29udGV4dC52YWx1ZVtjb250ZXh0LnZhbHVlLmxlbmd0aCAtIDFdIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBub2RlLl9rZXlcbiAgICB9XVxuICB9IDogdm9pZCAwO1xufSwgZ2V0U2VsZWN0ZWRCbG9ja3MgPSAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGlmICghY29udGV4dC5zZWxlY3Rpb24pXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFtdLCBzdGFydEtleSA9IGNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gaXNLZXlTZWdtZW50KGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwIDogaXNLZXlTZWdtZW50KGNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIGVuZEtleSA9IGNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gaXNLZXlTZWdtZW50KGNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdLl9rZXkgOiB2b2lkIDAgOiBpc0tleVNlZ21lbnQoY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXSkgPyBjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdLl9rZXkgOiB2b2lkIDA7XG4gIGlmICghc3RhcnRLZXkgfHwgIWVuZEtleSlcbiAgICByZXR1cm4gc2VsZWN0ZWRCbG9ja3M7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgY29udGV4dC52YWx1ZSkge1xuICAgIGlmIChibG9jay5fa2V5ID09PSBzdGFydEtleSkge1xuICAgICAgaWYgKHNlbGVjdGVkQmxvY2tzLnB1c2goe1xuICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9KSwgc3RhcnRLZXkgPT09IGVuZEtleSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLl9rZXkgPT09IGVuZEtleSkge1xuICAgICAgc2VsZWN0ZWRCbG9ja3MucHVzaCh7XG4gICAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgICBwYXRoOiBbe1xuICAgICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgICAgfV1cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRCbG9ja3MucHVzaCh7XG4gICAgICBub2RlOiBibG9jayxcbiAgICAgIHBhdGg6IFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH1dXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzO1xufSwgZ2V0U2VsZWN0aW9uU3RhcnRCbG9jayA9ICh7XG4gIGNvbnRleHRcbn0pID0+IHtcbiAgaWYgKCFjb250ZXh0LnNlbGVjdGlvbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGtleSA9IGNvbnRleHQuc2VsZWN0aW9uLmJhY2t3YXJkID8gaXNLZXlTZWdtZW50KGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0pID8gY29udGV4dC5zZWxlY3Rpb24uZm9jdXMucGF0aFswXS5fa2V5IDogdm9pZCAwIDogaXNLZXlTZWdtZW50KGNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmFuY2hvci5wYXRoWzBdLl9rZXkgOiB2b2lkIDAsIG5vZGUgPSBrZXkgPyBjb250ZXh0LnZhbHVlLmZpbmQoKGJsb2NrKSA9PiBibG9jay5fa2V5ID09PSBrZXkpIDogdm9pZCAwO1xuICByZXR1cm4gbm9kZSAmJiBrZXkgPyB7XG4gICAgbm9kZSxcbiAgICBwYXRoOiBbe1xuICAgICAgX2tleToga2V5XG4gICAgfV1cbiAgfSA6IHZvaWQgMDtcbn0sIGdldFNlbGVjdGlvbkVuZEJsb2NrID0gKHtcbiAgY29udGV4dFxufSkgPT4ge1xuICBpZiAoIWNvbnRleHQuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3Qga2V5ID0gY29udGV4dC5zZWxlY3Rpb24uYmFja3dhcmQgPyBpc0tleVNlZ21lbnQoY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0pID8gY29udGV4dC5zZWxlY3Rpb24uYW5jaG9yLnBhdGhbMF0uX2tleSA6IHZvaWQgMCA6IGlzS2V5U2VnbWVudChjb250ZXh0LnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdKSA/IGNvbnRleHQuc2VsZWN0aW9uLmZvY3VzLnBhdGhbMF0uX2tleSA6IHZvaWQgMCwgbm9kZSA9IGtleSA/IGNvbnRleHQudmFsdWUuZmluZCgoYmxvY2spID0+IGJsb2NrLl9rZXkgPT09IGtleSkgOiB2b2lkIDA7XG4gIHJldHVybiBub2RlICYmIGtleSA/IHtcbiAgICBub2RlLFxuICAgIHBhdGg6IFt7XG4gICAgICBfa2V5OiBrZXlcbiAgICB9XVxuICB9IDogdm9pZCAwO1xufSwgZ2V0UHJldmlvdXNCbG9jayA9ICh7XG4gIGNvbnRleHRcbn0pID0+IHtcbiAgbGV0IHByZXZpb3VzQmxvY2s7XG4gIGNvbnN0IHNlbGVjdGlvblN0YXJ0QmxvY2sgPSBnZXRTZWxlY3Rpb25TdGFydEJsb2NrKHtcbiAgICBjb250ZXh0XG4gIH0pO1xuICBpZiAoIXNlbGVjdGlvblN0YXJ0QmxvY2spXG4gICAgcmV0dXJuO1xuICBsZXQgZm91bmRTZWxlY3Rpb25TdGFydEJsb2NrID0gITE7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgY29udGV4dC52YWx1ZSkge1xuICAgIGlmIChibG9jay5fa2V5ID09PSBzZWxlY3Rpb25TdGFydEJsb2NrLm5vZGUuX2tleSkge1xuICAgICAgZm91bmRTZWxlY3Rpb25TdGFydEJsb2NrID0gITA7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldmlvdXNCbG9jayA9IHtcbiAgICAgIG5vZGU6IGJsb2NrLFxuICAgICAgcGF0aDogW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV1cbiAgICB9O1xuICB9XG4gIGlmIChmb3VuZFNlbGVjdGlvblN0YXJ0QmxvY2sgJiYgcHJldmlvdXNCbG9jaylcbiAgICByZXR1cm4gcHJldmlvdXNCbG9jaztcbn0sIGdldE5leHRCbG9jayA9ICh7XG4gIGNvbnRleHRcbn0pID0+IHtcbiAgbGV0IG5leHRCbG9jaztcbiAgY29uc3Qgc2VsZWN0aW9uRW5kQmxvY2sgPSBnZXRTZWxlY3Rpb25FbmRCbG9jayh7XG4gICAgY29udGV4dFxuICB9KTtcbiAgaWYgKCFzZWxlY3Rpb25FbmRCbG9jaylcbiAgICByZXR1cm47XG4gIGxldCBmb3VuZFNlbGVjdGlvbkVuZEJsb2NrID0gITE7XG4gIGZvciAoY29uc3QgYmxvY2sgb2YgY29udGV4dC52YWx1ZSkge1xuICAgIGlmIChibG9jay5fa2V5ID09PSBzZWxlY3Rpb25FbmRCbG9jay5ub2RlLl9rZXkpIHtcbiAgICAgIGZvdW5kU2VsZWN0aW9uRW5kQmxvY2sgPSAhMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZm91bmRTZWxlY3Rpb25FbmRCbG9jaykge1xuICAgICAgbmV4dEJsb2NrID0ge1xuICAgICAgICBub2RlOiBibG9jayxcbiAgICAgICAgcGF0aDogW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChmb3VuZFNlbGVjdGlvbkVuZEJsb2NrICYmIG5leHRCbG9jaylcbiAgICByZXR1cm4gbmV4dEJsb2NrO1xufSwgaXNTZWxlY3Rpb25Db2xsYXBzZWQgPSAoe1xuICBjb250ZXh0XG59KSA9PiBKU09OLnN0cmluZ2lmeShjb250ZXh0LnNlbGVjdGlvbj8uYW5jaG9yLnBhdGgpID09PSBKU09OLnN0cmluZ2lmeShjb250ZXh0LnNlbGVjdGlvbj8uZm9jdXMucGF0aCkgJiYgY29udGV4dC5zZWxlY3Rpb24/LmFuY2hvci5vZmZzZXQgPT09IGNvbnRleHQuc2VsZWN0aW9uPy5mb2N1cy5vZmZzZXQ7XG5leHBvcnQge1xuICBjcmVhdGVHdWFyZHMsXG4gIGdldEZpcnN0QmxvY2ssXG4gIGdldEZvY3VzQmxvY2ssXG4gIGdldEZvY3VzQmxvY2tPYmplY3QsXG4gIGdldEZvY3VzQ2hpbGQsXG4gIGdldEZvY3VzTGlzdEJsb2NrLFxuICBnZXRGb2N1c1NwYW4sXG4gIGdldEZvY3VzVGV4dEJsb2NrLFxuICBnZXRMYXN0QmxvY2ssXG4gIGdldE5leHRCbG9jayxcbiAgZ2V0UHJldmlvdXNCbG9jayxcbiAgZ2V0U2VsZWN0ZWRCbG9ja3MsXG4gIGdldFNlbGVjdGlvbkVuZEJsb2NrLFxuICBnZXRTZWxlY3Rpb25TdGFydEJsb2NrLFxuICBpc1NlbGVjdGlvbkNvbGxhcHNlZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbGVjdG9yLmlzLXNlbGVjdGlvbi1jb2xsYXBzZWQuanMubWFwXG4iXSwibmFtZXMiOlsiaXNQb3J0YWJsZVRleHRMaXN0QmxvY2siLCJpc1BvcnRhYmxlVGV4dFRleHRCbG9jayIsImlzS2V5U2VnbWVudCIsImlzUG9ydGFibGVUZXh0U3BhbiIsImNyZWF0ZUd1YXJkcyIsInNjaGVtYSIsImlzTGlzdEJsb2NrIiwiYmxvY2siLCJfdHlwZSIsIm5hbWUiLCJpc1RleHRCbG9jayIsImdldEZvY3VzQmxvY2siLCJjb250ZXh0Iiwia2V5Iiwic2VsZWN0aW9uIiwiZm9jdXMiLCJwYXRoIiwiX2tleSIsIm5vZGUiLCJ2YWx1ZSIsImZpbmQiLCJnZXRGb2N1c0xpc3RCbG9jayIsImd1YXJkcyIsImZvY3VzQmxvY2siLCJnZXRGb2N1c1RleHRCbG9jayIsImdldEZvY3VzQmxvY2tPYmplY3QiLCJnZXRGb2N1c0NoaWxkIiwiY2hpbGRyZW4iLCJzcGFuIiwiZ2V0Rm9jdXNTcGFuIiwiZm9jdXNDaGlsZCIsImdldEZpcnN0QmxvY2siLCJnZXRMYXN0QmxvY2siLCJsZW5ndGgiLCJnZXRTZWxlY3RlZEJsb2NrcyIsInNlbGVjdGVkQmxvY2tzIiwic3RhcnRLZXkiLCJiYWNrd2FyZCIsImFuY2hvciIsImVuZEtleSIsInB1c2giLCJnZXRTZWxlY3Rpb25TdGFydEJsb2NrIiwiZ2V0U2VsZWN0aW9uRW5kQmxvY2siLCJnZXRQcmV2aW91c0Jsb2NrIiwicHJldmlvdXNCbG9jayIsInNlbGVjdGlvblN0YXJ0QmxvY2siLCJmb3VuZFNlbGVjdGlvblN0YXJ0QmxvY2siLCJnZXROZXh0QmxvY2siLCJuZXh0QmxvY2siLCJzZWxlY3Rpb25FbmRCbG9jayIsImZvdW5kU2VsZWN0aW9uRW5kQmxvY2siLCJpc1NlbGVjdGlvbkNvbGxhcHNlZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJvZmZzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/editor/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EditorEventListener: () => (/* binding */ EditorEventListener),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   PortableTextEditable: () => (/* binding */ PortableTextEditable),\n/* harmony export */   PortableTextEditor: () => (/* binding */ PortableTextEditor),\n/* harmony export */   defineSchema: () => (/* binding */ defineSchema),\n/* harmony export */   editorMachine: () => (/* binding */ editorMachine),\n/* harmony export */   keyGenerator: () => (/* binding */ defaultKeyGenerator),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorSelector: () => (/* binding */ useEditorSelector),\n/* harmony export */   usePortableTextEditor: () => (/* binding */ usePortableTextEditor),\n/* harmony export */   usePortableTextEditorSelection: () => (/* binding */ usePortableTextEditorSelection)\n/* harmony export */ });\n/* harmony import */ var _sanity_schema__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @sanity/schema */ \"(ssr)/./node_modules/@sanity/schema/lib/index.mjs\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/./node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var lodash_startcase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.startcase */ \"(ssr)/./node_modules/lodash.startcase/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _xstate_react__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @xstate/react */ \"(ssr)/./node_modules/@xstate/react/dist/xstate-react.development.esm.js\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/./node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/noop.js */ \"(ssr)/./node_modules/lodash/noop.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var slate_react__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! slate-react */ \"(ssr)/./node_modules/@portabletext/editor/node_modules/slate-react/dist/index.es.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-compiler-runtime */ \"(ssr)/./node_modules/@portabletext/editor/node_modules/react-compiler-runtime/dist/index.js\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/styled-components/dist/styled-components.esm.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/./node_modules/lodash/uniq.js\");\n/* harmony import */ var _barrel_optimize_names_Subject_rxjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! __barrel_optimize__?names=Subject!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! use-effect-event */ \"(ssr)/./node_modules/@portabletext/editor/node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! xstate */ \"(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var _portabletext_patches__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @portabletext/patches */ \"(ssr)/./node_modules/@portabletext/patches/dist/index.js\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/./node_modules/lodash/flatten.js\");\n/* harmony import */ var lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/isPlainObject.js */ \"(ssr)/./node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_get_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/get.js */ \"(ssr)/./node_modules/lodash/get.js\");\n/* harmony import */ var lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash/isUndefined.js */ \"(ssr)/./node_modules/lodash/isUndefined.js\");\n/* harmony import */ var lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash/omitBy.js */ \"(ssr)/./node_modules/lodash/omitBy.js\");\n/* harmony import */ var _chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./_chunks-es/selector.is-selection-collapsed.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/selector.is-selection-collapsed.js\");\n/* harmony import */ var _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./_chunks-es/behavior.core.js */ \"(ssr)/./node_modules/@portabletext/editor/lib/_chunks-es/behavior.core.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/./node_modules/get-random-values-esm/index.mjs\");\n/* harmony import */ var _sanity_block_tools__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @sanity/block-tools */ \"(ssr)/./node_modules/@sanity/block-tools/lib/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction createEditorSchema(portableTextType) {\n    if (!portableTextType) throw new Error(\"Parameter 'portabletextType' missing (required)\");\n    const blockType = portableTextType.of?.find(findBlockType);\n    if (!blockType) throw new Error(\"Block type is not defined in this schema (required)\");\n    const childrenField = blockType.fields?.find((field)=>field.name === \"children\");\n    if (!childrenField) throw new Error(\"Children field for block type found in schema (required)\");\n    const ofType = childrenField.type.of;\n    if (!ofType) throw new Error(\"Valid types for block children not found in schema (required)\");\n    const spanType = ofType.find((memberType)=>memberType.name === \"span\");\n    if (!spanType) throw new Error(\"Span type not found in schema (required)\");\n    const inlineObjectTypes = ofType.filter((memberType)=>memberType.name !== \"span\") || [], blockObjectTypes = portableTextType.of?.filter((field)=>field.name !== blockType.name) || [];\n    return {\n        styles: resolveEnabledStyles(blockType),\n        decorators: resolveEnabledDecorators(spanType),\n        lists: resolveEnabledListItems(blockType),\n        block: blockType,\n        span: spanType,\n        portableText: portableTextType,\n        inlineObjects: inlineObjectTypes,\n        blockObjects: blockObjectTypes,\n        annotations: spanType.annotations\n    };\n}\nfunction resolveEnabledStyles(blockType) {\n    const styleField = blockType.fields?.find((btField)=>btField.name === \"style\");\n    if (!styleField) throw new Error(\"A field with name 'style' is not defined in the block type (required).\");\n    const textStyles = styleField.type.options?.list && styleField.type.options.list?.filter((style)=>style.value);\n    if (!textStyles || textStyles.length === 0) throw new Error(\"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\");\n    return textStyles;\n}\nfunction resolveEnabledDecorators(spanType) {\n    return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n    const listField = blockType.fields?.find((btField)=>btField.name === \"listItem\");\n    if (!listField) throw new Error(\"A field with name 'listItem' is not defined in the block type (required).\");\n    const listItems = listField.type.options?.list && listField.type.options.list.filter((list)=>list.value);\n    if (!listItems) throw new Error(\"The list field need at least to be an empty array\");\n    return listItems;\n}\nfunction findBlockType(type) {\n    return type.type ? findBlockType(type.type) : type.name === \"block\" ? type : null;\n}\nfunction defineSchema(definition) {\n    return definition;\n}\nfunction compileSchemaDefinition(definition) {\n    const blockObjects = definition?.blockObjects?.map((blockObject)=>(0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.defineType)({\n            type: \"object\",\n            // Very naive way to work around `SanitySchema.compile` adding default\n            // fields to objects with the name `image`\n            name: blockObject.name === \"image\" ? \"tmp-image\" : blockObject.name,\n            title: blockObject.title,\n            fields: []\n        })) ?? [], inlineObjects = definition?.inlineObjects?.map((inlineObject)=>(0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.defineType)({\n            type: \"object\",\n            name: inlineObject.name,\n            title: inlineObject.title,\n            fields: []\n        })) ?? [], portableTextSchema = (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.defineField)({\n        type: \"array\",\n        name: \"portable-text\",\n        of: [\n            ...blockObjects.map((blockObject)=>({\n                    type: blockObject.name\n                })),\n            {\n                type: \"block\",\n                name: \"block\",\n                of: inlineObjects.map((inlineObject)=>({\n                        type: inlineObject.name\n                    })),\n                marks: {\n                    decorators: definition?.decorators?.map((decorator)=>({\n                            title: decorator.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(decorator.name),\n                            value: decorator.name\n                        })) ?? [],\n                    annotations: definition?.annotations?.map((annotation)=>({\n                            name: annotation.name,\n                            type: \"object\",\n                            title: annotation.title\n                        })) ?? []\n                },\n                lists: definition?.lists?.map((list)=>({\n                        value: list.name,\n                        title: list.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(list.name)\n                    })) ?? [],\n                styles: definition?.styles?.map((style)=>({\n                        value: style.name,\n                        title: style.title ?? lodash_startcase__WEBPACK_IMPORTED_MODULE_0__(style.name)\n                    })) ?? []\n            }\n        ]\n    }), schema = _sanity_schema__WEBPACK_IMPORTED_MODULE_14__.Schema.compile({\n        types: [\n            portableTextSchema,\n            ...blockObjects,\n            ...inlineObjects\n        ]\n    }).get(\"portable-text\"), pteSchema = createEditorSchema(schema);\n    return {\n        ...pteSchema,\n        blockObjects: pteSchema.blockObjects.map((blockObject)=>blockObject.name === \"tmp-image\" ? {\n                ...blockObject,\n                name: \"image\",\n                type: {\n                    ...blockObject.type,\n                    name: \"image\"\n                }\n            } : blockObject)\n    };\n}\nconst rootName = \"sanity-pte:\";\ndebug__WEBPACK_IMPORTED_MODULE_5__(rootName);\nfunction debugWithName(name) {\n    const namespace = `${rootName}${name}`;\n    return debug__WEBPACK_IMPORTED_MODULE_5__ && debug__WEBPACK_IMPORTED_MODULE_5__.enabled(namespace) ? debug__WEBPACK_IMPORTED_MODULE_5__(namespace) : debug__WEBPACK_IMPORTED_MODULE_5__(rootName);\n}\nfunction createKeyedPath(point, value, types) {\n    const blockPath = [\n        point.path[0]\n    ];\n    if (!value) return null;\n    const block = value[blockPath[0]];\n    if (!block) return null;\n    const keyedBlockPath = [\n        {\n            _key: block._key\n        }\n    ];\n    if (block._type !== types.block.name) return keyedBlockPath;\n    let keyedChildPath;\n    const childPath = point.path.slice(0, 2), child = Array.isArray(block.children) && block.children[childPath[1]];\n    return child && (keyedChildPath = [\n        \"children\",\n        {\n            _key: child._key\n        }\n    ]), keyedChildPath ? [\n        ...keyedBlockPath,\n        ...keyedChildPath\n    ] : keyedBlockPath;\n}\nfunction toSlatePath(path, editor) {\n    if (!editor) return [];\n    const [block, blockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        at: [],\n        match: (n)=>(0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isKeySegment)(path[0]) && n._key === path[0]._key\n    }))[0] || [\n        void 0,\n        void 0\n    ];\n    if (!block || !slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block)) return [];\n    if (editor.isVoid(block)) return [\n        blockPath[0],\n        0\n    ];\n    const childPath = [\n        path[2]\n    ], childIndex = block.children.findIndex((child)=>lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__([\n            {\n                _key: child._key\n            }\n        ], childPath));\n    if (childIndex >= 0 && block.children[childIndex]) {\n        const child = block.children[childIndex];\n        return slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(child) && editor.isVoid(child) ? blockPath.concat(childIndex).concat(0) : blockPath.concat(childIndex);\n    }\n    return [\n        blockPath[0],\n        0\n    ];\n}\nfunction toPortableTextRange(value, range, types) {\n    if (!range) return null;\n    let anchor = null, focus = null;\n    const anchorPath = range.anchor && createKeyedPath(range.anchor, value, types);\n    anchorPath && range.anchor && (anchor = {\n        path: anchorPath,\n        offset: range.anchor.offset\n    });\n    const focusPath = range.focus && createKeyedPath(range.focus, value, types);\n    focusPath && range.focus && (focus = {\n        path: focusPath,\n        offset: range.focus.offset\n    });\n    const backward = !!(slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(range) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(range));\n    return anchor && focus ? {\n        anchor,\n        focus,\n        backward\n    } : null;\n}\nfunction toSlateRange(selection, editor) {\n    if (!selection || !editor) return null;\n    const anchor = {\n        path: toSlatePath(selection.anchor.path, editor),\n        offset: selection.anchor.offset\n    }, focus = {\n        path: toSlatePath(selection.focus.path, editor),\n        offset: selection.focus.offset\n    };\n    return focus.path.length === 0 || anchor.path.length === 0 ? null : anchor && focus ? {\n        anchor,\n        focus\n    } : null;\n}\nfunction moveRangeByOperation(range, operation) {\n    const anchor = slate__WEBPACK_IMPORTED_MODULE_15__.Point.transform(range.anchor, operation), focus = slate__WEBPACK_IMPORTED_MODULE_15__.Point.transform(range.focus, operation);\n    return anchor === null || focus === null ? null : slate__WEBPACK_IMPORTED_MODULE_15__.Point.equals(anchor, range.anchor) && slate__WEBPACK_IMPORTED_MODULE_15__.Point.equals(focus, range.focus) ? range : {\n        anchor,\n        focus\n    };\n}\nfunction normalizePoint(point, value) {\n    if (!point || !value) return null;\n    const newPath = [];\n    let newOffset = point.offset || 0;\n    const blockKey = typeof point.path[0] == \"object\" && \"_key\" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == \"object\" && \"_key\" in point.path[2] && point.path[2]._key, block = value.find((blk)=>blk._key === blockKey);\n    if (block) newPath.push({\n        _key: block._key\n    });\n    else return null;\n    if (block && point.path[1] === \"children\") {\n        if (!block.children || Array.isArray(block.children) && block.children.length === 0) return null;\n        const child = Array.isArray(block.children) && block.children.find((cld)=>cld._key === childKey);\n        if (child) newPath.push(\"children\"), newPath.push({\n            _key: child._key\n        }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;\n        else return null;\n    }\n    return {\n        path: newPath,\n        offset: newOffset\n    };\n}\nfunction normalizeSelection(selection, value) {\n    if (!selection || !value || value.length === 0) return null;\n    let newAnchor = null, newFocus = null;\n    const { anchor, focus } = selection;\n    return anchor && value.find((blk)=>lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n            _key: blk._key\n        }, anchor.path[0])) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk)=>lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n            _key: blk._key\n        }, focus.path[0])) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {\n        anchor: newAnchor,\n        focus: newFocus,\n        backward: selection.backward\n    } : null;\n}\nconst VOID_CHILD_KEY = \"void-child\";\nfunction keepObjectEquality(object, keyMap) {\n    const value = keyMap[object._key];\n    return value && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(object, value) ? value : (keyMap[object._key] = object, object);\n}\nfunction toSlateValue(value, { schemaTypes }, keyMap = {}) {\n    return value && Array.isArray(value) ? value.map((block)=>{\n        const { _type, _key, ...rest } = block, voidChildren = [\n            {\n                _key: VOID_CHILD_KEY,\n                _type: \"span\",\n                text: \"\",\n                marks: []\n            }\n        ];\n        if (block && block._type === schemaTypes.block.name) {\n            const textBlock = block;\n            let hasInlines = !1;\n            const hasMissingStyle = typeof textBlock.style > \"u\", hasMissingMarkDefs = typeof textBlock.markDefs > \"u\", hasMissingChildren = typeof textBlock.children > \"u\", children = (textBlock.children || []).map((child)=>{\n                const { _type: cType, _key: cKey, ...cRest } = child;\n                return cType !== \"span\" ? (hasInlines = !0, keepObjectEquality({\n                    _type: cType,\n                    _key: cKey,\n                    children: voidChildren,\n                    value: cRest,\n                    __inline: !0\n                }, keyMap)) : child;\n            });\n            return !hasMissingStyle && !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) ? block : (hasMissingStyle && (rest.style = schemaTypes.styles[0].value), keepObjectEquality({\n                _type,\n                _key,\n                ...rest,\n                children\n            }, keyMap));\n        }\n        return keepObjectEquality({\n            _type,\n            _key,\n            children: voidChildren,\n            value: rest\n        }, keyMap);\n    }) : [];\n}\nfunction fromSlateValue(value, textBlockType, keyMap = {}) {\n    return value.map((block)=>{\n        const { _key, _type } = block;\n        if (!_key || !_type) throw new Error(\"Not a valid block\");\n        if (_type === textBlockType && \"children\" in block && Array.isArray(block.children) && _key) {\n            let hasInlines = !1;\n            const children = block.children.map((child)=>{\n                const { _type: _cType } = child;\n                if (\"value\" in child && _cType !== \"span\") {\n                    hasInlines = !0;\n                    const { value: v, _key: k, _type: t, __inline: _i, children: _c, ...rest } = child;\n                    return keepObjectEquality({\n                        ...rest,\n                        ...v,\n                        _key: k,\n                        _type: t\n                    }, keyMap);\n                }\n                return child;\n            });\n            return hasInlines ? keepObjectEquality({\n                ...block,\n                children,\n                _key,\n                _type\n            }, keyMap) : block;\n        }\n        const blockValue = \"value\" in block && block.value;\n        return keepObjectEquality({\n            _key,\n            _type,\n            ...typeof blockValue == \"object\" ? blockValue : {}\n        }, keyMap);\n    });\n}\nfunction isEqualToEmptyEditor(children, schemaTypes) {\n    return children === void 0 || children && Array.isArray(children) && children.length === 0 || children && Array.isArray(children) && children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(children[0]) && children[0]._type === schemaTypes.block.name && \"style\" in children[0] && children[0].style === schemaTypes.styles[0].value && !(\"listItem\" in children[0]) && Array.isArray(children[0].children) && children[0].children.length === 1 && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(children[0].children[0]) && children[0].children[0]._type === \"span\" && !children[0].children[0].marks?.join(\"\") && children[0].children[0].text === \"\";\n}\nconst IS_PROCESSING_REMOTE_CHANGES = /* @__PURE__ */ new WeakMap(), IS_DRAGGING = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_ELEMENT = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_ELEMENT_TARGET = /* @__PURE__ */ new WeakMap(), IS_DRAGGING_BLOCK_TARGET_POSITION = /* @__PURE__ */ new WeakMap(), KEY_TO_SLATE_ELEMENT = /* @__PURE__ */ new WeakMap(), KEY_TO_VALUE_ELEMENT = /* @__PURE__ */ new WeakMap(), SLATE_TO_PORTABLE_TEXT_RANGE = /* @__PURE__ */ new WeakMap(), DefaultObject = (props)=>{\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(4);\n    let t0;\n    $[0] !== props.value ? (t0 = JSON.stringify(props.value, null, 2), $[0] = props.value, $[1] = t0) : t0 = $[1];\n    let t1;\n    return $[2] !== t0 ? (t1 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"pre\", {\n            children: t0\n        })\n    }), $[2] = t0, $[3] = t1) : t1 = $[3], t1;\n};\nDefaultObject.displayName = \"DefaultObject\";\nconst DefaultBlockObject = styled_components__WEBPACK_IMPORTED_MODULE_16__.styled.div`\n  user-select: none;\n  border: ${(props)=>props.selected ? \"1px solid blue\" : \"1px solid transparent\"};\n`;\nstyled_components__WEBPACK_IMPORTED_MODULE_16__.styled.span`\n  background: #999;\n  border: ${(props)=>props.selected ? \"1px solid blue\" : \"1px solid transparent\"};\n`;\nconst DefaultListItem = styled_components__WEBPACK_IMPORTED_MODULE_16__.styled.div`\n  &.pt-list-item {\n    width: fit-content;\n    position: relative;\n    display: block;\n\n    /* Important 'transform' in order to force refresh the ::before and ::after rules\n      in Webkit: https://stackoverflow.com/a/21947628/831480\n    */\n    transform: translateZ(0);\n    margin-left: ${(props)=>getLeftPositionForListLevel(props.listLevel)};\n  }\n  &.pt-list-item > .pt-list-item-inner {\n    display: flex;\n    margin: 0;\n    padding: 0;\n    &:before {\n      justify-content: flex-start;\n      vertical-align: top;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner:before {\n      content: '${(props)=>getContentForListLevelAndStyle(props.listLevel, props.listStyle)}';\n      font-size: 0.4375rem; /* 7px */\n      line-height: 1.5rem; /* Same as body text */\n      /* Optical alignment */\n      position: relative;\n    }\n  }\n  &.pt-list-item-bullet > .pt-list-item-inner {\n    &:before {\n      min-width: 1.5rem; /* Make sure space between bullet and text never shrinks */\n    }\n  }\n  &.pt-list-item-number {\n    counter-increment: ${(props)=>getCounterIncrementForListLevel(props.listLevel)};\n    counter-reset: ${(props)=>getCounterResetForListLevel(props.listLevel)};\n  }\n  & + :not(.pt-list-item-number) {\n    counter-reset: listItemNumber;\n  }\n  &.pt-list-item-number > .pt-list-item-inner:before {\n    content: ${(props)=>getCounterContentForListLevel(props.listLevel)};\n    min-width: 1.5rem; /* Make sure space between number and text never shrinks */\n    /* Optical alignment */\n    position: relative;\n    top: 1px;\n  }\n`, DefaultListItemInner = styled_components__WEBPACK_IMPORTED_MODULE_16__.styled.div``;\nfunction getLeftPositionForListLevel(level) {\n    switch(Number(level)){\n        case 1:\n            return \"1.5em\";\n        case 2:\n            return \"3em\";\n        case 3:\n            return \"4.5em\";\n        case 4:\n            return \"6em\";\n        case 5:\n            return \"7.5em\";\n        case 6:\n            return \"9em\";\n        case 7:\n            return \"10.5em\";\n        case 8:\n            return \"12em\";\n        case 9:\n            return \"13.5em\";\n        case 10:\n            return \"15em\";\n        default:\n            return \"0em\";\n    }\n}\nconst bullets = [\n    \"\",\n    \"\",\n    \"\"\n];\nfunction getContentForListLevelAndStyle(level, style) {\n    const normalizedLevel = (level - 1) % 3;\n    return style === \"bullet\" ? bullets[normalizedLevel] : \"*\";\n}\nfunction getCounterIncrementForListLevel(level) {\n    switch(level){\n        case 1:\n            return \"listItemNumber\";\n        case 2:\n            return \"listItemAlpha\";\n        case 3:\n            return \"listItemRoman\";\n        case 4:\n            return \"listItemNumberNext\";\n        case 5:\n            return \"listItemLetterNext\";\n        case 6:\n            return \"listItemRomanNext\";\n        case 7:\n            return \"listItemNumberNextNext\";\n        case 8:\n            return \"listItemAlphaNextNext\";\n        case 9:\n            return \"listItemRomanNextNext\";\n        default:\n            return \"listItemNumberNextNextNext\";\n    }\n}\nfunction getCounterResetForListLevel(level) {\n    switch(level){\n        case 1:\n            return \"listItemAlpha\";\n        case 2:\n            return \"listItemRoman\";\n        case 3:\n            return \"listItemNumberNext\";\n        case 4:\n            return \"listItemLetterNext\";\n        case 5:\n            return \"listItemRomanNext\";\n        case 6:\n            return \"listItemNumberNextNext\";\n        case 7:\n            return \"listItemAlphaNextNext\";\n        case 8:\n            return \"listItemRomanNextNext\";\n        case 9:\n            return \"listItemNumberNextNextNext\";\n        default:\n            return \"listItemNumberNextNextNext\";\n    }\n}\nfunction getCounterContentForListLevel(level) {\n    switch(level){\n        case 1:\n            return \"counter(listItemNumber) '. '\";\n        case 2:\n            return \"counter(listItemAlpha, lower-alpha) '. '\";\n        case 3:\n            return \"counter(listItemRoman, lower-roman) '. '\";\n        case 4:\n            return \"counter(listItemNumberNext) '. '\";\n        case 5:\n            return \"counter(listItemLetterNext, lower-alpha) '. '\";\n        case 6:\n            return \"counter(listItemRomanNext, lower-roman) '. '\";\n        case 7:\n            return \"counter(listItemNumberNextNext) '. '\";\n        case 8:\n            return \"counter(listItemAlphaNextNext, lower-alpha) '. '\";\n        case 9:\n            return \"counter(listItemRomanNextNext, lower-roman) '. '\";\n        default:\n            return \"counter(listItemNumberNextNextNext) '. '\";\n    }\n}\nconst debug$k = debugWithName(\"components:DraggableBlock\"), DraggableBlock = (t0)=>{\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(51), { children, element, readOnly, blockRef } = t0, editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSlateStatic)(), dragGhostRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(void 0), [isDragOver, setIsDragOver] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1);\n    let t1, t2;\n    $[0] !== editor || $[1] !== element ? (t2 = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isVoid(editor, element), $[0] = editor, $[1] = element, $[2] = t2) : t2 = $[2], t1 = t2;\n    const isVoid = t1;\n    let t3, t4;\n    $[3] !== editor || $[4] !== element ? (t4 = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isInline(editor, element), $[3] = editor, $[4] = element, $[5] = t4) : t4 = $[5], t3 = t4;\n    const isInline = t3, [blockElement, setBlockElement] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(null);\n    let t5, t6;\n    $[6] !== blockRef || $[7] !== editor || $[8] !== element ? (t5 = ()=>setBlockElement(blockRef ? blockRef.current : slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMNode(editor, element)), t6 = [\n        editor,\n        element,\n        blockRef\n    ], $[6] = blockRef, $[7] = editor, $[8] = element, $[9] = t5, $[10] = t6) : (t5 = $[9], t6 = $[10]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t5, t6);\n    let t7;\n    $[11] !== blockElement || $[12] !== editor || $[13] !== element ? (t7 = (event)=>{\n        const isMyDragOver = IS_DRAGGING_BLOCK_ELEMENT.get(editor);\n        if (!isMyDragOver || !blockElement) return;\n        event.preventDefault(), event.dataTransfer.dropEffect = \"move\", IS_DRAGGING_ELEMENT_TARGET.set(editor, element);\n        const elementRect = blockElement.getBoundingClientRect(), offset = elementRect.top, height = elementRect.height, Y = event.pageY, loc = Math.abs(offset - Y);\n        if (element === editor.children[0] || (loc < height / 2 ? IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, \"top\") : IS_DRAGGING_BLOCK_TARGET_POSITION.set(editor, \"bottom\")), isMyDragOver === element) {\n            event.dataTransfer.dropEffect = \"none\";\n            return;\n        }\n        setIsDragOver(!0);\n    }, $[11] = blockElement, $[12] = editor, $[13] = element, $[14] = t7) : t7 = $[14];\n    const handleDragOver = t7;\n    let t8;\n    $[15] === Symbol.for(\"react.memo_cache_sentinel\") ? (t8 = ()=>{\n        setIsDragOver(!1);\n    }, $[15] = t8) : t8 = $[15];\n    const handleDragLeave = t8;\n    let t9;\n    $[16] !== editor || $[17] !== element ? (t9 = (event_0)=>{\n        const targetBlock = IS_DRAGGING_ELEMENT_TARGET.get(editor);\n        if (targetBlock) {\n            IS_DRAGGING.set(editor, !1), event_0.preventDefault(), event_0.stopPropagation(), IS_DRAGGING_ELEMENT_TARGET.delete(editor), dragGhostRef.current && (debug$k(\"Removing drag ghost\"), document.body.removeChild(dragGhostRef.current));\n            const dragPosition = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor);\n            IS_DRAGGING_BLOCK_TARGET_POSITION.delete(editor);\n            let targetPath = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.findPath(editor, targetBlock);\n            const myPath = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.findPath(editor, element), isBefore = slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(myPath, targetPath);\n            if (dragPosition === \"bottom\" && !isBefore) {\n                if (targetPath[0] >= editor.children.length - 1) {\n                    debug$k(\"target is already at the bottom, not moving\");\n                    return;\n                }\n                const originalPath = targetPath;\n                targetPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(targetPath), debug$k(`Adjusting targetPath from ${JSON.stringify(originalPath)} to ${JSON.stringify(targetPath)}`);\n            }\n            if (dragPosition === \"top\" && isBefore && targetPath[0] !== editor.children.length - 1) {\n                const originalPath_0 = targetPath;\n                targetPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.previous(targetPath), debug$k(`Adjusting targetPath from ${JSON.stringify(originalPath_0)} to ${JSON.stringify(targetPath)}`);\n            }\n            if (slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(targetPath, myPath)) {\n                event_0.preventDefault(), debug$k(\"targetPath and myPath is the same, not moving\");\n                return;\n            }\n            debug$k(`Moving element ${element._key} from path ${JSON.stringify(myPath)} to ${JSON.stringify(targetPath)} (${dragPosition})`), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(editor, {\n                at: myPath,\n                to: targetPath\n            }), editor.onChange();\n            return;\n        }\n        debug$k(\"No target element, not doing anything\");\n    }, $[16] = editor, $[17] = element, $[18] = t9) : t9 = $[18];\n    const handleDragEnd = t9;\n    let t10;\n    $[19] !== editor || $[20] !== element ? (t10 = (event_1)=>{\n        IS_DRAGGING_BLOCK_ELEMENT.get(editor) && (debug$k(\"On drop (prevented)\", element), event_1.preventDefault(), event_1.stopPropagation(), setIsDragOver(!1));\n    }, $[19] = editor, $[20] = element, $[21] = t10) : t10 = $[21];\n    const handleDrop = t10;\n    let t11;\n    $[22] !== editor || $[23] !== element || $[24] !== isVoid ? (t11 = (event_2)=>{\n        if (!isVoid) {\n            IS_DRAGGING_BLOCK_ELEMENT.delete(editor);\n            return;\n        }\n        IS_DRAGGING.set(editor, !0), IS_DRAGGING_BLOCK_ELEMENT.set(editor, element), event_2.stopPropagation();\n        const target = event_2.target;\n        target instanceof HTMLElement && (target.style.opacity = \"1\");\n    }, $[22] = editor, $[23] = element, $[24] = isVoid, $[25] = t11) : t11 = $[25];\n    const handleDrag = t11;\n    let t12;\n    $[26] !== blockElement || $[27] !== editor || $[28] !== handleDrag || $[29] !== isInline || $[30] !== isVoid ? (t12 = (event_3)=>{\n        if (!isVoid || isInline) {\n            debug$k(\"Not dragging block\"), IS_DRAGGING_BLOCK_ELEMENT.delete(editor), IS_DRAGGING.set(editor, !1);\n            return;\n        }\n        if (debug$k(\"Drag start\"), IS_DRAGGING.set(editor, !0), event_3.dataTransfer && (event_3.dataTransfer.setData(\"application/portable-text\", \"something\"), event_3.dataTransfer.effectAllowed = \"move\"), blockElement && blockElement instanceof HTMLElement) {\n            let dragGhost = blockElement.cloneNode(!0);\n            const customGhost = dragGhost.querySelector(\"[data-pt-drag-ghost-element]\");\n            if (customGhost && (dragGhost = customGhost), dragGhost.setAttribute(\"data-dragged\", \"\"), document.body) {\n                dragGhostRef.current = dragGhost, dragGhost.style.position = \"absolute\", dragGhost.style.left = \"-99999px\", dragGhost.style.boxSizing = \"border-box\", document.body.appendChild(dragGhost);\n                const rect = blockElement.getBoundingClientRect(), x = event_3.clientX - rect.left, y = event_3.clientY - rect.top;\n                dragGhost.style.width = `${rect.width}px`, dragGhost.style.height = `${rect.height}px`, event_3.dataTransfer.setDragImage(dragGhost, x, y);\n            }\n        }\n        handleDrag(event_3);\n    }, $[26] = blockElement, $[27] = editor, $[28] = handleDrag, $[29] = isInline, $[30] = isVoid, $[31] = t12) : t12 = $[31];\n    const handleDragStart = t12;\n    let t13;\n    $[32] !== editor || $[33] !== isDragOver ? (t13 = isDragOver && editor.children[0] === IS_DRAGGING_ELEMENT_TARGET.get(editor), $[32] = editor, $[33] = isDragOver, $[34] = t13) : t13 = $[34];\n    const isDraggingOverFirstBlock = t13;\n    let t14;\n    $[35] !== editor || $[36] !== isDragOver ? (t14 = isDragOver && editor.children[editor.children.length - 1] === IS_DRAGGING_ELEMENT_TARGET.get(editor), $[35] = editor, $[36] = isDragOver, $[37] = t14) : t14 = $[37];\n    const isDraggingOverLastBlock = t14, dragPosition_0 = IS_DRAGGING_BLOCK_TARGET_POSITION.get(editor), isDraggingOverTop = isDraggingOverFirstBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition_0 === \"top\", isDraggingOverBottom = isDraggingOverLastBlock || isDragOver && !isDraggingOverFirstBlock && !isDraggingOverLastBlock && dragPosition_0 === \"bottom\";\n    let t15, t16;\n    $[38] === Symbol.for(\"react.memo_cache_sentinel\") ? (t16 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        className: \"pt-drop-indicator\",\n        style: {\n            position: \"absolute\",\n            width: \"100%\",\n            height: 1,\n            borderBottom: \"1px solid currentColor\",\n            zIndex: 5\n        }\n    }), $[38] = t16) : t16 = $[38], t15 = t16;\n    const dropIndicator = t15;\n    if (readOnly) {\n        let t172;\n        return $[39] !== children ? (t172 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n            children\n        }), $[39] = children, $[40] = t172) : t172 = $[40], t172;\n    }\n    const t17 = isDraggingOverTop && dropIndicator, t18 = isDraggingOverBottom && dropIndicator;\n    let t19;\n    return $[41] !== children || $[42] !== handleDrag || $[43] !== handleDragEnd || $[44] !== handleDragOver || $[45] !== handleDragStart || $[46] !== handleDrop || $[47] !== isVoid || $[48] !== t17 || $[49] !== t18 ? (t19 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", {\n        draggable: isVoid,\n        onDragStart: handleDragStart,\n        onDrag: handleDrag,\n        onDragOver: handleDragOver,\n        onDragLeave: handleDragLeave,\n        onDragEnd: handleDragEnd,\n        onDrop: handleDrop,\n        children: [\n            t17,\n            children,\n            t18\n        ]\n    }), $[41] = children, $[42] = handleDrag, $[43] = handleDragEnd, $[44] = handleDragOver, $[45] = handleDragStart, $[46] = handleDrop, $[47] = isVoid, $[48] = t17, $[49] = t18, $[50] = t19) : t19 = $[50], t19;\n};\nDraggableBlock.displayName = \"DraggableBlock\";\ndebugWithName(\"components:Element\");\nconst EMPTY_ANNOTATIONS = [], inlineBlockStyle = {\n    display: \"inline-block\"\n}, Element = ({ attributes, children, element, schemaTypes, readOnly, renderBlock, renderChild, renderListItem, renderStyle, spellCheck })=>{\n    const editor = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSlateStatic)(), selected = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSelected)(), blockRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), inlineBlockObjectRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), focused = selected && editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection) || !1, value = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>fromSlateValue([\n            element\n        ], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0], [\n        editor,\n        element,\n        schemaTypes.block.name\n    ]);\n    let renderedBlock = children, className;\n    const blockPath = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>[\n            {\n                _key: element._key\n            }\n        ], [\n        element\n    ]);\n    if (typeof element._type != \"string\") throw new Error(\"Expected element to have a _type property\");\n    if (typeof element._key != \"string\") throw new Error(\"Expected element to have a _key property\");\n    if (editor.isInline(element)) {\n        const path = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.findPath(editor, element), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n            depth: 1\n        }), schemaType = schemaTypes.inlineObjects.find((_type)=>_type.name === element._type);\n        if (!schemaType) throw new Error(\"Could not find type for inline block element\");\n        if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block)) {\n            const elmPath = [\n                {\n                    _key: block._key\n                },\n                \"children\",\n                {\n                    _key: element._key\n                }\n            ];\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", {\n                ...attributes,\n                children: [\n                    children,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"span\", {\n                        draggable: !readOnly,\n                        className: \"pt-inline-object\",\n                        \"data-testid\": \"pt-inline-object\",\n                        ref: inlineBlockObjectRef,\n                        style: inlineBlockStyle,\n                        contentEditable: !1,\n                        children: [\n                            renderChild && renderChild({\n                                annotations: EMPTY_ANNOTATIONS,\n                                // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, {\n                                    value\n                                }),\n                                editorElementRef: inlineBlockObjectRef,\n                                focused,\n                                path: elmPath,\n                                schemaType,\n                                selected,\n                                type: schemaType,\n                                value\n                            }),\n                            !renderChild && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, {\n                                value\n                            })\n                        ]\n                    }, element._key)\n                ]\n            });\n        }\n        throw new Error(\"Block not found!\");\n    }\n    if (element._type === schemaTypes.block.name) {\n        className = \"pt-block pt-text-block\";\n        const isListItem = \"listItem\" in element, style = \"style\" in element && element.style || \"normal\";\n        className = `pt-block pt-text-block pt-text-block-style-${style}`;\n        const blockStyleType = schemaTypes.styles.find((item)=>item.value === style);\n        renderStyle && blockStyleType && (renderedBlock = renderStyle({\n            block: element,\n            children,\n            focused,\n            selected,\n            value: style,\n            path: blockPath,\n            schemaType: blockStyleType,\n            editorElementRef: blockRef\n        }));\n        let level;\n        if (isListItem && (typeof element.level == \"number\" && (level = element.level), className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`), editor.isListBlock(value) && isListItem && element.listItem) {\n            const listType = schemaTypes.lists.find((item_0)=>item_0.value === element.listItem);\n            renderListItem && listType ? renderedBlock = renderListItem({\n                block: value,\n                children: renderedBlock,\n                focused,\n                selected,\n                value: element.listItem,\n                path: blockPath,\n                schemaType: listType,\n                level: value.level || 1,\n                editorElementRef: blockRef\n            }) : renderedBlock = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultListItem, {\n                listStyle: value.listItem || schemaTypes.lists[0].value,\n                listLevel: value.level || 1,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultListItemInner, {\n                    children: renderedBlock\n                })\n            });\n        }\n        const renderProps = Object.defineProperty({\n            children: renderedBlock,\n            editorElementRef: blockRef,\n            focused,\n            level,\n            listItem: isListItem ? element.listItem : void 0,\n            path: blockPath,\n            selected,\n            style,\n            schemaType: schemaTypes.block,\n            value\n        }, \"type\", {\n            enumerable: !1,\n            get () {\n                return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.block;\n            }\n        }), propsOrDefaultRendered = renderBlock ? renderBlock(renderProps) : children;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n            ...attributes,\n            className,\n            spellCheck,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DraggableBlock, {\n                element,\n                readOnly,\n                blockRef,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n                    ref: blockRef,\n                    children: propsOrDefaultRendered\n                })\n            })\n        }, element._key);\n    }\n    const schemaType_0 = schemaTypes.blockObjects.find((_type_0)=>_type_0.name === element._type);\n    if (!schemaType_0) throw new Error(`Could not find schema type for block element of _type ${element._type}`);\n    className = \"pt-block pt-object-block\";\n    const block_0 = fromSlateValue([\n        element\n    ], schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n    let renderedBlockFromProps;\n    if (renderBlock) {\n        const _props = Object.defineProperty({\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, {\n                value\n            }),\n            editorElementRef: blockRef,\n            focused,\n            path: blockPath,\n            schemaType: schemaType_0,\n            selected,\n            value: block_0\n        }, \"type\", {\n            enumerable: !1,\n            get () {\n                return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType_0;\n            }\n        });\n        renderedBlockFromProps = renderBlock(_props);\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", {\n        ...attributes,\n        className,\n        children: [\n            children,\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(DraggableBlock, {\n                element,\n                readOnly,\n                blockRef,\n                children: [\n                    renderedBlockFromProps && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n                        ref: blockRef,\n                        contentEditable: !1,\n                        children: renderedBlockFromProps\n                    }),\n                    !renderedBlockFromProps && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultBlockObject, {\n                        selected,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultObject, {\n                            value\n                        })\n                    })\n                ]\n            })\n        ]\n    }, element._key);\n};\nElement.displayName = \"Element\";\nconst PortableTextEditorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_4__.createContext)(null), usePortableTextEditor = ()=>{\n    const editor = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(PortableTextEditorContext);\n    if (!editor) throw new Error(\"The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.\");\n    return editor;\n};\nfunction DefaultAnnotation(props) {\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6);\n    let t0;\n    $[0] !== props.annotation ? (t0 = ()=>alert(JSON.stringify(props.annotation)), $[0] = props.annotation, $[1] = t0) : t0 = $[1];\n    const handleClick = t0;\n    let t1;\n    $[2] === Symbol.for(\"react.memo_cache_sentinel\") ? (t1 = {\n        color: \"blue\"\n    }, $[2] = t1) : t1 = $[2];\n    let t2;\n    return $[3] !== handleClick || $[4] !== props.children ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n        style: t1,\n        onClick: handleClick,\n        children: props.children\n    }), $[3] = handleClick, $[4] = props.children, $[5] = t2) : t2 = $[5], t2;\n}\nDefaultAnnotation.displayName = \"DefaultAnnotation\";\nfunction compileType(rawType) {\n    return _sanity_schema__WEBPACK_IMPORTED_MODULE_14__.Schema.compile({\n        name: \"blockTypeSchema\",\n        types: [\n            rawType\n        ]\n    }).get(rawType.name);\n}\nconst FLUSH_PATCHES_THROTTLED_MS =  false ? 0 : 1e3, mutationMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_18__.setup)({\n    types: {\n        context: {},\n        events: {},\n        input: {},\n        emitted: {}\n    },\n    actions: {\n        \"emit has pending patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)({\n            type: \"has pending patches\"\n        }),\n        \"emit mutation\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ context })=>({\n                type: \"mutation\",\n                patches: context.pendingPatches,\n                snapshot: fromSlateValue(context.slateEditor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(context.slateEditor))\n            })),\n        \"clear pending patches\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            pendingPatches: []\n        }),\n        \"defer patch\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            pendingPatches: ({ context, event })=>[\n                    ...context.pendingPatches,\n                    event.patch\n                ]\n        })\n    },\n    guards: {\n        \"slate is normalizing\": ({ context })=>slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isNormalizing(context.slateEditor)\n    }\n}).createMachine({\n    id: \"mutation\",\n    context: ({ input })=>({\n            pendingPatches: [],\n            schema: input.schema,\n            slateEditor: input.slateEditor\n        }),\n    initial: \"idle\",\n    states: {\n        idle: {\n            on: {\n                patch: {\n                    actions: [\n                        \"defer patch\",\n                        \"emit has pending patches\"\n                    ],\n                    target: \"has pending patches\"\n                }\n            }\n        },\n        \"has pending patches\": {\n            after: {\n                [FLUSH_PATCHES_THROTTLED_MS]: [\n                    {\n                        guard: \"slate is normalizing\",\n                        target: \"idle\",\n                        actions: [\n                            \"emit mutation\",\n                            \"clear pending patches\"\n                        ]\n                    },\n                    {\n                        reenter: !0\n                    }\n                ]\n            },\n            on: {\n                patch: {\n                    actions: [\n                        \"defer patch\"\n                    ],\n                    reenter: !0\n                }\n            }\n        }\n    }\n});\nfunction validateValue(value, types, keyGenerator) {\n    let resolution = null, valid = !0;\n    const validChildTypes = [\n        types.span.name,\n        ...types.inlineObjects.map((t)=>t.name)\n    ], validBlockTypes = [\n        types.block.name,\n        ...types.blockObjects.map((t)=>t.name)\n    ];\n    return value === void 0 ? {\n        valid: !0,\n        resolution: null,\n        value\n    } : !Array.isArray(value) || value.length === 0 ? {\n        valid: !1,\n        resolution: {\n            patches: [\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([])\n            ],\n            description: \"Editor value must be an array of Portable Text blocks, or undefined.\",\n            action: \"Unset the value\",\n            item: value,\n            i18n: {\n                description: \"inputs.portable-text.invalid-value.not-an-array.description\",\n                action: \"inputs.portable-text.invalid-value.not-an-array.action\"\n            }\n        },\n        value\n    } : (value.some((blk, index)=>{\n        if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__(blk)) return resolution = {\n            patches: [\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                    index\n                ])\n            ],\n            description: `Block must be an object, got ${String(blk)}`,\n            action: \"Unset invalid item\",\n            item: blk,\n            i18n: {\n                description: \"inputs.portable-text.invalid-value.not-an-object.description\",\n                action: \"inputs.portable-text.invalid-value.not-an-object.action\",\n                values: {\n                    index\n                }\n            }\n        }, !0;\n        if (!blk._key || typeof blk._key != \"string\") return resolution = {\n            patches: [\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n                    ...blk,\n                    _key: keyGenerator()\n                }, [\n                    index\n                ])\n            ],\n            description: `Block at index ${index} is missing required _key.`,\n            action: \"Set the block with a random _key value\",\n            item: blk,\n            i18n: {\n                description: \"inputs.portable-text.invalid-value.missing-key.description\",\n                action: \"inputs.portable-text.invalid-value.missing-key.action\",\n                values: {\n                    index\n                }\n            }\n        }, !0;\n        if (!blk._type || !validBlockTypes.includes(blk._type)) {\n            if (blk._type === \"block\") {\n                const currentBlockTypeName = types.block.name;\n                return resolution = {\n                    patches: [\n                        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n                            ...blk,\n                            _type: currentBlockTypeName\n                        }, [\n                            {\n                                _key: blk._key\n                            }\n                        ])\n                    ],\n                    description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,\n                    action: `Use type '${currentBlockTypeName}'`,\n                    item: blk,\n                    i18n: {\n                        description: \"inputs.portable-text.invalid-value.incorrect-block-type.description\",\n                        action: \"inputs.portable-text.invalid-value.incorrect-block-type.action\",\n                        values: {\n                            key: blk._key,\n                            expectedTypeName: currentBlockTypeName\n                        }\n                    }\n                }, !0;\n            }\n            return !blk._type && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextTextBlock)({\n                ...blk,\n                _type: types.block.name\n            }) ? (resolution = {\n                patches: [\n                    (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n                        ...blk,\n                        _type: types.block.name\n                    }, [\n                        {\n                            _key: blk._key\n                        }\n                    ])\n                ],\n                description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,\n                action: `Use type '${types.block.name}'`,\n                item: blk,\n                i18n: {\n                    description: \"inputs.portable-text.invalid-value.missing-block-type.description\",\n                    action: \"inputs.portable-text.invalid-value.missing-block-type.action\",\n                    values: {\n                        key: blk._key,\n                        expectedTypeName: types.block.name\n                    }\n                }\n            }, !0) : blk._type ? (resolution = {\n                patches: [\n                    (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                        {\n                            _key: blk._key\n                        }\n                    ])\n                ],\n                description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,\n                action: \"Remove the block\",\n                item: blk,\n                i18n: {\n                    description: \"inputs.portable-text.invalid-value.disallowed-type.description\",\n                    action: \"inputs.portable-text.invalid-value.disallowed-type.action\",\n                    values: {\n                        key: blk._key,\n                        typeName: blk._type\n                    }\n                }\n            }, !0) : (resolution = {\n                patches: [\n                    (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                        {\n                            _key: blk._key\n                        }\n                    ])\n                ],\n                description: `Block with _key '${blk._key}' is missing an _type property`,\n                action: \"Remove the block\",\n                item: blk,\n                i18n: {\n                    description: \"inputs.portable-text.invalid-value.missing-type.description\",\n                    action: \"inputs.portable-text.invalid-value.missing-type.action\",\n                    values: {\n                        key: blk._key\n                    }\n                }\n            }, !0);\n        }\n        if (blk._type === types.block.name) {\n            const textBlock = blk;\n            if (textBlock.children && !Array.isArray(textBlock.children)) return resolution = {\n                patches: [\n                    (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n                        children: []\n                    }, [\n                        {\n                            _key: textBlock._key\n                        }\n                    ])\n                ],\n                description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,\n                action: \"Reset the children property\",\n                item: textBlock,\n                i18n: {\n                    description: \"inputs.portable-text.invalid-value.missing-or-invalid-children.description\",\n                    action: \"inputs.portable-text.invalid-value.missing-or-invalid-children.action\",\n                    values: {\n                        key: textBlock._key\n                    }\n                }\n            }, !0;\n            if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {\n                const newSpan = {\n                    _type: types.span.name,\n                    _key: keyGenerator(),\n                    text: \"\",\n                    marks: []\n                };\n                return resolution = {\n                    autoResolve: !0,\n                    patches: [\n                        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.setIfMissing)([], [\n                            {\n                                _key: blk._key\n                            },\n                            \"children\"\n                        ]),\n                        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([\n                            newSpan\n                        ], \"after\", [\n                            {\n                                _key: blk._key\n                            },\n                            \"children\",\n                            0\n                        ])\n                    ],\n                    description: `Children for text block with _key '${blk._key}' is empty.`,\n                    action: \"Insert an empty text\",\n                    item: blk,\n                    i18n: {\n                        description: \"inputs.portable-text.invalid-value.empty-children.description\",\n                        action: \"inputs.portable-text.invalid-value.empty-children.action\",\n                        values: {\n                            key: blk._key\n                        }\n                    }\n                }, !0;\n            }\n            const allUsedMarks = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_8__(textBlock.children.filter((cld)=>cld._type === types.span.name).map((cld)=>cld.marks || [])));\n            if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {\n                const unusedMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__(blk.markDefs.map((def)=>def._key).filter((key)=>!allUsedMarks.includes(key)));\n                if (unusedMarkDefs.length > 0) return resolution = {\n                    autoResolve: !0,\n                    patches: unusedMarkDefs.map((markDefKey)=>(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                            {\n                                _key: blk._key\n                            },\n                            \"markDefs\",\n                            {\n                                _key: markDefKey\n                            }\n                        ])),\n                    description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(\", \")}.`,\n                    action: \"Remove unused mark definition item\",\n                    item: blk,\n                    i18n: {\n                        description: \"inputs.portable-text.invalid-value.orphaned-mark-defs.description\",\n                        action: \"inputs.portable-text.invalid-value.orphaned-mark-defs.action\",\n                        values: {\n                            key: blk._key,\n                            unusedMarkDefs: unusedMarkDefs.map((m)=>m.toString())\n                        }\n                    }\n                }, !0;\n            }\n            const orphanedMarks = allUsedMarks.filter((mark)=>!types.decorators.map((dec)=>dec.value).includes(mark)).filter((mark)=>textBlock.markDefs === void 0 || !textBlock.markDefs.find((def)=>def._key === mark));\n            if (orphanedMarks.length > 0) {\n                const spanChildren = textBlock.children.filter((cld)=>cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark)=>orphanedMarks.includes(mark)));\n                if (spanChildren) {\n                    const orphaned = orphanedMarks.join(\", \");\n                    return resolution = {\n                        autoResolve: !0,\n                        patches: spanChildren.map((child)=>(0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)((child.marks || []).filter((cMrk)=>!orphanedMarks.includes(cMrk)), [\n                                {\n                                    _key: blk._key\n                                },\n                                \"children\",\n                                {\n                                    _key: child._key\n                                },\n                                \"marks\"\n                            ])),\n                        description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,\n                        action: \"Remove invalid marks\",\n                        item: blk,\n                        i18n: {\n                            description: \"inputs.portable-text.invalid-value.orphaned-marks.description\",\n                            action: \"inputs.portable-text.invalid-value.orphaned-marks.action\",\n                            values: {\n                                key: blk._key,\n                                orphanedMarks: orphanedMarks.map((m)=>m.toString())\n                            }\n                        }\n                    }, !0;\n                }\n            }\n            textBlock.children.some((child, cIndex)=>{\n                if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__(child)) return resolution = {\n                    patches: [\n                        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                            {\n                                _key: blk._key\n                            },\n                            \"children\",\n                            cIndex\n                        ])\n                    ],\n                    description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,\n                    action: \"Remove the item\",\n                    item: blk,\n                    i18n: {\n                        description: \"inputs.portable-text.invalid-value.non-object-child.description\",\n                        action: \"inputs.portable-text.invalid-value.non-object-child.action\",\n                        values: {\n                            key: blk._key,\n                            index: cIndex\n                        }\n                    }\n                }, !0;\n                if (!child._key || typeof child._key != \"string\") {\n                    const newChild = {\n                        ...child,\n                        _key: keyGenerator()\n                    };\n                    return resolution = {\n                        autoResolve: !0,\n                        patches: [\n                            (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(newChild, [\n                                {\n                                    _key: blk._key\n                                },\n                                \"children\",\n                                cIndex\n                            ])\n                        ],\n                        description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,\n                        action: \"Set a new random _key on the object\",\n                        item: blk,\n                        i18n: {\n                            description: \"inputs.portable-text.invalid-value.missing-child-key.description\",\n                            action: \"inputs.portable-text.invalid-value.missing-child-key.action\",\n                            values: {\n                                key: blk._key,\n                                index: cIndex\n                            }\n                        }\n                    }, !0;\n                }\n                return child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != \"string\" ? (resolution = {\n                    patches: [\n                        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)({\n                            ...child,\n                            text: \"\"\n                        }, [\n                            {\n                                _key: blk._key\n                            },\n                            \"children\",\n                            {\n                                _key: child._key\n                            }\n                        ])\n                    ],\n                    description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,\n                    action: \"Write an empty text property to the object\",\n                    item: blk,\n                    i18n: {\n                        description: \"inputs.portable-text.invalid-value.invalid-span-text.description\",\n                        action: \"inputs.portable-text.invalid-value.invalid-span-text.action\",\n                        values: {\n                            key: blk._key,\n                            childKey: child._key\n                        }\n                    }\n                }, !0) : !1 : (resolution = {\n                    patches: [\n                        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                            {\n                                _key: blk._key\n                            },\n                            \"children\",\n                            {\n                                _key: child._key\n                            }\n                        ])\n                    ],\n                    description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,\n                    action: \"Remove the object\",\n                    item: blk,\n                    i18n: {\n                        description: \"inputs.portable-text.invalid-value.disallowed-child-type.description\",\n                        action: \"inputs.portable-text.invalid-value.disallowed-child-type.action\",\n                        values: {\n                            key: blk._key,\n                            childKey: child._key,\n                            childType: child._type\n                        }\n                    }\n                }, !0) : (resolution = {\n                    patches: [\n                        (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                            {\n                                _key: blk._key\n                            },\n                            \"children\",\n                            {\n                                _key: child._key\n                            }\n                        ])\n                    ],\n                    description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,\n                    action: \"Remove the object\",\n                    item: blk,\n                    i18n: {\n                        description: \"inputs.portable-text.invalid-value.missing-child-type.description\",\n                        action: \"inputs.portable-text.invalid-value.missing-child-type.action\",\n                        values: {\n                            key: blk._key,\n                            childKey: child._key\n                        }\n                    }\n                }, !0);\n            }) && (valid = !1);\n        }\n        return !1;\n    }) && (valid = !1), {\n        valid,\n        resolution,\n        value\n    });\n}\nfunction withRemoteChanges(editor, fn) {\n    const prev = isChangingRemotely(editor) || !1;\n    IS_PROCESSING_REMOTE_CHANGES.set(editor, !0), fn(), IS_PROCESSING_REMOTE_CHANGES.set(editor, prev);\n}\nfunction isChangingRemotely(editor) {\n    return IS_PROCESSING_REMOTE_CHANGES.get(editor);\n}\nconst PATCHING = /* @__PURE__ */ new WeakMap();\nfunction withoutPatching(editor, fn) {\n    const prev = isPatching(editor);\n    PATCHING.set(editor, !1), fn(), PATCHING.set(editor, prev);\n}\nfunction isPatching(editor) {\n    return PATCHING.get(editor);\n}\nfunction cloneDiff(diff2) {\n    const [type, patch] = diff2;\n    return [\n        type,\n        patch\n    ];\n}\nfunction getCommonOverlap(textA, textB) {\n    let text1 = textA, text2 = textB;\n    const text1Length = text1.length, text2Length = text2.length;\n    if (text1Length === 0 || text2Length === 0) return 0;\n    text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n    const textLength = Math.min(text1Length, text2Length);\n    if (text1 === text2) return textLength;\n    let best = 0, length = 1;\n    for(let found = 0; found !== -1;){\n        const pattern = text1.substring(textLength - length);\n        if (found = text2.indexOf(pattern), found === -1) return best;\n        length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n    }\n    return best;\n}\nfunction getCommonPrefix(text1, text2) {\n    if (!text1 || !text2 || text1[0] !== text2[0]) return 0;\n    let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n    for(; pointerMin < pointerMid;)text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n    return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n    if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;\n    let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n    for(; pointerMin < pointerMid;)text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n    return pointerMid;\n}\nfunction isHighSurrogate(char) {\n    const charCode = char.charCodeAt(0);\n    return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n    const charCode = char.charCodeAt(0);\n    return charCode >= 56320 && charCode <= 57343;\n}\nfunction bisect(text1, text2, deadline) {\n    const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n    for(let x = 0; x < vLength; x++)v1[x] = -1, v2[x] = -1;\n    v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n    const delta = text1Length - text2Length, front = delta % 2 !== 0;\n    let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n    for(let d = 0; d < maxD && !(Date.now() > deadline); d++){\n        for(let k1 = -d + k1start; k1 <= d - k1end; k1 += 2){\n            const k1Offset = vOffset + k1;\n            let x1;\n            k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n            let y1 = x1 - k1;\n            for(; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1);)x1++, y1++;\n            if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;\n            else if (y1 > text2Length) k1start += 2;\n            else if (front) {\n                const k2Offset = vOffset + delta - k1;\n                if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n                    const x2 = text1Length - v2[k2Offset];\n                    if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);\n                }\n            }\n        }\n        for(let k2 = -d + k2start; k2 <= d - k2end; k2 += 2){\n            const k2Offset = vOffset + k2;\n            let x2;\n            k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n            let y2 = x2 - k2;\n            for(; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1);)x2++, y2++;\n            if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;\n            else if (y2 > text2Length) k2start += 2;\n            else if (!front) {\n                const k1Offset = vOffset + delta - k2;\n                if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n                    const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n                    if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);\n                }\n            }\n        }\n    }\n    return [\n        [\n            DIFF_DELETE,\n            text1\n        ],\n        [\n            DIFF_INSERT,\n            text2\n        ]\n    ];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n    const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {\n        checkLines: !1,\n        deadline\n    }), diffsb = doDiff(text1b, text2b, {\n        checkLines: !1,\n        deadline\n    });\n    return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2, timeout = 1) {\n    if (timeout <= 0) return null;\n    const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n    if (longText.length < 4 || shortText.length * 2 < longText.length) return null;\n    const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n    let halfMatch;\n    if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n    else {\n        if (!halfMatch1 && !halfMatch2) return null;\n        halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n    }\n    if (!halfMatch) throw new Error(\"Unable to find a half match.\");\n    let text1A, text1B, text2A, text2B;\n    text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n    const midCommon = halfMatch[4];\n    return [\n        text1A,\n        text1B,\n        text2A,\n        text2B,\n        midCommon\n    ];\n}\nfunction halfMatchI(longText, shortText, i) {\n    const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n    let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n    for(; (j = shortText.indexOf(seed, j + 1)) !== -1;){\n        const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n        bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n    }\n    return bestCommon.length * 2 >= longText.length ? [\n        bestLongTextA || \"\",\n        bestLongTextB || \"\",\n        bestShortTextA || \"\",\n        bestShortTextB || \"\",\n        bestCommon || \"\"\n    ] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n    for(let x = 0; x < diffs.length; x++){\n        const chars = diffs[x][1], text = [];\n        for(let y = 0; y < chars.length; y++)text[y] = lineArray[chars.charCodeAt(y)];\n        diffs[x][1] = text.join(\"\");\n    }\n}\nfunction linesToChars(textA, textB) {\n    const lineArray = [], lineHash = {};\n    lineArray[0] = \"\";\n    function diffLinesToMunge(text) {\n        let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n        for(; lineEnd < text.length - 1;){\n            lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n            let line = text.slice(lineStart, lineEnd + 1);\n            (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n        }\n        return chars;\n    }\n    let maxLines = 4e4;\n    const chars1 = diffLinesToMunge(textA);\n    maxLines = 65535;\n    const chars2 = diffLinesToMunge(textB);\n    return {\n        chars1,\n        chars2,\n        lineArray\n    };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n    let text1 = textA, text2 = textB;\n    const a = linesToChars(text1, text2);\n    text1 = a.chars1, text2 = a.chars2;\n    const linearray = a.lineArray;\n    let diffs = doDiff(text1, text2, {\n        checkLines: !1,\n        deadline: opts.deadline\n    });\n    charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([\n        DIFF_EQUAL,\n        \"\"\n    ]);\n    let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n    for(; pointer < diffs.length;){\n        switch(diffs[pointer][0]){\n            case DIFF_INSERT:\n                countInsert++, textInsert += diffs[pointer][1];\n                break;\n            case DIFF_DELETE:\n                countDelete++, textDelete += diffs[pointer][1];\n                break;\n            case DIFF_EQUAL:\n                if (countDelete >= 1 && countInsert >= 1) {\n                    diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n                    const aa = doDiff(textDelete, textInsert, {\n                        checkLines: !1,\n                        deadline: opts.deadline\n                    });\n                    for(let j = aa.length - 1; j >= 0; j--)diffs.splice(pointer, 0, aa[j]);\n                    pointer += aa.length;\n                }\n                countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n                break;\n            default:\n                throw new Error(\"Unknown diff operation.\");\n        }\n        pointer++;\n    }\n    return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n    let diffs;\n    if (!text1) return [\n        [\n            DIFF_INSERT,\n            text2\n        ]\n    ];\n    if (!text2) return [\n        [\n            DIFF_DELETE,\n            text1\n        ]\n    ];\n    const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n    if (i !== -1) return diffs = [\n        [\n            DIFF_INSERT,\n            longtext.substring(0, i)\n        ],\n        [\n            DIFF_EQUAL,\n            shorttext\n        ],\n        [\n            DIFF_INSERT,\n            longtext.substring(i + shorttext.length)\n        ]\n    ], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n    if (shorttext.length === 1) return [\n        [\n            DIFF_DELETE,\n            text1\n        ],\n        [\n            DIFF_INSERT,\n            text2\n        ]\n    ];\n    const halfMatch = findHalfMatch(text1, text2);\n    if (halfMatch) {\n        const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n        return diffsA.concat([\n            [\n                DIFF_EQUAL,\n                midCommon\n            ]\n        ], diffsB);\n    }\n    return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nvar __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value\n    }) : obj[key] = value, __spreadValues$2 = (a, b)=>{\n    for(var prop in b || (b = {}))__hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n    if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b))__propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n    return a;\n};\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n    if (textA === null || textB === null) throw new Error(\"Null input. (diff)\");\n    const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n    return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n    let text1 = textA, text2 = textB;\n    if (text1 === text2) return text1 ? [\n        [\n            DIFF_EQUAL,\n            text1\n        ]\n    ] : [];\n    let commonlength = getCommonPrefix(text1, text2);\n    const commonprefix = text1.substring(0, commonlength);\n    text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n    const commonsuffix = text1.substring(text1.length - commonlength);\n    text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n    let diffs = computeDiff(text1, text2, options);\n    return commonprefix && diffs.unshift([\n        DIFF_EQUAL,\n        commonprefix\n    ]), commonsuffix && diffs.push([\n        DIFF_EQUAL,\n        commonsuffix\n    ]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n    let t = 1;\n    return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n    return __spreadValues$2({\n        checkLines: !0,\n        deadline: createDeadLine(opts.timeout || 1)\n    }, opts);\n}\nfunction combineChar(data, char, dir) {\n    return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n    return dir === 1 ? [\n        data.substring(0, data.length - 1),\n        data[data.length - 1]\n    ] : [\n        data.substring(1),\n        data[0]\n    ];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n    return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n    const inv = dir === 1 ? -1 : 1;\n    let insertIdx = null, deleteIdx = null, j = i + dir;\n    for(; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir){\n        const [op, text2] = diffs[j];\n        if (text2.length !== 0) {\n            if (op === DIFF_INSERT) {\n                insertIdx === null && (insertIdx = j);\n                continue;\n            } else if (op === DIFF_DELETE) {\n                deleteIdx === null && (deleteIdx = j);\n                continue;\n            } else if (op === DIFF_EQUAL) {\n                if (insertIdx === null && deleteIdx === null) {\n                    const [rest, char2] = splitChar(diffs[i][1], dir);\n                    diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n                    return;\n                }\n                break;\n            }\n        }\n    }\n    if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n        const [insertText2, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n        diffs[insertIdx][1] = insertText2, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n        return;\n    }\n    const [text, char] = splitChar(diffs[i][1], dir);\n    diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [\n        DIFF_INSERT,\n        char\n    ]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [\n        DIFF_DELETE,\n        char\n    ]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n    for(let i = 0; i < diffs.length; i++){\n        const [diffType, diffText] = diffs[i];\n        if (diffText.length === 0) continue;\n        const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n        isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n    }\n    for(let i = 0; i < diffs.length; i++)diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nfunction cleanupSemantic(rawDiffs) {\n    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2)), hasChanges = !1;\n    const equalities = [];\n    let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n    for(; pointer < diffs.length;)diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [\n        DIFF_DELETE,\n        lastEquality\n    ]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n    for(hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length;){\n        if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n            const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n            overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [\n                DIFF_EQUAL,\n                insertion.substring(0, overlapLength1)\n            ]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [\n                DIFF_EQUAL,\n                deletion.substring(0, overlapLength2)\n            ]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n        }\n        pointer++;\n    }\n    return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n    const diffs = rawDiffs.map((diff2)=>cloneDiff(diff2));\n    function diffCleanupSemanticScore(one, two) {\n        if (!one || !two) return 6;\n        const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n        return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n    }\n    let pointer = 1;\n    for(; pointer < diffs.length - 1;){\n        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n            let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n            const commonOffset = getCommonSuffix(equality1, edit);\n            if (commonOffset) {\n                const commonString = edit.substring(edit.length - commonOffset);\n                equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n            }\n            let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n            for(; edit.charAt(0) === equality2.charAt(0);){\n                equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n                const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n                score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n            }\n            diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n        }\n        pointer++;\n    }\n    return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2));\n    diffs.push([\n        DIFF_EQUAL,\n        \"\"\n    ]);\n    let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n    for(; pointer < diffs.length;)switch(diffs[pointer][0]){\n        case DIFF_INSERT:\n            countInsert++, textInsert += diffs[pointer][1], pointer++;\n            break;\n        case DIFF_DELETE:\n            countDelete++, textDelete += diffs[pointer][1], pointer++;\n            break;\n        case DIFF_EQUAL:\n            countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [\n                DIFF_EQUAL,\n                textInsert.substring(0, commonlength)\n            ]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [\n                DIFF_DELETE,\n                textDelete\n            ]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [\n                DIFF_INSERT,\n                textInsert\n            ]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n            break;\n        default:\n            throw new Error(\"Unknown diff operation\");\n    }\n    diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n    let hasChanges = !1;\n    for(pointer = 1; pointer < diffs.length - 1;)diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n    return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount(...args) {\n    return args.reduce((n, bool)=>n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs, editCost = 4) {\n    let diffs = rawDiffs.map((diff2)=>cloneDiff(diff2)), hasChanges = !1;\n    const equalities = [];\n    let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n    for(; pointer < diffs.length;)diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [\n        DIFF_DELETE,\n        lastEquality\n    ]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n    return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nvar __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {\n        enumerable: !0,\n        configurable: !0,\n        writable: !0,\n        value\n    }) : obj[key] = value, __spreadValues$1 = (a, b)=>{\n    for(var prop in b || (b = {}))__hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n    if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b))__propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n    return a;\n};\nconst DEFAULT_OPTIONS = {\n    /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */ threshold: 0.5,\n    /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */ distance: 1e3\n};\nfunction applyDefaults(options) {\n    return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc, opts = {}) {\n    if (pattern.length > MAX_BITS$1) throw new Error(\"Pattern too long for this browser.\");\n    const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n    function getBitapScore(e, x) {\n        const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n        return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n    }\n    let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n    bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n    const matchmask = 1 << pattern.length - 1;\n    bestLoc = -1;\n    let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n    for(let d = 0; d < pattern.length; d++){\n        for(binMin = 0, binMid = binMax; binMin < binMid;)getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n        binMax = binMid;\n        let start = Math.max(1, loc - binMid + 1);\n        const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n        rd[finish + 1] = (1 << d) - 1;\n        for(let j = finish; j >= start; j--){\n            const charMatch = s[text.charAt(j - 1)];\n            if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n                const score = getBitapScore(d, j - 1);\n                if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);\n                else break;\n            }\n        }\n        if (getBitapScore(d + 1, loc) > scoreThreshold) break;\n        lastRd = rd;\n    }\n    return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n    const s = {};\n    for(let i = 0; i < pattern.length; i++)s[pattern.charAt(i)] = 0;\n    for(let i = 0; i < pattern.length; i++)s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n    return s;\n}\nfunction match(text, pattern, searchLocation) {\n    if (text === null || pattern === null || searchLocation === null) throw new Error(\"Null input. (match())\");\n    const loc = Math.max(0, Math.min(searchLocation, text.length));\n    if (text === pattern) return 0;\n    if (text.length) {\n        if (text.substring(loc, loc + pattern.length) === pattern) return loc;\n    } else return -1;\n    return bitap(text, pattern, loc);\n}\nfunction diffText1(diffs) {\n    const text = [];\n    for(let x = 0; x < diffs.length; x++)diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n    return text.join(\"\");\n}\nfunction diffText2(diffs) {\n    const text = [];\n    for(let x = 0; x < diffs.length; x++)diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n    return text.join(\"\");\n}\nfunction levenshtein(diffs) {\n    let leven = 0, insertions = 0, deletions = 0;\n    for(let x = 0; x < diffs.length; x++){\n        const op = diffs[x][0], data = diffs[x][1];\n        switch(op){\n            case DIFF_INSERT:\n                insertions += data.length;\n                break;\n            case DIFF_DELETE:\n                deletions += data.length;\n                break;\n            case DIFF_EQUAL:\n                leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n                break;\n            default:\n                throw new Error(\"Unknown diff operation.\");\n        }\n    }\n    return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, loc) {\n    let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n    for(x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > loc)); x++)lastChars1 = chars1, lastChars2 = chars2;\n    return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (loc - lastChars1);\n}\nfunction countUtf8Bytes(str) {\n    let bytes = 0;\n    for(let i = 0; i < str.length; i++){\n        const codePoint = str.codePointAt(i);\n        if (typeof codePoint > \"u\") throw new Error(\"Failed to get codepoint\");\n        bytes += utf8len(codePoint);\n    }\n    return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base, options = {}) {\n    let byteOffset = 0, idx = 0;\n    function advanceTo(target) {\n        for(; byteOffset < target;){\n            const codePoint = base.codePointAt(idx);\n            if (typeof codePoint > \"u\") return idx;\n            byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n        }\n        if (!options.allowExceedingIndices && byteOffset !== target) throw new Error(\"Failed to determine byte offset\");\n        return idx;\n    }\n    const adjusted = [];\n    for (const patch of patches)adjusted.push({\n        diffs: patch.diffs.map((diff2)=>cloneDiff(diff2)),\n        start1: advanceTo(patch.start1),\n        start2: advanceTo(patch.start2),\n        utf8Start1: patch.utf8Start1,\n        utf8Start2: patch.utf8Start2,\n        length1: patch.length1,\n        length2: patch.length2,\n        utf8Length1: patch.utf8Length1,\n        utf8Length2: patch.utf8Length2\n    });\n    return adjusted;\n}\nfunction utf8len(codePoint) {\n    return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction addPadding(patches, margin = DEFAULT_MARGIN) {\n    const paddingLength = margin;\n    let nullPadding = \"\";\n    for(let x = 1; x <= paddingLength; x++)nullPadding += String.fromCharCode(x);\n    for (const p of patches)p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n    let patch = patches[0], diffs = patch.diffs;\n    if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([\n        DIFF_EQUAL,\n        nullPadding\n    ]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n    else if (paddingLength > diffs[0][1].length) {\n        const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n        diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n    }\n    if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([\n        DIFF_EQUAL,\n        nullPadding\n    ]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n    else if (paddingLength > diffs[diffs.length - 1][1].length) {\n        const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n    }\n    return nullPadding;\n}\nfunction createPatchObject(start1, start2) {\n    return {\n        diffs: [],\n        start1,\n        start2,\n        utf8Start1: start1,\n        utf8Start2: start2,\n        length1: 0,\n        length2: 0,\n        utf8Length1: 0,\n        utf8Length2: 0\n    };\n}\nfunction splitMax(patches, margin = DEFAULT_MARGIN) {\n    const patchSize = MAX_BITS;\n    for(let x = 0; x < patches.length; x++){\n        if (patches[x].length1 <= patchSize) continue;\n        const bigpatch = patches[x];\n        patches.splice(x--, 1);\n        let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n        for(; bigpatch.diffs.length !== 0;){\n            const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n            let empty = !0;\n            if (preContext !== \"\") {\n                const precontextByteCount = countUtf8Bytes(preContext);\n                patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([\n                    DIFF_EQUAL,\n                    preContext\n                ]);\n            }\n            for(; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin;){\n                const diffType = bigpatch.diffs[0][0];\n                let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n                if (diffType === DIFF_INSERT) {\n                    patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n                    const diff2 = bigpatch.diffs.shift();\n                    diff2 && patch.diffs.push(diff2), empty = !1;\n                } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([\n                    diffType,\n                    diffText\n                ]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([\n                    diffType,\n                    diffText\n                ]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n            }\n            preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n            const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n            postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([\n                DIFF_EQUAL,\n                postContext\n            ])), empty || patches.splice(++x, 0, patch);\n        }\n    }\n}\nfunction apply(patches, originalText, opts = {}) {\n    if (typeof patches == \"string\") throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n    let text = originalText;\n    if (patches.length === 0) return [\n        text,\n        []\n    ];\n    const parsed = adjustIndiciesToUcs2(patches, text, {\n        allowExceedingIndices: opts.allowExceedingIndices\n    }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n    text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n    let delta = 0;\n    const results = [];\n    for(let x = 0; x < parsed.length; x++){\n        const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n        let startLoc, endLoc = -1;\n        if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n        else {\n            results[x] = !0, delta = startLoc - expectedLoc;\n            let text2;\n            if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n            else {\n                let diffs = diff(text1, text2, {\n                    checkLines: !1\n                });\n                if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;\n                else {\n                    diffs = cleanupSemanticLossless(diffs);\n                    let index1 = 0, index2 = 0;\n                    for(let y = 0; y < parsed[x].diffs.length; y++){\n                        const mod = parsed[x].diffs[y];\n                        mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n                    }\n                }\n            }\n        }\n    }\n    return text = text.substring(nullPadding.length, text.length - nullPadding.length), [\n        text,\n        results\n    ];\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n    if (!textline) return [];\n    const patches = [], lines = textline.split(`\n`);\n    let textPointer = 0;\n    for(; textPointer < lines.length;){\n        const m = lines[textPointer].match(patchHeader);\n        if (!m) throw new Error(`Invalid patch string: ${lines[textPointer]}`);\n        const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n        for(patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length;){\n            const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n            if (sign === \"@\") break;\n            if (sign === \"\") {\n                textPointer++;\n                continue;\n            }\n            let line;\n            try {\n                line = decodeURI(currentLine.slice(1));\n            } catch  {\n                throw new Error(`Illegal escape in parse: ${currentLine}`);\n            }\n            const utf8Diff = countUtf8Bytes(line) - line.length;\n            if (sign === \"-\") patch.diffs.push([\n                DIFF_DELETE,\n                line\n            ]), patch.length1 -= utf8Diff;\n            else if (sign === \"+\") patch.diffs.push([\n                DIFF_INSERT,\n                line\n            ]), patch.length2 -= utf8Diff;\n            else if (sign === \" \") patch.diffs.push([\n                DIFF_EQUAL,\n                line\n            ]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n            else throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`);\n            textPointer++;\n        }\n    }\n    return patches;\n}\nfunction toInt(num) {\n    return parseInt(num, 10);\n}\nconst IS_UDOING = /* @__PURE__ */ new WeakMap(), IS_REDOING = /* @__PURE__ */ new WeakMap();\nfunction withUndoing(editor, fn) {\n    const prev = isUndoing(editor);\n    IS_UDOING.set(editor, !0), fn(), IS_UDOING.set(editor, prev);\n}\nfunction isUndoing(editor) {\n    return IS_UDOING.get(editor) ?? !1;\n}\nfunction setIsUndoing(editor, isUndoing2) {\n    IS_UDOING.set(editor, isUndoing2);\n}\nfunction withRedoing(editor, fn) {\n    const prev = isRedoing(editor);\n    IS_REDOING.set(editor, !0), fn(), IS_REDOING.set(editor, prev);\n}\nfunction isRedoing(editor) {\n    return IS_REDOING.get(editor) ?? !1;\n}\nfunction setIsRedoing(editor, isRedoing2) {\n    IS_REDOING.set(editor, isRedoing2);\n}\nconst debug$j = debugWithName(\"plugin:withUndoRedo\"), debugVerbose$3 = debug$j.enabled && !1, SAVING = /* @__PURE__ */ new WeakMap(), REMOTE_PATCHES = /* @__PURE__ */ new WeakMap(), UNDO_STEP_LIMIT = 1e3, isSaving = (editor)=>{\n    const state = SAVING.get(editor);\n    return state === void 0 ? !0 : state;\n}, getRemotePatches = (editor)=>(REMOTE_PATCHES.get(editor) || REMOTE_PATCHES.set(editor, []), REMOTE_PATCHES.get(editor) || []);\nfunction createWithUndoRedo(options) {\n    const { editorActor, blockSchemaType } = options;\n    return (editor)=>{\n        let previousSnapshot = fromSlateValue(editor.children, blockSchemaType.name);\n        const remotePatches = getRemotePatches(editor);\n        options.subscriptions.push(()=>{\n            debug$j(\"Subscribing to patches\");\n            const sub = editorActor.on(\"patches\", ({ patches, snapshot })=>{\n                let reset = !1;\n                patches.forEach((patch)=>{\n                    if (!reset && patch.origin !== \"local\" && remotePatches) {\n                        if (patch.type === \"unset\" && patch.path.length === 0) {\n                            debug$j(\"Someone else cleared the content, resetting undo/redo history\"), editor.history = {\n                                undos: [],\n                                redos: []\n                            }, remotePatches.splice(0, remotePatches.length), SAVING.set(editor, !0), reset = !0;\n                            return;\n                        }\n                        remotePatches.push({\n                            patch,\n                            time: /* @__PURE__ */ new Date(),\n                            snapshot,\n                            previousSnapshot\n                        });\n                    }\n                }), previousSnapshot = snapshot;\n            });\n            return ()=>{\n                debug$j(\"Unsubscribing to patches\"), sub.unsubscribe();\n            };\n        }), editor.history = {\n            undos: [],\n            redos: []\n        };\n        const { apply: apply2 } = editor;\n        return editor.apply = (op)=>{\n            if (editorActor.getSnapshot().matches({\n                \"edit mode\": \"read only\"\n            })) {\n                apply2(op);\n                return;\n            }\n            if (isChangingRemotely(editor)) {\n                apply2(op);\n                return;\n            }\n            if (isUndoing(editor) || isRedoing(editor)) {\n                apply2(op);\n                return;\n            }\n            const { operations, history } = editor, { undos } = history, step = undos[undos.length - 1], lastOp = step && step.operations && step.operations[step.operations.length - 1], overwrite = shouldOverwrite(op, lastOp), save = isSaving(editor);\n            let merge = !0;\n            if (save) {\n                if (step ? operations.length === 0 && (merge = shouldMerge(op, lastOp) || overwrite) : merge = !1, step && merge) step.operations.push(op);\n                else {\n                    const newStep = {\n                        operations: [\n                            ...editor.selection === null ? [] : [\n                                createSelectOperation(editor)\n                            ],\n                            op\n                        ],\n                        timestamp: /* @__PURE__ */ new Date()\n                    };\n                    undos.push(newStep), debug$j(\"Created new undo step\", step);\n                }\n                for(; undos.length > UNDO_STEP_LIMIT;)undos.shift();\n                shouldClear(op) && (history.redos = []);\n            }\n            apply2(op);\n        }, editor.undo = ()=>{\n            if (editorActor.getSnapshot().matches({\n                \"edit mode\": \"read only\"\n            })) return;\n            const { undos } = editor.history;\n            if (undos.length > 0) {\n                const step = undos[undos.length - 1];\n                if (debug$j(\"Undoing\", step), step.operations.length > 0) {\n                    const otherPatches = remotePatches.filter((item)=>item.time >= step.timestamp);\n                    let transformedOperations = step.operations;\n                    otherPatches.forEach((item)=>{\n                        transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_8__(transformedOperations.map((op)=>transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n                    });\n                    const reversedOperations = transformedOperations.map(slate__WEBPACK_IMPORTED_MODULE_15__.Operation.inverse).reverse();\n                    try {\n                        slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, ()=>{\n                            withUndoing(editor, ()=>{\n                                withoutSaving(editor, ()=>{\n                                    reversedOperations.forEach((op)=>{\n                                        editor.apply(op);\n                                    });\n                                });\n                            });\n                        }), editor.normalize(), editor.onChange();\n                    } catch (err) {\n                        debug$j(\"Could not perform undo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.history = {\n                            undos: [],\n                            redos: []\n                        }, SAVING.set(editor, !0), setIsUndoing(editor, !1), editor.onChange();\n                        return;\n                    }\n                    editor.history.redos.push(step), editor.history.undos.pop();\n                }\n            }\n        }, editor.redo = ()=>{\n            if (editorActor.getSnapshot().matches({\n                \"edit mode\": \"read only\"\n            })) return;\n            const { redos } = editor.history;\n            if (redos.length > 0) {\n                const step = redos[redos.length - 1];\n                if (debug$j(\"Redoing\", step), step.operations.length > 0) {\n                    const otherPatches = remotePatches.filter((item)=>item.time >= step.timestamp);\n                    let transformedOperations = step.operations;\n                    otherPatches.forEach((item)=>{\n                        transformedOperations = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_8__(transformedOperations.map((op)=>transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot)));\n                    });\n                    try {\n                        slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, ()=>{\n                            withRedoing(editor, ()=>{\n                                withoutSaving(editor, ()=>{\n                                    transformedOperations.forEach((op)=>{\n                                        editor.apply(op);\n                                    });\n                                });\n                            });\n                        }), editor.normalize(), editor.onChange();\n                    } catch (err) {\n                        debug$j(\"Could not perform redo step\", err), remotePatches.splice(0, remotePatches.length), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.history = {\n                            undos: [],\n                            redos: []\n                        }, SAVING.set(editor, !0), setIsRedoing(editor, !1), editor.onChange();\n                        return;\n                    }\n                    editor.history.undos.push(step), editor.history.redos.pop();\n                }\n            }\n        }, editor;\n    };\n}\nfunction transformOperation(editor, patch, operation, snapshot, previousSnapshot) {\n    debugVerbose$3 && (debug$j(`Adjusting '${operation.type}' operation paths for '${patch.type}' patch`), debug$j(`Operation ${JSON.stringify(operation)}`), debug$j(`Patch ${JSON.stringify(patch)}`));\n    const transformedOperation = {\n        ...operation\n    };\n    if (patch.type === \"insert\" && patch.path.length === 1) {\n        const insertBlockIndex = (snapshot || []).findIndex((blk)=>lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n                _key: blk._key\n            }, patch.path[0]));\n        return debug$j(`Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`), [\n            adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)\n        ];\n    }\n    if (patch.type === \"unset\" && patch.path.length === 1) {\n        const unsetBlockIndex = (previousSnapshot || []).findIndex((blk)=>lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n                _key: blk._key\n            }, patch.path[0]));\n        return \"path\" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$j(\"Skipping transformation that targeted removed block\"), []) : (debugVerbose$3 && (debug$j(`Selection ${JSON.stringify(editor.selection)}`), debug$j(`Adjusting block path (-1) for '${transformedOperation.type}' operation and patch '${patch.type}'`)), [\n            adjustBlockPath(transformedOperation, -1, unsetBlockIndex)\n        ]);\n    }\n    if (patch.type === \"unset\" && patch.path.length === 0) return debug$j(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];\n    if (patch.type === \"diffMatchPatch\") {\n        const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation);\n        return !operationTargetBlock || !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__({\n            _key: operationTargetBlock._key\n        }, patch.path[0]) ? [\n            transformedOperation\n        ] : (parse(patch.value).forEach((diffPatch)=>{\n            let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;\n            const { diffs } = diffPatch;\n            if (diffs.forEach((diff2, index)=>{\n                const [diffType, text] = diff2;\n                diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every(([dType])=>dType === DIFF_EQUAL) || (changedOffset += text.length));\n            }), transformedOperation.type === \"insert_text\" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"remove_text\" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === \"set_selection\") {\n                const currentFocus = transformedOperation.properties?.focus ? {\n                    ...transformedOperation.properties.focus\n                } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n                    ...transformedOperation.properties.anchor\n                } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n                    ...transformedOperation.newProperties.focus\n                } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n                    ...transformedOperation.newProperties.anchor\n                } : void 0;\n                (currentFocus && currentAnchor || newFocus && newAnchor) && ([\n                    currentFocus,\n                    currentAnchor,\n                    newFocus,\n                    newAnchor\n                ].forEach((point)=>{\n                    point && changedOffset < point.offset && (point.offset += adjustOffsetBy);\n                }), currentFocus && currentAnchor && (transformedOperation.properties = {\n                    focus: currentFocus,\n                    anchor: currentAnchor\n                }), newFocus && newAnchor && (transformedOperation.newProperties = {\n                    focus: newFocus,\n                    anchor: newAnchor\n                }));\n            }\n        }), [\n            transformedOperation\n        ]);\n    }\n    return [\n        transformedOperation\n    ];\n}\nfunction adjustBlockPath(operation, level, blockIndex) {\n    const transformedOperation = {\n        ...operation\n    };\n    if (blockIndex >= 0 && transformedOperation.type !== \"set_selection\" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {\n        const newPath = [\n            transformedOperation.path[0] + level,\n            ...transformedOperation.path.slice(1)\n        ];\n        transformedOperation.path = newPath;\n    }\n    if (transformedOperation.type === \"set_selection\") {\n        const currentFocus = transformedOperation.properties?.focus ? {\n            ...transformedOperation.properties.focus\n        } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {\n            ...transformedOperation.properties.anchor\n        } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {\n            ...transformedOperation.newProperties.focus\n        } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {\n            ...transformedOperation.newProperties.anchor\n        } : void 0;\n        (currentFocus && currentAnchor || newFocus && newAnchor) && ([\n            currentFocus,\n            currentAnchor,\n            newFocus,\n            newAnchor\n        ].forEach((point)=>{\n            point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [\n                point.path[0] + level,\n                ...point.path.slice(1)\n            ]);\n        }), currentFocus && currentAnchor && (transformedOperation.properties = {\n            focus: currentFocus,\n            anchor: currentAnchor\n        }), newFocus && newAnchor && (transformedOperation.newProperties = {\n            focus: newFocus,\n            anchor: newAnchor\n        }));\n    }\n    return transformedOperation;\n}\nconst shouldMerge = (op, prev)=>!!(op.type === \"set_selection\" || prev && op.type === \"insert_text\" && prev.type === \"insert_text\" && op.offset === prev.offset + prev.text.length && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(op.path, prev.path) && op.text !== \" \" || prev && op.type === \"remove_text\" && prev.type === \"remove_text\" && op.offset + op.text.length === prev.offset && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(op.path, prev.path)), shouldOverwrite = (op, prev)=>!!(prev && op.type === \"set_selection\" && prev.type === \"set_selection\"), shouldClear = (op)=>op.type !== \"set_selection\";\nfunction withoutSaving(editor, fn) {\n    const prev = isSaving(editor);\n    SAVING.set(editor, !1), fn(), SAVING.set(editor, prev);\n}\nfunction createSelectOperation(editor) {\n    return {\n        type: \"set_selection\",\n        properties: {\n            ...editor.selection\n        },\n        newProperties: {\n            ...editor.selection\n        }\n    };\n}\nfunction findOperationTargetBlock(editor, operation) {\n    let block;\n    return operation.type === \"set_selection\" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : \"path\" in operation && (block = editor.children[operation.path[0]]), block;\n}\nconst syncValueCallback = ({ sendBack, input })=>{\n    updateValue({\n        context: input.context,\n        sendBack,\n        slateEditor: input.slateEditor,\n        value: input.value,\n        streamBlocks: input.streamBlocks\n    });\n}, syncValueLogic = (0,xstate__WEBPACK_IMPORTED_MODULE_21__.fromCallback)(syncValueCallback), syncMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_18__.setup)({\n    types: {\n        context: {},\n        input: {},\n        events: {},\n        emitted: {}\n    },\n    actions: {\n        \"assign initial value synced\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            initialValueSynced: !0\n        }),\n        \"assign readOnly\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            readOnly: ({ event })=>((0,xstate__WEBPACK_IMPORTED_MODULE_18__.assertEvent)(event, \"update readOnly\"), event.readOnly)\n        }),\n        \"assign pending value\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            pendingValue: ({ event })=>((0,xstate__WEBPACK_IMPORTED_MODULE_18__.assertEvent)(event, \"update value\"), event.value)\n        }),\n        \"clear pending value\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            pendingValue: void 0\n        }),\n        \"assign previous value\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            previousValue: ({ event })=>((0,xstate__WEBPACK_IMPORTED_MODULE_18__.assertEvent)(event, \"done syncing\"), event.value)\n        }),\n        \"emit done syncing initial value\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)({\n            type: \"done syncing initial value\"\n        })\n    },\n    guards: {\n        \"initial value synced\": ({ context })=>context.initialValueSynced,\n        \"is busy\": ({ context })=>!context.readOnly && (context.isProcessingLocalChanges || (isChangingRemotely(context.slateEditor) ?? !1)),\n        \"value changed while syncing\": ({ context, event })=>((0,xstate__WEBPACK_IMPORTED_MODULE_18__.assertEvent)(event, \"done syncing\"), context.pendingValue !== event.value),\n        \"pending value equals previous value\": ({ context })=>!(context.previousValue === void 0 && context.pendingValue === void 0) && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(context.pendingValue, context.previousValue)\n    },\n    actors: {\n        \"sync value\": syncValueLogic\n    }\n}).createMachine({\n    id: \"sync\",\n    context: ({ input })=>({\n            initialValueSynced: !1,\n            isProcessingLocalChanges: !1,\n            keyGenerator: input.keyGenerator,\n            schema: input.schema,\n            readOnly: input.readOnly,\n            slateEditor: input.slateEditor,\n            pendingValue: void 0,\n            previousValue: void 0\n        }),\n    on: {\n        \"has pending patches\": {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n                isProcessingLocalChanges: !0\n            })\n        },\n        mutation: {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n                isProcessingLocalChanges: !1\n            })\n        },\n        \"update readOnly\": {\n            actions: [\n                \"assign readOnly\"\n            ]\n        }\n    },\n    type: \"parallel\",\n    states: {\n        \"setting up\": {\n            initial: \"syncing initial value\",\n            states: {\n                \"syncing initial value\": {\n                    always: {\n                        guard: \"initial value synced\",\n                        target: \"done syncing initial value\"\n                    }\n                },\n                \"done syncing initial value\": {\n                    entry: [\n                        \"emit done syncing initial value\"\n                    ],\n                    type: \"final\"\n                }\n            }\n        },\n        syncing: {\n            initial: \"idle\",\n            states: {\n                idle: {\n                    on: {\n                        \"update value\": [\n                            {\n                                guard: \"is busy\",\n                                target: \"busy\",\n                                actions: [\n                                    \"assign pending value\"\n                                ]\n                            },\n                            {\n                                target: \"syncing\",\n                                actions: [\n                                    \"assign pending value\"\n                                ]\n                            }\n                        ]\n                    }\n                },\n                busy: {\n                    after: {\n                        1e3: [\n                            {\n                                guard: \"is busy\",\n                                reenter: !0\n                            },\n                            {\n                                target: \"syncing\"\n                            }\n                        ]\n                    },\n                    on: {\n                        \"update value\": [\n                            {\n                                actions: [\n                                    \"assign pending value\"\n                                ]\n                            }\n                        ]\n                    }\n                },\n                syncing: {\n                    always: {\n                        guard: \"pending value equals previous value\",\n                        target: \"idle\",\n                        actions: [\n                            \"clear pending value\",\n                            \"assign initial value synced\"\n                        ]\n                    },\n                    invoke: {\n                        src: \"sync value\",\n                        id: \"sync value\",\n                        input: ({ context })=>({\n                                context: {\n                                    keyGenerator: context.keyGenerator,\n                                    previousValue: context.previousValue,\n                                    readOnly: context.readOnly,\n                                    schema: context.schema\n                                },\n                                slateEditor: context.slateEditor,\n                                streamBlocks: !context.initialValueSynced,\n                                value: context.pendingValue\n                            })\n                    },\n                    on: {\n                        \"update value\": {\n                            actions: [\n                                \"assign pending value\"\n                            ]\n                        },\n                        patch: {\n                            actions: [\n                                (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                            ]\n                        },\n                        \"invalid value\": {\n                            actions: [\n                                (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                            ]\n                        },\n                        \"value changed\": {\n                            actions: [\n                                (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                            ]\n                        },\n                        \"done syncing\": [\n                            {\n                                guard: \"value changed while syncing\",\n                                actions: [\n                                    \"assign previous value\",\n                                    \"assign initial value synced\"\n                                ],\n                                reenter: !0\n                            },\n                            {\n                                target: \"idle\",\n                                actions: [\n                                    \"clear pending value\",\n                                    \"assign previous value\",\n                                    \"assign initial value synced\"\n                                ]\n                            }\n                        ]\n                    }\n                }\n            }\n        }\n    }\n}), debug$i = debugWithName(\"hook:useSyncValue\");\nasync function updateValue({ context, sendBack, slateEditor, streamBlocks, value }) {\n    let isChanged = !1, isValid = !0;\n    const hadSelection = !!slateEditor.selection;\n    if ((!value || value.length === 0) && (debug$i(\"Value is empty\"), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, ()=>{\n        withoutSaving(slateEditor, ()=>{\n            withoutPatching(slateEditor, ()=>{\n                hadSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor);\n                const childrenLength = slateEditor.children.length;\n                slateEditor.children.forEach((_, index)=>{\n                    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n                        at: [\n                            childrenLength - 1 - index\n                        ]\n                    });\n                }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n                    decorators: []\n                }), {\n                    at: [\n                        0\n                    ]\n                }), hadSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, [\n                    0,\n                    0\n                ]);\n            });\n        });\n    }), isChanged = !0), value && value.length > 0) {\n        const slateValueFromProps = toSlateValue(value, {\n            schemaTypes: context.schema\n        });\n        await new Promise((resolve)=>{\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, ()=>{\n                withRemoteChanges(slateEditor, ()=>{\n                    withoutPatching(slateEditor, async ()=>{\n                        const childrenLength = slateEditor.children.length;\n                        if (slateValueFromProps.length < childrenLength) {\n                            for(let i = childrenLength - 1; i > slateValueFromProps.length - 1; i--)slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n                                at: [\n                                    i\n                                ]\n                            });\n                            isChanged = !0;\n                        }\n                        for await (const [currentBlock, currentBlockIndex] of getBlocks({\n                            slateValue: slateValueFromProps,\n                            streamBlocks\n                        })){\n                            const { blockChanged, blockValid } = syncBlock({\n                                context,\n                                sendBack,\n                                block: currentBlock,\n                                index: currentBlockIndex,\n                                slateEditor,\n                                value\n                            });\n                            isChanged = blockChanged || isChanged, isValid = isValid && blockValid;\n                        }\n                        resolve();\n                    });\n                });\n            });\n        });\n    }\n    if (!isValid) {\n        debug$i(\"Invalid value, returning\"), sendBack({\n            type: \"done syncing\",\n            value\n        });\n        return;\n    }\n    if (isChanged) {\n        debug$i(\"Server value changed, syncing editor\");\n        try {\n            slateEditor.onChange();\n        } catch (err) {\n            console.error(err), sendBack({\n                type: \"invalid value\",\n                resolution: null,\n                value\n            }), sendBack({\n                type: \"done syncing\",\n                value\n            });\n            return;\n        }\n        hadSelection && !slateEditor.selection && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, {\n            anchor: {\n                path: [\n                    0,\n                    0\n                ],\n                offset: 0\n            },\n            focus: {\n                path: [\n                    0,\n                    0\n                ],\n                offset: 0\n            }\n        }), slateEditor.onChange()), sendBack({\n            type: \"value changed\",\n            value\n        });\n    } else debug$i(\"Server value and editor value is equal, no need to sync.\");\n    sendBack({\n        type: \"done syncing\",\n        value\n    });\n}\nasync function* getBlocks({ slateValue, streamBlocks }) {\n    let index = 0;\n    for await (const block of slateValue)streamBlocks && await new Promise((resolve)=>setTimeout(resolve, 0)), yield [\n        block,\n        index\n    ], index++;\n}\nfunction syncBlock({ context, sendBack, block, index, slateEditor, value }) {\n    let blockChanged = !1, blockValid = !0;\n    const currentBlock = block, currentBlockIndex = index, oldBlock = slateEditor.children[currentBlockIndex], hasChanges = oldBlock && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(currentBlock, oldBlock);\n    return slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(slateEditor, ()=>{\n        withRemoteChanges(slateEditor, ()=>{\n            withoutPatching(slateEditor, ()=>{\n                if (hasChanges && blockValid) {\n                    const validationValue = [\n                        value[currentBlockIndex]\n                    ], validation = validateValue(validationValue, context.schema, context.keyGenerator);\n                    !validation.valid && validation.resolution?.autoResolve && validation.resolution?.patches.length > 0 && !context.readOnly && context.previousValue && context.previousValue !== value && (console.warn(`${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`), validation.resolution.patches.forEach((patch)=>{\n                        sendBack({\n                            type: \"patch\",\n                            patch\n                        });\n                    })), validation.valid || validation.resolution?.autoResolve ? (oldBlock._key === currentBlock._key ? (debug$i.enabled && debug$i(\"Updating block\", oldBlock, currentBlock), _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex)) : (debug$i.enabled && debug$i(\"Replacing block\", oldBlock, currentBlock), _replaceBlock(slateEditor, currentBlock, currentBlockIndex)), blockChanged = !0) : (sendBack({\n                        type: \"invalid value\",\n                        resolution: validation.resolution,\n                        value\n                    }), blockValid = !1);\n                }\n                if (!oldBlock && blockValid) {\n                    const validationValue = [\n                        value[currentBlockIndex]\n                    ], validation = validateValue(validationValue, context.schema, context.keyGenerator);\n                    debug$i.enabled && debug$i(\"Validating and inserting new block in the end of the value\", currentBlock), validation.valid || validation.resolution?.autoResolve ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlock, {\n                        at: [\n                            currentBlockIndex\n                        ]\n                    }) : (debug$i(\"Invalid\", validation), sendBack({\n                        type: \"invalid value\",\n                        resolution: validation.resolution,\n                        value\n                    }), blockValid = !1);\n                }\n            });\n        });\n    }), {\n        blockChanged,\n        blockValid\n    };\n}\nfunction _replaceBlock(slateEditor, currentBlock, currentBlockIndex) {\n    const currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === currentBlockIndex;\n    selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n        at: [\n            currentBlockIndex\n        ]\n    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlock, {\n        at: [\n            currentBlockIndex\n        ]\n    }), slateEditor.onChange(), selectionFocusOnBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, currentSelection);\n}\nfunction _updateBlock(slateEditor, currentBlock, oldBlock, currentBlockIndex) {\n    if (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, currentBlock, {\n        at: [\n            currentBlockIndex\n        ]\n    }), slateEditor.isTextBlock(currentBlock) && slateEditor.isTextBlock(oldBlock)) {\n        const oldBlockChildrenLength = oldBlock.children.length;\n        currentBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - currentBlock.children.length)).forEach((_, index)=>{\n            const childIndex = oldBlockChildrenLength - 1 - index;\n            childIndex > 0 && (debug$i(\"Removing child\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n                at: [\n                    currentBlockIndex,\n                    childIndex\n                ]\n            }));\n        }), currentBlock.children.forEach((currentBlockChild, currentBlockChildIndex)=>{\n            const oldBlockChild = oldBlock.children[currentBlockChildIndex], isChildChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(currentBlockChild, oldBlockChild), isTextChanged = !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(currentBlockChild.text, oldBlockChild?.text), path = [\n                currentBlockIndex,\n                currentBlockChildIndex\n            ];\n            if (isChildChanged) if (currentBlockChild._key === oldBlockChild?._key) {\n                debug$i(\"Updating changed child\", currentBlockChild, oldBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, currentBlockChild, {\n                    at: path\n                });\n                const isSpanNode = slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(currentBlockChild) && currentBlockChild._type === \"span\" && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(oldBlockChild) && oldBlockChild._type === \"span\";\n                isSpanNode && isTextChanged ? (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(slateEditor, {\n                    at: {\n                        focus: {\n                            path,\n                            offset: 0\n                        },\n                        anchor: {\n                            path,\n                            offset: oldBlockChild.text.length\n                        }\n                    }\n                }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertText(slateEditor, currentBlockChild.text, {\n                    at: path\n                }), slateEditor.onChange()) : isSpanNode || (debug$i(\"Updating changed inline object child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(slateEditor, {\n                    _key: VOID_CHILD_KEY\n                }, {\n                    at: [\n                        ...path,\n                        0\n                    ],\n                    voids: !0\n                }));\n            } else oldBlockChild ? (debug$i(\"Replacing child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(slateEditor, {\n                at: [\n                    currentBlockIndex,\n                    currentBlockChildIndex\n                ]\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n                at: [\n                    currentBlockIndex,\n                    currentBlockChildIndex\n                ]\n            }), slateEditor.onChange()) : oldBlockChild || (debug$i(\"Inserting new child\", currentBlockChild), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, currentBlockChild, {\n                at: [\n                    currentBlockIndex,\n                    currentBlockChildIndex\n                ]\n            }), slateEditor.onChange());\n        });\n    }\n}\nconst debug$h = debugWithName(\"component:PortableTextEditor:Synchronizer\");\nfunction Synchronizer(props) {\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(40), { editorActor, slateEditor } = props, value = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useSelector)(props.editorActor, _temp), readOnly = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useSelector)(props.editorActor, _temp2);\n    let t0;\n    $[0] !== props.editorActor ? (t0 = props.editorActor.getSnapshot(), $[0] = props.editorActor, $[1] = t0) : t0 = $[1];\n    const t1 = t0.context.keyGenerator;\n    let t2;\n    $[2] !== props.editorActor ? (t2 = props.editorActor.getSnapshot().matches({\n        \"edit mode\": \"read only\"\n    }), $[2] = props.editorActor, $[3] = t2) : t2 = $[3];\n    let t3;\n    $[4] !== props.editorActor ? (t3 = props.editorActor.getSnapshot(), $[4] = props.editorActor, $[5] = t3) : t3 = $[5];\n    let t4;\n    $[6] !== slateEditor || $[7] !== t0.context.keyGenerator || $[8] !== t2 || $[9] !== t3.context.schema ? (t4 = {\n        input: {\n            keyGenerator: t1,\n            readOnly: t2,\n            schema: t3.context.schema,\n            slateEditor\n        }\n    }, $[6] = slateEditor, $[7] = t0.context.keyGenerator, $[8] = t2, $[9] = t3.context.schema, $[10] = t4) : t4 = $[10];\n    const syncActorRef = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useActorRef)(syncMachine, t4);\n    let t5;\n    $[11] !== editorActor ? (t5 = editorActor.getSnapshot(), $[11] = editorActor, $[12] = t5) : t5 = $[12];\n    let t6;\n    $[13] !== slateEditor || $[14] !== t5.context.schema ? (t6 = {\n        input: {\n            schema: t5.context.schema,\n            slateEditor\n        }\n    }, $[13] = slateEditor, $[14] = t5.context.schema, $[15] = t6) : t6 = $[15];\n    const mutationActorRef = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useActorRef)(mutationMachine, t6);\n    let t7, t8;\n    $[16] !== editorActor || $[17] !== mutationActorRef || $[18] !== syncActorRef ? (t7 = ()=>{\n        const subscription = mutationActorRef.on(\"*\", (event)=>{\n            event.type === \"has pending patches\" && syncActorRef.send({\n                type: \"has pending patches\"\n            }), event.type === \"mutation\" && (syncActorRef.send({\n                type: \"mutation\"\n            }), editorActor.send({\n                type: \"mutation\",\n                patches: event.patches,\n                snapshot: event.snapshot,\n                value: event.snapshot\n            }));\n        });\n        return ()=>{\n            subscription.unsubscribe();\n        };\n    }, t8 = [\n        mutationActorRef,\n        syncActorRef,\n        editorActor\n    ], $[16] = editorActor, $[17] = mutationActorRef, $[18] = syncActorRef, $[19] = t7, $[20] = t8) : (t7 = $[19], t8 = $[20]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t7, t8);\n    let t10, t9;\n    $[21] !== props.editorActor || $[22] !== syncActorRef ? (t9 = ()=>{\n        const subscription_0 = syncActorRef.on(\"*\", (event_0)=>{\n            props.editorActor.send(event_0);\n        });\n        return ()=>{\n            subscription_0.unsubscribe();\n        };\n    }, t10 = [\n        props.editorActor,\n        syncActorRef\n    ], $[21] = props.editorActor, $[22] = syncActorRef, $[23] = t10, $[24] = t9) : (t10 = $[23], t9 = $[24]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t9, t10);\n    let t11, t12;\n    $[25] !== readOnly || $[26] !== syncActorRef ? (t11 = ()=>{\n        syncActorRef.send({\n            type: \"update readOnly\",\n            readOnly\n        });\n    }, t12 = [\n        syncActorRef,\n        readOnly\n    ], $[25] = readOnly, $[26] = syncActorRef, $[27] = t11, $[28] = t12) : (t11 = $[27], t12 = $[28]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t11, t12);\n    let t13, t14;\n    $[29] !== syncActorRef || $[30] !== value ? (t13 = ()=>{\n        debug$h(\"Value from props changed, syncing new value\"), syncActorRef.send({\n            type: \"update value\",\n            value\n        });\n    }, t14 = [\n        syncActorRef,\n        value\n    ], $[29] = syncActorRef, $[30] = value, $[31] = t13, $[32] = t14) : (t13 = $[31], t14 = $[32]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t13, t14);\n    let t15;\n    $[33] !== editorActor || $[34] !== mutationActorRef ? (t15 = ()=>{\n        debug$h(\"Subscribing to patch events\");\n        const sub = editorActor.on(\"patch\", (event_1)=>{\n            mutationActorRef.send(event_1);\n        });\n        return ()=>{\n            debug$h(\"Unsubscribing to patch events\"), sub.unsubscribe();\n        };\n    }, $[33] = editorActor, $[34] = mutationActorRef, $[35] = t15) : t15 = $[35];\n    let t16;\n    return $[36] !== editorActor || $[37] !== mutationActorRef || $[38] !== slateEditor ? (t16 = [\n        editorActor,\n        mutationActorRef,\n        slateEditor\n    ], $[36] = editorActor, $[37] = mutationActorRef, $[38] = slateEditor, $[39] = t16) : t16 = $[39], (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t15, t16), null;\n}\nfunction _temp2(s_0) {\n    return s_0.matches({\n        \"edit mode\": \"read only\"\n    });\n}\nfunction _temp(s) {\n    return s.context.value;\n}\nSynchronizer.displayName = \"Synchronizer\";\nconst debug$g = debugWithName(\"operationToPatches\");\nfunction createOperationToPatches(types) {\n    const textBlockName = types.block.name;\n    function insertTextPatch(editor, operation, beforeValue) {\n        debug$g.enabled && debug$g(\"Operation\", JSON.stringify(operation, null, 2));\n        const block = editor.isTextBlock(editor.children[operation.path[0]]) && editor.children[operation.path[0]];\n        if (!block) throw new Error(\"Could not find block\");\n        const textChild = editor.isTextBlock(block) && editor.isTextSpan(block.children[operation.path[1]]) && block.children[operation.path[1]];\n        if (!textChild) throw new Error(\"Could not find child\");\n        const path = [\n            {\n                _key: block._key\n            },\n            \"children\",\n            {\n                _key: textChild._key\n            },\n            \"text\"\n        ], prevBlock = beforeValue[operation.path[0]], prevChild = editor.isTextBlock(prevBlock) && prevBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevChild) ? prevChild.text : \"\", patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.diffMatchPatch)(prevText, textChild.text, path);\n        return patch.value.length ? [\n            patch\n        ] : [];\n    }\n    function removeTextPatch(editor, operation, beforeValue) {\n        const block = editor && editor.children[operation.path[0]];\n        if (!block) throw new Error(\"Could not find block\");\n        const child = editor.isTextBlock(block) && block.children[operation.path[1]] || void 0, textChild = editor.isTextSpan(child) ? child : void 0;\n        if (child && !textChild) throw new Error(\"Expected span\");\n        if (!textChild) throw new Error(\"Could not find child\");\n        const path = [\n            {\n                _key: block._key\n            },\n            \"children\",\n            {\n                _key: textChild._key\n            },\n            \"text\"\n        ], beforeBlock = beforeValue[operation.path[0]], prevTextChild = editor.isTextBlock(beforeBlock) && beforeBlock.children[operation.path[1]], prevText = editor.isTextSpan(prevTextChild) && prevTextChild.text, patch = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.diffMatchPatch)(prevText || \"\", textChild.text, path);\n        return patch.value ? [\n            patch\n        ] : [];\n    }\n    function setNodePatch(editor, operation) {\n        if (operation.path.length === 1) {\n            const block = editor.children[operation.path[0]];\n            if (typeof block._key != \"string\") throw new Error(\"Expected block to have a _key\");\n            const setNode = lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_12__({\n                ...editor.children[operation.path[0]],\n                ...operation.newProperties\n            }, lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_11__);\n            return [\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(fromSlateValue([\n                    setNode\n                ], textBlockName)[0], [\n                    {\n                        _key: block._key\n                    }\n                ])\n            ];\n        } else if (operation.path.length === 2) {\n            const block = editor.children[operation.path[0]];\n            if (editor.isTextBlock(block)) {\n                const child = block.children[operation.path[1]];\n                if (child) {\n                    const blockKey = block._key, childKey = child._key, patches = [], keys = Object.keys(operation.newProperties);\n                    return keys.forEach((keyName)=>{\n                        if (keys.length === 1 && keyName === \"_key\") {\n                            const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_10__(operation.newProperties, keyName);\n                            patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(val, [\n                                {\n                                    _key: blockKey\n                                },\n                                \"children\",\n                                block.children.indexOf(child),\n                                keyName\n                            ]));\n                        } else {\n                            const val = lodash_get_js__WEBPACK_IMPORTED_MODULE_10__(operation.newProperties, keyName);\n                            patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(val, [\n                                {\n                                    _key: blockKey\n                                },\n                                \"children\",\n                                {\n                                    _key: childKey\n                                },\n                                keyName\n                            ]));\n                        }\n                    }), patches;\n                }\n                throw new Error(\"Could not find a valid child\");\n            }\n            throw new Error(\"Could not find a valid block\");\n        } else throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);\n    }\n    function insertNodePatch(editor, operation, beforeValue) {\n        const block = beforeValue[operation.path[0]], isTextBlock = editor.isTextBlock(block);\n        if (operation.path.length === 1) {\n            const position = operation.path[0] === 0 ? \"before\" : \"after\", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key;\n            return targetKey ? [\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([\n                    fromSlateValue([\n                        operation.node\n                    ], textBlockName)[0]\n                ], position, [\n                    {\n                        _key: targetKey\n                    }\n                ])\n            ] : [\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.setIfMissing)(beforeValue, []),\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([\n                    fromSlateValue([\n                        operation.node\n                    ], textBlockName)[0]\n                ], \"before\", [\n                    operation.path[0]\n                ])\n            ];\n        } else if (isTextBlock && operation.path.length === 2 && editor.children[operation.path[0]]) {\n            const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? \"before\" : \"after\", node = {\n                ...operation.node\n            };\n            !node._type && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node) && (node._type = \"span\", node.marks = []);\n            const child = fromSlateValue([\n                {\n                    _key: \"bogus\",\n                    _type: textBlockName,\n                    children: [\n                        node\n                    ]\n                }\n            ], textBlockName)[0].children[0];\n            return [\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([\n                    child\n                ], position, [\n                    {\n                        _key: block._key\n                    },\n                    \"children\",\n                    block.children.length <= 1 || !block.children[operation.path[1] - 1] ? 0 : {\n                        _key: block.children[operation.path[1] - 1]._key\n                    }\n                ])\n            ];\n        }\n        return debug$g(\"Something was inserted into a void block. Not producing editor patches.\"), [];\n    }\n    function splitNodePatch(editor, operation, beforeValue) {\n        const patches = [], splitBlock = editor.children[operation.path[0]];\n        if (!editor.isTextBlock(splitBlock)) throw new Error(`Block with path ${JSON.stringify(operation.path[0])} is not a text block and can't be split`);\n        if (operation.path.length === 1) {\n            const oldBlock = beforeValue[operation.path[0]];\n            if (editor.isTextBlock(oldBlock)) {\n                const targetValue = fromSlateValue([\n                    editor.children[operation.path[0] + 1]\n                ], textBlockName)[0];\n                targetValue && (patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([\n                    targetValue\n                ], \"after\", [\n                    {\n                        _key: splitBlock._key\n                    }\n                ])), oldBlock.children.slice(operation.position).forEach((span)=>{\n                    const path = [\n                        {\n                            _key: oldBlock._key\n                        },\n                        \"children\",\n                        {\n                            _key: span._key\n                        }\n                    ];\n                    patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)(path));\n                }));\n            }\n            return patches;\n        }\n        if (operation.path.length === 2) {\n            const splitSpan = splitBlock.children[operation.path[1]];\n            if (editor.isTextSpan(splitSpan)) {\n                const targetSpans = fromSlateValue([\n                    {\n                        ...splitBlock,\n                        children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)\n                    }\n                ], textBlockName)[0].children;\n                patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)(targetSpans, \"after\", [\n                    {\n                        _key: splitBlock._key\n                    },\n                    \"children\",\n                    {\n                        _key: splitSpan._key\n                    }\n                ])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(splitSpan.text, [\n                    {\n                        _key: splitBlock._key\n                    },\n                    \"children\",\n                    {\n                        _key: splitSpan._key\n                    },\n                    \"text\"\n                ]));\n            }\n            return patches;\n        }\n        return patches;\n    }\n    function removeNodePatch(editor, operation, beforeValue) {\n        const block = beforeValue[operation.path[0]];\n        if (operation.path.length === 1) {\n            if (block && block._key) return [\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                    {\n                        _key: block._key\n                    }\n                ])\n            ];\n            throw new Error(\"Block not found\");\n        } else if (editor.isTextBlock(block) && operation.path.length === 2) {\n            const spanToRemove = block.children[operation.path[1]];\n            return spanToRemove ? block.children.filter((span)=>span._key === operation.node._key).length > 1 ? (console.warn(`Multiple spans have \\`_key\\` ${operation.node._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)), []) : [\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                    {\n                        _key: block._key\n                    },\n                    \"children\",\n                    {\n                        _key: spanToRemove._key\n                    }\n                ])\n            ] : (debug$g(\"Span not found in editor trying to remove node\"), []);\n        } else return debug$g(\"Not creating patch inside object block\"), [];\n    }\n    function mergeNodePatch(editor, operation, beforeValue) {\n        const patches = [], block = beforeValue[operation.path[0]], updatedBlock = editor.children[operation.path[0]];\n        if (operation.path.length === 1) if (block?._key) {\n            const newBlock = fromSlateValue([\n                editor.children[operation.path[0] - 1]\n            ], textBlockName)[0];\n            patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(newBlock, [\n                {\n                    _key: newBlock._key\n                }\n            ])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                {\n                    _key: block._key\n                }\n            ]));\n        } else throw new Error(\"Target key not found!\");\n        else if (editor.isTextBlock(block) && editor.isTextBlock(updatedBlock) && operation.path.length === 2) {\n            const updatedSpan = updatedBlock.children[operation.path[1] - 1] && editor.isTextSpan(updatedBlock.children[operation.path[1] - 1]) ? updatedBlock.children[operation.path[1] - 1] : void 0, removedSpan = block.children[operation.path[1]] && editor.isTextSpan(block.children[operation.path[1]]) ? block.children[operation.path[1]] : void 0;\n            updatedSpan && (block.children.filter((span)=>span._key === updatedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.set)(updatedSpan.text, [\n                {\n                    _key: block._key\n                },\n                \"children\",\n                {\n                    _key: updatedSpan._key\n                },\n                \"text\"\n            ])) : console.warn(`Multiple spans have \\`_key\\` ${updatedSpan._key}. It's ambiguous which one to update.`, JSON.stringify(block, null, 2))), removedSpan && (block.children.filter((span)=>span._key === removedSpan._key).length === 1 ? patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                {\n                    _key: block._key\n                },\n                \"children\",\n                {\n                    _key: removedSpan._key\n                }\n            ])) : console.warn(`Multiple spans have \\`_key\\` ${removedSpan._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)));\n        } else debug$g(\"Void nodes can't be merged, not creating any patches\");\n        return patches;\n    }\n    function moveNodePatch(editor, operation, beforeValue) {\n        const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];\n        if (!targetBlock) return patches;\n        if (operation.path.length === 1) {\n            const position = operation.path[0] > operation.newPath[0] ? \"before\" : \"after\";\n            patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                {\n                    _key: block._key\n                }\n            ])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([\n                fromSlateValue([\n                    block\n                ], textBlockName)[0]\n            ], position, [\n                {\n                    _key: targetBlock._key\n                }\n            ]));\n        } else if (operation.path.length === 2 && editor.isTextBlock(block) && editor.isTextBlock(targetBlock)) {\n            const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? \"after\" : \"before\", childToInsert = fromSlateValue([\n                block\n            ], textBlockName)[0].children[operation.path[1]];\n            patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([\n                {\n                    _key: block._key\n                },\n                \"children\",\n                {\n                    _key: child._key\n                }\n            ])), patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)([\n                childToInsert\n            ], position, [\n                {\n                    _key: targetBlock._key\n                },\n                \"children\",\n                {\n                    _key: targetChild._key\n                }\n            ]));\n        }\n        return patches;\n    }\n    return {\n        insertNodePatch,\n        insertTextPatch,\n        mergeNodePatch,\n        moveNodePatch,\n        removeNodePatch,\n        removeTextPatch,\n        setNodePatch,\n        splitNodePatch\n    };\n}\nfunction createWithEventListeners(editorActor, subscriptions) {\n    return function(editor) {\n        return editorActor.getSnapshot().context.maxBlocks !== void 0 || (subscriptions.push(()=>{\n            const subscription = editorActor.on(\"*\", (event)=>{\n                switch(event.type){\n                    case \"annotation.add\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"annotation.add\",\n                                    annotation: event.annotation\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"annotation.remove\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"annotation.remove\",\n                                    annotation: event.annotation\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"annotation.toggle\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"annotation.toggle\",\n                                    annotation: event.annotation\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"blur\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"blur\"\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"decorator.add\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"decorator.add\",\n                                    decorator: event.decorator\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"decorator.remove\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"decorator.remove\",\n                                    decorator: event.decorator\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"decorator.toggle\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"decorator.toggle\",\n                                    decorator: event.decorator\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"focus\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"focus\"\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"insert.block object\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"insert.block object\",\n                                    placement: event.placement,\n                                    blockObject: event.blockObject\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"insert.inline object\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"insert.inline object\",\n                                    inlineObject: event.inlineObject\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"list item.toggle\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"list item.toggle\",\n                                    listItem: event.listItem\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                    case \"style.toggle\":\n                        {\n                            editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"style.toggle\",\n                                    style: event.style\n                                },\n                                editor\n                            });\n                            break;\n                        }\n                }\n            });\n            return ()=>{\n                subscription.unsubscribe();\n            };\n        }), editor.addMark = (mark)=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"decorator.add\",\n                    decorator: mark\n                },\n                editor\n            });\n        }, editor.removeMark = (mark)=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"decorator.remove\",\n                    decorator: mark\n                },\n                editor\n            });\n        }, editor.deleteBackward = (unit)=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"delete.backward\",\n                    unit\n                },\n                editor\n            });\n        }, editor.deleteForward = (unit)=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"delete.forward\",\n                    unit\n                },\n                editor\n            });\n        }, editor.insertBreak = ()=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"insert.break\"\n                },\n                editor\n            });\n        }, editor.insertSoftBreak = ()=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"insert.soft break\"\n                },\n                editor\n            });\n        }, editor.insertText = (text, options)=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"insert.text\",\n                    text,\n                    options\n                },\n                editor\n            });\n        }), editor;\n    };\n}\nfunction createWithMaxBlocks(editorActor) {\n    return function(editor) {\n        const { apply: apply2 } = editor;\n        return editor.apply = (operation)=>{\n            if (editorActor.getSnapshot().matches({\n                \"edit mode\": \"read only\"\n            })) {\n                apply2(operation);\n                return;\n            }\n            if (isChangingRemotely(editor)) {\n                apply2(operation);\n                return;\n            }\n            if (isUndoing(editor) || isRedoing(editor)) {\n                apply2(operation);\n                return;\n            }\n            const rows = editorActor.getSnapshot().context.maxBlocks ?? -1;\n            rows > 0 && editor.children.length >= rows && (operation.type === \"insert_node\" || operation.type === \"split_node\") && operation.path.length === 1 || apply2(operation);\n        }, editor;\n    };\n}\nfunction createWithObjectKeys(editorActor, schemaTypes) {\n    return function(editor) {\n        const { apply: apply2, normalizeNode } = editor;\n        return editor.apply = (operation)=>{\n            if (isChangingRemotely(editor)) {\n                apply2(operation);\n                return;\n            }\n            if (isUndoing(editor) || isRedoing(editor)) {\n                apply2(operation);\n                return;\n            }\n            if (operation.type === \"split_node\") {\n                apply2({\n                    ...operation,\n                    properties: {\n                        ...operation.properties,\n                        _key: editorActor.getSnapshot().context.keyGenerator()\n                    }\n                });\n                return;\n            }\n            if (operation.type === \"insert_node\" && !slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(operation.node)) {\n                apply2({\n                    ...operation,\n                    node: {\n                        ...operation.node,\n                        _key: editorActor.getSnapshot().context.keyGenerator()\n                    }\n                });\n                return;\n            }\n            apply2(operation);\n        }, editor.normalizeNode = (entry)=>{\n            const [node, path] = entry;\n            if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node) && node._type === schemaTypes.block.name) {\n                if (!node._key) {\n                    editorActor.send({\n                        type: \"normalizing\"\n                    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                        _key: editorActor.getSnapshot().context.keyGenerator()\n                    }, {\n                        at: path\n                    }), editorActor.send({\n                        type: \"done normalizing\"\n                    });\n                    return;\n                }\n                for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path))if (!child._key) {\n                    editorActor.send({\n                        type: \"normalizing\"\n                    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                        _key: editorActor.getSnapshot().context.keyGenerator()\n                    }, {\n                        at: childPath\n                    }), editorActor.send({\n                        type: \"done normalizing\"\n                    });\n                    return;\n                }\n            }\n            normalizeNode(entry);\n        }, editor;\n    };\n}\nconst debug$f = debugWithName(\"applyPatches\"), debugVerbose$2 = debug$f.enabled && !0;\nfunction createApplyPatch(schemaTypes) {\n    return (editor, patch)=>{\n        let changed = !1;\n        debugVerbose$2 && (debug$f(`\n\nNEW PATCH =============================================================`), debug$f(JSON.stringify(patch, null, 2)));\n        try {\n            switch(patch.type){\n                case \"insert\":\n                    changed = insertPatch(editor, patch, schemaTypes);\n                    break;\n                case \"unset\":\n                    changed = unsetPatch(editor, patch);\n                    break;\n                case \"set\":\n                    changed = setPatch(editor, patch);\n                    break;\n                case \"diffMatchPatch\":\n                    changed = diffMatchPatch(editor, patch);\n                    break;\n                default:\n                    debug$f(\"Unhandled patch\", patch.type);\n            }\n        } catch (err) {\n            console.error(err);\n        }\n        return changed;\n    };\n}\nfunction diffMatchPatch(editor, patch) {\n    const { block, child, childPath } = findBlockAndChildFromPath(editor, patch.path);\n    if (!block) return debug$f(\"Block not found\"), !1;\n    if (!child || !childPath) return debug$f(\"Child not found\"), !1;\n    if (!(block && editor.isTextBlock(block) && patch.path.length === 4 && patch.path[1] === \"children\" && patch.path[3] === \"text\") || !slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child)) return !1;\n    const patches = parse(patch.value), [newValue] = apply(patches, child.text, {\n        allowExceedingIndices: !0\n    }), diff$1 = cleanupEfficiency(diff(child.text, newValue), 5);\n    debugState(editor, \"before\");\n    let offset = 0;\n    for (const [op, text] of diff$1)op === DIFF_INSERT ? (editor.apply({\n        type: \"insert_text\",\n        path: childPath,\n        offset,\n        text\n    }), offset += text.length) : op === DIFF_DELETE ? editor.apply({\n        type: \"remove_text\",\n        path: childPath,\n        offset,\n        text\n    }) : op === DIFF_EQUAL && (offset += text.length);\n    return debugState(editor, \"after\"), !0;\n}\nfunction insertPatch(editor, patch, schemaTypes) {\n    const { block: targetBlock, child: targetChild, blockPath: targetBlockPath, childPath: targetChildPath } = findBlockAndChildFromPath(editor, patch.path);\n    if (!targetBlock || !targetBlockPath) return debug$f(\"Block not found\"), !1;\n    if (patch.path.length > 1 && patch.path[1] !== \"children\") return debug$f(\"Ignoring patch targeting void value\"), !1;\n    if (patch.path.length === 1) {\n        const { items: items2, position: position2 } = patch, blocksToInsert = toSlateValue(items2, {\n            schemaTypes\n        }, KEY_TO_SLATE_ELEMENT.get(editor)), targetBlockIndex = targetBlockPath[0], normalizedIdx2 = position2 === \"after\" ? targetBlockIndex + 1 : targetBlockIndex;\n        return debug$f(`Inserting blocks at path [${normalizedIdx2}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, blocksToInsert, {\n            at: [\n                normalizedIdx2\n            ]\n        }), debugState(editor, \"after\"), !0;\n    }\n    const { items, position } = patch;\n    if (!targetChild || !targetChildPath) return debug$f(\"Child not found\"), !1;\n    const childrenToInsert = targetBlock && toSlateValue([\n        {\n            ...targetBlock,\n            children: items\n        }\n    ], {\n        schemaTypes\n    }, KEY_TO_SLATE_ELEMENT.get(editor)), targetChildIndex = targetChildPath[1], normalizedIdx = position === \"after\" ? targetChildIndex + 1 : targetChildIndex, childInsertPath = [\n        targetChildPath[0],\n        normalizedIdx\n    ];\n    return debug$f(`Inserting children at path ${childInsertPath}`), debugState(editor, \"before\"), childrenToInsert && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(childrenToInsert[0]) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, childrenToInsert[0].children, {\n        at: childInsertPath\n    }), debugState(editor, \"after\"), !0;\n}\nfunction setPatch(editor, patch) {\n    let value = patch.value;\n    typeof patch.path[3] == \"string\" && (value = {}, value[patch.path[3]] = patch.value);\n    const { block, blockPath, child, childPath } = findBlockAndChildFromPath(editor, patch.path);\n    if (!block) return debug$f(\"Block not found\"), !1;\n    const isTextBlock = editor.isTextBlock(block);\n    if (isTextBlock && patch.path.length > 1 && patch.path[1] !== \"children\") return debug$f(\"Ignoring setting void value\"), !1;\n    if (debugState(editor, \"before\"), isTextBlock && child && childPath) {\n        if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(value) && slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child)) {\n            const newText = child.text;\n            value.text !== newText && (debug$f(\"Setting text property\"), editor.apply({\n                type: \"remove_text\",\n                path: childPath,\n                offset: 0,\n                text: newText\n            }), editor.apply({\n                type: \"insert_text\",\n                path: childPath,\n                offset: 0,\n                text: value.text\n            }), editor.onChange());\n        } else debug$f(\"Setting non-text property\"), editor.apply({\n            type: \"set_node\",\n            path: childPath,\n            properties: {},\n            newProperties: value\n        });\n        return !0;\n    } else if (slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && patch.path.length === 1 && blockPath) {\n        debug$f(\"Setting block property\");\n        const { children, ...nextRest } = value, { children: prevChildren, ...prevRest } = block || {\n            children: void 0\n        };\n        editor.apply({\n            type: \"set_node\",\n            path: blockPath,\n            properties: {\n                ...prevRest\n            },\n            newProperties: nextRest\n        }), debug$f(\"Setting children\"), block.children.forEach((c2, cIndex)=>{\n            editor.apply({\n                type: \"remove_node\",\n                path: blockPath.concat(block.children.length - 1 - cIndex),\n                node: c2\n            });\n        }), Array.isArray(children) && children.forEach((c2, cIndex)=>{\n            editor.apply({\n                type: \"insert_node\",\n                path: blockPath.concat(cIndex),\n                node: c2\n            });\n        });\n    } else if (block && \"value\" in block) {\n        const newVal = (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.applyAll)([\n            block.value\n        ], [\n            patch\n        ])[0];\n        return slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            ...block,\n            value: newVal\n        }, {\n            at: blockPath\n        }), !0;\n    }\n    return debugState(editor, \"after\"), !0;\n}\nfunction unsetPatch(editor, patch) {\n    if (patch.path.length === 0) {\n        debug$f(\"Removing everything\"), debugState(editor, \"before\");\n        const previousSelection = editor.selection;\n        return slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.children.forEach((_child, i)=>{\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n                at: [\n                    i\n                ]\n            });\n        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, editor.pteCreateTextBlock({\n            decorators: []\n        })), previousSelection && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n            anchor: {\n                path: [\n                    0,\n                    0\n                ],\n                offset: 0\n            },\n            focus: {\n                path: [\n                    0,\n                    0\n                ],\n                offset: 0\n            }\n        }), editor.onChange(), debugState(editor, \"after\"), !0;\n    }\n    const { block, blockPath, child, childPath } = findBlockAndChildFromPath(editor, patch.path);\n    if (patch.path.length === 1) {\n        if (!block || !blockPath) return debug$f(\"Block not found\"), !1;\n        const blockIndex = blockPath[0];\n        return debug$f(`Removing block at path [${blockIndex}]`), debugState(editor, \"before\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n            at: [\n                blockIndex\n            ]\n        }), debugState(editor, \"after\"), !0;\n    }\n    return editor.isTextBlock(block) && patch.path[1] === \"children\" && patch.path.length === 3 ? !child || !childPath ? (debug$f(\"Child not found\"), !1) : (debug$f(`Unsetting child at path ${JSON.stringify(childPath)}`), debugState(editor, \"before\"), debugVerbose$2 && debug$f(`Removing child at path ${JSON.stringify(childPath)}`), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n        at: childPath\n    }), debugState(editor, \"after\"), !0) : !1;\n}\nfunction isKeyedSegment(segment) {\n    return typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction debugState(editor, stateName) {\n    debugVerbose$2 && (debug$f(`Children ${stateName}:`, JSON.stringify(editor.children, null, 2)), debug$f(`Selection ${stateName}: `, JSON.stringify(editor.selection, null, 2)));\n}\nfunction findBlockFromPath(editor, path) {\n    let blockIndex = -1;\n    const block = editor.children.find((node, index)=>{\n        const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index === path[0];\n        return isMatch && (blockIndex = index), isMatch;\n    });\n    return block ? {\n        block,\n        path: [\n            blockIndex\n        ]\n    } : {};\n}\nfunction findBlockAndChildFromPath(editor, path) {\n    const { block, path: blockPath } = findBlockFromPath(editor, path);\n    if (!(slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && path[1] === \"children\")) return {\n        block,\n        blockPath,\n        child: void 0,\n        childPath: void 0\n    };\n    let childIndex = -1;\n    const child = block.children.find((node, index)=>{\n        const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index === path[2];\n        return isMatch && (childIndex = index), isMatch;\n    });\n    return child ? {\n        block,\n        child,\n        blockPath,\n        childPath: blockPath?.concat(childIndex)\n    } : {\n        block,\n        blockPath,\n        child: void 0,\n        childPath: void 0\n    };\n}\nconst debug$e = debugWithName(\"plugin:withPatches\");\nfunction createWithPatches({ editorActor, patchFunctions, schemaTypes, subscriptions }) {\n    let previousChildren;\n    const applyPatch = createApplyPatch(schemaTypes);\n    return function(editor) {\n        IS_PROCESSING_REMOTE_CHANGES.set(editor, !1), PATCHING.set(editor, !0), previousChildren = [\n            ...editor.children\n        ];\n        const { apply: apply2 } = editor;\n        let bufferedPatches = [];\n        const handleBufferedRemotePatches = ()=>{\n            if (bufferedPatches.length === 0) return;\n            const patches = bufferedPatches;\n            bufferedPatches = [];\n            let changed = !1;\n            withRemoteChanges(editor, ()=>{\n                slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, ()=>{\n                    withoutPatching(editor, ()=>{\n                        withoutSaving(editor, ()=>{\n                            patches.forEach((patch)=>{\n                                debug$e.enabled && debug$e(`Handling remote patch ${JSON.stringify(patch)}`), changed = applyPatch(editor, patch);\n                            });\n                        });\n                    });\n                }), changed && (editor.normalize(), editor.onChange());\n            });\n        }, handlePatches = ({ patches })=>{\n            const remotePatches = patches.filter((p)=>p.origin !== \"local\");\n            remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());\n        };\n        return subscriptions.push(()=>{\n            debug$e(\"Subscribing to remote patches\");\n            const sub = editorActor.on(\"patches\", handlePatches);\n            return ()=>{\n                debug$e(\"Unsubscribing to remote patches\"), sub.unsubscribe();\n            };\n        }), editor.apply = (operation)=>{\n            let patches = [];\n            previousChildren = editor.children;\n            const editorWasEmpty = isEqualToEmptyEditor(previousChildren, schemaTypes);\n            apply2(operation);\n            const editorIsEmpty = isEqualToEmptyEditor(editor.children, schemaTypes);\n            if (!isPatching(editor)) return editor;\n            switch(editorWasEmpty && !editorIsEmpty && operation.type !== \"set_selection\" && patches.push((0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.insert)(previousChildren, \"before\", [\n                0\n            ])), operation.type){\n                case \"insert_text\":\n                    patches = [\n                        ...patches,\n                        ...patchFunctions.insertTextPatch(editor, operation, previousChildren)\n                    ];\n                    break;\n                case \"remove_text\":\n                    patches = [\n                        ...patches,\n                        ...patchFunctions.removeTextPatch(editor, operation, previousChildren)\n                    ];\n                    break;\n                case \"remove_node\":\n                    patches = [\n                        ...patches,\n                        ...patchFunctions.removeNodePatch(editor, operation, previousChildren)\n                    ];\n                    break;\n                case \"split_node\":\n                    patches = [\n                        ...patches,\n                        ...patchFunctions.splitNodePatch(editor, operation, previousChildren)\n                    ];\n                    break;\n                case \"insert_node\":\n                    patches = [\n                        ...patches,\n                        ...patchFunctions.insertNodePatch(editor, operation, previousChildren)\n                    ];\n                    break;\n                case \"set_node\":\n                    patches = [\n                        ...patches,\n                        ...patchFunctions.setNodePatch(editor, operation, previousChildren)\n                    ];\n                    break;\n                case \"merge_node\":\n                    patches = [\n                        ...patches,\n                        ...patchFunctions.mergeNodePatch(editor, operation, previousChildren)\n                    ];\n                    break;\n                case \"move_node\":\n                    patches = [\n                        ...patches,\n                        ...patchFunctions.moveNodePatch(editor, operation, previousChildren)\n                    ];\n                    break;\n            }\n            return !editorWasEmpty && editorIsEmpty && [\n                \"merge_node\",\n                \"set_node\",\n                \"remove_text\",\n                \"remove_node\"\n            ].includes(operation.type) && (patches = [\n                ...patches,\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.unset)([])\n            ], editorActor.send({\n                type: \"unset\",\n                previousValue: fromSlateValue(previousChildren, schemaTypes.block.name, KEY_TO_VALUE_ELEMENT.get(editor))\n            })), editorWasEmpty && patches.length > 0 && (patches = [\n                (0,_portabletext_patches__WEBPACK_IMPORTED_MODULE_20__.setIfMissing)([], []),\n                ...patches\n            ]), patches.length > 0 && patches.forEach((patch)=>{\n                editorActor.send({\n                    type: \"patch\",\n                    patch: {\n                        ...patch,\n                        origin: \"local\"\n                    }\n                });\n            }), editor;\n        }, editor;\n    };\n}\nconst debug$d = debugWithName(\"plugin:withPlaceholderBlock\");\nfunction createWithPlaceholderBlock(editorActor) {\n    return function(editor) {\n        const { apply: apply2 } = editor;\n        return editor.apply = (op)=>{\n            if (editorActor.getSnapshot().matches({\n                \"edit mode\": \"read only\"\n            })) {\n                apply2(op);\n                return;\n            }\n            if (isChangingRemotely(editor)) {\n                apply2(op);\n                return;\n            }\n            if (isUndoing(editor) || isRedoing(editor)) {\n                apply2(op);\n                return;\n            }\n            if (op.type === \"remove_node\") {\n                const node = op.node;\n                if (op.path[0] === 0 && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isVoid(editor, node)) {\n                    const nextPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(op.path);\n                    editor.children[nextPath[0]] || (debug$d(\"Adding placeholder block\"), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n                        decorators: []\n                    })));\n                }\n            }\n            apply2(op);\n        }, editor;\n    };\n}\nconst debug$c = debugWithName(\"plugin:withPortableTextBlockStyle\");\nfunction createWithPortableTextBlockStyle(editorActor, types) {\n    const defaultStyle = types.styles[0].value;\n    return function(editor) {\n        const { normalizeNode } = editor;\n        return editor.normalizeNode = (nodeEntry)=>{\n            const [, path] = nodeEntry;\n            for (const op of editor.operations)if (op.type === \"split_node\" && op.path.length === 1 && editor.isTextBlock(op.properties) && op.properties.style !== defaultStyle && op.path[0] === path[0] && !slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(path, op.path)) {\n                const [child] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, [\n                    op.path[0] + 1,\n                    0\n                ]);\n                if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child) && child.text === \"\") {\n                    debug$c(`Normalizing split node to ${defaultStyle} style`, op), editorActor.send({\n                        type: \"normalizing\"\n                    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                        style: defaultStyle\n                    }, {\n                        at: [\n                            op.path[0] + 1\n                        ],\n                        voids: !1\n                    }), editorActor.send({\n                        type: \"done normalizing\"\n                    });\n                    return;\n                }\n            }\n            normalizeNode(nodeEntry);\n        }, editor;\n    };\n}\nfunction isPortableTextSpan(node) {\n    return node._type === \"span\" && \"text\" in node && typeof node.text == \"string\" && (typeof node.marks > \"u\" || Array.isArray(node.marks) && node.marks.every((mark)=>typeof mark == \"string\"));\n}\nfunction isPortableTextBlock(node) {\n    return(// A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type == \"string\" && // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every((def)=>typeof def._key == \"string\")) && // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child)=>typeof child == \"object\" && \"_type\" in child));\n}\nfunction getPreviousSpan({ editor, blockPath, spanPath }) {\n    let previousSpan;\n    for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath, {\n        reverse: !0\n    }))if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(childPath, spanPath)) {\n        previousSpan = child;\n        break;\n    }\n    return previousSpan;\n}\nfunction getNextSpan({ editor, blockPath, spanPath }) {\n    let nextSpan;\n    for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath))if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isAfter(childPath, spanPath)) {\n        nextSpan = child;\n        break;\n    }\n    return nextSpan;\n}\nconst debug$b = debugWithName(\"plugin:withPortableTextMarkModel\");\nfunction createWithPortableTextMarkModel(editorActor, types) {\n    return function(editor) {\n        const { apply: apply2, normalizeNode } = editor, decorators = types.decorators.map((t)=>t.value);\n        return editor.normalizeNode = (nodeEntry)=>{\n            const [node, path] = nodeEntry;\n            if (editor.isTextBlock(node)) {\n                const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path);\n                for (const [child, childPath] of children){\n                    const nextNode = node.children[childPath[1] + 1];\n                    if (editor.isTextSpan(child) && editor.isTextSpan(nextNode) && child.marks?.every((mark)=>nextNode.marks?.includes(mark)) && nextNode.marks?.every((mark)=>child.marks?.includes(mark))) {\n                        debug$b(\"Merging spans\", JSON.stringify(child, null, 2), JSON.stringify(nextNode, null, 2)), editorActor.send({\n                            type: \"normalizing\"\n                        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.mergeNodes(editor, {\n                            at: [\n                                childPath[0],\n                                childPath[1] + 1\n                            ],\n                            voids: !0\n                        }), editorActor.send({\n                            type: \"done normalizing\"\n                        });\n                        return;\n                    }\n                }\n            }\n            if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {\n                debug$b(\"Adding .markDefs to block node\"), editorActor.send({\n                    type: \"normalizing\"\n                }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                    markDefs: []\n                }, {\n                    at: path\n                }), editorActor.send({\n                    type: \"done normalizing\"\n                });\n                return;\n            }\n            if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {\n                debug$b(\"Adding .marks to span node\"), editorActor.send({\n                    type: \"normalizing\"\n                }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                    marks: []\n                }, {\n                    at: path\n                }), editorActor.send({\n                    type: \"done normalizing\"\n                });\n                return;\n            }\n            if (editor.isTextSpan(node)) {\n                const blockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, blockPath), decorators2 = types.decorators.map((decorator)=>decorator.value), annotations = node.marks?.filter((mark)=>!decorators2.includes(mark));\n                if (editor.isTextBlock(block) && node.text === \"\" && annotations && annotations.length > 0) {\n                    debug$b(\"Removing annotations from empty span node\"), editorActor.send({\n                        type: \"normalizing\"\n                    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                        marks: node.marks?.filter((mark)=>decorators2.includes(mark))\n                    }, {\n                        at: path\n                    }), editorActor.send({\n                        type: \"done normalizing\"\n                    });\n                    return;\n                }\n            }\n            if (editor.isTextBlock(node)) {\n                const decorators2 = types.decorators.map((decorator)=>decorator.value);\n                for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, path))if (editor.isTextSpan(child)) {\n                    const marks = child.marks ?? [], orphanedAnnotations = marks.filter((mark)=>!decorators2.includes(mark) && !node.markDefs?.find((def)=>def._key === mark));\n                    if (orphanedAnnotations.length > 0) {\n                        debug$b(\"Removing orphaned annotations from span node\"), editorActor.send({\n                            type: \"normalizing\"\n                        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                            marks: marks.filter((mark)=>!orphanedAnnotations.includes(mark))\n                        }, {\n                            at: childPath\n                        }), editorActor.send({\n                            type: \"done normalizing\"\n                        });\n                        return;\n                    }\n                }\n            }\n            if (editor.isTextSpan(node)) {\n                const blockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.parent(path), [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, blockPath);\n                if (editor.isTextBlock(block)) {\n                    const decorators2 = types.decorators.map((decorator)=>decorator.value), marks = node.marks ?? [], orphanedAnnotations = marks.filter((mark)=>!decorators2.includes(mark) && !block.markDefs?.find((def)=>def._key === mark));\n                    if (orphanedAnnotations.length > 0) {\n                        debug$b(\"Removing orphaned annotations from span node\"), editorActor.send({\n                            type: \"normalizing\"\n                        }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                            marks: marks.filter((mark)=>!orphanedAnnotations.includes(mark))\n                        }, {\n                            at: path\n                        }), editorActor.send({\n                            type: \"done normalizing\"\n                        });\n                        return;\n                    }\n                }\n            }\n            if (editor.isTextBlock(node)) {\n                const markDefs = node.markDefs ?? [], markDefKeys = /* @__PURE__ */ new Set(), newMarkDefs = [];\n                for (const markDef of markDefs)markDefKeys.has(markDef._key) || (markDefKeys.add(markDef._key), newMarkDefs.push(markDef));\n                if (markDefs.length !== newMarkDefs.length) {\n                    debug$b(\"Removing duplicate markDefs\"), editorActor.send({\n                        type: \"normalizing\"\n                    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                        markDefs: newMarkDefs\n                    }, {\n                        at: path\n                    }), editorActor.send({\n                        type: \"done normalizing\"\n                    });\n                    return;\n                }\n            }\n            if (editor.isTextBlock(node) && !editor.operations.some((op)=>op.type === \"merge_node\" && \"markDefs\" in op.properties && op.path.length === 1)) {\n                const newMarkDefs = (node.markDefs || []).filter((def)=>node.children.find((child)=>slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));\n                if (node.markDefs && !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(newMarkDefs, node.markDefs)) {\n                    debug$b(\"Removing markDef not in use\"), editorActor.send({\n                        type: \"normalizing\"\n                    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                        markDefs: newMarkDefs\n                    }, {\n                        at: path\n                    }), editorActor.send({\n                        type: \"done normalizing\"\n                    });\n                    return;\n                }\n            }\n            normalizeNode(nodeEntry);\n        }, editor.apply = (op)=>{\n            if (isChangingRemotely(editor)) {\n                apply2(op);\n                return;\n            }\n            if (isUndoing(editor) || isRedoing(editor)) {\n                apply2(op);\n                return;\n            }\n            if (op.type === \"set_selection\" && slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) && op.properties && op.newProperties && op.properties.anchor && op.properties.focus && op.newProperties.anchor && op.newProperties.focus) {\n                const previousSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed({\n                    anchor: op.properties.anchor,\n                    focus: op.properties.focus\n                }), newSelectionIsCollapsed = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed({\n                    anchor: op.newProperties.anchor,\n                    focus: op.newProperties.focus\n                });\n                if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {\n                    const focusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n                        mode: \"lowest\",\n                        at: op.properties.focus,\n                        match: (n)=>editor.isTextSpan(n),\n                        voids: !1\n                    }))[0]?.[0], newFocusSpan = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n                        mode: \"lowest\",\n                        at: op.newProperties.focus,\n                        match: (n)=>editor.isTextSpan(n),\n                        voids: !1\n                    }))[0]?.[0], movedToNextSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] + 1 && focusSpan.text.length === op.properties.focus.offset && op.newProperties.focus.offset === 0, movedToPreviousSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] - 1 && op.properties.focus.offset === 0 && newFocusSpan.text.length === op.newProperties.focus.offset;\n                    if (movedToNextSpan || movedToPreviousSpan) return;\n                }\n            }\n            if (op.type === \"insert_node\") {\n                const { selection } = editor;\n                if (selection) {\n                    const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n                        depth: 1\n                    }), previousSpan = getPreviousSpan({\n                        editor,\n                        blockPath,\n                        spanPath: op.path\n                    }), previousSpanAnnotations = previousSpan ? previousSpan.marks?.filter((mark)=>!decorators.includes(mark)) : [], nextSpan = getNextSpan({\n                        editor,\n                        blockPath,\n                        spanPath: [\n                            op.path[0],\n                            op.path[1] - 1\n                        ]\n                    }), nextSpanAnnotations = nextSpan ? nextSpan.marks?.filter((mark)=>!decorators.includes(mark)) : [], annotationsEnding = previousSpanAnnotations?.filter((annotation)=>!nextSpanAnnotations?.includes(annotation)) ?? [], atTheEndOfAnnotation = annotationsEnding.length > 0;\n                    if (atTheEndOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark)=>annotationsEnding.includes(mark))) {\n                        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                            ...op.node,\n                            marks: op.node.marks?.filter((mark)=>!annotationsEnding.includes(mark)) ?? []\n                        });\n                        return;\n                    }\n                    const annotationsStarting = nextSpanAnnotations?.filter((annotation)=>!previousSpanAnnotations?.includes(annotation)) ?? [], atTheStartOfAnnotation = annotationsStarting.length > 0;\n                    if (atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.some((mark)=>annotationsStarting.includes(mark))) {\n                        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                            ...op.node,\n                            marks: op.node.marks?.filter((mark)=>!annotationsStarting.includes(mark)) ?? []\n                        });\n                        return;\n                    }\n                    const nextSpanDecorators = nextSpan?.marks?.filter((mark)=>decorators.includes(mark)) ?? [];\n                    if (nextSpanDecorators.length > 0 && atTheEndOfAnnotation && !atTheStartOfAnnotation && isPortableTextSpan(op.node) && op.node.marks?.length === 0) {\n                        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                            ...op.node,\n                            marks: nextSpanDecorators\n                        });\n                        return;\n                    }\n                }\n            }\n            if (op.type === \"insert_text\") {\n                const { selection } = editor, collapsedSelection = selection ? slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(selection) : !1;\n                if (selection && collapsedSelection) {\n                    const [_block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n                        depth: 1\n                    }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n                        mode: \"lowest\",\n                        at: selection.focus,\n                        match: (n)=>editor.isTextSpan(n),\n                        voids: !1\n                    }))[0] ?? [\n                        void 0,\n                        void 0\n                    ], marks = span.marks ?? [], marksWithoutAnnotations = marks.filter((mark)=>decorators.includes(mark)), spanHasAnnotations = marks.length > marksWithoutAnnotations.length, spanIsEmpty = span.text.length === 0, atTheBeginningOfSpan = selection.anchor.offset === 0, atTheEndOfSpan = selection.anchor.offset === span.text.length, previousSpan = getPreviousSpan({\n                        editor,\n                        blockPath,\n                        spanPath\n                    }), nextSpan = getNextSpan({\n                        editor,\n                        blockPath,\n                        spanPath\n                    }), nextSpanAnnotations = nextSpan?.marks?.filter((mark)=>!decorators.includes(mark)) ?? [], spanAnnotations = marks.filter((mark)=>!decorators.includes(mark)), previousSpanHasAnnotations = previousSpan ? previousSpan.marks?.some((mark)=>!decorators.includes(mark)) : !1, previousSpanHasSameAnnotations = previousSpan ? previousSpan.marks?.filter((mark)=>!decorators.includes(mark)).every((mark)=>marks.includes(mark)) : !1, previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark)=>!decorators.includes(mark) && marks.includes(mark)) : !1, previousSpanHasSameMarks = previousSpan ? previousSpan.marks?.every((mark)=>marks.includes(mark)) : !1, nextSpanSharesSomeAnnotations = spanAnnotations.some((mark)=>nextSpanAnnotations?.includes(mark));\n                    if (spanHasAnnotations && !spanIsEmpty) {\n                        if (atTheBeginningOfSpan) {\n                            if (previousSpanHasSameMarks) {\n                                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                                    _type: \"span\",\n                                    _key: editorActor.getSnapshot().context.keyGenerator(),\n                                    text: op.text,\n                                    marks: previousSpan?.marks ?? []\n                                });\n                                return;\n                            } else if (previousSpanHasSameAnnotations) {\n                                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                                    _type: \"span\",\n                                    _key: editorActor.getSnapshot().context.keyGenerator(),\n                                    text: op.text,\n                                    marks: previousSpan?.marks ?? []\n                                });\n                                return;\n                            } else if (previousSpanHasSameAnnotation) {\n                                apply2(op);\n                                return;\n                            } else if (!previousSpan) {\n                                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                                    _type: \"span\",\n                                    _key: editorActor.getSnapshot().context.keyGenerator(),\n                                    text: op.text,\n                                    marks: []\n                                });\n                                return;\n                            }\n                        }\n                        if (atTheEndOfSpan) {\n                            if (nextSpan && nextSpanSharesSomeAnnotations && nextSpanAnnotations.length < spanAnnotations.length || !nextSpanSharesSomeAnnotations) {\n                                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                                    _type: \"span\",\n                                    _key: editorActor.getSnapshot().context.keyGenerator(),\n                                    text: op.text,\n                                    marks: nextSpan?.marks ?? []\n                                });\n                                return;\n                            }\n                            if (!nextSpan) {\n                                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                                    _type: \"span\",\n                                    _key: editorActor.getSnapshot().context.keyGenerator(),\n                                    text: op.text,\n                                    marks: []\n                                });\n                                return;\n                            }\n                        }\n                    }\n                    if (atTheBeginningOfSpan && !spanIsEmpty && previousSpan) {\n                        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, {\n                            _type: \"span\",\n                            _key: editorActor.getSnapshot().context.keyGenerator(),\n                            text: op.text,\n                            marks: previousSpanHasAnnotations ? [] : (previousSpan.marks ?? []).filter((mark)=>decorators.includes(mark))\n                        });\n                        return;\n                    }\n                }\n            }\n            if (op.type === \"remove_text\") {\n                const { selection } = editor;\n                if (selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection)) {\n                    const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n                        depth: 1\n                    }), [span, spanPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n                        mode: \"lowest\",\n                        at: {\n                            path: op.path,\n                            offset: op.offset\n                        },\n                        match: (n)=>editor.isTextSpan(n),\n                        voids: !1\n                    }))[0] ?? [\n                        void 0,\n                        void 0\n                    ];\n                    if (span && block && isPortableTextBlock(block)) {\n                        const markDefs = block.markDefs ?? [], marks = span.marks ?? [], spanHasAnnotations = marks.some((mark)=>markDefs.find((markDef)=>markDef._key === mark)), deletingFromTheEnd = op.offset + op.text.length === span.text.length, deletingAllText = op.offset === 0 && deletingFromTheEnd, previousSpan = getPreviousSpan({\n                            editor,\n                            blockPath,\n                            spanPath\n                        }), nextSpan = getNextSpan({\n                            editor,\n                            blockPath,\n                            spanPath\n                        }), previousSpanHasSameAnnotation = previousSpan ? previousSpan.marks?.some((mark)=>!decorators.includes(mark) && marks.includes(mark)) : !1, nextSpanHasSameAnnotation = nextSpan ? nextSpan.marks?.some((mark)=>!decorators.includes(mark) && marks.includes(mark)) : !1;\n                        if (spanHasAnnotations && deletingAllText && !previousSpanHasSameAnnotation && !nextSpanHasSameAnnotation) {\n                            const marksWithoutAnnotationMarks = (({\n                                ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n                            }).marks || []).filter((mark)=>decorators.includes(mark));\n                            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, ()=>{\n                                apply2(op), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                                    marks: marksWithoutAnnotationMarks\n                                }, {\n                                    at: op.path\n                                });\n                            }), editor.onChange();\n                            return;\n                        }\n                    }\n                }\n            }\n            if (op.type === \"merge_node\" && op.path.length === 1 && \"markDefs\" in op.properties && op.properties._type === types.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {\n                const [targetBlock, targetPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, [\n                    op.path[0] - 1\n                ]);\n                if (editor.isTextBlock(targetBlock)) {\n                    const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__([\n                        ...oldDefs,\n                        ...op.properties.markDefs\n                    ]);\n                    debug$b(\"Copying markDefs over to merged block\", op), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                        markDefs: newMarkDefs\n                    }, {\n                        at: targetPath,\n                        voids: !1\n                    }), apply2(op);\n                    return;\n                }\n            }\n            apply2(op);\n        }, editor;\n    };\n}\nconst addDecoratorActionImplementation = ({ action })=>{\n    const editor = action.editor, mark = action.decorator;\n    if (editor.selection) {\n        if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n                match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n                split: !0,\n                hanging: !0\n            });\n            const splitTextNodes = slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(editor.selection) ? [\n                ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n                    at: editor.selection,\n                    match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText\n                })\n            ] : [];\n            splitTextNodes.length > 1 && splitTextNodes.every((node)=>node[0].marks?.includes(mark)) ? editor.removeMark(mark) : splitTextNodes.forEach(([node, path])=>{\n                const marks = [\n                    ...(Array.isArray(node.marks) ? node.marks : []).filter((eMark)=>eMark !== mark),\n                    mark\n                ];\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                    marks\n                }, {\n                    at: path,\n                    match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n                    split: !0,\n                    hanging: !0\n                });\n            });\n        } else {\n            const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n                depth: 1\n            }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n            if (lonelyEmptySpan) {\n                const existingMarks = lonelyEmptySpan.marks ?? [], existingMarksWithoutDecorator = existingMarks.filter((existingMark)=>existingMark !== mark);\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                    marks: existingMarks.length === existingMarksWithoutDecorator.length ? [\n                        ...existingMarks,\n                        mark\n                    ] : existingMarksWithoutDecorator\n                }, {\n                    at: blockPath,\n                    match: (node)=>editor.isTextSpan(node)\n                });\n            } else {\n                const existingMarks = {\n                    ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n                }.marks || [], marks = {\n                    ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {},\n                    marks: [\n                        ...existingMarks,\n                        mark\n                    ]\n                };\n                editor.marks = marks;\n            }\n        }\n        editor.onChange();\n    }\n}, removeDecoratorActionImplementation = ({ action })=>{\n    const editor = action.editor, mark = action.decorator, { selection } = editor;\n    if (selection) if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection)) slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n        split: !0,\n        hanging: !0\n    }), editor.selection && [\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            at: editor.selection,\n            match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText\n        })\n    ].forEach(([node, path])=>{\n        const block = editor.children[path[0]];\n        slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(block) && block.children.includes(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark)=>eMark !== mark),\n            _type: \"span\"\n        }, {\n            at: path\n        });\n    });\n    else {\n        const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection, {\n            depth: 1\n        }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === \"\" ? block.children[0] : void 0;\n        if (lonelyEmptySpan) {\n            const existingMarksWithoutDecorator = (lonelyEmptySpan.marks ?? []).filter((existingMark)=>existingMark !== mark);\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                marks: existingMarksWithoutDecorator\n            }, {\n                at: blockPath,\n                match: (node)=>editor.isTextSpan(node)\n            });\n        } else {\n            const existingMarks = {\n                ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n            }.marks || [], marks = {\n                ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {},\n                marks: existingMarks.filter((eMark)=>eMark !== mark)\n            };\n            editor.marks = {\n                marks: marks.marks,\n                _type: \"span\"\n            };\n        }\n    }\n};\nfunction isDecoratorActive({ editor, decorator }) {\n    if (!editor.selection) return !1;\n    const selectedTextNodes = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n        at: editor.selection\n    }));\n    return selectedTextNodes.length === 0 ? !1 : slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection) ? selectedTextNodes.every((n)=>{\n        const [node] = n;\n        return node.marks?.includes(decorator);\n    }) : (({\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n    }).marks || []).includes(decorator);\n}\nconst toggleDecoratorActionImplementation = ({ context, action })=>{\n    isDecoratorActive({\n        editor: action.editor,\n        decorator: action.decorator\n    }) ? removeDecoratorActionImplementation({\n        context,\n        action: {\n            type: \"decorator.remove\",\n            editor: action.editor,\n            decorator: action.decorator\n        }\n    }) : addDecoratorActionImplementation({\n        context,\n        action: {\n            type: \"decorator.add\",\n            editor: action.editor,\n            decorator: action.decorator\n        }\n    });\n}, debug$a = debugWithName(\"plugin:withPortableTextSelections\"), debugVerbose$1 = debug$a.enabled && !1;\nfunction createWithPortableTextSelections(editorActor, types) {\n    let prevSelection = null;\n    return function(editor) {\n        const emitPortableTextSelection = ()=>{\n            if (prevSelection !== editor.selection) {\n                let ptRange = null;\n                if (editor.selection) {\n                    const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n                    if (existing) ptRange = existing;\n                    else {\n                        const value = editor.children;\n                        ptRange = toPortableTextRange(value, editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n                    }\n                }\n                debugVerbose$1 && debug$a(`Emitting selection ${JSON.stringify(ptRange || null)} (${JSON.stringify(editor.selection)})`), ptRange ? editorActor.send({\n                    type: \"selection\",\n                    selection: ptRange\n                }) : editorActor.send({\n                    type: \"selection\",\n                    selection: null\n                });\n            }\n            prevSelection = editor.selection;\n        }, { onChange } = editor;\n        return editor.onChange = ()=>{\n            const hasChanges = editor.operations.length > 0;\n            onChange(), hasChanges && !editorActor.getSnapshot().matches({\n                setup: \"setting up\"\n            }) && emitPortableTextSelection();\n        }, editor;\n    };\n}\nconst debug$9 = debugWithName(\"plugin:withSchemaTypes\");\nfunction createWithSchemaTypes({ editorActor, schemaTypes }) {\n    return function(editor) {\n        editor.isTextBlock = (value)=>(0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextTextBlock)(value) && value._type === schemaTypes.block.name, editor.isTextSpan = (value)=>(0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextSpan)(value) && value._type === schemaTypes.span.name, editor.isListBlock = (value)=>(0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextListBlock)(value) && value._type === schemaTypes.block.name, editor.isVoid = (element)=>schemaTypes.block.name !== element._type && (schemaTypes.blockObjects.map((obj)=>obj.name).includes(element._type) || schemaTypes.inlineObjects.map((obj)=>obj.name).includes(element._type)), editor.isInline = (element)=>schemaTypes.inlineObjects.map((obj)=>obj.name).includes(element._type) && \"__inline\" in element && element.__inline === !0;\n        const { normalizeNode } = editor;\n        return editor.normalizeNode = (entry)=>{\n            const [node, path] = entry;\n            if (node._type === void 0 && path.length === 2) {\n                debug$9(\"Setting span type on text node without a type\");\n                const span = node, key = span._key || editorActor.getSnapshot().context.keyGenerator();\n                editorActor.send({\n                    type: \"normalizing\"\n                }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                    ...span,\n                    _type: schemaTypes.span.name,\n                    _key: key\n                }, {\n                    at: path\n                }), editorActor.send({\n                    type: \"done normalizing\"\n                });\n                return;\n            }\n            if (node._key === void 0 && (path.length === 1 || path.length === 2)) {\n                debug$9(\"Setting missing key on child node without a key\");\n                const key = editorActor.getSnapshot().context.keyGenerator();\n                editorActor.send({\n                    type: \"normalizing\"\n                }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                    _key: key\n                }, {\n                    at: path\n                }), editorActor.send({\n                    type: \"done normalizing\"\n                });\n                return;\n            }\n            normalizeNode(entry);\n        }, editor;\n    };\n}\nconst debug$8 = debugWithName(\"plugin:withUtils\");\nfunction createWithUtils({ editorActor, schemaTypes }) {\n    return function(editor) {\n        return editor.pteExpandToWord = ()=>{\n            const { selection } = editor;\n            if (selection && !slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(selection)) {\n                const [textNode] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, selection.focus, {\n                    depth: 2\n                });\n                if (!textNode || !slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(textNode) || textNode.text.length === 0) {\n                    debug$8(\"pteExpandToWord: Can't expand to word here\");\n                    return;\n                }\n                const { focus } = selection, focusOffset = focus.offset, charsBefore = textNode.text.slice(0, focusOffset), charsAfter = textNode.text.slice(focusOffset, -1), isEmpty = (str)=>str.match(/\\s/g), whiteSpaceBeforeIndex = charsBefore.split(\"\").reverse().findIndex((str)=>isEmpty(str)), newStartOffset = whiteSpaceBeforeIndex > -1 ? charsBefore.length - whiteSpaceBeforeIndex : 0, whiteSpaceAfterIndex = charsAfter.split(\"\").findIndex((obj)=>isEmpty(obj)), newEndOffset = charsBefore.length + (whiteSpaceAfterIndex > -1 ? whiteSpaceAfterIndex : charsAfter.length + 1);\n                if (!(newStartOffset === newEndOffset || Number.isNaN(newStartOffset) || Number.isNaN(newEndOffset))) {\n                    debug$8(\"pteExpandToWord: Expanding to focused word\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setSelection(editor, {\n                        anchor: {\n                            ...selection.anchor,\n                            offset: newStartOffset\n                        },\n                        focus: {\n                            ...selection.focus,\n                            offset: newEndOffset\n                        }\n                    });\n                    return;\n                }\n                debug$8(\"pteExpandToWord: Can't expand to word here\");\n            }\n        }, editor.pteCreateTextBlock = (options)=>toSlateValue([\n                {\n                    _type: schemaTypes.block.name,\n                    _key: editorActor.getSnapshot().context.keyGenerator(),\n                    style: schemaTypes.styles[0].value || \"normal\",\n                    ...options.listItem ? {\n                        listItem: options.listItem\n                    } : {},\n                    ...options.level ? {\n                        level: options.level\n                    } : {},\n                    markDefs: [],\n                    children: [\n                        {\n                            _type: \"span\",\n                            _key: editorActor.getSnapshot().context.keyGenerator(),\n                            text: \"\",\n                            marks: options.decorators.filter((decorator)=>schemaTypes.decorators.find(({ value })=>value === decorator))\n                        }\n                    ]\n                }\n            ], {\n                schemaTypes\n            })[0], editor;\n    };\n}\nconst withPlugins = (editor, options)=>{\n    const e = editor, { editorActor } = options, schemaTypes = editorActor.getSnapshot().context.schema, operationToPatches = createOperationToPatches(schemaTypes), withObjectKeys = createWithObjectKeys(editorActor, schemaTypes), withSchemaTypes = createWithSchemaTypes({\n        editorActor,\n        schemaTypes\n    }), withPatches = createWithPatches({\n        editorActor,\n        patchFunctions: operationToPatches,\n        schemaTypes,\n        subscriptions: options.subscriptions\n    }), withMaxBlocks = createWithMaxBlocks(editorActor), withUndoRedo = createWithUndoRedo({\n        editorActor,\n        blockSchemaType: schemaTypes.block,\n        subscriptions: options.subscriptions\n    }), withPortableTextMarkModel = createWithPortableTextMarkModel(editorActor, schemaTypes), withPortableTextBlockStyle = createWithPortableTextBlockStyle(editorActor, schemaTypes), withPlaceholderBlock = createWithPlaceholderBlock(editorActor), withUtils = createWithUtils({\n        editorActor,\n        schemaTypes\n    }), withPortableTextSelections = createWithPortableTextSelections(editorActor, schemaTypes);\n    return createWithEventListeners(editorActor, options.subscriptions)(withSchemaTypes(withObjectKeys(withPortableTextMarkModel(withPortableTextBlockStyle(withPlaceholderBlock(withUtils(withMaxBlocks(withUndoRedo(withPatches(withPortableTextSelections(e)))))))))));\n}, debug$7 = debugWithName(\"component:PortableTextEditor:SlateContainer\"), slateEditors = /* @__PURE__ */ new WeakMap();\nfunction createSlateEditor(config) {\n    const existingSlateEditor = slateEditors.get(config.editorActor);\n    if (existingSlateEditor) return debug$7(\"Reusing existing Slate editor instance\", config.editorActor.id), existingSlateEditor;\n    debug$7(\"Creating new Slate editor instance\", config.editorActor.id);\n    const unsubscriptions = [], subscriptions = [], instance = withPlugins((0,slate_react__WEBPACK_IMPORTED_MODULE_17__.withReact)((0,slate__WEBPACK_IMPORTED_MODULE_15__.createEditor)()), {\n        editorActor: config.editorActor,\n        subscriptions\n    });\n    KEY_TO_VALUE_ELEMENT.set(instance, {}), KEY_TO_SLATE_ELEMENT.set(instance, {});\n    for (const subscription of subscriptions)unsubscriptions.push(subscription());\n    const initialValue = [\n        instance.pteCreateTextBlock({\n            decorators: []\n        })\n    ], slateEditor = {\n        instance,\n        initialValue\n    };\n    return slateEditors.set(config.editorActor, slateEditor), slateEditor;\n}\nconst toggleListItemActionImplementation = ({ context, action })=>{\n    isListItemActive({\n        editor: action.editor,\n        listItem: action.listItem\n    }) ? removeListItemActionImplementation({\n        context,\n        action: {\n            ...action,\n            type: \"list item.remove\"\n        }\n    }) : addListItemActionImplementation({\n        context,\n        action: {\n            ...action,\n            type: \"list item.add\"\n        }\n    });\n}, removeListItemActionImplementation = ({ context, action })=>{\n    if (!action.editor.selection) return;\n    const guards = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_23__.createGuards)(context), selectedBlocks = [\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n            at: action.editor.selection,\n            match: (node)=>guards.isListBlock(node)\n        })\n    ];\n    for (const [, at] of selectedBlocks)slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.unsetNodes(action.editor, [\n        \"listItem\",\n        \"level\"\n    ], {\n        at\n    });\n}, addListItemActionImplementation = ({ context, action })=>{\n    if (!action.editor.selection) return;\n    const guards = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_23__.createGuards)(context), selectedBlocks = [\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n            at: action.editor.selection,\n            match: (node)=>guards.isTextBlock(node)\n        })\n    ];\n    for (const [, at] of selectedBlocks)slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n        level: 1,\n        listItem: action.listItem\n    }, {\n        at\n    });\n};\nfunction isListItemActive({ editor, listItem }) {\n    if (!editor.selection) return !1;\n    const selectedBlocks = [\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            at: editor.selection,\n            match: (node)=>editor.isTextBlock(node)\n        })\n    ];\n    return selectedBlocks.length > 0 ? selectedBlocks.every(([node])=>editor.isListBlock(node) && node.listItem === listItem) : !1;\n}\nconst toggleStyleActionImplementation = ({ context, action })=>{\n    isStyleActive({\n        editor: action.editor,\n        style: action.style\n    }) ? removeStyleActionImplementation({\n        context,\n        action: {\n            ...action,\n            type: \"style.remove\"\n        }\n    }) : addStyleActionImplementation({\n        context,\n        action: {\n            ...action,\n            type: \"style.add\"\n        }\n    });\n}, removeStyleActionImplementation = ({ context, action })=>{\n    if (!action.editor.selection) return;\n    const defaultStyle = context.schema.styles[0].value, guards = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_23__.createGuards)(context), selectedBlocks = [\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n            at: action.editor.selection,\n            match: (node)=>guards.isTextBlock(node)\n        })\n    ];\n    for (const [, at] of selectedBlocks)slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n        style: defaultStyle\n    }, {\n        at\n    });\n}, addStyleActionImplementation = ({ context, action })=>{\n    if (!action.editor.selection) return;\n    const guards = (0,_chunks_es_selector_is_selection_collapsed_js__WEBPACK_IMPORTED_MODULE_23__.createGuards)(context), selectedBlocks = [\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n            at: action.editor.selection,\n            match: (node)=>guards.isTextBlock(node)\n        })\n    ];\n    for (const [, at] of selectedBlocks)slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n        style: action.style\n    }, {\n        at\n    });\n};\nfunction isStyleActive({ editor, style }) {\n    if (!editor.selection) return !1;\n    const selectedBlocks = [\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            at: editor.selection,\n            match: (node)=>editor.isTextBlock(node)\n        })\n    ];\n    return selectedBlocks.length > 0 ? selectedBlocks.every(([node])=>node.style === style) : !1;\n}\nconst debug$6 = debugWithName(\"API:editable\");\nfunction createEditableAPI(editor, editorActor) {\n    const types = editorActor.getSnapshot().context.schema;\n    return {\n        focus: ()=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"focus\"\n                },\n                editor\n            });\n        },\n        blur: ()=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"blur\"\n                },\n                editor\n            });\n        },\n        toggleMark: (mark)=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"decorator.toggle\",\n                    decorator: mark\n                },\n                editor\n            });\n        },\n        toggleList: (listItem)=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"list item.toggle\",\n                    listItem\n                },\n                editor\n            });\n        },\n        toggleBlockStyle: (style)=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"style.toggle\",\n                    style\n                },\n                editor\n            });\n        },\n        isMarkActive: (mark)=>{\n            try {\n                return isDecoratorActive({\n                    editor,\n                    decorator: mark\n                });\n            } catch (err) {\n                return console.warn(err), !1;\n            }\n        },\n        marks: ()=>({\n                ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(editor) || {}\n            }).marks || [],\n        undo: ()=>editor.undo(),\n        redo: ()=>editor.redo(),\n        select: (selection)=>{\n            const slateSelection = toSlateRange(selection, editor);\n            slateSelection ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, slateSelection) : slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(editor), editor.onChange();\n        },\n        focusBlock: ()=>{\n            if (editor.selection) {\n                const block = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n                if (block) return fromSlateValue([\n                    block\n                ], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n            }\n        },\n        focusChild: ()=>{\n            if (editor.selection) {\n                const block = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, editor.selection.focus.path.slice(0, 1));\n                if (block && editor.isTextBlock(block)) return fromSlateValue([\n                    block\n                ], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0].children[editor.selection.focus.path[1]];\n            }\n        },\n        insertChild: (type, value)=>{\n            if (type.name !== types.span.name) return editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"insert.inline object\",\n                    inlineObject: {\n                        name: type.name,\n                        value\n                    }\n                },\n                editor\n            }), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path ?? [];\n            if (!editor.selection) throw new Error(\"The editor has no selection\");\n            const [focusBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n                at: editor.selection.focus.path.slice(0, 1),\n                match: (n)=>n._type === types.block.name\n            }))[0] || [\n                void 0\n            ];\n            if (!focusBlock) throw new Error(\"No focused text block\");\n            if (type.name !== types.span.name && !types.inlineObjects.some((t)=>t.name === type.name)) throw new Error(\"This type cannot be inserted as a child to a text block\");\n            const child = toSlateValue([\n                {\n                    _key: editorActor.getSnapshot().context.keyGenerator(),\n                    _type: types.block.name,\n                    children: [\n                        {\n                            _key: editorActor.getSnapshot().context.keyGenerator(),\n                            _type: type.name,\n                            ...value || {}\n                        }\n                    ]\n                }\n            ], {\n                schemaTypes: editorActor.getSnapshot().context.schema\n            })[0].children[0], focusChildPath = editor.selection.focus.path.slice(0, 2), isSpanNode = child._type === types.span.name, focusNode = slate__WEBPACK_IMPORTED_MODULE_15__.Node.get(editor, focusChildPath);\n            return isSpanNode && focusNode._type !== types.span.name && (debug$6(\"Inserting span child next to inline object child, moving selection + 1\"), editor.move({\n                distance: 1,\n                unit: \"character\"\n            })), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, child, {\n                select: !0,\n                at: editor.selection\n            }), editor.onChange(), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path || [];\n        },\n        insertBlock: (type, value)=>(editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"insert.block object\",\n                    blockObject: {\n                        name: type.name,\n                        value\n                    },\n                    placement: \"auto\"\n                },\n                editor\n            }), toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types)?.focus.path ?? []),\n        hasBlockStyle: (style)=>{\n            try {\n                return isStyleActive({\n                    editor,\n                    style\n                });\n            } catch  {\n                return !1;\n            }\n        },\n        hasListStyle: (listItem)=>{\n            try {\n                return isListItemActive({\n                    editor,\n                    listItem\n                });\n            } catch  {\n                return !1;\n            }\n        },\n        isVoid: (element)=>![\n                types.block.name,\n                types.span.name\n            ].includes(element._type),\n        findByPath: (path)=>{\n            const slatePath = toSlateRange({\n                focus: {\n                    path,\n                    offset: 0\n                },\n                anchor: {\n                    path,\n                    offset: 0\n                }\n            }, editor);\n            if (slatePath) {\n                const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, slatePath.focus.path.slice(0, 1));\n                if (block && blockPath && typeof block._key == \"string\") {\n                    if (path.length === 1 && slatePath.focus.path.length === 1) return [\n                        fromSlateValue([\n                            block\n                        ], types.block.name)[0],\n                        [\n                            {\n                                _key: block._key\n                            }\n                        ]\n                    ];\n                    const ptBlock = fromSlateValue([\n                        block\n                    ], types.block.name, KEY_TO_VALUE_ELEMENT.get(editor))[0];\n                    if (editor.isTextBlock(ptBlock)) {\n                        const ptChild = ptBlock.children[slatePath.focus.path[1]];\n                        if (ptChild) return [\n                            ptChild,\n                            [\n                                {\n                                    _key: block._key\n                                },\n                                \"children\",\n                                {\n                                    _key: ptChild._key\n                                }\n                            ]\n                        ];\n                    }\n                }\n            }\n            return [\n                void 0,\n                void 0\n            ];\n        },\n        findDOMNode: (element)=>{\n            let node;\n            try {\n                const [item] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n                    at: [],\n                    match: (n)=>n._key === element._key\n                }) || [])[0] || [\n                    void 0\n                ];\n                node = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMNode(editor, item);\n            } catch  {}\n            return node;\n        },\n        activeAnnotations: ()=>{\n            if (!editor.selection || editor.selection.focus.path.length < 2) return [];\n            try {\n                const activeAnnotations = [], spans = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n                    at: editor.selection,\n                    match: (node)=>slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0\n                });\n                for (const [span, path] of spans){\n                    const [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n                        depth: 1\n                    });\n                    editor.isTextBlock(block) && block.markDefs?.forEach((def)=>{\n                        slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);\n                    });\n                }\n                return activeAnnotations;\n            } catch  {\n                return [];\n            }\n        },\n        isAnnotationActive: (annotationType)=>isAnnotationActive({\n                editor,\n                annotation: {\n                    name: annotationType\n                }\n            }),\n        addAnnotation: (type, value)=>{\n            let paths;\n            return slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, ()=>{\n                paths = addAnnotationActionImplementation({\n                    context: {\n                        keyGenerator: editorActor.getSnapshot().context.keyGenerator,\n                        schema: types\n                    },\n                    action: {\n                        type: \"annotation.add\",\n                        annotation: {\n                            name: type.name,\n                            value: value ?? {}\n                        },\n                        editor\n                    }\n                });\n            }), editor.onChange(), paths;\n        },\n        delete: (selection, options)=>{\n            if (selection) {\n                const range = toSlateRange(selection, editor);\n                if (!(range && range.anchor.path.length > 0 && range.focus.path.length > 0)) throw new Error(\"Invalid range\");\n                if (range) {\n                    if (!options?.mode || options?.mode === \"selected\") {\n                        debug$6(\"Deleting content in selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(editor, {\n                            at: range,\n                            hanging: !0,\n                            voids: !0\n                        }), editor.onChange();\n                        return;\n                    }\n                    options?.mode === \"blocks\" && (debug$6(\"Deleting blocks touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n                        at: range,\n                        voids: !0,\n                        match: (node)=>editor.isTextBlock(node) || !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node)\n                    })), options?.mode === \"children\" && (debug$6(\"Deleting children touched by selection\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n                        at: range,\n                        voids: !0,\n                        match: (node)=>node._type === types.span.name || // Text children\n                            !editor.isTextBlock(node) && slate__WEBPACK_IMPORTED_MODULE_15__.Element.isElement(node)\n                    })), editor.children.length === 0 && (editor.children = [\n                        editor.pteCreateTextBlock({\n                            decorators: []\n                        })\n                    ]), editor.onChange();\n                }\n            }\n        },\n        removeAnnotation: (type)=>{\n            editorActor.send({\n                type: \"behavior event\",\n                behaviorEvent: {\n                    type: \"annotation.remove\",\n                    annotation: {\n                        name: type.name\n                    }\n                },\n                editor\n            });\n        },\n        getSelection: ()=>{\n            let ptRange = null;\n            if (editor.selection) {\n                const existing = SLATE_TO_PORTABLE_TEXT_RANGE.get(editor.selection);\n                if (existing) return existing;\n                ptRange = toPortableTextRange(fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)), editor.selection, types), SLATE_TO_PORTABLE_TEXT_RANGE.set(editor.selection, ptRange);\n            }\n            return ptRange;\n        },\n        getValue: ()=>fromSlateValue(editor.children, types.block.name, KEY_TO_VALUE_ELEMENT.get(editor)),\n        isCollapsedSelection: ()=>!!editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection),\n        isExpandedSelection: ()=>!!editor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isExpanded(editor.selection),\n        insertBreak: ()=>{\n            editor.insertBreak(), editor.onChange();\n        },\n        getFragment: ()=>fromSlateValue(editor.getFragment(), types.block.name),\n        isSelectionsOverlapping: (selectionA, selectionB)=>{\n            const rangeA = toSlateRange(selectionA, editor), rangeB = toSlateRange(selectionB, editor);\n            return slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(rangeA) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(rangeB) && slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(rangeA, rangeB);\n        }\n    };\n}\nfunction isAnnotationActive({ editor, annotation }) {\n    if (!editor.selection || editor.selection.focus.path.length < 2) return !1;\n    try {\n        const spans = [\n            ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n                at: editor.selection,\n                match: (node)=>slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(node)\n            })\n        ];\n        if (spans.length === 0 || spans.some(([span])=>!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextSpan)(span) || !span.marks || span.marks?.length === 0)) return !1;\n        const selectionMarkDefs = spans.reduce((accMarkDefs, [, path])=>{\n            const [block] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, path, {\n                depth: 1\n            });\n            return editor.isTextBlock(block) && block.markDefs ? [\n                ...accMarkDefs,\n                ...block.markDefs\n            ] : accMarkDefs;\n        }, []);\n        return spans.every(([span])=>(0,_sanity_types__WEBPACK_IMPORTED_MODULE_13__.isPortableTextSpan)(span) ? span.marks?.map((markKey)=>selectionMarkDefs.find((def)=>def?._key === markKey)?._type)?.includes(annotation.name) : !1);\n    } catch  {\n        return !1;\n    }\n}\nconst addAnnotationActionImplementation = ({ context, action })=>{\n    const editor = action.editor, { selection: originalSelection } = editor;\n    let paths;\n    if (originalSelection && (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(originalSelection) && (editor.pteExpandToWord(), editor.onChange()), editor.selection)) {\n        let spanPath, markDefPath;\n        const markDefPaths = [];\n        if (!editor.selection) return;\n        const selectedBlocks = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            at: editor.selection,\n            match: (node)=>editor.isTextBlock(node),\n            reverse: slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(editor.selection)\n        });\n        for (const [block, blockPath] of selectedBlocks){\n            if (block.children.length === 0 || block.children.length === 1 && block.children[0].text === \"\") continue;\n            const annotationKey = context.keyGenerator(), markDefs = block.markDefs ?? [];\n            markDefs.find((markDef)=>markDef._type === action.annotation.name && markDef._key === annotationKey) === void 0 && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                markDefs: [\n                    ...markDefs,\n                    {\n                        _type: action.annotation.name,\n                        _key: annotationKey,\n                        ...action.annotation.value\n                    }\n                ]\n            }, {\n                at: blockPath\n            }), markDefPath = [\n                {\n                    _key: block._key\n                },\n                \"markDefs\",\n                {\n                    _key: annotationKey\n                }\n            ], slate__WEBPACK_IMPORTED_MODULE_15__.Range.isBackward(editor.selection) ? markDefPaths.unshift(markDefPath) : markDefPaths.push(markDefPath)), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n                match: slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText,\n                split: !0\n            });\n            const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath);\n            for (const [span, path] of children){\n                if (!editor.isTextSpan(span) || !slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(editor.selection, path)) continue;\n                const marks = span.marks ?? [], existingSameTypeAnnotations = marks.filter((mark)=>markDefs.some((markDef)=>markDef._key === mark && markDef._type === action.annotation.name));\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                    marks: [\n                        ...marks.filter((mark)=>!existingSameTypeAnnotations.includes(mark)),\n                        annotationKey\n                    ]\n                }, {\n                    at: path\n                }), spanPath = [\n                    {\n                        _key: block._key\n                    },\n                    \"children\",\n                    {\n                        _key: span._key\n                    }\n                ];\n            }\n        }\n        markDefPath && spanPath && (paths = {\n            markDefPath,\n            markDefPaths,\n            spanPath\n        });\n    }\n    return paths;\n}, removeAnnotationActionImplementation = ({ action })=>{\n    const editor = action.editor;\n    if (debug$6(\"Removing annotation\", action.annotation.name), !!editor.selection) if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection)) {\n        const [block, blockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n            depth: 1\n        });\n        if (!editor.isTextBlock(block)) return;\n        const potentialAnnotations = (block.markDefs ?? []).filter((markDef)=>markDef._type === action.annotation.name), [selectedChild, selectedChildPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n            depth: 2\n        });\n        if (!editor.isTextSpan(selectedChild)) return;\n        const annotationToRemove = selectedChild.marks?.find((mark)=>potentialAnnotations.some((markDef)=>markDef._key === mark));\n        if (!annotationToRemove) return;\n        const previousSpansWithSameAnnotation = [];\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath, {\n            reverse: !0\n        }))if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isBefore(childPath, selectedChildPath)) if (child.marks?.includes(annotationToRemove)) previousSpansWithSameAnnotation.push([\n            child,\n            childPath\n        ]);\n        else break;\n        const nextSpansWithSameAnnotation = [];\n        for (const [child, childPath] of slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath))if (editor.isTextSpan(child) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.isAfter(childPath, selectedChildPath)) if (child.marks?.includes(annotationToRemove)) nextSpansWithSameAnnotation.push([\n            child,\n            childPath\n        ]);\n        else break;\n        for (const [child, childPath] of [\n            ...previousSpansWithSameAnnotation,\n            [\n                selectedChild,\n                selectedChildPath\n            ],\n            ...nextSpansWithSameAnnotation\n        ])slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n            marks: child.marks?.filter((mark)=>mark !== annotationToRemove)\n        }, {\n            at: childPath\n        });\n    } else {\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {}, {\n            match: (node)=>editor.isTextSpan(node),\n            split: !0,\n            hanging: !0\n        });\n        const blocks = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            at: editor.selection,\n            match: (node)=>editor.isTextBlock(node)\n        });\n        for (const [block, blockPath] of blocks){\n            const children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, blockPath);\n            for (const [child, childPath] of children){\n                if (!editor.isTextSpan(child) || !slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(editor.selection, childPath)) continue;\n                const markDefs = block.markDefs ?? [], marks = child.marks ?? [], marksWithoutAnnotation = marks.filter((mark)=>markDefs.find((markDef2)=>markDef2._key === mark)?._type !== action.annotation.name);\n                marksWithoutAnnotation.length !== marks.length && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                    marks: marksWithoutAnnotation\n                }, {\n                    at: childPath\n                });\n            }\n        }\n    }\n}, toggleAnnotationActionImplementation = ({ context, action })=>{\n    if (isAnnotationActive({\n        editor: action.editor,\n        annotation: {\n            name: action.annotation.name\n        }\n    })) removeAnnotationActionImplementation({\n        context,\n        action: {\n            type: \"annotation.remove\",\n            annotation: action.annotation,\n            editor: action.editor\n        }\n    });\n    else return addAnnotationActionImplementation({\n        context,\n        action: {\n            type: \"annotation.add\",\n            annotation: action.annotation,\n            editor: action.editor\n        }\n    });\n};\nfunction insertBlock({ block, placement, editor, schema }) {\n    if (editor.selection) {\n        const [focusBlock, focusBlockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            at: editor.selection.focus.path.slice(0, 1),\n            match: (n)=>!slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(n)\n        }))[0] ?? [\n            void 0,\n            void 0\n        ];\n        if (placement === \"after\") {\n            const nextPath = [\n                focusBlockPath[0] + 1\n            ];\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, block, {\n                at: nextPath\n            }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n                anchor: {\n                    path: [\n                        nextPath[0],\n                        0\n                    ],\n                    offset: 0\n                },\n                focus: {\n                    path: [\n                        nextPath[0],\n                        0\n                    ],\n                    offset: 0\n                }\n            });\n        } else placement === \"before\" ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(editor, block, {\n            at: focusBlockPath\n        }) : slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, block);\n        focusBlock && isEqualToEmptyEditor([\n            focusBlock\n        ], schema) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n            at: focusBlockPath\n        });\n    } else {\n        const lastBlock = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n            match: (n)=>!slate__WEBPACK_IMPORTED_MODULE_15__.Editor.isEditor(n),\n            at: [],\n            reverse: !0\n        }))[0];\n        slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, block), lastBlock && isEqualToEmptyEditor([\n            lastBlock[0]\n        ], schema) && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n            at: lastBlock[1]\n        });\n    }\n}\nconst insertBlockObjectActionImplementation = ({ context, action })=>{\n    const block = toSlateValue([\n        {\n            _key: context.keyGenerator(),\n            _type: action.blockObject.name,\n            ...action.blockObject.value ? action.blockObject.value : {}\n        }\n    ], {\n        schemaTypes: context.schema\n    })[0];\n    insertBlock({\n        block,\n        placement: action.placement,\n        editor: action.editor,\n        schema: context.schema\n    });\n}, insertBreakActionImplementation = ({ context, action })=>{\n    const keyGenerator = context.keyGenerator, schema = context.schema, editor = action.editor;\n    if (!editor.selection) return;\n    const [focusSpan] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(editor, {\n        mode: \"lowest\",\n        at: editor.selection.focus,\n        match: (n)=>editor.isTextSpan(n),\n        voids: !1\n    }))[0] ?? [\n        void 0\n    ], focusDecorators = focusSpan?.marks?.filter((mark)=>schema.decorators.some((decorator)=>decorator.value === mark)) ?? [], focusAnnotations = focusSpan?.marks?.filter((mark)=>!schema.decorators.some((decorator)=>decorator.value === mark)) ?? [], anchorBlockPath = editor.selection.anchor.path.slice(0, 1), focusBlockPath = editor.selection.focus.path.slice(0, 1), focusBlock = slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(editor, focusBlockPath);\n    if (editor.isTextBlock(focusBlock)) {\n        const [start, end] = slate__WEBPACK_IMPORTED_MODULE_15__.Range.edges(editor.selection), lastFocusBlockChild = focusBlock.children[focusBlock.children.length - 1], atTheEndOfBlock = lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(start, {\n            path: [\n                ...focusBlockPath,\n                focusBlock.children.length - 1\n            ],\n            offset: editor.isTextSpan(lastFocusBlockChild) ? lastFocusBlockChild.text.length : 0\n        }), atTheStartOfBlock = lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(end, {\n            path: [\n                ...focusBlockPath,\n                0\n            ],\n            offset: 0\n        });\n        if (atTheEndOfBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n                decorators: [],\n                listItem: focusBlock.listItem,\n                level: focusBlock.level\n            }));\n            return;\n        }\n        if (atTheStartOfBlock && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(editor.selection)) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.insertNode(editor, editor.pteCreateTextBlock({\n                decorators: focusAnnotations.length === 0 ? focusDecorators : [],\n                listItem: focusBlock.listItem,\n                level: focusBlock.level\n            }));\n            const [nextBlockPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(focusBlockPath);\n            slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(editor, {\n                anchor: {\n                    path: [\n                        nextBlockPath,\n                        0\n                    ],\n                    offset: 0\n                },\n                focus: {\n                    path: [\n                        nextBlockPath,\n                        0\n                    ],\n                    offset: 0\n                }\n            });\n            return;\n        }\n        const selectionAcrossBlocks = anchorBlockPath[0] !== focusBlockPath[0];\n        if (!atTheStartOfBlock && !atTheEndOfBlock && !selectionAcrossBlocks) {\n            slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(editor, ()=>{\n                if (!editor.selection) return;\n                slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(editor, {\n                    at: editor.selection\n                });\n                const [nextNode, nextNodePath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(focusBlockPath), {\n                    depth: 1\n                });\n                if (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setSelection(editor, {\n                    anchor: {\n                        path: [\n                            ...nextNodePath,\n                            0\n                        ],\n                        offset: 0\n                    },\n                    focus: {\n                        path: [\n                            ...nextNodePath,\n                            0\n                        ],\n                        offset: 0\n                    }\n                }), editor.isTextBlock(nextNode) && nextNode.markDefs && nextNode.markDefs.length > 0) {\n                    const newMarkDefKeys = /* @__PURE__ */ new Map(), prevNodeSpans = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, focusBlockPath)).map((entry)=>entry[0]).filter((node)=>editor.isTextSpan(node)), children = slate__WEBPACK_IMPORTED_MODULE_15__.Node.children(editor, nextNodePath);\n                    for (const [child, childPath] of children){\n                        if (!editor.isTextSpan(child)) continue;\n                        const marks = child.marks ?? [];\n                        for (const mark of marks)schema.decorators.some((decorator)=>decorator.value === mark) || prevNodeSpans.some((prevNodeSpan)=>prevNodeSpan.marks?.includes(mark)) && !newMarkDefKeys.has(mark) && newMarkDefKeys.set(mark, keyGenerator());\n                        const newMarks = marks.map((mark)=>newMarkDefKeys.get(mark) ?? mark);\n                        lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(marks, newMarks) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                            marks: newMarks\n                        }, {\n                            at: childPath\n                        });\n                    }\n                    const newMarkDefs = nextNode.markDefs.map((markDef)=>({\n                            ...markDef,\n                            _key: newMarkDefKeys.get(markDef._key) ?? markDef._key\n                        }));\n                    lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(nextNode.markDefs, newMarkDefs) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                        markDefs: newMarkDefs\n                    }, {\n                        at: nextNodePath,\n                        match: (node)=>editor.isTextBlock(node)\n                    });\n                }\n            }), editor.onChange();\n            return;\n        }\n    }\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(editor, {\n        always: !0\n    });\n}, insertSoftBreakActionImplementation = ({ context, action })=>{\n    insertBreakActionImplementation({\n        context,\n        action: {\n            ...action,\n            type: \"insert.break\"\n        }\n    });\n}, insertInlineObjectActionImplementation = ({ context, action })=>{\n    if (!context.schema.inlineObjects.some((inlineObject)=>inlineObject.name === action.inlineObject.name)) {\n        console.error(\"Unable to insert unknown inline object\");\n        return;\n    }\n    if (!action.editor.selection) {\n        console.error(\"Unable to insert inline object without selection\");\n        return;\n    }\n    const [focusTextBlock] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n        at: action.editor.selection.focus.path,\n        match: (node)=>action.editor.isTextBlock(node)\n    })).at(0) ?? [\n        void 0,\n        void 0\n    ];\n    if (!focusTextBlock) {\n        console.error(\"Unable to perform action without focus text block\");\n        return;\n    }\n    const child = toSlateValue([\n        {\n            _type: context.schema.block.name,\n            _key: context.keyGenerator(),\n            children: [\n                {\n                    _type: action.inlineObject.name,\n                    _key: context.keyGenerator(),\n                    ...action.inlineObject.value ?? {}\n                }\n            ]\n        }\n    ], {\n        schemaTypes: context.schema\n    }).at(0)?.children.at(0);\n    if (!child) {\n        console.error(\"Unable to insert inline object\");\n        return;\n    }\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(action.editor, child);\n}, insertSpanActionImplementation = ({ context, action })=>{\n    if (!action.editor.selection) {\n        console.error(\"Unable to perform action without selection\", action);\n        return;\n    }\n    const [focusBlock, focusBlockPath] = Array.from(slate__WEBPACK_IMPORTED_MODULE_15__.Editor.nodes(action.editor, {\n        at: action.editor.selection.focus.path,\n        match: (node)=>action.editor.isTextBlock(node)\n    }))[0] ?? [\n        void 0,\n        void 0\n    ];\n    if (!focusBlock || !focusBlockPath) {\n        console.error(\"Unable to perform action without focus block\", action);\n        return;\n    }\n    const markDefs = focusBlock.markDefs ?? [], annotations = action.annotations ? action.annotations.map((annotation)=>({\n            _type: annotation.name,\n            _key: context.keyGenerator(),\n            ...annotation.value\n        })) : void 0;\n    annotations && annotations.length > 0 && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n        markDefs: [\n            ...markDefs,\n            ...annotations\n        ]\n    }), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(action.editor, {\n        _type: \"span\",\n        _key: context.keyGenerator(),\n        text: action.text,\n        marks: [\n            ...annotations?.map((annotation)=>annotation._key) ?? [],\n            ...action.decorators ?? []\n        ]\n    });\n}, textBlockSetActionImplementation = ({ action })=>{\n    const at = toSlateRange({\n        anchor: {\n            path: action.at,\n            offset: 0\n        },\n        focus: {\n            path: action.at,\n            offset: 0\n        }\n    }, action.editor);\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(action.editor, {\n        ...action.style ? {\n            style: action.style\n        } : {},\n        ...action.listItem ? {\n            listItem: action.listItem\n        } : {},\n        ...action.level ? {\n            level: action.level\n        } : {}\n    }, {\n        at\n    });\n}, textBlockUnsetActionImplementation = ({ action })=>{\n    const at = toSlateRange({\n        anchor: {\n            path: action.at,\n            offset: 0\n        },\n        focus: {\n            path: action.at,\n            offset: 0\n        }\n    }, action.editor);\n    slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.unsetNodes(action.editor, action.props, {\n        at\n    });\n}, behaviorActionImplementations = {\n    \"annotation.add\": addAnnotationActionImplementation,\n    \"annotation.remove\": removeAnnotationActionImplementation,\n    \"annotation.toggle\": toggleAnnotationActionImplementation,\n    blur: ({ action })=>{\n        slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.blur(action.editor);\n    },\n    \"decorator.add\": addDecoratorActionImplementation,\n    \"decorator.remove\": removeDecoratorActionImplementation,\n    \"decorator.toggle\": toggleDecoratorActionImplementation,\n    focus: ({ action })=>{\n        slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.focus(action.editor);\n    },\n    \"delete.backward\": ({ action })=>{\n        (0,slate__WEBPACK_IMPORTED_MODULE_15__.deleteBackward)(action.editor, action.unit);\n    },\n    \"delete.forward\": ({ action })=>{\n        (0,slate__WEBPACK_IMPORTED_MODULE_15__.deleteForward)(action.editor, action.unit);\n    },\n    \"delete.block\": ({ action })=>{\n        const range = toSlateRange({\n            anchor: {\n                path: action.blockPath,\n                offset: 0\n            },\n            focus: {\n                path: action.blockPath,\n                offset: 0\n            }\n        }, action.editor);\n        if (!range) {\n            console.error(\"Unable to find Slate range from selection points\");\n            return;\n        }\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(action.editor, {\n            at: range\n        });\n    },\n    \"delete.text\": ({ context, action })=>{\n        const value = fromSlateValue(action.editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(action.editor)), anchor = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__.blockOffsetToSpanSelectionPoint)({\n            value,\n            blockOffset: action.anchor\n        }), focus = (0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__.blockOffsetToSpanSelectionPoint)({\n            value,\n            blockOffset: action.focus\n        });\n        if (!anchor || !focus) {\n            console.error(\"Unable to find anchor or focus selection point\");\n            return;\n        }\n        const range = toSlateRange({\n            anchor,\n            focus\n        }, action.editor);\n        if (!range) {\n            console.error(\"Unable to find Slate range from selection points\");\n            return;\n        }\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.delete(action.editor, {\n            at: range\n        });\n    },\n    \"insert.block object\": insertBlockObjectActionImplementation,\n    \"insert.break\": insertBreakActionImplementation,\n    \"insert.inline object\": insertInlineObjectActionImplementation,\n    \"insert.soft break\": insertSoftBreakActionImplementation,\n    \"insert.span\": insertSpanActionImplementation,\n    \"insert.text\": ({ action })=>{\n        (0,slate__WEBPACK_IMPORTED_MODULE_15__.insertText)(action.editor, action.text);\n    },\n    \"insert.text block\": ({ context, action })=>{\n        const block = toSlateValue([\n            {\n                _key: context.keyGenerator(),\n                _type: context.schema.block.name,\n                style: context.schema.styles[0].value ?? \"normal\",\n                markDefs: [],\n                children: action.textBlock?.children?.map((child)=>({\n                        ...child,\n                        _key: context.keyGenerator()\n                    })) ?? [\n                    {\n                        _type: context.schema.span.name,\n                        _key: context.keyGenerator(),\n                        text: \"\"\n                    }\n                ]\n            }\n        ], {\n            schemaTypes: context.schema\n        })[0];\n        insertBlock({\n            block,\n            editor: action.editor,\n            schema: context.schema,\n            placement: action.placement\n        });\n    },\n    effect: ({ action })=>{\n        action.effect();\n    },\n    \"list item.add\": addListItemActionImplementation,\n    \"list item.remove\": removeListItemActionImplementation,\n    \"list item.toggle\": toggleListItemActionImplementation,\n    \"move.block\": ({ action })=>{\n        const at = [\n            toSlatePath(action.at, action.editor)[0]\n        ], to = [\n            toSlatePath(action.to, action.editor)[0]\n        ];\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(action.editor, {\n            at,\n            to,\n            mode: \"highest\"\n        });\n    },\n    \"move.block down\": ({ action })=>{\n        const at = [\n            toSlatePath(action.at, action.editor)[0]\n        ], to = [\n            slate__WEBPACK_IMPORTED_MODULE_15__.Path.next(at)[0]\n        ];\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(action.editor, {\n            at,\n            to,\n            mode: \"highest\"\n        });\n    },\n    \"move.block up\": ({ action })=>{\n        const at = [\n            toSlatePath(action.at, action.editor)[0]\n        ];\n        if (!slate__WEBPACK_IMPORTED_MODULE_15__.Path.hasPrevious(at)) return;\n        const to = [\n            slate__WEBPACK_IMPORTED_MODULE_15__.Path.previous(at)[0]\n        ];\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.moveNodes(action.editor, {\n            at,\n            to,\n            mode: \"highest\"\n        });\n    },\n    noop: ()=>{},\n    select: ({ action })=>{\n        const newSelection = toSlateRange(action.selection, action.editor);\n        newSelection ? slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, newSelection) : slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(action.editor);\n    },\n    \"select.previous block\": ({ action })=>{\n        if (!action.editor.selection) {\n            console.error(\"Unable to select previous block without a selection\");\n            return;\n        }\n        const blockPath = action.editor.selection.focus.path.slice(0, 1);\n        if (!slate__WEBPACK_IMPORTED_MODULE_15__.Path.hasPrevious(blockPath)) {\n            console.error(\"There's no previous block to select\");\n            return;\n        }\n        const previousBlockPath = slate__WEBPACK_IMPORTED_MODULE_15__.Path.previous(blockPath);\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, previousBlockPath);\n    },\n    \"select.next block\": ({ action })=>{\n        if (!action.editor.selection) {\n            console.error(\"Unable to select next block without a selection\");\n            return;\n        }\n        const nextBlockPath = [\n            action.editor.selection.focus.path.slice(0, 1)[0] + 1\n        ];\n        slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, nextBlockPath);\n    },\n    reselect: ({ action })=>{\n        const selection = action.editor.selection;\n        selection && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(action.editor, {\n            ...selection\n        }), action.editor.selection = {\n            ...selection\n        });\n    },\n    \"style.toggle\": toggleStyleActionImplementation,\n    \"style.add\": addStyleActionImplementation,\n    \"style.remove\": removeStyleActionImplementation,\n    \"text block.set\": textBlockSetActionImplementation,\n    \"text block.unset\": textBlockUnsetActionImplementation\n};\nfunction performAction({ context, action }) {\n    switch(action.type){\n        case \"delete.block\":\n            {\n                behaviorActionImplementations[\"delete.block\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"delete.text\":\n            {\n                behaviorActionImplementations[\"delete.text\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"insert.span\":\n            {\n                behaviorActionImplementations[\"insert.span\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"insert.text block\":\n            {\n                behaviorActionImplementations[\"insert.text block\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"list item.add\":\n            {\n                behaviorActionImplementations[\"list item.add\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"list item.remove\":\n            {\n                behaviorActionImplementations[\"list item.remove\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"move.block\":\n            {\n                behaviorActionImplementations[\"move.block\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"move.block down\":\n            {\n                behaviorActionImplementations[\"move.block down\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"move.block up\":\n            {\n                behaviorActionImplementations[\"move.block up\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"noop\":\n            break;\n        case \"effect\":\n            {\n                behaviorActionImplementations.effect({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"select\":\n            {\n                behaviorActionImplementations.select({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"select.previous block\":\n            {\n                behaviorActionImplementations[\"select.previous block\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"select.next block\":\n            {\n                behaviorActionImplementations[\"select.next block\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"reselect\":\n            {\n                behaviorActionImplementations.reselect({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"style.add\":\n            {\n                behaviorActionImplementations[\"style.add\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"style.remove\":\n            {\n                behaviorActionImplementations[\"style.remove\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"text block.set\":\n            {\n                behaviorActionImplementations[\"text block.set\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"text block.unset\":\n            {\n                behaviorActionImplementations[\"text block.unset\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        default:\n            performDefaultAction({\n                context,\n                action\n            });\n    }\n}\nfunction performDefaultAction({ context, action }) {\n    switch(action.type){\n        case \"annotation.add\":\n            {\n                behaviorActionImplementations[\"annotation.add\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"annotation.remove\":\n            {\n                behaviorActionImplementations[\"annotation.remove\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"annotation.toggle\":\n            {\n                behaviorActionImplementations[\"annotation.toggle\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"blur\":\n            {\n                behaviorActionImplementations.blur({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"decorator.add\":\n            {\n                behaviorActionImplementations[\"decorator.add\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"decorator.remove\":\n            {\n                behaviorActionImplementations[\"decorator.remove\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"decorator.toggle\":\n            {\n                behaviorActionImplementations[\"decorator.toggle\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"delete.backward\":\n            {\n                behaviorActionImplementations[\"delete.backward\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"delete.forward\":\n            {\n                behaviorActionImplementations[\"delete.forward\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"focus\":\n            {\n                behaviorActionImplementations.focus({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"insert.block object\":\n            {\n                behaviorActionImplementations[\"insert.block object\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"insert.inline object\":\n            {\n                behaviorActionImplementations[\"insert.inline object\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"insert.break\":\n            {\n                behaviorActionImplementations[\"insert.break\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"insert.soft break\":\n            {\n                behaviorActionImplementations[\"insert.soft break\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"insert.text\":\n            {\n                behaviorActionImplementations[\"insert.text\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        case \"list item.toggle\":\n            {\n                behaviorActionImplementations[\"list item.toggle\"]({\n                    context,\n                    action\n                });\n                break;\n            }\n        default:\n            behaviorActionImplementations[\"style.toggle\"]({\n                context,\n                action\n            });\n    }\n}\nfunction getActiveDecorators({ schema, slateEditorInstance }) {\n    const decorators = schema.decorators.map((decorator)=>decorator.value);\n    return (({\n        ...slate__WEBPACK_IMPORTED_MODULE_15__.Editor.marks(slateEditorInstance) ?? {}\n    }).marks ?? []).filter((mark)=>decorators.includes(mark));\n}\nconst editorMachine = (0,xstate__WEBPACK_IMPORTED_MODULE_18__.setup)({\n    types: {\n        context: {},\n        events: {},\n        emitted: {},\n        input: {}\n    },\n    actions: {\n        \"assign behaviors\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            behaviors: ({ event })=>((0,xstate__WEBPACK_IMPORTED_MODULE_18__.assertEvent)(event, \"update behaviors\"), event.behaviors)\n        }),\n        \"assign schema\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            schema: ({ event })=>((0,xstate__WEBPACK_IMPORTED_MODULE_18__.assertEvent)(event, \"update schema\"), event.schema)\n        }),\n        \"emit patch event\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>((0,xstate__WEBPACK_IMPORTED_MODULE_18__.assertEvent)(event, \"patch\"), event)),\n        \"emit mutation event\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>((0,xstate__WEBPACK_IMPORTED_MODULE_18__.assertEvent)(event, \"mutation\"), event)),\n        \"emit read only\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)({\n            type: \"read only\"\n        }),\n        \"emit editable\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)({\n            type: \"editable\"\n        }),\n        \"defer event\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            pendingEvents: ({ context, event })=>((0,xstate__WEBPACK_IMPORTED_MODULE_18__.assertEvent)(event, [\n                    \"patch\",\n                    \"mutation\"\n                ]), [\n                    ...context.pendingEvents,\n                    event\n                ])\n        }),\n        \"emit pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.b)(({ context, enqueue })=>{\n            for (const event of context.pendingEvents)enqueue((0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(event));\n        }),\n        \"emit ready\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)({\n            type: \"ready\"\n        }),\n        \"clear pending events\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n            pendingEvents: []\n        }),\n        \"handle behavior event\": (0,xstate__WEBPACK_IMPORTED_MODULE_19__.b)(({ context, event, enqueue })=>{\n            (0,xstate__WEBPACK_IMPORTED_MODULE_18__.assertEvent)(event, [\n                \"behavior event\"\n            ]);\n            const defaultAction = event.behaviorEvent.type === \"copy\" || event.behaviorEvent.type === \"key.down\" || event.behaviorEvent.type === \"key.up\" || event.behaviorEvent.type === \"paste\" ? void 0 : {\n                ...event.behaviorEvent,\n                editor: event.editor\n            }, eventBehaviors = context.behaviors.filter((behavior)=>behavior.on === event.behaviorEvent.type);\n            if (eventBehaviors.length === 0) {\n                if (!defaultAction) return;\n                slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(event.editor, ()=>{\n                    performAction({\n                        context,\n                        action: defaultAction\n                    });\n                }), event.editor.onChange();\n                return;\n            }\n            const value = fromSlateValue(event.editor.children, context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(event.editor)), selection = toPortableTextRange(value, event.editor.selection, context.schema), editorContext = {\n                activeDecorators: getActiveDecorators({\n                    schema: context.schema,\n                    slateEditorInstance: event.editor\n                }),\n                keyGenerator: context.keyGenerator,\n                schema: context.schema,\n                selection,\n                value\n            };\n            let behaviorOverwritten = !1;\n            for (const eventBehavior of eventBehaviors){\n                const shouldRun = eventBehavior.guard === void 0 || eventBehavior.guard({\n                    context: editorContext,\n                    event: event.behaviorEvent\n                });\n                if (!shouldRun) continue;\n                const actionIntendSets = eventBehavior.actions.map((actionSet)=>actionSet({\n                        context: editorContext,\n                        event: event.behaviorEvent\n                    }, shouldRun));\n                for (const actionIntends of actionIntendSets)behaviorOverwritten = behaviorOverwritten || actionIntends.length > 0 && actionIntends.some((actionIntend)=>actionIntend.type !== \"effect\"), slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(event.editor, ()=>{\n                    for (const actionIntend of actionIntends){\n                        const action = {\n                            ...actionIntend,\n                            editor: event.editor\n                        };\n                        performAction({\n                            context,\n                            action\n                        });\n                    }\n                }), event.editor.onChange(), actionIntends.some((actionIntend)=>actionIntend.type === \"reselect\") && enqueue.raise({\n                    type: \"selection\",\n                    selection: toPortableTextRange(event.editor.children, event.editor.selection, context.schema)\n                });\n                if (behaviorOverwritten) {\n                    event.nativeEvent?.preventDefault();\n                    break;\n                }\n            }\n            if (!behaviorOverwritten) {\n                if (!defaultAction) return;\n                slate__WEBPACK_IMPORTED_MODULE_15__.Editor.withoutNormalizing(event.editor, ()=>{\n                    performAction({\n                        context,\n                        action: defaultAction\n                    });\n                }), event.editor.onChange();\n            }\n        })\n    }\n}).createMachine({\n    id: \"editor\",\n    context: ({ input })=>({\n            behaviors: input.behaviors ?? _chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__.coreBehaviors,\n            keyGenerator: input.keyGenerator,\n            pendingEvents: [],\n            schema: input.schema,\n            selection: null,\n            initialReadOnly: input.readOnly ?? !1,\n            maxBlocks: input.maxBlocks,\n            value: input.value\n        }),\n    on: {\n        unset: {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n        },\n        \"value changed\": {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n        },\n        \"invalid value\": {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n        },\n        error: {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n        },\n        selection: {\n            actions: [\n                (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n                    selection: ({ event })=>event.selection\n                }),\n                (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n            ]\n        },\n        blurred: {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n        },\n        focused: {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n        },\n        loading: {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)({\n                type: \"loading\"\n            })\n        },\n        patches: {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n        },\n        \"done loading\": {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)({\n                type: \"done loading\"\n            })\n        },\n        \"update behaviors\": {\n            actions: \"assign behaviors\"\n        },\n        \"update schema\": {\n            actions: \"assign schema\"\n        },\n        \"update value\": {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n                value: ({ event })=>event.value\n            })\n        },\n        \"update maxBlocks\": {\n            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.a)({\n                maxBlocks: ({ event })=>event.maxBlocks\n            })\n        }\n    },\n    type: \"parallel\",\n    states: {\n        \"edit mode\": {\n            initial: \"read only\",\n            states: {\n                \"read only\": {\n                    initial: \"determine initial edit mode\",\n                    states: {\n                        \"determine initial edit mode\": {\n                            on: {\n                                \"done syncing initial value\": [\n                                    {\n                                        target: \"#editor.edit mode.read only.read only\",\n                                        guard: ({ context })=>context.initialReadOnly\n                                    },\n                                    {\n                                        target: \"#editor.edit mode.editable\"\n                                    }\n                                ]\n                            }\n                        },\n                        \"read only\": {\n                            on: {\n                                \"update readOnly\": {\n                                    guard: ({ event })=>!event.readOnly,\n                                    target: \"#editor.edit mode.editable\",\n                                    actions: [\n                                        \"emit editable\"\n                                    ]\n                                }\n                            }\n                        }\n                    }\n                },\n                editable: {\n                    on: {\n                        \"update readOnly\": {\n                            guard: ({ event })=>event.readOnly,\n                            target: \"#editor.edit mode.read only.read only\",\n                            actions: [\n                                \"emit read only\"\n                            ]\n                        },\n                        \"behavior event\": {\n                            actions: \"handle behavior event\"\n                        },\n                        \"annotation.add\": {\n                            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                        },\n                        \"annotation.remove\": {\n                            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                        },\n                        \"annotation.toggle\": {\n                            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                        },\n                        blur: {\n                            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                        },\n                        \"decorator.*\": {\n                            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                        },\n                        focus: {\n                            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                        },\n                        \"insert.*\": {\n                            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                        },\n                        \"list item.*\": {\n                            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                        },\n                        \"style.*\": {\n                            actions: (0,xstate__WEBPACK_IMPORTED_MODULE_19__.e)(({ event })=>event)\n                        }\n                    }\n                }\n            }\n        },\n        setup: {\n            initial: \"setting up\",\n            states: {\n                \"setting up\": {\n                    exit: [\n                        \"emit ready\"\n                    ],\n                    on: {\n                        patch: {\n                            actions: \"defer event\"\n                        },\n                        mutation: {\n                            actions: \"defer event\"\n                        },\n                        \"done syncing initial value\": {\n                            target: \"pristine\"\n                        }\n                    }\n                },\n                pristine: {\n                    initial: \"idle\",\n                    states: {\n                        idle: {\n                            on: {\n                                normalizing: {\n                                    target: \"normalizing\"\n                                },\n                                patch: {\n                                    actions: \"defer event\",\n                                    target: \"#editor.setup.dirty\"\n                                },\n                                mutation: {\n                                    actions: \"defer event\",\n                                    target: \"#editor.setup.dirty\"\n                                }\n                            }\n                        },\n                        normalizing: {\n                            on: {\n                                \"done normalizing\": {\n                                    target: \"idle\"\n                                },\n                                patch: {\n                                    actions: \"defer event\"\n                                },\n                                mutation: {\n                                    actions: \"defer event\"\n                                }\n                            }\n                        }\n                    }\n                },\n                dirty: {\n                    entry: [\n                        \"emit pending events\",\n                        \"clear pending events\"\n                    ],\n                    on: {\n                        patch: {\n                            actions: \"emit patch event\"\n                        },\n                        mutation: {\n                            actions: \"emit mutation event\"\n                        }\n                    }\n                }\n            }\n        }\n    }\n});\nfunction getValue({ editorActorSnapshot, slateEditorInstance }) {\n    return fromSlateValue(slateEditorInstance.children, editorActorSnapshot.context.schema.block.name, KEY_TO_VALUE_ELEMENT.get(slateEditorInstance));\n}\nfunction defaultCompare(a, b) {\n    return a === b;\n}\nfunction useEditorSelector(editor, selector, t0) {\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(3), compare = t0 === void 0 ? defaultCompare : t0;\n    let t1;\n    return $[0] !== editor._internal.slateEditor.instance || $[1] !== selector ? (t1 = (editorActorSnapshot)=>{\n        const snapshot = getEditorSnapshot({\n            editorActorSnapshot,\n            slateEditorInstance: editor._internal.slateEditor.instance\n        });\n        return selector(snapshot);\n    }, $[0] = editor._internal.slateEditor.instance, $[1] = selector, $[2] = t1) : t1 = $[2], (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useSelector)(editor._internal.editorActor, t1, compare);\n}\nfunction getEditorSnapshot({ editorActorSnapshot, slateEditorInstance }) {\n    return {\n        context: {\n            activeDecorators: getActiveDecorators({\n                schema: editorActorSnapshot.context.schema,\n                slateEditorInstance\n            }),\n            keyGenerator: editorActorSnapshot.context.keyGenerator,\n            schema: editorActorSnapshot.context.schema,\n            selection: editorActorSnapshot.context.selection,\n            value: getValue({\n                editorActorSnapshot,\n                slateEditorInstance\n            })\n        }\n    };\n}\nconst defaultKeyGenerator = ()=>randomKey(12), getByteHexTable = /* @__PURE__ */ (()=>{\n    let table;\n    return ()=>{\n        if (table) return table;\n        table = [];\n        for(let i = 0; i < 256; ++i)table[i] = (i + 256).toString(16).slice(1);\n        return table;\n    };\n})();\nfunction whatwgRNG(length = 16) {\n    const rnds8 = new Uint8Array(length);\n    return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_25__[\"default\"])(rnds8), rnds8;\n}\nfunction randomKey(length) {\n    const table = getByteHexTable();\n    return whatwgRNG(length).reduce((str, n)=>str + table[n], \"\").slice(0, length);\n}\nfunction createEditor(config) {\n    const editorActor = (0,xstate__WEBPACK_IMPORTED_MODULE_26__.A)(editorMachine, {\n        input: editorConfigToMachineInput(config)\n    });\n    return editorActor.start(), createEditorFromActor(editorActor);\n}\nfunction useCreateEditor(config) {\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6);\n    let t0;\n    $[0] !== config ? (t0 = editorConfigToMachineInput(config), $[0] = config, $[1] = t0) : t0 = $[1];\n    let t1;\n    $[2] !== t0 ? (t1 = {\n        input: t0\n    }, $[2] = t0, $[3] = t1) : t1 = $[3];\n    const editorActor = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useActorRef)(editorMachine, t1);\n    let t2, t3;\n    return $[4] !== editorActor ? (t3 = createEditorFromActor(editorActor), $[4] = editorActor, $[5] = t3) : t3 = $[5], t2 = t3, t2;\n}\nfunction editorConfigToMachineInput(config) {\n    return {\n        behaviors: config.behaviors,\n        keyGenerator: config.keyGenerator ?? defaultKeyGenerator,\n        maxBlocks: config.maxBlocks,\n        readOnly: config.readOnly,\n        schema: config.schemaDefinition ? compileSchemaDefinition(config.schemaDefinition) : createEditorSchema(config.schema.hasOwnProperty(\"jsonType\") ? config.schema : compileType(config.schema)),\n        value: config.initialValue\n    };\n}\nfunction createEditorFromActor(editorActor) {\n    const slateEditor = createSlateEditor({\n        editorActor\n    }), editable = createEditableAPI(slateEditor.instance, editorActor);\n    return {\n        getSnapshot: ()=>getEditorSnapshot({\n                editorActorSnapshot: editorActor.getSnapshot(),\n                slateEditorInstance: slateEditor.instance\n            }),\n        send: (event)=>{\n            editorActor.send(event);\n        },\n        on: (event, listener)=>editorActor.on(event, // @ts-expect-error\n            listener),\n        _internal: {\n            editable,\n            editorActor,\n            slateEditor\n        }\n    };\n}\nconst EditorActorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_4__.createContext)({}), PortableTextEditorSelectionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_4__.createContext)(null), usePortableTextEditorSelection = ()=>{\n    const selection = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(PortableTextEditorSelectionContext);\n    if (selection === void 0) throw new Error(\"The `usePortableTextEditorSelection` hook must be used inside the <PortableTextEditor> component's context.\");\n    return selection;\n}, debug$5 = debugWithName(\"component:PortableTextEditor:SelectionProvider\"), debugVerbose = debug$5.enabled && !1;\nfunction PortableTextEditorSelectionProvider(props) {\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6), [selection, setSelection] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(null);\n    let t0, t1;\n    $[0] !== props.editorActor ? (t0 = ()=>{\n        debug$5(\"Subscribing to selection changes\");\n        const subscription = props.editorActor.on(\"selection\", (event)=>{\n            (0,react__WEBPACK_IMPORTED_MODULE_4__.startTransition)(()=>{\n                debugVerbose && debug$5(\"Setting selection\"), setSelection(event.selection);\n            });\n        });\n        return ()=>{\n            debug$5(\"Unsubscribing to selection changes\"), subscription.unsubscribe();\n        };\n    }, t1 = [\n        props.editorActor\n    ], $[0] = props.editorActor, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t0, t1);\n    let t2;\n    return $[3] !== props.children || $[4] !== selection ? (t2 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorSelectionContext.Provider, {\n        value: selection,\n        children: props.children\n    }), $[3] = props.children, $[4] = selection, $[5] = t2) : t2 = $[5], t2;\n}\nconst debug$4 = debugWithName(\"component:PortableTextEditor\");\nclass PortableTextEditor extends react__WEBPACK_IMPORTED_MODULE_4__.Component {\n    static{\n        this.displayName = \"PortableTextEditor\";\n    }\n    /**\n   * A lookup table for all the relevant schema types for this portable text type.\n   */ /**\n   * The editor instance\n   */ /*\n   * The editor API (currently implemented with Slate).\n   */ constructor(props){\n        var _temp;\n        _temp = super(props), /**\n   * An observable of all the editor changes.\n   */ this.change$ = new _barrel_optimize_names_Subject_rxjs__WEBPACK_IMPORTED_MODULE_27__.Subject(), this.setEditable = (editable)=>{\n            this.editor._internal.editable = {\n                ...this.editor._internal.editable,\n                ...editable\n            };\n        }, _temp, props.editor ? this.editor = props.editor : this.editor = createEditor({\n            keyGenerator: props.keyGenerator ?? defaultKeyGenerator,\n            schema: props.schemaType,\n            initialValue: props.value,\n            maxBlocks: props.maxBlocks === void 0 ? void 0 : Number.parseInt(props.maxBlocks.toString(), 10),\n            readOnly: props.readOnly\n        }), this.schemaTypes = this.editor._internal.editorActor.getSnapshot().context.schema, this.editable = this.editor._internal.editable;\n    }\n    componentDidUpdate(prevProps) {\n        !this.props.editor && !prevProps.editor && this.props.schemaType !== prevProps.schemaType && (this.schemaTypes = createEditorSchema(this.props.schemaType.hasOwnProperty(\"jsonType\") ? this.props.schemaType : compileType(this.props.schemaType)), this.editor._internal.editorActor.send({\n            type: \"update schema\",\n            schema: this.schemaTypes\n        })), !this.props.editor && !prevProps.editor && (this.props.readOnly !== prevProps.readOnly && this.editor._internal.editorActor.send({\n            type: \"update readOnly\",\n            readOnly: this.props.readOnly ?? !1\n        }), this.props.maxBlocks !== prevProps.maxBlocks && this.editor._internal.editorActor.send({\n            type: \"update maxBlocks\",\n            maxBlocks: this.props.maxBlocks === void 0 ? void 0 : Number.parseInt(this.props.maxBlocks.toString(), 10)\n        }), this.props.value !== prevProps.value && this.editor._internal.editorActor.send({\n            type: \"update value\",\n            value: this.props.value\n        }), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this));\n    }\n    render() {\n        const legacyPatches = this.props.editor ? void 0 : this.props.incomingPatches$ ?? this.props.patches$;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n            children: [\n                legacyPatches ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RoutePatchesObservableToEditorActor, {\n                    editorActor: this.editor._internal.editorActor,\n                    patches$: legacyPatches\n                }) : null,\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RouteEventsToChanges, {\n                    editorActor: this.editor._internal.editorActor,\n                    onChange: (change)=>{\n                        this.props.editor || this.props.onChange(change), this.change$.next(change);\n                    }\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Synchronizer, {\n                    editorActor: this.editor._internal.editorActor,\n                    slateEditor: this.editor._internal.slateEditor.instance\n                }),\n                /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorActorContext.Provider, {\n                    value: this.editor._internal.editorActor,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_17__.Slate, {\n                        editor: this.editor._internal.slateEditor.instance,\n                        initialValue: this.editor._internal.slateEditor.initialValue,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorContext.Provider, {\n                            value: this,\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorSelectionProvider, {\n                                editorActor: this.editor._internal.editorActor,\n                                children: this.props.children\n                            })\n                        })\n                    })\n                })\n            ]\n        });\n    }\n    static{\n        // Static API methods\n        this.activeAnnotations = (editor)=>editor && editor.editable ? editor.editable.activeAnnotations() : [];\n    }\n    static{\n        this.isAnnotationActive = (editor, annotationType)=>editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1;\n    }\n    static{\n        this.addAnnotation = (editor, type, value)=>editor.editable?.addAnnotation(type, value);\n    }\n    static{\n        this.blur = (editor)=>{\n            debug$4(\"Host blurred\"), editor.editable?.blur();\n        };\n    }\n    static{\n        this.delete = (editor, selection, options)=>editor.editable?.delete(selection, options);\n    }\n    static{\n        this.findDOMNode = (editor, element)=>editor.editable?.findDOMNode(element);\n    }\n    static{\n        this.findByPath = (editor, path)=>editor.editable?.findByPath(path) || [];\n    }\n    static{\n        this.focus = (editor)=>{\n            debug$4(\"Host requesting focus\"), editor.editable?.focus();\n        };\n    }\n    static{\n        this.focusBlock = (editor)=>editor.editable?.focusBlock();\n    }\n    static{\n        this.focusChild = (editor)=>editor.editable?.focusChild();\n    }\n    static{\n        this.getSelection = (editor)=>editor.editable ? editor.editable.getSelection() : null;\n    }\n    static{\n        this.getValue = (editor)=>editor.editable?.getValue();\n    }\n    static{\n        this.hasBlockStyle = (editor, blockStyle)=>editor.editable?.hasBlockStyle(blockStyle);\n    }\n    static{\n        this.hasListStyle = (editor, listStyle)=>editor.editable?.hasListStyle(listStyle);\n    }\n    static{\n        this.isCollapsedSelection = (editor)=>editor.editable?.isCollapsedSelection();\n    }\n    static{\n        this.isExpandedSelection = (editor)=>editor.editable?.isExpandedSelection();\n    }\n    static{\n        this.isMarkActive = (editor, mark)=>editor.editable?.isMarkActive(mark);\n    }\n    static{\n        this.insertChild = (editor, type, value)=>(debug$4(\"Host inserting child\"), editor.editable?.insertChild(type, value));\n    }\n    static{\n        this.insertBlock = (editor, type, value)=>editor.editable?.insertBlock(type, value);\n    }\n    static{\n        this.insertBreak = (editor)=>editor.editable?.insertBreak();\n    }\n    static{\n        this.isVoid = (editor, element)=>editor.editable?.isVoid(element);\n    }\n    static{\n        this.isObjectPath = (_editor, path)=>{\n            if (!path || !Array.isArray(path)) return !1;\n            const isChildObjectEditPath = path.length > 3 && path[1] === \"children\";\n            return path.length > 1 && path[1] !== \"children\" || isChildObjectEditPath;\n        };\n    }\n    static{\n        this.marks = (editor)=>editor.editable?.marks();\n    }\n    static{\n        this.select = (editor, selection)=>{\n            debug$4(\"Host setting selection\", selection), editor.editable?.select(selection);\n        };\n    }\n    static{\n        this.removeAnnotation = (editor, type)=>editor.editable?.removeAnnotation(type);\n    }\n    static{\n        this.toggleBlockStyle = (editor, blockStyle)=>(debug$4(\"Host is toggling block style\"), editor.editable?.toggleBlockStyle(blockStyle));\n    }\n    static{\n        this.toggleList = (editor, listStyle)=>editor.editable?.toggleList(listStyle);\n    }\n    static{\n        this.toggleMark = (editor, mark)=>{\n            debug$4(\"Host toggling mark\", mark), editor.editable?.toggleMark(mark);\n        };\n    }\n    static{\n        this.getFragment = (editor)=>(debug$4(\"Host getting fragment\"), editor.editable?.getFragment());\n    }\n    static{\n        this.undo = (editor)=>{\n            debug$4(\"Host undoing\"), editor.editable?.undo();\n        };\n    }\n    static{\n        this.redo = (editor)=>{\n            debug$4(\"Host redoing\"), editor.editable?.redo();\n        };\n    }\n    static{\n        this.isSelectionsOverlapping = (editor, selectionA, selectionB)=>editor.editable?.isSelectionsOverlapping(selectionA, selectionB);\n    }\n}\nfunction RoutePatchesObservableToEditorActor(props) {\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(4);\n    let t0, t1;\n    return $[0] !== props.editorActor || $[1] !== props.patches$ ? (t0 = ()=>{\n        const subscription = props.patches$.subscribe((payload)=>{\n            props.editorActor.send({\n                type: \"patches\",\n                ...payload\n            });\n        });\n        return ()=>{\n            subscription.unsubscribe();\n        };\n    }, t1 = [\n        props.editorActor,\n        props.patches$\n    ], $[0] = props.editorActor, $[1] = props.patches$, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t0, t1), null;\n}\nfunction RouteEventsToChanges(props) {\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(6);\n    let t0;\n    $[0] !== props ? (t0 = (change)=>props.onChange(change), $[0] = props, $[1] = t0) : t0 = $[1];\n    const handleChange = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_28__.useEffectEvent)(t0);\n    let t1, t2;\n    return $[2] !== handleChange || $[3] !== props.editorActor ? (t1 = ()=>{\n        debug$4(\"Subscribing to editor changes\");\n        const sub = props.editorActor.on(\"*\", (event)=>{\n            bb5: switch(event.type){\n                case \"blurred\":\n                    {\n                        handleChange({\n                            type: \"blur\",\n                            event: event.event\n                        });\n                        break bb5;\n                    }\n                case \"patch\":\n                    {\n                        handleChange(event);\n                        break bb5;\n                    }\n                case \"loading\":\n                    {\n                        handleChange({\n                            type: \"loading\",\n                            isLoading: !0\n                        });\n                        break bb5;\n                    }\n                case \"done loading\":\n                    {\n                        handleChange({\n                            type: \"loading\",\n                            isLoading: !1\n                        });\n                        break bb5;\n                    }\n                case \"focused\":\n                    {\n                        handleChange({\n                            type: \"focus\",\n                            event: event.event\n                        });\n                        break bb5;\n                    }\n                case \"value changed\":\n                    {\n                        handleChange({\n                            type: \"value\",\n                            value: event.value\n                        });\n                        break bb5;\n                    }\n                case \"invalid value\":\n                    {\n                        handleChange({\n                            type: \"invalidValue\",\n                            resolution: event.resolution,\n                            value: event.value\n                        });\n                        break bb5;\n                    }\n                case \"error\":\n                    {\n                        handleChange({\n                            ...event,\n                            level: \"warning\"\n                        });\n                        break bb5;\n                    }\n                case \"annotation.add\":\n                case \"annotation.remove\":\n                case \"annotation.toggle\":\n                case \"blur\":\n                case \"decorator.add\":\n                case \"decorator.remove\":\n                case \"decorator.toggle\":\n                case \"focus\":\n                case \"insert.block object\":\n                case \"insert.inline object\":\n                case \"list item.toggle\":\n                case \"style.toggle\":\n                case \"patches\":\n                case \"editable\":\n                case \"read only\":\n                    break bb5;\n                default:\n                    handleChange(event);\n            }\n        });\n        return ()=>{\n            debug$4(\"Unsubscribing to changes\"), sub.unsubscribe();\n        };\n    }, t2 = [\n        props.editorActor,\n        handleChange\n    ], $[2] = handleChange, $[3] = props.editorActor, $[4] = t1, $[5] = t2) : (t1 = $[4], t2 = $[5]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t1, t2), null;\n}\nconst debug$3 = debugWithName(\"components:Leaf\"), EMPTY_MARKS = [], Leaf = (props)=>{\n    const { editorActor, attributes, children, leaf, schemaTypes, renderChild, renderDecorator, renderAnnotation } = props, spanRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), portableTextEditor = usePortableTextEditor(), blockSelected = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSelected)(), [focused, setFocused] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1), [selected, setSelected] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1), block = children.props.parent, path = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>block ? [\n            {\n                _key: block?._key\n            },\n            \"children\",\n            {\n                _key: leaf._key\n            }\n        ] : [], [\n        block,\n        leaf._key\n    ]), decoratorValues = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>schemaTypes.decorators.map((dec)=>dec.value), [\n        schemaTypes.decorators\n    ]), marks = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__((leaf.marks || EMPTY_MARKS).filter((mark)=>decoratorValues.includes(mark))), [\n        decoratorValues,\n        leaf.marks\n    ]), annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS, annotations = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>annotationMarks.map((mark_0)=>!decoratorValues.includes(mark_0) && block?.markDefs?.find((def)=>def._key === mark_0)).filter(Boolean), [\n        annotationMarks,\n        block,\n        decoratorValues\n    ]), shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected;\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        if (!shouldTrackSelectionAndFocus) {\n            setFocused(!1);\n            return;\n        }\n        const sel = PortableTextEditor.getSelection(portableTextEditor);\n        sel && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(sel.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && (0,react__WEBPACK_IMPORTED_MODULE_4__.startTransition)(()=>{\n            setFocused(!0);\n        });\n    }, [\n        shouldTrackSelectionAndFocus,\n        path,\n        portableTextEditor\n    ]);\n    const setSelectedFromRange = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(()=>{\n        if (!shouldTrackSelectionAndFocus) return;\n        debug$3(\"Setting selection and focus from range\");\n        const winSelection = window.getSelection();\n        if (!winSelection) {\n            setSelected(!1);\n            return;\n        }\n        if (winSelection && winSelection.rangeCount > 0) {\n            const range = winSelection.getRangeAt(0);\n            spanRef.current && range.intersectsNode(spanRef.current) ? setSelected(!0) : setSelected(!1);\n        } else setSelected(!1);\n    }, [\n        shouldTrackSelectionAndFocus\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        if (!shouldTrackSelectionAndFocus) return;\n        const onBlur = editorActor.on(\"blur\", ()=>{\n            setFocused(!1), setSelected(!1);\n        }), onFocus = editorActor.on(\"focus\", ()=>{\n            const sel_0 = PortableTextEditor.getSelection(portableTextEditor);\n            sel_0 && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(sel_0.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) && setFocused(!0), setSelectedFromRange();\n        }), onSelection = editorActor.on(\"selection\", (event)=>{\n            event.selection && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(event.selection.focus.path, path) && PortableTextEditor.isCollapsedSelection(portableTextEditor) ? setFocused(!0) : setFocused(!1), setSelectedFromRange();\n        });\n        return ()=>{\n            onBlur.unsubscribe(), onFocus.unsubscribe(), onSelection.unsubscribe();\n        };\n    }, [\n        editorActor,\n        path,\n        portableTextEditor,\n        setSelectedFromRange,\n        shouldTrackSelectionAndFocus\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>setSelectedFromRange(), [\n        setSelectedFromRange\n    ]);\n    const content = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>{\n        let returnedChildren = children;\n        if (slate__WEBPACK_IMPORTED_MODULE_15__.Text.isText(leaf) && leaf._type === schemaTypes.span.name && (marks.forEach((mark_1)=>{\n            const schemaType = schemaTypes.decorators.find((dec_0)=>dec_0.value === mark_1);\n            if (schemaType && renderDecorator) {\n                const _props = Object.defineProperty({\n                    children: returnedChildren,\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    selected,\n                    schemaType,\n                    value: mark_1\n                }, \"type\", {\n                    enumerable: !1,\n                    get () {\n                        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType;\n                    }\n                });\n                returnedChildren = renderDecorator(_props);\n            }\n        }), block && annotations.length > 0 && annotations.forEach((annotation)=>{\n            const schemaType_0 = schemaTypes.annotations.find((t)=>t.name === annotation._type);\n            if (schemaType_0) if (renderAnnotation) {\n                const _props_0 = Object.defineProperty({\n                    block,\n                    children: returnedChildren,\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    selected,\n                    schemaType: schemaType_0,\n                    value: annotation\n                }, \"type\", {\n                    enumerable: !1,\n                    get () {\n                        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaType_0;\n                    }\n                });\n                returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n                    ref: spanRef,\n                    children: renderAnnotation(_props_0)\n                });\n            } else returnedChildren = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DefaultAnnotation, {\n                annotation,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n                    ref: spanRef,\n                    children: returnedChildren\n                })\n            });\n        }), block && renderChild)) {\n            const child = block.children.find((_child)=>_child._key === leaf._key);\n            if (child) {\n                const _props_1 = Object.defineProperty({\n                    annotations,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                        children: returnedChildren\n                    }),\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    schemaType: schemaTypes.span,\n                    selected,\n                    value: child\n                }, \"type\", {\n                    enumerable: !1,\n                    get () {\n                        return console.warn(\"Property 'type' is deprecated, use 'schemaType' instead.\"), schemaTypes.span;\n                    }\n                });\n                returnedChildren = renderChild(_props_1);\n            }\n        }\n        return returnedChildren;\n    }, [\n        annotations,\n        block,\n        children,\n        focused,\n        leaf,\n        marks,\n        path,\n        renderAnnotation,\n        renderChild,\n        renderDecorator,\n        schemaTypes.annotations,\n        schemaTypes.decorators,\n        schemaTypes.span,\n        selected\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n            ...attributes,\n            ref: spanRef,\n            children: content\n        }, leaf._key), [\n        leaf,\n        attributes,\n        content\n    ]);\n};\nLeaf.displayName = \"Leaf\";\nconst debug$2 = debugWithName(\"plugin:withHotKeys\"), DEFAULT_HOTKEYS = {\n    marks: {\n        \"mod+b\": \"strong\",\n        \"mod+i\": \"em\",\n        \"mod+u\": \"underline\",\n        \"mod+'\": \"code\"\n    },\n    custom: {}\n};\nfunction createWithHotkeys(editorActor, portableTextEditor, hotkeysFromOptions) {\n    const reservedHotkeys = [\n        \"enter\",\n        \"tab\",\n        \"shift\",\n        \"delete\",\n        \"end\"\n    ], activeHotkeys = hotkeysFromOptions || DEFAULT_HOTKEYS;\n    return function(editor) {\n        return editor.pteWithHotKeys = (event)=>{\n            Object.keys(activeHotkeys).forEach((cat)=>{\n                if (cat === \"marks\") for(const hotkey in activeHotkeys[cat]){\n                    if (reservedHotkeys.includes(hotkey)) throw new Error(`The hotkey ${hotkey} is reserved!`);\n                    if ((0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__.isHotkey)(hotkey, event.nativeEvent)) {\n                        event.preventDefault();\n                        const possibleMark = activeHotkeys[cat];\n                        if (possibleMark) {\n                            const mark = possibleMark[hotkey];\n                            debug$2(`HotKey ${hotkey} to toggle ${mark}`), editorActor.send({\n                                type: \"behavior event\",\n                                behaviorEvent: {\n                                    type: \"decorator.toggle\",\n                                    decorator: mark\n                                },\n                                editor\n                            });\n                        }\n                    }\n                }\n                if (cat === \"custom\") for(const hotkey in activeHotkeys[cat]){\n                    if (reservedHotkeys.includes(hotkey)) throw new Error(`The hotkey ${hotkey} is reserved!`);\n                    if ((0,_chunks_es_behavior_core_js__WEBPACK_IMPORTED_MODULE_24__.isHotkey)(hotkey, event.nativeEvent)) {\n                        const possibleCommand = activeHotkeys[cat];\n                        if (possibleCommand) {\n                            const command = possibleCommand[hotkey];\n                            command(event, portableTextEditor);\n                        }\n                    }\n                }\n            });\n        }, editor;\n    };\n}\nconst debug$1 = debugWithName(\"plugin:withInsertData\");\nfunction createWithInsertData(editorActor, schemaTypes) {\n    return function(editor) {\n        const blockTypeName = schemaTypes.block.name, spanTypeName = schemaTypes.span.name, whitespaceOnPasteMode = schemaTypes.block.options.unstable_whitespaceOnPasteMode, toPlainText = (blocks)=>blocks.map((block)=>editor.isTextBlock(block) ? block.children.map((child)=>child._type === spanTypeName ? child.text : `[${schemaTypes.inlineObjects.find((t)=>t.name === child._type)?.title || \"Object\"}]`).join(\"\") : `[${schemaTypes.blockObjects.find((t)=>t.name === block._type)?.title || \"Object\"}]`).join(`\n\n`);\n        return editor.setFragmentData = (data, originEvent)=>{\n            const { selection } = editor;\n            if (!selection) return;\n            const [start, end] = slate__WEBPACK_IMPORTED_MODULE_15__.Range.edges(selection), startVoid = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.void(editor, {\n                at: start.path\n            }), endVoid = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.void(editor, {\n                at: end.path\n            });\n            if (slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(selection) && !startVoid) return;\n            const domRange = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMRange(editor, selection);\n            let contents = domRange.cloneContents();\n            if (endVoid) {\n                const [voidNode] = endVoid, r = domRange.cloneRange(), domNode = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMNode(editor, voidNode);\n                r.setEndAfter(domNode), contents = r.cloneContents();\n            }\n            Array.from(contents.querySelectorAll(\"[data-slate-zero-width]\")).forEach((zw)=>{\n                const isNewline = zw.getAttribute(\"data-slate-zero-width\") === \"n\";\n                zw.textContent = isNewline ? `\n` : \"\";\n            }), Array.from(contents.querySelectorAll(\"*\")).forEach((elm)=>{\n                elm.removeAttribute(\"contentEditable\"), elm.removeAttribute(\"data-slate-inline\"), elm.removeAttribute(\"data-slate-leaf\"), elm.removeAttribute(\"data-slate-node\"), elm.removeAttribute(\"data-slate-spacer\"), elm.removeAttribute(\"data-slate-string\"), elm.removeAttribute(\"data-slate-zero-width\"), elm.removeAttribute(\"draggable\");\n                for(const key in elm.attributes)elm.hasAttribute(key) && elm.removeAttribute(key);\n            });\n            const div = contents.ownerDocument.createElement(\"div\");\n            div.appendChild(contents), div.setAttribute(\"hidden\", \"true\"), contents.ownerDocument.body.appendChild(div);\n            const asHTML = div.innerHTML;\n            contents.ownerDocument.body.removeChild(div);\n            const fragment = editor.getFragment(), portableText = fromSlateValue(fragment, blockTypeName), asJSON = JSON.stringify(portableText), asPlainText = toPlainText(portableText);\n            data.clearData(), data.setData(\"text/plain\", asPlainText), data.setData(\"text/html\", asHTML), data.setData(\"application/json\", asJSON), data.setData(\"application/x-portable-text\", asJSON), debug$1(\"text\", asPlainText), data.setData(\"application/x-portable-text-event-origin\", originEvent || \"external\"), debug$1(\"Set fragment data\", asJSON, asHTML);\n        }, editor.insertPortableTextData = (data)=>{\n            if (!editor.selection) return !1;\n            const pText = data.getData(\"application/x-portable-text\"), origin = data.getData(\"application/x-portable-text-event-origin\");\n            if (debug$1(`Inserting portable text from ${origin} event`, pText), pText) {\n                const parsed = JSON.parse(pText);\n                if (Array.isArray(parsed) && parsed.length > 0) {\n                    const slateValue = _regenerateKeys(editor, toSlateValue(parsed, {\n                        schemaTypes\n                    }), editorActor.getSnapshot().context.keyGenerator, spanTypeName, schemaTypes), validation = validateValue(parsed, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n                    if (!validation.valid && !validation.resolution?.autoResolve) {\n                        const errorDescription = `${validation.resolution?.description}`;\n                        return editorActor.send({\n                            type: \"error\",\n                            name: \"pasteError\",\n                            description: errorDescription,\n                            data: validation\n                        }), debug$1(\"Invalid insert result\", validation), !1;\n                    }\n                    return _insertFragment(editor, slateValue, schemaTypes), !0;\n                }\n            }\n            return !1;\n        }, editor.insertTextOrHTMLData = (data)=>{\n            if (!editor.selection) return debug$1(\"No selection, not inserting\"), !1;\n            const html = data.getData(\"text/html\"), text = data.getData(\"text/plain\");\n            if (html || text) {\n                debug$1(\"Inserting data\", data);\n                let portableText, fragment, insertedType;\n                if (html) {\n                    if (portableText = (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_29__.htmlToBlocks)(html, schemaTypes.portableText, {\n                        unstable_whitespaceOnPasteMode: whitespaceOnPasteMode\n                    }).map((block)=>(0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_29__.normalizeBlock)(block, {\n                            blockTypeName\n                        })), fragment = toSlateValue(portableText, {\n                        schemaTypes\n                    }), insertedType = \"HTML\", portableText.length === 0) return !1;\n                } else {\n                    const textToHtml = `<html><body>${escapeHtml(text).split(/\\n{2,}/).map((line)=>line ? `<p>${line.replace(/(?:\\r\\n|\\r|\\n)/g, \"<br/>\")}</p>` : \"<p></p>\").join(\"\")}</body></html>`;\n                    portableText = (0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_29__.htmlToBlocks)(textToHtml, schemaTypes.portableText).map((block)=>(0,_sanity_block_tools__WEBPACK_IMPORTED_MODULE_29__.normalizeBlock)(block, {\n                            blockTypeName\n                        })), fragment = toSlateValue(portableText, {\n                        schemaTypes\n                    }), insertedType = \"text\";\n                }\n                const validation = validateValue(portableText, schemaTypes, editorActor.getSnapshot().context.keyGenerator);\n                if (!validation.valid) {\n                    const errorDescription = `Could not validate the resulting portable text to insert.\n${validation.resolution?.description}\nTry to insert as plain text (shift-paste) instead.`;\n                    return editorActor.send({\n                        type: \"error\",\n                        name: \"pasteError\",\n                        description: errorDescription,\n                        data: validation\n                    }), debug$1(\"Invalid insert result\", validation), !1;\n                }\n                return debug$1(`Inserting ${insertedType} fragment at ${JSON.stringify(editor.selection)}`), _insertFragment(editor, fragment, schemaTypes), !0;\n            }\n            return !1;\n        }, editor.insertData = (data)=>{\n            editor.insertPortableTextData(data) || editor.insertTextOrHTMLData(data);\n        }, editor.insertFragmentData = (data)=>{\n            const fragment = data.getData(\"application/x-portable-text\");\n            if (fragment) {\n                const parsed = JSON.parse(fragment);\n                return editor.insertFragment(parsed), !0;\n            }\n            return !1;\n        }, editor;\n    };\n}\nconst entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\",\n    \"`\": \"&#x60;\",\n    \"=\": \"&#x3D;\"\n};\nfunction escapeHtml(str) {\n    return String(str).replace(/[&<>\"'`=/]/g, (s)=>entityMap[s]);\n}\nfunction _regenerateKeys(editor, fragment, keyGenerator, spanTypeName, editorTypes) {\n    return fragment.map((node)=>{\n        const newNode = {\n            ...node\n        };\n        if (editor.isTextBlock(newNode)) {\n            const annotations = editorTypes.annotations.map((t)=>t.name);\n            if (annotations.length === 0) {\n                const { markDefs, ...NewNodeNoDefs } = newNode;\n                return {\n                    ...NewNodeNoDefs,\n                    _key: keyGenerator()\n                };\n            }\n            if ((newNode.markDefs || []).some((def)=>!annotations.includes(def._type))) {\n                const allowedAnnotations = (newNode.markDefs || []).filter((def)=>annotations.includes(def._type));\n                return {\n                    ...newNode,\n                    markDefs: allowedAnnotations,\n                    _key: keyGenerator()\n                };\n            }\n            newNode.markDefs = (newNode.markDefs || []).map((def)=>{\n                const oldKey = def._key, newKey = keyGenerator();\n                return newNode.children = newNode.children.map((child)=>child._type === spanTypeName && editor.isTextSpan(child) ? {\n                        ...child,\n                        marks: child.marks && child.marks.includes(oldKey) ? [\n                            ...child.marks\n                        ].filter((mark)=>mark !== oldKey).concat(newKey) : child.marks\n                    } : child), {\n                    ...def,\n                    _key: newKey\n                };\n            });\n        }\n        const nodeWithNewKeys = {\n            ...newNode,\n            _key: keyGenerator()\n        };\n        return editor.isTextBlock(nodeWithNewKeys) && (nodeWithNewKeys.children = nodeWithNewKeys.children.map((child)=>({\n                ...child,\n                _key: keyGenerator()\n            }))), nodeWithNewKeys;\n    });\n}\nfunction _insertFragment(editor, fragment, schemaTypes) {\n    editor.withoutNormalizing(()=>{\n        if (!editor.selection) return;\n        const [focusBlock, focusPath] = slate__WEBPACK_IMPORTED_MODULE_15__.Editor.node(editor, editor.selection, {\n            depth: 1\n        });\n        if (editor.isTextBlock(focusBlock) && editor.isTextBlock(fragment[0])) {\n            const { markDefs } = focusBlock;\n            debug$1(\"Mixing markDefs of focusBlock and fragments[0] block\", markDefs, fragment[0].markDefs), lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(markDefs, fragment[0].markDefs) || slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.setNodes(editor, {\n                markDefs: lodash_uniq_js__WEBPACK_IMPORTED_MODULE_7__([\n                    ...fragment[0].markDefs || [],\n                    ...markDefs || []\n                ])\n            }, {\n                at: focusPath,\n                mode: \"lowest\",\n                voids: !1\n            });\n        }\n        isEqualToEmptyEditor(editor.children, schemaTypes) ? (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.splitNodes(editor, {\n            at: [\n                0,\n                0\n            ]\n        }), editor.insertFragment(fragment), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.removeNodes(editor, {\n            at: [\n                0\n            ]\n        })) : editor.insertFragment(fragment);\n    }), editor.onChange();\n}\nfunction withSyncRangeDecorations({ editorActor, slateEditor, syncRangeDecorations }) {\n    const originalApply = slateEditor.apply;\n    return slateEditor.apply = (op)=>{\n        originalApply(op), !editorActor.getSnapshot().matches({\n            \"edit mode\": \"read only\"\n        }) && op.type !== \"set_selection\" && syncRangeDecorations(op);\n    }, ()=>{\n        slateEditor.apply = originalApply;\n    };\n}\nconst debug = debugWithName(\"component:Editable\"), PLACEHOLDER_STYLE = {\n    position: \"absolute\",\n    userSelect: \"none\",\n    pointerEvents: \"none\",\n    left: 0,\n    right: 0\n}, PortableTextEditable = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_4__.forwardRef)(function(props, forwardedRef) {\n    const { hotkeys, onBlur, onFocus, onBeforeInput, onPaste, onCopy, onClick, rangeDecorations, renderAnnotation, renderBlock, renderChild, renderDecorator, renderListItem, renderPlaceholder, renderStyle, selection: propsSelection, scrollSelectionIntoView, spellCheck, ...restProps } = props, portableTextEditor = usePortableTextEditor(), ref = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null), [editableElement, setEditableElement] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(null), [hasInvalidValue, setHasInvalidValue] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1), [rangeDecorationState, setRangeDecorationsState] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useImperativeHandle)(forwardedRef, ()=>ref.current);\n    const rangeDecorationsRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(rangeDecorations), editorActor = (0,react__WEBPACK_IMPORTED_MODULE_4__.useContext)(EditorActorContext), readOnly = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useSelector)(editorActor, (s)=>s.matches({\n            \"edit mode\": \"read only\"\n        })), schemaTypes = (0,_xstate_react__WEBPACK_IMPORTED_MODULE_22__.useSelector)(editorActor, (s_0)=>s_0.context.schema), slateEditor = (0,slate_react__WEBPACK_IMPORTED_MODULE_17__.useSlate)(), blockTypeName = schemaTypes.block.name;\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>{\n        const withInsertData = createWithInsertData(editorActor, schemaTypes);\n        if (readOnly) return debug(\"Editable is in read only mode\"), withInsertData(slateEditor);\n        const withHotKeys = createWithHotkeys(editorActor, portableTextEditor, hotkeys);\n        return debug(\"Editable is in edit mode\"), withInsertData(withHotKeys(slateEditor));\n    }, [\n        editorActor,\n        hotkeys,\n        portableTextEditor,\n        readOnly,\n        schemaTypes,\n        slateEditor\n    ]);\n    const renderElement = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((eProps)=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Element, {\n            ...eProps,\n            readOnly,\n            renderBlock,\n            renderChild,\n            renderListItem,\n            renderStyle,\n            schemaTypes,\n            spellCheck\n        }), [\n        schemaTypes,\n        spellCheck,\n        readOnly,\n        renderBlock,\n        renderChild,\n        renderListItem,\n        renderStyle\n    ]), renderLeaf = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((lProps)=>{\n        if (lProps.leaf._type === \"span\") {\n            let rendered = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Leaf, {\n                ...lProps,\n                editorActor,\n                schemaTypes,\n                renderAnnotation,\n                renderChild,\n                renderDecorator,\n                readOnly\n            });\n            if (renderPlaceholder && lProps.leaf.placeholder && lProps.text.text === \"\") return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                children: [\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n                        style: PLACEHOLDER_STYLE,\n                        contentEditable: !1,\n                        children: renderPlaceholder()\n                    }),\n                    rendered\n                ]\n            });\n            const decoration = lProps.leaf.rangeDecoration;\n            return decoration && (rendered = decoration.component({\n                children: rendered\n            })), rendered;\n        }\n        return lProps.children;\n    }, [\n        editorActor,\n        readOnly,\n        renderAnnotation,\n        renderChild,\n        renderDecorator,\n        renderPlaceholder,\n        schemaTypes\n    ]), restoreSelectionFromProps = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(()=>{\n        if (propsSelection) {\n            debug(`Selection from props ${JSON.stringify(propsSelection)}`);\n            const normalizedSelection = normalizeSelection(propsSelection, fromSlateValue(slateEditor.children, blockTypeName));\n            if (normalizedSelection !== null) {\n                debug(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);\n                const slateRange = toSlateRange(normalizedSelection, slateEditor);\n                slateRange && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, slateRange), slateEditor.operations.some((o)=>o.type === \"set_selection\") || editorActor.send({\n                    type: \"selection\",\n                    selection: normalizedSelection\n                }), slateEditor.onChange());\n            }\n        }\n    }, [\n        blockTypeName,\n        editorActor,\n        propsSelection,\n        slateEditor\n    ]), syncRangeDecorations = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((operation)=>{\n        if (rangeDecorations && rangeDecorations.length > 0) {\n            const newSlateRanges = [];\n            if (rangeDecorations.forEach((rangeDecorationItem)=>{\n                const slateRange_0 = toSlateRange(rangeDecorationItem.selection, slateEditor);\n                if (!slate__WEBPACK_IMPORTED_MODULE_15__.Range.isRange(slateRange_0)) {\n                    rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n                        newSelection: null,\n                        rangeDecoration: rangeDecorationItem,\n                        origin: \"local\"\n                    });\n                    return;\n                }\n                let newRange;\n                if (operation && (newRange = moveRangeByOperation(slateRange_0, operation), newRange && newRange !== slateRange_0 || newRange === null && slateRange_0)) {\n                    const value = PortableTextEditor.getValue(portableTextEditor), newRangeSelection = toPortableTextRange(value, newRange, schemaTypes);\n                    rangeDecorationItem.onMoved && rangeDecorationItem.onMoved({\n                        newSelection: newRangeSelection,\n                        rangeDecoration: rangeDecorationItem,\n                        origin: \"local\"\n                    });\n                }\n                newRange !== null && newSlateRanges.push({\n                    ...newRange || slateRange_0,\n                    rangeDecoration: rangeDecorationItem\n                });\n            }), newSlateRanges.length > 0) {\n                setRangeDecorationsState(newSlateRanges);\n                return;\n            }\n        }\n        setRangeDecorationsState((rangeDecorationState_0)=>rangeDecorationState_0.length > 0 ? [] : rangeDecorationState_0);\n    }, [\n        portableTextEditor,\n        rangeDecorations,\n        schemaTypes,\n        slateEditor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        const onReady = editorActor.on(\"ready\", ()=>{\n            syncRangeDecorations(), restoreSelectionFromProps();\n        }), onInvalidValue = editorActor.on(\"invalid value\", ()=>{\n            setHasInvalidValue(!0);\n        }), onValueChanged = editorActor.on(\"value changed\", ()=>{\n            setHasInvalidValue(!1);\n        });\n        return ()=>{\n            onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();\n        };\n    }, [\n        editorActor,\n        restoreSelectionFromProps,\n        syncRangeDecorations\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        propsSelection && !hasInvalidValue && restoreSelectionFromProps();\n    }, [\n        hasInvalidValue,\n        propsSelection,\n        restoreSelectionFromProps\n    ]);\n    const [syncedRangeDecorations, setSyncedRangeDecorations] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(!1);\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        syncedRangeDecorations || (setSyncedRangeDecorations(!0), syncRangeDecorations());\n    }, [\n        syncRangeDecorations,\n        syncedRangeDecorations\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_2__(rangeDecorations, rangeDecorationsRef.current) || syncRangeDecorations(), rangeDecorationsRef.current = rangeDecorations;\n    }, [\n        rangeDecorations,\n        syncRangeDecorations\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        const teardown = withSyncRangeDecorations({\n            editorActor,\n            slateEditor,\n            syncRangeDecorations\n        });\n        return ()=>teardown();\n    }, [\n        editorActor,\n        slateEditor,\n        syncRangeDecorations\n    ]);\n    const handleCopy = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event)=>{\n        onCopy ? onCopy(event) !== void 0 && event.preventDefault() : event.nativeEvent.clipboardData && editorActor.send({\n            type: \"behavior event\",\n            behaviorEvent: {\n                type: \"copy\",\n                data: event.nativeEvent.clipboardData\n            },\n            editor: slateEditor,\n            nativeEvent: event\n        });\n    }, [\n        onCopy,\n        editorActor,\n        slateEditor\n    ]), handlePaste = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_0)=>{\n        const value_0 = PortableTextEditor.getValue(portableTextEditor), path = toPortableTextRange(value_0, slateEditor.selection, schemaTypes)?.focus.path || [], onPasteResult = onPaste?.({\n            event: event_0,\n            value: value_0,\n            path,\n            schemaTypes\n        });\n        onPasteResult || !slateEditor.selection ? (event_0.preventDefault(), editorActor.send({\n            type: \"loading\"\n        }), Promise.resolve(onPasteResult).then((result_0)=>{\n            debug(\"Custom paste function from client resolved\", result_0), !result_0 || !result_0.insert ? (debug(\"No result from custom paste handler, pasting normally\"), slateEditor.insertData(event_0.clipboardData)) : result_0.insert ? slateEditor.insertFragment(toSlateValue(result_0.insert, {\n                schemaTypes\n            })) : console.warn(\"Your onPaste function returned something unexpected:\", result_0);\n        }).catch((error)=>(console.error(error), error)).finally(()=>{\n            editorActor.send({\n                type: \"done loading\"\n            });\n        })) : event_0.nativeEvent.clipboardData && editorActor.send({\n            type: \"behavior event\",\n            behaviorEvent: {\n                type: \"paste\",\n                data: event_0.nativeEvent.clipboardData\n            },\n            editor: slateEditor,\n            nativeEvent: event_0\n        }), debug(\"No result from custom paste handler, pasting normally\");\n    }, [\n        editorActor,\n        onPaste,\n        portableTextEditor,\n        schemaTypes,\n        slateEditor\n    ]), handleOnFocus = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_1)=>{\n        if (onFocus && onFocus(event_1), !event_1.isDefaultPrevented()) {\n            const selection = PortableTextEditor.getSelection(portableTextEditor);\n            selection === null && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, slate__WEBPACK_IMPORTED_MODULE_15__.Editor.start(slateEditor, [])), slateEditor.onChange()), editorActor.send({\n                type: \"focused\",\n                event: event_1\n            });\n            const newSelection = PortableTextEditor.getSelection(portableTextEditor);\n            selection === newSelection && editorActor.send({\n                type: \"selection\",\n                selection\n            });\n        }\n    }, [\n        editorActor,\n        onFocus,\n        portableTextEditor,\n        slateEditor\n    ]), handleClick = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_2)=>{\n        onClick && onClick(event_2);\n        const focusBlockPath = slateEditor.selection ? slateEditor.selection.focus.path.slice(0, 1) : void 0, focusBlock = focusBlockPath ? slate__WEBPACK_IMPORTED_MODULE_15__.Node.descendant(slateEditor, focusBlockPath) : void 0, [_, lastNodePath] = slate__WEBPACK_IMPORTED_MODULE_15__.Node.last(slateEditor, []), lastBlockPath = lastNodePath.slice(0, 1), lastNodeFocused = focusBlockPath ? slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(lastBlockPath, focusBlockPath) : !1, lastBlockIsVoid = focusBlock ? !slateEditor.isTextBlock(focusBlock) : !1;\n        slateEditor.selection && slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(slateEditor.selection) && lastNodeFocused && lastBlockIsVoid && (slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.insertNodes(slateEditor, slateEditor.pteCreateTextBlock({\n            decorators: []\n        })), slateEditor.onChange());\n    }, [\n        onClick,\n        slateEditor\n    ]), handleOnBlur = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_3)=>{\n        onBlur && onBlur(event_3), event_3.isPropagationStopped() || editorActor.send({\n            type: \"blurred\",\n            event: event_3\n        });\n    }, [\n        editorActor,\n        onBlur\n    ]), handleOnBeforeInput = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_4)=>{\n        onBeforeInput && onBeforeInput(event_4);\n    }, [\n        onBeforeInput\n    ]), validateSelection = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(()=>{\n        if (!slateEditor.selection) return;\n        const root = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.findDocumentOrShadowRoot(slateEditor), { activeElement } = root;\n        if (ref.current !== activeElement) return;\n        const domSelection = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.getWindow(slateEditor).getSelection();\n        if (!domSelection || domSelection.rangeCount === 0) return;\n        const existingDOMRange = domSelection.getRangeAt(0);\n        try {\n            const newDOMRange = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMRange(slateEditor, slateEditor.selection);\n            (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug(\"DOM range out of sync, validating selection\"), domSelection?.removeAllRanges(), domSelection.addRange(newDOMRange));\n        } catch  {\n            debug(\"Could not resolve selection, selecting top document\"), slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.deselect(slateEditor), slateEditor.children.length > 0 && slate__WEBPACK_IMPORTED_MODULE_15__.Transforms.select(slateEditor, [\n                0,\n                0\n            ]), slateEditor.onChange();\n        }\n    }, [\n        ref,\n        slateEditor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        if (editableElement) {\n            const mutationObserver = new MutationObserver(validateSelection);\n            return mutationObserver.observe(editableElement, {\n                attributeOldValue: !1,\n                attributes: !1,\n                characterData: !1,\n                childList: !0,\n                subtree: !0\n            }), ()=>{\n                mutationObserver.disconnect();\n            };\n        }\n    }, [\n        validateSelection,\n        editableElement\n    ]);\n    const handleKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_5)=>{\n        props.onKeyDown && props.onKeyDown(event_5), event_5.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_5), event_5.isDefaultPrevented() || editorActor.send({\n            type: \"behavior event\",\n            behaviorEvent: {\n                type: \"key.down\",\n                keyboardEvent: {\n                    key: event_5.key,\n                    code: event_5.code,\n                    altKey: event_5.altKey,\n                    ctrlKey: event_5.ctrlKey,\n                    metaKey: event_5.metaKey,\n                    shiftKey: event_5.shiftKey\n                }\n            },\n            editor: slateEditor,\n            nativeEvent: event_5\n        });\n    }, [\n        props,\n        editorActor,\n        slateEditor\n    ]), handleKeyUp = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)((event_6)=>{\n        props.onKeyUp && props.onKeyUp(event_6), event_6.isDefaultPrevented() || editorActor.send({\n            type: \"behavior event\",\n            behaviorEvent: {\n                type: \"key.up\",\n                keyboardEvent: {\n                    key: event_6.key,\n                    code: event_6.code,\n                    altKey: event_6.altKey,\n                    ctrlKey: event_6.ctrlKey,\n                    metaKey: event_6.metaKey,\n                    shiftKey: event_6.shiftKey\n                }\n            },\n            editor: slateEditor,\n            nativeEvent: event_6\n        });\n    }, [\n        props,\n        editorActor,\n        slateEditor\n    ]), scrollSelectionIntoViewToSlate = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>{\n        if (scrollSelectionIntoView !== void 0) return scrollSelectionIntoView === null ? lodash_noop_js__WEBPACK_IMPORTED_MODULE_3__ : (_editor, domRange)=>{\n            scrollSelectionIntoView(portableTextEditor, domRange);\n        };\n    }, [\n        portableTextEditor,\n        scrollSelectionIntoView\n    ]), decorate = (0,react__WEBPACK_IMPORTED_MODULE_4__.useCallback)(([, path_0])=>{\n        if (isEqualToEmptyEditor(slateEditor.children, schemaTypes)) return [\n            {\n                anchor: {\n                    path: [\n                        0,\n                        0\n                    ],\n                    offset: 0\n                },\n                focus: {\n                    path: [\n                        0,\n                        0\n                    ],\n                    offset: 0\n                },\n                placeholder: !0\n            }\n        ];\n        if (path_0.length === 0) return [];\n        const result_1 = rangeDecorationState.filter((item)=>slate__WEBPACK_IMPORTED_MODULE_15__.Range.isCollapsed(item) ? path_0.length !== 2 ? !1 : slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(item.focus.path, path_0) && slate__WEBPACK_IMPORTED_MODULE_15__.Path.equals(item.anchor.path, path_0) : slate__WEBPACK_IMPORTED_MODULE_15__.Range.intersection(item, {\n                anchor: {\n                    path: path_0,\n                    offset: 0\n                },\n                focus: {\n                    path: path_0,\n                    offset: 0\n                }\n            }) || slate__WEBPACK_IMPORTED_MODULE_15__.Range.includes(item, path_0));\n        return result_1.length > 0 ? result_1 : [];\n    }, [\n        slateEditor,\n        schemaTypes,\n        rangeDecorationState\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        ref.current = slate_react__WEBPACK_IMPORTED_MODULE_17__.ReactEditor.toDOMNode(slateEditor, slateEditor), setEditableElement(ref.current);\n    }, [\n        slateEditor,\n        ref\n    ]), portableTextEditor ? hasInvalidValue ? null : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_17__.Editable, {\n        ...restProps,\n        autoFocus: !1,\n        className: restProps.className || \"pt-editable\",\n        decorate,\n        onBlur: handleOnBlur,\n        onCopy: handleCopy,\n        onClick: handleClick,\n        onDOMBeforeInput: handleOnBeforeInput,\n        onFocus: handleOnFocus,\n        onKeyDown: handleKeyDown,\n        onKeyUp: handleKeyUp,\n        onPaste: handlePaste,\n        readOnly,\n        renderPlaceholder: void 0,\n        renderElement,\n        renderLeaf,\n        scrollSelectionIntoView: scrollSelectionIntoViewToSlate\n    }) : null;\n});\nPortableTextEditable.displayName = \"ForwardRef(PortableTextEditable)\";\nconst EditorContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_4__.createContext(void 0);\nfunction EditorProvider(props) {\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(28), editor = useCreateEditor(props.initialConfig), editorActor = editor._internal.editorActor, slateEditor = editor._internal.slateEditor;\n    let t0, t1;\n    $[0] !== editor ? (t1 = new PortableTextEditor({\n        editor\n    }), $[0] = editor, $[1] = t1) : t1 = $[1], t0 = t1;\n    const portableTextEditor = t0;\n    let t2;\n    $[2] !== portableTextEditor.change$ ? (t2 = (change)=>{\n        portableTextEditor.change$.next(change);\n    }, $[2] = portableTextEditor.change$, $[3] = t2) : t2 = $[3];\n    let t3;\n    $[4] !== editorActor || $[5] !== t2 ? (t3 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RouteEventsToChanges, {\n        editorActor,\n        onChange: t2\n    }), $[4] = editorActor, $[5] = t2, $[6] = t3) : t3 = $[6];\n    let t4;\n    $[7] !== editorActor || $[8] !== slateEditor.instance ? (t4 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Synchronizer, {\n        editorActor,\n        slateEditor: slateEditor.instance\n    }), $[7] = editorActor, $[8] = slateEditor.instance, $[9] = t4) : t4 = $[9];\n    let t5;\n    $[10] !== editorActor || $[11] !== props.children ? (t5 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorSelectionProvider, {\n        editorActor,\n        children: props.children\n    }), $[10] = editorActor, $[11] = props.children, $[12] = t5) : t5 = $[12];\n    let t6;\n    $[13] !== portableTextEditor || $[14] !== t5 ? (t6 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PortableTextEditorContext.Provider, {\n        value: portableTextEditor,\n        children: t5\n    }), $[13] = portableTextEditor, $[14] = t5, $[15] = t6) : t6 = $[15];\n    let t7;\n    $[16] !== slateEditor.initialValue || $[17] !== slateEditor.instance || $[18] !== t6 ? (t7 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(slate_react__WEBPACK_IMPORTED_MODULE_17__.Slate, {\n        editor: slateEditor.instance,\n        initialValue: slateEditor.initialValue,\n        children: t6\n    }), $[16] = slateEditor.initialValue, $[17] = slateEditor.instance, $[18] = t6, $[19] = t7) : t7 = $[19];\n    let t8;\n    $[20] !== editorActor || $[21] !== t7 ? (t8 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorActorContext.Provider, {\n        value: editorActor,\n        children: t7\n    }), $[20] = editorActor, $[21] = t7, $[22] = t8) : t8 = $[22];\n    let t9;\n    return $[23] !== editor || $[24] !== t3 || $[25] !== t4 || $[26] !== t8 ? (t9 = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(EditorContext.Provider, {\n        value: editor,\n        children: [\n            t3,\n            t4,\n            t8\n        ]\n    }), $[23] = editor, $[24] = t3, $[25] = t4, $[26] = t8, $[27] = t9) : t9 = $[27], t9;\n}\nfunction useEditor() {\n    const editor = react__WEBPACK_IMPORTED_MODULE_4__.useContext(EditorContext);\n    if (!editor) throw new Error(\"No Editor set. Use EditorProvider to set one.\");\n    return editor;\n}\nfunction EditorEventListener(props) {\n    const $ = (0,react_compiler_runtime__WEBPACK_IMPORTED_MODULE_6__.c)(4), editor = useEditor(), on = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_28__.useEffectEvent)(props.on);\n    let t0, t1;\n    return $[0] !== editor || $[1] !== on ? (t0 = ()=>{\n        const subscription = editor.on(\"*\", on);\n        return ()=>{\n            subscription.unsubscribe();\n        };\n    }, t1 = [\n        editor,\n        on\n    ], $[0] = editor, $[1] = on, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(t0, t1), null;\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3IvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQzRIO0FBQzNIO0FBQ2U7QUFDQztBQUNqQjtBQUNOO0FBQ3VJO0FBQ2M7QUFDMUU7QUFDakY7QUFDZTtBQUNBO0FBQ1Q7QUFDSDtBQUNtQjtBQUNtRDtBQUNrQjtBQUMvRTtBQUNZO0FBQ3BCO0FBQ2dCO0FBQ1Y7QUFDeUM7QUFDMEI7QUFDckQ7QUFDZTtBQUNuRSxTQUFTa0YsbUJBQW1CQyxnQkFBZ0I7SUFDMUMsSUFBSSxDQUFDQSxrQkFDSCxNQUFNLElBQUlDLE1BQU07SUFDbEIsTUFBTUMsWUFBWUYsaUJBQWlCRyxFQUFFLEVBQUVDLEtBQUtDO0lBQzVDLElBQUksQ0FBQ0gsV0FDSCxNQUFNLElBQUlELE1BQU07SUFDbEIsTUFBTUssZ0JBQWdCSixVQUFVSyxNQUFNLEVBQUVILEtBQUssQ0FBQ0ksUUFBVUEsTUFBTUMsSUFBSSxLQUFLO0lBQ3ZFLElBQUksQ0FBQ0gsZUFDSCxNQUFNLElBQUlMLE1BQU07SUFDbEIsTUFBTVMsU0FBU0osY0FBY0ssSUFBSSxDQUFDUixFQUFFO0lBQ3BDLElBQUksQ0FBQ08sUUFDSCxNQUFNLElBQUlULE1BQU07SUFDbEIsTUFBTVcsV0FBV0YsT0FBT04sSUFBSSxDQUFDLENBQUNTLGFBQWVBLFdBQVdKLElBQUksS0FBSztJQUNqRSxJQUFJLENBQUNHLFVBQ0gsTUFBTSxJQUFJWCxNQUFNO0lBQ2xCLE1BQU1hLG9CQUFvQkosT0FBT0ssTUFBTSxDQUFDLENBQUNGLGFBQWVBLFdBQVdKLElBQUksS0FBSyxXQUFXLEVBQUUsRUFBRU8sbUJBQW1CaEIsaUJBQWlCRyxFQUFFLEVBQUVZLE9BQU8sQ0FBQ1AsUUFBVUEsTUFBTUMsSUFBSSxLQUFLUCxVQUFVTyxJQUFJLEtBQUssRUFBRTtJQUN6TCxPQUFPO1FBQ0xRLFFB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QUM1QyxNQUFNd3NCLGVBQWV6eEIsT0FBTzJSLEVBQUUsQ0FBQyxLQUFLQTtRQUNwQyxPQUFPO1lBQ0w4ZixhQUFhN0csV0FBVztRQUMxQjtJQUNGLEdBQUd4bEIsS0FBSztRQUFDcEY7UUFBUTJSO0tBQUcsRUFBRTNNLENBQUMsQ0FBQyxFQUFFLEdBQUdoRixRQUFRZ0YsQ0FBQyxDQUFDLEVBQUUsR0FBRzJNLElBQUkzTSxDQUFDLENBQUMsRUFBRSxHQUFHQyxJQUFJRCxDQUFDLENBQUMsRUFBRSxHQUFHSSxFQUFDLElBQU1ILENBQUFBLEtBQUtELENBQUMsQ0FBQyxFQUFFLEVBQUVJLEtBQUtKLENBQUMsQ0FBQyxFQUFFLEdBQUd6TixnREFBU0EsQ0FBQzBOLElBQUlHLEtBQUs7QUFDckg7QUFhRSxDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL0Bwb3J0YWJsZXRleHQvZWRpdG9yL2xpYi9pbmRleC5qcz9iMjJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNjaGVtYSB9IGZyb20gXCJAc2FuaXR5L3NjaGVtYVwiO1xuaW1wb3J0IHsgZGVmaW5lVHlwZSwgZGVmaW5lRmllbGQsIGlzS2V5U2VnbWVudCwgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0U3BhbiBhcyBpc1BvcnRhYmxlVGV4dFNwYW4kMSwgaXNQb3J0YWJsZVRleHRMaXN0QmxvY2sgfSBmcm9tIFwiQHNhbml0eS90eXBlc1wiO1xuaW1wb3J0IHN0YXJ0Q2FzZSBmcm9tIFwibG9kYXNoLnN0YXJ0Y2FzZVwiO1xuaW1wb3J0IHsganN4LCBGcmFnbWVudCwganN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgdXNlU2VsZWN0b3IsIHVzZUFjdG9yUmVmIH0gZnJvbSBcIkB4c3RhdGUvcmVhY3RcIjtcbmltcG9ydCBpc0VxdWFsIGZyb20gXCJsb2Rhc2gvaXNFcXVhbC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcImxvZGFzaC9ub29wLmpzXCI7XG5pbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VNZW1vLCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCBzdGFydFRyYW5zaXRpb24sIENvbXBvbmVudCwgdXNlQ2FsbGJhY2ssIGZvcndhcmRSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEVkaXRvciwgRWxlbWVudCBhcyBFbGVtZW50JDEsIFJhbmdlLCBQb2ludCwgVGV4dCwgUGF0aCwgVHJhbnNmb3JtcywgT3BlcmF0aW9uLCBOb2RlLCBjcmVhdGVFZGl0b3IgYXMgY3JlYXRlRWRpdG9yJDEsIGRlbGV0ZUJhY2t3YXJkLCBkZWxldGVGb3J3YXJkLCBpbnNlcnRUZXh0IH0gZnJvbSBcInNsYXRlXCI7XG5pbXBvcnQgeyB1c2VTbGF0ZVN0YXRpYywgUmVhY3RFZGl0b3IsIHVzZVNlbGVjdGVkLCB3aXRoUmVhY3QsIFNsYXRlLCB1c2VTbGF0ZSwgRWRpdGFibGUgfSBmcm9tIFwic2xhdGUtcmVhY3RcIjtcbmltcG9ydCBkZWJ1ZyRsIGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgYyB9IGZyb20gXCJyZWFjdC1jb21waWxlci1ydW50aW1lXCI7XG5pbXBvcnQgeyBzdHlsZWQgfSBmcm9tIFwic3R5bGVkLWNvbXBvbmVudHNcIjtcbmltcG9ydCB1bmlxIGZyb20gXCJsb2Rhc2gvdW5pcS5qc1wiO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3RFdmVudCB9IGZyb20gXCJ1c2UtZWZmZWN0LWV2ZW50XCI7XG5pbXBvcnQgeyBzZXR1cCwgZW1pdCwgYXNzaWduLCBmcm9tQ2FsbGJhY2ssIGFzc2VydEV2ZW50LCBlbnF1ZXVlQWN0aW9ucywgY3JlYXRlQWN0b3IgfSBmcm9tIFwieHN0YXRlXCI7XG5pbXBvcnQgeyB1bnNldCwgc2V0LCBzZXRJZk1pc3NpbmcsIGluc2VydCwgZGlmZk1hdGNoUGF0Y2ggYXMgZGlmZk1hdGNoUGF0Y2gkMSwgYXBwbHlBbGwgfSBmcm9tIFwiQHBvcnRhYmxldGV4dC9wYXRjaGVzXCI7XG5pbXBvcnQgZmxhdHRlbiBmcm9tIFwibG9kYXNoL2ZsYXR0ZW4uanNcIjtcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gXCJsb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1wiO1xuaW1wb3J0IGdldCBmcm9tIFwibG9kYXNoL2dldC5qc1wiO1xuaW1wb3J0IGlzVW5kZWZpbmVkIGZyb20gXCJsb2Rhc2gvaXNVbmRlZmluZWQuanNcIjtcbmltcG9ydCBvbWl0QnkgZnJvbSBcImxvZGFzaC9vbWl0QnkuanNcIjtcbmltcG9ydCB7IGNyZWF0ZUd1YXJkcyB9IGZyb20gXCIuL19jaHVua3MtZXMvc2VsZWN0b3IuaXMtc2VsZWN0aW9uLWNvbGxhcHNlZC5qc1wiO1xuaW1wb3J0IHsgYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCwgY29yZUJlaGF2aW9ycywgaXNIb3RrZXkgfSBmcm9tIFwiLi9fY2h1bmtzLWVzL2JlaGF2aW9yLmNvcmUuanNcIjtcbmltcG9ydCBnZXRSYW5kb21WYWx1ZXMgZnJvbSBcImdldC1yYW5kb20tdmFsdWVzLWVzbVwiO1xuaW1wb3J0IHsgaHRtbFRvQmxvY2tzLCBub3JtYWxpemVCbG9jayB9IGZyb20gXCJAc2FuaXR5L2Jsb2NrLXRvb2xzXCI7XG5mdW5jdGlvbiBjcmVhdGVFZGl0b3JTY2hlbWEocG9ydGFibGVUZXh0VHlwZSkge1xuICBpZiAoIXBvcnRhYmxlVGV4dFR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyICdwb3J0YWJsZXRleHRUeXBlJyBtaXNzaW5nIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IGJsb2NrVHlwZSA9IHBvcnRhYmxlVGV4dFR5cGUub2Y/LmZpbmQoZmluZEJsb2NrVHlwZSk7XG4gIGlmICghYmxvY2tUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIHR5cGUgaXMgbm90IGRlZmluZWQgaW4gdGhpcyBzY2hlbWEgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3QgY2hpbGRyZW5GaWVsZCA9IGJsb2NrVHlwZS5maWVsZHM/LmZpbmQoKGZpZWxkKSA9PiBmaWVsZC5uYW1lID09PSBcImNoaWxkcmVuXCIpO1xuICBpZiAoIWNoaWxkcmVuRmllbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGRyZW4gZmllbGQgZm9yIGJsb2NrIHR5cGUgZm91bmQgaW4gc2NoZW1hIChyZXF1aXJlZClcIik7XG4gIGNvbnN0IG9mVHlwZSA9IGNoaWxkcmVuRmllbGQudHlwZS5vZjtcbiAgaWYgKCFvZlR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWQgdHlwZXMgZm9yIGJsb2NrIGNoaWxkcmVuIG5vdCBmb3VuZCBpbiBzY2hlbWEgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3Qgc3BhblR5cGUgPSBvZlR5cGUuZmluZCgobWVtYmVyVHlwZSkgPT4gbWVtYmVyVHlwZS5uYW1lID09PSBcInNwYW5cIik7XG4gIGlmICghc3BhblR5cGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3BhbiB0eXBlIG5vdCBmb3VuZCBpbiBzY2hlbWEgKHJlcXVpcmVkKVwiKTtcbiAgY29uc3QgaW5saW5lT2JqZWN0VHlwZXMgPSBvZlR5cGUuZmlsdGVyKChtZW1iZXJUeXBlKSA9PiBtZW1iZXJUeXBlLm5hbWUgIT09IFwic3BhblwiKSB8fCBbXSwgYmxvY2tPYmplY3RUeXBlcyA9IHBvcnRhYmxlVGV4dFR5cGUub2Y/LmZpbHRlcigoZmllbGQpID0+IGZpZWxkLm5hbWUgIT09IGJsb2NrVHlwZS5uYW1lKSB8fCBbXTtcbiAgcmV0dXJuIHtcbiAgICBzdHlsZXM6IHJlc29sdmVFbmFibGVkU3R5bGVzKGJsb2NrVHlwZSksXG4gICAgZGVjb3JhdG9yczogcmVzb2x2ZUVuYWJsZWREZWNvcmF0b3JzKHNwYW5UeXBlKSxcbiAgICBsaXN0czogcmVzb2x2ZUVuYWJsZWRMaXN0SXRlbXMoYmxvY2tUeXBlKSxcbiAgICBibG9jazogYmxvY2tUeXBlLFxuICAgIHNwYW46IHNwYW5UeXBlLFxuICAgIHBvcnRhYmxlVGV4dDogcG9ydGFibGVUZXh0VHlwZSxcbiAgICBpbmxpbmVPYmplY3RzOiBpbmxpbmVPYmplY3RUeXBlcyxcbiAgICBibG9ja09iamVjdHM6IGJsb2NrT2JqZWN0VHlwZXMsXG4gICAgYW5ub3RhdGlvbnM6IHNwYW5UeXBlLmFubm90YXRpb25zXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZFN0eWxlcyhibG9ja1R5cGUpIHtcbiAgY29uc3Qgc3R5bGVGaWVsZCA9IGJsb2NrVHlwZS5maWVsZHM/LmZpbmQoKGJ0RmllbGQpID0+IGJ0RmllbGQubmFtZSA9PT0gXCJzdHlsZVwiKTtcbiAgaWYgKCFzdHlsZUZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkEgZmllbGQgd2l0aCBuYW1lICdzdHlsZScgaXMgbm90IGRlZmluZWQgaW4gdGhlIGJsb2NrIHR5cGUgKHJlcXVpcmVkKS5cIik7XG4gIGNvbnN0IHRleHRTdHlsZXMgPSBzdHlsZUZpZWxkLnR5cGUub3B0aW9ucz8ubGlzdCAmJiBzdHlsZUZpZWxkLnR5cGUub3B0aW9ucy5saXN0Py5maWx0ZXIoKHN0eWxlKSA9PiBzdHlsZS52YWx1ZSk7XG4gIGlmICghdGV4dFN0eWxlcyB8fCB0ZXh0U3R5bGVzLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUgZmllbGRzIG5lZWQgYXQgbGVhc3Qgb25lIHN0eWxlIGRlZmluZWQuIEkuZToge3RpdGxlOiAnTm9ybWFsJywgdmFsdWU6ICdub3JtYWwnfS5cIik7XG4gIHJldHVybiB0ZXh0U3R5bGVzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWREZWNvcmF0b3JzKHNwYW5UeXBlKSB7XG4gIHJldHVybiBzcGFuVHlwZS5kZWNvcmF0b3JzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWRMaXN0SXRlbXMoYmxvY2tUeXBlKSB7XG4gIGNvbnN0IGxpc3RGaWVsZCA9IGJsb2NrVHlwZS5maWVsZHM/LmZpbmQoKGJ0RmllbGQpID0+IGJ0RmllbGQubmFtZSA9PT0gXCJsaXN0SXRlbVwiKTtcbiAgaWYgKCFsaXN0RmllbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQSBmaWVsZCB3aXRoIG5hbWUgJ2xpc3RJdGVtJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgYmxvY2sgdHlwZSAocmVxdWlyZWQpLlwiKTtcbiAgY29uc3QgbGlzdEl0ZW1zID0gbGlzdEZpZWxkLnR5cGUub3B0aW9ucz8ubGlzdCAmJiBsaXN0RmllbGQudHlwZS5vcHRpb25zLmxpc3QuZmlsdGVyKChsaXN0KSA9PiBsaXN0LnZhbHVlKTtcbiAgaWYgKCFsaXN0SXRlbXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxpc3QgZmllbGQgbmVlZCBhdCBsZWFzdCB0byBiZSBhbiBlbXB0eSBhcnJheVwiKTtcbiAgcmV0dXJuIGxpc3RJdGVtcztcbn1cbmZ1bmN0aW9uIGZpbmRCbG9ja1R5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZS50eXBlID8gZmluZEJsb2NrVHlwZSh0eXBlLnR5cGUpIDogdHlwZS5uYW1lID09PSBcImJsb2NrXCIgPyB0eXBlIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGRlZmluZVNjaGVtYShkZWZpbml0aW9uKSB7XG4gIHJldHVybiBkZWZpbml0aW9uO1xufVxuZnVuY3Rpb24gY29tcGlsZVNjaGVtYURlZmluaXRpb24oZGVmaW5pdGlvbikge1xuICBjb25zdCBibG9ja09iamVjdHMgPSBkZWZpbml0aW9uPy5ibG9ja09iamVjdHM/Lm1hcCgoYmxvY2tPYmplY3QpID0+IGRlZmluZVR5cGUoe1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgLy8gVmVyeSBuYWl2ZSB3YXkgdG8gd29yayBhcm91bmQgYFNhbml0eVNjaGVtYS5jb21waWxlYCBhZGRpbmcgZGVmYXVsdFxuICAgIC8vIGZpZWxkcyB0byBvYmplY3RzIHdpdGggdGhlIG5hbWUgYGltYWdlYFxuICAgIG5hbWU6IGJsb2NrT2JqZWN0Lm5hbWUgPT09IFwiaW1hZ2VcIiA/IFwidG1wLWltYWdlXCIgOiBibG9ja09iamVjdC5uYW1lLFxuICAgIHRpdGxlOiBibG9ja09iamVjdC50aXRsZSxcbiAgICBmaWVsZHM6IFtdXG4gIH0pKSA/PyBbXSwgaW5saW5lT2JqZWN0cyA9IGRlZmluaXRpb24/LmlubGluZU9iamVjdHM/Lm1hcCgoaW5saW5lT2JqZWN0KSA9PiBkZWZpbmVUeXBlKHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIG5hbWU6IGlubGluZU9iamVjdC5uYW1lLFxuICAgIHRpdGxlOiBpbmxpbmVPYmplY3QudGl0bGUsXG4gICAgZmllbGRzOiBbXVxuICB9KSkgPz8gW10sIHBvcnRhYmxlVGV4dFNjaGVtYSA9IGRlZmluZUZpZWxkKHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbmFtZTogXCJwb3J0YWJsZS10ZXh0XCIsXG4gICAgb2Y6IFsuLi5ibG9ja09iamVjdHMubWFwKChibG9ja09iamVjdCkgPT4gKHtcbiAgICAgIHR5cGU6IGJsb2NrT2JqZWN0Lm5hbWVcbiAgICB9KSksIHtcbiAgICAgIHR5cGU6IFwiYmxvY2tcIixcbiAgICAgIG5hbWU6IFwiYmxvY2tcIixcbiAgICAgIG9mOiBpbmxpbmVPYmplY3RzLm1hcCgoaW5saW5lT2JqZWN0KSA9PiAoe1xuICAgICAgICB0eXBlOiBpbmxpbmVPYmplY3QubmFtZVxuICAgICAgfSkpLFxuICAgICAgbWFya3M6IHtcbiAgICAgICAgZGVjb3JhdG9yczogZGVmaW5pdGlvbj8uZGVjb3JhdG9ycz8ubWFwKChkZWNvcmF0b3IpID0+ICh7XG4gICAgICAgICAgdGl0bGU6IGRlY29yYXRvci50aXRsZSA/PyBzdGFydENhc2UoZGVjb3JhdG9yLm5hbWUpLFxuICAgICAgICAgIHZhbHVlOiBkZWNvcmF0b3IubmFtZVxuICAgICAgICB9KSkgPz8gW10sXG4gICAgICAgIGFubm90YXRpb25zOiBkZWZpbml0aW9uPy5hbm5vdGF0aW9ucz8ubWFwKChhbm5vdGF0aW9uKSA9PiAoe1xuICAgICAgICAgIG5hbWU6IGFubm90YXRpb24ubmFtZSxcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgIHRpdGxlOiBhbm5vdGF0aW9uLnRpdGxlXG4gICAgICAgIH0pKSA/PyBbXVxuICAgICAgfSxcbiAgICAgIGxpc3RzOiBkZWZpbml0aW9uPy5saXN0cz8ubWFwKChsaXN0KSA9PiAoe1xuICAgICAgICB2YWx1ZTogbGlzdC5uYW1lLFxuICAgICAgICB0aXRsZTogbGlzdC50aXRsZSA/PyBzdGFydENhc2UobGlzdC5uYW1lKVxuICAgICAgfSkpID8/IFtdLFxuICAgICAgc3R5bGVzOiBkZWZpbml0aW9uPy5zdHlsZXM/Lm1hcCgoc3R5bGUpID0+ICh7XG4gICAgICAgIHZhbHVlOiBzdHlsZS5uYW1lLFxuICAgICAgICB0aXRsZTogc3R5bGUudGl0bGUgPz8gc3RhcnRDYXNlKHN0eWxlLm5hbWUpXG4gICAgICB9KSkgPz8gW11cbiAgICB9XVxuICB9KSwgc2NoZW1hID0gU2NoZW1hLmNvbXBpbGUoe1xuICAgIHR5cGVzOiBbcG9ydGFibGVUZXh0U2NoZW1hLCAuLi5ibG9ja09iamVjdHMsIC4uLmlubGluZU9iamVjdHNdXG4gIH0pLmdldChcInBvcnRhYmxlLXRleHRcIiksIHB0ZVNjaGVtYSA9IGNyZWF0ZUVkaXRvclNjaGVtYShzY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIC4uLnB0ZVNjaGVtYSxcbiAgICBibG9ja09iamVjdHM6IHB0ZVNjaGVtYS5ibG9ja09iamVjdHMubWFwKChibG9ja09iamVjdCkgPT4gYmxvY2tPYmplY3QubmFtZSA9PT0gXCJ0bXAtaW1hZ2VcIiA/IHtcbiAgICAgIC4uLmJsb2NrT2JqZWN0LFxuICAgICAgbmFtZTogXCJpbWFnZVwiLFxuICAgICAgdHlwZToge1xuICAgICAgICAuLi5ibG9ja09iamVjdC50eXBlLFxuICAgICAgICBuYW1lOiBcImltYWdlXCJcbiAgICAgIH1cbiAgICB9IDogYmxvY2tPYmplY3QpXG4gIH07XG59XG5jb25zdCByb290TmFtZSA9IFwic2FuaXR5LXB0ZTpcIjtcbmRlYnVnJGwocm9vdE5hbWUpO1xuZnVuY3Rpb24gZGVidWdXaXRoTmFtZShuYW1lKSB7XG4gIGNvbnN0IG5hbWVzcGFjZSA9IGAke3Jvb3ROYW1lfSR7bmFtZX1gO1xuICByZXR1cm4gZGVidWckbCAmJiBkZWJ1ZyRsLmVuYWJsZWQobmFtZXNwYWNlKSA/IGRlYnVnJGwobmFtZXNwYWNlKSA6IGRlYnVnJGwocm9vdE5hbWUpO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5ZWRQYXRoKHBvaW50LCB2YWx1ZSwgdHlwZXMpIHtcbiAgY29uc3QgYmxvY2tQYXRoID0gW3BvaW50LnBhdGhbMF1dO1xuICBpZiAoIXZhbHVlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBibG9jayA9IHZhbHVlW2Jsb2NrUGF0aFswXV07XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGtleWVkQmxvY2tQYXRoID0gW3tcbiAgICBfa2V5OiBibG9jay5fa2V5XG4gIH1dO1xuICBpZiAoYmxvY2suX3R5cGUgIT09IHR5cGVzLmJsb2NrLm5hbWUpXG4gICAgcmV0dXJuIGtleWVkQmxvY2tQYXRoO1xuICBsZXQga2V5ZWRDaGlsZFBhdGg7XG4gIGNvbnN0IGNoaWxkUGF0aCA9IHBvaW50LnBhdGguc2xpY2UoMCwgMiksIGNoaWxkID0gQXJyYXkuaXNBcnJheShibG9jay5jaGlsZHJlbikgJiYgYmxvY2suY2hpbGRyZW5bY2hpbGRQYXRoWzFdXTtcbiAgcmV0dXJuIGNoaWxkICYmIChrZXllZENoaWxkUGF0aCA9IFtcImNoaWxkcmVuXCIsIHtcbiAgICBfa2V5OiBjaGlsZC5fa2V5XG4gIH1dKSwga2V5ZWRDaGlsZFBhdGggPyBbLi4ua2V5ZWRCbG9ja1BhdGgsIC4uLmtleWVkQ2hpbGRQYXRoXSA6IGtleWVkQmxvY2tQYXRoO1xufVxuZnVuY3Rpb24gdG9TbGF0ZVBhdGgocGF0aCwgZWRpdG9yKSB7XG4gIGlmICghZWRpdG9yKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IFtdLFxuICAgIG1hdGNoOiAobikgPT4gaXNLZXlTZWdtZW50KHBhdGhbMF0pICYmIG4uX2tleSA9PT0gcGF0aFswXS5fa2V5XG4gIH0pKVswXSB8fCBbdm9pZCAwLCB2b2lkIDBdO1xuICBpZiAoIWJsb2NrIHx8ICFFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSlcbiAgICByZXR1cm4gW107XG4gIGlmIChlZGl0b3IuaXNWb2lkKGJsb2NrKSlcbiAgICByZXR1cm4gW2Jsb2NrUGF0aFswXSwgMF07XG4gIGNvbnN0IGNoaWxkUGF0aCA9IFtwYXRoWzJdXSwgY2hpbGRJbmRleCA9IGJsb2NrLmNoaWxkcmVuLmZpbmRJbmRleCgoY2hpbGQpID0+IGlzRXF1YWwoW3tcbiAgICBfa2V5OiBjaGlsZC5fa2V5XG4gIH1dLCBjaGlsZFBhdGgpKTtcbiAgaWYgKGNoaWxkSW5kZXggPj0gMCAmJiBibG9jay5jaGlsZHJlbltjaGlsZEluZGV4XSkge1xuICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5bY2hpbGRJbmRleF07XG4gICAgcmV0dXJuIEVsZW1lbnQkMS5pc0VsZW1lbnQoY2hpbGQpICYmIGVkaXRvci5pc1ZvaWQoY2hpbGQpID8gYmxvY2tQYXRoLmNvbmNhdChjaGlsZEluZGV4KS5jb25jYXQoMCkgOiBibG9ja1BhdGguY29uY2F0KGNoaWxkSW5kZXgpO1xuICB9XG4gIHJldHVybiBbYmxvY2tQYXRoWzBdLCAwXTtcbn1cbmZ1bmN0aW9uIHRvUG9ydGFibGVUZXh0UmFuZ2UodmFsdWUsIHJhbmdlLCB0eXBlcykge1xuICBpZiAoIXJhbmdlKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgYW5jaG9yID0gbnVsbCwgZm9jdXMgPSBudWxsO1xuICBjb25zdCBhbmNob3JQYXRoID0gcmFuZ2UuYW5jaG9yICYmIGNyZWF0ZUtleWVkUGF0aChyYW5nZS5hbmNob3IsIHZhbHVlLCB0eXBlcyk7XG4gIGFuY2hvclBhdGggJiYgcmFuZ2UuYW5jaG9yICYmIChhbmNob3IgPSB7XG4gICAgcGF0aDogYW5jaG9yUGF0aCxcbiAgICBvZmZzZXQ6IHJhbmdlLmFuY2hvci5vZmZzZXRcbiAgfSk7XG4gIGNvbnN0IGZvY3VzUGF0aCA9IHJhbmdlLmZvY3VzICYmIGNyZWF0ZUtleWVkUGF0aChyYW5nZS5mb2N1cywgdmFsdWUsIHR5cGVzKTtcbiAgZm9jdXNQYXRoICYmIHJhbmdlLmZvY3VzICYmIChmb2N1cyA9IHtcbiAgICBwYXRoOiBmb2N1c1BhdGgsXG4gICAgb2Zmc2V0OiByYW5nZS5mb2N1cy5vZmZzZXRcbiAgfSk7XG4gIGNvbnN0IGJhY2t3YXJkID0gISEoUmFuZ2UuaXNSYW5nZShyYW5nZSkgJiYgUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkpO1xuICByZXR1cm4gYW5jaG9yICYmIGZvY3VzID8ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1cyxcbiAgICBiYWNrd2FyZFxuICB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRvU2xhdGVSYW5nZShzZWxlY3Rpb24sIGVkaXRvcikge1xuICBpZiAoIXNlbGVjdGlvbiB8fCAhZWRpdG9yKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBhbmNob3IgPSB7XG4gICAgcGF0aDogdG9TbGF0ZVBhdGgoc2VsZWN0aW9uLmFuY2hvci5wYXRoLCBlZGl0b3IpLFxuICAgIG9mZnNldDogc2VsZWN0aW9uLmFuY2hvci5vZmZzZXRcbiAgfSwgZm9jdXMgPSB7XG4gICAgcGF0aDogdG9TbGF0ZVBhdGgoc2VsZWN0aW9uLmZvY3VzLnBhdGgsIGVkaXRvciksXG4gICAgb2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXMub2Zmc2V0XG4gIH07XG4gIHJldHVybiBmb2N1cy5wYXRoLmxlbmd0aCA9PT0gMCB8fCBhbmNob3IucGF0aC5sZW5ndGggPT09IDAgPyBudWxsIDogYW5jaG9yICYmIGZvY3VzID8ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG1vdmVSYW5nZUJ5T3BlcmF0aW9uKHJhbmdlLCBvcGVyYXRpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gUG9pbnQudHJhbnNmb3JtKHJhbmdlLmFuY2hvciwgb3BlcmF0aW9uKSwgZm9jdXMgPSBQb2ludC50cmFuc2Zvcm0ocmFuZ2UuZm9jdXMsIG9wZXJhdGlvbik7XG4gIHJldHVybiBhbmNob3IgPT09IG51bGwgfHwgZm9jdXMgPT09IG51bGwgPyBudWxsIDogUG9pbnQuZXF1YWxzKGFuY2hvciwgcmFuZ2UuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMoZm9jdXMsIHJhbmdlLmZvY3VzKSA/IHJhbmdlIDoge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQocG9pbnQsIHZhbHVlKSB7XG4gIGlmICghcG9pbnQgfHwgIXZhbHVlKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBuZXdQYXRoID0gW107XG4gIGxldCBuZXdPZmZzZXQgPSBwb2ludC5vZmZzZXQgfHwgMDtcbiAgY29uc3QgYmxvY2tLZXkgPSB0eXBlb2YgcG9pbnQucGF0aFswXSA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHBvaW50LnBhdGhbMF0gJiYgcG9pbnQucGF0aFswXS5fa2V5LCBjaGlsZEtleSA9IHR5cGVvZiBwb2ludC5wYXRoWzJdID09IFwib2JqZWN0XCIgJiYgXCJfa2V5XCIgaW4gcG9pbnQucGF0aFsyXSAmJiBwb2ludC5wYXRoWzJdLl9rZXksIGJsb2NrID0gdmFsdWUuZmluZCgoYmxrKSA9PiBibGsuX2tleSA9PT0gYmxvY2tLZXkpO1xuICBpZiAoYmxvY2spXG4gICAgbmV3UGF0aC5wdXNoKHtcbiAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICB9KTtcbiAgZWxzZVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoYmxvY2sgJiYgcG9pbnQucGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiKSB7XG4gICAgaWYgKCFibG9jay5jaGlsZHJlbiB8fCBBcnJheS5pc0FycmF5KGJsb2NrLmNoaWxkcmVuKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjaGlsZCA9IEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIGJsb2NrLmNoaWxkcmVuLmZpbmQoKGNsZCkgPT4gY2xkLl9rZXkgPT09IGNoaWxkS2V5KTtcbiAgICBpZiAoY2hpbGQpXG4gICAgICBuZXdQYXRoLnB1c2goXCJjaGlsZHJlblwiKSwgbmV3UGF0aC5wdXNoKHtcbiAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgfSksIG5ld09mZnNldCA9IGNoaWxkLnRleHQgJiYgY2hpbGQudGV4dC5sZW5ndGggPj0gcG9pbnQub2Zmc2V0ID8gcG9pbnQub2Zmc2V0IDogY2hpbGQudGV4dCAmJiBjaGlsZC50ZXh0Lmxlbmd0aCB8fCAwO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aDogbmV3UGF0aCxcbiAgICBvZmZzZXQ6IG5ld09mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbiwgdmFsdWUpIHtcbiAgaWYgKCFzZWxlY3Rpb24gfHwgIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IG5ld0FuY2hvciA9IG51bGwsIG5ld0ZvY3VzID0gbnVsbDtcbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICByZXR1cm4gYW5jaG9yICYmIHZhbHVlLmZpbmQoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgX2tleTogYmxrLl9rZXlcbiAgfSwgYW5jaG9yLnBhdGhbMF0pKSAmJiAobmV3QW5jaG9yID0gbm9ybWFsaXplUG9pbnQoYW5jaG9yLCB2YWx1ZSkpLCBmb2N1cyAmJiB2YWx1ZS5maW5kKChibGspID0+IGlzRXF1YWwoe1xuICAgIF9rZXk6IGJsay5fa2V5XG4gIH0sIGZvY3VzLnBhdGhbMF0pKSAmJiAobmV3Rm9jdXMgPSBub3JtYWxpemVQb2ludChmb2N1cywgdmFsdWUpKSwgbmV3QW5jaG9yICYmIG5ld0ZvY3VzID8ge1xuICAgIGFuY2hvcjogbmV3QW5jaG9yLFxuICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICBiYWNrd2FyZDogc2VsZWN0aW9uLmJhY2t3YXJkXG4gIH0gOiBudWxsO1xufVxuY29uc3QgVk9JRF9DSElMRF9LRVkgPSBcInZvaWQtY2hpbGRcIjtcbmZ1bmN0aW9uIGtlZXBPYmplY3RFcXVhbGl0eShvYmplY3QsIGtleU1hcCkge1xuICBjb25zdCB2YWx1ZSA9IGtleU1hcFtvYmplY3QuX2tleV07XG4gIHJldHVybiB2YWx1ZSAmJiBpc0VxdWFsKG9iamVjdCwgdmFsdWUpID8gdmFsdWUgOiAoa2V5TWFwW29iamVjdC5fa2V5XSA9IG9iamVjdCwgb2JqZWN0KTtcbn1cbmZ1bmN0aW9uIHRvU2xhdGVWYWx1ZSh2YWx1ZSwge1xuICBzY2hlbWFUeXBlc1xufSwga2V5TWFwID0ge30pIHtcbiAgcmV0dXJuIHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKChibG9jaykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIF90eXBlLFxuICAgICAgX2tleSxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gYmxvY2ssIHZvaWRDaGlsZHJlbiA9IFt7XG4gICAgICBfa2V5OiBWT0lEX0NISUxEX0tFWSxcbiAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgIHRleHQ6IFwiXCIsXG4gICAgICBtYXJrczogW11cbiAgICB9XTtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUpIHtcbiAgICAgIGNvbnN0IHRleHRCbG9jayA9IGJsb2NrO1xuICAgICAgbGV0IGhhc0lubGluZXMgPSAhMTtcbiAgICAgIGNvbnN0IGhhc01pc3NpbmdTdHlsZSA9IHR5cGVvZiB0ZXh0QmxvY2suc3R5bGUgPiBcInVcIiwgaGFzTWlzc2luZ01hcmtEZWZzID0gdHlwZW9mIHRleHRCbG9jay5tYXJrRGVmcyA+IFwidVwiLCBoYXNNaXNzaW5nQ2hpbGRyZW4gPSB0eXBlb2YgdGV4dEJsb2NrLmNoaWxkcmVuID4gXCJ1XCIsIGNoaWxkcmVuID0gKHRleHRCbG9jay5jaGlsZHJlbiB8fCBbXSkubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgX3R5cGU6IGNUeXBlLFxuICAgICAgICAgIF9rZXk6IGNLZXksXG4gICAgICAgICAgLi4uY1Jlc3RcbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICByZXR1cm4gY1R5cGUgIT09IFwic3BhblwiID8gKGhhc0lubGluZXMgPSAhMCwga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgICBfdHlwZTogY1R5cGUsXG4gICAgICAgICAgX2tleTogY0tleSxcbiAgICAgICAgICBjaGlsZHJlbjogdm9pZENoaWxkcmVuLFxuICAgICAgICAgIHZhbHVlOiBjUmVzdCxcbiAgICAgICAgICBfX2lubGluZTogITBcbiAgICAgICAgfSwga2V5TWFwKSkgOiBjaGlsZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICFoYXNNaXNzaW5nU3R5bGUgJiYgIWhhc01pc3NpbmdNYXJrRGVmcyAmJiAhaGFzTWlzc2luZ0NoaWxkcmVuICYmICFoYXNJbmxpbmVzICYmIEVsZW1lbnQkMS5pc0VsZW1lbnQoYmxvY2spID8gYmxvY2sgOiAoaGFzTWlzc2luZ1N0eWxlICYmIChyZXN0LnN0eWxlID0gc2NoZW1hVHlwZXMuc3R5bGVzWzBdLnZhbHVlKSwga2VlcE9iamVjdEVxdWFsaXR5KHtcbiAgICAgICAgX3R5cGUsXG4gICAgICAgIF9rZXksXG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9LCBrZXlNYXApKTtcbiAgICB9XG4gICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICBfdHlwZSxcbiAgICAgIF9rZXksXG4gICAgICBjaGlsZHJlbjogdm9pZENoaWxkcmVuLFxuICAgICAgdmFsdWU6IHJlc3RcbiAgICB9LCBrZXlNYXApO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gZnJvbVNsYXRlVmFsdWUodmFsdWUsIHRleHRCbG9ja1R5cGUsIGtleU1hcCA9IHt9KSB7XG4gIHJldHVybiB2YWx1ZS5tYXAoKGJsb2NrKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgX2tleSxcbiAgICAgIF90eXBlXG4gICAgfSA9IGJsb2NrO1xuICAgIGlmICghX2tleSB8fCAhX3R5cGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCBibG9ja1wiKTtcbiAgICBpZiAoX3R5cGUgPT09IHRleHRCbG9ja1R5cGUgJiYgXCJjaGlsZHJlblwiIGluIGJsb2NrICYmIEFycmF5LmlzQXJyYXkoYmxvY2suY2hpbGRyZW4pICYmIF9rZXkpIHtcbiAgICAgIGxldCBoYXNJbmxpbmVzID0gITE7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIF90eXBlOiBfY1R5cGVcbiAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICBpZiAoXCJ2YWx1ZVwiIGluIGNoaWxkICYmIF9jVHlwZSAhPT0gXCJzcGFuXCIpIHtcbiAgICAgICAgICBoYXNJbmxpbmVzID0gITA7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgICAgICBfa2V5OiBrLFxuICAgICAgICAgICAgX3R5cGU6IHQsXG4gICAgICAgICAgICBfX2lubGluZTogX2ksXG4gICAgICAgICAgICBjaGlsZHJlbjogX2MsXG4gICAgICAgICAgICAuLi5yZXN0XG4gICAgICAgICAgfSA9IGNoaWxkO1xuICAgICAgICAgIHJldHVybiBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIC4uLnYsXG4gICAgICAgICAgICBfa2V5OiBrLFxuICAgICAgICAgICAgX3R5cGU6IHRcbiAgICAgICAgICB9LCBrZXlNYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhhc0lubGluZXMgPyBrZWVwT2JqZWN0RXF1YWxpdHkoe1xuICAgICAgICAuLi5ibG9jayxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIF9rZXksXG4gICAgICAgIF90eXBlXG4gICAgICB9LCBrZXlNYXApIDogYmxvY2s7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrVmFsdWUgPSBcInZhbHVlXCIgaW4gYmxvY2sgJiYgYmxvY2sudmFsdWU7XG4gICAgcmV0dXJuIGtlZXBPYmplY3RFcXVhbGl0eSh7XG4gICAgICBfa2V5LFxuICAgICAgX3R5cGUsXG4gICAgICAuLi50eXBlb2YgYmxvY2tWYWx1ZSA9PSBcIm9iamVjdFwiID8gYmxvY2tWYWx1ZSA6IHt9XG4gICAgfSwga2V5TWFwKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0VxdWFsVG9FbXB0eUVkaXRvcihjaGlsZHJlbiwgc2NoZW1hVHlwZXMpIHtcbiAgcmV0dXJuIGNoaWxkcmVuID09PSB2b2lkIDAgfHwgY2hpbGRyZW4gJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBFbGVtZW50JDEuaXNFbGVtZW50KGNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSAmJiBcInN0eWxlXCIgaW4gY2hpbGRyZW5bMF0gJiYgY2hpbGRyZW5bMF0uc3R5bGUgPT09IHNjaGVtYVR5cGVzLnN0eWxlc1swXS52YWx1ZSAmJiAhKFwibGlzdEl0ZW1cIiBpbiBjaGlsZHJlblswXSkgJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlblswXS5jaGlsZHJlbikgJiYgY2hpbGRyZW5bMF0uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIFRleHQuaXNUZXh0KGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5jaGlsZHJlblswXS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgIWNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLm1hcmtzPy5qb2luKFwiXCIpICYmIGNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCI7XG59XG5jb25zdCBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX0RSQUdHSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEtFWV9UT19TTEFURV9FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIEtFWV9UT19WQUxVRV9FTEVNRU5UID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgRGVmYXVsdE9iamVjdCA9IChwcm9wcykgPT4ge1xuICBjb25zdCAkID0gYyg0KTtcbiAgbGV0IHQwO1xuICAkWzBdICE9PSBwcm9wcy52YWx1ZSA/ICh0MCA9IEpTT04uc3RyaW5naWZ5KHByb3BzLnZhbHVlLCBudWxsLCAyKSwgJFswXSA9IHByb3BzLnZhbHVlLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBsZXQgdDE7XG4gIHJldHVybiAkWzJdICE9PSB0MCA/ICh0MSA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcInByZVwiLCB7IGNoaWxkcmVuOiB0MCB9KSB9KSwgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogdDEgPSAkWzNdLCB0MTtcbn07XG5EZWZhdWx0T2JqZWN0LmRpc3BsYXlOYW1lID0gXCJEZWZhdWx0T2JqZWN0XCI7XG5jb25zdCBEZWZhdWx0QmxvY2tPYmplY3QgPSBzdHlsZWQuZGl2YFxuICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgYm9yZGVyOiAkeyhwcm9wcykgPT4gcHJvcHMuc2VsZWN0ZWQgPyBcIjFweCBzb2xpZCBibHVlXCIgOiBcIjFweCBzb2xpZCB0cmFuc3BhcmVudFwifTtcbmA7XG5zdHlsZWQuc3BhbmBcbiAgYmFja2dyb3VuZDogIzk5OTtcbiAgYm9yZGVyOiAkeyhwcm9wcykgPT4gcHJvcHMuc2VsZWN0ZWQgPyBcIjFweCBzb2xpZCBibHVlXCIgOiBcIjFweCBzb2xpZCB0cmFuc3BhcmVudFwifTtcbmA7XG5jb25zdCBEZWZhdWx0TGlzdEl0ZW0gPSBzdHlsZWQuZGl2YFxuICAmLnB0LWxpc3QtaXRlbSB7XG4gICAgd2lkdGg6IGZpdC1jb250ZW50O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBkaXNwbGF5OiBibG9jaztcblxuICAgIC8qIEltcG9ydGFudCAndHJhbnNmb3JtJyBpbiBvcmRlciB0byBmb3JjZSByZWZyZXNoIHRoZSA6OmJlZm9yZSBhbmQgOjphZnRlciBydWxlc1xuICAgICAgaW4gV2Via2l0OiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjE5NDc2MjgvODMxNDgwXG4gICAgKi9cbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gICAgbWFyZ2luLWxlZnQ6ICR7KHByb3BzKSA9PiBnZXRMZWZ0UG9zaXRpb25Gb3JMaXN0TGV2ZWwocHJvcHMubGlzdExldmVsKX07XG4gIH1cbiAgJi5wdC1saXN0LWl0ZW0gPiAucHQtbGlzdC1pdGVtLWlubmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICAgICY6YmVmb3JlIHtcbiAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgfVxuICB9XG4gICYucHQtbGlzdC1pdGVtLWJ1bGxldCA+IC5wdC1saXN0LWl0ZW0taW5uZXI6YmVmb3JlIHtcbiAgICAgIGNvbnRlbnQ6ICckeyhwcm9wcykgPT4gZ2V0Q29udGVudEZvckxpc3RMZXZlbEFuZFN0eWxlKHByb3BzLmxpc3RMZXZlbCwgcHJvcHMubGlzdFN0eWxlKX0nO1xuICAgICAgZm9udC1zaXplOiAwLjQzNzVyZW07IC8qIDdweCAqL1xuICAgICAgbGluZS1oZWlnaHQ6IDEuNXJlbTsgLyogU2FtZSBhcyBib2R5IHRleHQgKi9cbiAgICAgIC8qIE9wdGljYWwgYWxpZ25tZW50ICovXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuICB9XG4gICYucHQtbGlzdC1pdGVtLWJ1bGxldCA+IC5wdC1saXN0LWl0ZW0taW5uZXIge1xuICAgICY6YmVmb3JlIHtcbiAgICAgIG1pbi13aWR0aDogMS41cmVtOyAvKiBNYWtlIHN1cmUgc3BhY2UgYmV0d2VlbiBidWxsZXQgYW5kIHRleHQgbmV2ZXIgc2hyaW5rcyAqL1xuICAgIH1cbiAgfVxuICAmLnB0LWxpc3QtaXRlbS1udW1iZXIge1xuICAgIGNvdW50ZXItaW5jcmVtZW50OiAkeyhwcm9wcykgPT4gZ2V0Q291bnRlckluY3JlbWVudEZvckxpc3RMZXZlbChwcm9wcy5saXN0TGV2ZWwpfTtcbiAgICBjb3VudGVyLXJlc2V0OiAkeyhwcm9wcykgPT4gZ2V0Q291bnRlclJlc2V0Rm9yTGlzdExldmVsKHByb3BzLmxpc3RMZXZlbCl9O1xuICB9XG4gICYgKyA6bm90KC5wdC1saXN0LWl0ZW0tbnVtYmVyKSB7XG4gICAgY291bnRlci1yZXNldDogbGlzdEl0ZW1OdW1iZXI7XG4gIH1cbiAgJi5wdC1saXN0LWl0ZW0tbnVtYmVyID4gLnB0LWxpc3QtaXRlbS1pbm5lcjpiZWZvcmUge1xuICAgIGNvbnRlbnQ6ICR7KHByb3BzKSA9PiBnZXRDb3VudGVyQ29udGVudEZvckxpc3RMZXZlbChwcm9wcy5saXN0TGV2ZWwpfTtcbiAgICBtaW4td2lkdGg6IDEuNXJlbTsgLyogTWFrZSBzdXJlIHNwYWNlIGJldHdlZW4gbnVtYmVyIGFuZCB0ZXh0IG5ldmVyIHNocmlua3MgKi9cbiAgICAvKiBPcHRpY2FsIGFsaWdubWVudCAqL1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB0b3A6IDFweDtcbiAgfVxuYCwgRGVmYXVsdExpc3RJdGVtSW5uZXIgPSBzdHlsZWQuZGl2YGA7XG5mdW5jdGlvbiBnZXRMZWZ0UG9zaXRpb25Gb3JMaXN0TGV2ZWwobGV2ZWwpIHtcbiAgc3dpdGNoIChOdW1iZXIobGV2ZWwpKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFwiMS41ZW1cIjtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gXCIzZW1cIjtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gXCI0LjVlbVwiO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBcIjZlbVwiO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBcIjcuNWVtXCI7XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIFwiOWVtXCI7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIFwiMTAuNWVtXCI7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIFwiMTJlbVwiO1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBcIjEzLjVlbVwiO1xuICAgIGNhc2UgMTA6XG4gICAgICByZXR1cm4gXCIxNWVtXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIjBlbVwiO1xuICB9XG59XG5jb25zdCBidWxsZXRzID0gW1wiXFx1MjVDRlwiLCBcIlxcdTI1Q0JcIiwgXCJcXHUyNUEwXCJdO1xuZnVuY3Rpb24gZ2V0Q29udGVudEZvckxpc3RMZXZlbEFuZFN0eWxlKGxldmVsLCBzdHlsZSkge1xuICBjb25zdCBub3JtYWxpemVkTGV2ZWwgPSAobGV2ZWwgLSAxKSAlIDM7XG4gIHJldHVybiBzdHlsZSA9PT0gXCJidWxsZXRcIiA/IGJ1bGxldHNbbm9ybWFsaXplZExldmVsXSA6IFwiKlwiO1xufVxuZnVuY3Rpb24gZ2V0Q291bnRlckluY3JlbWVudEZvckxpc3RMZXZlbChsZXZlbCkge1xuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1OdW1iZXJcIjtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbUFscGhhXCI7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1Sb21hblwiO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTnVtYmVyTmV4dFwiO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtTGV0dGVyTmV4dFwiO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtUm9tYW5OZXh0XCI7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1OdW1iZXJOZXh0TmV4dFwiO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtQWxwaGFOZXh0TmV4dFwiO1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtUm9tYW5OZXh0TmV4dFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbU51bWJlck5leHROZXh0TmV4dFwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb3VudGVyUmVzZXRGb3JMaXN0TGV2ZWwobGV2ZWwpIHtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBcImxpc3RJdGVtQWxwaGFcIjtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbVJvbWFuXCI7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1OdW1iZXJOZXh0XCI7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1MZXR0ZXJOZXh0XCI7XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1Sb21hbk5leHRcIjtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gXCJsaXN0SXRlbU51bWJlck5leHROZXh0XCI7XG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1BbHBoYU5leHROZXh0XCI7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1Sb21hbk5leHROZXh0XCI7XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1OdW1iZXJOZXh0TmV4dE5leHRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwibGlzdEl0ZW1OdW1iZXJOZXh0TmV4dE5leHRcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q291bnRlckNvbnRlbnRGb3JMaXN0TGV2ZWwobGV2ZWwpIHtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1OdW1iZXIpICcuICdcIjtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtQWxwaGEsIGxvd2VyLWFscGhhKSAnLiAnXCI7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbVJvbWFuLCBsb3dlci1yb21hbikgJy4gJ1wiO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBcImNvdW50ZXIobGlzdEl0ZW1OdW1iZXJOZXh0KSAnLiAnXCI7XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbUxldHRlck5leHQsIGxvd2VyLWFscGhhKSAnLiAnXCI7XG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbVJvbWFuTmV4dCwgbG93ZXItcm9tYW4pICcuICdcIjtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtTnVtYmVyTmV4dE5leHQpICcuICdcIjtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtQWxwaGFOZXh0TmV4dCwgbG93ZXItYWxwaGEpICcuICdcIjtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gXCJjb3VudGVyKGxpc3RJdGVtUm9tYW5OZXh0TmV4dCwgbG93ZXItcm9tYW4pICcuICdcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiY291bnRlcihsaXN0SXRlbU51bWJlck5leHROZXh0TmV4dCkgJy4gJ1wiO1xuICB9XG59XG5jb25zdCBkZWJ1ZyRrID0gZGVidWdXaXRoTmFtZShcImNvbXBvbmVudHM6RHJhZ2dhYmxlQmxvY2tcIiksIERyYWdnYWJsZUJsb2NrID0gKHQwKSA9PiB7XG4gIGNvbnN0ICQgPSBjKDUxKSwge1xuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnQsXG4gICAgcmVhZE9ubHksXG4gICAgYmxvY2tSZWZcbiAgfSA9IHQwLCBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpLCBkcmFnR2hvc3RSZWYgPSB1c2VSZWYodm9pZCAwKSwgW2lzRHJhZ092ZXIsIHNldElzRHJhZ092ZXJdID0gdXNlU3RhdGUoITEpO1xuICBsZXQgdDEsIHQyO1xuICAkWzBdICE9PSBlZGl0b3IgfHwgJFsxXSAhPT0gZWxlbWVudCA/ICh0MiA9IEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBlbGVtZW50KSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IGVsZW1lbnQsICRbMl0gPSB0MikgOiB0MiA9ICRbMl0sIHQxID0gdDI7XG4gIGNvbnN0IGlzVm9pZCA9IHQxO1xuICBsZXQgdDMsIHQ0O1xuICAkWzNdICE9PSBlZGl0b3IgfHwgJFs0XSAhPT0gZWxlbWVudCA/ICh0NCA9IEVkaXRvci5pc0lubGluZShlZGl0b3IsIGVsZW1lbnQpLCAkWzNdID0gZWRpdG9yLCAkWzRdID0gZWxlbWVudCwgJFs1XSA9IHQ0KSA6IHQ0ID0gJFs1XSwgdDMgPSB0NDtcbiAgY29uc3QgaXNJbmxpbmUgPSB0MywgW2Jsb2NrRWxlbWVudCwgc2V0QmxvY2tFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICBsZXQgdDUsIHQ2O1xuICAkWzZdICE9PSBibG9ja1JlZiB8fCAkWzddICE9PSBlZGl0b3IgfHwgJFs4XSAhPT0gZWxlbWVudCA/ICh0NSA9ICgpID0+IHNldEJsb2NrRWxlbWVudChibG9ja1JlZiA/IGJsb2NrUmVmLmN1cnJlbnQgOiBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlbGVtZW50KSksIHQ2ID0gW2VkaXRvciwgZWxlbWVudCwgYmxvY2tSZWZdLCAkWzZdID0gYmxvY2tSZWYsICRbN10gPSBlZGl0b3IsICRbOF0gPSBlbGVtZW50LCAkWzldID0gdDUsICRbMTBdID0gdDYpIDogKHQ1ID0gJFs5XSwgdDYgPSAkWzEwXSksIHVzZUVmZmVjdCh0NSwgdDYpO1xuICBsZXQgdDc7XG4gICRbMTFdICE9PSBibG9ja0VsZW1lbnQgfHwgJFsxMl0gIT09IGVkaXRvciB8fCAkWzEzXSAhPT0gZWxlbWVudCA/ICh0NyA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IGlzTXlEcmFnT3ZlciA9IElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgaWYgKCFpc015RHJhZ092ZXIgfHwgIWJsb2NrRWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpLCBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwibW92ZVwiLCBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVC5zZXQoZWRpdG9yLCBlbGVtZW50KTtcbiAgICBjb25zdCBlbGVtZW50UmVjdCA9IGJsb2NrRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgb2Zmc2V0ID0gZWxlbWVudFJlY3QudG9wLCBoZWlnaHQgPSBlbGVtZW50UmVjdC5oZWlnaHQsIFkgPSBldmVudC5wYWdlWSwgbG9jID0gTWF0aC5hYnMob2Zmc2V0IC0gWSk7XG4gICAgaWYgKGVsZW1lbnQgPT09IGVkaXRvci5jaGlsZHJlblswXSB8fCAobG9jIDwgaGVpZ2h0IC8gMiA/IElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5zZXQoZWRpdG9yLCBcInRvcFwiKSA6IElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5zZXQoZWRpdG9yLCBcImJvdHRvbVwiKSksIGlzTXlEcmFnT3ZlciA9PT0gZWxlbWVudCkge1xuICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcIm5vbmVcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0SXNEcmFnT3ZlcighMCk7XG4gIH0sICRbMTFdID0gYmxvY2tFbGVtZW50LCAkWzEyXSA9IGVkaXRvciwgJFsxM10gPSBlbGVtZW50LCAkWzE0XSA9IHQ3KSA6IHQ3ID0gJFsxNF07XG4gIGNvbnN0IGhhbmRsZURyYWdPdmVyID0gdDc7XG4gIGxldCB0ODtcbiAgJFsxNV0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQ4ID0gKCkgPT4ge1xuICAgIHNldElzRHJhZ092ZXIoITEpO1xuICB9LCAkWzE1XSA9IHQ4KSA6IHQ4ID0gJFsxNV07XG4gIGNvbnN0IGhhbmRsZURyYWdMZWF2ZSA9IHQ4O1xuICBsZXQgdDk7XG4gICRbMTZdICE9PSBlZGl0b3IgfHwgJFsxN10gIT09IGVsZW1lbnQgPyAodDkgPSAoZXZlbnRfMCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldEJsb2NrID0gSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZ2V0KGVkaXRvcik7XG4gICAgaWYgKHRhcmdldEJsb2NrKSB7XG4gICAgICBJU19EUkFHR0lORy5zZXQoZWRpdG9yLCAhMSksIGV2ZW50XzAucHJldmVudERlZmF1bHQoKSwgZXZlbnRfMC5zdG9wUHJvcGFnYXRpb24oKSwgSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZGVsZXRlKGVkaXRvciksIGRyYWdHaG9zdFJlZi5jdXJyZW50ICYmIChkZWJ1ZyRrKFwiUmVtb3ZpbmcgZHJhZyBnaG9zdFwiKSwgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkcmFnR2hvc3RSZWYuY3VycmVudCkpO1xuICAgICAgY29uc3QgZHJhZ1Bvc2l0aW9uID0gSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLmdldChlZGl0b3IpO1xuICAgICAgSVNfRFJBR0dJTkdfQkxPQ0tfVEFSR0VUX1BPU0lUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgbGV0IHRhcmdldFBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIHRhcmdldEJsb2NrKTtcbiAgICAgIGNvbnN0IG15UGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgZWxlbWVudCksIGlzQmVmb3JlID0gUGF0aC5pc0JlZm9yZShteVBhdGgsIHRhcmdldFBhdGgpO1xuICAgICAgaWYgKGRyYWdQb3NpdGlvbiA9PT0gXCJib3R0b21cIiAmJiAhaXNCZWZvcmUpIHtcbiAgICAgICAgaWYgKHRhcmdldFBhdGhbMF0gPj0gZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkZWJ1ZyRrKFwidGFyZ2V0IGlzIGFscmVhZHkgYXQgdGhlIGJvdHRvbSwgbm90IG1vdmluZ1wiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRoID0gdGFyZ2V0UGF0aDtcbiAgICAgICAgdGFyZ2V0UGF0aCA9IFBhdGgubmV4dCh0YXJnZXRQYXRoKSwgZGVidWckayhgQWRqdXN0aW5nIHRhcmdldFBhdGggZnJvbSAke0pTT04uc3RyaW5naWZ5KG9yaWdpbmFsUGF0aCl9IHRvICR7SlNPTi5zdHJpbmdpZnkodGFyZ2V0UGF0aCl9YCk7XG4gICAgICB9XG4gICAgICBpZiAoZHJhZ1Bvc2l0aW9uID09PSBcInRvcFwiICYmIGlzQmVmb3JlICYmIHRhcmdldFBhdGhbMF0gIT09IGVkaXRvci5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUGF0aF8wID0gdGFyZ2V0UGF0aDtcbiAgICAgICAgdGFyZ2V0UGF0aCA9IFBhdGgucHJldmlvdXModGFyZ2V0UGF0aCksIGRlYnVnJGsoYEFkanVzdGluZyB0YXJnZXRQYXRoIGZyb20gJHtKU09OLnN0cmluZ2lmeShvcmlnaW5hbFBhdGhfMCl9IHRvICR7SlNPTi5zdHJpbmdpZnkodGFyZ2V0UGF0aCl9YCk7XG4gICAgICB9XG4gICAgICBpZiAoUGF0aC5lcXVhbHModGFyZ2V0UGF0aCwgbXlQYXRoKSkge1xuICAgICAgICBldmVudF8wLnByZXZlbnREZWZhdWx0KCksIGRlYnVnJGsoXCJ0YXJnZXRQYXRoIGFuZCBteVBhdGggaXMgdGhlIHNhbWUsIG5vdCBtb3ZpbmdcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRlYnVnJGsoYE1vdmluZyBlbGVtZW50ICR7ZWxlbWVudC5fa2V5fSBmcm9tIHBhdGggJHtKU09OLnN0cmluZ2lmeShteVBhdGgpfSB0byAke0pTT04uc3RyaW5naWZ5KHRhcmdldFBhdGgpfSAoJHtkcmFnUG9zaXRpb259KWApLCBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IG15UGF0aCxcbiAgICAgICAgdG86IHRhcmdldFBhdGhcbiAgICAgIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVidWckayhcIk5vIHRhcmdldCBlbGVtZW50LCBub3QgZG9pbmcgYW55dGhpbmdcIik7XG4gIH0sICRbMTZdID0gZWRpdG9yLCAkWzE3XSA9IGVsZW1lbnQsICRbMThdID0gdDkpIDogdDkgPSAkWzE4XTtcbiAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IHQ5O1xuICBsZXQgdDEwO1xuICAkWzE5XSAhPT0gZWRpdG9yIHx8ICRbMjBdICE9PSBlbGVtZW50ID8gKHQxMCA9IChldmVudF8xKSA9PiB7XG4gICAgSVNfRFJBR0dJTkdfQkxPQ0tfRUxFTUVOVC5nZXQoZWRpdG9yKSAmJiAoZGVidWckayhcIk9uIGRyb3AgKHByZXZlbnRlZClcIiwgZWxlbWVudCksIGV2ZW50XzEucHJldmVudERlZmF1bHQoKSwgZXZlbnRfMS5zdG9wUHJvcGFnYXRpb24oKSwgc2V0SXNEcmFnT3ZlcighMSkpO1xuICB9LCAkWzE5XSA9IGVkaXRvciwgJFsyMF0gPSBlbGVtZW50LCAkWzIxXSA9IHQxMCkgOiB0MTAgPSAkWzIxXTtcbiAgY29uc3QgaGFuZGxlRHJvcCA9IHQxMDtcbiAgbGV0IHQxMTtcbiAgJFsyMl0gIT09IGVkaXRvciB8fCAkWzIzXSAhPT0gZWxlbWVudCB8fCAkWzI0XSAhPT0gaXNWb2lkID8gKHQxMSA9IChldmVudF8yKSA9PiB7XG4gICAgaWYgKCFpc1ZvaWQpIHtcbiAgICAgIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIElTX0RSQUdHSU5HLnNldChlZGl0b3IsICEwKSwgSVNfRFJBR0dJTkdfQkxPQ0tfRUxFTUVOVC5zZXQoZWRpdG9yLCBlbGVtZW50KSwgZXZlbnRfMi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudF8yLnRhcmdldDtcbiAgICB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAodGFyZ2V0LnN0eWxlLm9wYWNpdHkgPSBcIjFcIik7XG4gIH0sICRbMjJdID0gZWRpdG9yLCAkWzIzXSA9IGVsZW1lbnQsICRbMjRdID0gaXNWb2lkLCAkWzI1XSA9IHQxMSkgOiB0MTEgPSAkWzI1XTtcbiAgY29uc3QgaGFuZGxlRHJhZyA9IHQxMTtcbiAgbGV0IHQxMjtcbiAgJFsyNl0gIT09IGJsb2NrRWxlbWVudCB8fCAkWzI3XSAhPT0gZWRpdG9yIHx8ICRbMjhdICE9PSBoYW5kbGVEcmFnIHx8ICRbMjldICE9PSBpc0lubGluZSB8fCAkWzMwXSAhPT0gaXNWb2lkID8gKHQxMiA9IChldmVudF8zKSA9PiB7XG4gICAgaWYgKCFpc1ZvaWQgfHwgaXNJbmxpbmUpIHtcbiAgICAgIGRlYnVnJGsoXCJOb3QgZHJhZ2dpbmcgYmxvY2tcIiksIElTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQuZGVsZXRlKGVkaXRvciksIElTX0RSQUdHSU5HLnNldChlZGl0b3IsICExKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlYnVnJGsoXCJEcmFnIHN0YXJ0XCIpLCBJU19EUkFHR0lORy5zZXQoZWRpdG9yLCAhMCksIGV2ZW50XzMuZGF0YVRyYW5zZmVyICYmIChldmVudF8zLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiYXBwbGljYXRpb24vcG9ydGFibGUtdGV4dFwiLCBcInNvbWV0aGluZ1wiKSwgZXZlbnRfMy5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwibW92ZVwiKSwgYmxvY2tFbGVtZW50ICYmIGJsb2NrRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBsZXQgZHJhZ0dob3N0ID0gYmxvY2tFbGVtZW50LmNsb25lTm9kZSghMCk7XG4gICAgICBjb25zdCBjdXN0b21HaG9zdCA9IGRyYWdHaG9zdC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtcHQtZHJhZy1naG9zdC1lbGVtZW50XVwiKTtcbiAgICAgIGlmIChjdXN0b21HaG9zdCAmJiAoZHJhZ0dob3N0ID0gY3VzdG9tR2hvc3QpLCBkcmFnR2hvc3Quc2V0QXR0cmlidXRlKFwiZGF0YS1kcmFnZ2VkXCIsIFwiXCIpLCBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGRyYWdHaG9zdFJlZi5jdXJyZW50ID0gZHJhZ0dob3N0LCBkcmFnR2hvc3Quc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGRyYWdHaG9zdC5zdHlsZS5sZWZ0ID0gXCItOTk5OTlweFwiLCBkcmFnR2hvc3Quc3R5bGUuYm94U2l6aW5nID0gXCJib3JkZXItYm94XCIsIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ0dob3N0KTtcbiAgICAgICAgY29uc3QgcmVjdCA9IGJsb2NrRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgeCA9IGV2ZW50XzMuY2xpZW50WCAtIHJlY3QubGVmdCwgeSA9IGV2ZW50XzMuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgICBkcmFnR2hvc3Quc3R5bGUud2lkdGggPSBgJHtyZWN0LndpZHRofXB4YCwgZHJhZ0dob3N0LnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0fXB4YCwgZXZlbnRfMy5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGRyYWdHaG9zdCwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURyYWcoZXZlbnRfMyk7XG4gIH0sICRbMjZdID0gYmxvY2tFbGVtZW50LCAkWzI3XSA9IGVkaXRvciwgJFsyOF0gPSBoYW5kbGVEcmFnLCAkWzI5XSA9IGlzSW5saW5lLCAkWzMwXSA9IGlzVm9pZCwgJFszMV0gPSB0MTIpIDogdDEyID0gJFszMV07XG4gIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9IHQxMjtcbiAgbGV0IHQxMztcbiAgJFszMl0gIT09IGVkaXRvciB8fCAkWzMzXSAhPT0gaXNEcmFnT3ZlciA/ICh0MTMgPSBpc0RyYWdPdmVyICYmIGVkaXRvci5jaGlsZHJlblswXSA9PT0gSVNfRFJBR0dJTkdfRUxFTUVOVF9UQVJHRVQuZ2V0KGVkaXRvciksICRbMzJdID0gZWRpdG9yLCAkWzMzXSA9IGlzRHJhZ092ZXIsICRbMzRdID0gdDEzKSA6IHQxMyA9ICRbMzRdO1xuICBjb25zdCBpc0RyYWdnaW5nT3ZlckZpcnN0QmxvY2sgPSB0MTM7XG4gIGxldCB0MTQ7XG4gICRbMzVdICE9PSBlZGl0b3IgfHwgJFszNl0gIT09IGlzRHJhZ092ZXIgPyAodDE0ID0gaXNEcmFnT3ZlciAmJiBlZGl0b3IuY2hpbGRyZW5bZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCAtIDFdID09PSBJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVC5nZXQoZWRpdG9yKSwgJFszNV0gPSBlZGl0b3IsICRbMzZdID0gaXNEcmFnT3ZlciwgJFszN10gPSB0MTQpIDogdDE0ID0gJFszN107XG4gIGNvbnN0IGlzRHJhZ2dpbmdPdmVyTGFzdEJsb2NrID0gdDE0LCBkcmFnUG9zaXRpb25fMCA9IElTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTi5nZXQoZWRpdG9yKSwgaXNEcmFnZ2luZ092ZXJUb3AgPSBpc0RyYWdnaW5nT3ZlckZpcnN0QmxvY2sgfHwgaXNEcmFnT3ZlciAmJiAhaXNEcmFnZ2luZ092ZXJGaXJzdEJsb2NrICYmICFpc0RyYWdnaW5nT3Zlckxhc3RCbG9jayAmJiBkcmFnUG9zaXRpb25fMCA9PT0gXCJ0b3BcIiwgaXNEcmFnZ2luZ092ZXJCb3R0b20gPSBpc0RyYWdnaW5nT3Zlckxhc3RCbG9jayB8fCBpc0RyYWdPdmVyICYmICFpc0RyYWdnaW5nT3ZlckZpcnN0QmxvY2sgJiYgIWlzRHJhZ2dpbmdPdmVyTGFzdEJsb2NrICYmIGRyYWdQb3NpdGlvbl8wID09PSBcImJvdHRvbVwiO1xuICBsZXQgdDE1LCB0MTY7XG4gICRbMzhdID09PSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSA/ICh0MTYgPSAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInB0LWRyb3AtaW5kaWNhdG9yXCIsIHN0eWxlOiB7XG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgaGVpZ2h0OiAxLFxuICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgY3VycmVudENvbG9yXCIsXG4gICAgekluZGV4OiA1XG4gIH0gfSksICRbMzhdID0gdDE2KSA6IHQxNiA9ICRbMzhdLCB0MTUgPSB0MTY7XG4gIGNvbnN0IGRyb3BJbmRpY2F0b3IgPSB0MTU7XG4gIGlmIChyZWFkT25seSkge1xuICAgIGxldCB0MTcyO1xuICAgIHJldHVybiAkWzM5XSAhPT0gY2hpbGRyZW4gPyAodDE3MiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW4gfSksICRbMzldID0gY2hpbGRyZW4sICRbNDBdID0gdDE3MikgOiB0MTcyID0gJFs0MF0sIHQxNzI7XG4gIH1cbiAgY29uc3QgdDE3ID0gaXNEcmFnZ2luZ092ZXJUb3AgJiYgZHJvcEluZGljYXRvciwgdDE4ID0gaXNEcmFnZ2luZ092ZXJCb3R0b20gJiYgZHJvcEluZGljYXRvcjtcbiAgbGV0IHQxOTtcbiAgcmV0dXJuICRbNDFdICE9PSBjaGlsZHJlbiB8fCAkWzQyXSAhPT0gaGFuZGxlRHJhZyB8fCAkWzQzXSAhPT0gaGFuZGxlRHJhZ0VuZCB8fCAkWzQ0XSAhPT0gaGFuZGxlRHJhZ092ZXIgfHwgJFs0NV0gIT09IGhhbmRsZURyYWdTdGFydCB8fCAkWzQ2XSAhPT0gaGFuZGxlRHJvcCB8fCAkWzQ3XSAhPT0gaXNWb2lkIHx8ICRbNDhdICE9PSB0MTcgfHwgJFs0OV0gIT09IHQxOCA/ICh0MTkgPSAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IGRyYWdnYWJsZTogaXNWb2lkLCBvbkRyYWdTdGFydDogaGFuZGxlRHJhZ1N0YXJ0LCBvbkRyYWc6IGhhbmRsZURyYWcsIG9uRHJhZ092ZXI6IGhhbmRsZURyYWdPdmVyLCBvbkRyYWdMZWF2ZTogaGFuZGxlRHJhZ0xlYXZlLCBvbkRyYWdFbmQ6IGhhbmRsZURyYWdFbmQsIG9uRHJvcDogaGFuZGxlRHJvcCwgY2hpbGRyZW46IFtcbiAgICB0MTcsXG4gICAgY2hpbGRyZW4sXG4gICAgdDE4XG4gIF0gfSksICRbNDFdID0gY2hpbGRyZW4sICRbNDJdID0gaGFuZGxlRHJhZywgJFs0M10gPSBoYW5kbGVEcmFnRW5kLCAkWzQ0XSA9IGhhbmRsZURyYWdPdmVyLCAkWzQ1XSA9IGhhbmRsZURyYWdTdGFydCwgJFs0Nl0gPSBoYW5kbGVEcm9wLCAkWzQ3XSA9IGlzVm9pZCwgJFs0OF0gPSB0MTcsICRbNDldID0gdDE4LCAkWzUwXSA9IHQxOSkgOiB0MTkgPSAkWzUwXSwgdDE5O1xufTtcbkRyYWdnYWJsZUJsb2NrLmRpc3BsYXlOYW1lID0gXCJEcmFnZ2FibGVCbG9ja1wiO1xuZGVidWdXaXRoTmFtZShcImNvbXBvbmVudHM6RWxlbWVudFwiKTtcbmNvbnN0IEVNUFRZX0FOTk9UQVRJT05TID0gW10sIGlubGluZUJsb2NrU3R5bGUgPSB7XG4gIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJcbn0sIEVsZW1lbnQgPSAoe1xuICBhdHRyaWJ1dGVzLFxuICBjaGlsZHJlbixcbiAgZWxlbWVudCxcbiAgc2NoZW1hVHlwZXMsXG4gIHJlYWRPbmx5LFxuICByZW5kZXJCbG9jayxcbiAgcmVuZGVyQ2hpbGQsXG4gIHJlbmRlckxpc3RJdGVtLFxuICByZW5kZXJTdHlsZSxcbiAgc3BlbGxDaGVja1xufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpLCBzZWxlY3RlZCA9IHVzZVNlbGVjdGVkKCksIGJsb2NrUmVmID0gdXNlUmVmKG51bGwpLCBpbmxpbmVCbG9ja09iamVjdFJlZiA9IHVzZVJlZihudWxsKSwgZm9jdXNlZCA9IHNlbGVjdGVkICYmIGVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikgfHwgITEsIHZhbHVlID0gdXNlTWVtbygoKSA9PiBmcm9tU2xhdGVWYWx1ZShbZWxlbWVudF0sIHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKVswXSwgW2VkaXRvciwgZWxlbWVudCwgc2NoZW1hVHlwZXMuYmxvY2submFtZV0pO1xuICBsZXQgcmVuZGVyZWRCbG9jayA9IGNoaWxkcmVuLCBjbGFzc05hbWU7XG4gIGNvbnN0IGJsb2NrUGF0aCA9IHVzZU1lbW8oKCkgPT4gW3tcbiAgICBfa2V5OiBlbGVtZW50Ll9rZXlcbiAgfV0sIFtlbGVtZW50XSk7XG4gIGlmICh0eXBlb2YgZWxlbWVudC5fdHlwZSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGVsZW1lbnQgdG8gaGF2ZSBhIF90eXBlIHByb3BlcnR5XCIpO1xuICBpZiAodHlwZW9mIGVsZW1lbnQuX2tleSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGVsZW1lbnQgdG8gaGF2ZSBhIF9rZXkgcHJvcGVydHlcIik7XG4gIGlmIChlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkpIHtcbiAgICBjb25zdCBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBlbGVtZW50KSwgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCwge1xuICAgICAgZGVwdGg6IDFcbiAgICB9KSwgc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGVzLmlubGluZU9iamVjdHMuZmluZCgoX3R5cGUpID0+IF90eXBlLm5hbWUgPT09IGVsZW1lbnQuX3R5cGUpO1xuICAgIGlmICghc2NoZW1hVHlwZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHR5cGUgZm9yIGlubGluZSBibG9jayBlbGVtZW50XCIpO1xuICAgIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSkge1xuICAgICAgY29uc3QgZWxtUGF0aCA9IFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBlbGVtZW50Ll9rZXlcbiAgICAgIH1dO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwic3BhblwiLCB7IC4uLmF0dHJpYnV0ZXMsIGNoaWxkcmVuOiBbXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBkcmFnZ2FibGU6ICFyZWFkT25seSwgY2xhc3NOYW1lOiBcInB0LWlubGluZS1vYmplY3RcIiwgXCJkYXRhLXRlc3RpZFwiOiBcInB0LWlubGluZS1vYmplY3RcIiwgcmVmOiBpbmxpbmVCbG9ja09iamVjdFJlZiwgc3R5bGU6IGlubGluZUJsb2NrU3R5bGUsIGNvbnRlbnRFZGl0YWJsZTogITEsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgcmVuZGVyQ2hpbGQgJiYgcmVuZGVyQ2hpbGQoe1xuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IEVNUFRZX0FOTk9UQVRJT05TLFxuICAgICAgICAgICAgLy8gVGhlc2UgaW5saW5lIG9iamVjdHMgY3VycmVudGx5IGRvZXNuJ3Qgc3VwcG9ydCBhbm5vdGF0aW9ucy4gVGhpcyBpcyBhIGxpbWl0YXRpb24gb2YgdGhlIGN1cnJlbnQgUFQgc3BlYy9tb2RlbC5cbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRPYmplY3QsIHsgdmFsdWUgfSksXG4gICAgICAgICAgICBlZGl0b3JFbGVtZW50UmVmOiBpbmxpbmVCbG9ja09iamVjdFJlZixcbiAgICAgICAgICAgIGZvY3VzZWQsXG4gICAgICAgICAgICBwYXRoOiBlbG1QYXRoLFxuICAgICAgICAgICAgc2NoZW1hVHlwZSxcbiAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgdHlwZTogc2NoZW1hVHlwZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSksXG4gICAgICAgICAgIXJlbmRlckNoaWxkICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdE9iamVjdCwgeyB2YWx1ZSB9KVxuICAgICAgICBdIH0sIGVsZW1lbnQuX2tleSlcbiAgICAgIF0gfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkJsb2NrIG5vdCBmb3VuZCFcIik7XG4gIH1cbiAgaWYgKGVsZW1lbnQuX3R5cGUgPT09IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUpIHtcbiAgICBjbGFzc05hbWUgPSBcInB0LWJsb2NrIHB0LXRleHQtYmxvY2tcIjtcbiAgICBjb25zdCBpc0xpc3RJdGVtID0gXCJsaXN0SXRlbVwiIGluIGVsZW1lbnQsIHN0eWxlID0gXCJzdHlsZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC5zdHlsZSB8fCBcIm5vcm1hbFwiO1xuICAgIGNsYXNzTmFtZSA9IGBwdC1ibG9jayBwdC10ZXh0LWJsb2NrIHB0LXRleHQtYmxvY2stc3R5bGUtJHtzdHlsZX1gO1xuICAgIGNvbnN0IGJsb2NrU3R5bGVUeXBlID0gc2NoZW1hVHlwZXMuc3R5bGVzLmZpbmQoKGl0ZW0pID0+IGl0ZW0udmFsdWUgPT09IHN0eWxlKTtcbiAgICByZW5kZXJTdHlsZSAmJiBibG9ja1N0eWxlVHlwZSAmJiAocmVuZGVyZWRCbG9jayA9IHJlbmRlclN0eWxlKHtcbiAgICAgIGJsb2NrOiBlbGVtZW50LFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBmb2N1c2VkLFxuICAgICAgc2VsZWN0ZWQsXG4gICAgICB2YWx1ZTogc3R5bGUsXG4gICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICBzY2hlbWFUeXBlOiBibG9ja1N0eWxlVHlwZSxcbiAgICAgIGVkaXRvckVsZW1lbnRSZWY6IGJsb2NrUmVmXG4gICAgfSkpO1xuICAgIGxldCBsZXZlbDtcbiAgICBpZiAoaXNMaXN0SXRlbSAmJiAodHlwZW9mIGVsZW1lbnQubGV2ZWwgPT0gXCJudW1iZXJcIiAmJiAobGV2ZWwgPSBlbGVtZW50LmxldmVsKSwgY2xhc3NOYW1lICs9IGAgcHQtbGlzdC1pdGVtIHB0LWxpc3QtaXRlbS0ke2VsZW1lbnQubGlzdEl0ZW19IHB0LWxpc3QtaXRlbS1sZXZlbC0ke2xldmVsIHx8IDF9YCksIGVkaXRvci5pc0xpc3RCbG9jayh2YWx1ZSkgJiYgaXNMaXN0SXRlbSAmJiBlbGVtZW50Lmxpc3RJdGVtKSB7XG4gICAgICBjb25zdCBsaXN0VHlwZSA9IHNjaGVtYVR5cGVzLmxpc3RzLmZpbmQoKGl0ZW1fMCkgPT4gaXRlbV8wLnZhbHVlID09PSBlbGVtZW50Lmxpc3RJdGVtKTtcbiAgICAgIHJlbmRlckxpc3RJdGVtICYmIGxpc3RUeXBlID8gcmVuZGVyZWRCbG9jayA9IHJlbmRlckxpc3RJdGVtKHtcbiAgICAgICAgYmxvY2s6IHZhbHVlLFxuICAgICAgICBjaGlsZHJlbjogcmVuZGVyZWRCbG9jayxcbiAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgIHZhbHVlOiBlbGVtZW50Lmxpc3RJdGVtLFxuICAgICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICAgIHNjaGVtYVR5cGU6IGxpc3RUeXBlLFxuICAgICAgICBsZXZlbDogdmFsdWUubGV2ZWwgfHwgMSxcbiAgICAgICAgZWRpdG9yRWxlbWVudFJlZjogYmxvY2tSZWZcbiAgICAgIH0pIDogcmVuZGVyZWRCbG9jayA9IC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdExpc3RJdGVtLCB7IGxpc3RTdHlsZTogdmFsdWUubGlzdEl0ZW0gfHwgc2NoZW1hVHlwZXMubGlzdHNbMF0udmFsdWUsIGxpc3RMZXZlbDogdmFsdWUubGV2ZWwgfHwgMSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdExpc3RJdGVtSW5uZXIsIHsgY2hpbGRyZW46IHJlbmRlcmVkQmxvY2sgfSkgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgIGNoaWxkcmVuOiByZW5kZXJlZEJsb2NrLFxuICAgICAgZWRpdG9yRWxlbWVudFJlZjogYmxvY2tSZWYsXG4gICAgICBmb2N1c2VkLFxuICAgICAgbGV2ZWwsXG4gICAgICBsaXN0SXRlbTogaXNMaXN0SXRlbSA/IGVsZW1lbnQubGlzdEl0ZW0gOiB2b2lkIDAsXG4gICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHN0eWxlLFxuICAgICAgc2NoZW1hVHlwZTogc2NoZW1hVHlwZXMuYmxvY2ssXG4gICAgICB2YWx1ZVxuICAgIH0sIFwidHlwZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcIlByb3BlcnR5ICd0eXBlJyBpcyBkZXByZWNhdGVkLCB1c2UgJ3NjaGVtYVR5cGUnIGluc3RlYWQuXCIpLCBzY2hlbWFUeXBlcy5ibG9jaztcbiAgICAgIH1cbiAgICB9KSwgcHJvcHNPckRlZmF1bHRSZW5kZXJlZCA9IHJlbmRlckJsb2NrID8gcmVuZGVyQmxvY2socmVuZGVyUHJvcHMpIDogY2hpbGRyZW47XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyAuLi5hdHRyaWJ1dGVzLCBjbGFzc05hbWUsIHNwZWxsQ2hlY2ssIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KERyYWdnYWJsZUJsb2NrLCB7IGVsZW1lbnQsIHJlYWRPbmx5LCBibG9ja1JlZiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyByZWY6IGJsb2NrUmVmLCBjaGlsZHJlbjogcHJvcHNPckRlZmF1bHRSZW5kZXJlZCB9KSB9KSB9LCBlbGVtZW50Ll9rZXkpO1xuICB9XG4gIGNvbnN0IHNjaGVtYVR5cGVfMCA9IHNjaGVtYVR5cGVzLmJsb2NrT2JqZWN0cy5maW5kKChfdHlwZV8wKSA9PiBfdHlwZV8wLm5hbWUgPT09IGVsZW1lbnQuX3R5cGUpO1xuICBpZiAoIXNjaGVtYVR5cGVfMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHNjaGVtYSB0eXBlIGZvciBibG9jayBlbGVtZW50IG9mIF90eXBlICR7ZWxlbWVudC5fdHlwZX1gKTtcbiAgY2xhc3NOYW1lID0gXCJwdC1ibG9jayBwdC1vYmplY3QtYmxvY2tcIjtcbiAgY29uc3QgYmxvY2tfMCA9IGZyb21TbGF0ZVZhbHVlKFtlbGVtZW50XSwgc2NoZW1hVHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpWzBdO1xuICBsZXQgcmVuZGVyZWRCbG9ja0Zyb21Qcm9wcztcbiAgaWYgKHJlbmRlckJsb2NrKSB7XG4gICAgY29uc3QgX3Byb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRPYmplY3QsIHsgdmFsdWUgfSksXG4gICAgICBlZGl0b3JFbGVtZW50UmVmOiBibG9ja1JlZixcbiAgICAgIGZvY3VzZWQsXG4gICAgICBwYXRoOiBibG9ja1BhdGgsXG4gICAgICBzY2hlbWFUeXBlOiBzY2hlbWFUeXBlXzAsXG4gICAgICBzZWxlY3RlZCxcbiAgICAgIHZhbHVlOiBibG9ja18wXG4gICAgfSwgXCJ0eXBlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGVfMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZW5kZXJlZEJsb2NrRnJvbVByb3BzID0gcmVuZGVyQmxvY2soX3Byb3BzKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgeyAuLi5hdHRyaWJ1dGVzLCBjbGFzc05hbWUsIGNoaWxkcmVuOiBbXG4gICAgY2hpbGRyZW4sXG4gICAgLyogQF9fUFVSRV9fICovIGpzeHMoRHJhZ2dhYmxlQmxvY2ssIHsgZWxlbWVudCwgcmVhZE9ubHksIGJsb2NrUmVmLCBjaGlsZHJlbjogW1xuICAgICAgcmVuZGVyZWRCbG9ja0Zyb21Qcm9wcyAmJiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgcmVmOiBibG9ja1JlZiwgY29udGVudEVkaXRhYmxlOiAhMSwgY2hpbGRyZW46IHJlbmRlcmVkQmxvY2tGcm9tUHJvcHMgfSksXG4gICAgICAhcmVuZGVyZWRCbG9ja0Zyb21Qcm9wcyAmJiAvKiBAX19QVVJFX18gKi8ganN4KERlZmF1bHRCbG9ja09iamVjdCwgeyBzZWxlY3RlZCwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdE9iamVjdCwgeyB2YWx1ZSB9KSB9KVxuICAgIF0gfSlcbiAgXSB9LCBlbGVtZW50Ll9rZXkpO1xufTtcbkVsZW1lbnQuZGlzcGxheU5hbWUgPSBcIkVsZW1lbnRcIjtcbmNvbnN0IFBvcnRhYmxlVGV4dEVkaXRvckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpLCB1c2VQb3J0YWJsZVRleHRFZGl0b3IgPSAoKSA9PiB7XG4gIGNvbnN0IGVkaXRvciA9IHVzZUNvbnRleHQoUG9ydGFibGVUZXh0RWRpdG9yQ29udGV4dCk7XG4gIGlmICghZWRpdG9yKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlUG9ydGFibGVUZXh0RWRpdG9yYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxQb3J0YWJsZVRleHRFZGl0b3I+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICByZXR1cm4gZWRpdG9yO1xufTtcbmZ1bmN0aW9uIERlZmF1bHRBbm5vdGF0aW9uKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDYpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHByb3BzLmFubm90YXRpb24gPyAodDAgPSAoKSA9PiBhbGVydChKU09OLnN0cmluZ2lmeShwcm9wcy5hbm5vdGF0aW9uKSksICRbMF0gPSBwcm9wcy5hbm5vdGF0aW9uLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBjb25zdCBoYW5kbGVDbGljayA9IHQwO1xuICBsZXQgdDE7XG4gICRbMl0gPT09IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vX2NhY2hlX3NlbnRpbmVsXCIpID8gKHQxID0ge1xuICAgIGNvbG9yOiBcImJsdWVcIlxuICB9LCAkWzJdID0gdDEpIDogdDEgPSAkWzJdO1xuICBsZXQgdDI7XG4gIHJldHVybiAkWzNdICE9PSBoYW5kbGVDbGljayB8fCAkWzRdICE9PSBwcm9wcy5jaGlsZHJlbiA/ICh0MiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgc3R5bGU6IHQxLCBvbkNsaWNrOiBoYW5kbGVDbGljaywgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pLCAkWzNdID0gaGFuZGxlQ2xpY2ssICRbNF0gPSBwcm9wcy5jaGlsZHJlbiwgJFs1XSA9IHQyKSA6IHQyID0gJFs1XSwgdDI7XG59XG5EZWZhdWx0QW5ub3RhdGlvbi5kaXNwbGF5TmFtZSA9IFwiRGVmYXVsdEFubm90YXRpb25cIjtcbmZ1bmN0aW9uIGNvbXBpbGVUeXBlKHJhd1R5cGUpIHtcbiAgcmV0dXJuIFNjaGVtYS5jb21waWxlKHtcbiAgICBuYW1lOiBcImJsb2NrVHlwZVNjaGVtYVwiLFxuICAgIHR5cGVzOiBbcmF3VHlwZV1cbiAgfSkuZ2V0KHJhd1R5cGUubmFtZSk7XG59XG5jb25zdCBGTFVTSF9QQVRDSEVTX1RIUk9UVExFRF9NUyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInRlc3RcIiA/IDUwMCA6IDFlMywgbXV0YXRpb25NYWNoaW5lID0gc2V0dXAoe1xuICB0eXBlczoge1xuICAgIGNvbnRleHQ6IHt9LFxuICAgIGV2ZW50czoge30sXG4gICAgaW5wdXQ6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9XG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcImVtaXQgaGFzIHBlbmRpbmcgcGF0Y2hlc1wiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiXG4gICAgfSksXG4gICAgXCJlbWl0IG11dGF0aW9uXCI6IGVtaXQoKHtcbiAgICAgIGNvbnRleHRcbiAgICB9KSA9PiAoe1xuICAgICAgdHlwZTogXCJtdXRhdGlvblwiLFxuICAgICAgcGF0Y2hlczogY29udGV4dC5wZW5kaW5nUGF0Y2hlcyxcbiAgICAgIHNuYXBzaG90OiBmcm9tU2xhdGVWYWx1ZShjb250ZXh0LnNsYXRlRWRpdG9yLmNoaWxkcmVuLCBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoY29udGV4dC5zbGF0ZUVkaXRvcikpXG4gICAgfSkpLFxuICAgIFwiY2xlYXIgcGVuZGluZyBwYXRjaGVzXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nUGF0Y2hlczogW11cbiAgICB9KSxcbiAgICBcImRlZmVyIHBhdGNoXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nUGF0Y2hlczogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IFsuLi5jb250ZXh0LnBlbmRpbmdQYXRjaGVzLCBldmVudC5wYXRjaF1cbiAgICB9KVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBcInNsYXRlIGlzIG5vcm1hbGl6aW5nXCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gRWRpdG9yLmlzTm9ybWFsaXppbmcoY29udGV4dC5zbGF0ZUVkaXRvcilcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIGlkOiBcIm11dGF0aW9uXCIsXG4gIGNvbnRleHQ6ICh7XG4gICAgaW5wdXRcbiAgfSkgPT4gKHtcbiAgICBwZW5kaW5nUGF0Y2hlczogW10sXG4gICAgc2NoZW1hOiBpbnB1dC5zY2hlbWEsXG4gICAgc2xhdGVFZGl0b3I6IGlucHV0LnNsYXRlRWRpdG9yXG4gIH0pLFxuICBpbml0aWFsOiBcImlkbGVcIixcbiAgc3RhdGVzOiB7XG4gICAgaWRsZToge1xuICAgICAgb246IHtcbiAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICBhY3Rpb25zOiBbXCJkZWZlciBwYXRjaFwiLCBcImVtaXQgaGFzIHBlbmRpbmcgcGF0Y2hlc1wiXSxcbiAgICAgICAgICB0YXJnZXQ6IFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiOiB7XG4gICAgICBhZnRlcjoge1xuICAgICAgICBbRkxVU0hfUEFUQ0hFU19USFJPVFRMRURfTVNdOiBbe1xuICAgICAgICAgIGd1YXJkOiBcInNsYXRlIGlzIG5vcm1hbGl6aW5nXCIsXG4gICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIixcbiAgICAgICAgICBhY3Rpb25zOiBbXCJlbWl0IG11dGF0aW9uXCIsIFwiY2xlYXIgcGVuZGluZyBwYXRjaGVzXCJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICByZWVudGVyOiAhMFxuICAgICAgICB9XVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIHBhdGNoOiB7XG4gICAgICAgICAgYWN0aW9uczogW1wiZGVmZXIgcGF0Y2hcIl0sXG4gICAgICAgICAgcmVlbnRlcjogITBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbHVlLCB0eXBlcywga2V5R2VuZXJhdG9yKSB7XG4gIGxldCByZXNvbHV0aW9uID0gbnVsbCwgdmFsaWQgPSAhMDtcbiAgY29uc3QgdmFsaWRDaGlsZFR5cGVzID0gW3R5cGVzLnNwYW4ubmFtZSwgLi4udHlwZXMuaW5saW5lT2JqZWN0cy5tYXAoKHQpID0+IHQubmFtZSldLCB2YWxpZEJsb2NrVHlwZXMgPSBbdHlwZXMuYmxvY2submFtZSwgLi4udHlwZXMuYmxvY2tPYmplY3RzLm1hcCgodCkgPT4gdC5uYW1lKV07XG4gIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8ge1xuICAgIHZhbGlkOiAhMCxcbiAgICByZXNvbHV0aW9uOiBudWxsLFxuICAgIHZhbHVlXG4gIH0gOiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID09PSAwID8ge1xuICAgIHZhbGlkOiAhMSxcbiAgICByZXNvbHV0aW9uOiB7XG4gICAgICBwYXRjaGVzOiBbdW5zZXQoW10pXSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkVkaXRvciB2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IG9mIFBvcnRhYmxlIFRleHQgYmxvY2tzLCBvciB1bmRlZmluZWQuXCIsXG4gICAgICBhY3Rpb246IFwiVW5zZXQgdGhlIHZhbHVlXCIsXG4gICAgICBpdGVtOiB2YWx1ZSxcbiAgICAgIGkxOG46IHtcbiAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub3QtYW4tYXJyYXkuZGVzY3JpcHRpb25cIixcbiAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLWFycmF5LmFjdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICB2YWx1ZVxuICB9IDogKHZhbHVlLnNvbWUoKGJsaywgaW5kZXgpID0+IHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYmxrKSlcbiAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW2luZGV4XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgJHtTdHJpbmcoYmxrKX1gLFxuICAgICAgICBhY3Rpb246IFwiVW5zZXQgaW52YWxpZCBpdGVtXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm90LWFuLW9iamVjdC5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm5vdC1hbi1vYmplY3QuYWN0aW9uXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBpbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITA7XG4gICAgaWYgKCFibGsuX2tleSB8fCB0eXBlb2YgYmxrLl9rZXkgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAuLi5ibGssXG4gICAgICAgICAgX2tleToga2V5R2VuZXJhdG9yKClcbiAgICAgICAgfSwgW2luZGV4XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIGF0IGluZGV4ICR7aW5kZXh9IGlzIG1pc3NpbmcgcmVxdWlyZWQgX2tleS5gLFxuICAgICAgICBhY3Rpb246IFwiU2V0IHRoZSBibG9jayB3aXRoIGEgcmFuZG9tIF9rZXkgdmFsdWVcIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWtleS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmcta2V5LmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwO1xuICAgIGlmICghYmxrLl90eXBlIHx8ICF2YWxpZEJsb2NrVHlwZXMuaW5jbHVkZXMoYmxrLl90eXBlKSkge1xuICAgICAgaWYgKGJsay5fdHlwZSA9PT0gXCJibG9ja1wiKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCbG9ja1R5cGVOYW1lID0gdHlwZXMuYmxvY2submFtZTtcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgICAuLi5ibGssXG4gICAgICAgICAgICBfdHlwZTogY3VycmVudEJsb2NrVHlwZU5hbWVcbiAgICAgICAgICB9LCBbe1xuICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICB9XSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaGFzIGludmFsaWQgdHlwZSBuYW1lICcke2Jsay5fdHlwZX0nLiBBY2NvcmRpbmcgdG8gdGhlIHNjaGVtYSwgdGhlIGJsb2NrIHR5cGUgbmFtZSBpcyAnJHtjdXJyZW50QmxvY2tUeXBlTmFtZX0nYCxcbiAgICAgICAgICBhY3Rpb246IGBVc2UgdHlwZSAnJHtjdXJyZW50QmxvY2tUeXBlTmFtZX0nYCxcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5pbmNvcnJlY3QtYmxvY2stdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW5jb3JyZWN0LWJsb2NrLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgZXhwZWN0ZWRUeXBlTmFtZTogY3VycmVudEJsb2NrVHlwZU5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFibGsuX3R5cGUgJiYgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2soe1xuICAgICAgICAuLi5ibGssXG4gICAgICAgIF90eXBlOiB0eXBlcy5ibG9jay5uYW1lXG4gICAgICB9KSA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbc2V0KHtcbiAgICAgICAgICAuLi5ibGssXG4gICAgICAgICAgX3R5cGU6IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgICAgfSwgW3tcbiAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGlzIG1pc3NpbmcgYSB0eXBlIG5hbWUuIEFjY29yZGluZyB0byB0aGUgc2NoZW1hLCB0aGUgYmxvY2sgdHlwZSBuYW1lIGlzICcke3R5cGVzLmJsb2NrLm5hbWV9J2AsXG4gICAgICAgIGFjdGlvbjogYFVzZSB0eXBlICcke3R5cGVzLmJsb2NrLm5hbWV9J2AsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1ibG9jay10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1ibG9jay10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZU5hbWU6IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sICEwKSA6IGJsay5fdHlwZSA/IChyZXNvbHV0aW9uID0ge1xuICAgICAgICBwYXRjaGVzOiBbdW5zZXQoW3tcbiAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICB9XSldLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEJsb2NrIHdpdGggX2tleSAnJHtibGsuX2tleX0nIGhhcyBpbnZhbGlkIF90eXBlICcke2Jsay5fdHlwZX0nYCxcbiAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgYmxvY2tcIixcbiAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICBpMThuOiB7XG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLXR5cGUuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgdHlwZU5hbWU6IGJsay5fdHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITApIDogKHJlc29sdXRpb24gPSB7XG4gICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgIH1dKV0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaXMgbWlzc2luZyBhbiBfdHlwZSBwcm9wZXJ0eWAsXG4gICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIGJsb2NrXCIsXG4gICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy10eXBlLmFjdGlvblwiLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAga2V5OiBibGsuX2tleVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgITApO1xuICAgIH1cbiAgICBpZiAoYmxrLl90eXBlID09PSB0eXBlcy5ibG9jay5uYW1lKSB7XG4gICAgICBjb25zdCB0ZXh0QmxvY2sgPSBibGs7XG4gICAgICBpZiAodGV4dEJsb2NrLmNoaWxkcmVuICYmICFBcnJheS5pc0FycmF5KHRleHRCbG9jay5jaGlsZHJlbikpXG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFtzZXQoe1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgfSwgW3tcbiAgICAgICAgICAgIF9rZXk6IHRleHRCbG9jay5fa2V5XG4gICAgICAgICAgfV0pXSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYFRleHQgYmxvY2sgd2l0aCBfa2V5ICcke3RleHRCbG9jay5fa2V5fScgaGFzIGEgaW52YWxpZCByZXF1aXJlZCBwcm9wZXJ0eSAnY2hpbGRyZW4nLmAsXG4gICAgICAgICAgYWN0aW9uOiBcIlJlc2V0IHRoZSBjaGlsZHJlbiBwcm9wZXJ0eVwiLFxuICAgICAgICAgIGl0ZW06IHRleHRCbG9jayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3Npbmctb3ItaW52YWxpZC1jaGlsZHJlbi5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1vci1pbnZhbGlkLWNoaWxkcmVuLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogdGV4dEJsb2NrLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwO1xuICAgICAgaWYgKHRleHRCbG9jay5jaGlsZHJlbiA9PT0gdm9pZCAwIHx8IEFycmF5LmlzQXJyYXkodGV4dEJsb2NrLmNoaWxkcmVuKSAmJiB0ZXh0QmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG5ld1NwYW4gPSB7XG4gICAgICAgICAgX3R5cGU6IHR5cGVzLnNwYW4ubmFtZSxcbiAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiA9IHtcbiAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgcGF0Y2hlczogW3NldElmTWlzc2luZyhbXSwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiXSksIGluc2VydChbbmV3U3Bhbl0sIFwiYWZ0ZXJcIiwgW3tcbiAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCAwXSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGRyZW4gZm9yIHRleHQgYmxvY2sgd2l0aCBfa2V5ICcke2Jsay5fa2V5fScgaXMgZW1wdHkuYCxcbiAgICAgICAgICBhY3Rpb246IFwiSW5zZXJ0IGFuIGVtcHR5IHRleHRcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5lbXB0eS1jaGlsZHJlbi5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZW1wdHktY2hpbGRyZW4uYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgITA7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGxVc2VkTWFya3MgPSB1bmlxKGZsYXR0ZW4odGV4dEJsb2NrLmNoaWxkcmVuLmZpbHRlcigoY2xkKSA9PiBjbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSkubWFwKChjbGQpID0+IGNsZC5tYXJrcyB8fCBbXSkpKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGJsay5tYXJrRGVmcykgJiYgYmxrLm1hcmtEZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW51c2VkTWFya0RlZnMgPSB1bmlxKGJsay5tYXJrRGVmcy5tYXAoKGRlZikgPT4gZGVmLl9rZXkpLmZpbHRlcigoa2V5KSA9PiAhYWxsVXNlZE1hcmtzLmluY2x1ZGVzKGtleSkpKTtcbiAgICAgICAgaWYgKHVudXNlZE1hcmtEZWZzLmxlbmd0aCA+IDApXG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgICBwYXRjaGVzOiB1bnVzZWRNYXJrRGVmcy5tYXAoKG1hcmtEZWZLZXkpID0+IHVuc2V0KFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcIm1hcmtEZWZzXCIsIHtcbiAgICAgICAgICAgICAgX2tleTogbWFya0RlZktleVxuICAgICAgICAgICAgfV0pKSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQmxvY2sgY29udGFpbnMgb3JwaGFuZWQgZGF0YSAodW51c2VkIG1hcmsgZGVmaW5pdGlvbnMpOiAke3VudXNlZE1hcmtEZWZzLmpvaW4oXCIsIFwiKX0uYCxcbiAgICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdW51c2VkIG1hcmsgZGVmaW5pdGlvbiBpdGVtXCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUub3JwaGFuZWQtbWFyay1kZWZzLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm9ycGhhbmVkLW1hcmstZGVmcy5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICB1bnVzZWRNYXJrRGVmczogdW51c2VkTWFya0RlZnMubWFwKChtKSA9PiBtLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9ycGhhbmVkTWFya3MgPSBhbGxVc2VkTWFya3MuZmlsdGVyKChtYXJrKSA9PiAhdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlYykgPT4gZGVjLnZhbHVlKS5pbmNsdWRlcyhtYXJrKSkuZmlsdGVyKChtYXJrKSA9PiB0ZXh0QmxvY2subWFya0RlZnMgPT09IHZvaWQgMCB8fCAhdGV4dEJsb2NrLm1hcmtEZWZzLmZpbmQoKGRlZikgPT4gZGVmLl9rZXkgPT09IG1hcmspKTtcbiAgICAgIGlmIChvcnBoYW5lZE1hcmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc3BhbkNoaWxkcmVuID0gdGV4dEJsb2NrLmNoaWxkcmVuLmZpbHRlcigoY2xkKSA9PiBjbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSAmJiBBcnJheS5pc0FycmF5KGNsZC5tYXJrcykgJiYgY2xkLm1hcmtzLnNvbWUoKG1hcmspID0+IG9ycGhhbmVkTWFya3MuaW5jbHVkZXMobWFyaykpKTtcbiAgICAgICAgaWYgKHNwYW5DaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IG9ycGhhbmVkID0gb3JwaGFuZWRNYXJrcy5qb2luKFwiLCBcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgICBwYXRjaGVzOiBzcGFuQ2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gc2V0KChjaGlsZC5tYXJrcyB8fCBbXSkuZmlsdGVyKChjTXJrKSA9PiAhb3JwaGFuZWRNYXJrcy5pbmNsdWRlcyhjTXJrKSksIFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgICAgfSwgXCJtYXJrc1wiXSkpLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBCbG9jayB3aXRoIF9rZXkgJyR7YmxrLl9rZXl9JyBjb250YWlucyBtYXJrcyAoJHtvcnBoYW5lZH0pIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgY29udGVudCBtb2RlbC5gLFxuICAgICAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSBpbnZhbGlkIG1hcmtzXCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUub3JwaGFuZWQtbWFya3MuZGVzY3JpcHRpb25cIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUub3JwaGFuZWQtbWFya3MuYWN0aW9uXCIsXG4gICAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgICAgb3JwaGFuZWRNYXJrczogb3JwaGFuZWRNYXJrcy5tYXAoKG0pID0+IG0udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZXh0QmxvY2suY2hpbGRyZW4uc29tZSgoY2hpbGQsIGNJbmRleCkgPT4ge1xuICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QoY2hpbGQpKVxuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uID0ge1xuICAgICAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7XG4gICAgICAgICAgICAgIF9rZXk6IGJsay5fa2V5XG4gICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIGNJbmRleF0pXSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgYXQgaW5kZXggJyR7Y0luZGV4fScgaW4gYmxvY2sgd2l0aCBrZXkgJyR7YmxrLl9rZXl9JyBpcyBub3QgYW4gb2JqZWN0LmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiUmVtb3ZlIHRoZSBpdGVtXCIsXG4gICAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubm9uLW9iamVjdC1jaGlsZC5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5ub24tb2JqZWN0LWNoaWxkLmFjdGlvblwiLFxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IGJsay5fa2V5LFxuICAgICAgICAgICAgICAgIGluZGV4OiBjSW5kZXhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sICEwO1xuICAgICAgICBpZiAoIWNoaWxkLl9rZXkgfHwgdHlwZW9mIGNoaWxkLl9rZXkgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0ge1xuICAgICAgICAgICAgLi4uY2hpbGQsXG4gICAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgICBhdXRvUmVzb2x2ZTogITAsXG4gICAgICAgICAgICBwYXRjaGVzOiBbc2V0KG5ld0NoaWxkLCBbe1xuICAgICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgICAgfSwgXCJjaGlsZHJlblwiLCBjSW5kZXhdKV0sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYENoaWxkIGF0IGluZGV4ICR7Y0luZGV4fSBpcyBtaXNzaW5nIHJlcXVpcmVkIF9rZXkgaW4gYmxvY2sgd2l0aCBfa2V5ICR7YmxrLl9rZXl9LmAsXG4gICAgICAgICAgICBhY3Rpb246IFwiU2V0IGEgbmV3IHJhbmRvbSBfa2V5IG9uIHRoZSBvYmplY3RcIixcbiAgICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLWtleS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5taXNzaW5nLWNoaWxkLWtleS5hY3Rpb25cIixcbiAgICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgICBpbmRleDogY0luZGV4XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAhMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQuX3R5cGUgPyB2YWxpZENoaWxkVHlwZXMuaW5jbHVkZXMoY2hpbGQuX3R5cGUpID8gY2hpbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSAmJiB0eXBlb2YgY2hpbGQudGV4dCAhPSBcInN0cmluZ1wiID8gKHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3NldCh7XG4gICAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICAgIHRleHQ6IFwiXCJcbiAgICAgICAgICB9LCBbe1xuICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICB9XSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgd2l0aCBfa2V5ICcke2NoaWxkLl9rZXl9JyBpbiBibG9jayB3aXRoIGtleSAnJHtibGsuX2tleX0nIGhhcyBtaXNzaW5nIG9yIGludmFsaWQgdGV4dCBwcm9wZXJ0eSFgLFxuICAgICAgICAgIGFjdGlvbjogXCJXcml0ZSBhbiBlbXB0eSB0ZXh0IHByb3BlcnR5IHRvIHRoZSBvYmplY3RcIixcbiAgICAgICAgICBpdGVtOiBibGssXG4gICAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5pbnZhbGlkLXNwYW4tdGV4dC5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuaW52YWxpZC1zcGFuLXRleHQuYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgY2hpbGRLZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwKSA6ICExIDogKHJlc29sdXRpb24gPSB7XG4gICAgICAgICAgcGF0Y2hlczogW3Vuc2V0KFt7XG4gICAgICAgICAgICBfa2V5OiBibGsuX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgICAgIH1dKV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IGBDaGlsZCB3aXRoIF9rZXkgJyR7Y2hpbGQuX2tleX0nIGluIGJsb2NrIHdpdGgga2V5ICcke2Jsay5fa2V5fScgaGFzIGludmFsaWQgJ190eXBlJyBwcm9wZXJ0eSAoJHtjaGlsZC5fdHlwZX0pLmAsXG4gICAgICAgICAgYWN0aW9uOiBcIlJlbW92ZSB0aGUgb2JqZWN0XCIsXG4gICAgICAgICAgaXRlbTogYmxrLFxuICAgICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUuZGlzYWxsb3dlZC1jaGlsZC10eXBlLmRlc2NyaXB0aW9uXCIsXG4gICAgICAgICAgICBhY3Rpb246IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuaW52YWxpZC12YWx1ZS5kaXNhbGxvd2VkLWNoaWxkLXR5cGUuYWN0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAga2V5OiBibGsuX2tleSxcbiAgICAgICAgICAgICAgY2hpbGRLZXk6IGNoaWxkLl9rZXksXG4gICAgICAgICAgICAgIGNoaWxkVHlwZTogY2hpbGQuX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sICEwKSA6IChyZXNvbHV0aW9uID0ge1xuICAgICAgICAgIHBhdGNoZXM6IFt1bnNldChbe1xuICAgICAgICAgICAgX2tleTogYmxrLl9rZXlcbiAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIF9rZXk6IGNoaWxkLl9rZXlcbiAgICAgICAgICB9XSldLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2hpbGQgd2l0aCBfa2V5ICcke2NoaWxkLl9rZXl9JyBpbiBibG9jayB3aXRoIGtleSAnJHtibGsuX2tleX0nIGlzIG1pc3NpbmcgJ190eXBlJyBwcm9wZXJ0eS5gLFxuICAgICAgICAgIGFjdGlvbjogXCJSZW1vdmUgdGhlIG9iamVjdFwiLFxuICAgICAgICAgIGl0ZW06IGJsayxcbiAgICAgICAgICBpMThuOiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5pbnZhbGlkLXZhbHVlLm1pc3NpbmctY2hpbGQtdHlwZS5kZXNjcmlwdGlvblwiLFxuICAgICAgICAgICAgYWN0aW9uOiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmludmFsaWQtdmFsdWUubWlzc2luZy1jaGlsZC10eXBlLmFjdGlvblwiLFxuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgIGtleTogYmxrLl9rZXksXG4gICAgICAgICAgICAgIGNoaWxkS2V5OiBjaGlsZC5fa2V5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCAhMCk7XG4gICAgICB9KSAmJiAodmFsaWQgPSAhMSk7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfSkgJiYgKHZhbGlkID0gITEpLCB7XG4gICAgdmFsaWQsXG4gICAgcmVzb2x1dGlvbixcbiAgICB2YWx1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIHdpdGhSZW1vdGVDaGFuZ2VzKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpIHx8ICExO1xuICBJU19QUk9DRVNTSU5HX1JFTU9URV9DSEFOR0VTLnNldChlZGl0b3IsICEwKSwgZm4oKSwgSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpIHtcbiAgcmV0dXJuIElTX1BST0NFU1NJTkdfUkVNT1RFX0NIQU5HRVMuZ2V0KGVkaXRvcik7XG59XG5jb25zdCBQQVRDSElORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd2l0aG91dFBhdGNoaW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzUGF0Y2hpbmcoZWRpdG9yKTtcbiAgUEFUQ0hJTkcuc2V0KGVkaXRvciwgITEpLCBmbigpLCBQQVRDSElORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGlzUGF0Y2hpbmcoZWRpdG9yKSB7XG4gIHJldHVybiBQQVRDSElORy5nZXQoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIGNsb25lRGlmZihkaWZmMikge1xuICBjb25zdCBbdHlwZSwgcGF0Y2hdID0gZGlmZjI7XG4gIHJldHVybiBbdHlwZSwgcGF0Y2hdO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uT3ZlcmxhcCh0ZXh0QSwgdGV4dEIpIHtcbiAgbGV0IHRleHQxID0gdGV4dEEsIHRleHQyID0gdGV4dEI7XG4gIGNvbnN0IHRleHQxTGVuZ3RoID0gdGV4dDEubGVuZ3RoLCB0ZXh0Mkxlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgaWYgKHRleHQxTGVuZ3RoID09PSAwIHx8IHRleHQyTGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgdGV4dDFMZW5ndGggPiB0ZXh0Mkxlbmd0aCA/IHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKHRleHQxTGVuZ3RoIC0gdGV4dDJMZW5ndGgpIDogdGV4dDFMZW5ndGggPCB0ZXh0Mkxlbmd0aCAmJiAodGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDFMZW5ndGgpKTtcbiAgY29uc3QgdGV4dExlbmd0aCA9IE1hdGgubWluKHRleHQxTGVuZ3RoLCB0ZXh0Mkxlbmd0aCk7XG4gIGlmICh0ZXh0MSA9PT0gdGV4dDIpIHJldHVybiB0ZXh0TGVuZ3RoO1xuICBsZXQgYmVzdCA9IDAsIGxlbmd0aCA9IDE7XG4gIGZvciAobGV0IGZvdW5kID0gMDsgZm91bmQgIT09IC0xOyApIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGV4dDEuc3Vic3RyaW5nKHRleHRMZW5ndGggLSBsZW5ndGgpO1xuICAgIGlmIChmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybiksIGZvdW5kID09PSAtMSkgcmV0dXJuIGJlc3Q7XG4gICAgbGVuZ3RoICs9IGZvdW5kLCAoZm91bmQgPT09IDAgfHwgdGV4dDEuc3Vic3RyaW5nKHRleHRMZW5ndGggLSBsZW5ndGgpID09PSB0ZXh0Mi5zdWJzdHJpbmcoMCwgbGVuZ3RoKSkgJiYgKGJlc3QgPSBsZW5ndGgsIGxlbmd0aCsrKTtcbiAgfVxuICByZXR1cm4gYmVzdDtcbn1cbmZ1bmN0aW9uIGdldENvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpIHtcbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDFbMF0gIT09IHRleHQyWzBdKSByZXR1cm4gMDtcbiAgbGV0IHBvaW50ZXJNaW4gPSAwLCBwb2ludGVyTWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpLCBwb2ludGVyTWlkID0gcG9pbnRlck1heCwgcG9pbnRlclN0YXJ0ID0gMDtcbiAgZm9yICg7IHBvaW50ZXJNaW4gPCBwb2ludGVyTWlkOyApIHRleHQxLnN1YnN0cmluZyhwb2ludGVyU3RhcnQsIHBvaW50ZXJNaWQpID09PSB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlclN0YXJ0LCBwb2ludGVyTWlkKSA/IChwb2ludGVyTWluID0gcG9pbnRlck1pZCwgcG9pbnRlclN0YXJ0ID0gcG9pbnRlck1pbikgOiBwb2ludGVyTWF4ID0gcG9pbnRlck1pZCwgcG9pbnRlck1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJNYXggLSBwb2ludGVyTWluKSAvIDIgKyBwb2ludGVyTWluKTtcbiAgcmV0dXJuIHBvaW50ZXJNaWQ7XG59XG5mdW5jdGlvbiBnZXRDb21tb25TdWZmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxW3RleHQxLmxlbmd0aCAtIDFdICE9PSB0ZXh0Mlt0ZXh0Mi5sZW5ndGggLSAxXSkgcmV0dXJuIDA7XG4gIGxldCBwb2ludGVyTWluID0gMCwgcG9pbnRlck1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKSwgcG9pbnRlck1pZCA9IHBvaW50ZXJNYXgsIHBvaW50ZXJFbmQgPSAwO1xuICBmb3IgKDsgcG9pbnRlck1pbiA8IHBvaW50ZXJNaWQ7ICkgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJNaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJFbmQpID09PSB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlck1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlckVuZCkgPyAocG9pbnRlck1pbiA9IHBvaW50ZXJNaWQsIHBvaW50ZXJFbmQgPSBwb2ludGVyTWluKSA6IHBvaW50ZXJNYXggPSBwb2ludGVyTWlkLCBwb2ludGVyTWlkID0gTWF0aC5mbG9vcigocG9pbnRlck1heCAtIHBvaW50ZXJNaW4pIC8gMiArIHBvaW50ZXJNaW4pO1xuICByZXR1cm4gcG9pbnRlck1pZDtcbn1cbmZ1bmN0aW9uIGlzSGlnaFN1cnJvZ2F0ZShjaGFyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY2hhckNvZGUgPj0gNTUyOTYgJiYgY2hhckNvZGUgPD0gNTYzMTk7XG59XG5mdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjaGFyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY2hhckNvZGUgPj0gNTYzMjAgJiYgY2hhckNvZGUgPD0gNTczNDM7XG59XG5mdW5jdGlvbiBiaXNlY3QodGV4dDEsIHRleHQyLCBkZWFkbGluZSkge1xuICBjb25zdCB0ZXh0MUxlbmd0aCA9IHRleHQxLmxlbmd0aCwgdGV4dDJMZW5ndGggPSB0ZXh0Mi5sZW5ndGgsIG1heEQgPSBNYXRoLmNlaWwoKHRleHQxTGVuZ3RoICsgdGV4dDJMZW5ndGgpIC8gMiksIHZPZmZzZXQgPSBtYXhELCB2TGVuZ3RoID0gMiAqIG1heEQsIHYxID0gbmV3IEFycmF5KHZMZW5ndGgpLCB2MiA9IG5ldyBBcnJheSh2TGVuZ3RoKTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB2TGVuZ3RoOyB4KyspIHYxW3hdID0gLTEsIHYyW3hdID0gLTE7XG4gIHYxW3ZPZmZzZXQgKyAxXSA9IDAsIHYyW3ZPZmZzZXQgKyAxXSA9IDA7XG4gIGNvbnN0IGRlbHRhID0gdGV4dDFMZW5ndGggLSB0ZXh0Mkxlbmd0aCwgZnJvbnQgPSBkZWx0YSAlIDIgIT09IDA7XG4gIGxldCBrMXN0YXJ0ID0gMCwgazFlbmQgPSAwLCBrMnN0YXJ0ID0gMCwgazJlbmQgPSAwO1xuICBmb3IgKGxldCBkID0gMDsgZCA8IG1heEQgJiYgIShEYXRlLm5vdygpID4gZGVhZGxpbmUpOyBkKyspIHtcbiAgICBmb3IgKGxldCBrMSA9IC1kICsgazFzdGFydDsgazEgPD0gZCAtIGsxZW5kOyBrMSArPSAyKSB7XG4gICAgICBjb25zdCBrMU9mZnNldCA9IHZPZmZzZXQgKyBrMTtcbiAgICAgIGxldCB4MTtcbiAgICAgIGsxID09PSAtZCB8fCBrMSAhPT0gZCAmJiB2MVtrMU9mZnNldCAtIDFdIDwgdjFbazFPZmZzZXQgKyAxXSA/IHgxID0gdjFbazFPZmZzZXQgKyAxXSA6IHgxID0gdjFbazFPZmZzZXQgLSAxXSArIDE7XG4gICAgICBsZXQgeTEgPSB4MSAtIGsxO1xuICAgICAgZm9yICg7IHgxIDwgdGV4dDFMZW5ndGggJiYgeTEgPCB0ZXh0Mkxlbmd0aCAmJiB0ZXh0MS5jaGFyQXQoeDEpID09PSB0ZXh0Mi5jaGFyQXQoeTEpOyApIHgxKyssIHkxKys7XG4gICAgICBpZiAodjFbazFPZmZzZXRdID0geDEsIHgxID4gdGV4dDFMZW5ndGgpIGsxZW5kICs9IDI7XG4gICAgICBlbHNlIGlmICh5MSA+IHRleHQyTGVuZ3RoKSBrMXN0YXJ0ICs9IDI7XG4gICAgICBlbHNlIGlmIChmcm9udCkge1xuICAgICAgICBjb25zdCBrMk9mZnNldCA9IHZPZmZzZXQgKyBkZWx0YSAtIGsxO1xuICAgICAgICBpZiAoazJPZmZzZXQgPj0gMCAmJiBrMk9mZnNldCA8IHZMZW5ndGggJiYgdjJbazJPZmZzZXRdICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IHgyID0gdGV4dDFMZW5ndGggLSB2MltrMk9mZnNldF07XG4gICAgICAgICAgaWYgKHgxID49IHgyKSByZXR1cm4gYmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCB4MSwgeTEsIGRlYWRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrMiA9IC1kICsgazJzdGFydDsgazIgPD0gZCAtIGsyZW5kOyBrMiArPSAyKSB7XG4gICAgICBjb25zdCBrMk9mZnNldCA9IHZPZmZzZXQgKyBrMjtcbiAgICAgIGxldCB4MjtcbiAgICAgIGsyID09PSAtZCB8fCBrMiAhPT0gZCAmJiB2MltrMk9mZnNldCAtIDFdIDwgdjJbazJPZmZzZXQgKyAxXSA/IHgyID0gdjJbazJPZmZzZXQgKyAxXSA6IHgyID0gdjJbazJPZmZzZXQgLSAxXSArIDE7XG4gICAgICBsZXQgeTIgPSB4MiAtIGsyO1xuICAgICAgZm9yICg7IHgyIDwgdGV4dDFMZW5ndGggJiYgeTIgPCB0ZXh0Mkxlbmd0aCAmJiB0ZXh0MS5jaGFyQXQodGV4dDFMZW5ndGggLSB4MiAtIDEpID09PSB0ZXh0Mi5jaGFyQXQodGV4dDJMZW5ndGggLSB5MiAtIDEpOyApIHgyKyssIHkyKys7XG4gICAgICBpZiAodjJbazJPZmZzZXRdID0geDIsIHgyID4gdGV4dDFMZW5ndGgpIGsyZW5kICs9IDI7XG4gICAgICBlbHNlIGlmICh5MiA+IHRleHQyTGVuZ3RoKSBrMnN0YXJ0ICs9IDI7XG4gICAgICBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazFPZmZzZXQgPSB2T2Zmc2V0ICsgZGVsdGEgLSBrMjtcbiAgICAgICAgaWYgKGsxT2Zmc2V0ID49IDAgJiYgazFPZmZzZXQgPCB2TGVuZ3RoICYmIHYxW2sxT2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MSA9IHYxW2sxT2Zmc2V0XSwgeTEgPSB2T2Zmc2V0ICsgeDEgLSBrMU9mZnNldDtcbiAgICAgICAgICBpZiAoeDIgPSB0ZXh0MUxlbmd0aCAtIHgyLCB4MSA+PSB4MikgcmV0dXJuIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xufVxuZnVuY3Rpb24gYmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCB4LCB5LCBkZWFkbGluZSkge1xuICBjb25zdCB0ZXh0MWEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgeCksIHRleHQyYSA9IHRleHQyLnN1YnN0cmluZygwLCB5KSwgdGV4dDFiID0gdGV4dDEuc3Vic3RyaW5nKHgpLCB0ZXh0MmIgPSB0ZXh0Mi5zdWJzdHJpbmcoeSksIGRpZmZzID0gZG9EaWZmKHRleHQxYSwgdGV4dDJhLCB7XG4gICAgY2hlY2tMaW5lczogITEsXG4gICAgZGVhZGxpbmVcbiAgfSksIGRpZmZzYiA9IGRvRGlmZih0ZXh0MWIsIHRleHQyYiwge1xuICAgIGNoZWNrTGluZXM6ICExLFxuICAgIGRlYWRsaW5lXG4gIH0pO1xuICByZXR1cm4gZGlmZnMuY29uY2F0KGRpZmZzYik7XG59XG5mdW5jdGlvbiBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0MiwgdGltZW91dCA9IDEpIHtcbiAgaWYgKHRpbWVvdXQgPD0gMCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGxvbmdUZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0Miwgc2hvcnRUZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgaWYgKGxvbmdUZXh0Lmxlbmd0aCA8IDQgfHwgc2hvcnRUZXh0Lmxlbmd0aCAqIDIgPCBsb25nVGV4dC5sZW5ndGgpIHJldHVybiBudWxsO1xuICBjb25zdCBoYWxmTWF0Y2gxID0gaGFsZk1hdGNoSShsb25nVGV4dCwgc2hvcnRUZXh0LCBNYXRoLmNlaWwobG9uZ1RleHQubGVuZ3RoIC8gNCkpLCBoYWxmTWF0Y2gyID0gaGFsZk1hdGNoSShsb25nVGV4dCwgc2hvcnRUZXh0LCBNYXRoLmNlaWwobG9uZ1RleHQubGVuZ3RoIC8gMikpO1xuICBsZXQgaGFsZk1hdGNoO1xuICBpZiAoaGFsZk1hdGNoMSAmJiBoYWxmTWF0Y2gyKSBoYWxmTWF0Y2ggPSBoYWxmTWF0Y2gxWzRdLmxlbmd0aCA+IGhhbGZNYXRjaDJbNF0ubGVuZ3RoID8gaGFsZk1hdGNoMSA6IGhhbGZNYXRjaDI7XG4gIGVsc2Uge1xuICAgIGlmICghaGFsZk1hdGNoMSAmJiAhaGFsZk1hdGNoMikgcmV0dXJuIG51bGw7XG4gICAgaGFsZk1hdGNoMiA/IGhhbGZNYXRjaDEgfHwgKGhhbGZNYXRjaCA9IGhhbGZNYXRjaDIpIDogaGFsZk1hdGNoID0gaGFsZk1hdGNoMTtcbiAgfVxuICBpZiAoIWhhbGZNYXRjaCkgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgYSBoYWxmIG1hdGNoLlwiKTtcbiAgbGV0IHRleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQjtcbiAgdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gKHRleHQxQSA9IGhhbGZNYXRjaFswXSwgdGV4dDFCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MkEgPSBoYWxmTWF0Y2hbMl0sIHRleHQyQiA9IGhhbGZNYXRjaFszXSkgOiAodGV4dDJBID0gaGFsZk1hdGNoWzBdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbMV0sIHRleHQxQSA9IGhhbGZNYXRjaFsyXSwgdGV4dDFCID0gaGFsZk1hdGNoWzNdKTtcbiAgY29uc3QgbWlkQ29tbW9uID0gaGFsZk1hdGNoWzRdO1xuICByZXR1cm4gW3RleHQxQSwgdGV4dDFCLCB0ZXh0MkEsIHRleHQyQiwgbWlkQ29tbW9uXTtcbn1cbmZ1bmN0aW9uIGhhbGZNYXRjaEkobG9uZ1RleHQsIHNob3J0VGV4dCwgaSkge1xuICBjb25zdCBzZWVkID0gbG9uZ1RleHQuc2xpY2UoaSwgaSArIE1hdGguZmxvb3IobG9uZ1RleHQubGVuZ3RoIC8gNCkpO1xuICBsZXQgaiA9IC0xLCBiZXN0Q29tbW9uID0gXCJcIiwgYmVzdExvbmdUZXh0QSwgYmVzdExvbmdUZXh0QiwgYmVzdFNob3J0VGV4dEEsIGJlc3RTaG9ydFRleHRCO1xuICBmb3IgKDsgKGogPSBzaG9ydFRleHQuaW5kZXhPZihzZWVkLCBqICsgMSkpICE9PSAtMTsgKSB7XG4gICAgY29uc3QgcHJlZml4TGVuZ3RoID0gZ2V0Q29tbW9uUHJlZml4KGxvbmdUZXh0LnNsaWNlKGkpLCBzaG9ydFRleHQuc2xpY2UoaikpLCBzdWZmaXhMZW5ndGggPSBnZXRDb21tb25TdWZmaXgobG9uZ1RleHQuc2xpY2UoMCwgaSksIHNob3J0VGV4dC5zbGljZSgwLCBqKSk7XG4gICAgYmVzdENvbW1vbi5sZW5ndGggPCBzdWZmaXhMZW5ndGggKyBwcmVmaXhMZW5ndGggJiYgKGJlc3RDb21tb24gPSBzaG9ydFRleHQuc2xpY2UoaiAtIHN1ZmZpeExlbmd0aCwgaikgKyBzaG9ydFRleHQuc2xpY2UoaiwgaiArIHByZWZpeExlbmd0aCksIGJlc3RMb25nVGV4dEEgPSBsb25nVGV4dC5zbGljZSgwLCBpIC0gc3VmZml4TGVuZ3RoKSwgYmVzdExvbmdUZXh0QiA9IGxvbmdUZXh0LnNsaWNlKGkgKyBwcmVmaXhMZW5ndGgpLCBiZXN0U2hvcnRUZXh0QSA9IHNob3J0VGV4dC5zbGljZSgwLCBqIC0gc3VmZml4TGVuZ3RoKSwgYmVzdFNob3J0VGV4dEIgPSBzaG9ydFRleHQuc2xpY2UoaiArIHByZWZpeExlbmd0aCkpO1xuICB9XG4gIHJldHVybiBiZXN0Q29tbW9uLmxlbmd0aCAqIDIgPj0gbG9uZ1RleHQubGVuZ3RoID8gW2Jlc3RMb25nVGV4dEEgfHwgXCJcIiwgYmVzdExvbmdUZXh0QiB8fCBcIlwiLCBiZXN0U2hvcnRUZXh0QSB8fCBcIlwiLCBiZXN0U2hvcnRUZXh0QiB8fCBcIlwiLCBiZXN0Q29tbW9uIHx8IFwiXCJdIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNoYXJzVG9MaW5lcyhkaWZmcywgbGluZUFycmF5KSB7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBjaGFycyA9IGRpZmZzW3hdWzFdLCB0ZXh0ID0gW107XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBjaGFycy5sZW5ndGg7IHkrKykgdGV4dFt5XSA9IGxpbmVBcnJheVtjaGFycy5jaGFyQ29kZUF0KHkpXTtcbiAgICBkaWZmc1t4XVsxXSA9IHRleHQuam9pbihcIlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gbGluZXNUb0NoYXJzKHRleHRBLCB0ZXh0Qikge1xuICBjb25zdCBsaW5lQXJyYXkgPSBbXSwgbGluZUhhc2ggPSB7fTtcbiAgbGluZUFycmF5WzBdID0gXCJcIjtcbiAgZnVuY3Rpb24gZGlmZkxpbmVzVG9NdW5nZSh0ZXh0KSB7XG4gICAgbGV0IGNoYXJzID0gXCJcIiwgbGluZVN0YXJ0ID0gMCwgbGluZUVuZCA9IC0xLCBsaW5lQXJyYXlMZW5ndGggPSBsaW5lQXJyYXkubGVuZ3RoO1xuICAgIGZvciAoOyBsaW5lRW5kIDwgdGV4dC5sZW5ndGggLSAxOyApIHtcbiAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoYFxuYCwgbGluZVN0YXJ0KSwgbGluZUVuZCA9PT0gLTEgJiYgKGxpbmVFbmQgPSB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IGxpbmUgPSB0ZXh0LnNsaWNlKGxpbmVTdGFydCwgbGluZUVuZCArIDEpO1xuICAgICAgKGxpbmVIYXNoLmhhc093blByb3BlcnR5ID8gbGluZUhhc2guaGFzT3duUHJvcGVydHkobGluZSkgOiBsaW5lSGFzaFtsaW5lXSAhPT0gdm9pZCAwKSA/IGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUhhc2hbbGluZV0pIDogKGxpbmVBcnJheUxlbmd0aCA9PT0gbWF4TGluZXMgJiYgKGxpbmUgPSB0ZXh0LnNsaWNlKGxpbmVTdGFydCksIGxpbmVFbmQgPSB0ZXh0Lmxlbmd0aCksIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKSwgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGgsIGxpbmVBcnJheVtsaW5lQXJyYXlMZW5ndGgrK10gPSBsaW5lKSwgbGluZVN0YXJ0ID0gbGluZUVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfVxuICBsZXQgbWF4TGluZXMgPSA0ZTQ7XG4gIGNvbnN0IGNoYXJzMSA9IGRpZmZMaW5lc1RvTXVuZ2UodGV4dEEpO1xuICBtYXhMaW5lcyA9IDY1NTM1O1xuICBjb25zdCBjaGFyczIgPSBkaWZmTGluZXNUb011bmdlKHRleHRCKTtcbiAgcmV0dXJuIHtcbiAgICBjaGFyczEsXG4gICAgY2hhcnMyLFxuICAgIGxpbmVBcnJheVxuICB9O1xufVxuZnVuY3Rpb24gZG9MaW5lTW9kZURpZmYodGV4dEEsIHRleHRCLCBvcHRzKSB7XG4gIGxldCB0ZXh0MSA9IHRleHRBLCB0ZXh0MiA9IHRleHRCO1xuICBjb25zdCBhID0gbGluZXNUb0NoYXJzKHRleHQxLCB0ZXh0Mik7XG4gIHRleHQxID0gYS5jaGFyczEsIHRleHQyID0gYS5jaGFyczI7XG4gIGNvbnN0IGxpbmVhcnJheSA9IGEubGluZUFycmF5O1xuICBsZXQgZGlmZnMgPSBkb0RpZmYodGV4dDEsIHRleHQyLCB7XG4gICAgY2hlY2tMaW5lczogITEsXG4gICAgZGVhZGxpbmU6IG9wdHMuZGVhZGxpbmVcbiAgfSk7XG4gIGNoYXJzVG9MaW5lcyhkaWZmcywgbGluZWFycmF5KSwgZGlmZnMgPSBjbGVhbnVwU2VtYW50aWMoZGlmZnMpLCBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBcIlwiXSk7XG4gIGxldCBwb2ludGVyID0gMCwgY291bnREZWxldGUgPSAwLCBjb3VudEluc2VydCA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkge1xuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGNvdW50SW5zZXJ0KyssIHRleHRJbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnREZWxldGUrKywgdGV4dERlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChjb3VudERlbGV0ZSA+PSAxICYmIGNvdW50SW5zZXJ0ID49IDEpIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQsIGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQpLCBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQ7XG4gICAgICAgICAgY29uc3QgYWEgPSBkb0RpZmYodGV4dERlbGV0ZSwgdGV4dEluc2VydCwge1xuICAgICAgICAgICAgY2hlY2tMaW5lczogITEsXG4gICAgICAgICAgICBkZWFkbGluZTogb3B0cy5kZWFkbGluZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAobGV0IGogPSBhYS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIGFhW2pdKTtcbiAgICAgICAgICBwb2ludGVyICs9IGFhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb3VudEluc2VydCA9IDAsIGNvdW50RGVsZXRlID0gMCwgdGV4dERlbGV0ZSA9IFwiXCIsIHRleHRJbnNlcnQgPSBcIlwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGlmZiBvcGVyYXRpb24uXCIpO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzLnBvcCgpLCBkaWZmcztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVEaWZmKHRleHQxLCB0ZXh0Miwgb3B0cykge1xuICBsZXQgZGlmZnM7XG4gIGlmICghdGV4dDEpIHJldHVybiBbW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICBpZiAoIXRleHQyKSByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdXTtcbiAgY29uc3QgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyLCBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxLCBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPT0gLTEpIHJldHVybiBkaWZmcyA9IFtbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKV0sIFtESUZGX0VRVUFMLCBzaG9ydHRleHRdLCBbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCldXSwgdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoICYmIChkaWZmc1swXVswXSA9IERJRkZfREVMRVRFLCBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFKSwgZGlmZnM7XG4gIGlmIChzaG9ydHRleHQubGVuZ3RoID09PSAxKSByZXR1cm4gW1tESUZGX0RFTEVURSwgdGV4dDFdLCBbRElGRl9JTlNFUlQsIHRleHQyXV07XG4gIGNvbnN0IGhhbGZNYXRjaCA9IGZpbmRIYWxmTWF0Y2godGV4dDEsIHRleHQyKTtcbiAgaWYgKGhhbGZNYXRjaCkge1xuICAgIGNvbnN0IHRleHQxQSA9IGhhbGZNYXRjaFswXSwgdGV4dDFCID0gaGFsZk1hdGNoWzFdLCB0ZXh0MkEgPSBoYWxmTWF0Y2hbMl0sIHRleHQyQiA9IGhhbGZNYXRjaFszXSwgbWlkQ29tbW9uID0gaGFsZk1hdGNoWzRdLCBkaWZmc0EgPSBkb0RpZmYodGV4dDFBLCB0ZXh0MkEsIG9wdHMpLCBkaWZmc0IgPSBkb0RpZmYodGV4dDFCLCB0ZXh0MkIsIG9wdHMpO1xuICAgIHJldHVybiBkaWZmc0EuY29uY2F0KFtbRElGRl9FUVVBTCwgbWlkQ29tbW9uXV0sIGRpZmZzQik7XG4gIH1cbiAgcmV0dXJuIG9wdHMuY2hlY2tMaW5lcyAmJiB0ZXh0MS5sZW5ndGggPiAxMDAgJiYgdGV4dDIubGVuZ3RoID4gMTAwID8gZG9MaW5lTW9kZURpZmYodGV4dDEsIHRleHQyLCBvcHRzKSA6IGJpc2VjdCh0ZXh0MSwgdGV4dDIsIG9wdHMuZGVhZGxpbmUpO1xufVxudmFyIF9fZGVmUHJvcCQyID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2dldE93blByb3BTeW1ib2xzJDIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBfX2hhc093blByb3AkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIF9fcHJvcElzRW51bSQyID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgX19kZWZOb3JtYWxQcm9wJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDIob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19zcHJlYWRWYWx1ZXMkMiA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSkgX19oYXNPd25Qcm9wJDIuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMihhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMkMikgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzJDIoYikpIF9fcHJvcElzRW51bSQyLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDIoYSwgcHJvcCwgYltwcm9wXSk7XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IERJRkZfREVMRVRFID0gLTEsIERJRkZfSU5TRVJUID0gMSwgRElGRl9FUVVBTCA9IDA7XG5mdW5jdGlvbiBkaWZmKHRleHRBLCB0ZXh0Qiwgb3B0cykge1xuICBpZiAodGV4dEEgPT09IG51bGwgfHwgdGV4dEIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIk51bGwgaW5wdXQuIChkaWZmKVwiKTtcbiAgY29uc3QgZGlmZnMgPSBkb0RpZmYodGV4dEEsIHRleHRCLCBjcmVhdGVJbnRlcm5hbE9wdHMob3B0cyB8fCB7fSkpO1xuICByZXR1cm4gYWRqdXN0RGlmZkZvclN1cnJvZ2F0ZVBhaXJzKGRpZmZzKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBkb0RpZmYodGV4dEEsIHRleHRCLCBvcHRpb25zKSB7XG4gIGxldCB0ZXh0MSA9IHRleHRBLCB0ZXh0MiA9IHRleHRCO1xuICBpZiAodGV4dDEgPT09IHRleHQyKSByZXR1cm4gdGV4dDEgPyBbW0RJRkZfRVFVQUwsIHRleHQxXV0gOiBbXTtcbiAgbGV0IGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25wcmVmaXggPSB0ZXh0MS5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSwgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSwgY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gIGNvbnN0IGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpLCB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0Mi5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICBsZXQgZGlmZnMgPSBjb21wdXRlRGlmZih0ZXh0MSwgdGV4dDIsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tbW9ucHJlZml4ICYmIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIGNvbW1vbnByZWZpeF0pLCBjb21tb25zdWZmaXggJiYgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgY29tbW9uc3VmZml4XSksIGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWFkTGluZSh0aW1lb3V0KSB7XG4gIGxldCB0ID0gMTtcbiAgcmV0dXJuIHR5cGVvZiB0aW1lb3V0IDwgXCJ1XCIgJiYgKHQgPSB0aW1lb3V0IDw9IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogdGltZW91dCksIERhdGUubm93KCkgKyB0ICogMWUzO1xufVxuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxPcHRzKG9wdHMpIHtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzJDIoe1xuICAgIGNoZWNrTGluZXM6ICEwLFxuICAgIGRlYWRsaW5lOiBjcmVhdGVEZWFkTGluZShvcHRzLnRpbWVvdXQgfHwgMSlcbiAgfSwgb3B0cyk7XG59XG5mdW5jdGlvbiBjb21iaW5lQ2hhcihkYXRhLCBjaGFyLCBkaXIpIHtcbiAgcmV0dXJuIGRpciA9PT0gMSA/IGRhdGEgKyBjaGFyIDogY2hhciArIGRhdGE7XG59XG5mdW5jdGlvbiBzcGxpdENoYXIoZGF0YSwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBbZGF0YS5zdWJzdHJpbmcoMCwgZGF0YS5sZW5ndGggLSAxKSwgZGF0YVtkYXRhLmxlbmd0aCAtIDFdXSA6IFtkYXRhLnN1YnN0cmluZygxKSwgZGF0YVswXV07XG59XG5mdW5jdGlvbiBoYXNTaGFyZWRDaGFyKGRpZmZzLCBpLCBqLCBkaXIpIHtcbiAgcmV0dXJuIGRpciA9PT0gMSA/IGRpZmZzW2ldWzFdW2RpZmZzW2ldWzFdLmxlbmd0aCAtIDFdID09PSBkaWZmc1tqXVsxXVtkaWZmc1tqXVsxXS5sZW5ndGggLSAxXSA6IGRpZmZzW2ldWzFdWzBdID09PSBkaWZmc1tqXVsxXVswXTtcbn1cbmZ1bmN0aW9uIGRlaXNvbGF0ZUNoYXIoZGlmZnMsIGksIGRpcikge1xuICBjb25zdCBpbnYgPSBkaXIgPT09IDEgPyAtMSA6IDE7XG4gIGxldCBpbnNlcnRJZHggPSBudWxsLCBkZWxldGVJZHggPSBudWxsLCBqID0gaSArIGRpcjtcbiAgZm9yICg7IGogPj0gMCAmJiBqIDwgZGlmZnMubGVuZ3RoICYmIChpbnNlcnRJZHggPT09IG51bGwgfHwgZGVsZXRlSWR4ID09PSBudWxsKTsgaiArPSBkaXIpIHtcbiAgICBjb25zdCBbb3AsIHRleHQyXSA9IGRpZmZzW2pdO1xuICAgIGlmICh0ZXh0Mi5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmIChvcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgaW5zZXJ0SWR4ID09PSBudWxsICYmIChpbnNlcnRJZHggPSBqKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG9wID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICBkZWxldGVJZHggPT09IG51bGwgJiYgKGRlbGV0ZUlkeCA9IGopO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAob3AgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgaWYgKGluc2VydElkeCA9PT0gbnVsbCAmJiBkZWxldGVJZHggPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBbcmVzdCwgY2hhcjJdID0gc3BsaXRDaGFyKGRpZmZzW2ldWzFdLCBkaXIpO1xuICAgICAgICAgIGRpZmZzW2ldWzFdID0gcmVzdCwgZGlmZnNbal1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tqXVsxXSwgY2hhcjIsIGludik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5zZXJ0SWR4ICE9PSBudWxsICYmIGRlbGV0ZUlkeCAhPT0gbnVsbCAmJiBoYXNTaGFyZWRDaGFyKGRpZmZzLCBpbnNlcnRJZHgsIGRlbGV0ZUlkeCwgZGlyKSkge1xuICAgIGNvbnN0IFtpbnNlcnRUZXh0MiwgaW5zZXJ0Q2hhcl0gPSBzcGxpdENoYXIoZGlmZnNbaW5zZXJ0SWR4XVsxXSwgaW52KSwgW2RlbGV0ZVRleHRdID0gc3BsaXRDaGFyKGRpZmZzW2RlbGV0ZUlkeF1bMV0sIGludik7XG4gICAgZGlmZnNbaW5zZXJ0SWR4XVsxXSA9IGluc2VydFRleHQyLCBkaWZmc1tkZWxldGVJZHhdWzFdID0gZGVsZXRlVGV4dCwgZGlmZnNbaV1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tpXVsxXSwgaW5zZXJ0Q2hhciwgZGlyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW3RleHQsIGNoYXJdID0gc3BsaXRDaGFyKGRpZmZzW2ldWzFdLCBkaXIpO1xuICBkaWZmc1tpXVsxXSA9IHRleHQsIGluc2VydElkeCA9PT0gbnVsbCA/IChkaWZmcy5zcGxpY2UoaiwgMCwgW0RJRkZfSU5TRVJULCBjaGFyXSksIGRlbGV0ZUlkeCAhPT0gbnVsbCAmJiBkZWxldGVJZHggPj0gaiAmJiBkZWxldGVJZHgrKykgOiBkaWZmc1tpbnNlcnRJZHhdWzFdID0gY29tYmluZUNoYXIoZGlmZnNbaW5zZXJ0SWR4XVsxXSwgY2hhciwgaW52KSwgZGVsZXRlSWR4ID09PSBudWxsID8gZGlmZnMuc3BsaWNlKGosIDAsIFtESUZGX0RFTEVURSwgY2hhcl0pIDogZGlmZnNbZGVsZXRlSWR4XVsxXSA9IGNvbWJpbmVDaGFyKGRpZmZzW2RlbGV0ZUlkeF1bMV0sIGNoYXIsIGludik7XG59XG5mdW5jdGlvbiBhZGp1c3REaWZmRm9yU3Vycm9nYXRlUGFpcnMoZGlmZnMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtkaWZmVHlwZSwgZGlmZlRleHRdID0gZGlmZnNbaV07XG4gICAgaWYgKGRpZmZUZXh0Lmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgY29uc3QgZmlyc3RDaGFyID0gZGlmZlRleHRbMF0sIGxhc3RDaGFyID0gZGlmZlRleHRbZGlmZlRleHQubGVuZ3RoIC0gMV07XG4gICAgaXNIaWdoU3Vycm9nYXRlKGxhc3RDaGFyKSAmJiBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCAmJiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCAxKSwgaXNMb3dTdXJyb2dhdGUoZmlyc3RDaGFyKSAmJiBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCAmJiBkZWlzb2xhdGVDaGFyKGRpZmZzLCBpLCAtMSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykgZGlmZnNbaV1bMV0ubGVuZ3RoID09PSAwICYmIGRpZmZzLnNwbGljZShpLCAxKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBTZW1hbnRpYyhyYXdEaWZmcykge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKSwgaGFzQ2hhbmdlcyA9ICExO1xuICBjb25zdCBlcXVhbGl0aWVzID0gW107XG4gIGxldCBlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcG9pbnRlciA9IDAsIGxlbmd0aEluc2VydGlvbnMxID0gMCwgbGVuZ3RoRGVsZXRpb25zMSA9IDAsIGxlbmd0aEluc2VydGlvbnMyID0gMCwgbGVuZ3RoRGVsZXRpb25zMiA9IDA7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMID8gKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXIsIGxlbmd0aEluc2VydGlvbnMxID0gbGVuZ3RoSW5zZXJ0aW9uczIsIGxlbmd0aERlbGV0aW9uczEgPSBsZW5ndGhEZWxldGlvbnMyLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwLCBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXSkgOiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUID8gbGVuZ3RoSW5zZXJ0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDogbGVuZ3RoRGVsZXRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGgsIGxhc3RFcXVhbGl0eSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMxLCBsZW5ndGhEZWxldGlvbnMxKSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aEluc2VydGlvbnMyLCBsZW5ndGhEZWxldGlvbnMyKSAmJiAoZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBbRElGRl9ERUxFVEUsIGxhc3RFcXVhbGl0eV0pLCBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQsIGVxdWFsaXRpZXNMZW5ndGgtLSwgZXF1YWxpdGllc0xlbmd0aC0tLCBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xLCBsZW5ndGhJbnNlcnRpb25zMSA9IDAsIGxlbmd0aERlbGV0aW9uczEgPSAwLCBsZW5ndGhJbnNlcnRpb25zMiA9IDAsIGxlbmd0aERlbGV0aW9uczIgPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICBmb3IgKGhhc0NoYW5nZXMgJiYgKGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSksIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpLCBwb2ludGVyID0gMTsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9ERUxFVEUgJiYgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICBjb25zdCBkZWxldGlvbiA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSwgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV0sIG92ZXJsYXBMZW5ndGgxID0gZ2V0Q29tbW9uT3ZlcmxhcChkZWxldGlvbiwgaW5zZXJ0aW9uKSwgb3ZlcmxhcExlbmd0aDIgPSBnZXRDb21tb25PdmVybGFwKGluc2VydGlvbiwgZGVsZXRpb24pO1xuICAgICAgb3ZlcmxhcExlbmd0aDEgPj0gb3ZlcmxhcExlbmd0aDIgPyAob3ZlcmxhcExlbmd0aDEgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwTGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikgJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwTGVuZ3RoMSldKSwgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKDAsIGRlbGV0aW9uLmxlbmd0aCAtIG92ZXJsYXBMZW5ndGgxKSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZyhvdmVybGFwTGVuZ3RoMSksIHBvaW50ZXIrKykgOiAob3ZlcmxhcExlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwTGVuZ3RoMiA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikgJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9FUVVBTCwgZGVsZXRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBMZW5ndGgyKV0pLCBkaWZmc1twb2ludGVyIC0gMV1bMF0gPSBESUZGX0lOU0VSVCwgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBpbnNlcnRpb24ubGVuZ3RoIC0gb3ZlcmxhcExlbmd0aDIpLCBkaWZmc1twb2ludGVyICsgMV1bMF0gPSBESUZGX0RFTEVURSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKG92ZXJsYXBMZW5ndGgyKSwgcG9pbnRlcisrKSwgcG9pbnRlcisrO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufVxuY29uc3Qgbm9uQWxwaGFOdW1lcmljUmVnZXggPSAvW15hLXpBLVowLTldLywgd2hpdGVzcGFjZVJlZ2V4ID0gL1xccy8sIGxpbmVicmVha1JlZ2V4ID0gL1tcXHJcXG5dLywgYmxhbmtsaW5lRW5kUmVnZXggPSAvXFxuXFxyP1xcbiQvLCBibGFua2xpbmVTdGFydFJlZ2V4ID0gL15cXHI/XFxuXFxyP1xcbi87XG5mdW5jdGlvbiBjbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhyYXdEaWZmcykge1xuICBjb25zdCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpO1xuICBmdW5jdGlvbiBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUob25lLCB0d28pIHtcbiAgICBpZiAoIW9uZSB8fCAhdHdvKSByZXR1cm4gNjtcbiAgICBjb25zdCBjaGFyMSA9IG9uZS5jaGFyQXQob25lLmxlbmd0aCAtIDEpLCBjaGFyMiA9IHR3by5jaGFyQXQoMCksIG5vbkFscGhhTnVtZXJpYzEgPSBjaGFyMS5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleCksIG5vbkFscGhhTnVtZXJpYzIgPSBjaGFyMi5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleCksIHdoaXRlc3BhY2UxID0gbm9uQWxwaGFOdW1lcmljMSAmJiBjaGFyMS5tYXRjaCh3aGl0ZXNwYWNlUmVnZXgpLCB3aGl0ZXNwYWNlMiA9IG5vbkFscGhhTnVtZXJpYzIgJiYgY2hhcjIubWF0Y2god2hpdGVzcGFjZVJlZ2V4KSwgbGluZUJyZWFrMSA9IHdoaXRlc3BhY2UxICYmIGNoYXIxLm1hdGNoKGxpbmVicmVha1JlZ2V4KSwgbGluZUJyZWFrMiA9IHdoaXRlc3BhY2UyICYmIGNoYXIyLm1hdGNoKGxpbmVicmVha1JlZ2V4KSwgYmxhbmtMaW5lMSA9IGxpbmVCcmVhazEgJiYgb25lLm1hdGNoKGJsYW5rbGluZUVuZFJlZ2V4KSwgYmxhbmtMaW5lMiA9IGxpbmVCcmVhazIgJiYgdHdvLm1hdGNoKGJsYW5rbGluZVN0YXJ0UmVnZXgpO1xuICAgIHJldHVybiBibGFua0xpbmUxIHx8IGJsYW5rTGluZTIgPyA1IDogbGluZUJyZWFrMSB8fCBsaW5lQnJlYWsyID8gNCA6IG5vbkFscGhhTnVtZXJpYzEgJiYgIXdoaXRlc3BhY2UxICYmIHdoaXRlc3BhY2UyID8gMyA6IHdoaXRlc3BhY2UxIHx8IHdoaXRlc3BhY2UyID8gMiA6IG5vbkFscGhhTnVtZXJpYzEgfHwgbm9uQWxwaGFOdW1lcmljMiA/IDEgOiAwO1xuICB9XG4gIGxldCBwb2ludGVyID0gMTtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxOyApIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMICYmIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgbGV0IGVxdWFsaXR5MSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSwgZWRpdCA9IGRpZmZzW3BvaW50ZXJdWzFdLCBlcXVhbGl0eTIgPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICBjb25zdCBjb21tb25PZmZzZXQgPSBnZXRDb21tb25TdWZmaXgoZXF1YWxpdHkxLCBlZGl0KTtcbiAgICAgIGlmIChjb21tb25PZmZzZXQpIHtcbiAgICAgICAgY29uc3QgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTEgPSBlcXVhbGl0eTEuc3Vic3RyaW5nKDAsIGVxdWFsaXR5MS5sZW5ndGggLSBjb21tb25PZmZzZXQpLCBlZGl0ID0gY29tbW9uU3RyaW5nICsgZWRpdC5zdWJzdHJpbmcoMCwgZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpLCBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XG4gICAgICB9XG4gICAgICBsZXQgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MSwgYmVzdEVkaXQgPSBlZGl0LCBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyLCBiZXN0U2NvcmUgPSBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgZm9yICg7IGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApOyApIHtcbiAgICAgICAgZXF1YWxpdHkxICs9IGVkaXQuY2hhckF0KDApLCBlZGl0ID0gZWRpdC5zdWJzdHJpbmcoMSkgKyBlcXVhbGl0eTIuY2hhckF0KDApLCBlcXVhbGl0eTIgPSBlcXVhbGl0eTIuc3Vic3RyaW5nKDEpO1xuICAgICAgICBjb25zdCBzY29yZSA9IGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlcXVhbGl0eTEsIGVkaXQpICsgZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICAgIHNjb3JlID49IGJlc3RTY29yZSAmJiAoYmVzdFNjb3JlID0gc2NvcmUsIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTEsIGJlc3RFZGl0ID0gZWRpdCwgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5Mik7XG4gICAgICB9XG4gICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gIT09IGJlc3RFcXVhbGl0eTEgJiYgKGJlc3RFcXVhbGl0eTEgPyBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBiZXN0RXF1YWxpdHkxIDogKGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSksIHBvaW50ZXItLSksIGRpZmZzW3BvaW50ZXJdWzFdID0gYmVzdEVkaXQsIGJlc3RFcXVhbGl0eTIgPyBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBiZXN0RXF1YWxpdHkyIDogKGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSksIHBvaW50ZXItLSkpO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufVxuZnVuY3Rpb24gY2xlYW51cE1lcmdlKHJhd0RpZmZzKSB7XG4gIGxldCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpO1xuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBcIlwiXSk7XG4gIGxldCBwb2ludGVyID0gMCwgY291bnREZWxldGUgPSAwLCBjb3VudEluc2VydCA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIiwgY29tbW9ubGVuZ3RoO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKSBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgIGNvdW50SW5zZXJ0KyssIHRleHRJbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV0sIHBvaW50ZXIrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICBjb3VudERlbGV0ZSsrLCB0ZXh0RGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdLCBwb2ludGVyKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0ID4gMSA/IChjb3VudERlbGV0ZSAhPT0gMCAmJiBjb3VudEluc2VydCAhPT0gMCAmJiAoY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uUHJlZml4KHRleHRJbnNlcnQsIHRleHREZWxldGUpLCBjb21tb25sZW5ndGggIT09IDAgJiYgKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0ID4gMCAmJiBkaWZmc1twb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gZGlmZnNbcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgLSAxXVsxXSArPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpIDogKGRpZmZzLnNwbGljZSgwLCAwLCBbRElGRl9FUVVBTCwgdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKV0pLCBwb2ludGVyKyspLCB0ZXh0SW5zZXJ0ID0gdGV4dEluc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSwgdGV4dERlbGV0ZSA9IHRleHREZWxldGUuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCkpLCBjb21tb25sZW5ndGggPSBnZXRDb21tb25TdWZmaXgodGV4dEluc2VydCwgdGV4dERlbGV0ZSksIGNvbW1vbmxlbmd0aCAhPT0gMCAmJiAoZGlmZnNbcG9pbnRlcl1bMV0gPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZyh0ZXh0SW5zZXJ0Lmxlbmd0aCAtIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXSwgdGV4dEluc2VydCA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKDAsIHRleHRJbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSwgdGV4dERlbGV0ZSA9IHRleHREZWxldGUuc3Vic3RyaW5nKDAsIHRleHREZWxldGUubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSkpLCBwb2ludGVyIC09IGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQsIGRpZmZzLnNwbGljZShwb2ludGVyLCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0KSwgdGV4dERlbGV0ZS5sZW5ndGggJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9ERUxFVEUsIHRleHREZWxldGVdKSwgcG9pbnRlcisrKSwgdGV4dEluc2VydC5sZW5ndGggJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9JTlNFUlQsIHRleHRJbnNlcnRdKSwgcG9pbnRlcisrKSwgcG9pbnRlcisrKSA6IHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyXVsxXSwgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpKSA6IHBvaW50ZXIrKywgY291bnRJbnNlcnQgPSAwLCBjb3VudERlbGV0ZSA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uXCIpO1xuICB9XG4gIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSBcIlwiICYmIGRpZmZzLnBvcCgpO1xuICBsZXQgaGFzQ2hhbmdlcyA9ICExO1xuICBmb3IgKHBvaW50ZXIgPSAxOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMTsgKSBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZnNbcG9pbnRlciArIDFdWzBdID09PSBESUZGX0VRVUFMICYmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCkgPT09IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA/IChkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSwgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdLCBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpLCBoYXNDaGFuZ2VzID0gITApIDogZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09PSBkaWZmc1twb2ludGVyICsgMV1bMV0gJiYgKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV0sIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICsgZGlmZnNbcG9pbnRlciArIDFdWzFdLCBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpLCBoYXNDaGFuZ2VzID0gITApKSwgcG9pbnRlcisrO1xuICByZXR1cm4gaGFzQ2hhbmdlcyAmJiAoZGlmZnMgPSBjbGVhbnVwTWVyZ2UoZGlmZnMpKSwgZGlmZnM7XG59XG5mdW5jdGlvbiB0cnVlQ291bnQoLi4uYXJncykge1xuICByZXR1cm4gYXJncy5yZWR1Y2UoKG4sIGJvb2wpID0+IG4gKyAoYm9vbCA/IDEgOiAwKSwgMCk7XG59XG5mdW5jdGlvbiBjbGVhbnVwRWZmaWNpZW5jeShyYXdEaWZmcywgZWRpdENvc3QgPSA0KSB7XG4gIGxldCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpLCBoYXNDaGFuZ2VzID0gITE7XG4gIGNvbnN0IGVxdWFsaXRpZXMgPSBbXTtcbiAgbGV0IGVxdWFsaXRpZXNMZW5ndGggPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBwb2ludGVyID0gMCwgcHJlSW5zID0gITEsIHByZURlbCA9ICExLCBwb3N0SW5zID0gITEsIHBvc3REZWwgPSAhMTtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfRVFVQUwgPyAoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDwgZWRpdENvc3QgJiYgKHBvc3RJbnMgfHwgcG9zdERlbCkgPyAoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlciwgcHJlSW5zID0gcG9zdElucywgcHJlRGVsID0gcG9zdERlbCwgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV0pIDogKGVxdWFsaXRpZXNMZW5ndGggPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsKSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITEpIDogKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0RFTEVURSA/IHBvc3REZWwgPSAhMCA6IHBvc3RJbnMgPSAhMCwgbGFzdEVxdWFsaXR5ICYmIChwcmVJbnMgJiYgcHJlRGVsICYmIHBvc3RJbnMgJiYgcG9zdERlbCB8fCBsYXN0RXF1YWxpdHkubGVuZ3RoIDwgZWRpdENvc3QgLyAyICYmIHRydWVDb3VudChwcmVJbnMsIHByZURlbCwgcG9zdElucywgcG9zdERlbCkgPT09IDMpICYmIChkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsIFtESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5XSksIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVCwgZXF1YWxpdGllc0xlbmd0aC0tLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBwcmVJbnMgJiYgcHJlRGVsID8gKHBvc3RJbnMgPSAhMCwgcG9zdERlbCA9ICEwLCBlcXVhbGl0aWVzTGVuZ3RoID0gMCkgOiAoZXF1YWxpdGllc0xlbmd0aC0tLCBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xLCBwb3N0SW5zID0gITEsIHBvc3REZWwgPSAhMSksIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIHJldHVybiBoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcztcbn1cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19nZXRPd25Qcm9wU3ltYm9scyQxID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wJDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0kMSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzJDEgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpIF9faGFzT3duUHJvcCQxLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wJDEoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzJDEpIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQxKGIpKSBfX3Byb3BJc0VudW0kMS5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQxKGEsIHByb3AsIGJbcHJvcF0pO1xuICByZXR1cm4gYTtcbn07XG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIC8qKlxuICAgKiBBdCB3aGF0IHBvaW50IGlzIG5vIG1hdGNoIGRlY2xhcmVkICgwLjAgPSBwZXJmZWN0aW9uLCAxLjAgPSB2ZXJ5IGxvb3NlKS5cbiAgICovXG4gIHRocmVzaG9sZDogMC41LFxuICAvKipcbiAgICogSG93IGZhciB0byBzZWFyY2ggZm9yIGEgbWF0Y2ggKDAgPSBleGFjdCBsb2NhdGlvbiwgMTAwMCsgPSBicm9hZCBtYXRjaCkuXG4gICAqIEEgbWF0Y2ggdGhpcyBtYW55IGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBleHBlY3RlZCBsb2NhdGlvbiB3aWxsIGFkZFxuICAgKiAxLjAgdG8gdGhlIHNjb3JlICgwLjAgaXMgYSBwZXJmZWN0IG1hdGNoKS5cbiAgICovXG4gIGRpc3RhbmNlOiAxZTNcbn07XG5mdW5jdGlvbiBhcHBseURlZmF1bHRzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzJDEoX19zcHJlYWRWYWx1ZXMkMSh7fSwgREVGQVVMVF9PUFRJT05TKSwgb3B0aW9ucyk7XG59XG5jb25zdCBNQVhfQklUUyQxID0gMzI7XG5mdW5jdGlvbiBiaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MsIG9wdHMgPSB7fSkge1xuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfQklUUyQxKSB0aHJvdyBuZXcgRXJyb3IoXCJQYXR0ZXJuIHRvbyBsb25nIGZvciB0aGlzIGJyb3dzZXIuXCIpO1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0cyhvcHRzKSwgcyA9IGdldEFscGhhYmV0RnJvbVBhdHRlcm4ocGF0dGVybik7XG4gIGZ1bmN0aW9uIGdldEJpdGFwU2NvcmUoZSwgeCkge1xuICAgIGNvbnN0IGFjY3VyYWN5ID0gZSAvIHBhdHRlcm4ubGVuZ3RoLCBwcm94aW1pdHkgPSBNYXRoLmFicyhsb2MgLSB4KTtcbiAgICByZXR1cm4gb3B0aW9ucy5kaXN0YW5jZSA/IGFjY3VyYWN5ICsgcHJveGltaXR5IC8gb3B0aW9ucy5kaXN0YW5jZSA6IHByb3hpbWl0eSA/IDEgOiBhY2N1cmFjeTtcbiAgfVxuICBsZXQgc2NvcmVUaHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCwgYmVzdExvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBsb2MpO1xuICBiZXN0TG9jICE9PSAtMSAmJiAoc2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihnZXRCaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCksIGJlc3RMb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIGxvYyArIHBhdHRlcm4ubGVuZ3RoKSwgYmVzdExvYyAhPT0gLTEgJiYgKHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4oZ2V0Qml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpKSk7XG4gIGNvbnN0IG1hdGNobWFzayA9IDEgPDwgcGF0dGVybi5sZW5ndGggLSAxO1xuICBiZXN0TG9jID0gLTE7XG4gIGxldCBiaW5NaW4sIGJpbk1pZCwgYmluTWF4ID0gcGF0dGVybi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCwgbGFzdFJkID0gW107XG4gIGZvciAobGV0IGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xuICAgIGZvciAoYmluTWluID0gMCwgYmluTWlkID0gYmluTWF4OyBiaW5NaW4gPCBiaW5NaWQ7ICkgZ2V0Qml0YXBTY29yZShkLCBsb2MgKyBiaW5NaWQpIDw9IHNjb3JlVGhyZXNob2xkID8gYmluTWluID0gYmluTWlkIDogYmluTWF4ID0gYmluTWlkLCBiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XG4gICAgYmluTWF4ID0gYmluTWlkO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIGxvYyAtIGJpbk1pZCArIDEpO1xuICAgIGNvbnN0IGZpbmlzaCA9IE1hdGgubWluKGxvYyArIGJpbk1pZCwgdGV4dC5sZW5ndGgpICsgcGF0dGVybi5sZW5ndGgsIHJkID0gbmV3IEFycmF5KGZpbmlzaCArIDIpO1xuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xuICAgIGZvciAobGV0IGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgY29uc3QgY2hhck1hdGNoID0gc1t0ZXh0LmNoYXJBdChqIC0gMSldO1xuICAgICAgaWYgKGQgPT09IDAgPyByZFtqXSA9IChyZFtqICsgMV0gPDwgMSB8IDEpICYgY2hhck1hdGNoIDogcmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaCB8ICgobGFzdFJkW2ogKyAxXSB8IGxhc3RSZFtqXSkgPDwgMSB8IDEpIHwgbGFzdFJkW2ogKyAxXSwgcmRbal0gJiBtYXRjaG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBnZXRCaXRhcFNjb3JlKGQsIGogLSAxKTtcbiAgICAgICAgaWYgKHNjb3JlIDw9IHNjb3JlVGhyZXNob2xkKSBpZiAoc2NvcmVUaHJlc2hvbGQgPSBzY29yZSwgYmVzdExvYyA9IGogLSAxLCBiZXN0TG9jID4gbG9jKSBzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBsb2MgLSBiZXN0TG9jKTtcbiAgICAgICAgZWxzZSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdldEJpdGFwU2NvcmUoZCArIDEsIGxvYykgPiBzY29yZVRocmVzaG9sZCkgYnJlYWs7XG4gICAgbGFzdFJkID0gcmQ7XG4gIH1cbiAgcmV0dXJuIGJlc3RMb2M7XG59XG5mdW5jdGlvbiBnZXRBbHBoYWJldEZyb21QYXR0ZXJuKHBhdHRlcm4pIHtcbiAgY29uc3QgcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHNbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSBzW3BhdHRlcm4uY2hhckF0KGkpXSB8PSAxIDw8IHBhdHRlcm4ubGVuZ3RoIC0gaSAtIDE7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gbWF0Y2godGV4dCwgcGF0dGVybiwgc2VhcmNoTG9jYXRpb24pIHtcbiAgaWYgKHRleHQgPT09IG51bGwgfHwgcGF0dGVybiA9PT0gbnVsbCB8fCBzZWFyY2hMb2NhdGlvbiA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKG1hdGNoKCkpXCIpO1xuICBjb25zdCBsb2MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWFyY2hMb2NhdGlvbiwgdGV4dC5sZW5ndGgpKTtcbiAgaWYgKHRleHQgPT09IHBhdHRlcm4pIHJldHVybiAwO1xuICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT09IHBhdHRlcm4pIHJldHVybiBsb2M7XG4gIH0gZWxzZSByZXR1cm4gLTE7XG4gIHJldHVybiBiaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQxKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykgZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQyKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykgZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gbGV2ZW5zaHRlaW4oZGlmZnMpIHtcbiAgbGV0IGxldmVuID0gMCwgaW5zZXJ0aW9ucyA9IDAsIGRlbGV0aW9ucyA9IDA7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBvcCA9IGRpZmZzW3hdWzBdLCBkYXRhID0gZGlmZnNbeF1bMV07XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaW5zZXJ0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBkZWxldGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBsZXZlbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpLCBpbnNlcnRpb25zID0gMCwgZGVsZXRpb25zID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVuICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyksIGxldmVuO1xufVxuZnVuY3Rpb24geEluZGV4KGRpZmZzLCBsb2MpIHtcbiAgbGV0IGNoYXJzMSA9IDAsIGNoYXJzMiA9IDAsIGxhc3RDaGFyczEgPSAwLCBsYXN0Q2hhcnMyID0gMCwgeDtcbiAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aCAmJiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmIChjaGFyczEgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoKSwgZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFICYmIChjaGFyczIgKz0gZGlmZnNbeF1bMV0ubGVuZ3RoKSwgIShjaGFyczEgPiBsb2MpKTsgeCsrKSBsYXN0Q2hhcnMxID0gY2hhcnMxLCBsYXN0Q2hhcnMyID0gY2hhcnMyO1xuICByZXR1cm4gZGlmZnMubGVuZ3RoICE9PSB4ICYmIGRpZmZzW3hdWzBdID09PSBESUZGX0RFTEVURSA/IGxhc3RDaGFyczIgOiBsYXN0Q2hhcnMyICsgKGxvYyAtIGxhc3RDaGFyczEpO1xufVxuZnVuY3Rpb24gY291bnRVdGY4Qnl0ZXMoc3RyKSB7XG4gIGxldCBieXRlcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgIGlmICh0eXBlb2YgY29kZVBvaW50ID4gXCJ1XCIpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgY29kZXBvaW50XCIpO1xuICAgIGJ5dGVzICs9IHV0ZjhsZW4oY29kZVBvaW50KTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCBiYXNlLCBvcHRpb25zID0ge30pIHtcbiAgbGV0IGJ5dGVPZmZzZXQgPSAwLCBpZHggPSAwO1xuICBmdW5jdGlvbiBhZHZhbmNlVG8odGFyZ2V0KSB7XG4gICAgZm9yICg7IGJ5dGVPZmZzZXQgPCB0YXJnZXQ7ICkge1xuICAgICAgY29uc3QgY29kZVBvaW50ID0gYmFzZS5jb2RlUG9pbnRBdChpZHgpO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlUG9pbnQgPiBcInVcIikgcmV0dXJuIGlkeDtcbiAgICAgIGJ5dGVPZmZzZXQgKz0gdXRmOGxlbihjb2RlUG9pbnQpLCBjb2RlUG9pbnQgPiA2NTUzNSA/IGlkeCArPSAyIDogaWR4ICs9IDE7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5hbGxvd0V4Y2VlZGluZ0luZGljZXMgJiYgYnl0ZU9mZnNldCAhPT0gdGFyZ2V0KSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGV0ZXJtaW5lIGJ5dGUgb2Zmc2V0XCIpO1xuICAgIHJldHVybiBpZHg7XG4gIH1cbiAgY29uc3QgYWRqdXN0ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKSBhZGp1c3RlZC5wdXNoKHtcbiAgICBkaWZmczogcGF0Y2guZGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSksXG4gICAgc3RhcnQxOiBhZHZhbmNlVG8ocGF0Y2guc3RhcnQxKSxcbiAgICBzdGFydDI6IGFkdmFuY2VUbyhwYXRjaC5zdGFydDIpLFxuICAgIHV0ZjhTdGFydDE6IHBhdGNoLnV0ZjhTdGFydDEsXG4gICAgdXRmOFN0YXJ0MjogcGF0Y2gudXRmOFN0YXJ0MixcbiAgICBsZW5ndGgxOiBwYXRjaC5sZW5ndGgxLFxuICAgIGxlbmd0aDI6IHBhdGNoLmxlbmd0aDIsXG4gICAgdXRmOExlbmd0aDE6IHBhdGNoLnV0ZjhMZW5ndGgxLFxuICAgIHV0ZjhMZW5ndGgyOiBwYXRjaC51dGY4TGVuZ3RoMlxuICB9KTtcbiAgcmV0dXJuIGFkanVzdGVkO1xufVxuZnVuY3Rpb24gdXRmOGxlbihjb2RlUG9pbnQpIHtcbiAgcmV0dXJuIGNvZGVQb2ludCA8PSAxMjcgPyAxIDogY29kZVBvaW50IDw9IDIwNDcgPyAyIDogY29kZVBvaW50IDw9IDY1NTM1ID8gMyA6IDQ7XG59XG5jb25zdCBNQVhfQklUUyA9IDMyLCBERUZBVUxUX01BUkdJTiA9IDQ7XG5mdW5jdGlvbiBhZGRQYWRkaW5nKHBhdGNoZXMsIG1hcmdpbiA9IERFRkFVTFRfTUFSR0lOKSB7XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSBtYXJnaW47XG4gIGxldCBudWxsUGFkZGluZyA9IFwiXCI7XG4gIGZvciAobGV0IHggPSAxOyB4IDw9IHBhZGRpbmdMZW5ndGg7IHgrKykgbnVsbFBhZGRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgZm9yIChjb25zdCBwIG9mIHBhdGNoZXMpIHAuc3RhcnQxICs9IHBhZGRpbmdMZW5ndGgsIHAuc3RhcnQyICs9IHBhZGRpbmdMZW5ndGgsIHAudXRmOFN0YXJ0MSArPSBwYWRkaW5nTGVuZ3RoLCBwLnV0ZjhTdGFydDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgbGV0IHBhdGNoID0gcGF0Y2hlc1swXSwgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCB8fCBkaWZmc1swXVswXSAhPT0gRElGRl9FUVVBTCkgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKSwgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDIgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBhZGRpbmdMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1swXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBmaXJzdERpZmZMZW5ndGggPSBkaWZmc1swXVsxXS5sZW5ndGgsIGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGZpcnN0RGlmZkxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhmaXJzdERpZmZMZW5ndGgpICsgZGlmZnNbMF1bMV0sIHBhdGNoLnN0YXJ0MSAtPSBleHRyYUxlbmd0aCwgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQxIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQyIC09IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC5sZW5ndGgyICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgaWYgKHBhdGNoID0gcGF0Y2hlc1twYXRjaGVzLmxlbmd0aCAtIDFdLCBkaWZmcyA9IHBhdGNoLmRpZmZzLCBkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT09IERJRkZfRVFVQUwpIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSksIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xuICBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XG4gICAgY29uc3QgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdICs9IG51bGxQYWRkaW5nLnN1YnN0cmluZygwLCBleHRyYUxlbmd0aCksIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuICByZXR1cm4gbnVsbFBhZGRpbmc7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaE9iamVjdChzdGFydDEsIHN0YXJ0Mikge1xuICByZXR1cm4ge1xuICAgIGRpZmZzOiBbXSxcbiAgICBzdGFydDEsXG4gICAgc3RhcnQyLFxuICAgIHV0ZjhTdGFydDE6IHN0YXJ0MSxcbiAgICB1dGY4U3RhcnQyOiBzdGFydDIsXG4gICAgbGVuZ3RoMTogMCxcbiAgICBsZW5ndGgyOiAwLFxuICAgIHV0ZjhMZW5ndGgxOiAwLFxuICAgIHV0ZjhMZW5ndGgyOiAwXG4gIH07XG59XG5mdW5jdGlvbiBzcGxpdE1heChwYXRjaGVzLCBtYXJnaW4gPSBERUZBVUxUX01BUkdJTikge1xuICBjb25zdCBwYXRjaFNpemUgPSBNQVhfQklUUztcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA8PSBwYXRjaFNpemUpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcbiAgICBwYXRjaGVzLnNwbGljZSh4LS0sIDEpO1xuICAgIGxldCBzdGFydDEgPSBiaWdwYXRjaC5zdGFydDEsIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MiwgcHJlQ29udGV4dCA9IFwiXCI7XG4gICAgZm9yICg7IGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMDsgKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoT2JqZWN0KHN0YXJ0MSAtIHByZUNvbnRleHQubGVuZ3RoLCBzdGFydDIgLSBwcmVDb250ZXh0Lmxlbmd0aCk7XG4gICAgICBsZXQgZW1wdHkgPSAhMDtcbiAgICAgIGlmIChwcmVDb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIGNvbnN0IHByZWNvbnRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhwcmVDb250ZXh0KTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSA9IHByZUNvbnRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSA9IHByZWNvbnRleHRCeXRlQ291bnQsIHBhdGNoLmxlbmd0aDIgPSBwcmVDb250ZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgPSBwcmVjb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwcmVDb250ZXh0XSk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmxlbmd0aDEgPCBwYXRjaFNpemUgLSBtYXJnaW47ICkge1xuICAgICAgICBjb25zdCBkaWZmVHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICBsZXQgZGlmZlRleHQgPSBiaWdwYXRjaC5kaWZmc1swXVsxXSwgZGlmZlRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhkaWZmVGV4dCk7XG4gICAgICAgIGlmIChkaWZmVHlwZSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGlmZjIgPSBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIGRpZmYyICYmIHBhdGNoLmRpZmZzLnB1c2goZGlmZjIpLCBlbXB0eSA9ICExO1xuICAgICAgICB9IGVsc2UgZGlmZlR5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PT0gMSAmJiBwYXRjaC5kaWZmc1swXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmVGV4dC5sZW5ndGggPiAyICogcGF0Y2hTaXplID8gKHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQxICs9IGRpZmZUZXh0Lmxlbmd0aCwgZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpIDogKGRpZmZUZXh0ID0gZGlmZlRleHQuc3Vic3RyaW5nKDAsIHBhdGNoU2l6ZSAtIHBhdGNoLmxlbmd0aDEgLSBtYXJnaW4pLCBkaWZmVGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKGRpZmZUZXh0KSwgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDEgKz0gZGlmZlRleHQubGVuZ3RoLCBkaWZmVHlwZSA9PT0gRElGRl9FUVVBTCA/IChwYXRjaC5sZW5ndGgyICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MiArPSBkaWZmVGV4dC5sZW5ndGgpIDogZW1wdHkgPSAhMSwgcGF0Y2guZGlmZnMucHVzaChbZGlmZlR5cGUsIGRpZmZUZXh0XSksIGRpZmZUZXh0ID09PSBiaWdwYXRjaC5kaWZmc1swXVsxXSA/IGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkgOiBiaWdwYXRjaC5kaWZmc1swXVsxXSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmVGV4dC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHByZUNvbnRleHQgPSBkaWZmVGV4dDIocGF0Y2guZGlmZnMpLCBwcmVDb250ZXh0ID0gcHJlQ29udGV4dC5zdWJzdHJpbmcocHJlQ29udGV4dC5sZW5ndGggLSBtYXJnaW4pO1xuICAgICAgY29uc3QgcG9zdENvbnRleHQgPSBkaWZmVGV4dDEoYmlncGF0Y2guZGlmZnMpLnN1YnN0cmluZygwLCBtYXJnaW4pLCBwb3N0Q29udGV4dEJ5dGVDb3VudCA9IGNvdW50VXRmOEJ5dGVzKHBvc3RDb250ZXh0KTtcbiAgICAgIHBvc3RDb250ZXh0ICE9PSBcIlwiICYmIChwYXRjaC5sZW5ndGgxICs9IHBvc3RDb250ZXh0Lmxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Q29udGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHBvc3RDb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwb3N0Q29udGV4dEJ5dGVDb3VudCwgcGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdENvbnRleHQgOiBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBwb3N0Q29udGV4dF0pKSwgZW1wdHkgfHwgcGF0Y2hlcy5zcGxpY2UoKyt4LCAwLCBwYXRjaCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhcHBseShwYXRjaGVzLCBvcmlnaW5hbFRleHQsIG9wdHMgPSB7fSkge1xuICBpZiAodHlwZW9mIHBhdGNoZXMgPT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiUGF0Y2hlcyBtdXN0IGJlIGFuIGFycmF5IC0gcGFzcyB0aGUgcGF0Y2ggdG8gYHBhcnNlUGF0Y2goKWAgZmlyc3RcIik7XG4gIGxldCB0ZXh0ID0gb3JpZ2luYWxUZXh0O1xuICBpZiAocGF0Y2hlcy5sZW5ndGggPT09IDApIHJldHVybiBbdGV4dCwgW11dO1xuICBjb25zdCBwYXJzZWQgPSBhZGp1c3RJbmRpY2llc1RvVWNzMihwYXRjaGVzLCB0ZXh0LCB7XG4gICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiBvcHRzLmFsbG93RXhjZWVkaW5nSW5kaWNlc1xuICB9KSwgbWFyZ2luID0gb3B0cy5tYXJnaW4gfHwgREVGQVVMVF9NQVJHSU4sIGRlbGV0ZVRocmVzaG9sZCA9IG9wdHMuZGVsZXRlVGhyZXNob2xkIHx8IDAuNCwgbnVsbFBhZGRpbmcgPSBhZGRQYWRkaW5nKHBhcnNlZCwgbWFyZ2luKTtcbiAgdGV4dCA9IG51bGxQYWRkaW5nICsgdGV4dCArIG51bGxQYWRkaW5nLCBzcGxpdE1heChwYXJzZWQsIG1hcmdpbik7XG4gIGxldCBkZWx0YSA9IDA7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXJzZWQubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBleHBlY3RlZExvYyA9IHBhcnNlZFt4XS5zdGFydDIgKyBkZWx0YSwgdGV4dDEgPSBkaWZmVGV4dDEocGFyc2VkW3hdLmRpZmZzKTtcbiAgICBsZXQgc3RhcnRMb2MsIGVuZExvYyA9IC0xO1xuICAgIGlmICh0ZXh0MS5sZW5ndGggPiBNQVhfQklUUyA/IChzdGFydExvYyA9IG1hdGNoKHRleHQsIHRleHQxLnN1YnN0cmluZygwLCBNQVhfQklUUyksIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgIT09IC0xICYmIChlbmRMb2MgPSBtYXRjaCh0ZXh0LCB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gTUFYX0JJVFMpLCBleHBlY3RlZExvYyArIHRleHQxLmxlbmd0aCAtIE1BWF9CSVRTKSwgKGVuZExvYyA9PT0gLTEgfHwgc3RhcnRMb2MgPj0gZW5kTG9jKSAmJiAoc3RhcnRMb2MgPSAtMSkpKSA6IHN0YXJ0TG9jID0gbWF0Y2godGV4dCwgdGV4dDEsIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgPT09IC0xKSByZXN1bHRzW3hdID0gITEsIGRlbHRhIC09IHBhcnNlZFt4XS5sZW5ndGgyIC0gcGFyc2VkW3hdLmxlbmd0aDE7XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHRzW3hdID0gITAsIGRlbHRhID0gc3RhcnRMb2MgLSBleHBlY3RlZExvYztcbiAgICAgIGxldCB0ZXh0MjtcbiAgICAgIGlmIChlbmRMb2MgPT09IC0xID8gdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgc3RhcnRMb2MgKyB0ZXh0MS5sZW5ndGgpIDogdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydExvYywgZW5kTG9jICsgTUFYX0JJVFMpLCB0ZXh0MSA9PT0gdGV4dDIpIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydExvYykgKyBkaWZmVGV4dDIocGFyc2VkW3hdLmRpZmZzKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgdGV4dDEubGVuZ3RoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgZGlmZnMgPSBkaWZmKHRleHQxLCB0ZXh0Miwge1xuICAgICAgICAgIGNoZWNrTGluZXM6ICExXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGV4dDEubGVuZ3RoID4gTUFYX0JJVFMgJiYgbGV2ZW5zaHRlaW4oZGlmZnMpIC8gdGV4dDEubGVuZ3RoID4gZGVsZXRlVGhyZXNob2xkKSByZXN1bHRzW3hdID0gITE7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRpZmZzID0gY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICAgICAgICAgIGxldCBpbmRleDEgPSAwLCBpbmRleDIgPSAwO1xuICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcGFyc2VkW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSBwYXJzZWRbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBtb2RbMF0gIT09IERJRkZfRVFVQUwgJiYgKGluZGV4MiA9IHhJbmRleChkaWZmcywgaW5kZXgxKSksIG1vZFswXSA9PT0gRElGRl9JTlNFUlQgPyB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRMb2MgKyBpbmRleDIpICsgbW9kWzFdICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MgKyBpbmRleDIpIDogbW9kWzBdID09PSBESUZGX0RFTEVURSAmJiAodGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgeEluZGV4KGRpZmZzLCBpbmRleDEgKyBtb2RbMV0ubGVuZ3RoKSkpLCBtb2RbMF0gIT09IERJRkZfREVMRVRFICYmIChpbmRleDEgKz0gbW9kWzFdLmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCksIFt0ZXh0LCByZXN1bHRzXTtcbn1cbmNvbnN0IHBhdGNoSGVhZGVyID0gL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLztcbmZ1bmN0aW9uIHBhcnNlKHRleHRsaW5lKSB7XG4gIGlmICghdGV4dGxpbmUpIHJldHVybiBbXTtcbiAgY29uc3QgcGF0Y2hlcyA9IFtdLCBsaW5lcyA9IHRleHRsaW5lLnNwbGl0KGBcbmApO1xuICBsZXQgdGV4dFBvaW50ZXIgPSAwO1xuICBmb3IgKDsgdGV4dFBvaW50ZXIgPCBsaW5lcy5sZW5ndGg7ICkge1xuICAgIGNvbnN0IG0gPSBsaW5lc1t0ZXh0UG9pbnRlcl0ubWF0Y2gocGF0Y2hIZWFkZXIpO1xuICAgIGlmICghbSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIHN0cmluZzogJHtsaW5lc1t0ZXh0UG9pbnRlcl19YCk7XG4gICAgY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdCh0b0ludChtWzFdKSwgdG9JbnQobVszXSkpO1xuICAgIGZvciAocGF0Y2hlcy5wdXNoKHBhdGNoKSwgbVsyXSA9PT0gXCJcIiA/IChwYXRjaC5zdGFydDEtLSwgcGF0Y2gudXRmOFN0YXJ0MS0tLCBwYXRjaC5sZW5ndGgxID0gMSwgcGF0Y2gudXRmOExlbmd0aDEgPSAxKSA6IG1bMl0gPT09IFwiMFwiID8gKHBhdGNoLmxlbmd0aDEgPSAwLCBwYXRjaC51dGY4TGVuZ3RoMSA9IDApIDogKHBhdGNoLnN0YXJ0MS0tLCBwYXRjaC51dGY4U3RhcnQxLS0sIHBhdGNoLnV0ZjhMZW5ndGgxID0gdG9JbnQobVsyXSksIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC51dGY4TGVuZ3RoMSksIG1bNF0gPT09IFwiXCIgPyAocGF0Y2guc3RhcnQyLS0sIHBhdGNoLnV0ZjhTdGFydDItLSwgcGF0Y2gubGVuZ3RoMiA9IDEsIHBhdGNoLnV0ZjhMZW5ndGgyID0gMSkgOiBtWzRdID09PSBcIjBcIiA/IChwYXRjaC5sZW5ndGgyID0gMCwgcGF0Y2gudXRmOExlbmd0aDIgPSAwKSA6IChwYXRjaC5zdGFydDItLSwgcGF0Y2gudXRmOFN0YXJ0Mi0tLCBwYXRjaC51dGY4TGVuZ3RoMiA9IHRvSW50KG1bNF0pLCBwYXRjaC5sZW5ndGgyID0gcGF0Y2gudXRmOExlbmd0aDIpLCB0ZXh0UG9pbnRlcisrOyB0ZXh0UG9pbnRlciA8IGxpbmVzLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBjdXJyZW50TGluZSA9IGxpbmVzW3RleHRQb2ludGVyXSwgc2lnbiA9IGN1cnJlbnRMaW5lLmNoYXJBdCgwKTtcbiAgICAgIGlmIChzaWduID09PSBcIkBcIikgYnJlYWs7XG4gICAgICBpZiAoc2lnbiA9PT0gXCJcIikge1xuICAgICAgICB0ZXh0UG9pbnRlcisrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGluZSA9IGRlY29kZVVSSShjdXJyZW50TGluZS5zbGljZSgxKSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIGVzY2FwZSBpbiBwYXJzZTogJHtjdXJyZW50TGluZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHV0ZjhEaWZmID0gY291bnRVdGY4Qnl0ZXMobGluZSkgLSBsaW5lLmxlbmd0aDtcbiAgICAgIGlmIChzaWduID09PSBcIi1cIikgcGF0Y2guZGlmZnMucHVzaChbRElGRl9ERUxFVEUsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMSAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgaWYgKHNpZ24gPT09IFwiK1wiKSBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0lOU0VSVCwgbGluZV0pLCBwYXRjaC5sZW5ndGgyIC09IHV0ZjhEaWZmO1xuICAgICAgZWxzZSBpZiAoc2lnbiA9PT0gXCIgXCIpIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGxpbmVdKSwgcGF0Y2gubGVuZ3RoMSAtPSB1dGY4RGlmZiwgcGF0Y2gubGVuZ3RoMiAtPSB1dGY4RGlmZjtcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIG1vZGUgXCIke3NpZ259XCIgaW46ICR7bGluZX1gKTtcbiAgICAgIHRleHRQb2ludGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gdG9JbnQobnVtKSB7XG4gIHJldHVybiBwYXJzZUludChudW0sIDEwKTtcbn1cbmNvbnN0IElTX1VET0lORyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBJU19SRURPSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiB3aXRoVW5kb2luZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1VuZG9pbmcoZWRpdG9yKTtcbiAgSVNfVURPSU5HLnNldChlZGl0b3IsICEwKSwgZm4oKSwgSVNfVURPSU5HLnNldChlZGl0b3IsIHByZXYpO1xufVxuZnVuY3Rpb24gaXNVbmRvaW5nKGVkaXRvcikge1xuICByZXR1cm4gSVNfVURPSU5HLmdldChlZGl0b3IpID8/ICExO1xufVxuZnVuY3Rpb24gc2V0SXNVbmRvaW5nKGVkaXRvciwgaXNVbmRvaW5nMikge1xuICBJU19VRE9JTkcuc2V0KGVkaXRvciwgaXNVbmRvaW5nMik7XG59XG5mdW5jdGlvbiB3aXRoUmVkb2luZyhlZGl0b3IsIGZuKSB7XG4gIGNvbnN0IHByZXYgPSBpc1JlZG9pbmcoZWRpdG9yKTtcbiAgSVNfUkVET0lORy5zZXQoZWRpdG9yLCAhMCksIGZuKCksIElTX1JFRE9JTkcuc2V0KGVkaXRvciwgcHJldik7XG59XG5mdW5jdGlvbiBpc1JlZG9pbmcoZWRpdG9yKSB7XG4gIHJldHVybiBJU19SRURPSU5HLmdldChlZGl0b3IpID8/ICExO1xufVxuZnVuY3Rpb24gc2V0SXNSZWRvaW5nKGVkaXRvciwgaXNSZWRvaW5nMikge1xuICBJU19SRURPSU5HLnNldChlZGl0b3IsIGlzUmVkb2luZzIpO1xufVxuY29uc3QgZGVidWckaiA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFVuZG9SZWRvXCIpLCBkZWJ1Z1ZlcmJvc2UkMyA9IGRlYnVnJGouZW5hYmxlZCAmJiAhMSwgU0FWSU5HID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFJFTU9URV9QQVRDSEVTID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIFVORE9fU1RFUF9MSU1JVCA9IDFlMywgaXNTYXZpbmcgPSAoZWRpdG9yKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gU0FWSU5HLmdldChlZGl0b3IpO1xuICByZXR1cm4gc3RhdGUgPT09IHZvaWQgMCA/ICEwIDogc3RhdGU7XG59LCBnZXRSZW1vdGVQYXRjaGVzID0gKGVkaXRvcikgPT4gKFJFTU9URV9QQVRDSEVTLmdldChlZGl0b3IpIHx8IFJFTU9URV9QQVRDSEVTLnNldChlZGl0b3IsIFtdKSwgUkVNT1RFX1BBVENIRVMuZ2V0KGVkaXRvcikgfHwgW10pO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFVuZG9SZWRvKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIGJsb2NrU2NoZW1hVHlwZVxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIChlZGl0b3IpID0+IHtcbiAgICBsZXQgcHJldmlvdXNTbmFwc2hvdCA9IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgYmxvY2tTY2hlbWFUeXBlLm5hbWUpO1xuICAgIGNvbnN0IHJlbW90ZVBhdGNoZXMgPSBnZXRSZW1vdGVQYXRjaGVzKGVkaXRvcik7XG4gICAgb3B0aW9ucy5zdWJzY3JpcHRpb25zLnB1c2goKCkgPT4ge1xuICAgICAgZGVidWckaihcIlN1YnNjcmliaW5nIHRvIHBhdGNoZXNcIik7XG4gICAgICBjb25zdCBzdWIgPSBlZGl0b3JBY3Rvci5vbihcInBhdGNoZXNcIiwgKHtcbiAgICAgICAgcGF0Y2hlcyxcbiAgICAgICAgc25hcHNob3RcbiAgICAgIH0pID0+IHtcbiAgICAgICAgbGV0IHJlc2V0ID0gITE7XG4gICAgICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc2V0ICYmIHBhdGNoLm9yaWdpbiAhPT0gXCJsb2NhbFwiICYmIHJlbW90ZVBhdGNoZXMpIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZGVidWckaihcIlNvbWVvbmUgZWxzZSBjbGVhcmVkIHRoZSBjb250ZW50LCByZXNldHRpbmcgdW5kby9yZWRvIGhpc3RvcnlcIiksIGVkaXRvci5oaXN0b3J5ID0ge1xuICAgICAgICAgICAgICAgIHVuZG9zOiBbXSxcbiAgICAgICAgICAgICAgICByZWRvczogW11cbiAgICAgICAgICAgICAgfSwgcmVtb3RlUGF0Y2hlcy5zcGxpY2UoMCwgcmVtb3RlUGF0Y2hlcy5sZW5ndGgpLCBTQVZJTkcuc2V0KGVkaXRvciwgITApLCByZXNldCA9ICEwO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdGVQYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICBwYXRjaCxcbiAgICAgICAgICAgICAgdGltZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIHNuYXBzaG90LFxuICAgICAgICAgICAgICBwcmV2aW91c1NuYXBzaG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBwcmV2aW91c1NuYXBzaG90ID0gc25hcHNob3Q7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlYnVnJGooXCJVbnN1YnNjcmliaW5nIHRvIHBhdGNoZXNcIiksIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9KSwgZWRpdG9yLmhpc3RvcnkgPSB7XG4gICAgICB1bmRvczogW10sXG4gICAgICByZWRvczogW11cbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgICAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gICAgICB9KSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5kb2luZyhlZGl0b3IpIHx8IGlzUmVkb2luZyhlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3BlcmF0aW9ucyxcbiAgICAgICAgaGlzdG9yeVxuICAgICAgfSA9IGVkaXRvciwge1xuICAgICAgICB1bmRvc1xuICAgICAgfSA9IGhpc3RvcnksIHN0ZXAgPSB1bmRvc1t1bmRvcy5sZW5ndGggLSAxXSwgbGFzdE9wID0gc3RlcCAmJiBzdGVwLm9wZXJhdGlvbnMgJiYgc3RlcC5vcGVyYXRpb25zW3N0ZXAub3BlcmF0aW9ucy5sZW5ndGggLSAxXSwgb3ZlcndyaXRlID0gc2hvdWxkT3ZlcndyaXRlKG9wLCBsYXN0T3ApLCBzYXZlID0gaXNTYXZpbmcoZWRpdG9yKTtcbiAgICAgIGxldCBtZXJnZSA9ICEwO1xuICAgICAgaWYgKHNhdmUpIHtcbiAgICAgICAgaWYgKHN0ZXAgPyBvcGVyYXRpb25zLmxlbmd0aCA9PT0gMCAmJiAobWVyZ2UgPSBzaG91bGRNZXJnZShvcCwgbGFzdE9wKSB8fCBvdmVyd3JpdGUpIDogbWVyZ2UgPSAhMSwgc3RlcCAmJiBtZXJnZSlcbiAgICAgICAgICBzdGVwLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5ld1N0ZXAgPSB7XG4gICAgICAgICAgICBvcGVyYXRpb25zOiBbLi4uZWRpdG9yLnNlbGVjdGlvbiA9PT0gbnVsbCA/IFtdIDogW2NyZWF0ZVNlbGVjdE9wZXJhdGlvbihlZGl0b3IpXSwgb3BdLFxuICAgICAgICAgICAgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICAgICAgICAgIH07XG4gICAgICAgICAgdW5kb3MucHVzaChuZXdTdGVwKSwgZGVidWckaihcIkNyZWF0ZWQgbmV3IHVuZG8gc3RlcFwiLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgdW5kb3MubGVuZ3RoID4gVU5ET19TVEVQX0xJTUlUOyApXG4gICAgICAgICAgdW5kb3Muc2hpZnQoKTtcbiAgICAgICAgc2hvdWxkQ2xlYXIob3ApICYmIChoaXN0b3J5LnJlZG9zID0gW10pO1xuICAgICAgfVxuICAgICAgYXBwbHkyKG9wKTtcbiAgICB9LCBlZGl0b3IudW5kbyA9ICgpID0+IHtcbiAgICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgICAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gICAgICB9KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qge1xuICAgICAgICB1bmRvc1xuICAgICAgfSA9IGVkaXRvci5oaXN0b3J5O1xuICAgICAgaWYgKHVuZG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHVuZG9zW3VuZG9zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZGVidWckaihcIlVuZG9pbmdcIiwgc3RlcCksIHN0ZXAub3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgb3RoZXJQYXRjaGVzID0gcmVtb3RlUGF0Y2hlcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udGltZSA+PSBzdGVwLnRpbWVzdGFtcCk7XG4gICAgICAgICAgbGV0IHRyYW5zZm9ybWVkT3BlcmF0aW9ucyA9IHN0ZXAub3BlcmF0aW9ucztcbiAgICAgICAgICBvdGhlclBhdGNoZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRPcGVyYXRpb25zID0gZmxhdHRlbih0cmFuc2Zvcm1lZE9wZXJhdGlvbnMubWFwKChvcCkgPT4gdHJhbnNmb3JtT3BlcmF0aW9uKGVkaXRvciwgaXRlbS5wYXRjaCwgb3AsIGl0ZW0uc25hcHNob3QsIGl0ZW0ucHJldmlvdXNTbmFwc2hvdCkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCByZXZlcnNlZE9wZXJhdGlvbnMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMubWFwKE9wZXJhdGlvbi5pbnZlcnNlKS5yZXZlcnNlKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHdpdGhVbmRvaW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXZlcnNlZE9wZXJhdGlvbnMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmFwcGx5KG9wKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLCBlZGl0b3Iubm9ybWFsaXplKCksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVidWckaihcIkNvdWxkIG5vdCBwZXJmb3JtIHVuZG8gc3RlcFwiLCBlcnIpLCByZW1vdGVQYXRjaGVzLnNwbGljZSgwLCByZW1vdGVQYXRjaGVzLmxlbmd0aCksIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKSwgZWRpdG9yLmhpc3RvcnkgPSB7XG4gICAgICAgICAgICAgIHVuZG9zOiBbXSxcbiAgICAgICAgICAgICAgcmVkb3M6IFtdXG4gICAgICAgICAgICB9LCBTQVZJTkcuc2V0KGVkaXRvciwgITApLCBzZXRJc1VuZG9pbmcoZWRpdG9yLCAhMSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlZGl0b3IuaGlzdG9yeS5yZWRvcy5wdXNoKHN0ZXApLCBlZGl0b3IuaGlzdG9yeS51bmRvcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGVkaXRvci5yZWRvID0gKCkgPT4ge1xuICAgICAgaWYgKGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICAgIFwiZWRpdCBtb2RlXCI6IFwicmVhZCBvbmx5XCJcbiAgICAgIH0pKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlZG9zXG4gICAgICB9ID0gZWRpdG9yLmhpc3Rvcnk7XG4gICAgICBpZiAocmVkb3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBzdGVwID0gcmVkb3NbcmVkb3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkZWJ1ZyRqKFwiUmVkb2luZ1wiLCBzdGVwKSwgc3RlcC5vcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBvdGhlclBhdGNoZXMgPSByZW1vdGVQYXRjaGVzLmZpbHRlcigoaXRlbSkgPT4gaXRlbS50aW1lID49IHN0ZXAudGltZXN0YW1wKTtcbiAgICAgICAgICBsZXQgdHJhbnNmb3JtZWRPcGVyYXRpb25zID0gc3RlcC5vcGVyYXRpb25zO1xuICAgICAgICAgIG90aGVyUGF0Y2hlcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZE9wZXJhdGlvbnMgPSBmbGF0dGVuKHRyYW5zZm9ybWVkT3BlcmF0aW9ucy5tYXAoKG9wKSA9PiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBpdGVtLnBhdGNoLCBvcCwgaXRlbS5zbmFwc2hvdCwgaXRlbS5wcmV2aW91c1NuYXBzaG90KSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICB3aXRoUmVkb2luZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgICB3aXRob3V0U2F2aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRPcGVyYXRpb25zLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5hcHBseShvcCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSwgZWRpdG9yLm5vcm1hbGl6ZSgpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlYnVnJGooXCJDb3VsZCBub3QgcGVyZm9ybSByZWRvIHN0ZXBcIiwgZXJyKSwgcmVtb3RlUGF0Y2hlcy5zcGxpY2UoMCwgcmVtb3RlUGF0Y2hlcy5sZW5ndGgpLCBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvciksIGVkaXRvci5oaXN0b3J5ID0ge1xuICAgICAgICAgICAgICB1bmRvczogW10sXG4gICAgICAgICAgICAgIHJlZG9zOiBbXVxuICAgICAgICAgICAgfSwgU0FWSU5HLnNldChlZGl0b3IsICEwKSwgc2V0SXNSZWRvaW5nKGVkaXRvciwgITEpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLmhpc3RvcnkudW5kb3MucHVzaChzdGVwKSwgZWRpdG9yLmhpc3RvcnkucmVkb3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1PcGVyYXRpb24oZWRpdG9yLCBwYXRjaCwgb3BlcmF0aW9uLCBzbmFwc2hvdCwgcHJldmlvdXNTbmFwc2hvdCkge1xuICBkZWJ1Z1ZlcmJvc2UkMyAmJiAoZGVidWckaihgQWRqdXN0aW5nICcke29wZXJhdGlvbi50eXBlfScgb3BlcmF0aW9uIHBhdGhzIGZvciAnJHtwYXRjaC50eXBlfScgcGF0Y2hgKSwgZGVidWckaihgT3BlcmF0aW9uICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uKX1gKSwgZGVidWckaihgUGF0Y2ggJHtKU09OLnN0cmluZ2lmeShwYXRjaCl9YCkpO1xuICBjb25zdCB0cmFuc2Zvcm1lZE9wZXJhdGlvbiA9IHtcbiAgICAuLi5vcGVyYXRpb25cbiAgfTtcbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwiaW5zZXJ0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBpbnNlcnRCbG9ja0luZGV4ID0gKHNuYXBzaG90IHx8IFtdKS5maW5kSW5kZXgoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgICBfa2V5OiBibGsuX2tleVxuICAgIH0sIHBhdGNoLnBhdGhbMF0pKTtcbiAgICByZXR1cm4gZGVidWckaihgQWRqdXN0aW5nIGJsb2NrIHBhdGggKCske3BhdGNoLml0ZW1zLmxlbmd0aH0pIGZvciAnJHt0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlfScgb3BlcmF0aW9uIGFuZCBwYXRjaCAnJHtwYXRjaC50eXBlfSdgKSwgW2FkanVzdEJsb2NrUGF0aCh0cmFuc2Zvcm1lZE9wZXJhdGlvbiwgcGF0Y2guaXRlbXMubGVuZ3RoLCBpbnNlcnRCbG9ja0luZGV4KV07XG4gIH1cbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHVuc2V0QmxvY2tJbmRleCA9IChwcmV2aW91c1NuYXBzaG90IHx8IFtdKS5maW5kSW5kZXgoKGJsaykgPT4gaXNFcXVhbCh7XG4gICAgICBfa2V5OiBibGsuX2tleVxuICAgIH0sIHBhdGNoLnBhdGhbMF0pKTtcbiAgICByZXR1cm4gXCJwYXRoXCIgaW4gdHJhbnNmb3JtZWRPcGVyYXRpb24gJiYgQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoKSAmJiB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wYXRoWzBdID09PSB1bnNldEJsb2NrSW5kZXggPyAoZGVidWckaihcIlNraXBwaW5nIHRyYW5zZm9ybWF0aW9uIHRoYXQgdGFyZ2V0ZWQgcmVtb3ZlZCBibG9ja1wiKSwgW10pIDogKGRlYnVnVmVyYm9zZSQzICYmIChkZWJ1ZyRqKGBTZWxlY3Rpb24gJHtKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uKX1gKSwgZGVidWckaihgQWRqdXN0aW5nIGJsb2NrIHBhdGggKC0xKSBmb3IgJyR7dHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZX0nIG9wZXJhdGlvbiBhbmQgcGF0Y2ggJyR7cGF0Y2gudHlwZX0nYCkpLCBbYWRqdXN0QmxvY2tQYXRoKHRyYW5zZm9ybWVkT3BlcmF0aW9uLCAtMSwgdW5zZXRCbG9ja0luZGV4KV0pO1xuICB9XG4gIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIgJiYgcGF0Y2gucGF0aC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGRlYnVnJGooYEFkanVzdGluZyBzZWxlY3Rpb24gZm9yIHVuc2V0IGV2ZXJ5dGhpbmcgcGF0Y2ggYW5kICR7b3BlcmF0aW9uLnR5cGV9IG9wZXJhdGlvbmApLCBbXTtcbiAgaWYgKHBhdGNoLnR5cGUgPT09IFwiZGlmZk1hdGNoUGF0Y2hcIikge1xuICAgIGNvbnN0IG9wZXJhdGlvblRhcmdldEJsb2NrID0gZmluZE9wZXJhdGlvblRhcmdldEJsb2NrKGVkaXRvciwgdHJhbnNmb3JtZWRPcGVyYXRpb24pO1xuICAgIHJldHVybiAhb3BlcmF0aW9uVGFyZ2V0QmxvY2sgfHwgIWlzRXF1YWwoe1xuICAgICAgX2tleTogb3BlcmF0aW9uVGFyZ2V0QmxvY2suX2tleVxuICAgIH0sIHBhdGNoLnBhdGhbMF0pID8gW3RyYW5zZm9ybWVkT3BlcmF0aW9uXSA6IChwYXJzZShwYXRjaC52YWx1ZSkuZm9yRWFjaCgoZGlmZlBhdGNoKSA9PiB7XG4gICAgICBsZXQgYWRqdXN0T2Zmc2V0QnkgPSAwLCBjaGFuZ2VkT2Zmc2V0ID0gZGlmZlBhdGNoLnV0ZjhTdGFydDE7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpZmZzXG4gICAgICB9ID0gZGlmZlBhdGNoO1xuICAgICAgaWYgKGRpZmZzLmZvckVhY2goKGRpZmYyLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBbZGlmZlR5cGUsIHRleHRdID0gZGlmZjI7XG4gICAgICAgIGRpZmZUeXBlID09PSBESUZGX0lOU0VSVCA/IChhZGp1c3RPZmZzZXRCeSArPSB0ZXh0Lmxlbmd0aCwgY2hhbmdlZE9mZnNldCArPSB0ZXh0Lmxlbmd0aCkgOiBkaWZmVHlwZSA9PT0gRElGRl9ERUxFVEUgPyAoYWRqdXN0T2Zmc2V0QnkgLT0gdGV4dC5sZW5ndGgsIGNoYW5nZWRPZmZzZXQgLT0gdGV4dC5sZW5ndGgpIDogZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgKGRpZmZzLnNsaWNlKGluZGV4KS5ldmVyeSgoW2RUeXBlXSkgPT4gZFR5cGUgPT09IERJRkZfRVFVQUwpIHx8IChjaGFuZ2VkT2Zmc2V0ICs9IHRleHQubGVuZ3RoKSk7XG4gICAgICB9KSwgdHJhbnNmb3JtZWRPcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfdGV4dFwiICYmIGNoYW5nZWRPZmZzZXQgPCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCArPSBhZGp1c3RPZmZzZXRCeSksIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwicmVtb3ZlX3RleHRcIiAmJiBjaGFuZ2VkT2Zmc2V0IDw9IHRyYW5zZm9ybWVkT3BlcmF0aW9uLm9mZnNldCAtIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnRleHQubGVuZ3RoICYmICh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5vZmZzZXQgKz0gYWRqdXN0T2Zmc2V0QnkpLCB0cmFuc2Zvcm1lZE9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIikge1xuICAgICAgICBjb25zdCBjdXJyZW50Rm9jdXMgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzPy5mb2N1cyA/IHtcbiAgICAgICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0gOiB2b2lkIDAsIGN1cnJlbnRBbmNob3IgPSB0cmFuc2Zvcm1lZE9wZXJhdGlvbj8ucHJvcGVydGllcz8uYW5jaG9yID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMuYW5jaG9yXG4gICAgICAgIH0gOiB2b2lkIDAsIG5ld0ZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybWVkT3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMuZm9jdXNcbiAgICAgICAgfSA6IHZvaWQgMCwgbmV3QW5jaG9yID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmFuY2hvciA/IHtcbiAgICAgICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmFuY2hvclxuICAgICAgICB9IDogdm9pZCAwO1xuICAgICAgICAoY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgfHwgbmV3Rm9jdXMgJiYgbmV3QW5jaG9yKSAmJiAoW2N1cnJlbnRGb2N1cywgY3VycmVudEFuY2hvciwgbmV3Rm9jdXMsIG5ld0FuY2hvcl0uZm9yRWFjaCgocG9pbnQpID0+IHtcbiAgICAgICAgICBwb2ludCAmJiBjaGFuZ2VkT2Zmc2V0IDwgcG9pbnQub2Zmc2V0ICYmIChwb2ludC5vZmZzZXQgKz0gYWRqdXN0T2Zmc2V0QnkpO1xuICAgICAgICB9KSwgY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgZm9jdXM6IGN1cnJlbnRGb2N1cyxcbiAgICAgICAgICBhbmNob3I6IGN1cnJlbnRBbmNob3JcbiAgICAgICAgfSksIG5ld0ZvY3VzICYmIG5ld0FuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcyA9IHtcbiAgICAgICAgICBmb2N1czogbmV3Rm9jdXMsXG4gICAgICAgICAgYW5jaG9yOiBuZXdBbmNob3JcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pLCBbdHJhbnNmb3JtZWRPcGVyYXRpb25dKTtcbiAgfVxuICByZXR1cm4gW3RyYW5zZm9ybWVkT3BlcmF0aW9uXTtcbn1cbmZ1bmN0aW9uIGFkanVzdEJsb2NrUGF0aChvcGVyYXRpb24sIGxldmVsLCBibG9ja0luZGV4KSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVkT3BlcmF0aW9uID0ge1xuICAgIC4uLm9wZXJhdGlvblxuICB9O1xuICBpZiAoYmxvY2tJbmRleCA+PSAwICYmIHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgIT09IFwic2V0X3NlbGVjdGlvblwiICYmIEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aCkgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSA+PSBibG9ja0luZGV4ICsgbGV2ZWwgJiYgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aFswXSArIGxldmVsID4gLTEpIHtcbiAgICBjb25zdCBuZXdQYXRoID0gW3RyYW5zZm9ybWVkT3BlcmF0aW9uLnBhdGhbMF0gKyBsZXZlbCwgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aC5zbGljZSgxKV07XG4gICAgdHJhbnNmb3JtZWRPcGVyYXRpb24ucGF0aCA9IG5ld1BhdGg7XG4gIH1cbiAgaWYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiKSB7XG4gICAgY29uc3QgY3VycmVudEZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24ucHJvcGVydGllcz8uZm9jdXMgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgfSA6IHZvaWQgMCwgY3VycmVudEFuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5wcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5wcm9wZXJ0aWVzLmFuY2hvclxuICAgIH0gOiB2b2lkIDAsIG5ld0ZvY3VzID0gdHJhbnNmb3JtZWRPcGVyYXRpb24/Lm5ld1Byb3BlcnRpZXM/LmZvY3VzID8ge1xuICAgICAgLi4udHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcy5mb2N1c1xuICAgIH0gOiB2b2lkIDAsIG5ld0FuY2hvciA9IHRyYW5zZm9ybWVkT3BlcmF0aW9uPy5uZXdQcm9wZXJ0aWVzPy5hbmNob3IgPyB7XG4gICAgICAuLi50cmFuc2Zvcm1lZE9wZXJhdGlvbi5uZXdQcm9wZXJ0aWVzLmFuY2hvclxuICAgIH0gOiB2b2lkIDA7XG4gICAgKGN1cnJlbnRGb2N1cyAmJiBjdXJyZW50QW5jaG9yIHx8IG5ld0ZvY3VzICYmIG5ld0FuY2hvcikgJiYgKFtjdXJyZW50Rm9jdXMsIGN1cnJlbnRBbmNob3IsIG5ld0ZvY3VzLCBuZXdBbmNob3JdLmZvckVhY2goKHBvaW50KSA9PiB7XG4gICAgICBwb2ludCAmJiBwb2ludC5wYXRoWzBdID49IGJsb2NrSW5kZXggKyBsZXZlbCAmJiBwb2ludC5wYXRoWzBdICsgbGV2ZWwgPiAtMSAmJiAocG9pbnQucGF0aCA9IFtwb2ludC5wYXRoWzBdICsgbGV2ZWwsIC4uLnBvaW50LnBhdGguc2xpY2UoMSldKTtcbiAgICB9KSwgY3VycmVudEZvY3VzICYmIGN1cnJlbnRBbmNob3IgJiYgKHRyYW5zZm9ybWVkT3BlcmF0aW9uLnByb3BlcnRpZXMgPSB7XG4gICAgICBmb2N1czogY3VycmVudEZvY3VzLFxuICAgICAgYW5jaG9yOiBjdXJyZW50QW5jaG9yXG4gICAgfSksIG5ld0ZvY3VzICYmIG5ld0FuY2hvciAmJiAodHJhbnNmb3JtZWRPcGVyYXRpb24ubmV3UHJvcGVydGllcyA9IHtcbiAgICAgIGZvY3VzOiBuZXdGb2N1cyxcbiAgICAgIGFuY2hvcjogbmV3QW5jaG9yXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1lZE9wZXJhdGlvbjtcbn1cbmNvbnN0IHNob3VsZE1lcmdlID0gKG9wLCBwcmV2KSA9PiAhIShvcC50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiB8fCBwcmV2ICYmIG9wLnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBwcmV2LnR5cGUgPT09IFwiaW5zZXJ0X3RleHRcIiAmJiBvcC5vZmZzZXQgPT09IHByZXYub2Zmc2V0ICsgcHJldi50ZXh0Lmxlbmd0aCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpICYmIG9wLnRleHQgIT09IFwiIFwiIHx8IHByZXYgJiYgb3AudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIHByZXYudHlwZSA9PT0gXCJyZW1vdmVfdGV4dFwiICYmIG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoID09PSBwcmV2Lm9mZnNldCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpKSwgc2hvdWxkT3ZlcndyaXRlID0gKG9wLCBwcmV2KSA9PiAhIShwcmV2ICYmIG9wLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiICYmIHByZXYudHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpLCBzaG91bGRDbGVhciA9IChvcCkgPT4gb3AudHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCI7XG5mdW5jdGlvbiB3aXRob3V0U2F2aW5nKGVkaXRvciwgZm4pIHtcbiAgY29uc3QgcHJldiA9IGlzU2F2aW5nKGVkaXRvcik7XG4gIFNBVklORy5zZXQoZWRpdG9yLCAhMSksIGZuKCksIFNBVklORy5zZXQoZWRpdG9yLCBwcmV2KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdE9wZXJhdGlvbihlZGl0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInNldF9zZWxlY3Rpb25cIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAuLi5lZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSxcbiAgICBuZXdQcm9wZXJ0aWVzOiB7XG4gICAgICAuLi5lZGl0b3Iuc2VsZWN0aW9uXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZE9wZXJhdGlvblRhcmdldEJsb2NrKGVkaXRvciwgb3BlcmF0aW9uKSB7XG4gIGxldCBibG9jaztcbiAgcmV0dXJuIG9wZXJhdGlvbi50eXBlID09PSBcInNldF9zZWxlY3Rpb25cIiAmJiBlZGl0b3Iuc2VsZWN0aW9uID8gYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoWzBdXSA6IFwicGF0aFwiIGluIG9wZXJhdGlvbiAmJiAoYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dKSwgYmxvY2s7XG59XG5jb25zdCBzeW5jVmFsdWVDYWxsYmFjayA9ICh7XG4gIHNlbmRCYWNrLFxuICBpbnB1dFxufSkgPT4ge1xuICB1cGRhdGVWYWx1ZSh7XG4gICAgY29udGV4dDogaW5wdXQuY29udGV4dCxcbiAgICBzZW5kQmFjayxcbiAgICBzbGF0ZUVkaXRvcjogaW5wdXQuc2xhdGVFZGl0b3IsXG4gICAgdmFsdWU6IGlucHV0LnZhbHVlLFxuICAgIHN0cmVhbUJsb2NrczogaW5wdXQuc3RyZWFtQmxvY2tzXG4gIH0pO1xufSwgc3luY1ZhbHVlTG9naWMgPSBmcm9tQ2FsbGJhY2soc3luY1ZhbHVlQ2FsbGJhY2spLCBzeW5jTWFjaGluZSA9IHNldHVwKHtcbiAgdHlwZXM6IHtcbiAgICBjb250ZXh0OiB7fSxcbiAgICBpbnB1dDoge30sXG4gICAgZXZlbnRzOiB7fSxcbiAgICBlbWl0dGVkOiB7fVxuICB9LFxuICBhY3Rpb25zOiB7XG4gICAgXCJhc3NpZ24gaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIjogYXNzaWduKHtcbiAgICAgIGluaXRpYWxWYWx1ZVN5bmNlZDogITBcbiAgICB9KSxcbiAgICBcImFzc2lnbiByZWFkT25seVwiOiBhc3NpZ24oe1xuICAgICAgcmVhZE9ubHk6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwidXBkYXRlIHJlYWRPbmx5XCIpLCBldmVudC5yZWFkT25seSlcbiAgICB9KSxcbiAgICBcImFzc2lnbiBwZW5kaW5nIHZhbHVlXCI6IGFzc2lnbih7XG4gICAgICBwZW5kaW5nVmFsdWU6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwidXBkYXRlIHZhbHVlXCIpLCBldmVudC52YWx1ZSlcbiAgICB9KSxcbiAgICBcImNsZWFyIHBlbmRpbmcgdmFsdWVcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdWYWx1ZTogdm9pZCAwXG4gICAgfSksXG4gICAgXCJhc3NpZ24gcHJldmlvdXMgdmFsdWVcIjogYXNzaWduKHtcbiAgICAgIHByZXZpb3VzVmFsdWU6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwiZG9uZSBzeW5jaW5nXCIpLCBldmVudC52YWx1ZSlcbiAgICB9KSxcbiAgICBcImVtaXQgZG9uZSBzeW5jaW5nIGluaXRpYWwgdmFsdWVcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcImRvbmUgc3luY2luZyBpbml0aWFsIHZhbHVlXCJcbiAgICB9KVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBcImluaXRpYWwgdmFsdWUgc3luY2VkXCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gY29udGV4dC5pbml0aWFsVmFsdWVTeW5jZWQsXG4gICAgXCJpcyBidXN5XCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gIWNvbnRleHQucmVhZE9ubHkgJiYgKGNvbnRleHQuaXNQcm9jZXNzaW5nTG9jYWxDaGFuZ2VzIHx8IChpc0NoYW5naW5nUmVtb3RlbHkoY29udGV4dC5zbGF0ZUVkaXRvcikgPz8gITEpKSxcbiAgICBcInZhbHVlIGNoYW5nZWQgd2hpbGUgc3luY2luZ1wiOiAoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcImRvbmUgc3luY2luZ1wiKSwgY29udGV4dC5wZW5kaW5nVmFsdWUgIT09IGV2ZW50LnZhbHVlKSxcbiAgICBcInBlbmRpbmcgdmFsdWUgZXF1YWxzIHByZXZpb3VzIHZhbHVlXCI6ICh7XG4gICAgICBjb250ZXh0XG4gICAgfSkgPT4gIShjb250ZXh0LnByZXZpb3VzVmFsdWUgPT09IHZvaWQgMCAmJiBjb250ZXh0LnBlbmRpbmdWYWx1ZSA9PT0gdm9pZCAwKSAmJiBpc0VxdWFsKGNvbnRleHQucGVuZGluZ1ZhbHVlLCBjb250ZXh0LnByZXZpb3VzVmFsdWUpXG4gIH0sXG4gIGFjdG9yczoge1xuICAgIFwic3luYyB2YWx1ZVwiOiBzeW5jVmFsdWVMb2dpY1xuICB9XG59KS5jcmVhdGVNYWNoaW5lKHtcbiAgaWQ6IFwic3luY1wiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgaW5pdGlhbFZhbHVlU3luY2VkOiAhMSxcbiAgICBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXM6ICExLFxuICAgIGtleUdlbmVyYXRvcjogaW5wdXQua2V5R2VuZXJhdG9yLFxuICAgIHNjaGVtYTogaW5wdXQuc2NoZW1hLFxuICAgIHJlYWRPbmx5OiBpbnB1dC5yZWFkT25seSxcbiAgICBzbGF0ZUVkaXRvcjogaW5wdXQuc2xhdGVFZGl0b3IsXG4gICAgcGVuZGluZ1ZhbHVlOiB2b2lkIDAsXG4gICAgcHJldmlvdXNWYWx1ZTogdm9pZCAwXG4gIH0pLFxuICBvbjoge1xuICAgIFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiOiB7XG4gICAgICBhY3Rpb25zOiBhc3NpZ24oe1xuICAgICAgICBpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXM6ICEwXG4gICAgICB9KVxuICAgIH0sXG4gICAgbXV0YXRpb246IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIGlzUHJvY2Vzc2luZ0xvY2FsQ2hhbmdlczogITFcbiAgICAgIH0pXG4gICAgfSxcbiAgICBcInVwZGF0ZSByZWFkT25seVwiOiB7XG4gICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcmVhZE9ubHlcIl1cbiAgICB9XG4gIH0sXG4gIHR5cGU6IFwicGFyYWxsZWxcIixcbiAgc3RhdGVzOiB7XG4gICAgXCJzZXR0aW5nIHVwXCI6IHtcbiAgICAgIGluaXRpYWw6IFwic3luY2luZyBpbml0aWFsIHZhbHVlXCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgXCJzeW5jaW5nIGluaXRpYWwgdmFsdWVcIjoge1xuICAgICAgICAgIGFsd2F5czoge1xuICAgICAgICAgICAgZ3VhcmQ6IFwiaW5pdGlhbCB2YWx1ZSBzeW5jZWRcIixcbiAgICAgICAgICAgIHRhcmdldDogXCJkb25lIHN5bmNpbmcgaW5pdGlhbCB2YWx1ZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImRvbmUgc3luY2luZyBpbml0aWFsIHZhbHVlXCI6IHtcbiAgICAgICAgICBlbnRyeTogW1wiZW1pdCBkb25lIHN5bmNpbmcgaW5pdGlhbCB2YWx1ZVwiXSxcbiAgICAgICAgICB0eXBlOiBcImZpbmFsXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3luY2luZzoge1xuICAgICAgaW5pdGlhbDogXCJpZGxlXCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgaWRsZToge1xuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcInVwZGF0ZSB2YWx1ZVwiOiBbe1xuICAgICAgICAgICAgICBndWFyZDogXCJpcyBidXN5XCIsXG4gICAgICAgICAgICAgIHRhcmdldDogXCJidXN5XCIsXG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcImFzc2lnbiBwZW5kaW5nIHZhbHVlXCJdXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHRhcmdldDogXCJzeW5jaW5nXCIsXG4gICAgICAgICAgICAgIGFjdGlvbnM6IFtcImFzc2lnbiBwZW5kaW5nIHZhbHVlXCJdXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYnVzeToge1xuICAgICAgICAgIGFmdGVyOiB7XG4gICAgICAgICAgICAxZTM6IFt7XG4gICAgICAgICAgICAgIGd1YXJkOiBcImlzIGJ1c3lcIixcbiAgICAgICAgICAgICAgcmVlbnRlcjogITBcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInN5bmNpbmdcIlxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBcInVwZGF0ZSB2YWx1ZVwiOiBbe1xuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJhc3NpZ24gcGVuZGluZyB2YWx1ZVwiXVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN5bmNpbmc6IHtcbiAgICAgICAgICBhbHdheXM6IHtcbiAgICAgICAgICAgIGd1YXJkOiBcInBlbmRpbmcgdmFsdWUgZXF1YWxzIHByZXZpb3VzIHZhbHVlXCIsXG4gICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgICAgYWN0aW9uczogW1wiY2xlYXIgcGVuZGluZyB2YWx1ZVwiLCBcImFzc2lnbiBpbml0aWFsIHZhbHVlIHN5bmNlZFwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW52b2tlOiB7XG4gICAgICAgICAgICBzcmM6IFwic3luYyB2YWx1ZVwiLFxuICAgICAgICAgICAgaWQ6IFwic3luYyB2YWx1ZVwiLFxuICAgICAgICAgICAgaW5wdXQ6ICh7XG4gICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IGNvbnRleHQucHJldmlvdXNWYWx1ZSxcbiAgICAgICAgICAgICAgICByZWFkT25seTogY29udGV4dC5yZWFkT25seSxcbiAgICAgICAgICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNsYXRlRWRpdG9yOiBjb250ZXh0LnNsYXRlRWRpdG9yLFxuICAgICAgICAgICAgICBzdHJlYW1CbG9ja3M6ICFjb250ZXh0LmluaXRpYWxWYWx1ZVN5bmNlZCxcbiAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHQucGVuZGluZ1ZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwidXBkYXRlIHZhbHVlXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiYXNzaWduIHBlbmRpbmcgdmFsdWVcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRjaDoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBbZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImludmFsaWQgdmFsdWVcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBbZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInZhbHVlIGNoYW5nZWRcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBbZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImRvbmUgc3luY2luZ1wiOiBbe1xuICAgICAgICAgICAgICBndWFyZDogXCJ2YWx1ZSBjaGFuZ2VkIHdoaWxlIHN5bmNpbmdcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiYXNzaWduIHByZXZpb3VzIHZhbHVlXCIsIFwiYXNzaWduIGluaXRpYWwgdmFsdWUgc3luY2VkXCJdLFxuICAgICAgICAgICAgICByZWVudGVyOiAhMFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiLFxuICAgICAgICAgICAgICBhY3Rpb25zOiBbXCJjbGVhciBwZW5kaW5nIHZhbHVlXCIsIFwiYXNzaWduIHByZXZpb3VzIHZhbHVlXCIsIFwiYXNzaWduIGluaXRpYWwgdmFsdWUgc3luY2VkXCJdXG4gICAgICAgICAgICB9XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIGRlYnVnJGkgPSBkZWJ1Z1dpdGhOYW1lKFwiaG9vazp1c2VTeW5jVmFsdWVcIik7XG5hc3luYyBmdW5jdGlvbiB1cGRhdGVWYWx1ZSh7XG4gIGNvbnRleHQsXG4gIHNlbmRCYWNrLFxuICBzbGF0ZUVkaXRvcixcbiAgc3RyZWFtQmxvY2tzLFxuICB2YWx1ZVxufSkge1xuICBsZXQgaXNDaGFuZ2VkID0gITEsIGlzVmFsaWQgPSAhMDtcbiAgY29uc3QgaGFkU2VsZWN0aW9uID0gISFzbGF0ZUVkaXRvci5zZWxlY3Rpb247XG4gIGlmICgoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkgJiYgKGRlYnVnJGkoXCJWYWx1ZSBpcyBlbXB0eVwiKSwgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgIHdpdGhvdXRTYXZpbmcoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgIHdpdGhvdXRQYXRjaGluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICBoYWRTZWxlY3Rpb24gJiYgVHJhbnNmb3Jtcy5kZXNlbGVjdChzbGF0ZUVkaXRvcik7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gc2xhdGVFZGl0b3IuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBzbGF0ZUVkaXRvci5jaGlsZHJlbi5mb3JFYWNoKChfLCBpbmRleCkgPT4ge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBbY2hpbGRyZW5MZW5ndGggLSAxIC0gaW5kZXhdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBzbGF0ZUVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgYXQ6IFswXVxuICAgICAgICB9KSwgaGFkU2VsZWN0aW9uICYmIFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBbMCwgMF0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pLCBpc0NoYW5nZWQgPSAhMCksIHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBzbGF0ZVZhbHVlRnJvbVByb3BzID0gdG9TbGF0ZVZhbHVlKHZhbHVlLCB7XG4gICAgICBzY2hlbWFUeXBlczogY29udGV4dC5zY2hlbWFcbiAgICB9KTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICB3aXRoUmVtb3RlQ2hhbmdlcyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHdpdGhvdXRQYXRjaGluZyhzbGF0ZUVkaXRvciwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBzbGF0ZUVkaXRvci5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc2xhdGVWYWx1ZUZyb21Qcm9wcy5sZW5ndGggPCBjaGlsZHJlbkxlbmd0aCkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW5MZW5ndGggLSAxOyBpID4gc2xhdGVWYWx1ZUZyb21Qcm9wcy5sZW5ndGggLSAxOyBpLS0pXG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgYXQ6IFtpXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpc0NoYW5nZWQgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgW2N1cnJlbnRCbG9jaywgY3VycmVudEJsb2NrSW5kZXhdIG9mIGdldEJsb2Nrcyh7XG4gICAgICAgICAgICAgIHNsYXRlVmFsdWU6IHNsYXRlVmFsdWVGcm9tUHJvcHMsXG4gICAgICAgICAgICAgIHN0cmVhbUJsb2Nrc1xuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGJsb2NrQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICBibG9ja1ZhbGlkXG4gICAgICAgICAgICAgIH0gPSBzeW5jQmxvY2soe1xuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgc2VuZEJhY2ssXG4gICAgICAgICAgICAgICAgYmxvY2s6IGN1cnJlbnRCbG9jayxcbiAgICAgICAgICAgICAgICBpbmRleDogY3VycmVudEJsb2NrSW5kZXgsXG4gICAgICAgICAgICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlzQ2hhbmdlZCA9IGJsb2NrQ2hhbmdlZCB8fCBpc0NoYW5nZWQsIGlzVmFsaWQgPSBpc1ZhbGlkICYmIGJsb2NrVmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgZGVidWckaShcIkludmFsaWQgdmFsdWUsIHJldHVybmluZ1wiKSwgc2VuZEJhY2soe1xuICAgICAgdHlwZTogXCJkb25lIHN5bmNpbmdcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc0NoYW5nZWQpIHtcbiAgICBkZWJ1ZyRpKFwiU2VydmVyIHZhbHVlIGNoYW5nZWQsIHN5bmNpbmcgZWRpdG9yXCIpO1xuICAgIHRyeSB7XG4gICAgICBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpLCBzZW5kQmFjayh7XG4gICAgICAgIHR5cGU6IFwiaW52YWxpZCB2YWx1ZVwiLFxuICAgICAgICByZXNvbHV0aW9uOiBudWxsLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSksIHNlbmRCYWNrKHtcbiAgICAgICAgdHlwZTogXCJkb25lIHN5bmNpbmdcIixcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYWRTZWxlY3Rpb24gJiYgIXNsYXRlRWRpdG9yLnNlbGVjdGlvbiAmJiAoVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpLCBzZW5kQmFjayh7XG4gICAgICB0eXBlOiBcInZhbHVlIGNoYW5nZWRcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZVxuICAgIGRlYnVnJGkoXCJTZXJ2ZXIgdmFsdWUgYW5kIGVkaXRvciB2YWx1ZSBpcyBlcXVhbCwgbm8gbmVlZCB0byBzeW5jLlwiKTtcbiAgc2VuZEJhY2soe1xuICAgIHR5cGU6IFwiZG9uZSBzeW5jaW5nXCIsXG4gICAgdmFsdWVcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiogZ2V0QmxvY2tzKHtcbiAgc2xhdGVWYWx1ZSxcbiAgc3RyZWFtQmxvY2tzXG59KSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgYmxvY2sgb2Ygc2xhdGVWYWx1ZSlcbiAgICBzdHJlYW1CbG9ja3MgJiYgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMCkpLCB5aWVsZCBbYmxvY2ssIGluZGV4XSwgaW5kZXgrKztcbn1cbmZ1bmN0aW9uIHN5bmNCbG9jayh7XG4gIGNvbnRleHQsXG4gIHNlbmRCYWNrLFxuICBibG9jayxcbiAgaW5kZXgsXG4gIHNsYXRlRWRpdG9yLFxuICB2YWx1ZVxufSkge1xuICBsZXQgYmxvY2tDaGFuZ2VkID0gITEsIGJsb2NrVmFsaWQgPSAhMDtcbiAgY29uc3QgY3VycmVudEJsb2NrID0gYmxvY2ssIGN1cnJlbnRCbG9ja0luZGV4ID0gaW5kZXgsIG9sZEJsb2NrID0gc2xhdGVFZGl0b3IuY2hpbGRyZW5bY3VycmVudEJsb2NrSW5kZXhdLCBoYXNDaGFuZ2VzID0gb2xkQmxvY2sgJiYgIWlzRXF1YWwoY3VycmVudEJsb2NrLCBvbGRCbG9jayk7XG4gIHJldHVybiBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKHNsYXRlRWRpdG9yLCAoKSA9PiB7XG4gICAgd2l0aFJlbW90ZUNoYW5nZXMoc2xhdGVFZGl0b3IsICgpID0+IHtcbiAgICAgIHdpdGhvdXRQYXRjaGluZyhzbGF0ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgICBpZiAoaGFzQ2hhbmdlcyAmJiBibG9ja1ZhbGlkKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdGlvblZhbHVlID0gW3ZhbHVlW2N1cnJlbnRCbG9ja0luZGV4XV0sIHZhbGlkYXRpb24gPSB2YWxpZGF0ZVZhbHVlKHZhbGlkYXRpb25WYWx1ZSwgY29udGV4dC5zY2hlbWEsIGNvbnRleHQua2V5R2VuZXJhdG9yKTtcbiAgICAgICAgICAhdmFsaWRhdGlvbi52YWxpZCAmJiB2YWxpZGF0aW9uLnJlc29sdXRpb24/LmF1dG9SZXNvbHZlICYmIHZhbGlkYXRpb24ucmVzb2x1dGlvbj8ucGF0Y2hlcy5sZW5ndGggPiAwICYmICFjb250ZXh0LnJlYWRPbmx5ICYmIGNvbnRleHQucHJldmlvdXNWYWx1ZSAmJiBjb250ZXh0LnByZXZpb3VzVmFsdWUgIT09IHZhbHVlICYmIChjb25zb2xlLndhcm4oYCR7dmFsaWRhdGlvbi5yZXNvbHV0aW9uLmFjdGlvbn0gZm9yIGJsb2NrIHdpdGggX2tleSAnJHt2YWxpZGF0aW9uVmFsdWVbMF0uX2tleX0nLiAke3ZhbGlkYXRpb24ucmVzb2x1dGlvbj8uZGVzY3JpcHRpb259YCksIHZhbGlkYXRpb24ucmVzb2x1dGlvbi5wYXRjaGVzLmZvckVhY2goKHBhdGNoKSA9PiB7XG4gICAgICAgICAgICBzZW5kQmFjayh7XG4gICAgICAgICAgICAgIHR5cGU6IFwicGF0Y2hcIixcbiAgICAgICAgICAgICAgcGF0Y2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKSwgdmFsaWRhdGlvbi52YWxpZCB8fCB2YWxpZGF0aW9uLnJlc29sdXRpb24/LmF1dG9SZXNvbHZlID8gKG9sZEJsb2NrLl9rZXkgPT09IGN1cnJlbnRCbG9jay5fa2V5ID8gKGRlYnVnJGkuZW5hYmxlZCAmJiBkZWJ1ZyRpKFwiVXBkYXRpbmcgYmxvY2tcIiwgb2xkQmxvY2ssIGN1cnJlbnRCbG9jayksIF91cGRhdGVCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBvbGRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpKSA6IChkZWJ1ZyRpLmVuYWJsZWQgJiYgZGVidWckaShcIlJlcGxhY2luZyBibG9ja1wiLCBvbGRCbG9jaywgY3VycmVudEJsb2NrKSwgX3JlcGxhY2VCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkpLCBibG9ja0NoYW5nZWQgPSAhMCkgOiAoc2VuZEJhY2soe1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkIHZhbHVlXCIsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiB2YWxpZGF0aW9uLnJlc29sdXRpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pLCBibG9ja1ZhbGlkID0gITEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb2xkQmxvY2sgJiYgYmxvY2tWYWxpZCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25WYWx1ZSA9IFt2YWx1ZVtjdXJyZW50QmxvY2tJbmRleF1dLCB2YWxpZGF0aW9uID0gdmFsaWRhdGVWYWx1ZSh2YWxpZGF0aW9uVmFsdWUsIGNvbnRleHQuc2NoZW1hLCBjb250ZXh0LmtleUdlbmVyYXRvcik7XG4gICAgICAgICAgZGVidWckaS5lbmFibGVkICYmIGRlYnVnJGkoXCJWYWxpZGF0aW5nIGFuZCBpbnNlcnRpbmcgbmV3IGJsb2NrIGluIHRoZSBlbmQgb2YgdGhlIHZhbHVlXCIsIGN1cnJlbnRCbG9jayksIHZhbGlkYXRpb24udmFsaWQgfHwgdmFsaWRhdGlvbi5yZXNvbHV0aW9uPy5hdXRvUmVzb2x2ZSA/IFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywge1xuICAgICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleF1cbiAgICAgICAgICB9KSA6IChkZWJ1ZyRpKFwiSW52YWxpZFwiLCB2YWxpZGF0aW9uKSwgc2VuZEJhY2soe1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkIHZhbHVlXCIsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiB2YWxpZGF0aW9uLnJlc29sdXRpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pLCBibG9ja1ZhbGlkID0gITEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSksIHtcbiAgICBibG9ja0NoYW5nZWQsXG4gICAgYmxvY2tWYWxpZFxuICB9O1xufVxuZnVuY3Rpb24gX3JlcGxhY2VCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBjdXJyZW50QmxvY2tJbmRleCkge1xuICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gc2xhdGVFZGl0b3Iuc2VsZWN0aW9uLCBzZWxlY3Rpb25Gb2N1c09uQmxvY2sgPSBjdXJyZW50U2VsZWN0aW9uICYmIGN1cnJlbnRTZWxlY3Rpb24uZm9jdXMucGF0aFswXSA9PT0gY3VycmVudEJsb2NrSW5kZXg7XG4gIHNlbGVjdGlvbkZvY3VzT25CbG9jayAmJiBUcmFuc2Zvcm1zLmRlc2VsZWN0KHNsYXRlRWRpdG9yKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhzbGF0ZUVkaXRvciwge1xuICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2ssIHtcbiAgICBhdDogW2N1cnJlbnRCbG9ja0luZGV4XVxuICB9KSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKSwgc2VsZWN0aW9uRm9jdXNPbkJsb2NrICYmIFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBjdXJyZW50U2VsZWN0aW9uKTtcbn1cbmZ1bmN0aW9uIF91cGRhdGVCbG9jayhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrLCBvbGRCbG9jaywgY3VycmVudEJsb2NrSW5kZXgpIHtcbiAgaWYgKFRyYW5zZm9ybXMuc2V0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9jaywge1xuICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXhdXG4gIH0pLCBzbGF0ZUVkaXRvci5pc1RleHRCbG9jayhjdXJyZW50QmxvY2spICYmIHNsYXRlRWRpdG9yLmlzVGV4dEJsb2NrKG9sZEJsb2NrKSkge1xuICAgIGNvbnN0IG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggPSBvbGRCbG9jay5jaGlsZHJlbi5sZW5ndGg7XG4gICAgY3VycmVudEJsb2NrLmNoaWxkcmVuLmxlbmd0aCA8IG9sZEJsb2NrQ2hpbGRyZW5MZW5ndGggJiYgQXJyYXkuZnJvbShBcnJheShvbGRCbG9ja0NoaWxkcmVuTGVuZ3RoIC0gY3VycmVudEJsb2NrLmNoaWxkcmVuLmxlbmd0aCkpLmZvckVhY2goKF8sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjaGlsZEluZGV4ID0gb2xkQmxvY2tDaGlsZHJlbkxlbmd0aCAtIDEgLSBpbmRleDtcbiAgICAgIGNoaWxkSW5kZXggPiAwICYmIChkZWJ1ZyRpKFwiUmVtb3ZpbmcgY2hpbGRcIiksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoc2xhdGVFZGl0b3IsIHtcbiAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY2hpbGRJbmRleF1cbiAgICAgIH0pKTtcbiAgICB9KSwgY3VycmVudEJsb2NrLmNoaWxkcmVuLmZvckVhY2goKGN1cnJlbnRCbG9ja0NoaWxkLCBjdXJyZW50QmxvY2tDaGlsZEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBvbGRCbG9ja0NoaWxkID0gb2xkQmxvY2suY2hpbGRyZW5bY3VycmVudEJsb2NrQ2hpbGRJbmRleF0sIGlzQ2hpbGRDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEJsb2NrQ2hpbGQsIG9sZEJsb2NrQ2hpbGQpLCBpc1RleHRDaGFuZ2VkID0gIWlzRXF1YWwoY3VycmVudEJsb2NrQ2hpbGQudGV4dCwgb2xkQmxvY2tDaGlsZD8udGV4dCksIHBhdGggPSBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdO1xuICAgICAgaWYgKGlzQ2hpbGRDaGFuZ2VkKVxuICAgICAgICBpZiAoY3VycmVudEJsb2NrQ2hpbGQuX2tleSA9PT0gb2xkQmxvY2tDaGlsZD8uX2tleSkge1xuICAgICAgICAgIGRlYnVnJGkoXCJVcGRhdGluZyBjaGFuZ2VkIGNoaWxkXCIsIGN1cnJlbnRCbG9ja0NoaWxkLCBvbGRCbG9ja0NoaWxkKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhzbGF0ZUVkaXRvciwgY3VycmVudEJsb2NrQ2hpbGQsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaXNTcGFuTm9kZSA9IFRleHQuaXNUZXh0KGN1cnJlbnRCbG9ja0NoaWxkKSAmJiBjdXJyZW50QmxvY2tDaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgVGV4dC5pc1RleHQob2xkQmxvY2tDaGlsZCkgJiYgb2xkQmxvY2tDaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCI7XG4gICAgICAgICAgaXNTcGFuTm9kZSAmJiBpc1RleHRDaGFuZ2VkID8gKFRyYW5zZm9ybXMuZGVsZXRlKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgICBhdDoge1xuICAgICAgICAgICAgICBmb2N1czoge1xuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBvbGRCbG9ja0NoaWxkLnRleHQubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2tDaGlsZC50ZXh0LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKSA6IGlzU3Bhbk5vZGUgfHwgKGRlYnVnJGkoXCJVcGRhdGluZyBjaGFuZ2VkIGlubGluZSBvYmplY3QgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLnNldE5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgICBfa2V5OiBWT0lEX0NISUxEX0tFWVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBbLi4ucGF0aCwgMF0sXG4gICAgICAgICAgICB2b2lkczogITBcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBvbGRCbG9ja0NoaWxkID8gKGRlYnVnJGkoXCJSZXBsYWNpbmcgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKHNsYXRlRWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF1cbiAgICAgICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoc2xhdGVFZGl0b3IsIGN1cnJlbnRCbG9ja0NoaWxkLCB7XG4gICAgICAgICAgYXQ6IFtjdXJyZW50QmxvY2tJbmRleCwgY3VycmVudEJsb2NrQ2hpbGRJbmRleF1cbiAgICAgICAgfSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpIDogb2xkQmxvY2tDaGlsZCB8fCAoZGVidWckaShcIkluc2VydGluZyBuZXcgY2hpbGRcIiwgY3VycmVudEJsb2NrQ2hpbGQpLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBjdXJyZW50QmxvY2tDaGlsZCwge1xuICAgICAgICAgIGF0OiBbY3VycmVudEJsb2NrSW5kZXgsIGN1cnJlbnRCbG9ja0NoaWxkSW5kZXhdXG4gICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgZGVidWckaCA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yOlN5bmNocm9uaXplclwiKTtcbmZ1bmN0aW9uIFN5bmNocm9uaXplcihwcm9wcykge1xuICBjb25zdCAkID0gYyg0MCksIHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBzbGF0ZUVkaXRvclxuICB9ID0gcHJvcHMsIHZhbHVlID0gdXNlU2VsZWN0b3IocHJvcHMuZWRpdG9yQWN0b3IsIF90ZW1wKSwgcmVhZE9ubHkgPSB1c2VTZWxlY3Rvcihwcm9wcy5lZGl0b3JBY3RvciwgX3RlbXAyKTtcbiAgbGV0IHQwO1xuICAkWzBdICE9PSBwcm9wcy5lZGl0b3JBY3RvciA/ICh0MCA9IHByb3BzLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCksICRbMF0gPSBwcm9wcy5lZGl0b3JBY3RvciwgJFsxXSA9IHQwKSA6IHQwID0gJFsxXTtcbiAgY29uc3QgdDEgPSB0MC5jb250ZXh0LmtleUdlbmVyYXRvcjtcbiAgbGV0IHQyO1xuICAkWzJdICE9PSBwcm9wcy5lZGl0b3JBY3RvciA/ICh0MiA9IHByb3BzLmVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICB9KSwgJFsyXSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzNdID0gdDIpIDogdDIgPSAkWzNdO1xuICBsZXQgdDM7XG4gICRbNF0gIT09IHByb3BzLmVkaXRvckFjdG9yID8gKHQzID0gcHJvcHMuZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKSwgJFs0XSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzVdID0gdDMpIDogdDMgPSAkWzVdO1xuICBsZXQgdDQ7XG4gICRbNl0gIT09IHNsYXRlRWRpdG9yIHx8ICRbN10gIT09IHQwLmNvbnRleHQua2V5R2VuZXJhdG9yIHx8ICRbOF0gIT09IHQyIHx8ICRbOV0gIT09IHQzLmNvbnRleHQuc2NoZW1hID8gKHQ0ID0ge1xuICAgIGlucHV0OiB7XG4gICAgICBrZXlHZW5lcmF0b3I6IHQxLFxuICAgICAgcmVhZE9ubHk6IHQyLFxuICAgICAgc2NoZW1hOiB0My5jb250ZXh0LnNjaGVtYSxcbiAgICAgIHNsYXRlRWRpdG9yXG4gICAgfVxuICB9LCAkWzZdID0gc2xhdGVFZGl0b3IsICRbN10gPSB0MC5jb250ZXh0LmtleUdlbmVyYXRvciwgJFs4XSA9IHQyLCAkWzldID0gdDMuY29udGV4dC5zY2hlbWEsICRbMTBdID0gdDQpIDogdDQgPSAkWzEwXTtcbiAgY29uc3Qgc3luY0FjdG9yUmVmID0gdXNlQWN0b3JSZWYoc3luY01hY2hpbmUsIHQ0KTtcbiAgbGV0IHQ1O1xuICAkWzExXSAhPT0gZWRpdG9yQWN0b3IgPyAodDUgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLCAkWzExXSA9IGVkaXRvckFjdG9yLCAkWzEyXSA9IHQ1KSA6IHQ1ID0gJFsxMl07XG4gIGxldCB0NjtcbiAgJFsxM10gIT09IHNsYXRlRWRpdG9yIHx8ICRbMTRdICE9PSB0NS5jb250ZXh0LnNjaGVtYSA/ICh0NiA9IHtcbiAgICBpbnB1dDoge1xuICAgICAgc2NoZW1hOiB0NS5jb250ZXh0LnNjaGVtYSxcbiAgICAgIHNsYXRlRWRpdG9yXG4gICAgfVxuICB9LCAkWzEzXSA9IHNsYXRlRWRpdG9yLCAkWzE0XSA9IHQ1LmNvbnRleHQuc2NoZW1hLCAkWzE1XSA9IHQ2KSA6IHQ2ID0gJFsxNV07XG4gIGNvbnN0IG11dGF0aW9uQWN0b3JSZWYgPSB1c2VBY3RvclJlZihtdXRhdGlvbk1hY2hpbmUsIHQ2KTtcbiAgbGV0IHQ3LCB0ODtcbiAgJFsxNl0gIT09IGVkaXRvckFjdG9yIHx8ICRbMTddICE9PSBtdXRhdGlvbkFjdG9yUmVmIHx8ICRbMThdICE9PSBzeW5jQWN0b3JSZWYgPyAodDcgPSAoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbXV0YXRpb25BY3RvclJlZi5vbihcIipcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBldmVudC50eXBlID09PSBcImhhcyBwZW5kaW5nIHBhdGNoZXNcIiAmJiBzeW5jQWN0b3JSZWYuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiaGFzIHBlbmRpbmcgcGF0Y2hlc1wiXG4gICAgICB9KSwgZXZlbnQudHlwZSA9PT0gXCJtdXRhdGlvblwiICYmIChzeW5jQWN0b3JSZWYuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwibXV0YXRpb25cIlxuICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcIm11dGF0aW9uXCIsXG4gICAgICAgIHBhdGNoZXM6IGV2ZW50LnBhdGNoZXMsXG4gICAgICAgIHNuYXBzaG90OiBldmVudC5zbmFwc2hvdCxcbiAgICAgICAgdmFsdWU6IGV2ZW50LnNuYXBzaG90XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQ4ID0gW211dGF0aW9uQWN0b3JSZWYsIHN5bmNBY3RvclJlZiwgZWRpdG9yQWN0b3JdLCAkWzE2XSA9IGVkaXRvckFjdG9yLCAkWzE3XSA9IG11dGF0aW9uQWN0b3JSZWYsICRbMThdID0gc3luY0FjdG9yUmVmLCAkWzE5XSA9IHQ3LCAkWzIwXSA9IHQ4KSA6ICh0NyA9ICRbMTldLCB0OCA9ICRbMjBdKSwgdXNlRWZmZWN0KHQ3LCB0OCk7XG4gIGxldCB0MTAsIHQ5O1xuICAkWzIxXSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgfHwgJFsyMl0gIT09IHN5bmNBY3RvclJlZiA/ICh0OSA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25fMCA9IHN5bmNBY3RvclJlZi5vbihcIipcIiwgKGV2ZW50XzApID0+IHtcbiAgICAgIHByb3BzLmVkaXRvckFjdG9yLnNlbmQoZXZlbnRfMCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbl8wLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgdDEwID0gW3Byb3BzLmVkaXRvckFjdG9yLCBzeW5jQWN0b3JSZWZdLCAkWzIxXSA9IHByb3BzLmVkaXRvckFjdG9yLCAkWzIyXSA9IHN5bmNBY3RvclJlZiwgJFsyM10gPSB0MTAsICRbMjRdID0gdDkpIDogKHQxMCA9ICRbMjNdLCB0OSA9ICRbMjRdKSwgdXNlRWZmZWN0KHQ5LCB0MTApO1xuICBsZXQgdDExLCB0MTI7XG4gICRbMjVdICE9PSByZWFkT25seSB8fCAkWzI2XSAhPT0gc3luY0FjdG9yUmVmID8gKHQxMSA9ICgpID0+IHtcbiAgICBzeW5jQWN0b3JSZWYuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSByZWFkT25seVwiLFxuICAgICAgcmVhZE9ubHlcbiAgICB9KTtcbiAgfSwgdDEyID0gW3N5bmNBY3RvclJlZiwgcmVhZE9ubHldLCAkWzI1XSA9IHJlYWRPbmx5LCAkWzI2XSA9IHN5bmNBY3RvclJlZiwgJFsyN10gPSB0MTEsICRbMjhdID0gdDEyKSA6ICh0MTEgPSAkWzI3XSwgdDEyID0gJFsyOF0pLCB1c2VFZmZlY3QodDExLCB0MTIpO1xuICBsZXQgdDEzLCB0MTQ7XG4gICRbMjldICE9PSBzeW5jQWN0b3JSZWYgfHwgJFszMF0gIT09IHZhbHVlID8gKHQxMyA9ICgpID0+IHtcbiAgICBkZWJ1ZyRoKFwiVmFsdWUgZnJvbSBwcm9wcyBjaGFuZ2VkLCBzeW5jaW5nIG5ldyB2YWx1ZVwiKSwgc3luY0FjdG9yUmVmLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgdmFsdWVcIixcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0sIHQxNCA9IFtzeW5jQWN0b3JSZWYsIHZhbHVlXSwgJFsyOV0gPSBzeW5jQWN0b3JSZWYsICRbMzBdID0gdmFsdWUsICRbMzFdID0gdDEzLCAkWzMyXSA9IHQxNCkgOiAodDEzID0gJFszMV0sIHQxNCA9ICRbMzJdKSwgdXNlRWZmZWN0KHQxMywgdDE0KTtcbiAgbGV0IHQxNTtcbiAgJFszM10gIT09IGVkaXRvckFjdG9yIHx8ICRbMzRdICE9PSBtdXRhdGlvbkFjdG9yUmVmID8gKHQxNSA9ICgpID0+IHtcbiAgICBkZWJ1ZyRoKFwiU3Vic2NyaWJpbmcgdG8gcGF0Y2ggZXZlbnRzXCIpO1xuICAgIGNvbnN0IHN1YiA9IGVkaXRvckFjdG9yLm9uKFwicGF0Y2hcIiwgKGV2ZW50XzEpID0+IHtcbiAgICAgIG11dGF0aW9uQWN0b3JSZWYuc2VuZChldmVudF8xKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVidWckaChcIlVuc3Vic2NyaWJpbmcgdG8gcGF0Y2ggZXZlbnRzXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCAkWzMzXSA9IGVkaXRvckFjdG9yLCAkWzM0XSA9IG11dGF0aW9uQWN0b3JSZWYsICRbMzVdID0gdDE1KSA6IHQxNSA9ICRbMzVdO1xuICBsZXQgdDE2O1xuICByZXR1cm4gJFszNl0gIT09IGVkaXRvckFjdG9yIHx8ICRbMzddICE9PSBtdXRhdGlvbkFjdG9yUmVmIHx8ICRbMzhdICE9PSBzbGF0ZUVkaXRvciA/ICh0MTYgPSBbZWRpdG9yQWN0b3IsIG11dGF0aW9uQWN0b3JSZWYsIHNsYXRlRWRpdG9yXSwgJFszNl0gPSBlZGl0b3JBY3RvciwgJFszN10gPSBtdXRhdGlvbkFjdG9yUmVmLCAkWzM4XSA9IHNsYXRlRWRpdG9yLCAkWzM5XSA9IHQxNikgOiB0MTYgPSAkWzM5XSwgdXNlRWZmZWN0KHQxNSwgdDE2KSwgbnVsbDtcbn1cbmZ1bmN0aW9uIF90ZW1wMihzXzApIHtcbiAgcmV0dXJuIHNfMC5tYXRjaGVzKHtcbiAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gIH0pO1xufVxuZnVuY3Rpb24gX3RlbXAocykge1xuICByZXR1cm4gcy5jb250ZXh0LnZhbHVlO1xufVxuU3luY2hyb25pemVyLmRpc3BsYXlOYW1lID0gXCJTeW5jaHJvbml6ZXJcIjtcbmNvbnN0IGRlYnVnJGcgPSBkZWJ1Z1dpdGhOYW1lKFwib3BlcmF0aW9uVG9QYXRjaGVzXCIpO1xuZnVuY3Rpb24gY3JlYXRlT3BlcmF0aW9uVG9QYXRjaGVzKHR5cGVzKSB7XG4gIGNvbnN0IHRleHRCbG9ja05hbWUgPSB0eXBlcy5ibG9jay5uYW1lO1xuICBmdW5jdGlvbiBpbnNlcnRUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgZGVidWckZy5lbmFibGVkICYmIGRlYnVnJGcoXCJPcGVyYXRpb25cIiwgSlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLCBudWxsLCAyKSk7XG4gICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuaXNUZXh0QmxvY2soZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSkgJiYgZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAoIWJsb2NrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYmxvY2tcIik7XG4gICAgY29uc3QgdGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0pICYmIGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICBpZiAoIXRleHRDaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGNoaWxkXCIpO1xuICAgIGNvbnN0IHBhdGggPSBbe1xuICAgICAgX2tleTogYmxvY2suX2tleVxuICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgX2tleTogdGV4dENoaWxkLl9rZXlcbiAgICB9LCBcInRleHRcIl0sIHByZXZCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgcHJldkNoaWxkID0gZWRpdG9yLmlzVGV4dEJsb2NrKHByZXZCbG9jaykgJiYgcHJldkJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBlZGl0b3IuaXNUZXh0U3BhbihwcmV2Q2hpbGQpID8gcHJldkNoaWxkLnRleHQgOiBcIlwiLCBwYXRjaCA9IGRpZmZNYXRjaFBhdGNoJDEocHJldlRleHQsIHRleHRDaGlsZC50ZXh0LCBwYXRoKTtcbiAgICByZXR1cm4gcGF0Y2gudmFsdWUubGVuZ3RoID8gW3BhdGNoXSA6IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRleHRQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGVkaXRvciAmJiBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmICghYmxvY2spXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBibG9ja1wiKTtcbiAgICBjb25zdCBjaGlsZCA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dIHx8IHZvaWQgMCwgdGV4dENoaWxkID0gZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpID8gY2hpbGQgOiB2b2lkIDA7XG4gICAgaWYgKGNoaWxkICYmICF0ZXh0Q2hpbGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBzcGFuXCIpO1xuICAgIGlmICghdGV4dENoaWxkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgY2hpbGRcIik7XG4gICAgY29uc3QgcGF0aCA9IFt7XG4gICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgfSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICBfa2V5OiB0ZXh0Q2hpbGQuX2tleVxuICAgIH0sIFwidGV4dFwiXSwgYmVmb3JlQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV0sIHByZXZUZXh0Q2hpbGQgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmVmb3JlQmxvY2spICYmIGJlZm9yZUJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSwgcHJldlRleHQgPSBlZGl0b3IuaXNUZXh0U3BhbihwcmV2VGV4dENoaWxkKSAmJiBwcmV2VGV4dENoaWxkLnRleHQsIHBhdGNoID0gZGlmZk1hdGNoUGF0Y2gkMShwcmV2VGV4dCB8fCBcIlwiLCB0ZXh0Q2hpbGQudGV4dCwgcGF0aCk7XG4gICAgcmV0dXJuIHBhdGNoLnZhbHVlID8gW3BhdGNoXSA6IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHNldE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICAgIGlmICh0eXBlb2YgYmxvY2suX2tleSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBibG9jayB0byBoYXZlIGEgX2tleVwiKTtcbiAgICAgIGNvbnN0IHNldE5vZGUgPSBvbWl0Qnkoe1xuICAgICAgICAuLi5lZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dLFxuICAgICAgICAuLi5vcGVyYXRpb24ubmV3UHJvcGVydGllc1xuICAgICAgfSwgaXNVbmRlZmluZWQpO1xuICAgICAgcmV0dXJuIFtzZXQoZnJvbVNsYXRlVmFsdWUoW3NldE5vZGVdLCB0ZXh0QmxvY2tOYW1lKVswXSwgW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV0pXTtcbiAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgYmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV07XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGNvbnN0IGJsb2NrS2V5ID0gYmxvY2suX2tleSwgY2hpbGRLZXkgPSBjaGlsZC5fa2V5LCBwYXRjaGVzID0gW10sIGtleXMgPSBPYmplY3Qua2V5cyhvcGVyYXRpb24ubmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgcmV0dXJuIGtleXMuZm9yRWFjaCgoa2V5TmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleU5hbWUgPT09IFwiX2tleVwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGdldChvcGVyYXRpb24ubmV3UHJvcGVydGllcywga2V5TmFtZSk7XG4gICAgICAgICAgICAgIHBhdGNoZXMucHVzaChzZXQodmFsLCBbe1xuICAgICAgICAgICAgICAgIF9rZXk6IGJsb2NrS2V5XG4gICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwgYmxvY2suY2hpbGRyZW4uaW5kZXhPZihjaGlsZCksIGtleU5hbWVdKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB2YWwgPSBnZXQob3BlcmF0aW9uLm5ld1Byb3BlcnRpZXMsIGtleU5hbWUpO1xuICAgICAgICAgICAgICBwYXRjaGVzLnB1c2goc2V0KHZhbCwgW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9ja0tleVxuICAgICAgICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgICAgICBfa2V5OiBjaGlsZEtleVxuICAgICAgICAgICAgICB9LCBrZXlOYW1lXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBwYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgY2hpbGRcIik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhIHZhbGlkIGJsb2NrXCIpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHBhdGggZW5jb3VudGVyZWQ6ICR7SlNPTi5zdHJpbmdpZnkob3BlcmF0aW9uLnBhdGgpfWApO1xuICB9XG4gIGZ1bmN0aW9uIGluc2VydE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgaXNUZXh0QmxvY2sgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spO1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gb3BlcmF0aW9uLnBhdGhbMF0gPT09IDAgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiLCBiZWZvcmVCbG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdIC0gMV0sIHRhcmdldEtleSA9IG9wZXJhdGlvbi5wYXRoWzBdID09PSAwID8gYmxvY2s/Ll9rZXkgOiBiZWZvcmVCbG9jaz8uX2tleTtcbiAgICAgIHJldHVybiB0YXJnZXRLZXkgPyBbaW5zZXJ0KFtmcm9tU2xhdGVWYWx1ZShbb3BlcmF0aW9uLm5vZGVdLCB0ZXh0QmxvY2tOYW1lKVswXV0sIHBvc2l0aW9uLCBbe1xuICAgICAgICBfa2V5OiB0YXJnZXRLZXlcbiAgICAgIH1dKV0gOiBbc2V0SWZNaXNzaW5nKGJlZm9yZVZhbHVlLCBbXSksIGluc2VydChbZnJvbVNsYXRlVmFsdWUoW29wZXJhdGlvbi5ub2RlXSwgdGV4dEJsb2NrTmFtZSlbMF1dLCBcImJlZm9yZVwiLCBbb3BlcmF0aW9uLnBhdGhbMF1dKV07XG4gICAgfSBlbHNlIGlmIChpc1RleHRCbG9jayAmJiBvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIgJiYgZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgIWJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdIC0gMV0gPyBcImJlZm9yZVwiIDogXCJhZnRlclwiLCBub2RlID0ge1xuICAgICAgICAuLi5vcGVyYXRpb24ubm9kZVxuICAgICAgfTtcbiAgICAgICFub2RlLl90eXBlICYmIFRleHQuaXNUZXh0KG5vZGUpICYmIChub2RlLl90eXBlID0gXCJzcGFuXCIsIG5vZGUubWFya3MgPSBbXSk7XG4gICAgICBjb25zdCBjaGlsZCA9IGZyb21TbGF0ZVZhbHVlKFt7XG4gICAgICAgIF9rZXk6IFwiYm9ndXNcIixcbiAgICAgICAgX3R5cGU6IHRleHRCbG9ja05hbWUsXG4gICAgICAgIGNoaWxkcmVuOiBbbm9kZV1cbiAgICAgIH1dLCB0ZXh0QmxvY2tOYW1lKVswXS5jaGlsZHJlblswXTtcbiAgICAgIHJldHVybiBbaW5zZXJ0KFtjaGlsZF0sIHBvc2l0aW9uLCBbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIGJsb2NrLmNoaWxkcmVuLmxlbmd0aCA8PSAxIHx8ICFibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdID8gMCA6IHtcbiAgICAgICAgX2tleTogYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV0gLSAxXS5fa2V5XG4gICAgICB9XSldO1xuICAgIH1cbiAgICByZXR1cm4gZGVidWckZyhcIlNvbWV0aGluZyB3YXMgaW5zZXJ0ZWQgaW50byBhIHZvaWQgYmxvY2suIE5vdCBwcm9kdWNpbmcgZWRpdG9yIHBhdGNoZXMuXCIpLCBbXTtcbiAgfVxuICBmdW5jdGlvbiBzcGxpdE5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgYmVmb3JlVmFsdWUpIHtcbiAgICBjb25zdCBwYXRjaGVzID0gW10sIHNwbGl0QmxvY2sgPSBlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF1dO1xuICAgIGlmICghZWRpdG9yLmlzVGV4dEJsb2NrKHNwbGl0QmxvY2spKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayB3aXRoIHBhdGggJHtKU09OLnN0cmluZ2lmeShvcGVyYXRpb24ucGF0aFswXSl9IGlzIG5vdCBhIHRleHQgYmxvY2sgYW5kIGNhbid0IGJlIHNwbGl0YCk7XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3Qgb2xkQmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV07XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG9sZEJsb2NrKSkge1xuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IGZyb21TbGF0ZVZhbHVlKFtlZGl0b3IuY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMF0gKyAxXV0sIHRleHRCbG9ja05hbWUpWzBdO1xuICAgICAgICB0YXJnZXRWYWx1ZSAmJiAocGF0Y2hlcy5wdXNoKGluc2VydChbdGFyZ2V0VmFsdWVdLCBcImFmdGVyXCIsIFt7XG4gICAgICAgICAgX2tleTogc3BsaXRCbG9jay5fa2V5XG4gICAgICAgIH1dKSksIG9sZEJsb2NrLmNoaWxkcmVuLnNsaWNlKG9wZXJhdGlvbi5wb3NpdGlvbikuZm9yRWFjaCgoc3BhbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhdGggPSBbe1xuICAgICAgICAgICAgX2tleTogb2xkQmxvY2suX2tleVxuICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgX2tleTogc3Bhbi5fa2V5XG4gICAgICAgICAgfV07XG4gICAgICAgICAgcGF0Y2hlcy5wdXNoKHVuc2V0KHBhdGgpKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGNoZXM7XG4gICAgfVxuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHNwbGl0U3BhbiA9IHNwbGl0QmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKHNwbGl0U3BhbikpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3BhbnMgPSBmcm9tU2xhdGVWYWx1ZShbe1xuICAgICAgICAgIC4uLnNwbGl0QmxvY2ssXG4gICAgICAgICAgY2hpbGRyZW46IHNwbGl0QmxvY2suY2hpbGRyZW4uc2xpY2Uob3BlcmF0aW9uLnBhdGhbMV0gKyAxLCBvcGVyYXRpb24ucGF0aFsxXSArIDIpXG4gICAgICAgIH1dLCB0ZXh0QmxvY2tOYW1lKVswXS5jaGlsZHJlbjtcbiAgICAgICAgcGF0Y2hlcy5wdXNoKGluc2VydCh0YXJnZXRTcGFucywgXCJhZnRlclwiLCBbe1xuICAgICAgICAgIF9rZXk6IHNwbGl0QmxvY2suX2tleVxuICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBfa2V5OiBzcGxpdFNwYW4uX2tleVxuICAgICAgICB9XSkpLCBwYXRjaGVzLnB1c2goc2V0KHNwbGl0U3Bhbi50ZXh0LCBbe1xuICAgICAgICAgIF9rZXk6IHNwbGl0QmxvY2suX2tleVxuICAgICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICBfa2V5OiBzcGxpdFNwYW4uX2tleVxuICAgICAgICB9LCBcInRleHRcIl0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRjaGVzO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgY29uc3QgYmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ucGF0aFswXV07XG4gICAgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGJsb2NrICYmIGJsb2NrLl9rZXkpXG4gICAgICAgIHJldHVybiBbdW5zZXQoW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dKV07XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCbG9jayBub3QgZm91bmRcIik7XG4gICAgfSBlbHNlIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3Qgc3BhblRvUmVtb3ZlID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dO1xuICAgICAgcmV0dXJuIHNwYW5Ub1JlbW92ZSA/IGJsb2NrLmNoaWxkcmVuLmZpbHRlcigoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSBvcGVyYXRpb24ubm9kZS5fa2V5KS5sZW5ndGggPiAxID8gKGNvbnNvbGUud2FybihgTXVsdGlwbGUgc3BhbnMgaGF2ZSBcXGBfa2V5XFxgICR7b3BlcmF0aW9uLm5vZGUuX2tleX0uIEl0J3MgYW1iaWd1b3VzIHdoaWNoIG9uZSB0byByZW1vdmUuYCwgSlNPTi5zdHJpbmdpZnkoYmxvY2ssIG51bGwsIDIpKSwgW10pIDogW3Vuc2V0KFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiBzcGFuVG9SZW1vdmUuX2tleVxuICAgICAgfV0pXSA6IChkZWJ1ZyRnKFwiU3BhbiBub3QgZm91bmQgaW4gZWRpdG9yIHRyeWluZyB0byByZW1vdmUgbm9kZVwiKSwgW10pO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIGRlYnVnJGcoXCJOb3QgY3JlYXRpbmcgcGF0Y2ggaW5zaWRlIG9iamVjdCBibG9ja1wiKSwgW107XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgY29uc3QgcGF0Y2hlcyA9IFtdLCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgdXBkYXRlZEJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzBdXTtcbiAgICBpZiAob3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxKVxuICAgICAgaWYgKGJsb2NrPy5fa2V5KSB7XG4gICAgICAgIGNvbnN0IG5ld0Jsb2NrID0gZnJvbVNsYXRlVmFsdWUoW2VkaXRvci5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFswXSAtIDFdXSwgdGV4dEJsb2NrTmFtZSlbMF07XG4gICAgICAgIHBhdGNoZXMucHVzaChzZXQobmV3QmxvY2ssIFt7XG4gICAgICAgICAgX2tleTogbmV3QmxvY2suX2tleVxuICAgICAgICB9XSkpLCBwYXRjaGVzLnB1c2godW5zZXQoW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH1dKSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IGtleSBub3QgZm91bmQhXCIpO1xuICAgIGVsc2UgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgZWRpdG9yLmlzVGV4dEJsb2NrKHVwZGF0ZWRCbG9jaykgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCB1cGRhdGVkU3BhbiA9IHVwZGF0ZWRCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdICYmIGVkaXRvci5pc1RleHRTcGFuKHVwZGF0ZWRCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdKSA/IHVwZGF0ZWRCbG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXSAtIDFdIDogdm9pZCAwLCByZW1vdmVkU3BhbiA9IGJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXSAmJiBlZGl0b3IuaXNUZXh0U3BhbihibG9jay5jaGlsZHJlbltvcGVyYXRpb24ucGF0aFsxXV0pID8gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dIDogdm9pZCAwO1xuICAgICAgdXBkYXRlZFNwYW4gJiYgKGJsb2NrLmNoaWxkcmVuLmZpbHRlcigoc3BhbikgPT4gc3Bhbi5fa2V5ID09PSB1cGRhdGVkU3Bhbi5fa2V5KS5sZW5ndGggPT09IDEgPyBwYXRjaGVzLnB1c2goc2V0KHVwZGF0ZWRTcGFuLnRleHQsIFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiB1cGRhdGVkU3Bhbi5fa2V5XG4gICAgICB9LCBcInRleHRcIl0pKSA6IGNvbnNvbGUud2FybihgTXVsdGlwbGUgc3BhbnMgaGF2ZSBcXGBfa2V5XFxgICR7dXBkYXRlZFNwYW4uX2tleX0uIEl0J3MgYW1iaWd1b3VzIHdoaWNoIG9uZSB0byB1cGRhdGUuYCwgSlNPTi5zdHJpbmdpZnkoYmxvY2ssIG51bGwsIDIpKSksIHJlbW92ZWRTcGFuICYmIChibG9jay5jaGlsZHJlbi5maWx0ZXIoKHNwYW4pID0+IHNwYW4uX2tleSA9PT0gcmVtb3ZlZFNwYW4uX2tleSkubGVuZ3RoID09PSAxID8gcGF0Y2hlcy5wdXNoKHVuc2V0KFt7XG4gICAgICAgIF9rZXk6IGJsb2NrLl9rZXlcbiAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBfa2V5OiByZW1vdmVkU3Bhbi5fa2V5XG4gICAgICB9XSkpIDogY29uc29sZS53YXJuKGBNdWx0aXBsZSBzcGFucyBoYXZlIFxcYF9rZXlcXGAgJHtyZW1vdmVkU3Bhbi5fa2V5fS4gSXQncyBhbWJpZ3VvdXMgd2hpY2ggb25lIHRvIHJlbW92ZS5gLCBKU09OLnN0cmluZ2lmeShibG9jaywgbnVsbCwgMikpKTtcbiAgICB9IGVsc2VcbiAgICAgIGRlYnVnJGcoXCJWb2lkIG5vZGVzIGNhbid0IGJlIG1lcmdlZCwgbm90IGNyZWF0aW5nIGFueSBwYXRjaGVzXCIpO1xuICAgIHJldHVybiBwYXRjaGVzO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmVOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIGJlZm9yZVZhbHVlKSB7XG4gICAgY29uc3QgcGF0Y2hlcyA9IFtdLCBibG9jayA9IGJlZm9yZVZhbHVlW29wZXJhdGlvbi5wYXRoWzBdXSwgdGFyZ2V0QmxvY2sgPSBiZWZvcmVWYWx1ZVtvcGVyYXRpb24ubmV3UGF0aFswXV07XG4gICAgaWYgKCF0YXJnZXRCbG9jaylcbiAgICAgIHJldHVybiBwYXRjaGVzO1xuICAgIGlmIChvcGVyYXRpb24ucGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gb3BlcmF0aW9uLnBhdGhbMF0gPiBvcGVyYXRpb24ubmV3UGF0aFswXSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCI7XG4gICAgICBwYXRjaGVzLnB1c2godW5zZXQoW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfV0pKSwgcGF0Y2hlcy5wdXNoKGluc2VydChbZnJvbVNsYXRlVmFsdWUoW2Jsb2NrXSwgdGV4dEJsb2NrTmFtZSlbMF1dLCBwb3NpdGlvbiwgW3tcbiAgICAgICAgX2tleTogdGFyZ2V0QmxvY2suX2tleVxuICAgICAgfV0pKTtcbiAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA9PT0gMiAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIGVkaXRvci5pc1RleHRCbG9jayh0YXJnZXRCbG9jaykpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW5bb3BlcmF0aW9uLnBhdGhbMV1dLCB0YXJnZXRDaGlsZCA9IHRhcmdldEJsb2NrLmNoaWxkcmVuW29wZXJhdGlvbi5uZXdQYXRoWzFdXSwgcG9zaXRpb24gPSBvcGVyYXRpb24ubmV3UGF0aFsxXSA9PT0gdGFyZ2V0QmxvY2suY2hpbGRyZW4ubGVuZ3RoID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIiwgY2hpbGRUb0luc2VydCA9IGZyb21TbGF0ZVZhbHVlKFtibG9ja10sIHRleHRCbG9ja05hbWUpWzBdLmNoaWxkcmVuW29wZXJhdGlvbi5wYXRoWzFdXTtcbiAgICAgIHBhdGNoZXMucHVzaCh1bnNldChbe1xuICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogY2hpbGQuX2tleVxuICAgICAgfV0pKSwgcGF0Y2hlcy5wdXNoKGluc2VydChbY2hpbGRUb0luc2VydF0sIHBvc2l0aW9uLCBbe1xuICAgICAgICBfa2V5OiB0YXJnZXRCbG9jay5fa2V5XG4gICAgICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgX2tleTogdGFyZ2V0Q2hpbGQuX2tleVxuICAgICAgfV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGNoZXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpbnNlcnROb2RlUGF0Y2gsXG4gICAgaW5zZXJ0VGV4dFBhdGNoLFxuICAgIG1lcmdlTm9kZVBhdGNoLFxuICAgIG1vdmVOb2RlUGF0Y2gsXG4gICAgcmVtb3ZlTm9kZVBhdGNoLFxuICAgIHJlbW92ZVRleHRQYXRjaCxcbiAgICBzZXROb2RlUGF0Y2gsXG4gICAgc3BsaXROb2RlUGF0Y2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhFdmVudExpc3RlbmVycyhlZGl0b3JBY3Rvciwgc3Vic2NyaXB0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5tYXhCbG9ja3MgIT09IHZvaWQgMCB8fCAoc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGVkaXRvckFjdG9yLm9uKFwiKlwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFubm90YXRpb24uYWRkXCI6IHtcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFubm90YXRpb24uYWRkXCIsXG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbjogZXZlbnQuYW5ub3RhdGlvblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLnJlbW92ZVwiOiB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhbm5vdGF0aW9uLnJlbW92ZVwiLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb246IGV2ZW50LmFubm90YXRpb25cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi50b2dnbGVcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYW5ub3RhdGlvbi50b2dnbGVcIixcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uOiBldmVudC5hbm5vdGF0aW9uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImJsdXJcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYmx1clwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImRlY29yYXRvci5hZGRcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLmFkZFwiLFxuICAgICAgICAgICAgICAgIGRlY29yYXRvcjogZXZlbnQuZGVjb3JhdG9yXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImRlY29yYXRvci5yZW1vdmVcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnJlbW92ZVwiLFxuICAgICAgICAgICAgICAgIGRlY29yYXRvcjogZXZlbnQuZGVjb3JhdG9yXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImRlY29yYXRvci50b2dnbGVcIjoge1xuICAgICAgICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLnRvZ2dsZVwiLFxuICAgICAgICAgICAgICAgIGRlY29yYXRvcjogZXZlbnQuZGVjb3JhdG9yXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImZvY3VzXCI6IHtcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZvY3VzXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiaW5zZXJ0LmJsb2NrIG9iamVjdFwiOiB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2sgb2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBldmVudC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgYmxvY2tPYmplY3Q6IGV2ZW50LmJsb2NrT2JqZWN0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImluc2VydC5pbmxpbmUgb2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImluc2VydC5pbmxpbmUgb2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgaW5saW5lT2JqZWN0OiBldmVudC5pbmxpbmVPYmplY3RcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibGlzdCBpdGVtLnRvZ2dsZVwiOiB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJsaXN0IGl0ZW0udG9nZ2xlXCIsXG4gICAgICAgICAgICAgICAgbGlzdEl0ZW06IGV2ZW50Lmxpc3RJdGVtXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInN0eWxlLnRvZ2dsZVwiOiB7XG4gICAgICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHlsZS50b2dnbGVcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogZXZlbnQuc3R5bGVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSksIGVkaXRvci5hZGRNYXJrID0gKG1hcmspID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci5hZGRcIixcbiAgICAgICAgICBkZWNvcmF0b3I6IG1hcmtcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IucmVtb3ZlTWFyayA9IChtYXJrKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkZWNvcmF0b3IucmVtb3ZlXCIsXG4gICAgICAgICAgZGVjb3JhdG9yOiBtYXJrXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkID0gKHVuaXQpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlbGV0ZS5iYWNrd2FyZFwiLFxuICAgICAgICAgIHVuaXRcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IuZGVsZXRlRm9yd2FyZCA9ICh1bml0KSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJkZWxldGUuZm9yd2FyZFwiLFxuICAgICAgICAgIHVuaXRcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3IuaW5zZXJ0QnJlYWsgPSAoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJpbnNlcnQuYnJlYWtcIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sIGVkaXRvci5pbnNlcnRTb2Z0QnJlYWsgPSAoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogXCJpbnNlcnQuc29mdCBicmVha1wiXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSwgZWRpdG9yLmluc2VydFRleHQgPSAodGV4dCwgb3B0aW9ucykgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwiaW5zZXJ0LnRleHRcIixcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9KSwgZWRpdG9yO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlV2l0aE1heEJsb2NrcyhlZGl0b3JBY3Rvcikge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MlxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGlmIChlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgICAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gICAgICB9KSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcGVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRvaW5nKGVkaXRvcikgfHwgaXNSZWRvaW5nKGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvd3MgPSBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQubWF4QmxvY2tzID8/IC0xO1xuICAgICAgcm93cyA+IDAgJiYgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+PSByb3dzICYmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiIHx8IG9wZXJhdGlvbi50eXBlID09PSBcInNwbGl0X25vZGVcIikgJiYgb3BlcmF0aW9uLnBhdGgubGVuZ3RoID09PSAxIHx8IGFwcGx5MihvcGVyYXRpb24pO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdpdGhPYmplY3RLZXlzKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcykge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXBwbHk6IGFwcGx5MixcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3IuYXBwbHkgPSAob3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAoaXNDaGFuZ2luZ1JlbW90ZWx5KGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBcInNwbGl0X25vZGVcIikge1xuICAgICAgICBhcHBseTIoe1xuICAgICAgICAgIC4uLm9wZXJhdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAuLi5vcGVyYXRpb24ucHJvcGVydGllcyxcbiAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiICYmICFFZGl0b3IuaXNFZGl0b3Iob3BlcmF0aW9uLm5vZGUpKSB7XG4gICAgICAgIGFwcGx5Mih7XG4gICAgICAgICAgLi4ub3BlcmF0aW9uLFxuICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgIC4uLm9wZXJhdGlvbi5ub2RlLFxuICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBwbHkyKG9wZXJhdGlvbik7XG4gICAgfSwgZWRpdG9yLm5vcm1hbGl6ZU5vZGUgPSAoZW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuYmxvY2submFtZSkge1xuICAgICAgICBpZiAoIW5vZGUuX2tleSkge1xuICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKClcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICBpZiAoIWNoaWxkLl9rZXkpIHtcbiAgICAgICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKClcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9ybWFsaXplTm9kZShlbnRyeSk7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZGVidWckZiA9IGRlYnVnV2l0aE5hbWUoXCJhcHBseVBhdGNoZXNcIiksIGRlYnVnVmVyYm9zZSQyID0gZGVidWckZi5lbmFibGVkICYmICEwO1xuZnVuY3Rpb24gY3JlYXRlQXBwbHlQYXRjaChzY2hlbWFUeXBlcykge1xuICByZXR1cm4gKGVkaXRvciwgcGF0Y2gpID0+IHtcbiAgICBsZXQgY2hhbmdlZCA9ICExO1xuICAgIGRlYnVnVmVyYm9zZSQyICYmIChkZWJ1ZyRmKGBcblxuTkVXIFBBVENIID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1gKSwgZGVidWckZihKU09OLnN0cmluZ2lmeShwYXRjaCwgbnVsbCwgMikpKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChwYXRjaC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gaW5zZXJ0UGF0Y2goZWRpdG9yLCBwYXRjaCwgc2NoZW1hVHlwZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidW5zZXRcIjpcbiAgICAgICAgICBjaGFuZ2VkID0gdW5zZXRQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIGNoYW5nZWQgPSBzZXRQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRpZmZNYXRjaFBhdGNoXCI6XG4gICAgICAgICAgY2hhbmdlZCA9IGRpZmZNYXRjaFBhdGNoKGVkaXRvciwgcGF0Y2gpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlYnVnJGYoXCJVbmhhbmRsZWQgcGF0Y2hcIiwgcGF0Y2gudHlwZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9O1xufVxuZnVuY3Rpb24gZGlmZk1hdGNoUGF0Y2goZWRpdG9yLCBwYXRjaCkge1xuICBjb25zdCB7XG4gICAgYmxvY2ssXG4gICAgY2hpbGQsXG4gICAgY2hpbGRQYXRoXG4gIH0gPSBmaW5kQmxvY2tBbmRDaGlsZEZyb21QYXRoKGVkaXRvciwgcGF0Y2gucGF0aCk7XG4gIGlmICghYmxvY2spXG4gICAgcmV0dXJuIGRlYnVnJGYoXCJCbG9jayBub3QgZm91bmRcIiksICExO1xuICBpZiAoIWNoaWxkIHx8ICFjaGlsZFBhdGgpXG4gICAgcmV0dXJuIGRlYnVnJGYoXCJDaGlsZCBub3QgZm91bmRcIiksICExO1xuICBpZiAoIShibG9jayAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIHBhdGNoLnBhdGgubGVuZ3RoID09PSA0ICYmIHBhdGNoLnBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIiAmJiBwYXRjaC5wYXRoWzNdID09PSBcInRleHRcIikgfHwgIVRleHQuaXNUZXh0KGNoaWxkKSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHBhdGNoZXMgPSBwYXJzZShwYXRjaC52YWx1ZSksIFtuZXdWYWx1ZV0gPSBhcHBseShwYXRjaGVzLCBjaGlsZC50ZXh0LCB7XG4gICAgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiAhMFxuICB9KSwgZGlmZiQxID0gY2xlYW51cEVmZmljaWVuY3koZGlmZihjaGlsZC50ZXh0LCBuZXdWYWx1ZSksIDUpO1xuICBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIik7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IFtvcCwgdGV4dF0gb2YgZGlmZiQxKVxuICAgIG9wID09PSBESUZGX0lOU0VSVCA/IChlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogXCJpbnNlcnRfdGV4dFwiLFxuICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGV4dFxuICAgIH0pLCBvZmZzZXQgKz0gdGV4dC5sZW5ndGgpIDogb3AgPT09IERJRkZfREVMRVRFID8gZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6IFwicmVtb3ZlX3RleHRcIixcbiAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgIG9mZnNldCxcbiAgICAgIHRleHRcbiAgICB9KSA6IG9wID09PSBESUZGX0VRVUFMICYmIChvZmZzZXQgKz0gdGV4dC5sZW5ndGgpO1xuICByZXR1cm4gZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xufVxuZnVuY3Rpb24gaW5zZXJ0UGF0Y2goZWRpdG9yLCBwYXRjaCwgc2NoZW1hVHlwZXMpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrOiB0YXJnZXRCbG9jayxcbiAgICBjaGlsZDogdGFyZ2V0Q2hpbGQsXG4gICAgYmxvY2tQYXRoOiB0YXJnZXRCbG9ja1BhdGgsXG4gICAgY2hpbGRQYXRoOiB0YXJnZXRDaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKCF0YXJnZXRCbG9jayB8fCAhdGFyZ2V0QmxvY2tQYXRoKVxuICAgIHJldHVybiBkZWJ1ZyRmKFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID4gMSAmJiBwYXRjaC5wYXRoWzFdICE9PSBcImNoaWxkcmVuXCIpXG4gICAgcmV0dXJuIGRlYnVnJGYoXCJJZ25vcmluZyBwYXRjaCB0YXJnZXRpbmcgdm9pZCB2YWx1ZVwiKSwgITE7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW1zOiBpdGVtczIsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24yXG4gICAgfSA9IHBhdGNoLCBibG9ja3NUb0luc2VydCA9IHRvU2xhdGVWYWx1ZShpdGVtczIsIHtcbiAgICAgIHNjaGVtYVR5cGVzXG4gICAgfSwgS0VZX1RPX1NMQVRFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCB0YXJnZXRCbG9ja0luZGV4ID0gdGFyZ2V0QmxvY2tQYXRoWzBdLCBub3JtYWxpemVkSWR4MiA9IHBvc2l0aW9uMiA9PT0gXCJhZnRlclwiID8gdGFyZ2V0QmxvY2tJbmRleCArIDEgOiB0YXJnZXRCbG9ja0luZGV4O1xuICAgIHJldHVybiBkZWJ1ZyRmKGBJbnNlcnRpbmcgYmxvY2tzIGF0IHBhdGggWyR7bm9ybWFsaXplZElkeDJ9XWApLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBibG9ja3NUb0luc2VydCwge1xuICAgICAgYXQ6IFtub3JtYWxpemVkSWR4Ml1cbiAgICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpdGVtcyxcbiAgICBwb3NpdGlvblxuICB9ID0gcGF0Y2g7XG4gIGlmICghdGFyZ2V0Q2hpbGQgfHwgIXRhcmdldENoaWxkUGF0aClcbiAgICByZXR1cm4gZGVidWckZihcIkNoaWxkIG5vdCBmb3VuZFwiKSwgITE7XG4gIGNvbnN0IGNoaWxkcmVuVG9JbnNlcnQgPSB0YXJnZXRCbG9jayAmJiB0b1NsYXRlVmFsdWUoW3tcbiAgICAuLi50YXJnZXRCbG9jayxcbiAgICBjaGlsZHJlbjogaXRlbXNcbiAgfV0sIHtcbiAgICBzY2hlbWFUeXBlc1xuICB9LCBLRVlfVE9fU0xBVEVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIHRhcmdldENoaWxkSW5kZXggPSB0YXJnZXRDaGlsZFBhdGhbMV0sIG5vcm1hbGl6ZWRJZHggPSBwb3NpdGlvbiA9PT0gXCJhZnRlclwiID8gdGFyZ2V0Q2hpbGRJbmRleCArIDEgOiB0YXJnZXRDaGlsZEluZGV4LCBjaGlsZEluc2VydFBhdGggPSBbdGFyZ2V0Q2hpbGRQYXRoWzBdLCBub3JtYWxpemVkSWR4XTtcbiAgcmV0dXJuIGRlYnVnJGYoYEluc2VydGluZyBjaGlsZHJlbiBhdCBwYXRoICR7Y2hpbGRJbnNlcnRQYXRofWApLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIGNoaWxkcmVuVG9JbnNlcnQgJiYgRWxlbWVudCQxLmlzRWxlbWVudChjaGlsZHJlblRvSW5zZXJ0WzBdKSAmJiBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgY2hpbGRyZW5Ub0luc2VydFswXS5jaGlsZHJlbiwge1xuICAgIGF0OiBjaGlsZEluc2VydFBhdGhcbiAgfSksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImFmdGVyXCIpLCAhMDtcbn1cbmZ1bmN0aW9uIHNldFBhdGNoKGVkaXRvciwgcGF0Y2gpIHtcbiAgbGV0IHZhbHVlID0gcGF0Y2gudmFsdWU7XG4gIHR5cGVvZiBwYXRjaC5wYXRoWzNdID09IFwic3RyaW5nXCIgJiYgKHZhbHVlID0ge30sIHZhbHVlW3BhdGNoLnBhdGhbM11dID0gcGF0Y2gudmFsdWUpO1xuICBjb25zdCB7XG4gICAgYmxvY2ssXG4gICAgYmxvY2tQYXRoLFxuICAgIGNoaWxkLFxuICAgIGNoaWxkUGF0aFxuICB9ID0gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGNoLnBhdGgpO1xuICBpZiAoIWJsb2NrKVxuICAgIHJldHVybiBkZWJ1ZyRmKFwiQmxvY2sgbm90IGZvdW5kXCIpLCAhMTtcbiAgY29uc3QgaXNUZXh0QmxvY2sgPSBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spO1xuICBpZiAoaXNUZXh0QmxvY2sgJiYgcGF0Y2gucGF0aC5sZW5ndGggPiAxICYmIHBhdGNoLnBhdGhbMV0gIT09IFwiY2hpbGRyZW5cIilcbiAgICByZXR1cm4gZGVidWckZihcIklnbm9yaW5nIHNldHRpbmcgdm9pZCB2YWx1ZVwiKSwgITE7XG4gIGlmIChkZWJ1Z1N0YXRlKGVkaXRvciwgXCJiZWZvcmVcIiksIGlzVGV4dEJsb2NrICYmIGNoaWxkICYmIGNoaWxkUGF0aCkge1xuICAgIGlmIChUZXh0LmlzVGV4dCh2YWx1ZSkgJiYgVGV4dC5pc1RleHQoY2hpbGQpKSB7XG4gICAgICBjb25zdCBuZXdUZXh0ID0gY2hpbGQudGV4dDtcbiAgICAgIHZhbHVlLnRleHQgIT09IG5ld1RleHQgJiYgKGRlYnVnJGYoXCJTZXR0aW5nIHRleHQgcHJvcGVydHlcIiksIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwicmVtb3ZlX3RleHRcIixcbiAgICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIHRleHQ6IG5ld1RleHRcbiAgICAgIH0pLCBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiBcImluc2VydF90ZXh0XCIsXG4gICAgICAgIHBhdGg6IGNoaWxkUGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICB0ZXh0OiB2YWx1ZS50ZXh0XG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgIH0gZWxzZVxuICAgICAgZGVidWckZihcIlNldHRpbmcgbm9uLXRleHQgcHJvcGVydHlcIiksIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwic2V0X25vZGVcIixcbiAgICAgICAgcGF0aDogY2hpbGRQYXRoLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgbmV3UHJvcGVydGllczogdmFsdWVcbiAgICAgIH0pO1xuICAgIHJldHVybiAhMDtcbiAgfSBlbHNlIGlmIChFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMSAmJiBibG9ja1BhdGgpIHtcbiAgICBkZWJ1ZyRmKFwiU2V0dGluZyBibG9jayBwcm9wZXJ0eVwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIC4uLm5leHRSZXN0XG4gICAgfSA9IHZhbHVlLCB7XG4gICAgICBjaGlsZHJlbjogcHJldkNoaWxkcmVuLFxuICAgICAgLi4ucHJldlJlc3RcbiAgICB9ID0gYmxvY2sgfHwge1xuICAgICAgY2hpbGRyZW46IHZvaWQgMFxuICAgIH07XG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6IFwic2V0X25vZGVcIixcbiAgICAgIHBhdGg6IGJsb2NrUGF0aCxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLi4ucHJldlJlc3RcbiAgICAgIH0sXG4gICAgICBuZXdQcm9wZXJ0aWVzOiBuZXh0UmVzdFxuICAgIH0pLCBkZWJ1ZyRmKFwiU2V0dGluZyBjaGlsZHJlblwiKSwgYmxvY2suY2hpbGRyZW4uZm9yRWFjaCgoYzIsIGNJbmRleCkgPT4ge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogXCJyZW1vdmVfbm9kZVwiLFxuICAgICAgICBwYXRoOiBibG9ja1BhdGguY29uY2F0KGJsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDEgLSBjSW5kZXgpLFxuICAgICAgICBub2RlOiBjMlxuICAgICAgfSk7XG4gICAgfSksIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmZvckVhY2goKGMyLCBjSW5kZXgpID0+IHtcbiAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6IFwiaW5zZXJ0X25vZGVcIixcbiAgICAgICAgcGF0aDogYmxvY2tQYXRoLmNvbmNhdChjSW5kZXgpLFxuICAgICAgICBub2RlOiBjMlxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoYmxvY2sgJiYgXCJ2YWx1ZVwiIGluIGJsb2NrKSB7XG4gICAgY29uc3QgbmV3VmFsID0gYXBwbHlBbGwoW2Jsb2NrLnZhbHVlXSwgW3BhdGNoXSlbMF07XG4gICAgcmV0dXJuIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAuLi5ibG9jayxcbiAgICAgIHZhbHVlOiBuZXdWYWxcbiAgICB9LCB7XG4gICAgICBhdDogYmxvY2tQYXRoXG4gICAgfSksICEwO1xuICB9XG4gIHJldHVybiBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG59XG5mdW5jdGlvbiB1bnNldFBhdGNoKGVkaXRvciwgcGF0Y2gpIHtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgZGVidWckZihcIlJlbW92aW5nIGV2ZXJ5dGhpbmdcIiksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKTtcbiAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgcmV0dXJuIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKSwgZWRpdG9yLmNoaWxkcmVuLmZvckVhY2goKF9jaGlsZCwgaSkgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IFtpXVxuICAgICAgfSk7XG4gICAgfSksIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgIGRlY29yYXRvcnM6IFtdXG4gICAgfSkpLCBwcmV2aW91c1NlbGVjdGlvbiAmJiBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IFswLCAwXSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfSksIGVkaXRvci5vbkNoYW5nZSgpLCBkZWJ1Z1N0YXRlKGVkaXRvciwgXCJhZnRlclwiKSwgITA7XG4gIH1cbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZCxcbiAgICBjaGlsZFBhdGhcbiAgfSA9IGZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgoZWRpdG9yLCBwYXRjaC5wYXRoKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKCFibG9jayB8fCAhYmxvY2tQYXRoKVxuICAgICAgcmV0dXJuIGRlYnVnJGYoXCJCbG9jayBub3QgZm91bmRcIiksICExO1xuICAgIGNvbnN0IGJsb2NrSW5kZXggPSBibG9ja1BhdGhbMF07XG4gICAgcmV0dXJuIGRlYnVnJGYoYFJlbW92aW5nIGJsb2NrIGF0IHBhdGggWyR7YmxvY2tJbmRleH1dYCksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBbYmxvY2tJbmRleF1cbiAgICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwO1xuICB9XG4gIHJldHVybiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIHBhdGNoLnBhdGhbMV0gPT09IFwiY2hpbGRyZW5cIiAmJiBwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMyA/ICFjaGlsZCB8fCAhY2hpbGRQYXRoID8gKGRlYnVnJGYoXCJDaGlsZCBub3QgZm91bmRcIiksICExKSA6IChkZWJ1ZyRmKGBVbnNldHRpbmcgY2hpbGQgYXQgcGF0aCAke0pTT04uc3RyaW5naWZ5KGNoaWxkUGF0aCl9YCksIGRlYnVnU3RhdGUoZWRpdG9yLCBcImJlZm9yZVwiKSwgZGVidWdWZXJib3NlJDIgJiYgZGVidWckZihgUmVtb3ZpbmcgY2hpbGQgYXQgcGF0aCAke0pTT04uc3RyaW5naWZ5KGNoaWxkUGF0aCl9YCksIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IGNoaWxkUGF0aFxuICB9KSwgZGVidWdTdGF0ZShlZGl0b3IsIFwiYWZ0ZXJcIiksICEwKSA6ICExO1xufVxuZnVuY3Rpb24gaXNLZXllZFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJvYmplY3RcIiAmJiBcIl9rZXlcIiBpbiBzZWdtZW50O1xufVxuZnVuY3Rpb24gZGVidWdTdGF0ZShlZGl0b3IsIHN0YXRlTmFtZSkge1xuICBkZWJ1Z1ZlcmJvc2UkMiAmJiAoZGVidWckZihgQ2hpbGRyZW4gJHtzdGF0ZU5hbWV9OmAsIEpTT04uc3RyaW5naWZ5KGVkaXRvci5jaGlsZHJlbiwgbnVsbCwgMikpLCBkZWJ1ZyRmKGBTZWxlY3Rpb24gJHtzdGF0ZU5hbWV9OiBgLCBKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uLCBudWxsLCAyKSkpO1xufVxuZnVuY3Rpb24gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKSB7XG4gIGxldCBibG9ja0luZGV4ID0gLTE7XG4gIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaCA9IGlzS2V5ZWRTZWdtZW50KHBhdGhbMF0pID8gbm9kZS5fa2V5ID09PSBwYXRoWzBdLl9rZXkgOiBpbmRleCA9PT0gcGF0aFswXTtcbiAgICByZXR1cm4gaXNNYXRjaCAmJiAoYmxvY2tJbmRleCA9IGluZGV4KSwgaXNNYXRjaDtcbiAgfSk7XG4gIHJldHVybiBibG9jayA/IHtcbiAgICBibG9jayxcbiAgICBwYXRoOiBbYmxvY2tJbmRleF1cbiAgfSA6IHt9O1xufVxuZnVuY3Rpb24gZmluZEJsb2NrQW5kQ2hpbGRGcm9tUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgY29uc3Qge1xuICAgIGJsb2NrLFxuICAgIHBhdGg6IGJsb2NrUGF0aFxuICB9ID0gZmluZEJsb2NrRnJvbVBhdGgoZWRpdG9yLCBwYXRoKTtcbiAgaWYgKCEoRWxlbWVudCQxLmlzRWxlbWVudChibG9jaykgJiYgcGF0aFsxXSA9PT0gXCJjaGlsZHJlblwiKSlcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2ssXG4gICAgICBibG9ja1BhdGgsXG4gICAgICBjaGlsZDogdm9pZCAwLFxuICAgICAgY2hpbGRQYXRoOiB2b2lkIDBcbiAgICB9O1xuICBsZXQgY2hpbGRJbmRleCA9IC0xO1xuICBjb25zdCBjaGlsZCA9IGJsb2NrLmNoaWxkcmVuLmZpbmQoKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaCA9IGlzS2V5ZWRTZWdtZW50KHBhdGhbMl0pID8gbm9kZS5fa2V5ID09PSBwYXRoWzJdLl9rZXkgOiBpbmRleCA9PT0gcGF0aFsyXTtcbiAgICByZXR1cm4gaXNNYXRjaCAmJiAoY2hpbGRJbmRleCA9IGluZGV4KSwgaXNNYXRjaDtcbiAgfSk7XG4gIHJldHVybiBjaGlsZCA/IHtcbiAgICBibG9jayxcbiAgICBjaGlsZCxcbiAgICBibG9ja1BhdGgsXG4gICAgY2hpbGRQYXRoOiBibG9ja1BhdGg/LmNvbmNhdChjaGlsZEluZGV4KVxuICB9IDoge1xuICAgIGJsb2NrLFxuICAgIGJsb2NrUGF0aCxcbiAgICBjaGlsZDogdm9pZCAwLFxuICAgIGNoaWxkUGF0aDogdm9pZCAwXG4gIH07XG59XG5jb25zdCBkZWJ1ZyRlID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUGF0Y2hlc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQYXRjaGVzKHtcbiAgZWRpdG9yQWN0b3IsXG4gIHBhdGNoRnVuY3Rpb25zLFxuICBzY2hlbWFUeXBlcyxcbiAgc3Vic2NyaXB0aW9uc1xufSkge1xuICBsZXQgcHJldmlvdXNDaGlsZHJlbjtcbiAgY29uc3QgYXBwbHlQYXRjaCA9IGNyZWF0ZUFwcGx5UGF0Y2goc2NoZW1hVHlwZXMpO1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUy5zZXQoZWRpdG9yLCAhMSksIFBBVENISU5HLnNldChlZGl0b3IsICEwKSwgcHJldmlvdXNDaGlsZHJlbiA9IFsuLi5lZGl0b3IuY2hpbGRyZW5dO1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGx5OiBhcHBseTJcbiAgICB9ID0gZWRpdG9yO1xuICAgIGxldCBidWZmZXJlZFBhdGNoZXMgPSBbXTtcbiAgICBjb25zdCBoYW5kbGVCdWZmZXJlZFJlbW90ZVBhdGNoZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoYnVmZmVyZWRQYXRjaGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcGF0Y2hlcyA9IGJ1ZmZlcmVkUGF0Y2hlcztcbiAgICAgIGJ1ZmZlcmVkUGF0Y2hlcyA9IFtdO1xuICAgICAgbGV0IGNoYW5nZWQgPSAhMTtcbiAgICAgIHdpdGhSZW1vdGVDaGFuZ2VzKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHdpdGhvdXRQYXRjaGluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIHdpdGhvdXRTYXZpbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHBhdGNoZXMuZm9yRWFjaCgocGF0Y2gpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyRlLmVuYWJsZWQgJiYgZGVidWckZShgSGFuZGxpbmcgcmVtb3RlIHBhdGNoICR7SlNPTi5zdHJpbmdpZnkocGF0Y2gpfWApLCBjaGFuZ2VkID0gYXBwbHlQYXRjaChlZGl0b3IsIHBhdGNoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGNoYW5nZWQgJiYgKGVkaXRvci5ub3JtYWxpemUoKSwgZWRpdG9yLm9uQ2hhbmdlKCkpO1xuICAgICAgfSk7XG4gICAgfSwgaGFuZGxlUGF0Y2hlcyA9ICh7XG4gICAgICBwYXRjaGVzXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgcmVtb3RlUGF0Y2hlcyA9IHBhdGNoZXMuZmlsdGVyKChwKSA9PiBwLm9yaWdpbiAhPT0gXCJsb2NhbFwiKTtcbiAgICAgIHJlbW90ZVBhdGNoZXMubGVuZ3RoICE9PSAwICYmIChidWZmZXJlZFBhdGNoZXMgPSBidWZmZXJlZFBhdGNoZXMuY29uY2F0KHJlbW90ZVBhdGNoZXMpLCBoYW5kbGVCdWZmZXJlZFJlbW90ZVBhdGNoZXMoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9ucy5wdXNoKCgpID0+IHtcbiAgICAgIGRlYnVnJGUoXCJTdWJzY3JpYmluZyB0byByZW1vdGUgcGF0Y2hlc1wiKTtcbiAgICAgIGNvbnN0IHN1YiA9IGVkaXRvckFjdG9yLm9uKFwicGF0Y2hlc1wiLCBoYW5kbGVQYXRjaGVzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlYnVnJGUoXCJVbnN1YnNjcmliaW5nIHRvIHJlbW90ZSBwYXRjaGVzXCIpLCBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSksIGVkaXRvci5hcHBseSA9IChvcGVyYXRpb24pID0+IHtcbiAgICAgIGxldCBwYXRjaGVzID0gW107XG4gICAgICBwcmV2aW91c0NoaWxkcmVuID0gZWRpdG9yLmNoaWxkcmVuO1xuICAgICAgY29uc3QgZWRpdG9yV2FzRW1wdHkgPSBpc0VxdWFsVG9FbXB0eUVkaXRvcihwcmV2aW91c0NoaWxkcmVuLCBzY2hlbWFUeXBlcyk7XG4gICAgICBhcHBseTIob3BlcmF0aW9uKTtcbiAgICAgIGNvbnN0IGVkaXRvcklzRW1wdHkgPSBpc0VxdWFsVG9FbXB0eUVkaXRvcihlZGl0b3IuY2hpbGRyZW4sIHNjaGVtYVR5cGVzKTtcbiAgICAgIGlmICghaXNQYXRjaGluZyhlZGl0b3IpKVxuICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgICAgc3dpdGNoIChlZGl0b3JXYXNFbXB0eSAmJiAhZWRpdG9ySXNFbXB0eSAmJiBvcGVyYXRpb24udHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgcGF0Y2hlcy5wdXNoKGluc2VydChwcmV2aW91c0NoaWxkcmVuLCBcImJlZm9yZVwiLCBbMF0pKSwgb3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImluc2VydF90ZXh0XCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5pbnNlcnRUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlbW92ZV90ZXh0XCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5yZW1vdmVUZXh0UGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlbW92ZV9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5yZW1vdmVOb2RlUGF0Y2goZWRpdG9yLCBvcGVyYXRpb24sIHByZXZpb3VzQ2hpbGRyZW4pXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNwbGl0X25vZGVcIjpcbiAgICAgICAgICBwYXRjaGVzID0gWy4uLnBhdGNoZXMsIC4uLnBhdGNoRnVuY3Rpb25zLnNwbGl0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMuaW5zZXJ0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZXRfbm9kZVwiOlxuICAgICAgICAgIHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgLi4ucGF0Y2hGdW5jdGlvbnMuc2V0Tm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXJnZV9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5tZXJnZU5vZGVQYXRjaChlZGl0b3IsIG9wZXJhdGlvbiwgcHJldmlvdXNDaGlsZHJlbildO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW92ZV9ub2RlXCI6XG4gICAgICAgICAgcGF0Y2hlcyA9IFsuLi5wYXRjaGVzLCAuLi5wYXRjaEZ1bmN0aW9ucy5tb3ZlTm9kZVBhdGNoKGVkaXRvciwgb3BlcmF0aW9uLCBwcmV2aW91c0NoaWxkcmVuKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gIWVkaXRvcldhc0VtcHR5ICYmIGVkaXRvcklzRW1wdHkgJiYgW1wibWVyZ2Vfbm9kZVwiLCBcInNldF9ub2RlXCIsIFwicmVtb3ZlX3RleHRcIiwgXCJyZW1vdmVfbm9kZVwiXS5pbmNsdWRlcyhvcGVyYXRpb24udHlwZSkgJiYgKHBhdGNoZXMgPSBbLi4ucGF0Y2hlcywgdW5zZXQoW10pXSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwidW5zZXRcIixcbiAgICAgICAgcHJldmlvdXNWYWx1ZTogZnJvbVNsYXRlVmFsdWUocHJldmlvdXNDaGlsZHJlbiwgc2NoZW1hVHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpXG4gICAgICB9KSksIGVkaXRvcldhc0VtcHR5ICYmIHBhdGNoZXMubGVuZ3RoID4gMCAmJiAocGF0Y2hlcyA9IFtzZXRJZk1pc3NpbmcoW10sIFtdKSwgLi4ucGF0Y2hlc10pLCBwYXRjaGVzLmxlbmd0aCA+IDAgJiYgcGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInBhdGNoXCIsXG4gICAgICAgICAgcGF0Y2g6IHtcbiAgICAgICAgICAgIC4uLnBhdGNoLFxuICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSksIGVkaXRvcjtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyRkID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoUGxhY2Vob2xkZXJCbG9ja1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQbGFjZWhvbGRlckJsb2NrKGVkaXRvckFjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLmFwcGx5ID0gKG9wKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5tYXRjaGVzKHtcbiAgICAgICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICAgICAgfSkpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2hhbmdpbmdSZW1vdGVseShlZGl0b3IpKSB7XG4gICAgICAgIGFwcGx5MihvcCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZG9pbmcoZWRpdG9yKSB8fCBpc1JlZG9pbmcoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJyZW1vdmVfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBvcC5ub2RlO1xuICAgICAgICBpZiAob3AucGF0aFswXSA9PT0gMCAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IFBhdGgubmV4dChvcC5wYXRoKTtcbiAgICAgICAgICBlZGl0b3IuY2hpbGRyZW5bbmV4dFBhdGhbMF1dIHx8IChkZWJ1ZyRkKFwiQWRkaW5nIHBsYWNlaG9sZGVyIGJsb2NrXCIpLCBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseTIob3ApO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJGMgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGUoZWRpdG9yQWN0b3IsIHR5cGVzKSB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHR5cGVzLnN0eWxlc1swXS52YWx1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vcm1hbGl6ZU5vZGVcbiAgICB9ID0gZWRpdG9yO1xuICAgIHJldHVybiBlZGl0b3Iubm9ybWFsaXplTm9kZSA9IChub2RlRW50cnkpID0+IHtcbiAgICAgIGNvbnN0IFssIHBhdGhdID0gbm9kZUVudHJ5O1xuICAgICAgZm9yIChjb25zdCBvcCBvZiBlZGl0b3Iub3BlcmF0aW9ucylcbiAgICAgICAgaWYgKG9wLnR5cGUgPT09IFwic3BsaXRfbm9kZVwiICYmIG9wLnBhdGgubGVuZ3RoID09PSAxICYmIGVkaXRvci5pc1RleHRCbG9jayhvcC5wcm9wZXJ0aWVzKSAmJiBvcC5wcm9wZXJ0aWVzLnN0eWxlICE9PSBkZWZhdWx0U3R5bGUgJiYgb3AucGF0aFswXSA9PT0gcGF0aFswXSAmJiAhUGF0aC5lcXVhbHMocGF0aCwgb3AucGF0aCkpIHtcbiAgICAgICAgICBjb25zdCBbY2hpbGRdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBbb3AucGF0aFswXSArIDEsIDBdKTtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQoY2hpbGQpICYmIGNoaWxkLnRleHQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGRlYnVnJGMoYE5vcm1hbGl6aW5nIHNwbGl0IG5vZGUgdG8gJHtkZWZhdWx0U3R5bGV9IHN0eWxlYCwgb3ApLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogW29wLnBhdGhbMF0gKyAxXSxcbiAgICAgICAgICAgICAgdm9pZHM6ICExXG4gICAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUobm9kZUVudHJ5KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFNwYW4obm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgXCJ0ZXh0XCIgaW4gbm9kZSAmJiB0eXBlb2Ygbm9kZS50ZXh0ID09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiBub2RlLm1hcmtzID4gXCJ1XCIgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSAmJiBub2RlLm1hcmtzLmV2ZXJ5KChtYXJrKSA9PiB0eXBlb2YgbWFyayA9PSBcInN0cmluZ1wiKSk7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBBIGJsb2NrIGRvZXNuJ3QgX2hhdmVfIHRvIGJlIG5hbWVkICdibG9jaycgLSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW5cbiAgICAvLyBhbGxvd2VkIGNoaWxkIHR5cGVzIGFuZCBtYXJrcywgb25lIG1pZ2h0IG5hbWUgdGhlbSBkaWZmZXJlbnRseVxuICAgIHR5cGVvZiBub2RlLl90eXBlID09IFwic3RyaW5nXCIgJiYgLy8gVG9vbGtpdC10eXBlcyBsaWtlIG5lc3RlZCBzcGFucyBhcmUgQC1wcmVmaXhlZFxuICAgIG5vZGUuX3R5cGVbMF0gIT09IFwiQFwiICYmIC8vIGBtYXJrRGVmc2AgaXNuJ3QgX3JlcXVpcmVkXyBwZXIgc2F5LCBidXQgaWYgaXQncyB0aGVyZSwgaXQgbmVlZHMgdG8gYmUgYW4gYXJyYXlcbiAgICAoIShcIm1hcmtEZWZzXCIgaW4gbm9kZSkgfHwgIW5vZGUubWFya0RlZnMgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtEZWZzKSAmJiAvLyBFdmVyeSBtYXJrIGRlZmluaXRpb24gbmVlZHMgdG8gaGF2ZSBhbiBgX2tleWAgdG8gYmUgbWFwcGFibGUgaW4gY2hpbGQgc3BhbnNcbiAgICBub2RlLm1hcmtEZWZzLmV2ZXJ5KChkZWYpID0+IHR5cGVvZiBkZWYuX2tleSA9PSBcInN0cmluZ1wiKSkgJiYgLy8gYGNoaWxkcmVuYCBpcyByZXF1aXJlZCBhbmQgbmVlZHMgdG8gYmUgYW4gYXJyYXlcbiAgICBcImNoaWxkcmVuXCIgaW4gbm9kZSAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pICYmIC8vIEFsbCBjaGlsZHJlbiBhcmUgb2JqZWN0cyB3aXRoIGBfdHlwZWAgKHVzdWFsbHkgc3BhbnMsIGJ1dCBjYW4gY29udGFpbiBvdGhlciBzdHVmZilcbiAgICBub2RlLmNoaWxkcmVuLmV2ZXJ5KChjaGlsZCkgPT4gdHlwZW9mIGNoaWxkID09IFwib2JqZWN0XCIgJiYgXCJfdHlwZVwiIGluIGNoaWxkKVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNTcGFuKHtcbiAgZWRpdG9yLFxuICBibG9ja1BhdGgsXG4gIHNwYW5QYXRoXG59KSB7XG4gIGxldCBwcmV2aW91c1NwYW47XG4gIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgsIHtcbiAgICByZXZlcnNlOiAhMFxuICB9KSlcbiAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNCZWZvcmUoY2hpbGRQYXRoLCBzcGFuUGF0aCkpIHtcbiAgICAgIHByZXZpb3VzU3BhbiA9IGNoaWxkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gcHJldmlvdXNTcGFuO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFNwYW4oe1xuICBlZGl0b3IsXG4gIGJsb2NrUGF0aCxcbiAgc3BhblBhdGhcbn0pIHtcbiAgbGV0IG5leHRTcGFuO1xuICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBOb2RlLmNoaWxkcmVuKGVkaXRvciwgYmxvY2tQYXRoKSlcbiAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNBZnRlcihjaGlsZFBhdGgsIHNwYW5QYXRoKSkge1xuICAgICAgbmV4dFNwYW4gPSBjaGlsZDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIG5leHRTcGFuO1xufVxuY29uc3QgZGVidWckYiA9IGRlYnVnV2l0aE5hbWUoXCJwbHVnaW46d2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwoZWRpdG9yQWN0b3IsIHR5cGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBhcHBseTogYXBwbHkyLFxuICAgICAgbm9ybWFsaXplTm9kZVxuICAgIH0gPSBlZGl0b3IsIGRlY29yYXRvcnMgPSB0eXBlcy5kZWNvcmF0b3JzLm1hcCgodCkgPT4gdC52YWx1ZSk7XG4gICAgcmV0dXJuIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKG5vZGVFbnRyeSkgPT4ge1xuICAgICAgY29uc3QgW25vZGUsIHBhdGhdID0gbm9kZUVudHJ5O1xuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGUuY2hpbGRyZW5bY2hpbGRQYXRoWzFdICsgMV07XG4gICAgICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSAmJiBlZGl0b3IuaXNUZXh0U3BhbihuZXh0Tm9kZSkgJiYgY2hpbGQubWFya3M/LmV2ZXJ5KChtYXJrKSA9PiBuZXh0Tm9kZS5tYXJrcz8uaW5jbHVkZXMobWFyaykpICYmIG5leHROb2RlLm1hcmtzPy5ldmVyeSgobWFyaykgPT4gY2hpbGQubWFya3M/LmluY2x1ZGVzKG1hcmspKSkge1xuICAgICAgICAgICAgZGVidWckYihcIk1lcmdpbmcgc3BhbnNcIiwgSlNPTi5zdHJpbmdpZnkoY2hpbGQsIG51bGwsIDIpLCBKU09OLnN0cmluZ2lmeShuZXh0Tm9kZSwgbnVsbCwgMikpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBhdDogW2NoaWxkUGF0aFswXSwgY2hpbGRQYXRoWzFdICsgMV0sXG4gICAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpICYmICFBcnJheS5pc0FycmF5KG5vZGUubWFya0RlZnMpKSB7XG4gICAgICAgIGRlYnVnJGIoXCJBZGRpbmcgLm1hcmtEZWZzIHRvIGJsb2NrIG5vZGVcIiksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBtYXJrRGVmczogW11cbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRTcGFuKG5vZGUpICYmICFBcnJheS5pc0FycmF5KG5vZGUubWFya3MpKSB7XG4gICAgICAgIGRlYnVnJGIoXCJBZGRpbmcgLm1hcmtzIHRvIHNwYW4gbm9kZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJub3JtYWxpemluZ1wiXG4gICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiBbXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiZG9uZSBub3JtYWxpemluZ1wiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4obm9kZSkpIHtcbiAgICAgICAgY29uc3QgYmxvY2tQYXRoID0gUGF0aC5wYXJlbnQocGF0aCksIFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGJsb2NrUGF0aCksIGRlY29yYXRvcnMyID0gdHlwZXMuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlKSwgYW5ub3RhdGlvbnMgPSBub2RlLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzMi5pbmNsdWRlcyhtYXJrKSk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spICYmIG5vZGUudGV4dCA9PT0gXCJcIiAmJiBhbm5vdGF0aW9ucyAmJiBhbm5vdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGVidWckYihcIlJlbW92aW5nIGFubm90YXRpb25zIGZyb20gZW1wdHkgc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pLCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya3M6IG5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhub2RlKSkge1xuICAgICAgICBjb25zdCBkZWNvcmF0b3JzMiA9IHR5cGVzLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXJrcyA9IGNoaWxkLm1hcmtzID8/IFtdLCBvcnBoYW5lZEFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9yczIuaW5jbHVkZXMobWFyaykgJiYgIW5vZGUubWFya0RlZnM/LmZpbmQoKGRlZikgPT4gZGVmLl9rZXkgPT09IG1hcmspKTtcbiAgICAgICAgICAgIGlmIChvcnBoYW5lZEFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZGVidWckYihcIlJlbW92aW5nIG9ycGhhbmVkIGFubm90YXRpb25zIGZyb20gc3BhbiBub2RlXCIpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgbWFya3M6IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIW9ycGhhbmVkQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFyaykpXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgICAgIH0pLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSkge1xuICAgICAgICBjb25zdCBibG9ja1BhdGggPSBQYXRoLnBhcmVudChwYXRoKSwgW2Jsb2NrXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgYmxvY2tQYXRoKTtcbiAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhibG9jaykpIHtcbiAgICAgICAgICBjb25zdCBkZWNvcmF0b3JzMiA9IHR5cGVzLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSksIG1hcmtzID0gbm9kZS5tYXJrcyA/PyBbXSwgb3JwaGFuZWRBbm5vdGF0aW9ucyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gIWRlY29yYXRvcnMyLmluY2x1ZGVzKG1hcmspICYmICFibG9jay5tYXJrRGVmcz8uZmluZCgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgICAgIGlmIChvcnBoYW5lZEFubm90YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlYnVnJGIoXCJSZW1vdmluZyBvcnBoYW5lZCBhbm5vdGF0aW9ucyBmcm9tIHNwYW4gbm9kZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hcmtzOiBtYXJrcy5maWx0ZXIoKG1hcmspID0+ICFvcnBoYW5lZEFubm90YXRpb25zLmluY2x1ZGVzKG1hcmspKVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICB0eXBlOiBcImRvbmUgbm9ybWFsaXppbmdcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IG1hcmtEZWZzID0gbm9kZS5tYXJrRGVmcyA/PyBbXSwgbWFya0RlZktleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBuZXdNYXJrRGVmcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcmtEZWYgb2YgbWFya0RlZnMpXG4gICAgICAgICAgbWFya0RlZktleXMuaGFzKG1hcmtEZWYuX2tleSkgfHwgKG1hcmtEZWZLZXlzLmFkZChtYXJrRGVmLl9rZXkpLCBuZXdNYXJrRGVmcy5wdXNoKG1hcmtEZWYpKTtcbiAgICAgICAgaWYgKG1hcmtEZWZzLmxlbmd0aCAhPT0gbmV3TWFya0RlZnMubGVuZ3RoKSB7XG4gICAgICAgICAgZGVidWckYihcIlJlbW92aW5nIGR1cGxpY2F0ZSBtYXJrRGVmc1wiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgIWVkaXRvci5vcGVyYXRpb25zLnNvbWUoKG9wKSA9PiBvcC50eXBlID09PSBcIm1lcmdlX25vZGVcIiAmJiBcIm1hcmtEZWZzXCIgaW4gb3AucHJvcGVydGllcyAmJiBvcC5wYXRoLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgICAgY29uc3QgbmV3TWFya0RlZnMgPSAobm9kZS5tYXJrRGVmcyB8fCBbXSkuZmlsdGVyKChkZWYpID0+IG5vZGUuY2hpbGRyZW4uZmluZCgoY2hpbGQpID0+IFRleHQuaXNUZXh0KGNoaWxkKSAmJiBBcnJheS5pc0FycmF5KGNoaWxkLm1hcmtzKSAmJiBjaGlsZC5tYXJrcy5pbmNsdWRlcyhkZWYuX2tleSkpKTtcbiAgICAgICAgaWYgKG5vZGUubWFya0RlZnMgJiYgIWlzRXF1YWwobmV3TWFya0RlZnMsIG5vZGUubWFya0RlZnMpKSB7XG4gICAgICAgICAgZGVidWckYihcIlJlbW92aW5nIG1hcmtEZWYgbm90IGluIHVzZVwiKSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBwYXRoXG4gICAgICAgICAgfSksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUobm9kZUVudHJ5KTtcbiAgICB9LCBlZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICAgIGlmIChpc0NoYW5naW5nUmVtb3RlbHkoZWRpdG9yKSkge1xuICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNVbmRvaW5nKGVkaXRvcikgfHwgaXNSZWRvaW5nKGVkaXRvcikpIHtcbiAgICAgICAgYXBwbHkyKG9wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwic2V0X3NlbGVjdGlvblwiICYmIEVkaXRvci5tYXJrcyhlZGl0b3IpICYmIG9wLnByb3BlcnRpZXMgJiYgb3AubmV3UHJvcGVydGllcyAmJiBvcC5wcm9wZXJ0aWVzLmFuY2hvciAmJiBvcC5wcm9wZXJ0aWVzLmZvY3VzICYmIG9wLm5ld1Byb3BlcnRpZXMuYW5jaG9yICYmIG9wLm5ld1Byb3BlcnRpZXMuZm9jdXMpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb25Jc0NvbGxhcHNlZCA9IFJhbmdlLmlzQ29sbGFwc2VkKHtcbiAgICAgICAgICBhbmNob3I6IG9wLnByb3BlcnRpZXMuYW5jaG9yLFxuICAgICAgICAgIGZvY3VzOiBvcC5wcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0pLCBuZXdTZWxlY3Rpb25Jc0NvbGxhcHNlZCA9IFJhbmdlLmlzQ29sbGFwc2VkKHtcbiAgICAgICAgICBhbmNob3I6IG9wLm5ld1Byb3BlcnRpZXMuYW5jaG9yLFxuICAgICAgICAgIGZvY3VzOiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJldmlvdXNTZWxlY3Rpb25Jc0NvbGxhcHNlZCAmJiBuZXdTZWxlY3Rpb25Jc0NvbGxhcHNlZCkge1xuICAgICAgICAgIGNvbnN0IGZvY3VzU3BhbiA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgICAgIGF0OiBvcC5wcm9wZXJ0aWVzLmZvY3VzLFxuICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBlZGl0b3IuaXNUZXh0U3BhbihuKSxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pKVswXT8uWzBdLCBuZXdGb2N1c1NwYW4gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgICAgICBhdDogb3AubmV3UHJvcGVydGllcy5mb2N1cyxcbiAgICAgICAgICAgIG1hdGNoOiAobikgPT4gZWRpdG9yLmlzVGV4dFNwYW4obiksXG4gICAgICAgICAgICB2b2lkczogITFcbiAgICAgICAgICB9KSlbMF0/LlswXSwgbW92ZWRUb05leHRTcGFuID0gZm9jdXNTcGFuICYmIG5ld0ZvY3VzU3BhbiAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMF0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFswXSAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMV0gPT09IG9wLnByb3BlcnRpZXMuZm9jdXMucGF0aFsxXSArIDEgJiYgZm9jdXNTcGFuLnRleHQubGVuZ3RoID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLm9mZnNldCAmJiBvcC5uZXdQcm9wZXJ0aWVzLmZvY3VzLm9mZnNldCA9PT0gMCwgbW92ZWRUb1ByZXZpb3VzU3BhbiA9IGZvY3VzU3BhbiAmJiBuZXdGb2N1c1NwYW4gJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cy5wYXRoWzBdID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMF0gJiYgb3AubmV3UHJvcGVydGllcy5mb2N1cy5wYXRoWzFdID09PSBvcC5wcm9wZXJ0aWVzLmZvY3VzLnBhdGhbMV0gLSAxICYmIG9wLnByb3BlcnRpZXMuZm9jdXMub2Zmc2V0ID09PSAwICYmIG5ld0ZvY3VzU3Bhbi50ZXh0Lmxlbmd0aCA9PT0gb3AubmV3UHJvcGVydGllcy5mb2N1cy5vZmZzZXQ7XG4gICAgICAgICAgaWYgKG1vdmVkVG9OZXh0U3BhbiB8fCBtb3ZlZFRvUHJldmlvdXNTcGFuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3AudHlwZSA9PT0gXCJpbnNlcnRfbm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGNvbnN0IFtfYmxvY2ssIGJsb2NrUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHNlbGVjdGlvbiwge1xuICAgICAgICAgICAgZGVwdGg6IDFcbiAgICAgICAgICB9KSwgcHJldmlvdXNTcGFuID0gZ2V0UHJldmlvdXNTcGFuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgIHNwYW5QYXRoOiBvcC5wYXRoXG4gICAgICAgICAgfSksIHByZXZpb3VzU3BhbkFubm90YXRpb25zID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA6IFtdLCBuZXh0U3BhbiA9IGdldE5leHRTcGFuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgIHNwYW5QYXRoOiBbb3AucGF0aFswXSwgb3AucGF0aFsxXSAtIDFdXG4gICAgICAgICAgfSksIG5leHRTcGFuQW5ub3RhdGlvbnMgPSBuZXh0U3BhbiA/IG5leHRTcGFuLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA6IFtdLCBhbm5vdGF0aW9uc0VuZGluZyA9IHByZXZpb3VzU3BhbkFubm90YXRpb25zPy5maWx0ZXIoKGFubm90YXRpb24pID0+ICFuZXh0U3BhbkFubm90YXRpb25zPy5pbmNsdWRlcyhhbm5vdGF0aW9uKSkgPz8gW10sIGF0VGhlRW5kT2ZBbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNFbmRpbmcubGVuZ3RoID4gMDtcbiAgICAgICAgICBpZiAoYXRUaGVFbmRPZkFubm90YXRpb24gJiYgaXNQb3J0YWJsZVRleHRTcGFuKG9wLm5vZGUpICYmIG9wLm5vZGUubWFya3M/LnNvbWUoKG1hcmspID0+IGFubm90YXRpb25zRW5kaW5nLmluY2x1ZGVzKG1hcmspKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgLi4ub3Aubm9kZSxcbiAgICAgICAgICAgICAgbWFya3M6IG9wLm5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWFubm90YXRpb25zRW5kaW5nLmluY2x1ZGVzKG1hcmspKSA/PyBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zU3RhcnRpbmcgPSBuZXh0U3BhbkFubm90YXRpb25zPy5maWx0ZXIoKGFubm90YXRpb24pID0+ICFwcmV2aW91c1NwYW5Bbm5vdGF0aW9ucz8uaW5jbHVkZXMoYW5ub3RhdGlvbikpID8/IFtdLCBhdFRoZVN0YXJ0T2ZBbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNTdGFydGluZy5sZW5ndGggPiAwO1xuICAgICAgICAgIGlmIChhdFRoZVN0YXJ0T2ZBbm5vdGF0aW9uICYmIGlzUG9ydGFibGVUZXh0U3BhbihvcC5ub2RlKSAmJiBvcC5ub2RlLm1hcmtzPy5zb21lKChtYXJrKSA9PiBhbm5vdGF0aW9uc1N0YXJ0aW5nLmluY2x1ZGVzKG1hcmspKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgLi4ub3Aubm9kZSxcbiAgICAgICAgICAgICAgbWFya3M6IG9wLm5vZGUubWFya3M/LmZpbHRlcigobWFyaykgPT4gIWFubm90YXRpb25zU3RhcnRpbmcuaW5jbHVkZXMobWFyaykpID8/IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV4dFNwYW5EZWNvcmF0b3JzID0gbmV4dFNwYW4/Lm1hcmtzPy5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpID8/IFtdO1xuICAgICAgICAgIGlmIChuZXh0U3BhbkRlY29yYXRvcnMubGVuZ3RoID4gMCAmJiBhdFRoZUVuZE9mQW5ub3RhdGlvbiAmJiAhYXRUaGVTdGFydE9mQW5ub3RhdGlvbiAmJiBpc1BvcnRhYmxlVGV4dFNwYW4ob3Aubm9kZSkgJiYgb3Aubm9kZS5tYXJrcz8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAuLi5vcC5ub2RlLFxuICAgICAgICAgICAgICBtYXJrczogbmV4dFNwYW5EZWNvcmF0b3JzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcC50eXBlID09PSBcImluc2VydF90ZXh0XCIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yLCBjb2xsYXBzZWRTZWxlY3Rpb24gPSBzZWxlY3Rpb24gPyBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pIDogITE7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgY29sbGFwc2VkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgW19ibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLCB7XG4gICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgIH0pLCBbc3Bhbiwgc3BhblBhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgICAgICAgICAgYXQ6IHNlbGVjdGlvbi5mb2N1cyxcbiAgICAgICAgICAgIG1hdGNoOiAobikgPT4gZWRpdG9yLmlzVGV4dFNwYW4obiksXG4gICAgICAgICAgICB2b2lkczogITFcbiAgICAgICAgICB9KSlbMF0gPz8gW3ZvaWQgMCwgdm9pZCAwXSwgbWFya3MgPSBzcGFuLm1hcmtzID8/IFtdLCBtYXJrc1dpdGhvdXRBbm5vdGF0aW9ucyA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSksIHNwYW5IYXNBbm5vdGF0aW9ucyA9IG1hcmtzLmxlbmd0aCA+IG1hcmtzV2l0aG91dEFubm90YXRpb25zLmxlbmd0aCwgc3BhbklzRW1wdHkgPSBzcGFuLnRleHQubGVuZ3RoID09PSAwLCBhdFRoZUJlZ2lubmluZ09mU3BhbiA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAwLCBhdFRoZUVuZE9mU3BhbiA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSBzcGFuLnRleHQubGVuZ3RoLCBwcmV2aW91c1NwYW4gPSBnZXRQcmV2aW91c1NwYW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgc3BhblBhdGhcbiAgICAgICAgICB9KSwgbmV4dFNwYW4gPSBnZXROZXh0U3Bhbih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBibG9ja1BhdGgsXG4gICAgICAgICAgICBzcGFuUGF0aFxuICAgICAgICAgIH0pLCBuZXh0U3BhbkFubm90YXRpb25zID0gbmV4dFNwYW4/Lm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKSA/PyBbXSwgc3BhbkFubm90YXRpb25zID0gbWFya3MuZmlsdGVyKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSksIHByZXZpb3VzU3Bhbkhhc0Fubm90YXRpb25zID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgcHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb25zID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+ICFkZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspKS5ldmVyeSgobWFyaykgPT4gbWFya3MuaW5jbHVkZXMobWFyaykpIDogITEsIHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9uID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSAmJiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMSwgcHJldmlvdXNTcGFuSGFzU2FtZU1hcmtzID0gcHJldmlvdXNTcGFuID8gcHJldmlvdXNTcGFuLm1hcmtzPy5ldmVyeSgobWFyaykgPT4gbWFya3MuaW5jbHVkZXMobWFyaykpIDogITEsIG5leHRTcGFuU2hhcmVzU29tZUFubm90YXRpb25zID0gc3BhbkFubm90YXRpb25zLnNvbWUoKG1hcmspID0+IG5leHRTcGFuQW5ub3RhdGlvbnM/LmluY2x1ZGVzKG1hcmspKTtcbiAgICAgICAgICBpZiAoc3Bhbkhhc0Fubm90YXRpb25zICYmICFzcGFuSXNFbXB0eSkge1xuICAgICAgICAgICAgaWYgKGF0VGhlQmVnaW5uaW5nT2ZTcGFuKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c1NwYW5IYXNTYW1lTWFya3MpIHtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgX3R5cGU6IFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICAgICAgdGV4dDogb3AudGV4dCxcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBwcmV2aW91c1NwYW4/Lm1hcmtzID8/IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzU3Bhbkhhc1NhbWVBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICAgICAgbWFya3M6IHByZXZpb3VzU3Bhbj8ubWFya3MgPz8gW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICBhcHBseTIob3ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghcHJldmlvdXNTcGFuKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdFRoZUVuZE9mU3Bhbikge1xuICAgICAgICAgICAgICBpZiAobmV4dFNwYW4gJiYgbmV4dFNwYW5TaGFyZXNTb21lQW5ub3RhdGlvbnMgJiYgbmV4dFNwYW5Bbm5vdGF0aW9ucy5sZW5ndGggPCBzcGFuQW5ub3RhdGlvbnMubGVuZ3RoIHx8ICFuZXh0U3BhblNoYXJlc1NvbWVBbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICBfa2V5OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICAgICAgbWFya3M6IG5leHRTcGFuPy5tYXJrcyA/PyBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIW5leHRTcGFuKSB7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IG9wLnRleHQsXG4gICAgICAgICAgICAgICAgICBtYXJrczogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0VGhlQmVnaW5uaW5nT2ZTcGFuICYmICFzcGFuSXNFbXB0eSAmJiBwcmV2aW91c1NwYW4pIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICAgICAgICB0ZXh0OiBvcC50ZXh0LFxuICAgICAgICAgICAgICBtYXJrczogcHJldmlvdXNTcGFuSGFzQW5ub3RhdGlvbnMgPyBbXSA6IChwcmV2aW91c1NwYW4ubWFya3MgPz8gW10pLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wLnR5cGUgPT09IFwicmVtb3ZlX3RleHRcIikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VsZWN0aW9uXG4gICAgICAgIH0gPSBlZGl0b3I7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24sIHtcbiAgICAgICAgICAgIGRlcHRoOiAxXG4gICAgICAgICAgfSksIFtzcGFuLCBzcGFuUGF0aF0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1vZGU6IFwibG93ZXN0XCIsXG4gICAgICAgICAgICBhdDoge1xuICAgICAgICAgICAgICBwYXRoOiBvcC5wYXRoLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG9wLm9mZnNldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hdGNoOiAobikgPT4gZWRpdG9yLmlzVGV4dFNwYW4obiksXG4gICAgICAgICAgICB2b2lkczogITFcbiAgICAgICAgICB9KSlbMF0gPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICAgICAgICBpZiAoc3BhbiAmJiBibG9jayAmJiBpc1BvcnRhYmxlVGV4dEJsb2NrKGJsb2NrKSkge1xuICAgICAgICAgICAgY29uc3QgbWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyA/PyBbXSwgbWFya3MgPSBzcGFuLm1hcmtzID8/IFtdLCBzcGFuSGFzQW5ub3RhdGlvbnMgPSBtYXJrcy5zb21lKChtYXJrKSA9PiBtYXJrRGVmcy5maW5kKChtYXJrRGVmKSA9PiBtYXJrRGVmLl9rZXkgPT09IG1hcmspKSwgZGVsZXRpbmdGcm9tVGhlRW5kID0gb3Aub2Zmc2V0ICsgb3AudGV4dC5sZW5ndGggPT09IHNwYW4udGV4dC5sZW5ndGgsIGRlbGV0aW5nQWxsVGV4dCA9IG9wLm9mZnNldCA9PT0gMCAmJiBkZWxldGluZ0Zyb21UaGVFbmQsIHByZXZpb3VzU3BhbiA9IGdldFByZXZpb3VzU3Bhbih7XG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgYmxvY2tQYXRoLFxuICAgICAgICAgICAgICBzcGFuUGF0aFxuICAgICAgICAgICAgfSksIG5leHRTcGFuID0gZ2V0TmV4dFNwYW4oe1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIGJsb2NrUGF0aCxcbiAgICAgICAgICAgICAgc3BhblBhdGhcbiAgICAgICAgICAgIH0pLCBwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbiA9IHByZXZpb3VzU3BhbiA/IHByZXZpb3VzU3Bhbi5tYXJrcz8uc29tZSgobWFyaykgPT4gIWRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykgJiYgbWFya3MuaW5jbHVkZXMobWFyaykpIDogITEsIG5leHRTcGFuSGFzU2FtZUFubm90YXRpb24gPSBuZXh0U3BhbiA/IG5leHRTcGFuLm1hcmtzPy5zb21lKChtYXJrKSA9PiAhZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSAmJiBtYXJrcy5pbmNsdWRlcyhtYXJrKSkgOiAhMTtcbiAgICAgICAgICAgIGlmIChzcGFuSGFzQW5ub3RhdGlvbnMgJiYgZGVsZXRpbmdBbGxUZXh0ICYmICFwcmV2aW91c1NwYW5IYXNTYW1lQW5ub3RhdGlvbiAmJiAhbmV4dFNwYW5IYXNTYW1lQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrc1dpdGhvdXRBbm5vdGF0aW9uTWFya3MgPSAoe1xuICAgICAgICAgICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gICAgICAgICAgICAgIH0ubWFya3MgfHwgW10pLmZpbHRlcigobWFyaykgPT4gZGVjb3JhdG9ycy5pbmNsdWRlcyhtYXJrKSk7XG4gICAgICAgICAgICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXBwbHkyKG9wKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICAgIG1hcmtzOiBtYXJrc1dpdGhvdXRBbm5vdGF0aW9uTWFya3NcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICBhdDogb3AucGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcC50eXBlID09PSBcIm1lcmdlX25vZGVcIiAmJiBvcC5wYXRoLmxlbmd0aCA9PT0gMSAmJiBcIm1hcmtEZWZzXCIgaW4gb3AucHJvcGVydGllcyAmJiBvcC5wcm9wZXJ0aWVzLl90eXBlID09PSB0eXBlcy5ibG9jay5uYW1lICYmIEFycmF5LmlzQXJyYXkob3AucHJvcGVydGllcy5tYXJrRGVmcykgJiYgb3AucHJvcGVydGllcy5tYXJrRGVmcy5sZW5ndGggPiAwICYmIG9wLnBhdGhbMF0gLSAxID49IDApIHtcbiAgICAgICAgY29uc3QgW3RhcmdldEJsb2NrLCB0YXJnZXRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgW29wLnBhdGhbMF0gLSAxXSk7XG4gICAgICAgIGlmIChlZGl0b3IuaXNUZXh0QmxvY2sodGFyZ2V0QmxvY2spKSB7XG4gICAgICAgICAgY29uc3Qgb2xkRGVmcyA9IEFycmF5LmlzQXJyYXkodGFyZ2V0QmxvY2subWFya0RlZnMpICYmIHRhcmdldEJsb2NrLm1hcmtEZWZzIHx8IFtdLCBuZXdNYXJrRGVmcyA9IHVuaXEoWy4uLm9sZERlZnMsIC4uLm9wLnByb3BlcnRpZXMubWFya0RlZnNdKTtcbiAgICAgICAgICBkZWJ1ZyRiKFwiQ29weWluZyBtYXJrRGVmcyBvdmVyIHRvIG1lcmdlZCBibG9ja1wiLCBvcCksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBtYXJrRGVmczogbmV3TWFya0RlZnNcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UGF0aCxcbiAgICAgICAgICAgIHZvaWRzOiAhMVxuICAgICAgICAgIH0pLCBhcHBseTIob3ApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXBwbHkyKG9wKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBhZGREZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBhY3Rpb24uZWRpdG9yLCBtYXJrID0gYWN0aW9uLmRlY29yYXRvcjtcbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt9LCB7XG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICBoYW5naW5nOiAhMFxuICAgICAgfSk7XG4gICAgICBjb25zdCBzcGxpdFRleHROb2RlcyA9IFJhbmdlLmlzUmFuZ2UoZWRpdG9yLnNlbGVjdGlvbikgPyBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KV0gOiBbXTtcbiAgICAgIHNwbGl0VGV4dE5vZGVzLmxlbmd0aCA+IDEgJiYgc3BsaXRUZXh0Tm9kZXMuZXZlcnkoKG5vZGUpID0+IG5vZGVbMF0ubWFya3M/LmluY2x1ZGVzKG1hcmspKSA/IGVkaXRvci5yZW1vdmVNYXJrKG1hcmspIDogc3BsaXRUZXh0Tm9kZXMuZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtzID0gWy4uLihBcnJheS5pc0FycmF5KG5vZGUubWFya3MpID8gbm9kZS5tYXJrcyA6IFtdKS5maWx0ZXIoKGVNYXJrKSA9PiBlTWFyayAhPT0gbWFyayksIG1hcmtdO1xuICAgICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICAgICAgc3BsaXQ6ICEwLFxuICAgICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgICBkZXB0aDogMVxuICAgICAgfSksIGxvbmVseUVtcHR5U3BhbiA9IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGVkaXRvci5pc1RleHRTcGFuKGJsb2NrLmNoaWxkcmVuWzBdKSAmJiBibG9jay5jaGlsZHJlblswXS50ZXh0ID09PSBcIlwiID8gYmxvY2suY2hpbGRyZW5bMF0gOiB2b2lkIDA7XG4gICAgICBpZiAobG9uZWx5RW1wdHlTcGFuKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSBsb25lbHlFbXB0eVNwYW4ubWFya3MgPz8gW10sIGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yID0gZXhpc3RpbmdNYXJrcy5maWx0ZXIoKGV4aXN0aW5nTWFyaykgPT4gZXhpc3RpbmdNYXJrICE9PSBtYXJrKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrcy5sZW5ndGggPT09IGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yLmxlbmd0aCA/IFsuLi5leGlzdGluZ01hcmtzLCBtYXJrXSA6IGV4aXN0aW5nTWFya3NXaXRob3V0RGVjb3JhdG9yXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogYmxvY2tQYXRoLFxuICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dFNwYW4obm9kZSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBleGlzdGluZ01hcmtzID0ge1xuICAgICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9XG4gICAgICAgIH0ubWFya3MgfHwgW10sIG1hcmtzID0ge1xuICAgICAgICAgIC4uLkVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9LFxuICAgICAgICAgIG1hcmtzOiBbLi4uZXhpc3RpbmdNYXJrcywgbWFya11cbiAgICAgICAgfTtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG4gICAgICB9XG4gICAgfVxuICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICB9XG59LCByZW1vdmVEZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBhY3Rpb24uZWRpdG9yLCBtYXJrID0gYWN0aW9uLmRlY29yYXRvciwge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoc2VsZWN0aW9uKVxuICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpXG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge30sIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgICBzcGxpdDogITAsXG4gICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICB9KSwgZWRpdG9yLnNlbGVjdGlvbiAmJiBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KV0uZm9yRWFjaCgoW25vZGUsIHBhdGhdKSA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gZWRpdG9yLmNoaWxkcmVuW3BhdGhbMF1dO1xuICAgICAgICBFbGVtZW50JDEuaXNFbGVtZW50KGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5pbmNsdWRlcyhub2RlKSAmJiBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIG1hcmtzOiAoQXJyYXkuaXNBcnJheShub2RlLm1hcmtzKSA/IG5vZGUubWFya3MgOiBbXSkuZmlsdGVyKChlTWFyaykgPT4gZU1hcmsgIT09IG1hcmspLFxuICAgICAgICAgIF90eXBlOiBcInNwYW5cIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uLCB7XG4gICAgICAgIGRlcHRoOiAxXG4gICAgICB9KSwgbG9uZWx5RW1wdHlTcGFuID0gZWRpdG9yLmlzVGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZWRpdG9yLmlzVGV4dFNwYW4oYmxvY2suY2hpbGRyZW5bMF0pICYmIGJsb2NrLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCIgPyBibG9jay5jaGlsZHJlblswXSA6IHZvaWQgMDtcbiAgICAgIGlmIChsb25lbHlFbXB0eVNwYW4pIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3IgPSAobG9uZWx5RW1wdHlTcGFuLm1hcmtzID8/IFtdKS5maWx0ZXIoKGV4aXN0aW5nTWFyaykgPT4gZXhpc3RpbmdNYXJrICE9PSBtYXJrKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBtYXJrczogZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3JcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSB7XG4gICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICAgICAgfS5tYXJrcyB8fCBbXSwgbWFya3MgPSB7XG4gICAgICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30sXG4gICAgICAgICAgbWFya3M6IGV4aXN0aW5nTWFya3MuZmlsdGVyKChlTWFyaykgPT4gZU1hcmsgIT09IG1hcmspXG4gICAgICAgIH07XG4gICAgICAgIGVkaXRvci5tYXJrcyA9IHtcbiAgICAgICAgICBtYXJrczogbWFya3MubWFya3MsXG4gICAgICAgICAgX3R5cGU6IFwic3BhblwiXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIGlzRGVjb3JhdG9yQWN0aXZlKHtcbiAgZWRpdG9yLFxuICBkZWNvcmF0b3Jcbn0pIHtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3Qgc2VsZWN0ZWRUZXh0Tm9kZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgYXQ6IGVkaXRvci5zZWxlY3Rpb25cbiAgfSkpO1xuICByZXR1cm4gc2VsZWN0ZWRUZXh0Tm9kZXMubGVuZ3RoID09PSAwID8gITEgOiBSYW5nZS5pc0V4cGFuZGVkKGVkaXRvci5zZWxlY3Rpb24pID8gc2VsZWN0ZWRUZXh0Tm9kZXMuZXZlcnkoKG4pID0+IHtcbiAgICBjb25zdCBbbm9kZV0gPSBuO1xuICAgIHJldHVybiBub2RlLm1hcmtzPy5pbmNsdWRlcyhkZWNvcmF0b3IpO1xuICB9KSA6ICh7XG4gICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgfS5tYXJrcyB8fCBbXSkuaW5jbHVkZXMoZGVjb3JhdG9yKTtcbn1cbmNvbnN0IHRvZ2dsZURlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGlzRGVjb3JhdG9yQWN0aXZlKHtcbiAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgZGVjb3JhdG9yOiBhY3Rpb24uZGVjb3JhdG9yXG4gIH0pID8gcmVtb3ZlRGVjb3JhdG9yQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgIGNvbnRleHQsXG4gICAgYWN0aW9uOiB7XG4gICAgICB0eXBlOiBcImRlY29yYXRvci5yZW1vdmVcIixcbiAgICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvcixcbiAgICAgIGRlY29yYXRvcjogYWN0aW9uLmRlY29yYXRvclxuICAgIH1cbiAgfSkgOiBhZGREZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb246IHtcbiAgICAgIHR5cGU6IFwiZGVjb3JhdG9yLmFkZFwiLFxuICAgICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgICAgZGVjb3JhdG9yOiBhY3Rpb24uZGVjb3JhdG9yXG4gICAgfVxuICB9KTtcbn0sIGRlYnVnJGEgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zXCIpLCBkZWJ1Z1ZlcmJvc2UkMSA9IGRlYnVnJGEuZW5hYmxlZCAmJiAhMTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zKGVkaXRvckFjdG9yLCB0eXBlcykge1xuICBsZXQgcHJldlNlbGVjdGlvbiA9IG51bGw7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBjb25zdCBlbWl0UG9ydGFibGVUZXh0U2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKHByZXZTZWxlY3Rpb24gIT09IGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IHB0UmFuZ2UgPSBudWxsO1xuICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gU0xBVEVfVE9fUE9SVEFCTEVfVEVYVF9SQU5HRS5nZXQoZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nKVxuICAgICAgICAgICAgcHRSYW5nZSA9IGV4aXN0aW5nO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlZGl0b3IuY2hpbGRyZW47XG4gICAgICAgICAgICBwdFJhbmdlID0gdG9Qb3J0YWJsZVRleHRSYW5nZSh2YWx1ZSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpLCBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLnNldChlZGl0b3Iuc2VsZWN0aW9uLCBwdFJhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdWZXJib3NlJDEgJiYgZGVidWckYShgRW1pdHRpbmcgc2VsZWN0aW9uICR7SlNPTi5zdHJpbmdpZnkocHRSYW5nZSB8fCBudWxsKX0gKCR7SlNPTi5zdHJpbmdpZnkoZWRpdG9yLnNlbGVjdGlvbil9KWApLCBwdFJhbmdlID8gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJzZWxlY3Rpb25cIixcbiAgICAgICAgICBzZWxlY3Rpb246IHB0UmFuZ2VcbiAgICAgICAgfSkgOiBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgIHNlbGVjdGlvbjogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHByZXZTZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uO1xuICAgIH0sIHtcbiAgICAgIG9uQ2hhbmdlXG4gICAgfSA9IGVkaXRvcjtcbiAgICByZXR1cm4gZWRpdG9yLm9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgY29uc3QgaGFzQ2hhbmdlcyA9IGVkaXRvci5vcGVyYXRpb25zLmxlbmd0aCA+IDA7XG4gICAgICBvbkNoYW5nZSgpLCBoYXNDaGFuZ2VzICYmICFlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLm1hdGNoZXMoe1xuICAgICAgICBzZXR1cDogXCJzZXR0aW5nIHVwXCJcbiAgICAgIH0pICYmIGVtaXRQb3J0YWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyQ5ID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoU2NoZW1hVHlwZXNcIik7XG5mdW5jdGlvbiBjcmVhdGVXaXRoU2NoZW1hVHlwZXMoe1xuICBlZGl0b3JBY3RvcixcbiAgc2NoZW1hVHlwZXNcbn0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGVkaXRvci5pc1RleHRCbG9jayA9ICh2YWx1ZSkgPT4gaXNQb3J0YWJsZVRleHRUZXh0QmxvY2sodmFsdWUpICYmIHZhbHVlLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBlZGl0b3IuaXNUZXh0U3BhbiA9ICh2YWx1ZSkgPT4gaXNQb3J0YWJsZVRleHRTcGFuJDEodmFsdWUpICYmIHZhbHVlLl90eXBlID09PSBzY2hlbWFUeXBlcy5zcGFuLm5hbWUsIGVkaXRvci5pc0xpc3RCbG9jayA9ICh2YWx1ZSkgPT4gaXNQb3J0YWJsZVRleHRMaXN0QmxvY2sodmFsdWUpICYmIHZhbHVlLl90eXBlID09PSBzY2hlbWFUeXBlcy5ibG9jay5uYW1lLCBlZGl0b3IuaXNWb2lkID0gKGVsZW1lbnQpID0+IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUgIT09IGVsZW1lbnQuX3R5cGUgJiYgKHNjaGVtYVR5cGVzLmJsb2NrT2JqZWN0cy5tYXAoKG9iaikgPT4gb2JqLm5hbWUpLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpIHx8IHNjaGVtYVR5cGVzLmlubGluZU9iamVjdHMubWFwKChvYmopID0+IG9iai5uYW1lKS5pbmNsdWRlcyhlbGVtZW50Ll90eXBlKSksIGVkaXRvci5pc0lubGluZSA9IChlbGVtZW50KSA9PiBzY2hlbWFUeXBlcy5pbmxpbmVPYmplY3RzLm1hcCgob2JqKSA9PiBvYmoubmFtZSkuaW5jbHVkZXMoZWxlbWVudC5fdHlwZSkgJiYgXCJfX2lubGluZVwiIGluIGVsZW1lbnQgJiYgZWxlbWVudC5fX2lubGluZSA9PT0gITA7XG4gICAgY29uc3Qge1xuICAgICAgbm9ybWFsaXplTm9kZVxuICAgIH0gPSBlZGl0b3I7XG4gICAgcmV0dXJuIGVkaXRvci5ub3JtYWxpemVOb2RlID0gKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBbbm9kZSwgcGF0aF0gPSBlbnRyeTtcbiAgICAgIGlmIChub2RlLl90eXBlID09PSB2b2lkIDAgJiYgcGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZGVidWckOShcIlNldHRpbmcgc3BhbiB0eXBlIG9uIHRleHQgbm9kZSB3aXRob3V0IGEgdHlwZVwiKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IG5vZGUsIGtleSA9IHNwYW4uX2tleSB8fCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKCk7XG4gICAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwibm9ybWFsaXppbmdcIlxuICAgICAgICB9KSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAuLi5zcGFuLFxuICAgICAgICAgIF90eXBlOiBzY2hlbWFUeXBlcy5zcGFuLm5hbWUsXG4gICAgICAgICAgX2tleToga2V5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLl9rZXkgPT09IHZvaWQgMCAmJiAocGF0aC5sZW5ndGggPT09IDEgfHwgcGF0aC5sZW5ndGggPT09IDIpKSB7XG4gICAgICAgIGRlYnVnJDkoXCJTZXR0aW5nIG1pc3Npbmcga2V5IG9uIGNoaWxkIG5vZGUgd2l0aG91dCBhIGtleVwiKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpO1xuICAgICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgICB0eXBlOiBcIm5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSksIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgX2tleToga2V5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBhdDogcGF0aFxuICAgICAgICB9KSwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgdHlwZTogXCJkb25lIG5vcm1hbGl6aW5nXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vcm1hbGl6ZU5vZGUoZW50cnkpO1xuICAgIH0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IGRlYnVnJDggPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhVdGlsc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhVdGlscyh7XG4gIGVkaXRvckFjdG9yLFxuICBzY2hlbWFUeXBlc1xufSkge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wdGVFeHBhbmRUb1dvcmQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgIVJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBbdGV4dE5vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24uZm9jdXMsIHtcbiAgICAgICAgICBkZXB0aDogMlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0ZXh0Tm9kZSB8fCAhVGV4dC5pc1RleHQodGV4dE5vZGUpIHx8IHRleHROb2RlLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVidWckOChcInB0ZUV4cGFuZFRvV29yZDogQ2FuJ3QgZXhwYW5kIHRvIHdvcmQgaGVyZVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvY3VzXG4gICAgICAgIH0gPSBzZWxlY3Rpb24sIGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0LCBjaGFyc0JlZm9yZSA9IHRleHROb2RlLnRleHQuc2xpY2UoMCwgZm9jdXNPZmZzZXQpLCBjaGFyc0FmdGVyID0gdGV4dE5vZGUudGV4dC5zbGljZShmb2N1c09mZnNldCwgLTEpLCBpc0VtcHR5ID0gKHN0cikgPT4gc3RyLm1hdGNoKC9cXHMvZyksIHdoaXRlU3BhY2VCZWZvcmVJbmRleCA9IGNoYXJzQmVmb3JlLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5maW5kSW5kZXgoKHN0cikgPT4gaXNFbXB0eShzdHIpKSwgbmV3U3RhcnRPZmZzZXQgPSB3aGl0ZVNwYWNlQmVmb3JlSW5kZXggPiAtMSA/IGNoYXJzQmVmb3JlLmxlbmd0aCAtIHdoaXRlU3BhY2VCZWZvcmVJbmRleCA6IDAsIHdoaXRlU3BhY2VBZnRlckluZGV4ID0gY2hhcnNBZnRlci5zcGxpdChcIlwiKS5maW5kSW5kZXgoKG9iaikgPT4gaXNFbXB0eShvYmopKSwgbmV3RW5kT2Zmc2V0ID0gY2hhcnNCZWZvcmUubGVuZ3RoICsgKHdoaXRlU3BhY2VBZnRlckluZGV4ID4gLTEgPyB3aGl0ZVNwYWNlQWZ0ZXJJbmRleCA6IGNoYXJzQWZ0ZXIubGVuZ3RoICsgMSk7XG4gICAgICAgIGlmICghKG5ld1N0YXJ0T2Zmc2V0ID09PSBuZXdFbmRPZmZzZXQgfHwgTnVtYmVyLmlzTmFOKG5ld1N0YXJ0T2Zmc2V0KSB8fCBOdW1iZXIuaXNOYU4obmV3RW5kT2Zmc2V0KSkpIHtcbiAgICAgICAgICBkZWJ1ZyQ4KFwicHRlRXhwYW5kVG9Xb3JkOiBFeHBhbmRpbmcgdG8gZm9jdXNlZCB3b3JkXCIpLCBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgICAgICAuLi5zZWxlY3Rpb24uYW5jaG9yLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG5ld1N0YXJ0T2Zmc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgICAgLi4uc2VsZWN0aW9uLmZvY3VzLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG5ld0VuZE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyQ4KFwicHRlRXhwYW5kVG9Xb3JkOiBDYW4ndCBleHBhbmQgdG8gd29yZCBoZXJlXCIpO1xuICAgICAgfVxuICAgIH0sIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2sgPSAob3B0aW9ucykgPT4gdG9TbGF0ZVZhbHVlKFt7XG4gICAgICBfdHlwZTogc2NoZW1hVHlwZXMuYmxvY2submFtZSxcbiAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgIHN0eWxlOiBzY2hlbWFUeXBlcy5zdHlsZXNbMF0udmFsdWUgfHwgXCJub3JtYWxcIixcbiAgICAgIC4uLm9wdGlvbnMubGlzdEl0ZW0gPyB7XG4gICAgICAgIGxpc3RJdGVtOiBvcHRpb25zLmxpc3RJdGVtXG4gICAgICB9IDoge30sXG4gICAgICAuLi5vcHRpb25zLmxldmVsID8ge1xuICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgfSA6IHt9LFxuICAgICAgbWFya0RlZnM6IFtdLFxuICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgIF90eXBlOiBcInNwYW5cIixcbiAgICAgICAgX2tleTogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogb3B0aW9ucy5kZWNvcmF0b3JzLmZpbHRlcigoZGVjb3JhdG9yKSA9PiBzY2hlbWFUeXBlcy5kZWNvcmF0b3JzLmZpbmQoKHtcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KSA9PiB2YWx1ZSA9PT0gZGVjb3JhdG9yKSlcbiAgICAgIH1dXG4gICAgfV0sIHtcbiAgICAgIHNjaGVtYVR5cGVzXG4gICAgfSlbMF0sIGVkaXRvcjtcbiAgfTtcbn1cbmNvbnN0IHdpdGhQbHVnaW5zID0gKGVkaXRvciwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBlID0gZWRpdG9yLCB7XG4gICAgZWRpdG9yQWN0b3JcbiAgfSA9IG9wdGlvbnMsIHNjaGVtYVR5cGVzID0gZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYSwgb3BlcmF0aW9uVG9QYXRjaGVzID0gY3JlYXRlT3BlcmF0aW9uVG9QYXRjaGVzKHNjaGVtYVR5cGVzKSwgd2l0aE9iamVjdEtleXMgPSBjcmVhdGVXaXRoT2JqZWN0S2V5cyhlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMpLCB3aXRoU2NoZW1hVHlwZXMgPSBjcmVhdGVXaXRoU2NoZW1hVHlwZXMoe1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHNjaGVtYVR5cGVzXG4gIH0pLCB3aXRoUGF0Y2hlcyA9IGNyZWF0ZVdpdGhQYXRjaGVzKHtcbiAgICBlZGl0b3JBY3RvcixcbiAgICBwYXRjaEZ1bmN0aW9uczogb3BlcmF0aW9uVG9QYXRjaGVzLFxuICAgIHNjaGVtYVR5cGVzLFxuICAgIHN1YnNjcmlwdGlvbnM6IG9wdGlvbnMuc3Vic2NyaXB0aW9uc1xuICB9KSwgd2l0aE1heEJsb2NrcyA9IGNyZWF0ZVdpdGhNYXhCbG9ja3MoZWRpdG9yQWN0b3IpLCB3aXRoVW5kb1JlZG8gPSBjcmVhdGVXaXRoVW5kb1JlZG8oe1xuICAgIGVkaXRvckFjdG9yLFxuICAgIGJsb2NrU2NoZW1hVHlwZTogc2NoZW1hVHlwZXMuYmxvY2ssXG4gICAgc3Vic2NyaXB0aW9uczogb3B0aW9ucy5zdWJzY3JpcHRpb25zXG4gIH0pLCB3aXRoUG9ydGFibGVUZXh0TWFya01vZGVsID0gY3JlYXRlV2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbChlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMpLCB3aXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZSA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcyksIHdpdGhQbGFjZWhvbGRlckJsb2NrID0gY3JlYXRlV2l0aFBsYWNlaG9sZGVyQmxvY2soZWRpdG9yQWN0b3IpLCB3aXRoVXRpbHMgPSBjcmVhdGVXaXRoVXRpbHMoe1xuICAgIGVkaXRvckFjdG9yLFxuICAgIHNjaGVtYVR5cGVzXG4gIH0pLCB3aXRoUG9ydGFibGVUZXh0U2VsZWN0aW9ucyA9IGNyZWF0ZVdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcyk7XG4gIHJldHVybiBjcmVhdGVXaXRoRXZlbnRMaXN0ZW5lcnMoZWRpdG9yQWN0b3IsIG9wdGlvbnMuc3Vic2NyaXB0aW9ucykod2l0aFNjaGVtYVR5cGVzKHdpdGhPYmplY3RLZXlzKHdpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwod2l0aFBvcnRhYmxlVGV4dEJsb2NrU3R5bGUod2l0aFBsYWNlaG9sZGVyQmxvY2sod2l0aFV0aWxzKHdpdGhNYXhCbG9ja3Mod2l0aFVuZG9SZWRvKHdpdGhQYXRjaGVzKHdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zKGUpKSkpKSkpKSkpKTtcbn0sIGRlYnVnJDcgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50OlBvcnRhYmxlVGV4dEVkaXRvcjpTbGF0ZUNvbnRhaW5lclwiKSwgc2xhdGVFZGl0b3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBjcmVhdGVTbGF0ZUVkaXRvcihjb25maWcpIHtcbiAgY29uc3QgZXhpc3RpbmdTbGF0ZUVkaXRvciA9IHNsYXRlRWRpdG9ycy5nZXQoY29uZmlnLmVkaXRvckFjdG9yKTtcbiAgaWYgKGV4aXN0aW5nU2xhdGVFZGl0b3IpXG4gICAgcmV0dXJuIGRlYnVnJDcoXCJSZXVzaW5nIGV4aXN0aW5nIFNsYXRlIGVkaXRvciBpbnN0YW5jZVwiLCBjb25maWcuZWRpdG9yQWN0b3IuaWQpLCBleGlzdGluZ1NsYXRlRWRpdG9yO1xuICBkZWJ1ZyQ3KFwiQ3JlYXRpbmcgbmV3IFNsYXRlIGVkaXRvciBpbnN0YW5jZVwiLCBjb25maWcuZWRpdG9yQWN0b3IuaWQpO1xuICBjb25zdCB1bnN1YnNjcmlwdGlvbnMgPSBbXSwgc3Vic2NyaXB0aW9ucyA9IFtdLCBpbnN0YW5jZSA9IHdpdGhQbHVnaW5zKHdpdGhSZWFjdChjcmVhdGVFZGl0b3IkMSgpKSwge1xuICAgIGVkaXRvckFjdG9yOiBjb25maWcuZWRpdG9yQWN0b3IsXG4gICAgc3Vic2NyaXB0aW9uc1xuICB9KTtcbiAgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuc2V0KGluc3RhbmNlLCB7fSksIEtFWV9UT19TTEFURV9FTEVNRU5ULnNldChpbnN0YW5jZSwge30pO1xuICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiBzdWJzY3JpcHRpb25zKVxuICAgIHVuc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbigpKTtcbiAgY29uc3QgaW5pdGlhbFZhbHVlID0gW2luc3RhbmNlLnB0ZUNyZWF0ZVRleHRCbG9jayh7XG4gICAgZGVjb3JhdG9yczogW11cbiAgfSldLCBzbGF0ZUVkaXRvciA9IHtcbiAgICBpbnN0YW5jZSxcbiAgICBpbml0aWFsVmFsdWVcbiAgfTtcbiAgcmV0dXJuIHNsYXRlRWRpdG9ycy5zZXQoY29uZmlnLmVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvciksIHNsYXRlRWRpdG9yO1xufVxuY29uc3QgdG9nZ2xlTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpc0xpc3RJdGVtQWN0aXZlKHtcbiAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgbGlzdEl0ZW06IGFjdGlvbi5saXN0SXRlbVxuICB9KSA/IHJlbW92ZUxpc3RJdGVtQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgIGNvbnRleHQsXG4gICAgYWN0aW9uOiB7XG4gICAgICAuLi5hY3Rpb24sXG4gICAgICB0eXBlOiBcImxpc3QgaXRlbS5yZW1vdmVcIlxuICAgIH1cbiAgfSkgOiBhZGRMaXN0SXRlbUFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgLi4uYWN0aW9uLFxuICAgICAgdHlwZTogXCJsaXN0IGl0ZW0uYWRkXCJcbiAgICB9XG4gIH0pO1xufSwgcmVtb3ZlTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGd1YXJkcy5pc0xpc3RCbG9jayhub2RlKVxuICB9KV07XG4gIGZvciAoY29uc3QgWywgYXRdIG9mIHNlbGVjdGVkQmxvY2tzKVxuICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhhY3Rpb24uZWRpdG9yLCBbXCJsaXN0SXRlbVwiLCBcImxldmVsXCJdLCB7XG4gICAgICBhdFxuICAgIH0pO1xufSwgYWRkTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGd1YXJkcy5pc1RleHRCbG9jayhub2RlKVxuICB9KV07XG4gIGZvciAoY29uc3QgWywgYXRdIG9mIHNlbGVjdGVkQmxvY2tzKVxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgbGV2ZWw6IDEsXG4gICAgICBsaXN0SXRlbTogYWN0aW9uLmxpc3RJdGVtXG4gICAgfSwge1xuICAgICAgYXRcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBpc0xpc3RJdGVtQWN0aXZlKHtcbiAgZWRpdG9yLFxuICBsaXN0SXRlbVxufSkge1xuICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSlcbiAgfSldO1xuICByZXR1cm4gc2VsZWN0ZWRCbG9ja3MubGVuZ3RoID4gMCA/IHNlbGVjdGVkQmxvY2tzLmV2ZXJ5KChbbm9kZV0pID0+IGVkaXRvci5pc0xpc3RCbG9jayhub2RlKSAmJiBub2RlLmxpc3RJdGVtID09PSBsaXN0SXRlbSkgOiAhMTtcbn1cbmNvbnN0IHRvZ2dsZVN0eWxlQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaXNTdHlsZUFjdGl2ZSh7XG4gICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgIHN0eWxlOiBhY3Rpb24uc3R5bGVcbiAgfSkgPyByZW1vdmVTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgLi4uYWN0aW9uLFxuICAgICAgdHlwZTogXCJzdHlsZS5yZW1vdmVcIlxuICAgIH1cbiAgfSkgOiBhZGRTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uKHtcbiAgICBjb250ZXh0LFxuICAgIGFjdGlvbjoge1xuICAgICAgLi4uYWN0aW9uLFxuICAgICAgdHlwZTogXCJzdHlsZS5hZGRcIlxuICAgIH1cbiAgfSk7XG59LCByZW1vdmVTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGlmICghYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24pXG4gICAgcmV0dXJuO1xuICBjb25zdCBkZWZhdWx0U3R5bGUgPSBjb250ZXh0LnNjaGVtYS5zdHlsZXNbMF0udmFsdWUsIGd1YXJkcyA9IGNyZWF0ZUd1YXJkcyhjb250ZXh0KSwgc2VsZWN0ZWRCbG9ja3MgPSBbLi4uRWRpdG9yLm5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICBhdDogYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24sXG4gICAgbWF0Y2g6IChub2RlKSA9PiBndWFyZHMuaXNUZXh0QmxvY2sobm9kZSlcbiAgfSldO1xuICBmb3IgKGNvbnN0IFssIGF0XSBvZiBzZWxlY3RlZEJsb2NrcylcbiAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9LCB7XG4gICAgICBhdFxuICAgIH0pO1xufSwgYWRkU3R5bGVBY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgZ3VhcmRzID0gY3JlYXRlR3VhcmRzKGNvbnRleHQpLCBzZWxlY3RlZEJsb2NrcyA9IFsuLi5FZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaDogKG5vZGUpID0+IGd1YXJkcy5pc1RleHRCbG9jayhub2RlKVxuICB9KV07XG4gIGZvciAoY29uc3QgWywgYXRdIG9mIHNlbGVjdGVkQmxvY2tzKVxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgc3R5bGU6IGFjdGlvbi5zdHlsZVxuICAgIH0sIHtcbiAgICAgIGF0XG4gICAgfSk7XG59O1xuZnVuY3Rpb24gaXNTdHlsZUFjdGl2ZSh7XG4gIGVkaXRvcixcbiAgc3R5bGVcbn0pIHtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3Qgc2VsZWN0ZWRCbG9ja3MgPSBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gIH0pXTtcbiAgcmV0dXJuIHNlbGVjdGVkQmxvY2tzLmxlbmd0aCA+IDAgPyBzZWxlY3RlZEJsb2Nrcy5ldmVyeSgoW25vZGVdKSA9PiBub2RlLnN0eWxlID09PSBzdHlsZSkgOiAhMTtcbn1cbmNvbnN0IGRlYnVnJDYgPSBkZWJ1Z1dpdGhOYW1lKFwiQVBJOmVkaXRhYmxlXCIpO1xuZnVuY3Rpb24gY3JlYXRlRWRpdGFibGVBUEkoZWRpdG9yLCBlZGl0b3JBY3Rvcikge1xuICBjb25zdCB0eXBlcyA9IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5zY2hlbWE7XG4gIHJldHVybiB7XG4gICAgZm9jdXM6ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImZvY3VzXCJcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJsdXI6ICgpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImJsdXJcIlxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdG9nZ2xlTWFyazogKG1hcmspID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgICAgICAgICBkZWNvcmF0b3I6IG1hcmtcbiAgICAgICAgfSxcbiAgICAgICAgZWRpdG9yXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRvZ2dsZUxpc3Q6IChsaXN0SXRlbSkgPT4ge1xuICAgICAgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgIHR5cGU6IFwibGlzdCBpdGVtLnRvZ2dsZVwiLFxuICAgICAgICAgIGxpc3RJdGVtXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0b2dnbGVCbG9ja1N0eWxlOiAoc3R5bGUpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcInN0eWxlLnRvZ2dsZVwiLFxuICAgICAgICAgIHN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvclxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpc01hcmtBY3RpdmU6IChtYXJrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaXNEZWNvcmF0b3JBY3RpdmUoe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBkZWNvcmF0b3I6IG1hcmtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihlcnIpLCAhMTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1hcmtzOiAoKSA9PiAoe1xuICAgICAgLi4uRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge31cbiAgICB9KS5tYXJrcyB8fCBbXSxcbiAgICB1bmRvOiAoKSA9PiBlZGl0b3IudW5kbygpLFxuICAgIHJlZG86ICgpID0+IGVkaXRvci5yZWRvKCksXG4gICAgc2VsZWN0OiAoc2VsZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBzbGF0ZVNlbGVjdGlvbiA9IHRvU2xhdGVSYW5nZShzZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICBzbGF0ZVNlbGVjdGlvbiA/IFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2xhdGVTZWxlY3Rpb24pIDogVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9LFxuICAgIGZvY3VzQmxvY2s6ICgpID0+IHtcbiAgICAgIGlmIChlZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpKTtcbiAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgIHJldHVybiBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF07XG4gICAgICB9XG4gICAgfSxcbiAgICBmb2N1c0NoaWxkOiAoKSA9PiB7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBibG9jayA9IE5vZGUuZGVzY2VuZGFudChlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSk7XG4gICAgICAgIGlmIChibG9jayAmJiBlZGl0b3IuaXNUZXh0QmxvY2soYmxvY2spKVxuICAgICAgICAgIHJldHVybiBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF0uY2hpbGRyZW5bZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoWzFdXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluc2VydENoaWxkOiAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgIGlmICh0eXBlLm5hbWUgIT09IHR5cGVzLnNwYW4ubmFtZSlcbiAgICAgICAgcmV0dXJuIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgICAgICBiZWhhdmlvckV2ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBcImluc2VydC5pbmxpbmUgb2JqZWN0XCIsXG4gICAgICAgICAgICBpbmxpbmVPYmplY3Q6IHtcbiAgICAgICAgICAgICAgbmFtZTogdHlwZS5uYW1lLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZWRpdG9yXG4gICAgICAgIH0pLCB0b1BvcnRhYmxlVGV4dFJhbmdlKGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgdHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLCBlZGl0b3Iuc2VsZWN0aW9uLCB0eXBlcyk/LmZvY3VzLnBhdGggPz8gW107XG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlZGl0b3IgaGFzIG5vIHNlbGVjdGlvblwiKTtcbiAgICAgIGNvbnN0IFtmb2N1c0Jsb2NrXSA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpLFxuICAgICAgICBtYXRjaDogKG4pID0+IG4uX3R5cGUgPT09IHR5cGVzLmJsb2NrLm5hbWVcbiAgICAgIH0pKVswXSB8fCBbdm9pZCAwXTtcbiAgICAgIGlmICghZm9jdXNCbG9jaylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZm9jdXNlZCB0ZXh0IGJsb2NrXCIpO1xuICAgICAgaWYgKHR5cGUubmFtZSAhPT0gdHlwZXMuc3Bhbi5uYW1lICYmICF0eXBlcy5pbmxpbmVPYmplY3RzLnNvbWUoKHQpID0+IHQubmFtZSA9PT0gdHlwZS5uYW1lKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyB0eXBlIGNhbm5vdCBiZSBpbnNlcnRlZCBhcyBhIGNoaWxkIHRvIGEgdGV4dCBibG9ja1wiKTtcbiAgICAgIGNvbnN0IGNoaWxkID0gdG9TbGF0ZVZhbHVlKFt7XG4gICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgX3R5cGU6IHR5cGVzLmJsb2NrLm5hbWUsXG4gICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgIF9rZXk6IGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgICBfdHlwZTogdHlwZS5uYW1lLFxuICAgICAgICAgIC4uLnZhbHVlIHx8IHt9XG4gICAgICAgIH1dXG4gICAgICB9XSwge1xuICAgICAgICBzY2hlbWFUeXBlczogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnNjaGVtYVxuICAgICAgfSlbMF0uY2hpbGRyZW5bMF0sIGZvY3VzQ2hpbGRQYXRoID0gZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDIpLCBpc1NwYW5Ob2RlID0gY2hpbGQuX3R5cGUgPT09IHR5cGVzLnNwYW4ubmFtZSwgZm9jdXNOb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBmb2N1c0NoaWxkUGF0aCk7XG4gICAgICByZXR1cm4gaXNTcGFuTm9kZSAmJiBmb2N1c05vZGUuX3R5cGUgIT09IHR5cGVzLnNwYW4ubmFtZSAmJiAoZGVidWckNihcIkluc2VydGluZyBzcGFuIGNoaWxkIG5leHQgdG8gaW5saW5lIG9iamVjdCBjaGlsZCwgbW92aW5nIHNlbGVjdGlvbiArIDFcIiksIGVkaXRvci5tb3ZlKHtcbiAgICAgICAgZGlzdGFuY2U6IDEsXG4gICAgICAgIHVuaXQ6IFwiY2hhcmFjdGVyXCJcbiAgICAgIH0pKSwgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkLCB7XG4gICAgICAgIHNlbGVjdDogITAsXG4gICAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCksIHRvUG9ydGFibGVUZXh0UmFuZ2UoZnJvbVNsYXRlVmFsdWUoZWRpdG9yLmNoaWxkcmVuLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSksIGVkaXRvci5zZWxlY3Rpb24sIHR5cGVzKT8uZm9jdXMucGF0aCB8fCBbXTtcbiAgICB9LFxuICAgIGluc2VydEJsb2NrOiAodHlwZSwgdmFsdWUpID0+IChlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJpbnNlcnQuYmxvY2sgb2JqZWN0XCIsXG4gICAgICAgIGJsb2NrT2JqZWN0OiB7XG4gICAgICAgICAgbmFtZTogdHlwZS5uYW1lLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0sXG4gICAgICAgIHBsYWNlbWVudDogXCJhdXRvXCJcbiAgICAgIH0sXG4gICAgICBlZGl0b3JcbiAgICB9KSwgdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpPy5mb2N1cy5wYXRoID8/IFtdKSxcbiAgICBoYXNCbG9ja1N0eWxlOiAoc3R5bGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBpc1N0eWxlQWN0aXZlKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgc3R5bGVcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFzTGlzdFN0eWxlOiAobGlzdEl0ZW0pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBpc0xpc3RJdGVtQWN0aXZlKHtcbiAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgbGlzdEl0ZW1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNWb2lkOiAoZWxlbWVudCkgPT4gIVt0eXBlcy5ibG9jay5uYW1lLCB0eXBlcy5zcGFuLm5hbWVdLmluY2x1ZGVzKGVsZW1lbnQuX3R5cGUpLFxuICAgIGZpbmRCeVBhdGg6IChwYXRoKSA9PiB7XG4gICAgICBjb25zdCBzbGF0ZVBhdGggPSB0b1NsYXRlUmFuZ2Uoe1xuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0sIGVkaXRvcik7XG4gICAgICBpZiAoc2xhdGVQYXRoKSB7XG4gICAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2xhdGVQYXRoLmZvY3VzLnBhdGguc2xpY2UoMCwgMSkpO1xuICAgICAgICBpZiAoYmxvY2sgJiYgYmxvY2tQYXRoICYmIHR5cGVvZiBibG9jay5fa2V5ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEgJiYgc2xhdGVQYXRoLmZvY3VzLnBhdGgubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFtmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lKVswXSwgW3tcbiAgICAgICAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgICAgICAgfV1dO1xuICAgICAgICAgIGNvbnN0IHB0QmxvY2sgPSBmcm9tU2xhdGVWYWx1ZShbYmxvY2tdLCB0eXBlcy5ibG9jay5uYW1lLCBLRVlfVE9fVkFMVUVfRUxFTUVOVC5nZXQoZWRpdG9yKSlbMF07XG4gICAgICAgICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhwdEJsb2NrKSkge1xuICAgICAgICAgICAgY29uc3QgcHRDaGlsZCA9IHB0QmxvY2suY2hpbGRyZW5bc2xhdGVQYXRoLmZvY3VzLnBhdGhbMV1dO1xuICAgICAgICAgICAgaWYgKHB0Q2hpbGQpXG4gICAgICAgICAgICAgIHJldHVybiBbcHRDaGlsZCwgW3tcbiAgICAgICAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgICAgICAgIF9rZXk6IHB0Q2hpbGQuX2tleVxuICAgICAgICAgICAgICB9XV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgICB9LFxuICAgIGZpbmRET01Ob2RlOiAoZWxlbWVudCkgPT4ge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBbaXRlbV0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogW10sXG4gICAgICAgICAgbWF0Y2g6IChuKSA9PiBuLl9rZXkgPT09IGVsZW1lbnQuX2tleVxuICAgICAgICB9KSB8fCBbXSlbMF0gfHwgW3ZvaWQgMF07XG4gICAgICAgIG5vZGUgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBpdGVtKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBhY3RpdmVBbm5vdGF0aW9uczogKCkgPT4ge1xuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8IGVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5sZW5ndGggPCAyKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhY3RpdmVBbm5vdGF0aW9ucyA9IFtdLCBzcGFucyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IFRleHQuaXNUZXh0KG5vZGUpICYmIG5vZGUubWFya3MgIT09IHZvaWQgMCAmJiBBcnJheS5pc0FycmF5KG5vZGUubWFya3MpICYmIG5vZGUubWFya3MubGVuZ3RoID4gMFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBbc3BhbiwgcGF0aF0gb2Ygc3BhbnMpIHtcbiAgICAgICAgICBjb25zdCBbYmxvY2tdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoLCB7XG4gICAgICAgICAgICBkZXB0aDogMVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2subWFya0RlZnM/LmZvckVhY2goKGRlZikgPT4ge1xuICAgICAgICAgICAgVGV4dC5pc1RleHQoc3BhbikgJiYgc3Bhbi5tYXJrcyAmJiBBcnJheS5pc0FycmF5KHNwYW4ubWFya3MpICYmIHNwYW4ubWFya3MuaW5jbHVkZXMoZGVmLl9rZXkpICYmIGFjdGl2ZUFubm90YXRpb25zLnB1c2goZGVmKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlQW5ub3RhdGlvbnM7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNBbm5vdGF0aW9uQWN0aXZlOiAoYW5ub3RhdGlvblR5cGUpID0+IGlzQW5ub3RhdGlvbkFjdGl2ZSh7XG4gICAgICBlZGl0b3IsXG4gICAgICBhbm5vdGF0aW9uOiB7XG4gICAgICAgIG5hbWU6IGFubm90YXRpb25UeXBlXG4gICAgICB9XG4gICAgfSksXG4gICAgYWRkQW5ub3RhdGlvbjogKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICBsZXQgcGF0aHM7XG4gICAgICByZXR1cm4gRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgICAgcGF0aHMgPSBhZGRBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24oe1xuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGtleUdlbmVyYXRvcjogZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcixcbiAgICAgICAgICAgIHNjaGVtYTogdHlwZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgdHlwZTogXCJhbm5vdGF0aW9uLmFkZFwiLFxuICAgICAgICAgICAgYW5ub3RhdGlvbjoge1xuICAgICAgICAgICAgICBuYW1lOiB0eXBlLm5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSA/PyB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCksIHBhdGhzO1xuICAgIH0sXG4gICAgZGVsZXRlOiAoc2VsZWN0aW9uLCBvcHRpb25zKSA9PiB7XG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICAgICAgaWYgKCEocmFuZ2UgJiYgcmFuZ2UuYW5jaG9yLnBhdGgubGVuZ3RoID4gMCAmJiByYW5nZS5mb2N1cy5wYXRoLmxlbmd0aCA+IDApKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmFuZ2VcIik7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIGlmICghb3B0aW9ucz8ubW9kZSB8fCBvcHRpb25zPy5tb2RlID09PSBcInNlbGVjdGVkXCIpIHtcbiAgICAgICAgICAgIGRlYnVnJDYoXCJEZWxldGluZyBjb250ZW50IGluIHNlbGVjdGlvblwiKSwgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgICAgaGFuZ2luZzogITAsXG4gICAgICAgICAgICAgIHZvaWRzOiAhMFxuICAgICAgICAgICAgfSksIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcHRpb25zPy5tb2RlID09PSBcImJsb2Nrc1wiICYmIChkZWJ1ZyQ2KFwiRGVsZXRpbmcgYmxvY2tzIHRvdWNoZWQgYnkgc2VsZWN0aW9uXCIpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgdm9pZHM6ICEwLFxuICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgfHwgIWVkaXRvci5pc1RleHRCbG9jayhub2RlKSAmJiBFbGVtZW50JDEuaXNFbGVtZW50KG5vZGUpXG4gICAgICAgICAgfSkpLCBvcHRpb25zPy5tb2RlID09PSBcImNoaWxkcmVuXCIgJiYgKGRlYnVnJDYoXCJEZWxldGluZyBjaGlsZHJlbiB0b3VjaGVkIGJ5IHNlbGVjdGlvblwiKSwgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIHZvaWRzOiAhMCxcbiAgICAgICAgICAgIG1hdGNoOiAobm9kZSkgPT4gbm9kZS5fdHlwZSA9PT0gdHlwZXMuc3Bhbi5uYW1lIHx8IC8vIFRleHQgY2hpbGRyZW5cbiAgICAgICAgICAgICFlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSkgJiYgRWxlbWVudCQxLmlzRWxlbWVudChub2RlKVxuICAgICAgICAgIH0pKSwgZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiAoZWRpdG9yLmNoaWxkcmVuID0gW2VkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICAgICAgZGVjb3JhdG9yczogW11cbiAgICAgICAgICB9KV0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlQW5ub3RhdGlvbjogKHR5cGUpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImJlaGF2aW9yIGV2ZW50XCIsXG4gICAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcImFubm90YXRpb24ucmVtb3ZlXCIsXG4gICAgICAgICAgYW5ub3RhdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogdHlwZS5uYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlZGl0b3JcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0aW9uOiAoKSA9PiB7XG4gICAgICBsZXQgcHRSYW5nZSA9IG51bGw7XG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IFNMQVRFX1RPX1BPUlRBQkxFX1RFWFRfUkFOR0UuZ2V0KGVkaXRvci5zZWxlY3Rpb24pO1xuICAgICAgICBpZiAoZXhpc3RpbmcpXG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICBwdFJhbmdlID0gdG9Qb3J0YWJsZVRleHRSYW5nZShmcm9tU2xhdGVWYWx1ZShlZGl0b3IuY2hpbGRyZW4sIHR5cGVzLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChlZGl0b3IpKSwgZWRpdG9yLnNlbGVjdGlvbiwgdHlwZXMpLCBTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFLnNldChlZGl0b3Iuc2VsZWN0aW9uLCBwdFJhbmdlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdFJhbmdlO1xuICAgIH0sXG4gICAgZ2V0VmFsdWU6ICgpID0+IGZyb21TbGF0ZVZhbHVlKGVkaXRvci5jaGlsZHJlbiwgdHlwZXMuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGVkaXRvcikpLFxuICAgIGlzQ29sbGFwc2VkU2VsZWN0aW9uOiAoKSA9PiAhIWVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbiksXG4gICAgaXNFeHBhbmRlZFNlbGVjdGlvbjogKCkgPT4gISFlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoZWRpdG9yLnNlbGVjdGlvbiksXG4gICAgaW5zZXJ0QnJlYWs6ICgpID0+IHtcbiAgICAgIGVkaXRvci5pbnNlcnRCcmVhaygpLCBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9LFxuICAgIGdldEZyYWdtZW50OiAoKSA9PiBmcm9tU2xhdGVWYWx1ZShlZGl0b3IuZ2V0RnJhZ21lbnQoKSwgdHlwZXMuYmxvY2submFtZSksXG4gICAgaXNTZWxlY3Rpb25zT3ZlcmxhcHBpbmc6IChzZWxlY3Rpb25BLCBzZWxlY3Rpb25CKSA9PiB7XG4gICAgICBjb25zdCByYW5nZUEgPSB0b1NsYXRlUmFuZ2Uoc2VsZWN0aW9uQSwgZWRpdG9yKSwgcmFuZ2VCID0gdG9TbGF0ZVJhbmdlKHNlbGVjdGlvbkIsIGVkaXRvcik7XG4gICAgICByZXR1cm4gUmFuZ2UuaXNSYW5nZShyYW5nZUEpICYmIFJhbmdlLmlzUmFuZ2UocmFuZ2VCKSAmJiBSYW5nZS5pbmNsdWRlcyhyYW5nZUEsIHJhbmdlQik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNBbm5vdGF0aW9uQWN0aXZlKHtcbiAgZWRpdG9yLFxuICBhbm5vdGF0aW9uXG59KSB7XG4gIGlmICghZWRpdG9yLnNlbGVjdGlvbiB8fCBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGgubGVuZ3RoIDwgMilcbiAgICByZXR1cm4gITE7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3BhbnMgPSBbLi4uRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtYXRjaDogKG5vZGUpID0+IFRleHQuaXNUZXh0KG5vZGUpXG4gICAgfSldO1xuICAgIGlmIChzcGFucy5sZW5ndGggPT09IDAgfHwgc3BhbnMuc29tZSgoW3NwYW5dKSA9PiAhaXNQb3J0YWJsZVRleHRTcGFuJDEoc3BhbikgfHwgIXNwYW4ubWFya3MgfHwgc3Bhbi5tYXJrcz8ubGVuZ3RoID09PSAwKSkgcmV0dXJuICExO1xuICAgIGNvbnN0IHNlbGVjdGlvbk1hcmtEZWZzID0gc3BhbnMucmVkdWNlKChhY2NNYXJrRGVmcywgWywgcGF0aF0pID0+IHtcbiAgICAgIGNvbnN0IFtibG9ja10gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgZGVwdGg6IDFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgJiYgYmxvY2subWFya0RlZnMgPyBbLi4uYWNjTWFya0RlZnMsIC4uLmJsb2NrLm1hcmtEZWZzXSA6IGFjY01hcmtEZWZzO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gc3BhbnMuZXZlcnkoKFtzcGFuXSkgPT4gaXNQb3J0YWJsZVRleHRTcGFuJDEoc3BhbikgPyBzcGFuLm1hcmtzPy5tYXAoKG1hcmtLZXkpID0+IHNlbGVjdGlvbk1hcmtEZWZzLmZpbmQoKGRlZikgPT4gZGVmPy5fa2V5ID09PSBtYXJrS2V5KT8uX3R5cGUpPy5pbmNsdWRlcyhhbm5vdGF0aW9uLm5hbWUpIDogITEpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNvbnN0IGFkZEFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBhY3Rpb24uZWRpdG9yLCB7XG4gICAgc2VsZWN0aW9uOiBvcmlnaW5hbFNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBsZXQgcGF0aHM7XG4gIGlmIChvcmlnaW5hbFNlbGVjdGlvbiAmJiAoUmFuZ2UuaXNDb2xsYXBzZWQob3JpZ2luYWxTZWxlY3Rpb24pICYmIChlZGl0b3IucHRlRXhwYW5kVG9Xb3JkKCksIGVkaXRvci5vbkNoYW5nZSgpKSwgZWRpdG9yLnNlbGVjdGlvbikpIHtcbiAgICBsZXQgc3BhblBhdGgsIG1hcmtEZWZQYXRoO1xuICAgIGNvbnN0IG1hcmtEZWZQYXRocyA9IFtdO1xuICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzZWxlY3RlZEJsb2NrcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbWF0Y2g6IChub2RlKSA9PiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZSksXG4gICAgICByZXZlcnNlOiBSYW5nZS5pc0JhY2t3YXJkKGVkaXRvci5zZWxlY3Rpb24pXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbYmxvY2ssIGJsb2NrUGF0aF0gb2Ygc2VsZWN0ZWRCbG9ja3MpIHtcbiAgICAgIGlmIChibG9jay5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgYmxvY2suY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGJsb2NrLmNoaWxkcmVuWzBdLnRleHQgPT09IFwiXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYW5ub3RhdGlvbktleSA9IGNvbnRleHQua2V5R2VuZXJhdG9yKCksIG1hcmtEZWZzID0gYmxvY2subWFya0RlZnMgPz8gW107XG4gICAgICBtYXJrRGVmcy5maW5kKChtYXJrRGVmKSA9PiBtYXJrRGVmLl90eXBlID09PSBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lICYmIG1hcmtEZWYuX2tleSA9PT0gYW5ub3RhdGlvbktleSkgPT09IHZvaWQgMCAmJiAoVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWFya0RlZnM6IFsuLi5tYXJrRGVmcywge1xuICAgICAgICAgIF90eXBlOiBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lLFxuICAgICAgICAgIF9rZXk6IGFubm90YXRpb25LZXksXG4gICAgICAgICAgLi4uYWN0aW9uLmFubm90YXRpb24udmFsdWVcbiAgICAgICAgfV1cbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IGJsb2NrUGF0aFxuICAgICAgfSksIG1hcmtEZWZQYXRoID0gW3tcbiAgICAgICAgX2tleTogYmxvY2suX2tleVxuICAgICAgfSwgXCJtYXJrRGVmc1wiLCB7XG4gICAgICAgIF9rZXk6IGFubm90YXRpb25LZXlcbiAgICAgIH1dLCBSYW5nZS5pc0JhY2t3YXJkKGVkaXRvci5zZWxlY3Rpb24pID8gbWFya0RlZlBhdGhzLnVuc2hpZnQobWFya0RlZlBhdGgpIDogbWFya0RlZlBhdGhzLnB1c2gobWFya0RlZlBhdGgpKSwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHt9LCB7XG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgc3BsaXQ6ICEwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gTm9kZS5jaGlsZHJlbihlZGl0b3IsIGJsb2NrUGF0aCk7XG4gICAgICBmb3IgKGNvbnN0IFtzcGFuLCBwYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgICBpZiAoIWVkaXRvci5pc1RleHRTcGFuKHNwYW4pIHx8ICFSYW5nZS5pbmNsdWRlcyhlZGl0b3Iuc2VsZWN0aW9uLCBwYXRoKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbWFya3MgPSBzcGFuLm1hcmtzID8/IFtdLCBleGlzdGluZ1NhbWVUeXBlQW5ub3RhdGlvbnMgPSBtYXJrcy5maWx0ZXIoKG1hcmspID0+IG1hcmtEZWZzLnNvbWUoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFyayAmJiBtYXJrRGVmLl90eXBlID09PSBhY3Rpb24uYW5ub3RhdGlvbi5uYW1lKSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IFsuLi5tYXJrcy5maWx0ZXIoKG1hcmspID0+ICFleGlzdGluZ1NhbWVUeXBlQW5ub3RhdGlvbnMuaW5jbHVkZXMobWFyaykpLCBhbm5vdGF0aW9uS2V5XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgYXQ6IHBhdGhcbiAgICAgICAgfSksIHNwYW5QYXRoID0gW3tcbiAgICAgICAgICBfa2V5OiBibG9jay5fa2V5XG4gICAgICAgIH0sIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICAgIF9rZXk6IHNwYW4uX2tleVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWFya0RlZlBhdGggJiYgc3BhblBhdGggJiYgKHBhdGhzID0ge1xuICAgICAgbWFya0RlZlBhdGgsXG4gICAgICBtYXJrRGVmUGF0aHMsXG4gICAgICBzcGFuUGF0aFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXRocztcbn0sIHJlbW92ZUFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGFjdGlvblxufSkgPT4ge1xuICBjb25zdCBlZGl0b3IgPSBhY3Rpb24uZWRpdG9yO1xuICBpZiAoZGVidWckNihcIlJlbW92aW5nIGFubm90YXRpb25cIiwgYWN0aW9uLmFubm90YXRpb24ubmFtZSksICEhZWRpdG9yLnNlbGVjdGlvbilcbiAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IFtibG9jaywgYmxvY2tQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbiwge1xuICAgICAgICBkZXB0aDogMVxuICAgICAgfSk7XG4gICAgICBpZiAoIWVkaXRvci5pc1RleHRCbG9jayhibG9jaykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHBvdGVudGlhbEFubm90YXRpb25zID0gKGJsb2NrLm1hcmtEZWZzID8/IFtdKS5maWx0ZXIoKG1hcmtEZWYpID0+IG1hcmtEZWYuX3R5cGUgPT09IGFjdGlvbi5hbm5vdGF0aW9uLm5hbWUpLCBbc2VsZWN0ZWRDaGlsZCwgc2VsZWN0ZWRDaGlsZFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uLCB7XG4gICAgICAgIGRlcHRoOiAyXG4gICAgICB9KTtcbiAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oc2VsZWN0ZWRDaGlsZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGFubm90YXRpb25Ub1JlbW92ZSA9IHNlbGVjdGVkQ2hpbGQubWFya3M/LmZpbmQoKG1hcmspID0+IHBvdGVudGlhbEFubm90YXRpb25zLnNvbWUoKG1hcmtEZWYpID0+IG1hcmtEZWYuX2tleSA9PT0gbWFyaykpO1xuICAgICAgaWYgKCFhbm5vdGF0aW9uVG9SZW1vdmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3BhbnNXaXRoU2FtZUFubm90YXRpb24gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgsIHtcbiAgICAgICAgcmV2ZXJzZTogITBcbiAgICAgIH0pKVxuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNCZWZvcmUoY2hpbGRQYXRoLCBzZWxlY3RlZENoaWxkUGF0aCkpXG4gICAgICAgICAgaWYgKGNoaWxkLm1hcmtzPy5pbmNsdWRlcyhhbm5vdGF0aW9uVG9SZW1vdmUpKVxuICAgICAgICAgICAgcHJldmlvdXNTcGFuc1dpdGhTYW1lQW5ub3RhdGlvbi5wdXNoKFtjaGlsZCwgY2hpbGRQYXRoXSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICBjb25zdCBuZXh0U3BhbnNXaXRoU2FtZUFubm90YXRpb24gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgW2NoaWxkLCBjaGlsZFBhdGhdIG9mIE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpKVxuICAgICAgICBpZiAoZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpICYmIFBhdGguaXNBZnRlcihjaGlsZFBhdGgsIHNlbGVjdGVkQ2hpbGRQYXRoKSlcbiAgICAgICAgICBpZiAoY2hpbGQubWFya3M/LmluY2x1ZGVzKGFubm90YXRpb25Ub1JlbW92ZSkpXG4gICAgICAgICAgICBuZXh0U3BhbnNXaXRoU2FtZUFubm90YXRpb24ucHVzaChbY2hpbGQsIGNoaWxkUGF0aF0pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgWy4uLnByZXZpb3VzU3BhbnNXaXRoU2FtZUFubm90YXRpb24sIFtzZWxlY3RlZENoaWxkLCBzZWxlY3RlZENoaWxkUGF0aF0sIC4uLm5leHRTcGFuc1dpdGhTYW1lQW5ub3RhdGlvbl0pXG4gICAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgbWFya3M6IGNoaWxkLm1hcmtzPy5maWx0ZXIoKG1hcmspID0+IG1hcmsgIT09IGFubm90YXRpb25Ub1JlbW92ZSlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGF0OiBjaGlsZFBhdGhcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7fSwge1xuICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRTcGFuKG5vZGUpLFxuICAgICAgICBzcGxpdDogITAsXG4gICAgICAgIGhhbmdpbmc6ICEwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGJsb2NrcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1hdGNoOiAobm9kZSkgPT4gZWRpdG9yLmlzVGV4dEJsb2NrKG5vZGUpXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgW2Jsb2NrLCBibG9ja1BhdGhdIG9mIGJsb2Nrcykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IE5vZGUuY2hpbGRyZW4oZWRpdG9yLCBibG9ja1BhdGgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtjaGlsZCwgY2hpbGRQYXRoXSBvZiBjaGlsZHJlbikge1xuICAgICAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpIHx8ICFSYW5nZS5pbmNsdWRlcyhlZGl0b3Iuc2VsZWN0aW9uLCBjaGlsZFBhdGgpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3QgbWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyA/PyBbXSwgbWFya3MgPSBjaGlsZC5tYXJrcyA/PyBbXSwgbWFya3NXaXRob3V0QW5ub3RhdGlvbiA9IG1hcmtzLmZpbHRlcigobWFyaykgPT4gbWFya0RlZnMuZmluZCgobWFya0RlZjIpID0+IG1hcmtEZWYyLl9rZXkgPT09IG1hcmspPy5fdHlwZSAhPT0gYWN0aW9uLmFubm90YXRpb24ubmFtZSk7XG4gICAgICAgICAgbWFya3NXaXRob3V0QW5ub3RhdGlvbi5sZW5ndGggIT09IG1hcmtzLmxlbmd0aCAmJiBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgbWFya3M6IG1hcmtzV2l0aG91dEFubm90YXRpb25cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogY2hpbGRQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG59LCB0b2dnbGVBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaWYgKGlzQW5ub3RhdGlvbkFjdGl2ZSh7XG4gICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgIGFubm90YXRpb246IHtcbiAgICAgIG5hbWU6IGFjdGlvbi5hbm5vdGF0aW9uLm5hbWVcbiAgICB9XG4gIH0pKVxuICAgIHJlbW92ZUFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgICBjb250ZXh0LFxuICAgICAgYWN0aW9uOiB7XG4gICAgICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5yZW1vdmVcIixcbiAgICAgICAgYW5ub3RhdGlvbjogYWN0aW9uLmFubm90YXRpb24sXG4gICAgICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvclxuICAgICAgfVxuICAgIH0pO1xuICBlbHNlXG4gICAgcmV0dXJuIGFkZEFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgICBjb250ZXh0LFxuICAgICAgYWN0aW9uOiB7XG4gICAgICAgIHR5cGU6IFwiYW5ub3RhdGlvbi5hZGRcIixcbiAgICAgICAgYW5ub3RhdGlvbjogYWN0aW9uLmFubm90YXRpb24sXG4gICAgICAgIGVkaXRvcjogYWN0aW9uLmVkaXRvclxuICAgICAgfVxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGluc2VydEJsb2NrKHtcbiAgYmxvY2ssXG4gIHBsYWNlbWVudCxcbiAgZWRpdG9yLFxuICBzY2hlbWFcbn0pIHtcbiAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICBjb25zdCBbZm9jdXNCbG9jaywgZm9jdXNCbG9ja1BhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpLFxuICAgICAgbWF0Y2g6IChuKSA9PiAhRWRpdG9yLmlzRWRpdG9yKG4pXG4gICAgfSkpWzBdID8/IFt2b2lkIDAsIHZvaWQgMF07XG4gICAgaWYgKHBsYWNlbWVudCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICBjb25zdCBuZXh0UGF0aCA9IFtmb2N1c0Jsb2NrUGF0aFswXSArIDFdO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGJsb2NrLCB7XG4gICAgICAgIGF0OiBuZXh0UGF0aFxuICAgICAgfSksIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwge1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoOiBbbmV4dFBhdGhbMF0sIDBdLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBmb2N1czoge1xuICAgICAgICAgIHBhdGg6IFtuZXh0UGF0aFswXSwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBwbGFjZW1lbnQgPT09IFwiYmVmb3JlXCIgPyBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgYmxvY2ssIHtcbiAgICAgIGF0OiBmb2N1c0Jsb2NrUGF0aFxuICAgIH0pIDogRWRpdG9yLmluc2VydE5vZGUoZWRpdG9yLCBibG9jayk7XG4gICAgZm9jdXNCbG9jayAmJiBpc0VxdWFsVG9FbXB0eUVkaXRvcihbZm9jdXNCbG9ja10sIHNjaGVtYSkgJiYgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiBmb2N1c0Jsb2NrUGF0aFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3RCbG9jayA9IEFycmF5LmZyb20oRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IChuKSA9PiAhRWRpdG9yLmlzRWRpdG9yKG4pLFxuICAgICAgYXQ6IFtdLFxuICAgICAgcmV2ZXJzZTogITBcbiAgICB9KSlbMF07XG4gICAgRWRpdG9yLmluc2VydE5vZGUoZWRpdG9yLCBibG9jayksIGxhc3RCbG9jayAmJiBpc0VxdWFsVG9FbXB0eUVkaXRvcihbbGFzdEJsb2NrWzBdXSwgc2NoZW1hKSAmJiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IGxhc3RCbG9ja1sxXVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBpbnNlcnRCbG9ja09iamVjdEFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGJsb2NrID0gdG9TbGF0ZVZhbHVlKFt7XG4gICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICBfdHlwZTogYWN0aW9uLmJsb2NrT2JqZWN0Lm5hbWUsXG4gICAgLi4uYWN0aW9uLmJsb2NrT2JqZWN0LnZhbHVlID8gYWN0aW9uLmJsb2NrT2JqZWN0LnZhbHVlIDoge31cbiAgfV0sIHtcbiAgICBzY2hlbWFUeXBlczogY29udGV4dC5zY2hlbWFcbiAgfSlbMF07XG4gIGluc2VydEJsb2NrKHtcbiAgICBibG9jayxcbiAgICBwbGFjZW1lbnQ6IGFjdGlvbi5wbGFjZW1lbnQsXG4gICAgZWRpdG9yOiBhY3Rpb24uZWRpdG9yLFxuICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWFcbiAgfSk7XG59LCBpbnNlcnRCcmVha0FjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGtleUdlbmVyYXRvciA9IGNvbnRleHQua2V5R2VuZXJhdG9yLCBzY2hlbWEgPSBjb250ZXh0LnNjaGVtYSwgZWRpdG9yID0gYWN0aW9uLmVkaXRvcjtcbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uKVxuICAgIHJldHVybjtcbiAgY29uc3QgW2ZvY3VzU3Bhbl0gPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICBtb2RlOiBcImxvd2VzdFwiLFxuICAgIGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLFxuICAgIG1hdGNoOiAobikgPT4gZWRpdG9yLmlzVGV4dFNwYW4obiksXG4gICAgdm9pZHM6ICExXG4gIH0pKVswXSA/PyBbdm9pZCAwXSwgZm9jdXNEZWNvcmF0b3JzID0gZm9jdXNTcGFuPy5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiBzY2hlbWEuZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSA9PT0gbWFyaykpID8/IFtdLCBmb2N1c0Fubm90YXRpb25zID0gZm9jdXNTcGFuPy5tYXJrcz8uZmlsdGVyKChtYXJrKSA9PiAhc2NoZW1hLmRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IudmFsdWUgPT09IG1hcmspKSA/PyBbXSwgYW5jaG9yQmxvY2tQYXRoID0gZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IucGF0aC5zbGljZSgwLCAxKSwgZm9jdXNCbG9ja1BhdGggPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGguc2xpY2UoMCwgMSksIGZvY3VzQmxvY2sgPSBOb2RlLmRlc2NlbmRhbnQoZWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCk7XG4gIGlmIChlZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykpIHtcbiAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhlZGl0b3Iuc2VsZWN0aW9uKSwgbGFzdEZvY3VzQmxvY2tDaGlsZCA9IGZvY3VzQmxvY2suY2hpbGRyZW5bZm9jdXNCbG9jay5jaGlsZHJlbi5sZW5ndGggLSAxXSwgYXRUaGVFbmRPZkJsb2NrID0gaXNFcXVhbChzdGFydCwge1xuICAgICAgcGF0aDogWy4uLmZvY3VzQmxvY2tQYXRoLCBmb2N1c0Jsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDFdLFxuICAgICAgb2Zmc2V0OiBlZGl0b3IuaXNUZXh0U3BhbihsYXN0Rm9jdXNCbG9ja0NoaWxkKSA/IGxhc3RGb2N1c0Jsb2NrQ2hpbGQudGV4dC5sZW5ndGggOiAwXG4gICAgfSksIGF0VGhlU3RhcnRPZkJsb2NrID0gaXNFcXVhbChlbmQsIHtcbiAgICAgIHBhdGg6IFsuLi5mb2N1c0Jsb2NrUGF0aCwgMF0sXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9KTtcbiAgICBpZiAoYXRUaGVFbmRPZkJsb2NrICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pKSB7XG4gICAgICBFZGl0b3IuaW5zZXJ0Tm9kZShlZGl0b3IsIGVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgICBkZWNvcmF0b3JzOiBbXSxcbiAgICAgICAgbGlzdEl0ZW06IGZvY3VzQmxvY2subGlzdEl0ZW0sXG4gICAgICAgIGxldmVsOiBmb2N1c0Jsb2NrLmxldmVsXG4gICAgICB9KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhdFRoZVN0YXJ0T2ZCbG9jayAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSkge1xuICAgICAgRWRpdG9yLmluc2VydE5vZGUoZWRpdG9yLCBlZGl0b3IucHRlQ3JlYXRlVGV4dEJsb2NrKHtcbiAgICAgICAgZGVjb3JhdG9yczogZm9jdXNBbm5vdGF0aW9ucy5sZW5ndGggPT09IDAgPyBmb2N1c0RlY29yYXRvcnMgOiBbXSxcbiAgICAgICAgbGlzdEl0ZW06IGZvY3VzQmxvY2subGlzdEl0ZW0sXG4gICAgICAgIGxldmVsOiBmb2N1c0Jsb2NrLmxldmVsXG4gICAgICB9KSk7XG4gICAgICBjb25zdCBbbmV4dEJsb2NrUGF0aF0gPSBQYXRoLm5leHQoZm9jdXNCbG9ja1BhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB7XG4gICAgICAgIGFuY2hvcjoge1xuICAgICAgICAgIHBhdGg6IFtuZXh0QmxvY2tQYXRoLCAwXSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICBwYXRoOiBbbmV4dEJsb2NrUGF0aCwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb25BY3Jvc3NCbG9ja3MgPSBhbmNob3JCbG9ja1BhdGhbMF0gIT09IGZvY3VzQmxvY2tQYXRoWzBdO1xuICAgIGlmICghYXRUaGVTdGFydE9mQmxvY2sgJiYgIWF0VGhlRW5kT2ZCbG9jayAmJiAhc2VsZWN0aW9uQWNyb3NzQmxvY2tzKSB7XG4gICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IFtuZXh0Tm9kZSwgbmV4dE5vZGVQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgUGF0aC5uZXh0KGZvY3VzQmxvY2tQYXRoKSwge1xuICAgICAgICAgIGRlcHRoOiAxXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgYW5jaG9yOiB7XG4gICAgICAgICAgICBwYXRoOiBbLi4ubmV4dE5vZGVQYXRoLCAwXSxcbiAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgIHBhdGg6IFsuLi5uZXh0Tm9kZVBhdGgsIDBdLFxuICAgICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9KSwgZWRpdG9yLmlzVGV4dEJsb2NrKG5leHROb2RlKSAmJiBuZXh0Tm9kZS5tYXJrRGVmcyAmJiBuZXh0Tm9kZS5tYXJrRGVmcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3TWFya0RlZktleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBwcmV2Tm9kZVNwYW5zID0gQXJyYXkuZnJvbShOb2RlLmNoaWxkcmVuKGVkaXRvciwgZm9jdXNCbG9ja1BhdGgpKS5tYXAoKGVudHJ5KSA9PiBlbnRyeVswXSkuZmlsdGVyKChub2RlKSA9PiBlZGl0b3IuaXNUZXh0U3Bhbihub2RlKSksIGNoaWxkcmVuID0gTm9kZS5jaGlsZHJlbihlZGl0b3IsIG5leHROb2RlUGF0aCk7XG4gICAgICAgICAgZm9yIChjb25zdCBbY2hpbGQsIGNoaWxkUGF0aF0gb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghZWRpdG9yLmlzVGV4dFNwYW4oY2hpbGQpKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gY2hpbGQubWFya3MgPz8gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcmsgb2YgbWFya3MpXG4gICAgICAgICAgICAgIHNjaGVtYS5kZWNvcmF0b3JzLnNvbWUoKGRlY29yYXRvcikgPT4gZGVjb3JhdG9yLnZhbHVlID09PSBtYXJrKSB8fCBwcmV2Tm9kZVNwYW5zLnNvbWUoKHByZXZOb2RlU3BhbikgPT4gcHJldk5vZGVTcGFuLm1hcmtzPy5pbmNsdWRlcyhtYXJrKSkgJiYgIW5ld01hcmtEZWZLZXlzLmhhcyhtYXJrKSAmJiBuZXdNYXJrRGVmS2V5cy5zZXQobWFyaywga2V5R2VuZXJhdG9yKCkpO1xuICAgICAgICAgICAgY29uc3QgbmV3TWFya3MgPSBtYXJrcy5tYXAoKG1hcmspID0+IG5ld01hcmtEZWZLZXlzLmdldChtYXJrKSA/PyBtYXJrKTtcbiAgICAgICAgICAgIGlzRXF1YWwobWFya3MsIG5ld01hcmtzKSB8fCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICBtYXJrczogbmV3TWFya3NcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgYXQ6IGNoaWxkUGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld01hcmtEZWZzID0gbmV4dE5vZGUubWFya0RlZnMubWFwKChtYXJrRGVmKSA9PiAoe1xuICAgICAgICAgICAgLi4ubWFya0RlZixcbiAgICAgICAgICAgIF9rZXk6IG5ld01hcmtEZWZLZXlzLmdldChtYXJrRGVmLl9rZXkpID8/IG1hcmtEZWYuX2tleVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBpc0VxdWFsKG5leHROb2RlLm1hcmtEZWZzLCBuZXdNYXJrRGVmcykgfHwgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hcmtEZWZzOiBuZXdNYXJrRGVmc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGF0OiBuZXh0Tm9kZVBhdGgsXG4gICAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IGVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICBhbHdheXM6ICEwXG4gIH0pO1xufSwgaW5zZXJ0U29mdEJyZWFrQWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaW5zZXJ0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbih7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb246IHtcbiAgICAgIC4uLmFjdGlvbixcbiAgICAgIHR5cGU6IFwiaW5zZXJ0LmJyZWFrXCJcbiAgICB9XG4gIH0pO1xufSwgaW5zZXJ0SW5saW5lT2JqZWN0QWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBjb250ZXh0LFxuICBhY3Rpb25cbn0pID0+IHtcbiAgaWYgKCFjb250ZXh0LnNjaGVtYS5pbmxpbmVPYmplY3RzLnNvbWUoKGlubGluZU9iamVjdCkgPT4gaW5saW5lT2JqZWN0Lm5hbWUgPT09IGFjdGlvbi5pbmxpbmVPYmplY3QubmFtZSkpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGluc2VydCB1bmtub3duIGlubGluZSBvYmplY3RcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGluc2VydCBpbmxpbmUgb2JqZWN0IHdpdGhvdXQgc2VsZWN0aW9uXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbZm9jdXNUZXh0QmxvY2tdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLFxuICAgIG1hdGNoOiAobm9kZSkgPT4gYWN0aW9uLmVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICB9KSkuYXQoMCkgPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgaWYgKCFmb2N1c1RleHRCbG9jaykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gcGVyZm9ybSBhY3Rpb24gd2l0aG91dCBmb2N1cyB0ZXh0IGJsb2NrXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjaGlsZCA9IHRvU2xhdGVWYWx1ZShbe1xuICAgIF90eXBlOiBjb250ZXh0LnNjaGVtYS5ibG9jay5uYW1lLFxuICAgIF9rZXk6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICBfdHlwZTogYWN0aW9uLmlubGluZU9iamVjdC5uYW1lLFxuICAgICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgIC4uLmFjdGlvbi5pbmxpbmVPYmplY3QudmFsdWUgPz8ge31cbiAgICB9XVxuICB9XSwge1xuICAgIHNjaGVtYVR5cGVzOiBjb250ZXh0LnNjaGVtYVxuICB9KS5hdCgwKT8uY2hpbGRyZW4uYXQoMCk7XG4gIGlmICghY2hpbGQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGluc2VydCBpbmxpbmUgb2JqZWN0XCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGFjdGlvbi5lZGl0b3IsIGNoaWxkKTtcbn0sIGluc2VydFNwYW5BY3Rpb25JbXBsZW1lbnRhdGlvbiA9ICh7XG4gIGNvbnRleHQsXG4gIGFjdGlvblxufSkgPT4ge1xuICBpZiAoIWFjdGlvbi5lZGl0b3Iuc2VsZWN0aW9uKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBwZXJmb3JtIGFjdGlvbiB3aXRob3V0IHNlbGVjdGlvblwiLCBhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbZm9jdXNCbG9jaywgZm9jdXNCbG9ja1BhdGhdID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIGF0OiBhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLFxuICAgIG1hdGNoOiAobm9kZSkgPT4gYWN0aW9uLmVkaXRvci5pc1RleHRCbG9jayhub2RlKVxuICB9KSlbMF0gPz8gW3ZvaWQgMCwgdm9pZCAwXTtcbiAgaWYgKCFmb2N1c0Jsb2NrIHx8ICFmb2N1c0Jsb2NrUGF0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gcGVyZm9ybSBhY3Rpb24gd2l0aG91dCBmb2N1cyBibG9ja1wiLCBhY3Rpb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBtYXJrRGVmcyA9IGZvY3VzQmxvY2subWFya0RlZnMgPz8gW10sIGFubm90YXRpb25zID0gYWN0aW9uLmFubm90YXRpb25zID8gYWN0aW9uLmFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4gKHtcbiAgICBfdHlwZTogYW5ub3RhdGlvbi5uYW1lLFxuICAgIF9rZXk6IGNvbnRleHQua2V5R2VuZXJhdG9yKCksXG4gICAgLi4uYW5ub3RhdGlvbi52YWx1ZVxuICB9KSkgOiB2b2lkIDA7XG4gIGFubm90YXRpb25zICYmIGFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgVHJhbnNmb3Jtcy5zZXROb2RlcyhhY3Rpb24uZWRpdG9yLCB7XG4gICAgbWFya0RlZnM6IFsuLi5tYXJrRGVmcywgLi4uYW5ub3RhdGlvbnNdXG4gIH0pLCBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICB0ZXh0OiBhY3Rpb24udGV4dCxcbiAgICBtYXJrczogWy4uLmFubm90YXRpb25zPy5tYXAoKGFubm90YXRpb24pID0+IGFubm90YXRpb24uX2tleSkgPz8gW10sIC4uLmFjdGlvbi5kZWNvcmF0b3JzID8/IFtdXVxuICB9KTtcbn0sIHRleHRCbG9ja1NldEFjdGlvbkltcGxlbWVudGF0aW9uID0gKHtcbiAgYWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IGF0ID0gdG9TbGF0ZVJhbmdlKHtcbiAgICBhbmNob3I6IHtcbiAgICAgIHBhdGg6IGFjdGlvbi5hdCxcbiAgICAgIG9mZnNldDogMFxuICAgIH0sXG4gICAgZm9jdXM6IHtcbiAgICAgIHBhdGg6IGFjdGlvbi5hdCxcbiAgICAgIG9mZnNldDogMFxuICAgIH1cbiAgfSwgYWN0aW9uLmVkaXRvcik7XG4gIFRyYW5zZm9ybXMuc2V0Tm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgIC4uLmFjdGlvbi5zdHlsZSA/IHtcbiAgICAgIHN0eWxlOiBhY3Rpb24uc3R5bGVcbiAgICB9IDoge30sXG4gICAgLi4uYWN0aW9uLmxpc3RJdGVtID8ge1xuICAgICAgbGlzdEl0ZW06IGFjdGlvbi5saXN0SXRlbVxuICAgIH0gOiB7fSxcbiAgICAuLi5hY3Rpb24ubGV2ZWwgPyB7XG4gICAgICBsZXZlbDogYWN0aW9uLmxldmVsXG4gICAgfSA6IHt9XG4gIH0sIHtcbiAgICBhdFxuICB9KTtcbn0sIHRleHRCbG9ja1Vuc2V0QWN0aW9uSW1wbGVtZW50YXRpb24gPSAoe1xuICBhY3Rpb25cbn0pID0+IHtcbiAgY29uc3QgYXQgPSB0b1NsYXRlUmFuZ2Uoe1xuICAgIGFuY2hvcjoge1xuICAgICAgcGF0aDogYWN0aW9uLmF0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICBmb2N1czoge1xuICAgICAgcGF0aDogYWN0aW9uLmF0LFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfVxuICB9LCBhY3Rpb24uZWRpdG9yKTtcbiAgVHJhbnNmb3Jtcy51bnNldE5vZGVzKGFjdGlvbi5lZGl0b3IsIGFjdGlvbi5wcm9wcywge1xuICAgIGF0XG4gIH0pO1xufSwgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMgPSB7XG4gIFwiYW5ub3RhdGlvbi5hZGRcIjogYWRkQW5ub3RhdGlvbkFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImFubm90YXRpb24ucmVtb3ZlXCI6IHJlbW92ZUFubm90YXRpb25BY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJhbm5vdGF0aW9uLnRvZ2dsZVwiOiB0b2dnbGVBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIGJsdXI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBSZWFjdEVkaXRvci5ibHVyKGFjdGlvbi5lZGl0b3IpO1xuICB9LFxuICBcImRlY29yYXRvci5hZGRcIjogYWRkRGVjb3JhdG9yQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiZGVjb3JhdG9yLnJlbW92ZVwiOiByZW1vdmVEZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJkZWNvcmF0b3IudG9nZ2xlXCI6IHRvZ2dsZURlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBmb2N1czogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIFJlYWN0RWRpdG9yLmZvY3VzKGFjdGlvbi5lZGl0b3IpO1xuICB9LFxuICBcImRlbGV0ZS5iYWNrd2FyZFwiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgZGVsZXRlQmFja3dhcmQoYWN0aW9uLmVkaXRvciwgYWN0aW9uLnVuaXQpO1xuICB9LFxuICBcImRlbGV0ZS5mb3J3YXJkXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBkZWxldGVGb3J3YXJkKGFjdGlvbi5lZGl0b3IsIGFjdGlvbi51bml0KTtcbiAgfSxcbiAgXCJkZWxldGUuYmxvY2tcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHJhbmdlID0gdG9TbGF0ZVJhbmdlKHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBhY3Rpb24uYmxvY2tQYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBmb2N1czoge1xuICAgICAgICBwYXRoOiBhY3Rpb24uYmxvY2tQYXRoLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH1cbiAgICB9LCBhY3Rpb24uZWRpdG9yKTtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGZpbmQgU2xhdGUgcmFuZ2UgZnJvbSBzZWxlY3Rpb24gcG9pbnRzXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICB9LFxuICBcImRlbGV0ZS50ZXh0XCI6ICh7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gZnJvbVNsYXRlVmFsdWUoYWN0aW9uLmVkaXRvci5jaGlsZHJlbiwgY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGFjdGlvbi5lZGl0b3IpKSwgYW5jaG9yID0gYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGJsb2NrT2Zmc2V0OiBhY3Rpb24uYW5jaG9yXG4gICAgfSksIGZvY3VzID0gYmxvY2tPZmZzZXRUb1NwYW5TZWxlY3Rpb25Qb2ludCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIGJsb2NrT2Zmc2V0OiBhY3Rpb24uZm9jdXNcbiAgICB9KTtcbiAgICBpZiAoIWFuY2hvciB8fCAhZm9jdXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gZmluZCBhbmNob3Igb3IgZm9jdXMgc2VsZWN0aW9uIHBvaW50XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IHRvU2xhdGVSYW5nZSh7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0sIGFjdGlvbi5lZGl0b3IpO1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gZmluZCBTbGF0ZSByYW5nZSBmcm9tIHNlbGVjdGlvbiBwb2ludHNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGFjdGlvbi5lZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICB9LFxuICBcImluc2VydC5ibG9jayBvYmplY3RcIjogaW5zZXJ0QmxvY2tPYmplY3RBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuYnJlYWtcIjogaW5zZXJ0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuaW5saW5lIG9iamVjdFwiOiBpbnNlcnRJbmxpbmVPYmplY3RBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuc29mdCBicmVha1wiOiBpbnNlcnRTb2Z0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJpbnNlcnQuc3BhblwiOiBpbnNlcnRTcGFuQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwiaW5zZXJ0LnRleHRcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGluc2VydFRleHQoYWN0aW9uLmVkaXRvciwgYWN0aW9uLnRleHQpO1xuICB9LFxuICBcImluc2VydC50ZXh0IGJsb2NrXCI6ICh7XG4gICAgY29udGV4dCxcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGNvbnN0IGJsb2NrID0gdG9TbGF0ZVZhbHVlKFt7XG4gICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpLFxuICAgICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsXG4gICAgICBzdHlsZTogY29udGV4dC5zY2hlbWEuc3R5bGVzWzBdLnZhbHVlID8/IFwibm9ybWFsXCIsXG4gICAgICBtYXJrRGVmczogW10sXG4gICAgICBjaGlsZHJlbjogYWN0aW9uLnRleHRCbG9jaz8uY2hpbGRyZW4/Lm1hcCgoY2hpbGQpID0+ICh7XG4gICAgICAgIC4uLmNoaWxkLFxuICAgICAgICBfa2V5OiBjb250ZXh0LmtleUdlbmVyYXRvcigpXG4gICAgICB9KSkgPz8gW3tcbiAgICAgICAgX3R5cGU6IGNvbnRleHQuc2NoZW1hLnNwYW4ubmFtZSxcbiAgICAgICAgX2tleTogY29udGV4dC5rZXlHZW5lcmF0b3IoKSxcbiAgICAgICAgdGV4dDogXCJcIlxuICAgICAgfV1cbiAgICB9XSwge1xuICAgICAgc2NoZW1hVHlwZXM6IGNvbnRleHQuc2NoZW1hXG4gICAgfSlbMF07XG4gICAgaW5zZXJ0QmxvY2soe1xuICAgICAgYmxvY2ssXG4gICAgICBlZGl0b3I6IGFjdGlvbi5lZGl0b3IsXG4gICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgcGxhY2VtZW50OiBhY3Rpb24ucGxhY2VtZW50XG4gICAgfSk7XG4gIH0sXG4gIGVmZmVjdDogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGFjdGlvbi5lZmZlY3QoKTtcbiAgfSxcbiAgXCJsaXN0IGl0ZW0uYWRkXCI6IGFkZExpc3RJdGVtQWN0aW9uSW1wbGVtZW50YXRpb24sXG4gIFwibGlzdCBpdGVtLnJlbW92ZVwiOiByZW1vdmVMaXN0SXRlbUFjdGlvbkltcGxlbWVudGF0aW9uLFxuICBcImxpc3QgaXRlbS50b2dnbGVcIjogdG9nZ2xlTGlzdEl0ZW1BY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJtb3ZlLmJsb2NrXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBjb25zdCBhdCA9IFt0b1NsYXRlUGF0aChhY3Rpb24uYXQsIGFjdGlvbi5lZGl0b3IpWzBdXSwgdG8gPSBbdG9TbGF0ZVBhdGgoYWN0aW9uLnRvLCBhY3Rpb24uZWRpdG9yKVswXV07XG4gICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICB0byxcbiAgICAgIG1vZGU6IFwiaGlnaGVzdFwiXG4gICAgfSk7XG4gIH0sXG4gIFwibW92ZS5ibG9jayBkb3duXCI6ICh7XG4gICAgYWN0aW9uXG4gIH0pID0+IHtcbiAgICBjb25zdCBhdCA9IFt0b1NsYXRlUGF0aChhY3Rpb24uYXQsIGFjdGlvbi5lZGl0b3IpWzBdXSwgdG8gPSBbUGF0aC5uZXh0KGF0KVswXV07XG4gICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICB0byxcbiAgICAgIG1vZGU6IFwiaGlnaGVzdFwiXG4gICAgfSk7XG4gIH0sXG4gIFwibW92ZS5ibG9jayB1cFwiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgY29uc3QgYXQgPSBbdG9TbGF0ZVBhdGgoYWN0aW9uLmF0LCBhY3Rpb24uZWRpdG9yKVswXV07XG4gICAgaWYgKCFQYXRoLmhhc1ByZXZpb3VzKGF0KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0byA9IFtQYXRoLnByZXZpb3VzKGF0KVswXV07XG4gICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoYWN0aW9uLmVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICB0byxcbiAgICAgIG1vZGU6IFwiaGlnaGVzdFwiXG4gICAgfSk7XG4gIH0sXG4gIG5vb3A6ICgpID0+IHtcbiAgfSxcbiAgc2VsZWN0OiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgY29uc3QgbmV3U2VsZWN0aW9uID0gdG9TbGF0ZVJhbmdlKGFjdGlvbi5zZWxlY3Rpb24sIGFjdGlvbi5lZGl0b3IpO1xuICAgIG5ld1NlbGVjdGlvbiA/IFRyYW5zZm9ybXMuc2VsZWN0KGFjdGlvbi5lZGl0b3IsIG5ld1NlbGVjdGlvbikgOiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGFjdGlvbi5lZGl0b3IpO1xuICB9LFxuICBcInNlbGVjdC5wcmV2aW91cyBibG9ja1wiOiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgaWYgKCFhY3Rpb24uZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBzZWxlY3QgcHJldmlvdXMgYmxvY2sgd2l0aG91dCBhIHNlbGVjdGlvblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tQYXRoID0gYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKTtcbiAgICBpZiAoIVBhdGguaGFzUHJldmlvdXMoYmxvY2tQYXRoKSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRoZXJlJ3Mgbm8gcHJldmlvdXMgYmxvY2sgdG8gc2VsZWN0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0Jsb2NrUGF0aCA9IFBhdGgucHJldmlvdXMoYmxvY2tQYXRoKTtcbiAgICBUcmFuc2Zvcm1zLnNlbGVjdChhY3Rpb24uZWRpdG9yLCBwcmV2aW91c0Jsb2NrUGF0aCk7XG4gIH0sXG4gIFwic2VsZWN0Lm5leHQgYmxvY2tcIjogKHtcbiAgICBhY3Rpb25cbiAgfSkgPT4ge1xuICAgIGlmICghYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gc2VsZWN0IG5leHQgYmxvY2sgd2l0aG91dCBhIHNlbGVjdGlvblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dEJsb2NrUGF0aCA9IFthY3Rpb24uZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLnNsaWNlKDAsIDEpWzBdICsgMV07XG4gICAgVHJhbnNmb3Jtcy5zZWxlY3QoYWN0aW9uLmVkaXRvciwgbmV4dEJsb2NrUGF0aCk7XG4gIH0sXG4gIHJlc2VsZWN0OiAoe1xuICAgIGFjdGlvblxuICB9KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gYWN0aW9uLmVkaXRvci5zZWxlY3Rpb247XG4gICAgc2VsZWN0aW9uICYmIChUcmFuc2Zvcm1zLnNlbGVjdChhY3Rpb24uZWRpdG9yLCB7XG4gICAgICAuLi5zZWxlY3Rpb25cbiAgICB9KSwgYWN0aW9uLmVkaXRvci5zZWxlY3Rpb24gPSB7XG4gICAgICAuLi5zZWxlY3Rpb25cbiAgICB9KTtcbiAgfSxcbiAgXCJzdHlsZS50b2dnbGVcIjogdG9nZ2xlU3R5bGVBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJzdHlsZS5hZGRcIjogYWRkU3R5bGVBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJzdHlsZS5yZW1vdmVcIjogcmVtb3ZlU3R5bGVBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJ0ZXh0IGJsb2NrLnNldFwiOiB0ZXh0QmxvY2tTZXRBY3Rpb25JbXBsZW1lbnRhdGlvbixcbiAgXCJ0ZXh0IGJsb2NrLnVuc2V0XCI6IHRleHRCbG9ja1Vuc2V0QWN0aW9uSW1wbGVtZW50YXRpb25cbn07XG5mdW5jdGlvbiBwZXJmb3JtQWN0aW9uKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiZGVsZXRlLmJsb2NrXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVsZXRlLmJsb2NrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVsZXRlLnRleHRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWxldGUudGV4dFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImluc2VydC5zcGFuXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LnNwYW5cIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbnNlcnQudGV4dCBibG9ja1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydC50ZXh0IGJsb2NrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibGlzdCBpdGVtLmFkZFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImxpc3QgaXRlbS5hZGRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJsaXN0IGl0ZW0ucmVtb3ZlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wibGlzdCBpdGVtLnJlbW92ZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIm1vdmUuYmxvY2tcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJtb3ZlLmJsb2NrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibW92ZS5ibG9jayBkb3duXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wibW92ZS5ibG9jayBkb3duXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibW92ZS5ibG9jayB1cFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcIm1vdmUuYmxvY2sgdXBcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJub29wXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZWZmZWN0XCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zLmVmZmVjdCh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInNlbGVjdFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9ucy5zZWxlY3Qoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJzZWxlY3QucHJldmlvdXMgYmxvY2tcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJzZWxlY3QucHJldmlvdXMgYmxvY2tcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJzZWxlY3QubmV4dCBibG9ja1wiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcInNlbGVjdC5uZXh0IGJsb2NrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwicmVzZWxlY3RcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnMucmVzZWxlY3Qoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJzdHlsZS5hZGRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJzdHlsZS5hZGRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJzdHlsZS5yZW1vdmVcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJzdHlsZS5yZW1vdmVcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ0ZXh0IGJsb2NrLnNldFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcInRleHQgYmxvY2suc2V0XCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwidGV4dCBibG9jay51bnNldFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcInRleHQgYmxvY2sudW5zZXRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBwZXJmb3JtRGVmYXVsdEFjdGlvbih7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBlcmZvcm1EZWZhdWx0QWN0aW9uKHtcbiAgY29udGV4dCxcbiAgYWN0aW9uXG59KSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiYW5ub3RhdGlvbi5hZGRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJhbm5vdGF0aW9uLmFkZFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImFubm90YXRpb24ucmVtb3ZlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiYW5ub3RhdGlvbi5yZW1vdmVcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJhbm5vdGF0aW9uLnRvZ2dsZVwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImFubm90YXRpb24udG9nZ2xlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiYmx1clwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9ucy5ibHVyKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVjb3JhdG9yLmFkZFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImRlY29yYXRvci5hZGRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkZWNvcmF0b3IucmVtb3ZlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVjb3JhdG9yLnJlbW92ZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImRlY29yYXRvci50b2dnbGVcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWNvcmF0b3IudG9nZ2xlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVsZXRlLmJhY2t3YXJkXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiZGVsZXRlLmJhY2t3YXJkXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZGVsZXRlLmZvcndhcmRcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJkZWxldGUuZm9yd2FyZFwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZvY3VzXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zLmZvY3VzKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0LmJsb2NrIG9iamVjdFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydC5ibG9jayBvYmplY3RcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJpbnNlcnQuaW5saW5lIG9iamVjdFwiOiB7XG4gICAgICBiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9uc1tcImluc2VydC5pbmxpbmUgb2JqZWN0XCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0LmJyZWFrXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LmJyZWFrXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiaW5zZXJ0LnNvZnQgYnJlYWtcIjoge1xuICAgICAgYmVoYXZpb3JBY3Rpb25JbXBsZW1lbnRhdGlvbnNbXCJpbnNlcnQuc29mdCBicmVha1wiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImluc2VydC50ZXh0XCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wiaW5zZXJ0LnRleHRcIl0oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBhY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJsaXN0IGl0ZW0udG9nZ2xlXCI6IHtcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wibGlzdCBpdGVtLnRvZ2dsZVwiXSh7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFjdGlvblxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGJlaGF2aW9yQWN0aW9uSW1wbGVtZW50YXRpb25zW1wic3R5bGUudG9nZ2xlXCJdKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWN0aW9uXG4gICAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRGVjb3JhdG9ycyh7XG4gIHNjaGVtYSxcbiAgc2xhdGVFZGl0b3JJbnN0YW5jZVxufSkge1xuICBjb25zdCBkZWNvcmF0b3JzID0gc2NoZW1hLmRlY29yYXRvcnMubWFwKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci52YWx1ZSk7XG4gIHJldHVybiAoe1xuICAgIC4uLkVkaXRvci5tYXJrcyhzbGF0ZUVkaXRvckluc3RhbmNlKSA/PyB7fVxuICB9Lm1hcmtzID8/IFtdKS5maWx0ZXIoKG1hcmspID0+IGRlY29yYXRvcnMuaW5jbHVkZXMobWFyaykpO1xufVxuY29uc3QgZWRpdG9yTWFjaGluZSA9IHNldHVwKHtcbiAgdHlwZXM6IHtcbiAgICBjb250ZXh0OiB7fSxcbiAgICBldmVudHM6IHt9LFxuICAgIGVtaXR0ZWQ6IHt9LFxuICAgIGlucHV0OiB7fVxuICB9LFxuICBhY3Rpb25zOiB7XG4gICAgXCJhc3NpZ24gYmVoYXZpb3JzXCI6IGFzc2lnbih7XG4gICAgICBiZWhhdmlvcnM6ICh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwidXBkYXRlIGJlaGF2aW9yc1wiKSwgZXZlbnQuYmVoYXZpb3JzKVxuICAgIH0pLFxuICAgIFwiYXNzaWduIHNjaGVtYVwiOiBhc3NpZ24oe1xuICAgICAgc2NoZW1hOiAoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInVwZGF0ZSBzY2hlbWFcIiksIGV2ZW50LnNjaGVtYSlcbiAgICB9KSxcbiAgICBcImVtaXQgcGF0Y2ggZXZlbnRcIjogZW1pdCgoe1xuICAgICAgZXZlbnRcbiAgICB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwicGF0Y2hcIiksIGV2ZW50KSksXG4gICAgXCJlbWl0IG11dGF0aW9uIGV2ZW50XCI6IGVtaXQoKHtcbiAgICAgIGV2ZW50XG4gICAgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcIm11dGF0aW9uXCIpLCBldmVudCkpLFxuICAgIFwiZW1pdCByZWFkIG9ubHlcIjogZW1pdCh7XG4gICAgICB0eXBlOiBcInJlYWQgb25seVwiXG4gICAgfSksXG4gICAgXCJlbWl0IGVkaXRhYmxlXCI6IGVtaXQoe1xuICAgICAgdHlwZTogXCJlZGl0YWJsZVwiXG4gICAgfSksXG4gICAgXCJkZWZlciBldmVudFwiOiBhc3NpZ24oe1xuICAgICAgcGVuZGluZ0V2ZW50czogKHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IChhc3NlcnRFdmVudChldmVudCwgW1wicGF0Y2hcIiwgXCJtdXRhdGlvblwiXSksIFsuLi5jb250ZXh0LnBlbmRpbmdFdmVudHMsIGV2ZW50XSlcbiAgICB9KSxcbiAgICBcImVtaXQgcGVuZGluZyBldmVudHNcIjogZW5xdWV1ZUFjdGlvbnMoKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBlbnF1ZXVlXG4gICAgfSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBldmVudCBvZiBjb250ZXh0LnBlbmRpbmdFdmVudHMpXG4gICAgICAgIGVucXVldWUoZW1pdChldmVudCkpO1xuICAgIH0pLFxuICAgIFwiZW1pdCByZWFkeVwiOiBlbWl0KHtcbiAgICAgIHR5cGU6IFwicmVhZHlcIlxuICAgIH0pLFxuICAgIFwiY2xlYXIgcGVuZGluZyBldmVudHNcIjogYXNzaWduKHtcbiAgICAgIHBlbmRpbmdFdmVudHM6IFtdXG4gICAgfSksXG4gICAgXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIjogZW5xdWV1ZUFjdGlvbnMoKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIGVucXVldWVcbiAgICB9KSA9PiB7XG4gICAgICBhc3NlcnRFdmVudChldmVudCwgW1wiYmVoYXZpb3IgZXZlbnRcIl0pO1xuICAgICAgY29uc3QgZGVmYXVsdEFjdGlvbiA9IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJjb3B5XCIgfHwgZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlID09PSBcImtleS5kb3duXCIgfHwgZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlID09PSBcImtleS51cFwiIHx8IGV2ZW50LmJlaGF2aW9yRXZlbnQudHlwZSA9PT0gXCJwYXN0ZVwiID8gdm9pZCAwIDoge1xuICAgICAgICAuLi5ldmVudC5iZWhhdmlvckV2ZW50LFxuICAgICAgICBlZGl0b3I6IGV2ZW50LmVkaXRvclxuICAgICAgfSwgZXZlbnRCZWhhdmlvcnMgPSBjb250ZXh0LmJlaGF2aW9ycy5maWx0ZXIoKGJlaGF2aW9yKSA9PiBiZWhhdmlvci5vbiA9PT0gZXZlbnQuYmVoYXZpb3JFdmVudC50eXBlKTtcbiAgICAgIGlmIChldmVudEJlaGF2aW9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKCFkZWZhdWx0QWN0aW9uKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhldmVudC5lZGl0b3IsICgpID0+IHtcbiAgICAgICAgICBwZXJmb3JtQWN0aW9uKHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBhY3Rpb246IGRlZmF1bHRBY3Rpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGV2ZW50LmVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGZyb21TbGF0ZVZhbHVlKGV2ZW50LmVkaXRvci5jaGlsZHJlbiwgY29udGV4dC5zY2hlbWEuYmxvY2submFtZSwgS0VZX1RPX1ZBTFVFX0VMRU1FTlQuZ2V0KGV2ZW50LmVkaXRvcikpLCBzZWxlY3Rpb24gPSB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlLCBldmVudC5lZGl0b3Iuc2VsZWN0aW9uLCBjb250ZXh0LnNjaGVtYSksIGVkaXRvckNvbnRleHQgPSB7XG4gICAgICAgIGFjdGl2ZURlY29yYXRvcnM6IGdldEFjdGl2ZURlY29yYXRvcnMoe1xuICAgICAgICAgIHNjaGVtYTogY29udGV4dC5zY2hlbWEsXG4gICAgICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogZXZlbnQuZWRpdG9yXG4gICAgICAgIH0pLFxuICAgICAgICBrZXlHZW5lcmF0b3I6IGNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgICBzY2hlbWE6IGNvbnRleHQuc2NoZW1hLFxuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgICAgbGV0IGJlaGF2aW9yT3ZlcndyaXR0ZW4gPSAhMTtcbiAgICAgIGZvciAoY29uc3QgZXZlbnRCZWhhdmlvciBvZiBldmVudEJlaGF2aW9ycykge1xuICAgICAgICBjb25zdCBzaG91bGRSdW4gPSBldmVudEJlaGF2aW9yLmd1YXJkID09PSB2b2lkIDAgfHwgZXZlbnRCZWhhdmlvci5ndWFyZCh7XG4gICAgICAgICAgY29udGV4dDogZWRpdG9yQ29udGV4dCxcbiAgICAgICAgICBldmVudDogZXZlbnQuYmVoYXZpb3JFdmVudFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzaG91bGRSdW4pXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGFjdGlvbkludGVuZFNldHMgPSBldmVudEJlaGF2aW9yLmFjdGlvbnMubWFwKChhY3Rpb25TZXQpID0+IGFjdGlvblNldCh7XG4gICAgICAgICAgY29udGV4dDogZWRpdG9yQ29udGV4dCxcbiAgICAgICAgICBldmVudDogZXZlbnQuYmVoYXZpb3JFdmVudFxuICAgICAgICB9LCBzaG91bGRSdW4pKTtcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25JbnRlbmRzIG9mIGFjdGlvbkludGVuZFNldHMpXG4gICAgICAgICAgYmVoYXZpb3JPdmVyd3JpdHRlbiA9IGJlaGF2aW9yT3ZlcndyaXR0ZW4gfHwgYWN0aW9uSW50ZW5kcy5sZW5ndGggPiAwICYmIGFjdGlvbkludGVuZHMuc29tZSgoYWN0aW9uSW50ZW5kKSA9PiBhY3Rpb25JbnRlbmQudHlwZSAhPT0gXCJlZmZlY3RcIiksIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZXZlbnQuZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbkludGVuZCBvZiBhY3Rpb25JbnRlbmRzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAuLi5hY3Rpb25JbnRlbmQsXG4gICAgICAgICAgICAgICAgZWRpdG9yOiBldmVudC5lZGl0b3JcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcGVyZm9ybUFjdGlvbih7XG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICBhY3Rpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGV2ZW50LmVkaXRvci5vbkNoYW5nZSgpLCBhY3Rpb25JbnRlbmRzLnNvbWUoKGFjdGlvbkludGVuZCkgPT4gYWN0aW9uSW50ZW5kLnR5cGUgPT09IFwicmVzZWxlY3RcIikgJiYgZW5xdWV1ZS5yYWlzZSh7XG4gICAgICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB0b1BvcnRhYmxlVGV4dFJhbmdlKGV2ZW50LmVkaXRvci5jaGlsZHJlbiwgZXZlbnQuZWRpdG9yLnNlbGVjdGlvbiwgY29udGV4dC5zY2hlbWEpXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChiZWhhdmlvck92ZXJ3cml0dGVuKSB7XG4gICAgICAgICAgZXZlbnQubmF0aXZlRXZlbnQ/LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghYmVoYXZpb3JPdmVyd3JpdHRlbikge1xuICAgICAgICBpZiAoIWRlZmF1bHRBY3Rpb24pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGV2ZW50LmVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgIHBlcmZvcm1BY3Rpb24oe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGFjdGlvbjogZGVmYXVsdEFjdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgZXZlbnQuZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIGlkOiBcImVkaXRvclwiLFxuICBjb250ZXh0OiAoe1xuICAgIGlucHV0XG4gIH0pID0+ICh7XG4gICAgYmVoYXZpb3JzOiBpbnB1dC5iZWhhdmlvcnMgPz8gY29yZUJlaGF2aW9ycyxcbiAgICBrZXlHZW5lcmF0b3I6IGlucHV0LmtleUdlbmVyYXRvcixcbiAgICBwZW5kaW5nRXZlbnRzOiBbXSxcbiAgICBzY2hlbWE6IGlucHV0LnNjaGVtYSxcbiAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgaW5pdGlhbFJlYWRPbmx5OiBpbnB1dC5yZWFkT25seSA/PyAhMSxcbiAgICBtYXhCbG9ja3M6IGlucHV0Lm1heEJsb2NrcyxcbiAgICB2YWx1ZTogaW5wdXQudmFsdWVcbiAgfSksXG4gIG9uOiB7XG4gICAgdW5zZXQ6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgXCJ2YWx1ZSBjaGFuZ2VkXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgXCJpbnZhbGlkIHZhbHVlXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgZXJyb3I6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgc2VsZWN0aW9uOiB7XG4gICAgICBhY3Rpb25zOiBbYXNzaWduKHtcbiAgICAgICAgc2VsZWN0aW9uOiAoe1xuICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pID0+IGV2ZW50LnNlbGVjdGlvblxuICAgICAgfSksIGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KV1cbiAgICB9LFxuICAgIGJsdXJyZWQ6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pID0+IGV2ZW50KVxuICAgIH0sXG4gICAgZm9jdXNlZDoge1xuICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICBldmVudFxuICAgICAgfSkgPT4gZXZlbnQpXG4gICAgfSxcbiAgICBsb2FkaW5nOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KHtcbiAgICAgICAgdHlwZTogXCJsb2FkaW5nXCJcbiAgICAgIH0pXG4gICAgfSxcbiAgICBwYXRjaGVzOiB7XG4gICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgIGV2ZW50XG4gICAgICB9KSA9PiBldmVudClcbiAgICB9LFxuICAgIFwiZG9uZSBsb2FkaW5nXCI6IHtcbiAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICAgICAgICB0eXBlOiBcImRvbmUgbG9hZGluZ1wiXG4gICAgICB9KVxuICAgIH0sXG4gICAgXCJ1cGRhdGUgYmVoYXZpb3JzXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwiYXNzaWduIGJlaGF2aW9yc1wiXG4gICAgfSxcbiAgICBcInVwZGF0ZSBzY2hlbWFcIjoge1xuICAgICAgYWN0aW9uczogXCJhc3NpZ24gc2NoZW1hXCJcbiAgICB9LFxuICAgIFwidXBkYXRlIHZhbHVlXCI6IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIHZhbHVlOiAoe1xuICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pID0+IGV2ZW50LnZhbHVlXG4gICAgICB9KVxuICAgIH0sXG4gICAgXCJ1cGRhdGUgbWF4QmxvY2tzXCI6IHtcbiAgICAgIGFjdGlvbnM6IGFzc2lnbih7XG4gICAgICAgIG1heEJsb2NrczogKHtcbiAgICAgICAgICBldmVudFxuICAgICAgICB9KSA9PiBldmVudC5tYXhCbG9ja3NcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICB0eXBlOiBcInBhcmFsbGVsXCIsXG4gIHN0YXRlczoge1xuICAgIFwiZWRpdCBtb2RlXCI6IHtcbiAgICAgIGluaXRpYWw6IFwicmVhZCBvbmx5XCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgXCJyZWFkIG9ubHlcIjoge1xuICAgICAgICAgIGluaXRpYWw6IFwiZGV0ZXJtaW5lIGluaXRpYWwgZWRpdCBtb2RlXCIsXG4gICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICBcImRldGVybWluZSBpbml0aWFsIGVkaXQgbW9kZVwiOiB7XG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgXCJkb25lIHN5bmNpbmcgaW5pdGlhbCB2YWx1ZVwiOiBbe1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZWRpdCBtb2RlLnJlYWQgb25seS5yZWFkIG9ubHlcIixcbiAgICAgICAgICAgICAgICAgIGd1YXJkOiAoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgICB9KSA9PiBjb250ZXh0LmluaXRpYWxSZWFkT25seVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLmVkaXQgbW9kZS5lZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicmVhZCBvbmx5XCI6IHtcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBcInVwZGF0ZSByZWFkT25seVwiOiB7XG4gICAgICAgICAgICAgICAgICBndWFyZDogKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICAgIH0pID0+ICFldmVudC5yZWFkT25seSxcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLmVkaXQgbW9kZS5lZGl0YWJsZVwiLFxuICAgICAgICAgICAgICAgICAgYWN0aW9uczogW1wiZW1pdCBlZGl0YWJsZVwiXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZWRpdGFibGU6IHtcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJ1cGRhdGUgcmVhZE9ubHlcIjoge1xuICAgICAgICAgICAgICBndWFyZDogKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudC5yZWFkT25seSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3IuZWRpdCBtb2RlLnJlYWQgb25seS5yZWFkIG9ubHlcIixcbiAgICAgICAgICAgICAgYWN0aW9uczogW1wiZW1pdCByZWFkIG9ubHlcIl1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImJlaGF2aW9yIGV2ZW50XCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJoYW5kbGUgYmVoYXZpb3IgZXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYW5ub3RhdGlvbi5hZGRcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhbm5vdGF0aW9uLnJlbW92ZVwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFubm90YXRpb24udG9nZ2xlXCI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsdXI6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZGVjb3JhdG9yLipcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXM6IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogZW1pdCgoe1xuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgIH0pID0+IGV2ZW50KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiaW5zZXJ0LipcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJsaXN0IGl0ZW0uKlwiOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IGVtaXQoKHtcbiAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICB9KSA9PiBldmVudClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInN0eWxlLipcIjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBlbWl0KCh7XG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgfSkgPT4gZXZlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXR1cDoge1xuICAgICAgaW5pdGlhbDogXCJzZXR0aW5nIHVwXCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgXCJzZXR0aW5nIHVwXCI6IHtcbiAgICAgICAgICBleGl0OiBbXCJlbWl0IHJlYWR5XCJdLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBwYXRjaDoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBcImRlZmVyIGV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdXRhdGlvbjoge1xuICAgICAgICAgICAgICBhY3Rpb25zOiBcImRlZmVyIGV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImRvbmUgc3luY2luZyBpbml0aWFsIHZhbHVlXCI6IHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBcInByaXN0aW5lXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByaXN0aW5lOiB7XG4gICAgICAgICAgaW5pdGlhbDogXCJpZGxlXCIsXG4gICAgICAgICAgc3RhdGVzOiB7XG4gICAgICAgICAgICBpZGxlOiB7XG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXppbmc6IHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJub3JtYWxpemluZ1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXRjaDoge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcIiNlZGl0b3Iuc2V0dXAuZGlydHlcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFwiZGVmZXIgZXZlbnRcIixcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjZWRpdG9yLnNldHVwLmRpcnR5XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3JtYWxpemluZzoge1xuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFwiZG9uZSBub3JtYWxpemluZ1wiOiB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXRjaDoge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtdXRhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgYWN0aW9uczogXCJkZWZlciBldmVudFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkaXJ0eToge1xuICAgICAgICAgIGVudHJ5OiBbXCJlbWl0IHBlbmRpbmcgZXZlbnRzXCIsIFwiY2xlYXIgcGVuZGluZyBldmVudHNcIl0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIHBhdGNoOiB7XG4gICAgICAgICAgICAgIGFjdGlvbnM6IFwiZW1pdCBwYXRjaCBldmVudFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXV0YXRpb246IHtcbiAgICAgICAgICAgICAgYWN0aW9uczogXCJlbWl0IG11dGF0aW9uIGV2ZW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gZ2V0VmFsdWUoe1xuICBlZGl0b3JBY3RvclNuYXBzaG90LFxuICBzbGF0ZUVkaXRvckluc3RhbmNlXG59KSB7XG4gIHJldHVybiBmcm9tU2xhdGVWYWx1ZShzbGF0ZUVkaXRvckluc3RhbmNlLmNoaWxkcmVuLCBlZGl0b3JBY3RvclNuYXBzaG90LmNvbnRleHQuc2NoZW1hLmJsb2NrLm5hbWUsIEtFWV9UT19WQUxVRV9FTEVNRU5ULmdldChzbGF0ZUVkaXRvckluc3RhbmNlKSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuZnVuY3Rpb24gdXNlRWRpdG9yU2VsZWN0b3IoZWRpdG9yLCBzZWxlY3RvciwgdDApIHtcbiAgY29uc3QgJCA9IGMoMyksIGNvbXBhcmUgPSB0MCA9PT0gdm9pZCAwID8gZGVmYXVsdENvbXBhcmUgOiB0MDtcbiAgbGV0IHQxO1xuICByZXR1cm4gJFswXSAhPT0gZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZSB8fCAkWzFdICE9PSBzZWxlY3RvciA/ICh0MSA9IChlZGl0b3JBY3RvclNuYXBzaG90KSA9PiB7XG4gICAgY29uc3Qgc25hcHNob3QgPSBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gICAgICBlZGl0b3JBY3RvclNuYXBzaG90LFxuICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvci5pbnN0YW5jZVxuICAgIH0pO1xuICAgIHJldHVybiBzZWxlY3RvcihzbmFwc2hvdCk7XG4gIH0sICRbMF0gPSBlZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluc3RhbmNlLCAkWzFdID0gc2VsZWN0b3IsICRbMl0gPSB0MSkgOiB0MSA9ICRbMl0sIHVzZVNlbGVjdG9yKGVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIHQxLCBjb21wYXJlKTtcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclNuYXBzaG90KHtcbiAgZWRpdG9yQWN0b3JTbmFwc2hvdCxcbiAgc2xhdGVFZGl0b3JJbnN0YW5jZVxufSkge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIGFjdGl2ZURlY29yYXRvcnM6IGdldEFjdGl2ZURlY29yYXRvcnMoe1xuICAgICAgICBzY2hlbWE6IGVkaXRvckFjdG9yU25hcHNob3QuY29udGV4dC5zY2hlbWEsXG4gICAgICAgIHNsYXRlRWRpdG9ySW5zdGFuY2VcbiAgICAgIH0pLFxuICAgICAga2V5R2VuZXJhdG9yOiBlZGl0b3JBY3RvclNuYXBzaG90LmNvbnRleHQua2V5R2VuZXJhdG9yLFxuICAgICAgc2NoZW1hOiBlZGl0b3JBY3RvclNuYXBzaG90LmNvbnRleHQuc2NoZW1hLFxuICAgICAgc2VsZWN0aW9uOiBlZGl0b3JBY3RvclNuYXBzaG90LmNvbnRleHQuc2VsZWN0aW9uLFxuICAgICAgdmFsdWU6IGdldFZhbHVlKHtcbiAgICAgICAgZWRpdG9yQWN0b3JTbmFwc2hvdCxcbiAgICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59XG5jb25zdCBkZWZhdWx0S2V5R2VuZXJhdG9yID0gKCkgPT4gcmFuZG9tS2V5KDEyKSwgZ2V0Qnl0ZUhleFRhYmxlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGxldCB0YWJsZTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAodGFibGUpXG4gICAgICByZXR1cm4gdGFibGU7XG4gICAgdGFibGUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKVxuICAgICAgdGFibGVbaV0gPSAoaSArIDI1NikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgIHJldHVybiB0YWJsZTtcbiAgfTtcbn0pKCk7XG5mdW5jdGlvbiB3aGF0d2dSTkcobGVuZ3RoID0gMTYpIHtcbiAgY29uc3Qgcm5kczggPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KSwgcm5kczg7XG59XG5mdW5jdGlvbiByYW5kb21LZXkobGVuZ3RoKSB7XG4gIGNvbnN0IHRhYmxlID0gZ2V0Qnl0ZUhleFRhYmxlKCk7XG4gIHJldHVybiB3aGF0d2dSTkcobGVuZ3RoKS5yZWR1Y2UoKHN0ciwgbikgPT4gc3RyICsgdGFibGVbbl0sIFwiXCIpLnNsaWNlKDAsIGxlbmd0aCk7XG59XG5mdW5jdGlvbiBjcmVhdGVFZGl0b3IoY29uZmlnKSB7XG4gIGNvbnN0IGVkaXRvckFjdG9yID0gY3JlYXRlQWN0b3IoZWRpdG9yTWFjaGluZSwge1xuICAgIGlucHV0OiBlZGl0b3JDb25maWdUb01hY2hpbmVJbnB1dChjb25maWcpXG4gIH0pO1xuICByZXR1cm4gZWRpdG9yQWN0b3Iuc3RhcnQoKSwgY3JlYXRlRWRpdG9yRnJvbUFjdG9yKGVkaXRvckFjdG9yKTtcbn1cbmZ1bmN0aW9uIHVzZUNyZWF0ZUVkaXRvcihjb25maWcpIHtcbiAgY29uc3QgJCA9IGMoNik7XG4gIGxldCB0MDtcbiAgJFswXSAhPT0gY29uZmlnID8gKHQwID0gZWRpdG9yQ29uZmlnVG9NYWNoaW5lSW5wdXQoY29uZmlnKSwgJFswXSA9IGNvbmZpZywgJFsxXSA9IHQwKSA6IHQwID0gJFsxXTtcbiAgbGV0IHQxO1xuICAkWzJdICE9PSB0MCA/ICh0MSA9IHtcbiAgICBpbnB1dDogdDBcbiAgfSwgJFsyXSA9IHQwLCAkWzNdID0gdDEpIDogdDEgPSAkWzNdO1xuICBjb25zdCBlZGl0b3JBY3RvciA9IHVzZUFjdG9yUmVmKGVkaXRvck1hY2hpbmUsIHQxKTtcbiAgbGV0IHQyLCB0MztcbiAgcmV0dXJuICRbNF0gIT09IGVkaXRvckFjdG9yID8gKHQzID0gY3JlYXRlRWRpdG9yRnJvbUFjdG9yKGVkaXRvckFjdG9yKSwgJFs0XSA9IGVkaXRvckFjdG9yLCAkWzVdID0gdDMpIDogdDMgPSAkWzVdLCB0MiA9IHQzLCB0Mjtcbn1cbmZ1bmN0aW9uIGVkaXRvckNvbmZpZ1RvTWFjaGluZUlucHV0KGNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIGJlaGF2aW9yczogY29uZmlnLmJlaGF2aW9ycyxcbiAgICBrZXlHZW5lcmF0b3I6IGNvbmZpZy5rZXlHZW5lcmF0b3IgPz8gZGVmYXVsdEtleUdlbmVyYXRvcixcbiAgICBtYXhCbG9ja3M6IGNvbmZpZy5tYXhCbG9ja3MsXG4gICAgcmVhZE9ubHk6IGNvbmZpZy5yZWFkT25seSxcbiAgICBzY2hlbWE6IGNvbmZpZy5zY2hlbWFEZWZpbml0aW9uID8gY29tcGlsZVNjaGVtYURlZmluaXRpb24oY29uZmlnLnNjaGVtYURlZmluaXRpb24pIDogY3JlYXRlRWRpdG9yU2NoZW1hKGNvbmZpZy5zY2hlbWEuaGFzT3duUHJvcGVydHkoXCJqc29uVHlwZVwiKSA/IGNvbmZpZy5zY2hlbWEgOiBjb21waWxlVHlwZShjb25maWcuc2NoZW1hKSksXG4gICAgdmFsdWU6IGNvbmZpZy5pbml0aWFsVmFsdWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRvckZyb21BY3RvcihlZGl0b3JBY3Rvcikge1xuICBjb25zdCBzbGF0ZUVkaXRvciA9IGNyZWF0ZVNsYXRlRWRpdG9yKHtcbiAgICBlZGl0b3JBY3RvclxuICB9KSwgZWRpdGFibGUgPSBjcmVhdGVFZGl0YWJsZUFQSShzbGF0ZUVkaXRvci5pbnN0YW5jZSwgZWRpdG9yQWN0b3IpO1xuICByZXR1cm4ge1xuICAgIGdldFNuYXBzaG90OiAoKSA9PiBnZXRFZGl0b3JTbmFwc2hvdCh7XG4gICAgICBlZGl0b3JBY3RvclNuYXBzaG90OiBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLFxuICAgICAgc2xhdGVFZGl0b3JJbnN0YW5jZTogc2xhdGVFZGl0b3IuaW5zdGFuY2VcbiAgICB9KSxcbiAgICBzZW5kOiAoZXZlbnQpID0+IHtcbiAgICAgIGVkaXRvckFjdG9yLnNlbmQoZXZlbnQpO1xuICAgIH0sXG4gICAgb246IChldmVudCwgbGlzdGVuZXIpID0+IGVkaXRvckFjdG9yLm9uKFxuICAgICAgZXZlbnQsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBsaXN0ZW5lclxuICAgICksXG4gICAgX2ludGVybmFsOiB7XG4gICAgICBlZGl0YWJsZSxcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3JcbiAgICB9XG4gIH07XG59XG5jb25zdCBFZGl0b3JBY3RvckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KSwgUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCksIHVzZVBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbiA9ICgpID0+IHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gdXNlQ29udGV4dChQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Db250ZXh0KTtcbiAgaWYgKHNlbGVjdGlvbiA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxQb3J0YWJsZVRleHRFZGl0b3I+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICByZXR1cm4gc2VsZWN0aW9uO1xufSwgZGVidWckNSA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yOlNlbGVjdGlvblByb3ZpZGVyXCIpLCBkZWJ1Z1ZlcmJvc2UgPSBkZWJ1ZyQ1LmVuYWJsZWQgJiYgITE7XG5mdW5jdGlvbiBQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Qcm92aWRlcihwcm9wcykge1xuICBjb25zdCAkID0gYyg2KSwgW3NlbGVjdGlvbiwgc2V0U2VsZWN0aW9uXSA9IHVzZVN0YXRlKG51bGwpO1xuICBsZXQgdDAsIHQxO1xuICAkWzBdICE9PSBwcm9wcy5lZGl0b3JBY3RvciA/ICh0MCA9ICgpID0+IHtcbiAgICBkZWJ1ZyQ1KFwiU3Vic2NyaWJpbmcgdG8gc2VsZWN0aW9uIGNoYW5nZXNcIik7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gcHJvcHMuZWRpdG9yQWN0b3Iub24oXCJzZWxlY3Rpb25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICBkZWJ1Z1ZlcmJvc2UgJiYgZGVidWckNShcIlNldHRpbmcgc2VsZWN0aW9uXCIpLCBzZXRTZWxlY3Rpb24oZXZlbnQuc2VsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkZWJ1ZyQ1KFwiVW5zdWJzY3JpYmluZyB0byBzZWxlY3Rpb24gY2hhbmdlc1wiKSwgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgdDEgPSBbcHJvcHMuZWRpdG9yQWN0b3JdLCAkWzBdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbMV0gPSB0MCwgJFsyXSA9IHQxKSA6ICh0MCA9ICRbMV0sIHQxID0gJFsyXSksIHVzZUVmZmVjdCh0MCwgdDEpO1xuICBsZXQgdDI7XG4gIHJldHVybiAkWzNdICE9PSBwcm9wcy5jaGlsZHJlbiB8fCAkWzRdICE9PSBzZWxlY3Rpb24gPyAodDIgPSAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNlbGVjdGlvbiwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pLCAkWzNdID0gcHJvcHMuY2hpbGRyZW4sICRbNF0gPSBzZWxlY3Rpb24sICRbNV0gPSB0MikgOiB0MiA9ICRbNV0sIHQyO1xufVxuY29uc3QgZGVidWckNCA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnQ6UG9ydGFibGVUZXh0RWRpdG9yXCIpO1xuY2xhc3MgUG9ydGFibGVUZXh0RWRpdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgc3RhdGljIGRpc3BsYXlOYW1lID0gXCJQb3J0YWJsZVRleHRFZGl0b3JcIjtcbiAgLyoqXG4gICAqIEFuIG9ic2VydmFibGUgb2YgYWxsIHRoZSBlZGl0b3IgY2hhbmdlcy5cbiAgICovXG4gIGNoYW5nZSQgPSBuZXcgU3ViamVjdCgpO1xuICAvKipcbiAgICogQSBsb29rdXAgdGFibGUgZm9yIGFsbCB0aGUgcmVsZXZhbnQgc2NoZW1hIHR5cGVzIGZvciB0aGlzIHBvcnRhYmxlIHRleHQgdHlwZS5cbiAgICovXG4gIC8qKlxuICAgKiBUaGUgZWRpdG9yIGluc3RhbmNlXG4gICAqL1xuICAvKlxuICAgKiBUaGUgZWRpdG9yIEFQSSAoY3VycmVudGx5IGltcGxlbWVudGVkIHdpdGggU2xhdGUpLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyksIHByb3BzLmVkaXRvciA/IHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yIDogdGhpcy5lZGl0b3IgPSBjcmVhdGVFZGl0b3Ioe1xuICAgICAga2V5R2VuZXJhdG9yOiBwcm9wcy5rZXlHZW5lcmF0b3IgPz8gZGVmYXVsdEtleUdlbmVyYXRvcixcbiAgICAgIHNjaGVtYTogcHJvcHMuc2NoZW1hVHlwZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUsXG4gICAgICBtYXhCbG9ja3M6IHByb3BzLm1heEJsb2NrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogTnVtYmVyLnBhcnNlSW50KHByb3BzLm1heEJsb2Nrcy50b1N0cmluZygpLCAxMCksXG4gICAgICByZWFkT25seTogcHJvcHMucmVhZE9ubHlcbiAgICB9KSwgdGhpcy5zY2hlbWFUeXBlcyA9IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQuc2NoZW1hLCB0aGlzLmVkaXRhYmxlID0gdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRhYmxlO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAhdGhpcy5wcm9wcy5lZGl0b3IgJiYgIXByZXZQcm9wcy5lZGl0b3IgJiYgdGhpcy5wcm9wcy5zY2hlbWFUeXBlICE9PSBwcmV2UHJvcHMuc2NoZW1hVHlwZSAmJiAodGhpcy5zY2hlbWFUeXBlcyA9IGNyZWF0ZUVkaXRvclNjaGVtYSh0aGlzLnByb3BzLnNjaGVtYVR5cGUuaGFzT3duUHJvcGVydHkoXCJqc29uVHlwZVwiKSA/IHRoaXMucHJvcHMuc2NoZW1hVHlwZSA6IGNvbXBpbGVUeXBlKHRoaXMucHJvcHMuc2NoZW1hVHlwZSkpLCB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcInVwZGF0ZSBzY2hlbWFcIixcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFUeXBlc1xuICAgIH0pKSwgIXRoaXMucHJvcHMuZWRpdG9yICYmICFwcmV2UHJvcHMuZWRpdG9yICYmICh0aGlzLnByb3BzLnJlYWRPbmx5ICE9PSBwcmV2UHJvcHMucmVhZE9ubHkgJiYgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgcmVhZE9ubHlcIixcbiAgICAgIHJlYWRPbmx5OiB0aGlzLnByb3BzLnJlYWRPbmx5ID8/ICExXG4gICAgfSksIHRoaXMucHJvcHMubWF4QmxvY2tzICE9PSBwcmV2UHJvcHMubWF4QmxvY2tzICYmIHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwidXBkYXRlIG1heEJsb2Nrc1wiLFxuICAgICAgbWF4QmxvY2tzOiB0aGlzLnByb3BzLm1heEJsb2NrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogTnVtYmVyLnBhcnNlSW50KHRoaXMucHJvcHMubWF4QmxvY2tzLnRvU3RyaW5nKCksIDEwKVxuICAgIH0pLCB0aGlzLnByb3BzLnZhbHVlICE9PSBwcmV2UHJvcHMudmFsdWUgJiYgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJ1cGRhdGUgdmFsdWVcIixcbiAgICAgIHZhbHVlOiB0aGlzLnByb3BzLnZhbHVlXG4gICAgfSksIHRoaXMucHJvcHMuZWRpdG9yUmVmICE9PSBwcmV2UHJvcHMuZWRpdG9yUmVmICYmIHRoaXMucHJvcHMuZWRpdG9yUmVmICYmICh0aGlzLnByb3BzLmVkaXRvclJlZi5jdXJyZW50ID0gdGhpcykpO1xuICB9XG4gIHNldEVkaXRhYmxlID0gKGVkaXRhYmxlKSA9PiB7XG4gICAgdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRhYmxlID0ge1xuICAgICAgLi4udGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRhYmxlLFxuICAgICAgLi4uZWRpdGFibGVcbiAgICB9O1xuICB9O1xuICByZW5kZXIoKSB7XG4gICAgY29uc3QgbGVnYWN5UGF0Y2hlcyA9IHRoaXMucHJvcHMuZWRpdG9yID8gdm9pZCAwIDogdGhpcy5wcm9wcy5pbmNvbWluZ1BhdGNoZXMkID8/IHRoaXMucHJvcHMucGF0Y2hlcyQ7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICBsZWdhY3lQYXRjaGVzID8gLyogQF9fUFVSRV9fICovIGpzeChSb3V0ZVBhdGNoZXNPYnNlcnZhYmxlVG9FZGl0b3JBY3RvciwgeyBlZGl0b3JBY3RvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCBwYXRjaGVzJDogbGVnYWN5UGF0Y2hlcyB9KSA6IG51bGwsXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFJvdXRlRXZlbnRzVG9DaGFuZ2VzLCB7IGVkaXRvckFjdG9yOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIG9uQ2hhbmdlOiAoY2hhbmdlKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMuZWRpdG9yIHx8IHRoaXMucHJvcHMub25DaGFuZ2UoY2hhbmdlKSwgdGhpcy5jaGFuZ2UkLm5leHQoY2hhbmdlKTtcbiAgICAgIH0gfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFN5bmNocm9uaXplciwgeyBlZGl0b3JBY3RvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLmVkaXRvckFjdG9yLCBzbGF0ZUVkaXRvcjogdGhpcy5lZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluc3RhbmNlIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChFZGl0b3JBY3RvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3RvciwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goU2xhdGUsIHsgZWRpdG9yOiB0aGlzLmVkaXRvci5faW50ZXJuYWwuc2xhdGVFZGl0b3IuaW5zdGFuY2UsIGluaXRpYWxWYWx1ZTogdGhpcy5lZGl0b3IuX2ludGVybmFsLnNsYXRlRWRpdG9yLmluaXRpYWxWYWx1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcywgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uUHJvdmlkZXIsIHsgZWRpdG9yQWN0b3I6IHRoaXMuZWRpdG9yLl9pbnRlcm5hbC5lZGl0b3JBY3RvciwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSkgfSkgfSkgfSlcbiAgICBdIH0pO1xuICB9XG4gIC8vIFN0YXRpYyBBUEkgbWV0aG9kc1xuICBzdGF0aWMgYWN0aXZlQW5ub3RhdGlvbnMgPSAoZWRpdG9yKSA9PiBlZGl0b3IgJiYgZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmFjdGl2ZUFubm90YXRpb25zKCkgOiBbXTtcbiAgc3RhdGljIGlzQW5ub3RhdGlvbkFjdGl2ZSA9IChlZGl0b3IsIGFubm90YXRpb25UeXBlKSA9PiBlZGl0b3IgJiYgZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmlzQW5ub3RhdGlvbkFjdGl2ZShhbm5vdGF0aW9uVHlwZSkgOiAhMTtcbiAgc3RhdGljIGFkZEFubm90YXRpb24gPSAoZWRpdG9yLCB0eXBlLCB2YWx1ZSkgPT4gZWRpdG9yLmVkaXRhYmxlPy5hZGRBbm5vdGF0aW9uKHR5cGUsIHZhbHVlKTtcbiAgc3RhdGljIGJsdXIgPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWckNChcIkhvc3QgYmx1cnJlZFwiKSwgZWRpdG9yLmVkaXRhYmxlPy5ibHVyKCk7XG4gIH07XG4gIHN0YXRpYyBkZWxldGUgPSAoZWRpdG9yLCBzZWxlY3Rpb24sIG9wdGlvbnMpID0+IGVkaXRvci5lZGl0YWJsZT8uZGVsZXRlKHNlbGVjdGlvbiwgb3B0aW9ucyk7XG4gIHN0YXRpYyBmaW5kRE9NTm9kZSA9IChlZGl0b3IsIGVsZW1lbnQpID0+IGVkaXRvci5lZGl0YWJsZT8uZmluZERPTU5vZGUoZWxlbWVudCk7XG4gIHN0YXRpYyBmaW5kQnlQYXRoID0gKGVkaXRvciwgcGF0aCkgPT4gZWRpdG9yLmVkaXRhYmxlPy5maW5kQnlQYXRoKHBhdGgpIHx8IFtdO1xuICBzdGF0aWMgZm9jdXMgPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWckNChcIkhvc3QgcmVxdWVzdGluZyBmb2N1c1wiKSwgZWRpdG9yLmVkaXRhYmxlPy5mb2N1cygpO1xuICB9O1xuICBzdGF0aWMgZm9jdXNCbG9jayA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZm9jdXNCbG9jaygpO1xuICBzdGF0aWMgZm9jdXNDaGlsZCA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uZm9jdXNDaGlsZCgpO1xuICBzdGF0aWMgZ2V0U2VsZWN0aW9uID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlID8gZWRpdG9yLmVkaXRhYmxlLmdldFNlbGVjdGlvbigpIDogbnVsbDtcbiAgc3RhdGljIGdldFZhbHVlID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5nZXRWYWx1ZSgpO1xuICBzdGF0aWMgaGFzQmxvY2tTdHlsZSA9IChlZGl0b3IsIGJsb2NrU3R5bGUpID0+IGVkaXRvci5lZGl0YWJsZT8uaGFzQmxvY2tTdHlsZShibG9ja1N0eWxlKTtcbiAgc3RhdGljIGhhc0xpc3RTdHlsZSA9IChlZGl0b3IsIGxpc3RTdHlsZSkgPT4gZWRpdG9yLmVkaXRhYmxlPy5oYXNMaXN0U3R5bGUobGlzdFN0eWxlKTtcbiAgc3RhdGljIGlzQ29sbGFwc2VkU2VsZWN0aW9uID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc0NvbGxhcHNlZFNlbGVjdGlvbigpO1xuICBzdGF0aWMgaXNFeHBhbmRlZFNlbGVjdGlvbiA9IChlZGl0b3IpID0+IGVkaXRvci5lZGl0YWJsZT8uaXNFeHBhbmRlZFNlbGVjdGlvbigpO1xuICBzdGF0aWMgaXNNYXJrQWN0aXZlID0gKGVkaXRvciwgbWFyaykgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc01hcmtBY3RpdmUobWFyayk7XG4gIHN0YXRpYyBpbnNlcnRDaGlsZCA9IChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiAoZGVidWckNChcIkhvc3QgaW5zZXJ0aW5nIGNoaWxkXCIpLCBlZGl0b3IuZWRpdGFibGU/Lmluc2VydENoaWxkKHR5cGUsIHZhbHVlKSk7XG4gIHN0YXRpYyBpbnNlcnRCbG9jayA9IChlZGl0b3IsIHR5cGUsIHZhbHVlKSA9PiBlZGl0b3IuZWRpdGFibGU/Lmluc2VydEJsb2NrKHR5cGUsIHZhbHVlKTtcbiAgc3RhdGljIGluc2VydEJyZWFrID0gKGVkaXRvcikgPT4gZWRpdG9yLmVkaXRhYmxlPy5pbnNlcnRCcmVhaygpO1xuICBzdGF0aWMgaXNWb2lkID0gKGVkaXRvciwgZWxlbWVudCkgPT4gZWRpdG9yLmVkaXRhYmxlPy5pc1ZvaWQoZWxlbWVudCk7XG4gIHN0YXRpYyBpc09iamVjdFBhdGggPSAoX2VkaXRvciwgcGF0aCkgPT4ge1xuICAgIGlmICghcGF0aCB8fCAhQXJyYXkuaXNBcnJheShwYXRoKSkgcmV0dXJuICExO1xuICAgIGNvbnN0IGlzQ2hpbGRPYmplY3RFZGl0UGF0aCA9IHBhdGgubGVuZ3RoID4gMyAmJiBwYXRoWzFdID09PSBcImNoaWxkcmVuXCI7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMSAmJiBwYXRoWzFdICE9PSBcImNoaWxkcmVuXCIgfHwgaXNDaGlsZE9iamVjdEVkaXRQYXRoO1xuICB9O1xuICBzdGF0aWMgbWFya3MgPSAoZWRpdG9yKSA9PiBlZGl0b3IuZWRpdGFibGU/Lm1hcmtzKCk7XG4gIHN0YXRpYyBzZWxlY3QgPSAoZWRpdG9yLCBzZWxlY3Rpb24pID0+IHtcbiAgICBkZWJ1ZyQ0KFwiSG9zdCBzZXR0aW5nIHNlbGVjdGlvblwiLCBzZWxlY3Rpb24pLCBlZGl0b3IuZWRpdGFibGU/LnNlbGVjdChzZWxlY3Rpb24pO1xuICB9O1xuICBzdGF0aWMgcmVtb3ZlQW5ub3RhdGlvbiA9IChlZGl0b3IsIHR5cGUpID0+IGVkaXRvci5lZGl0YWJsZT8ucmVtb3ZlQW5ub3RhdGlvbih0eXBlKTtcbiAgc3RhdGljIHRvZ2dsZUJsb2NrU3R5bGUgPSAoZWRpdG9yLCBibG9ja1N0eWxlKSA9PiAoZGVidWckNChcIkhvc3QgaXMgdG9nZ2xpbmcgYmxvY2sgc3R5bGVcIiksIGVkaXRvci5lZGl0YWJsZT8udG9nZ2xlQmxvY2tTdHlsZShibG9ja1N0eWxlKSk7XG4gIHN0YXRpYyB0b2dnbGVMaXN0ID0gKGVkaXRvciwgbGlzdFN0eWxlKSA9PiBlZGl0b3IuZWRpdGFibGU/LnRvZ2dsZUxpc3QobGlzdFN0eWxlKTtcbiAgc3RhdGljIHRvZ2dsZU1hcmsgPSAoZWRpdG9yLCBtYXJrKSA9PiB7XG4gICAgZGVidWckNChcIkhvc3QgdG9nZ2xpbmcgbWFya1wiLCBtYXJrKSwgZWRpdG9yLmVkaXRhYmxlPy50b2dnbGVNYXJrKG1hcmspO1xuICB9O1xuICBzdGF0aWMgZ2V0RnJhZ21lbnQgPSAoZWRpdG9yKSA9PiAoZGVidWckNChcIkhvc3QgZ2V0dGluZyBmcmFnbWVudFwiKSwgZWRpdG9yLmVkaXRhYmxlPy5nZXRGcmFnbWVudCgpKTtcbiAgc3RhdGljIHVuZG8gPSAoZWRpdG9yKSA9PiB7XG4gICAgZGVidWckNChcIkhvc3QgdW5kb2luZ1wiKSwgZWRpdG9yLmVkaXRhYmxlPy51bmRvKCk7XG4gIH07XG4gIHN0YXRpYyByZWRvID0gKGVkaXRvcikgPT4ge1xuICAgIGRlYnVnJDQoXCJIb3N0IHJlZG9pbmdcIiksIGVkaXRvci5lZGl0YWJsZT8ucmVkbygpO1xuICB9O1xuICBzdGF0aWMgaXNTZWxlY3Rpb25zT3ZlcmxhcHBpbmcgPSAoZWRpdG9yLCBzZWxlY3Rpb25BLCBzZWxlY3Rpb25CKSA9PiBlZGl0b3IuZWRpdGFibGU/LmlzU2VsZWN0aW9uc092ZXJsYXBwaW5nKHNlbGVjdGlvbkEsIHNlbGVjdGlvbkIpO1xufVxuZnVuY3Rpb24gUm91dGVQYXRjaGVzT2JzZXJ2YWJsZVRvRWRpdG9yQWN0b3IocHJvcHMpIHtcbiAgY29uc3QgJCA9IGMoNCk7XG4gIGxldCB0MCwgdDE7XG4gIHJldHVybiAkWzBdICE9PSBwcm9wcy5lZGl0b3JBY3RvciB8fCAkWzFdICE9PSBwcm9wcy5wYXRjaGVzJCA/ICh0MCA9ICgpID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBwcm9wcy5wYXRjaGVzJC5zdWJzY3JpYmUoKHBheWxvYWQpID0+IHtcbiAgICAgIHByb3BzLmVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcInBhdGNoZXNcIixcbiAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQxID0gW3Byb3BzLmVkaXRvckFjdG9yLCBwcm9wcy5wYXRjaGVzJF0sICRbMF0gPSBwcm9wcy5lZGl0b3JBY3RvciwgJFsxXSA9IHByb3BzLnBhdGNoZXMkLCAkWzJdID0gdDAsICRbM10gPSB0MSkgOiAodDAgPSAkWzJdLCB0MSA9ICRbM10pLCB1c2VFZmZlY3QodDAsIHQxKSwgbnVsbDtcbn1cbmZ1bmN0aW9uIFJvdXRlRXZlbnRzVG9DaGFuZ2VzKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDYpO1xuICBsZXQgdDA7XG4gICRbMF0gIT09IHByb3BzID8gKHQwID0gKGNoYW5nZSkgPT4gcHJvcHMub25DaGFuZ2UoY2hhbmdlKSwgJFswXSA9IHByb3BzLCAkWzFdID0gdDApIDogdDAgPSAkWzFdO1xuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCh0MCk7XG4gIGxldCB0MSwgdDI7XG4gIHJldHVybiAkWzJdICE9PSBoYW5kbGVDaGFuZ2UgfHwgJFszXSAhPT0gcHJvcHMuZWRpdG9yQWN0b3IgPyAodDEgPSAoKSA9PiB7XG4gICAgZGVidWckNChcIlN1YnNjcmliaW5nIHRvIGVkaXRvciBjaGFuZ2VzXCIpO1xuICAgIGNvbnN0IHN1YiA9IHByb3BzLmVkaXRvckFjdG9yLm9uKFwiKlwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGJiNTogc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJibHVycmVkXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJibHVyXCIsXG4gICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInBhdGNoXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2UoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrIGJiNTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibG9hZGluZ1wiOiB7XG4gICAgICAgICAgaGFuZGxlQ2hhbmdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwibG9hZGluZ1wiLFxuICAgICAgICAgICAgaXNMb2FkaW5nOiAhMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrIGJiNTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZG9uZSBsb2FkaW5nXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJsb2FkaW5nXCIsXG4gICAgICAgICAgICBpc0xvYWRpbmc6ICExXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmb2N1c2VkXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJmb2N1c1wiLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LmV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ2YWx1ZSBjaGFuZ2VkXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJpbnZhbGlkIHZhbHVlXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkVmFsdWVcIixcbiAgICAgICAgICAgIHJlc29sdXRpb246IGV2ZW50LnJlc29sdXRpb24sXG4gICAgICAgICAgICB2YWx1ZTogZXZlbnQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICBoYW5kbGVDaGFuZ2Uoe1xuICAgICAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgICAgICBsZXZlbDogXCJ3YXJuaW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhayBiYjU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFubm90YXRpb24uYWRkXCI6XG4gICAgICAgIGNhc2UgXCJhbm5vdGF0aW9uLnJlbW92ZVwiOlxuICAgICAgICBjYXNlIFwiYW5ub3RhdGlvbi50b2dnbGVcIjpcbiAgICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgICAgY2FzZSBcImRlY29yYXRvci5hZGRcIjpcbiAgICAgICAgY2FzZSBcImRlY29yYXRvci5yZW1vdmVcIjpcbiAgICAgICAgY2FzZSBcImRlY29yYXRvci50b2dnbGVcIjpcbiAgICAgICAgY2FzZSBcImZvY3VzXCI6XG4gICAgICAgIGNhc2UgXCJpbnNlcnQuYmxvY2sgb2JqZWN0XCI6XG4gICAgICAgIGNhc2UgXCJpbnNlcnQuaW5saW5lIG9iamVjdFwiOlxuICAgICAgICBjYXNlIFwibGlzdCBpdGVtLnRvZ2dsZVwiOlxuICAgICAgICBjYXNlIFwic3R5bGUudG9nZ2xlXCI6XG4gICAgICAgIGNhc2UgXCJwYXRjaGVzXCI6XG4gICAgICAgIGNhc2UgXCJlZGl0YWJsZVwiOlxuICAgICAgICBjYXNlIFwicmVhZCBvbmx5XCI6XG4gICAgICAgICAgYnJlYWsgYmI1O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGhhbmRsZUNoYW5nZShldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlYnVnJDQoXCJVbnN1YnNjcmliaW5nIHRvIGNoYW5nZXNcIiksIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIHQyID0gW3Byb3BzLmVkaXRvckFjdG9yLCBoYW5kbGVDaGFuZ2VdLCAkWzJdID0gaGFuZGxlQ2hhbmdlLCAkWzNdID0gcHJvcHMuZWRpdG9yQWN0b3IsICRbNF0gPSB0MSwgJFs1XSA9IHQyKSA6ICh0MSA9ICRbNF0sIHQyID0gJFs1XSksIHVzZUVmZmVjdCh0MSwgdDIpLCBudWxsO1xufVxuY29uc3QgZGVidWckMyA9IGRlYnVnV2l0aE5hbWUoXCJjb21wb25lbnRzOkxlYWZcIiksIEVNUFRZX01BUktTID0gW10sIExlYWYgPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGVkaXRvckFjdG9yLFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW4sXG4gICAgbGVhZixcbiAgICBzY2hlbWFUeXBlcyxcbiAgICByZW5kZXJDaGlsZCxcbiAgICByZW5kZXJEZWNvcmF0b3IsXG4gICAgcmVuZGVyQW5ub3RhdGlvblxuICB9ID0gcHJvcHMsIHNwYW5SZWYgPSB1c2VSZWYobnVsbCksIHBvcnRhYmxlVGV4dEVkaXRvciA9IHVzZVBvcnRhYmxlVGV4dEVkaXRvcigpLCBibG9ja1NlbGVjdGVkID0gdXNlU2VsZWN0ZWQoKSwgW2ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoITEpLCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9IHVzZVN0YXRlKCExKSwgYmxvY2sgPSBjaGlsZHJlbi5wcm9wcy5wYXJlbnQsIHBhdGggPSB1c2VNZW1vKCgpID0+IGJsb2NrID8gW3tcbiAgICBfa2V5OiBibG9jaz8uX2tleVxuICB9LCBcImNoaWxkcmVuXCIsIHtcbiAgICBfa2V5OiBsZWFmLl9rZXlcbiAgfV0gOiBbXSwgW2Jsb2NrLCBsZWFmLl9rZXldKSwgZGVjb3JhdG9yVmFsdWVzID0gdXNlTWVtbygoKSA9PiBzY2hlbWFUeXBlcy5kZWNvcmF0b3JzLm1hcCgoZGVjKSA9PiBkZWMudmFsdWUpLCBbc2NoZW1hVHlwZXMuZGVjb3JhdG9yc10pLCBtYXJrcyA9IHVzZU1lbW8oKCkgPT4gdW5pcSgobGVhZi5tYXJrcyB8fCBFTVBUWV9NQVJLUykuZmlsdGVyKChtYXJrKSA9PiBkZWNvcmF0b3JWYWx1ZXMuaW5jbHVkZXMobWFyaykpKSwgW2RlY29yYXRvclZhbHVlcywgbGVhZi5tYXJrc10pLCBhbm5vdGF0aW9uTWFya3MgPSBBcnJheS5pc0FycmF5KGxlYWYubWFya3MpID8gbGVhZi5tYXJrcyA6IEVNUFRZX01BUktTLCBhbm5vdGF0aW9ucyA9IHVzZU1lbW8oKCkgPT4gYW5ub3RhdGlvbk1hcmtzLm1hcCgobWFya18wKSA9PiAhZGVjb3JhdG9yVmFsdWVzLmluY2x1ZGVzKG1hcmtfMCkgJiYgYmxvY2s/Lm1hcmtEZWZzPy5maW5kKChkZWYpID0+IGRlZi5fa2V5ID09PSBtYXJrXzApKS5maWx0ZXIoQm9vbGVhbiksIFthbm5vdGF0aW9uTWFya3MsIGJsb2NrLCBkZWNvcmF0b3JWYWx1ZXNdKSwgc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1cyA9IGFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgYmxvY2tTZWxlY3RlZDtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMpIHtcbiAgICAgIHNldEZvY3VzZWQoITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWwgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgc2VsICYmIGlzRXF1YWwoc2VsLmZvY3VzLnBhdGgsIHBhdGgpICYmIFBvcnRhYmxlVGV4dEVkaXRvci5pc0NvbGxhcHNlZFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpICYmIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICBzZXRGb2N1c2VkKCEwKTtcbiAgICB9KTtcbiAgfSwgW3Nob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMsIHBhdGgsIHBvcnRhYmxlVGV4dEVkaXRvcl0pO1xuICBjb25zdCBzZXRTZWxlY3RlZEZyb21SYW5nZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXMpXG4gICAgICByZXR1cm47XG4gICAgZGVidWckMyhcIlNldHRpbmcgc2VsZWN0aW9uIGFuZCBmb2N1cyBmcm9tIHJhbmdlXCIpO1xuICAgIGNvbnN0IHdpblNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXdpblNlbGVjdGlvbikge1xuICAgICAgc2V0U2VsZWN0ZWQoITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAod2luU2VsZWN0aW9uICYmIHdpblNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgY29uc3QgcmFuZ2UgPSB3aW5TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgIHNwYW5SZWYuY3VycmVudCAmJiByYW5nZS5pbnRlcnNlY3RzTm9kZShzcGFuUmVmLmN1cnJlbnQpID8gc2V0U2VsZWN0ZWQoITApIDogc2V0U2VsZWN0ZWQoITEpO1xuICAgIH0gZWxzZVxuICAgICAgc2V0U2VsZWN0ZWQoITEpO1xuICB9LCBbc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1c10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghc2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1cylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvbkJsdXIgPSBlZGl0b3JBY3Rvci5vbihcImJsdXJcIiwgKCkgPT4ge1xuICAgICAgc2V0Rm9jdXNlZCghMSksIHNldFNlbGVjdGVkKCExKTtcbiAgICB9KSwgb25Gb2N1cyA9IGVkaXRvckFjdG9yLm9uKFwiZm9jdXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsXzAgPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICBzZWxfMCAmJiBpc0VxdWFsKHNlbF8wLmZvY3VzLnBhdGgsIHBhdGgpICYmIFBvcnRhYmxlVGV4dEVkaXRvci5pc0NvbGxhcHNlZFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpICYmIHNldEZvY3VzZWQoITApLCBzZXRTZWxlY3RlZEZyb21SYW5nZSgpO1xuICAgIH0pLCBvblNlbGVjdGlvbiA9IGVkaXRvckFjdG9yLm9uKFwic2VsZWN0aW9uXCIsIChldmVudCkgPT4ge1xuICAgICAgZXZlbnQuc2VsZWN0aW9uICYmIGlzRXF1YWwoZXZlbnQuc2VsZWN0aW9uLmZvY3VzLnBhdGgsIHBhdGgpICYmIFBvcnRhYmxlVGV4dEVkaXRvci5pc0NvbGxhcHNlZFNlbGVjdGlvbihwb3J0YWJsZVRleHRFZGl0b3IpID8gc2V0Rm9jdXNlZCghMCkgOiBzZXRGb2N1c2VkKCExKSwgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgb25CbHVyLnVuc3Vic2NyaWJlKCksIG9uRm9jdXMudW5zdWJzY3JpYmUoKSwgb25TZWxlY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbZWRpdG9yQWN0b3IsIHBhdGgsIHBvcnRhYmxlVGV4dEVkaXRvciwgc2V0U2VsZWN0ZWRGcm9tUmFuZ2UsIHNob3VsZFRyYWNrU2VsZWN0aW9uQW5kRm9jdXNdKSwgdXNlRWZmZWN0KCgpID0+IHNldFNlbGVjdGVkRnJvbVJhbmdlKCksIFtzZXRTZWxlY3RlZEZyb21SYW5nZV0pO1xuICBjb25zdCBjb250ZW50ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHJldHVybmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICBpZiAoVGV4dC5pc1RleHQobGVhZikgJiYgbGVhZi5fdHlwZSA9PT0gc2NoZW1hVHlwZXMuc3Bhbi5uYW1lICYmIChtYXJrcy5mb3JFYWNoKChtYXJrXzEpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBzY2hlbWFUeXBlcy5kZWNvcmF0b3JzLmZpbmQoKGRlY18wKSA9PiBkZWNfMC52YWx1ZSA9PT0gbWFya18xKTtcbiAgICAgIGlmIChzY2hlbWFUeXBlICYmIHJlbmRlckRlY29yYXRvcikge1xuICAgICAgICBjb25zdCBfcHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgIGNoaWxkcmVuOiByZXR1cm5lZENoaWxkcmVuLFxuICAgICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsXG4gICAgICAgICAgZm9jdXNlZCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgIHNjaGVtYVR5cGUsXG4gICAgICAgICAgdmFsdWU6IG1hcmtfMVxuICAgICAgICB9LCBcInR5cGVcIiwge1xuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm5lZENoaWxkcmVuID0gcmVuZGVyRGVjb3JhdG9yKF9wcm9wcyk7XG4gICAgICB9XG4gICAgfSksIGJsb2NrICYmIGFubm90YXRpb25zLmxlbmd0aCA+IDAgJiYgYW5ub3RhdGlvbnMuZm9yRWFjaCgoYW5ub3RhdGlvbikgPT4ge1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZV8wID0gc2NoZW1hVHlwZXMuYW5ub3RhdGlvbnMuZmluZCgodCkgPT4gdC5uYW1lID09PSBhbm5vdGF0aW9uLl90eXBlKTtcbiAgICAgIGlmIChzY2hlbWFUeXBlXzApXG4gICAgICAgIGlmIChyZW5kZXJBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgY29uc3QgX3Byb3BzXzAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICBjaGlsZHJlbjogcmV0dXJuZWRDaGlsZHJlbixcbiAgICAgICAgICAgIGVkaXRvckVsZW1lbnRSZWY6IHNwYW5SZWYsXG4gICAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgc2NoZW1hVHlwZTogc2NoZW1hVHlwZV8wLFxuICAgICAgICAgICAgdmFsdWU6IGFubm90YXRpb25cbiAgICAgICAgICB9LCBcInR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJQcm9wZXJ0eSAndHlwZScgaXMgZGVwcmVjYXRlZCwgdXNlICdzY2hlbWFUeXBlJyBpbnN0ZWFkLlwiKSwgc2NoZW1hVHlwZV8wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybmVkQ2hpbGRyZW4gPSAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IHJlZjogc3BhblJlZiwgY2hpbGRyZW46IHJlbmRlckFubm90YXRpb24oX3Byb3BzXzApIH0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICByZXR1cm5lZENoaWxkcmVuID0gLyogQF9fUFVSRV9fICovIGpzeChEZWZhdWx0QW5ub3RhdGlvbiwgeyBhbm5vdGF0aW9uLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyByZWY6IHNwYW5SZWYsIGNoaWxkcmVuOiByZXR1cm5lZENoaWxkcmVuIH0pIH0pO1xuICAgIH0pLCBibG9jayAmJiByZW5kZXJDaGlsZCkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gYmxvY2suY2hpbGRyZW4uZmluZCgoX2NoaWxkKSA9PiBfY2hpbGQuX2tleSA9PT0gbGVhZi5fa2V5KTtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBjb25zdCBfcHJvcHNfMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IHJldHVybmVkQ2hpbGRyZW4gfSksXG4gICAgICAgICAgZWRpdG9yRWxlbWVudFJlZjogc3BhblJlZixcbiAgICAgICAgICBmb2N1c2VkLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgc2NoZW1hVHlwZTogc2NoZW1hVHlwZXMuc3BhbixcbiAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICB2YWx1ZTogY2hpbGRcbiAgICAgICAgfSwgXCJ0eXBlXCIsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiUHJvcGVydHkgJ3R5cGUnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnc2NoZW1hVHlwZScgaW5zdGVhZC5cIiksIHNjaGVtYVR5cGVzLnNwYW47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuZWRDaGlsZHJlbiA9IHJlbmRlckNoaWxkKF9wcm9wc18xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybmVkQ2hpbGRyZW47XG4gIH0sIFthbm5vdGF0aW9ucywgYmxvY2ssIGNoaWxkcmVuLCBmb2N1c2VkLCBsZWFmLCBtYXJrcywgcGF0aCwgcmVuZGVyQW5ub3RhdGlvbiwgcmVuZGVyQ2hpbGQsIHJlbmRlckRlY29yYXRvciwgc2NoZW1hVHlwZXMuYW5ub3RhdGlvbnMsIHNjaGVtYVR5cGVzLmRlY29yYXRvcnMsIHNjaGVtYVR5cGVzLnNwYW4sIHNlbGVjdGVkXSk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgLi4uYXR0cmlidXRlcywgcmVmOiBzcGFuUmVmLCBjaGlsZHJlbjogY29udGVudCB9LCBsZWFmLl9rZXkpLCBbbGVhZiwgYXR0cmlidXRlcywgY29udGVudF0pO1xufTtcbkxlYWYuZGlzcGxheU5hbWUgPSBcIkxlYWZcIjtcbmNvbnN0IGRlYnVnJDIgPSBkZWJ1Z1dpdGhOYW1lKFwicGx1Z2luOndpdGhIb3RLZXlzXCIpLCBERUZBVUxUX0hPVEtFWVMgPSB7XG4gIG1hcmtzOiB7XG4gICAgXCJtb2QrYlwiOiBcInN0cm9uZ1wiLFxuICAgIFwibW9kK2lcIjogXCJlbVwiLFxuICAgIFwibW9kK3VcIjogXCJ1bmRlcmxpbmVcIixcbiAgICBcIm1vZCsnXCI6IFwiY29kZVwiXG4gIH0sXG4gIGN1c3RvbToge31cbn07XG5mdW5jdGlvbiBjcmVhdGVXaXRoSG90a2V5cyhlZGl0b3JBY3RvciwgcG9ydGFibGVUZXh0RWRpdG9yLCBob3RrZXlzRnJvbU9wdGlvbnMpIHtcbiAgY29uc3QgcmVzZXJ2ZWRIb3RrZXlzID0gW1wiZW50ZXJcIiwgXCJ0YWJcIiwgXCJzaGlmdFwiLCBcImRlbGV0ZVwiLCBcImVuZFwiXSwgYWN0aXZlSG90a2V5cyA9IGhvdGtleXNGcm9tT3B0aW9ucyB8fCBERUZBVUxUX0hPVEtFWVM7XG4gIHJldHVybiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnB0ZVdpdGhIb3RLZXlzID0gKGV2ZW50KSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhhY3RpdmVIb3RrZXlzKS5mb3JFYWNoKChjYXQpID0+IHtcbiAgICAgICAgaWYgKGNhdCA9PT0gXCJtYXJrc1wiKVxuICAgICAgICAgIGZvciAoY29uc3QgaG90a2V5IGluIGFjdGl2ZUhvdGtleXNbY2F0XSkge1xuICAgICAgICAgICAgaWYgKHJlc2VydmVkSG90a2V5cy5pbmNsdWRlcyhob3RrZXkpKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBob3RrZXkgJHtob3RrZXl9IGlzIHJlc2VydmVkIWApO1xuICAgICAgICAgICAgaWYgKGlzSG90a2V5KGhvdGtleSwgZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlTWFyayA9IGFjdGl2ZUhvdGtleXNbY2F0XTtcbiAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlTWFyaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsgPSBwb3NzaWJsZU1hcmtbaG90a2V5XTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyQyKGBIb3RLZXkgJHtob3RrZXl9IHRvIHRvZ2dsZSAke21hcmt9YCksIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgICAgICAgICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRlY29yYXRvci50b2dnbGVcIixcbiAgICAgICAgICAgICAgICAgICAgZGVjb3JhdG9yOiBtYXJrXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGlmIChjYXQgPT09IFwiY3VzdG9tXCIpXG4gICAgICAgICAgZm9yIChjb25zdCBob3RrZXkgaW4gYWN0aXZlSG90a2V5c1tjYXRdKSB7XG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRIb3RrZXlzLmluY2x1ZGVzKGhvdGtleSkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGhvdGtleSAke2hvdGtleX0gaXMgcmVzZXJ2ZWQhYCk7XG4gICAgICAgICAgICBpZiAoaXNIb3RrZXkoaG90a2V5LCBldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVDb21tYW5kID0gYWN0aXZlSG90a2V5c1tjYXRdO1xuICAgICAgICAgICAgICBpZiAocG9zc2libGVDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IHBvc3NpYmxlQ29tbWFuZFtob3RrZXldO1xuICAgICAgICAgICAgICAgIGNvbW1hbmQoZXZlbnQsIHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBlZGl0b3I7XG4gIH07XG59XG5jb25zdCBkZWJ1ZyQxID0gZGVidWdXaXRoTmFtZShcInBsdWdpbjp3aXRoSW5zZXJ0RGF0YVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdpdGhJbnNlcnREYXRhKGVkaXRvckFjdG9yLCBzY2hlbWFUeXBlcykge1xuICByZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgY29uc3QgYmxvY2tUeXBlTmFtZSA9IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWUsIHNwYW5UeXBlTmFtZSA9IHNjaGVtYVR5cGVzLnNwYW4ubmFtZSwgd2hpdGVzcGFjZU9uUGFzdGVNb2RlID0gc2NoZW1hVHlwZXMuYmxvY2sub3B0aW9ucy51bnN0YWJsZV93aGl0ZXNwYWNlT25QYXN0ZU1vZGUsIHRvUGxhaW5UZXh0ID0gKGJsb2NrcykgPT4gYmxvY2tzLm1hcCgoYmxvY2spID0+IGVkaXRvci5pc1RleHRCbG9jayhibG9jaykgPyBibG9jay5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5fdHlwZSA9PT0gc3BhblR5cGVOYW1lID8gY2hpbGQudGV4dCA6IGBbJHtzY2hlbWFUeXBlcy5pbmxpbmVPYmplY3RzLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gY2hpbGQuX3R5cGUpPy50aXRsZSB8fCBcIk9iamVjdFwifV1gKS5qb2luKFwiXCIpIDogYFske3NjaGVtYVR5cGVzLmJsb2NrT2JqZWN0cy5maW5kKCh0KSA9PiB0Lm5hbWUgPT09IGJsb2NrLl90eXBlKT8udGl0bGUgfHwgXCJPYmplY3RcIn1dYCkuam9pbihgXG5cbmApO1xuICAgIHJldHVybiBlZGl0b3Iuc2V0RnJhZ21lbnREYXRhID0gKGRhdGEsIG9yaWdpbkV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhzZWxlY3Rpb24pLCBzdGFydFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LnBhdGhcbiAgICAgIH0pLCBlbmRWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQucGF0aFxuICAgICAgfSk7XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJiAhc3RhcnRWb2lkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBkb21SYW5nZSA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgICAgbGV0IGNvbnRlbnRzID0gZG9tUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgICAgY29uc3QgW3ZvaWROb2RlXSA9IGVuZFZvaWQsIHIgPSBkb21SYW5nZS5jbG9uZVJhbmdlKCksIGRvbU5vZGUgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCB2b2lkTm9kZSk7XG4gICAgICAgIHIuc2V0RW5kQWZ0ZXIoZG9tTm9kZSksIGNvbnRlbnRzID0gci5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICB9XG4gICAgICBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXVwiKSkuZm9yRWFjaCgoencpID0+IHtcbiAgICAgICAgY29uc3QgaXNOZXdsaW5lID0gencuZ2V0QXR0cmlidXRlKFwiZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXCIpID09PSBcIm5cIjtcbiAgICAgICAgencudGV4dENvbnRlbnQgPSBpc05ld2xpbmUgPyBgXG5gIDogXCJcIjtcbiAgICAgIH0pLCBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKS5mb3JFYWNoKChlbG0pID0+IHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtaW5saW5lXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1sZWFmXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1ub2RlXCIpLCBlbG0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zbGF0ZS1zcGFjZXJcIiksIGVsbS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXNsYXRlLXN0cmluZ1wiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2xhdGUtemVyby13aWR0aFwiKSwgZWxtLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZWxtLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgZWxtLmhhc0F0dHJpYnV0ZShrZXkpICYmIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZGl2ID0gY29udGVudHMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGNvbnRlbnRzKSwgZGl2LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcInRydWVcIiksIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgY29uc3QgYXNIVE1MID0gZGl2LmlubmVySFRNTDtcbiAgICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBlZGl0b3IuZ2V0RnJhZ21lbnQoKSwgcG9ydGFibGVUZXh0ID0gZnJvbVNsYXRlVmFsdWUoZnJhZ21lbnQsIGJsb2NrVHlwZU5hbWUpLCBhc0pTT04gPSBKU09OLnN0cmluZ2lmeShwb3J0YWJsZVRleHQpLCBhc1BsYWluVGV4dCA9IHRvUGxhaW5UZXh0KHBvcnRhYmxlVGV4dCk7XG4gICAgICBkYXRhLmNsZWFyRGF0YSgpLCBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIGFzUGxhaW5UZXh0KSwgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGFzSFRNTCksIGRhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL2pzb25cIiwgYXNKU09OKSwgZGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0XCIsIGFzSlNPTiksIGRlYnVnJDEoXCJ0ZXh0XCIsIGFzUGxhaW5UZXh0KSwgZGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24veC1wb3J0YWJsZS10ZXh0LWV2ZW50LW9yaWdpblwiLCBvcmlnaW5FdmVudCB8fCBcImV4dGVybmFsXCIpLCBkZWJ1ZyQxKFwiU2V0IGZyYWdtZW50IGRhdGFcIiwgYXNKU09OLCBhc0hUTUwpO1xuICAgIH0sIGVkaXRvci5pbnNlcnRQb3J0YWJsZVRleHREYXRhID0gKGRhdGEpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgY29uc3QgcFRleHQgPSBkYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIiksIG9yaWdpbiA9IGRhdGEuZ2V0RGF0YShcImFwcGxpY2F0aW9uL3gtcG9ydGFibGUtdGV4dC1ldmVudC1vcmlnaW5cIik7XG4gICAgICBpZiAoZGVidWckMShgSW5zZXJ0aW5nIHBvcnRhYmxlIHRleHQgZnJvbSAke29yaWdpbn0gZXZlbnRgLCBwVGV4dCksIHBUZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocFRleHQpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWQpICYmIHBhcnNlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgc2xhdGVWYWx1ZSA9IF9yZWdlbmVyYXRlS2V5cyhlZGl0b3IsIHRvU2xhdGVWYWx1ZShwYXJzZWQsIHtcbiAgICAgICAgICAgIHNjaGVtYVR5cGVzXG4gICAgICAgICAgfSksIGVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC5rZXlHZW5lcmF0b3IsIHNwYW5UeXBlTmFtZSwgc2NoZW1hVHlwZXMpLCB2YWxpZGF0aW9uID0gdmFsaWRhdGVWYWx1ZShwYXJzZWQsIHNjaGVtYVR5cGVzLCBlZGl0b3JBY3Rvci5nZXRTbmFwc2hvdCgpLmNvbnRleHQua2V5R2VuZXJhdG9yKTtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQgJiYgIXZhbGlkYXRpb24ucmVzb2x1dGlvbj8uYXV0b1Jlc29sdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGVzY3JpcHRpb24gPSBgJHt2YWxpZGF0aW9uLnJlc29sdXRpb24/LmRlc2NyaXB0aW9ufWA7XG4gICAgICAgICAgICByZXR1cm4gZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgbmFtZTogXCJwYXN0ZUVycm9yXCIsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBlcnJvckRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICBkYXRhOiB2YWxpZGF0aW9uXG4gICAgICAgICAgICB9KSwgZGVidWckMShcIkludmFsaWQgaW5zZXJ0IHJlc3VsdFwiLCB2YWxpZGF0aW9uKSwgITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBzbGF0ZVZhbHVlLCBzY2hlbWFUeXBlcyksICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZWRpdG9yLmluc2VydFRleHRPckhUTUxEYXRhID0gKGRhdGEpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbilcbiAgICAgICAgcmV0dXJuIGRlYnVnJDEoXCJObyBzZWxlY3Rpb24sIG5vdCBpbnNlcnRpbmdcIiksICExO1xuICAgICAgY29uc3QgaHRtbCA9IGRhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgdGV4dCA9IGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICBpZiAoaHRtbCB8fCB0ZXh0KSB7XG4gICAgICAgIGRlYnVnJDEoXCJJbnNlcnRpbmcgZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgbGV0IHBvcnRhYmxlVGV4dCwgZnJhZ21lbnQsIGluc2VydGVkVHlwZTtcbiAgICAgICAgaWYgKGh0bWwpIHtcbiAgICAgICAgICBpZiAocG9ydGFibGVUZXh0ID0gaHRtbFRvQmxvY2tzKGh0bWwsIHNjaGVtYVR5cGVzLnBvcnRhYmxlVGV4dCwge1xuICAgICAgICAgICAgdW5zdGFibGVfd2hpdGVzcGFjZU9uUGFzdGVNb2RlOiB3aGl0ZXNwYWNlT25QYXN0ZU1vZGVcbiAgICAgICAgICB9KS5tYXAoKGJsb2NrKSA9PiBub3JtYWxpemVCbG9jayhibG9jaywge1xuICAgICAgICAgICAgYmxvY2tUeXBlTmFtZVxuICAgICAgICAgIH0pKSwgZnJhZ21lbnQgPSB0b1NsYXRlVmFsdWUocG9ydGFibGVUZXh0LCB7XG4gICAgICAgICAgICBzY2hlbWFUeXBlc1xuICAgICAgICAgIH0pLCBpbnNlcnRlZFR5cGUgPSBcIkhUTUxcIiwgcG9ydGFibGVUZXh0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0ZXh0VG9IdG1sID0gYDxodG1sPjxib2R5PiR7ZXNjYXBlSHRtbCh0ZXh0KS5zcGxpdCgvXFxuezIsfS8pLm1hcCgobGluZSkgPT4gbGluZSA/IGA8cD4ke2xpbmUucmVwbGFjZSgvKD86XFxyXFxufFxccnxcXG4pL2csIFwiPGJyLz5cIil9PC9wPmAgOiBcIjxwPjwvcD5cIikuam9pbihcIlwiKX08L2JvZHk+PC9odG1sPmA7XG4gICAgICAgICAgcG9ydGFibGVUZXh0ID0gaHRtbFRvQmxvY2tzKHRleHRUb0h0bWwsIHNjaGVtYVR5cGVzLnBvcnRhYmxlVGV4dCkubWFwKChibG9jaykgPT4gbm9ybWFsaXplQmxvY2soYmxvY2ssIHtcbiAgICAgICAgICAgIGJsb2NrVHlwZU5hbWVcbiAgICAgICAgICB9KSksIGZyYWdtZW50ID0gdG9TbGF0ZVZhbHVlKHBvcnRhYmxlVGV4dCwge1xuICAgICAgICAgICAgc2NoZW1hVHlwZXNcbiAgICAgICAgICB9KSwgaW5zZXJ0ZWRUeXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlVmFsdWUocG9ydGFibGVUZXh0LCBzY2hlbWFUeXBlcywgZWRpdG9yQWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LmtleUdlbmVyYXRvcik7XG4gICAgICAgIGlmICghdmFsaWRhdGlvbi52YWxpZCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGVzY3JpcHRpb24gPSBgQ291bGQgbm90IHZhbGlkYXRlIHRoZSByZXN1bHRpbmcgcG9ydGFibGUgdGV4dCB0byBpbnNlcnQuXG4ke3ZhbGlkYXRpb24ucmVzb2x1dGlvbj8uZGVzY3JpcHRpb259XG5UcnkgdG8gaW5zZXJ0IGFzIHBsYWluIHRleHQgKHNoaWZ0LXBhc3RlKSBpbnN0ZWFkLmA7XG4gICAgICAgICAgcmV0dXJuIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgbmFtZTogXCJwYXN0ZUVycm9yXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZXJyb3JEZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGRhdGE6IHZhbGlkYXRpb25cbiAgICAgICAgICB9KSwgZGVidWckMShcIkludmFsaWQgaW5zZXJ0IHJlc3VsdFwiLCB2YWxpZGF0aW9uKSwgITE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlYnVnJDEoYEluc2VydGluZyAke2luc2VydGVkVHlwZX0gZnJhZ21lbnQgYXQgJHtKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VsZWN0aW9uKX1gKSwgX2luc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQsIHNjaGVtYVR5cGVzKSwgITA7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZWRpdG9yLmluc2VydERhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgZWRpdG9yLmluc2VydFBvcnRhYmxlVGV4dERhdGEoZGF0YSkgfHwgZWRpdG9yLmluc2VydFRleHRPckhUTUxEYXRhKGRhdGEpO1xuICAgIH0sIGVkaXRvci5pbnNlcnRGcmFnbWVudERhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnQgPSBkYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi94LXBvcnRhYmxlLXRleHRcIik7XG4gICAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQocGFyc2VkKSwgITA7XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfSwgZWRpdG9yO1xuICB9O1xufVxuY29uc3QgZW50aXR5TWFwID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiMzOTtcIixcbiAgXCIvXCI6IFwiJiN4MkY7XCIsXG4gIFwiYFwiOiBcIiYjeDYwO1wiLFxuICBcIj1cIjogXCImI3gzRDtcIlxufTtcbmZ1bmN0aW9uIGVzY2FwZUh0bWwoc3RyKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC9bJjw+XCInYD0vXS9nLCAocykgPT4gZW50aXR5TWFwW3NdKTtcbn1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRlS2V5cyhlZGl0b3IsIGZyYWdtZW50LCBrZXlHZW5lcmF0b3IsIHNwYW5UeXBlTmFtZSwgZWRpdG9yVHlwZXMpIHtcbiAgcmV0dXJuIGZyYWdtZW50Lm1hcCgobm9kZSkgPT4ge1xuICAgIGNvbnN0IG5ld05vZGUgPSB7XG4gICAgICAuLi5ub2RlXG4gICAgfTtcbiAgICBpZiAoZWRpdG9yLmlzVGV4dEJsb2NrKG5ld05vZGUpKSB7XG4gICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IGVkaXRvclR5cGVzLmFubm90YXRpb25zLm1hcCgodCkgPT4gdC5uYW1lKTtcbiAgICAgIGlmIChhbm5vdGF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1hcmtEZWZzLFxuICAgICAgICAgIC4uLk5ld05vZGVOb0RlZnNcbiAgICAgICAgfSA9IG5ld05vZGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uTmV3Tm9kZU5vRGVmcyxcbiAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKChuZXdOb2RlLm1hcmtEZWZzIHx8IFtdKS5zb21lKChkZWYpID0+ICFhbm5vdGF0aW9ucy5pbmNsdWRlcyhkZWYuX3R5cGUpKSkge1xuICAgICAgICBjb25zdCBhbGxvd2VkQW5ub3RhdGlvbnMgPSAobmV3Tm9kZS5tYXJrRGVmcyB8fCBbXSkuZmlsdGVyKChkZWYpID0+IGFubm90YXRpb25zLmluY2x1ZGVzKGRlZi5fdHlwZSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm5ld05vZGUsXG4gICAgICAgICAgbWFya0RlZnM6IGFsbG93ZWRBbm5vdGF0aW9ucyxcbiAgICAgICAgICBfa2V5OiBrZXlHZW5lcmF0b3IoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbmV3Tm9kZS5tYXJrRGVmcyA9IChuZXdOb2RlLm1hcmtEZWZzIHx8IFtdKS5tYXAoKGRlZikgPT4ge1xuICAgICAgICBjb25zdCBvbGRLZXkgPSBkZWYuX2tleSwgbmV3S2V5ID0ga2V5R2VuZXJhdG9yKCk7XG4gICAgICAgIHJldHVybiBuZXdOb2RlLmNoaWxkcmVuID0gbmV3Tm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5fdHlwZSA9PT0gc3BhblR5cGVOYW1lICYmIGVkaXRvci5pc1RleHRTcGFuKGNoaWxkKSA/IHtcbiAgICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgICBtYXJrczogY2hpbGQubWFya3MgJiYgY2hpbGQubWFya3MuaW5jbHVkZXMob2xkS2V5KSA/IFsuLi5jaGlsZC5tYXJrc10uZmlsdGVyKChtYXJrKSA9PiBtYXJrICE9PSBvbGRLZXkpLmNvbmNhdChuZXdLZXkpIDogY2hpbGQubWFya3NcbiAgICAgICAgfSA6IGNoaWxkKSwge1xuICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICBfa2V5OiBuZXdLZXlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBub2RlV2l0aE5ld0tleXMgPSB7XG4gICAgICAuLi5uZXdOb2RlLFxuICAgICAgX2tleToga2V5R2VuZXJhdG9yKClcbiAgICB9O1xuICAgIHJldHVybiBlZGl0b3IuaXNUZXh0QmxvY2sobm9kZVdpdGhOZXdLZXlzKSAmJiAobm9kZVdpdGhOZXdLZXlzLmNoaWxkcmVuID0gbm9kZVdpdGhOZXdLZXlzLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+ICh7XG4gICAgICAuLi5jaGlsZCxcbiAgICAgIF9rZXk6IGtleUdlbmVyYXRvcigpXG4gICAgfSkpKSwgbm9kZVdpdGhOZXdLZXlzO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBzY2hlbWFUeXBlcykge1xuICBlZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKCgpID0+IHtcbiAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2ZvY3VzQmxvY2ssIGZvY3VzUGF0aF0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICAgIGRlcHRoOiAxXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvci5pc1RleHRCbG9jayhmb2N1c0Jsb2NrKSAmJiBlZGl0b3IuaXNUZXh0QmxvY2soZnJhZ21lbnRbMF0pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1hcmtEZWZzXG4gICAgICB9ID0gZm9jdXNCbG9jaztcbiAgICAgIGRlYnVnJDEoXCJNaXhpbmcgbWFya0RlZnMgb2YgZm9jdXNCbG9jayBhbmQgZnJhZ21lbnRzWzBdIGJsb2NrXCIsIG1hcmtEZWZzLCBmcmFnbWVudFswXS5tYXJrRGVmcyksIGlzRXF1YWwobWFya0RlZnMsIGZyYWdtZW50WzBdLm1hcmtEZWZzKSB8fCBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwge1xuICAgICAgICBtYXJrRGVmczogdW5pcShbLi4uZnJhZ21lbnRbMF0ubWFya0RlZnMgfHwgW10sIC4uLm1hcmtEZWZzIHx8IFtdXSlcbiAgICAgIH0sIHtcbiAgICAgICAgYXQ6IGZvY3VzUGF0aCxcbiAgICAgICAgbW9kZTogXCJsb3dlc3RcIixcbiAgICAgICAgdm9pZHM6ICExXG4gICAgICB9KTtcbiAgICB9XG4gICAgaXNFcXVhbFRvRW1wdHlFZGl0b3IoZWRpdG9yLmNoaWxkcmVuLCBzY2hlbWFUeXBlcykgPyAoVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IFswLCAwXVxuICAgIH0pLCBlZGl0b3IuaW5zZXJ0RnJhZ21lbnQoZnJhZ21lbnQpLCBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IFswXVxuICAgIH0pKSA6IGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gIH0pLCBlZGl0b3Iub25DaGFuZ2UoKTtcbn1cbmZ1bmN0aW9uIHdpdGhTeW5jUmFuZ2VEZWNvcmF0aW9ucyh7XG4gIGVkaXRvckFjdG9yLFxuICBzbGF0ZUVkaXRvcixcbiAgc3luY1JhbmdlRGVjb3JhdGlvbnNcbn0pIHtcbiAgY29uc3Qgb3JpZ2luYWxBcHBseSA9IHNsYXRlRWRpdG9yLmFwcGx5O1xuICByZXR1cm4gc2xhdGVFZGl0b3IuYXBwbHkgPSAob3ApID0+IHtcbiAgICBvcmlnaW5hbEFwcGx5KG9wKSwgIWVkaXRvckFjdG9yLmdldFNuYXBzaG90KCkubWF0Y2hlcyh7XG4gICAgICBcImVkaXQgbW9kZVwiOiBcInJlYWQgb25seVwiXG4gICAgfSkgJiYgb3AudHlwZSAhPT0gXCJzZXRfc2VsZWN0aW9uXCIgJiYgc3luY1JhbmdlRGVjb3JhdGlvbnMob3ApO1xuICB9LCAoKSA9PiB7XG4gICAgc2xhdGVFZGl0b3IuYXBwbHkgPSBvcmlnaW5hbEFwcGx5O1xuICB9O1xufVxuY29uc3QgZGVidWcgPSBkZWJ1Z1dpdGhOYW1lKFwiY29tcG9uZW50OkVkaXRhYmxlXCIpLCBQTEFDRUhPTERFUl9TVFlMRSA9IHtcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgdXNlclNlbGVjdDogXCJub25lXCIsXG4gIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICBsZWZ0OiAwLFxuICByaWdodDogMFxufSwgUG9ydGFibGVUZXh0RWRpdGFibGUgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uKHByb3BzLCBmb3J3YXJkZWRSZWYpIHtcbiAgY29uc3Qge1xuICAgIGhvdGtleXMsXG4gICAgb25CbHVyLFxuICAgIG9uRm9jdXMsXG4gICAgb25CZWZvcmVJbnB1dCxcbiAgICBvblBhc3RlLFxuICAgIG9uQ29weSxcbiAgICBvbkNsaWNrLFxuICAgIHJhbmdlRGVjb3JhdGlvbnMsXG4gICAgcmVuZGVyQW5ub3RhdGlvbixcbiAgICByZW5kZXJCbG9jayxcbiAgICByZW5kZXJDaGlsZCxcbiAgICByZW5kZXJEZWNvcmF0b3IsXG4gICAgcmVuZGVyTGlzdEl0ZW0sXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyU3R5bGUsXG4gICAgc2VsZWN0aW9uOiBwcm9wc1NlbGVjdGlvbixcbiAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyxcbiAgICBzcGVsbENoZWNrLFxuICAgIC4uLnJlc3RQcm9wc1xuICB9ID0gcHJvcHMsIHBvcnRhYmxlVGV4dEVkaXRvciA9IHVzZVBvcnRhYmxlVGV4dEVkaXRvcigpLCByZWYgPSB1c2VSZWYobnVsbCksIFtlZGl0YWJsZUVsZW1lbnQsIHNldEVkaXRhYmxlRWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKSwgW2hhc0ludmFsaWRWYWx1ZSwgc2V0SGFzSW52YWxpZFZhbHVlXSA9IHVzZVN0YXRlKCExKSwgW3JhbmdlRGVjb3JhdGlvblN0YXRlLCBzZXRSYW5nZURlY29yYXRpb25zU3RhdGVdID0gdXNlU3RhdGUoW10pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCkgPT4gcmVmLmN1cnJlbnQpO1xuICBjb25zdCByYW5nZURlY29yYXRpb25zUmVmID0gdXNlUmVmKHJhbmdlRGVjb3JhdGlvbnMpLCBlZGl0b3JBY3RvciA9IHVzZUNvbnRleHQoRWRpdG9yQWN0b3JDb250ZXh0KSwgcmVhZE9ubHkgPSB1c2VTZWxlY3RvcihlZGl0b3JBY3RvciwgKHMpID0+IHMubWF0Y2hlcyh7XG4gICAgXCJlZGl0IG1vZGVcIjogXCJyZWFkIG9ubHlcIlxuICB9KSksIHNjaGVtYVR5cGVzID0gdXNlU2VsZWN0b3IoZWRpdG9yQWN0b3IsIChzXzApID0+IHNfMC5jb250ZXh0LnNjaGVtYSksIHNsYXRlRWRpdG9yID0gdXNlU2xhdGUoKSwgYmxvY2tUeXBlTmFtZSA9IHNjaGVtYVR5cGVzLmJsb2NrLm5hbWU7XG4gIHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHdpdGhJbnNlcnREYXRhID0gY3JlYXRlV2l0aEluc2VydERhdGEoZWRpdG9yQWN0b3IsIHNjaGVtYVR5cGVzKTtcbiAgICBpZiAocmVhZE9ubHkpXG4gICAgICByZXR1cm4gZGVidWcoXCJFZGl0YWJsZSBpcyBpbiByZWFkIG9ubHkgbW9kZVwiKSwgd2l0aEluc2VydERhdGEoc2xhdGVFZGl0b3IpO1xuICAgIGNvbnN0IHdpdGhIb3RLZXlzID0gY3JlYXRlV2l0aEhvdGtleXMoZWRpdG9yQWN0b3IsIHBvcnRhYmxlVGV4dEVkaXRvciwgaG90a2V5cyk7XG4gICAgcmV0dXJuIGRlYnVnKFwiRWRpdGFibGUgaXMgaW4gZWRpdCBtb2RlXCIpLCB3aXRoSW5zZXJ0RGF0YSh3aXRoSG90S2V5cyhzbGF0ZUVkaXRvcikpO1xuICB9LCBbZWRpdG9yQWN0b3IsIGhvdGtleXMsIHBvcnRhYmxlVGV4dEVkaXRvciwgcmVhZE9ubHksIHNjaGVtYVR5cGVzLCBzbGF0ZUVkaXRvcl0pO1xuICBjb25zdCByZW5kZXJFbGVtZW50ID0gdXNlQ2FsbGJhY2soKGVQcm9wcykgPT4gLyogQF9fUFVSRV9fICovIGpzeChFbGVtZW50LCB7IC4uLmVQcm9wcywgcmVhZE9ubHksIHJlbmRlckJsb2NrLCByZW5kZXJDaGlsZCwgcmVuZGVyTGlzdEl0ZW0sIHJlbmRlclN0eWxlLCBzY2hlbWFUeXBlcywgc3BlbGxDaGVjayB9KSwgW3NjaGVtYVR5cGVzLCBzcGVsbENoZWNrLCByZWFkT25seSwgcmVuZGVyQmxvY2ssIHJlbmRlckNoaWxkLCByZW5kZXJMaXN0SXRlbSwgcmVuZGVyU3R5bGVdKSwgcmVuZGVyTGVhZiA9IHVzZUNhbGxiYWNrKChsUHJvcHMpID0+IHtcbiAgICBpZiAobFByb3BzLmxlYWYuX3R5cGUgPT09IFwic3BhblwiKSB7XG4gICAgICBsZXQgcmVuZGVyZWQgPSAvKiBAX19QVVJFX18gKi8ganN4KExlYWYsIHsgLi4ubFByb3BzLCBlZGl0b3JBY3Rvciwgc2NoZW1hVHlwZXMsIHJlbmRlckFubm90YXRpb24sIHJlbmRlckNoaWxkLCByZW5kZXJEZWNvcmF0b3IsIHJlYWRPbmx5IH0pO1xuICAgICAgaWYgKHJlbmRlclBsYWNlaG9sZGVyICYmIGxQcm9wcy5sZWFmLnBsYWNlaG9sZGVyICYmIGxQcm9wcy50ZXh0LnRleHQgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgc3R5bGU6IFBMQUNFSE9MREVSX1NUWUxFLCBjb250ZW50RWRpdGFibGU6ICExLCBjaGlsZHJlbjogcmVuZGVyUGxhY2Vob2xkZXIoKSB9KSxcbiAgICAgICAgICByZW5kZXJlZFxuICAgICAgICBdIH0pO1xuICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IGxQcm9wcy5sZWFmLnJhbmdlRGVjb3JhdGlvbjtcbiAgICAgIHJldHVybiBkZWNvcmF0aW9uICYmIChyZW5kZXJlZCA9IGRlY29yYXRpb24uY29tcG9uZW50KHtcbiAgICAgICAgY2hpbGRyZW46IHJlbmRlcmVkXG4gICAgICB9KSksIHJlbmRlcmVkO1xuICAgIH1cbiAgICByZXR1cm4gbFByb3BzLmNoaWxkcmVuO1xuICB9LCBbZWRpdG9yQWN0b3IsIHJlYWRPbmx5LCByZW5kZXJBbm5vdGF0aW9uLCByZW5kZXJDaGlsZCwgcmVuZGVyRGVjb3JhdG9yLCByZW5kZXJQbGFjZWhvbGRlciwgc2NoZW1hVHlwZXNdKSwgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocHJvcHNTZWxlY3Rpb24pIHtcbiAgICAgIGRlYnVnKGBTZWxlY3Rpb24gZnJvbSBwcm9wcyAke0pTT04uc3RyaW5naWZ5KHByb3BzU2VsZWN0aW9uKX1gKTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWxlY3Rpb24gPSBub3JtYWxpemVTZWxlY3Rpb24ocHJvcHNTZWxlY3Rpb24sIGZyb21TbGF0ZVZhbHVlKHNsYXRlRWRpdG9yLmNoaWxkcmVuLCBibG9ja1R5cGVOYW1lKSk7XG4gICAgICBpZiAobm9ybWFsaXplZFNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBkZWJ1ZyhgTm9ybWFsaXplZCBzZWxlY3Rpb24gZnJvbSBwcm9wcyAke0pTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZWxlY3Rpb24pfWApO1xuICAgICAgICBjb25zdCBzbGF0ZVJhbmdlID0gdG9TbGF0ZVJhbmdlKG5vcm1hbGl6ZWRTZWxlY3Rpb24sIHNsYXRlRWRpdG9yKTtcbiAgICAgICAgc2xhdGVSYW5nZSAmJiAoVHJhbnNmb3Jtcy5zZWxlY3Qoc2xhdGVFZGl0b3IsIHNsYXRlUmFuZ2UpLCBzbGF0ZUVkaXRvci5vcGVyYXRpb25zLnNvbWUoKG8pID0+IG8udHlwZSA9PT0gXCJzZXRfc2VsZWN0aW9uXCIpIHx8IGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgc2VsZWN0aW9uOiBub3JtYWxpemVkU2VsZWN0aW9uXG4gICAgICAgIH0pLCBzbGF0ZUVkaXRvci5vbkNoYW5nZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtibG9ja1R5cGVOYW1lLCBlZGl0b3JBY3RvciwgcHJvcHNTZWxlY3Rpb24sIHNsYXRlRWRpdG9yXSksIHN5bmNSYW5nZURlY29yYXRpb25zID0gdXNlQ2FsbGJhY2soKG9wZXJhdGlvbikgPT4ge1xuICAgIGlmIChyYW5nZURlY29yYXRpb25zICYmIHJhbmdlRGVjb3JhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmV3U2xhdGVSYW5nZXMgPSBbXTtcbiAgICAgIGlmIChyYW5nZURlY29yYXRpb25zLmZvckVhY2goKHJhbmdlRGVjb3JhdGlvbkl0ZW0pID0+IHtcbiAgICAgICAgY29uc3Qgc2xhdGVSYW5nZV8wID0gdG9TbGF0ZVJhbmdlKHJhbmdlRGVjb3JhdGlvbkl0ZW0uc2VsZWN0aW9uLCBzbGF0ZUVkaXRvcik7XG4gICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShzbGF0ZVJhbmdlXzApKSB7XG4gICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uSXRlbS5vbk1vdmVkICYmIHJhbmdlRGVjb3JhdGlvbkl0ZW0ub25Nb3ZlZCh7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb246IG51bGwsXG4gICAgICAgICAgICByYW5nZURlY29yYXRpb246IHJhbmdlRGVjb3JhdGlvbkl0ZW0sXG4gICAgICAgICAgICBvcmlnaW46IFwibG9jYWxcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3UmFuZ2U7XG4gICAgICAgIGlmIChvcGVyYXRpb24gJiYgKG5ld1JhbmdlID0gbW92ZVJhbmdlQnlPcGVyYXRpb24oc2xhdGVSYW5nZV8wLCBvcGVyYXRpb24pLCBuZXdSYW5nZSAmJiBuZXdSYW5nZSAhPT0gc2xhdGVSYW5nZV8wIHx8IG5ld1JhbmdlID09PSBudWxsICYmIHNsYXRlUmFuZ2VfMCkpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IFBvcnRhYmxlVGV4dEVkaXRvci5nZXRWYWx1ZShwb3J0YWJsZVRleHRFZGl0b3IpLCBuZXdSYW5nZVNlbGVjdGlvbiA9IHRvUG9ydGFibGVUZXh0UmFuZ2UodmFsdWUsIG5ld1JhbmdlLCBzY2hlbWFUeXBlcyk7XG4gICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uSXRlbS5vbk1vdmVkICYmIHJhbmdlRGVjb3JhdGlvbkl0ZW0ub25Nb3ZlZCh7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb246IG5ld1JhbmdlU2VsZWN0aW9uLFxuICAgICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uOiByYW5nZURlY29yYXRpb25JdGVtLFxuICAgICAgICAgICAgb3JpZ2luOiBcImxvY2FsXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBuZXdSYW5nZSAhPT0gbnVsbCAmJiBuZXdTbGF0ZVJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAuLi5uZXdSYW5nZSB8fCBzbGF0ZVJhbmdlXzAsXG4gICAgICAgICAgcmFuZ2VEZWNvcmF0aW9uOiByYW5nZURlY29yYXRpb25JdGVtXG4gICAgICAgIH0pO1xuICAgICAgfSksIG5ld1NsYXRlUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2V0UmFuZ2VEZWNvcmF0aW9uc1N0YXRlKG5ld1NsYXRlUmFuZ2VzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRSYW5nZURlY29yYXRpb25zU3RhdGUoKHJhbmdlRGVjb3JhdGlvblN0YXRlXzApID0+IHJhbmdlRGVjb3JhdGlvblN0YXRlXzAubGVuZ3RoID4gMCA/IFtdIDogcmFuZ2VEZWNvcmF0aW9uU3RhdGVfMCk7XG4gIH0sIFtwb3J0YWJsZVRleHRFZGl0b3IsIHJhbmdlRGVjb3JhdGlvbnMsIHNjaGVtYVR5cGVzLCBzbGF0ZUVkaXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG9uUmVhZHkgPSBlZGl0b3JBY3Rvci5vbihcInJlYWR5XCIsICgpID0+IHtcbiAgICAgIHN5bmNSYW5nZURlY29yYXRpb25zKCksIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMoKTtcbiAgICB9KSwgb25JbnZhbGlkVmFsdWUgPSBlZGl0b3JBY3Rvci5vbihcImludmFsaWQgdmFsdWVcIiwgKCkgPT4ge1xuICAgICAgc2V0SGFzSW52YWxpZFZhbHVlKCEwKTtcbiAgICB9KSwgb25WYWx1ZUNoYW5nZWQgPSBlZGl0b3JBY3Rvci5vbihcInZhbHVlIGNoYW5nZWRcIiwgKCkgPT4ge1xuICAgICAgc2V0SGFzSW52YWxpZFZhbHVlKCExKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgb25SZWFkeS51bnN1YnNjcmliZSgpLCBvbkludmFsaWRWYWx1ZS51bnN1YnNjcmliZSgpLCBvblZhbHVlQ2hhbmdlZC51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtlZGl0b3JBY3RvciwgcmVzdG9yZVNlbGVjdGlvbkZyb21Qcm9wcywgc3luY1JhbmdlRGVjb3JhdGlvbnNdKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBwcm9wc1NlbGVjdGlvbiAmJiAhaGFzSW52YWxpZFZhbHVlICYmIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHMoKTtcbiAgfSwgW2hhc0ludmFsaWRWYWx1ZSwgcHJvcHNTZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb25Gcm9tUHJvcHNdKTtcbiAgY29uc3QgW3N5bmNlZFJhbmdlRGVjb3JhdGlvbnMsIHNldFN5bmNlZFJhbmdlRGVjb3JhdGlvbnNdID0gdXNlU3RhdGUoITEpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHN5bmNlZFJhbmdlRGVjb3JhdGlvbnMgfHwgKHNldFN5bmNlZFJhbmdlRGVjb3JhdGlvbnMoITApLCBzeW5jUmFuZ2VEZWNvcmF0aW9ucygpKTtcbiAgfSwgW3N5bmNSYW5nZURlY29yYXRpb25zLCBzeW5jZWRSYW5nZURlY29yYXRpb25zXSksIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNFcXVhbChyYW5nZURlY29yYXRpb25zLCByYW5nZURlY29yYXRpb25zUmVmLmN1cnJlbnQpIHx8IHN5bmNSYW5nZURlY29yYXRpb25zKCksIHJhbmdlRGVjb3JhdGlvbnNSZWYuY3VycmVudCA9IHJhbmdlRGVjb3JhdGlvbnM7XG4gIH0sIFtyYW5nZURlY29yYXRpb25zLCBzeW5jUmFuZ2VEZWNvcmF0aW9uc10pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHRlYXJkb3duID0gd2l0aFN5bmNSYW5nZURlY29yYXRpb25zKHtcbiAgICAgIGVkaXRvckFjdG9yLFxuICAgICAgc2xhdGVFZGl0b3IsXG4gICAgICBzeW5jUmFuZ2VEZWNvcmF0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB0ZWFyZG93bigpO1xuICB9LCBbZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yLCBzeW5jUmFuZ2VEZWNvcmF0aW9uc10pO1xuICBjb25zdCBoYW5kbGVDb3B5ID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgb25Db3B5ID8gb25Db3B5KGV2ZW50KSAhPT0gdm9pZCAwICYmIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgOiBldmVudC5uYXRpdmVFdmVudC5jbGlwYm9hcmREYXRhICYmIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICB0eXBlOiBcImNvcHlcIixcbiAgICAgICAgZGF0YTogZXZlbnQubmF0aXZlRXZlbnQuY2xpcGJvYXJkRGF0YVxuICAgICAgfSxcbiAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICB9KTtcbiAgfSwgW29uQ29weSwgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZVBhc3RlID0gdXNlQ2FsbGJhY2soKGV2ZW50XzApID0+IHtcbiAgICBjb25zdCB2YWx1ZV8wID0gUG9ydGFibGVUZXh0RWRpdG9yLmdldFZhbHVlKHBvcnRhYmxlVGV4dEVkaXRvciksIHBhdGggPSB0b1BvcnRhYmxlVGV4dFJhbmdlKHZhbHVlXzAsIHNsYXRlRWRpdG9yLnNlbGVjdGlvbiwgc2NoZW1hVHlwZXMpPy5mb2N1cy5wYXRoIHx8IFtdLCBvblBhc3RlUmVzdWx0ID0gb25QYXN0ZT8uKHtcbiAgICAgIGV2ZW50OiBldmVudF8wLFxuICAgICAgdmFsdWU6IHZhbHVlXzAsXG4gICAgICBwYXRoLFxuICAgICAgc2NoZW1hVHlwZXNcbiAgICB9KTtcbiAgICBvblBhc3RlUmVzdWx0IHx8ICFzbGF0ZUVkaXRvci5zZWxlY3Rpb24gPyAoZXZlbnRfMC5wcmV2ZW50RGVmYXVsdCgpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwibG9hZGluZ1wiXG4gICAgfSksIFByb21pc2UucmVzb2x2ZShvblBhc3RlUmVzdWx0KS50aGVuKChyZXN1bHRfMCkgPT4ge1xuICAgICAgZGVidWcoXCJDdXN0b20gcGFzdGUgZnVuY3Rpb24gZnJvbSBjbGllbnQgcmVzb2x2ZWRcIiwgcmVzdWx0XzApLCAhcmVzdWx0XzAgfHwgIXJlc3VsdF8wLmluc2VydCA/IChkZWJ1ZyhcIk5vIHJlc3VsdCBmcm9tIGN1c3RvbSBwYXN0ZSBoYW5kbGVyLCBwYXN0aW5nIG5vcm1hbGx5XCIpLCBzbGF0ZUVkaXRvci5pbnNlcnREYXRhKGV2ZW50XzAuY2xpcGJvYXJkRGF0YSkpIDogcmVzdWx0XzAuaW5zZXJ0ID8gc2xhdGVFZGl0b3IuaW5zZXJ0RnJhZ21lbnQodG9TbGF0ZVZhbHVlKHJlc3VsdF8wLmluc2VydCwge1xuICAgICAgICBzY2hlbWFUeXBlc1xuICAgICAgfSkpIDogY29uc29sZS53YXJuKFwiWW91ciBvblBhc3RlIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZyB1bmV4cGVjdGVkOlwiLCByZXN1bHRfMCk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiAoY29uc29sZS5lcnJvcihlcnJvciksIGVycm9yKSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJkb25lIGxvYWRpbmdcIlxuICAgICAgfSk7XG4gICAgfSkpIDogZXZlbnRfMC5uYXRpdmVFdmVudC5jbGlwYm9hcmREYXRhICYmIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgdHlwZTogXCJiZWhhdmlvciBldmVudFwiLFxuICAgICAgYmVoYXZpb3JFdmVudDoge1xuICAgICAgICB0eXBlOiBcInBhc3RlXCIsXG4gICAgICAgIGRhdGE6IGV2ZW50XzAubmF0aXZlRXZlbnQuY2xpcGJvYXJkRGF0YVxuICAgICAgfSxcbiAgICAgIGVkaXRvcjogc2xhdGVFZGl0b3IsXG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRfMFxuICAgIH0pLCBkZWJ1ZyhcIk5vIHJlc3VsdCBmcm9tIGN1c3RvbSBwYXN0ZSBoYW5kbGVyLCBwYXN0aW5nIG5vcm1hbGx5XCIpO1xuICB9LCBbZWRpdG9yQWN0b3IsIG9uUGFzdGUsIHBvcnRhYmxlVGV4dEVkaXRvciwgc2NoZW1hVHlwZXMsIHNsYXRlRWRpdG9yXSksIGhhbmRsZU9uRm9jdXMgPSB1c2VDYWxsYmFjaygoZXZlbnRfMSkgPT4ge1xuICAgIGlmIChvbkZvY3VzICYmIG9uRm9jdXMoZXZlbnRfMSksICFldmVudF8xLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBQb3J0YWJsZVRleHRFZGl0b3IuZ2V0U2VsZWN0aW9uKHBvcnRhYmxlVGV4dEVkaXRvcik7XG4gICAgICBzZWxlY3Rpb24gPT09IG51bGwgJiYgKFRyYW5zZm9ybXMuc2VsZWN0KHNsYXRlRWRpdG9yLCBFZGl0b3Iuc3RhcnQoc2xhdGVFZGl0b3IsIFtdKSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpLCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgICAgdHlwZTogXCJmb2N1c2VkXCIsXG4gICAgICAgIGV2ZW50OiBldmVudF8xXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFBvcnRhYmxlVGV4dEVkaXRvci5nZXRTZWxlY3Rpb24ocG9ydGFibGVUZXh0RWRpdG9yKTtcbiAgICAgIHNlbGVjdGlvbiA9PT0gbmV3U2VsZWN0aW9uICYmIGVkaXRvckFjdG9yLnNlbmQoe1xuICAgICAgICB0eXBlOiBcInNlbGVjdGlvblwiLFxuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VkaXRvckFjdG9yLCBvbkZvY3VzLCBwb3J0YWJsZVRleHRFZGl0b3IsIHNsYXRlRWRpdG9yXSksIGhhbmRsZUNsaWNrID0gdXNlQ2FsbGJhY2soKGV2ZW50XzIpID0+IHtcbiAgICBvbkNsaWNrICYmIG9uQ2xpY2soZXZlbnRfMik7XG4gICAgY29uc3QgZm9jdXNCbG9ja1BhdGggPSBzbGF0ZUVkaXRvci5zZWxlY3Rpb24gPyBzbGF0ZUVkaXRvci5zZWxlY3Rpb24uZm9jdXMucGF0aC5zbGljZSgwLCAxKSA6IHZvaWQgMCwgZm9jdXNCbG9jayA9IGZvY3VzQmxvY2tQYXRoID8gTm9kZS5kZXNjZW5kYW50KHNsYXRlRWRpdG9yLCBmb2N1c0Jsb2NrUGF0aCkgOiB2b2lkIDAsIFtfLCBsYXN0Tm9kZVBhdGhdID0gTm9kZS5sYXN0KHNsYXRlRWRpdG9yLCBbXSksIGxhc3RCbG9ja1BhdGggPSBsYXN0Tm9kZVBhdGguc2xpY2UoMCwgMSksIGxhc3ROb2RlRm9jdXNlZCA9IGZvY3VzQmxvY2tQYXRoID8gUGF0aC5lcXVhbHMobGFzdEJsb2NrUGF0aCwgZm9jdXNCbG9ja1BhdGgpIDogITEsIGxhc3RCbG9ja0lzVm9pZCA9IGZvY3VzQmxvY2sgPyAhc2xhdGVFZGl0b3IuaXNUZXh0QmxvY2soZm9jdXNCbG9jaykgOiAhMTtcbiAgICBzbGF0ZUVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKSAmJiBsYXN0Tm9kZUZvY3VzZWQgJiYgbGFzdEJsb2NrSXNWb2lkICYmIChUcmFuc2Zvcm1zLmluc2VydE5vZGVzKHNsYXRlRWRpdG9yLCBzbGF0ZUVkaXRvci5wdGVDcmVhdGVUZXh0QmxvY2soe1xuICAgICAgZGVjb3JhdG9yczogW11cbiAgICB9KSksIHNsYXRlRWRpdG9yLm9uQ2hhbmdlKCkpO1xuICB9LCBbb25DbGljaywgc2xhdGVFZGl0b3JdKSwgaGFuZGxlT25CbHVyID0gdXNlQ2FsbGJhY2soKGV2ZW50XzMpID0+IHtcbiAgICBvbkJsdXIgJiYgb25CbHVyKGV2ZW50XzMpLCBldmVudF8zLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgfHwgZWRpdG9yQWN0b3Iuc2VuZCh7XG4gICAgICB0eXBlOiBcImJsdXJyZWRcIixcbiAgICAgIGV2ZW50OiBldmVudF8zXG4gICAgfSk7XG4gIH0sIFtlZGl0b3JBY3Rvciwgb25CbHVyXSksIGhhbmRsZU9uQmVmb3JlSW5wdXQgPSB1c2VDYWxsYmFjaygoZXZlbnRfNCkgPT4ge1xuICAgIG9uQmVmb3JlSW5wdXQgJiYgb25CZWZvcmVJbnB1dChldmVudF80KTtcbiAgfSwgW29uQmVmb3JlSW5wdXRdKSwgdmFsaWRhdGVTZWxlY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFzbGF0ZUVkaXRvci5zZWxlY3Rpb24pXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChzbGF0ZUVkaXRvciksIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gcm9vdDtcbiAgICBpZiAocmVmLmN1cnJlbnQgIT09IGFjdGl2ZUVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gUmVhY3RFZGl0b3IuZ2V0V2luZG93KHNsYXRlRWRpdG9yKS5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIWRvbVNlbGVjdGlvbiB8fCBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBleGlzdGluZ0RPTVJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5ld0RPTVJhbmdlID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShzbGF0ZUVkaXRvciwgc2xhdGVFZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgIChuZXdET01SYW5nZS5zdGFydE9mZnNldCAhPT0gZXhpc3RpbmdET01SYW5nZS5zdGFydE9mZnNldCB8fCBuZXdET01SYW5nZS5lbmRPZmZzZXQgIT09IGV4aXN0aW5nRE9NUmFuZ2UuZW5kT2Zmc2V0KSAmJiAoZGVidWcoXCJET00gcmFuZ2Ugb3V0IG9mIHN5bmMsIHZhbGlkYXRpbmcgc2VsZWN0aW9uXCIpLCBkb21TZWxlY3Rpb24/LnJlbW92ZUFsbFJhbmdlcygpLCBkb21TZWxlY3Rpb24uYWRkUmFuZ2UobmV3RE9NUmFuZ2UpKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGRlYnVnKFwiQ291bGQgbm90IHJlc29sdmUgc2VsZWN0aW9uLCBzZWxlY3RpbmcgdG9wIGRvY3VtZW50XCIpLCBUcmFuc2Zvcm1zLmRlc2VsZWN0KHNsYXRlRWRpdG9yKSwgc2xhdGVFZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiBUcmFuc2Zvcm1zLnNlbGVjdChzbGF0ZUVkaXRvciwgWzAsIDBdKSwgc2xhdGVFZGl0b3Iub25DaGFuZ2UoKTtcbiAgICB9XG4gIH0sIFtyZWYsIHNsYXRlRWRpdG9yXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVkaXRhYmxlRWxlbWVudCkge1xuICAgICAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHZhbGlkYXRlU2VsZWN0aW9uKTtcbiAgICAgIHJldHVybiBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoZWRpdGFibGVFbGVtZW50LCB7XG4gICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiAhMSxcbiAgICAgICAgYXR0cmlidXRlczogITEsXG4gICAgICAgIGNoYXJhY3RlckRhdGE6ICExLFxuICAgICAgICBjaGlsZExpc3Q6ICEwLFxuICAgICAgICBzdWJ0cmVlOiAhMFxuICAgICAgfSksICgpID0+IHtcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3ZhbGlkYXRlU2VsZWN0aW9uLCBlZGl0YWJsZUVsZW1lbnRdKTtcbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKChldmVudF81KSA9PiB7XG4gICAgcHJvcHMub25LZXlEb3duICYmIHByb3BzLm9uS2V5RG93bihldmVudF81KSwgZXZlbnRfNS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBzbGF0ZUVkaXRvci5wdGVXaXRoSG90S2V5cyhldmVudF81KSwgZXZlbnRfNS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJrZXkuZG93blwiLFxuICAgICAgICBrZXlib2FyZEV2ZW50OiB7XG4gICAgICAgICAga2V5OiBldmVudF81LmtleSxcbiAgICAgICAgICBjb2RlOiBldmVudF81LmNvZGUsXG4gICAgICAgICAgYWx0S2V5OiBldmVudF81LmFsdEtleSxcbiAgICAgICAgICBjdHJsS2V5OiBldmVudF81LmN0cmxLZXksXG4gICAgICAgICAgbWV0YUtleTogZXZlbnRfNS5tZXRhS2V5LFxuICAgICAgICAgIHNoaWZ0S2V5OiBldmVudF81LnNoaWZ0S2V5XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlZGl0b3I6IHNsYXRlRWRpdG9yLFxuICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XzVcbiAgICB9KTtcbiAgfSwgW3Byb3BzLCBlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3JdKSwgaGFuZGxlS2V5VXAgPSB1c2VDYWxsYmFjaygoZXZlbnRfNikgPT4ge1xuICAgIHByb3BzLm9uS2V5VXAgJiYgcHJvcHMub25LZXlVcChldmVudF82KSwgZXZlbnRfNi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBlZGl0b3JBY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwiYmVoYXZpb3IgZXZlbnRcIixcbiAgICAgIGJlaGF2aW9yRXZlbnQ6IHtcbiAgICAgICAgdHlwZTogXCJrZXkudXBcIixcbiAgICAgICAga2V5Ym9hcmRFdmVudDoge1xuICAgICAgICAgIGtleTogZXZlbnRfNi5rZXksXG4gICAgICAgICAgY29kZTogZXZlbnRfNi5jb2RlLFxuICAgICAgICAgIGFsdEtleTogZXZlbnRfNi5hbHRLZXksXG4gICAgICAgICAgY3RybEtleTogZXZlbnRfNi5jdHJsS2V5LFxuICAgICAgICAgIG1ldGFLZXk6IGV2ZW50XzYubWV0YUtleSxcbiAgICAgICAgICBzaGlmdEtleTogZXZlbnRfNi5zaGlmdEtleVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZWRpdG9yOiBzbGF0ZUVkaXRvcixcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudF82XG4gICAgfSk7XG4gIH0sIFtwcm9wcywgZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yXSksIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3VG9TbGF0ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3ID09PSBudWxsID8gbm9vcCA6IChfZWRpdG9yLCBkb21SYW5nZSkgPT4ge1xuICAgICAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyhwb3J0YWJsZVRleHRFZGl0b3IsIGRvbVJhbmdlKTtcbiAgICAgIH07XG4gIH0sIFtwb3J0YWJsZVRleHRFZGl0b3IsIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3XSksIGRlY29yYXRlID0gdXNlQ2FsbGJhY2soKFssIHBhdGhfMF0pID0+IHtcbiAgICBpZiAoaXNFcXVhbFRvRW1wdHlFZGl0b3Ioc2xhdGVFZGl0b3IuY2hpbGRyZW4sIHNjaGVtYVR5cGVzKSlcbiAgICAgIHJldHVybiBbe1xuICAgICAgICBhbmNob3I6IHtcbiAgICAgICAgICBwYXRoOiBbMCwgMF0sXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiB7XG4gICAgICAgICAgcGF0aDogWzAsIDBdLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9LFxuICAgICAgICBwbGFjZWhvbGRlcjogITBcbiAgICAgIH1dO1xuICAgIGlmIChwYXRoXzAubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHJlc3VsdF8xID0gcmFuZ2VEZWNvcmF0aW9uU3RhdGUuZmlsdGVyKChpdGVtKSA9PiBSYW5nZS5pc0NvbGxhcHNlZChpdGVtKSA/IHBhdGhfMC5sZW5ndGggIT09IDIgPyAhMSA6IFBhdGguZXF1YWxzKGl0ZW0uZm9jdXMucGF0aCwgcGF0aF8wKSAmJiBQYXRoLmVxdWFscyhpdGVtLmFuY2hvci5wYXRoLCBwYXRoXzApIDogUmFuZ2UuaW50ZXJzZWN0aW9uKGl0ZW0sIHtcbiAgICAgIGFuY2hvcjoge1xuICAgICAgICBwYXRoOiBwYXRoXzAsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGZvY3VzOiB7XG4gICAgICAgIHBhdGg6IHBhdGhfMCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9XG4gICAgfSkgfHwgUmFuZ2UuaW5jbHVkZXMoaXRlbSwgcGF0aF8wKSk7XG4gICAgcmV0dXJuIHJlc3VsdF8xLmxlbmd0aCA+IDAgPyByZXN1bHRfMSA6IFtdO1xuICB9LCBbc2xhdGVFZGl0b3IsIHNjaGVtYVR5cGVzLCByYW5nZURlY29yYXRpb25TdGF0ZV0pO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShzbGF0ZUVkaXRvciwgc2xhdGVFZGl0b3IpLCBzZXRFZGl0YWJsZUVsZW1lbnQocmVmLmN1cnJlbnQpO1xuICB9LCBbc2xhdGVFZGl0b3IsIHJlZl0pLCBwb3J0YWJsZVRleHRFZGl0b3IgPyBoYXNJbnZhbGlkVmFsdWUgPyBudWxsIDogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBFZGl0YWJsZSxcbiAgICB7XG4gICAgICAuLi5yZXN0UHJvcHMsXG4gICAgICBhdXRvRm9jdXM6ICExLFxuICAgICAgY2xhc3NOYW1lOiByZXN0UHJvcHMuY2xhc3NOYW1lIHx8IFwicHQtZWRpdGFibGVcIixcbiAgICAgIGRlY29yYXRlLFxuICAgICAgb25CbHVyOiBoYW5kbGVPbkJsdXIsXG4gICAgICBvbkNvcHk6IGhhbmRsZUNvcHksXG4gICAgICBvbkNsaWNrOiBoYW5kbGVDbGljayxcbiAgICAgIG9uRE9NQmVmb3JlSW5wdXQ6IGhhbmRsZU9uQmVmb3JlSW5wdXQsXG4gICAgICBvbkZvY3VzOiBoYW5kbGVPbkZvY3VzLFxuICAgICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgICAgb25LZXlVcDogaGFuZGxlS2V5VXAsXG4gICAgICBvblBhc3RlOiBoYW5kbGVQYXN0ZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcmVuZGVyUGxhY2Vob2xkZXI6IHZvaWQgMCxcbiAgICAgIHJlbmRlckVsZW1lbnQsXG4gICAgICByZW5kZXJMZWFmLFxuICAgICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXc6IHNjcm9sbFNlbGVjdGlvbkludG9WaWV3VG9TbGF0ZVxuICAgIH1cbiAgKSA6IG51bGw7XG59KTtcblBvcnRhYmxlVGV4dEVkaXRhYmxlLmRpc3BsYXlOYW1lID0gXCJGb3J3YXJkUmVmKFBvcnRhYmxlVGV4dEVkaXRhYmxlKVwiO1xuY29uc3QgRWRpdG9yQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmZ1bmN0aW9uIEVkaXRvclByb3ZpZGVyKHByb3BzKSB7XG4gIGNvbnN0ICQgPSBjKDI4KSwgZWRpdG9yID0gdXNlQ3JlYXRlRWRpdG9yKHByb3BzLmluaXRpYWxDb25maWcpLCBlZGl0b3JBY3RvciA9IGVkaXRvci5faW50ZXJuYWwuZWRpdG9yQWN0b3IsIHNsYXRlRWRpdG9yID0gZWRpdG9yLl9pbnRlcm5hbC5zbGF0ZUVkaXRvcjtcbiAgbGV0IHQwLCB0MTtcbiAgJFswXSAhPT0gZWRpdG9yID8gKHQxID0gbmV3IFBvcnRhYmxlVGV4dEVkaXRvcih7XG4gICAgZWRpdG9yXG4gIH0pLCAkWzBdID0gZWRpdG9yLCAkWzFdID0gdDEpIDogdDEgPSAkWzFdLCB0MCA9IHQxO1xuICBjb25zdCBwb3J0YWJsZVRleHRFZGl0b3IgPSB0MDtcbiAgbGV0IHQyO1xuICAkWzJdICE9PSBwb3J0YWJsZVRleHRFZGl0b3IuY2hhbmdlJCA/ICh0MiA9IChjaGFuZ2UpID0+IHtcbiAgICBwb3J0YWJsZVRleHRFZGl0b3IuY2hhbmdlJC5uZXh0KGNoYW5nZSk7XG4gIH0sICRbMl0gPSBwb3J0YWJsZVRleHRFZGl0b3IuY2hhbmdlJCwgJFszXSA9IHQyKSA6IHQyID0gJFszXTtcbiAgbGV0IHQzO1xuICAkWzRdICE9PSBlZGl0b3JBY3RvciB8fCAkWzVdICE9PSB0MiA/ICh0MyA9IC8qIEBfX1BVUkVfXyAqLyBqc3goUm91dGVFdmVudHNUb0NoYW5nZXMsIHsgZWRpdG9yQWN0b3IsIG9uQ2hhbmdlOiB0MiB9KSwgJFs0XSA9IGVkaXRvckFjdG9yLCAkWzVdID0gdDIsICRbNl0gPSB0MykgOiB0MyA9ICRbNl07XG4gIGxldCB0NDtcbiAgJFs3XSAhPT0gZWRpdG9yQWN0b3IgfHwgJFs4XSAhPT0gc2xhdGVFZGl0b3IuaW5zdGFuY2UgPyAodDQgPSAvKiBAX19QVVJFX18gKi8ganN4KFN5bmNocm9uaXplciwgeyBlZGl0b3JBY3Rvciwgc2xhdGVFZGl0b3I6IHNsYXRlRWRpdG9yLmluc3RhbmNlIH0pLCAkWzddID0gZWRpdG9yQWN0b3IsICRbOF0gPSBzbGF0ZUVkaXRvci5pbnN0YW5jZSwgJFs5XSA9IHQ0KSA6IHQ0ID0gJFs5XTtcbiAgbGV0IHQ1O1xuICAkWzEwXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsxMV0gIT09IHByb3BzLmNoaWxkcmVuID8gKHQ1ID0gLyogQF9fUFVSRV9fICovIGpzeChQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb25Qcm92aWRlciwgeyBlZGl0b3JBY3RvciwgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuIH0pLCAkWzEwXSA9IGVkaXRvckFjdG9yLCAkWzExXSA9IHByb3BzLmNoaWxkcmVuLCAkWzEyXSA9IHQ1KSA6IHQ1ID0gJFsxMl07XG4gIGxldCB0NjtcbiAgJFsxM10gIT09IHBvcnRhYmxlVGV4dEVkaXRvciB8fCAkWzE0XSAhPT0gdDUgPyAodDYgPSAvKiBAX19QVVJFX18gKi8ganN4KFBvcnRhYmxlVGV4dEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHBvcnRhYmxlVGV4dEVkaXRvciwgY2hpbGRyZW46IHQ1IH0pLCAkWzEzXSA9IHBvcnRhYmxlVGV4dEVkaXRvciwgJFsxNF0gPSB0NSwgJFsxNV0gPSB0NikgOiB0NiA9ICRbMTVdO1xuICBsZXQgdDc7XG4gICRbMTZdICE9PSBzbGF0ZUVkaXRvci5pbml0aWFsVmFsdWUgfHwgJFsxN10gIT09IHNsYXRlRWRpdG9yLmluc3RhbmNlIHx8ICRbMThdICE9PSB0NiA/ICh0NyA9IC8qIEBfX1BVUkVfXyAqLyBqc3goU2xhdGUsIHsgZWRpdG9yOiBzbGF0ZUVkaXRvci5pbnN0YW5jZSwgaW5pdGlhbFZhbHVlOiBzbGF0ZUVkaXRvci5pbml0aWFsVmFsdWUsIGNoaWxkcmVuOiB0NiB9KSwgJFsxNl0gPSBzbGF0ZUVkaXRvci5pbml0aWFsVmFsdWUsICRbMTddID0gc2xhdGVFZGl0b3IuaW5zdGFuY2UsICRbMThdID0gdDYsICRbMTldID0gdDcpIDogdDcgPSAkWzE5XTtcbiAgbGV0IHQ4O1xuICAkWzIwXSAhPT0gZWRpdG9yQWN0b3IgfHwgJFsyMV0gIT09IHQ3ID8gKHQ4ID0gLyogQF9fUFVSRV9fICovIGpzeChFZGl0b3JBY3RvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGVkaXRvckFjdG9yLCBjaGlsZHJlbjogdDcgfSksICRbMjBdID0gZWRpdG9yQWN0b3IsICRbMjFdID0gdDcsICRbMjJdID0gdDgpIDogdDggPSAkWzIyXTtcbiAgbGV0IHQ5O1xuICByZXR1cm4gJFsyM10gIT09IGVkaXRvciB8fCAkWzI0XSAhPT0gdDMgfHwgJFsyNV0gIT09IHQ0IHx8ICRbMjZdICE9PSB0OCA/ICh0OSA9IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEVkaXRvckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGVkaXRvciwgY2hpbGRyZW46IFtcbiAgICB0MyxcbiAgICB0NCxcbiAgICB0OFxuICBdIH0pLCAkWzIzXSA9IGVkaXRvciwgJFsyNF0gPSB0MywgJFsyNV0gPSB0NCwgJFsyNl0gPSB0OCwgJFsyN10gPSB0OSkgOiB0OSA9ICRbMjddLCB0OTtcbn1cbmZ1bmN0aW9uIHVzZUVkaXRvcigpIHtcbiAgY29uc3QgZWRpdG9yID0gUmVhY3QudXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbiAgaWYgKCFlZGl0b3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gRWRpdG9yIHNldC4gVXNlIEVkaXRvclByb3ZpZGVyIHRvIHNldCBvbmUuXCIpO1xuICByZXR1cm4gZWRpdG9yO1xufVxuZnVuY3Rpb24gRWRpdG9yRXZlbnRMaXN0ZW5lcihwcm9wcykge1xuICBjb25zdCAkID0gYyg0KSwgZWRpdG9yID0gdXNlRWRpdG9yKCksIG9uID0gdXNlRWZmZWN0RXZlbnQocHJvcHMub24pO1xuICBsZXQgdDAsIHQxO1xuICByZXR1cm4gJFswXSAhPT0gZWRpdG9yIHx8ICRbMV0gIT09IG9uID8gKHQwID0gKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGVkaXRvci5vbihcIipcIiwgb24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCB0MSA9IFtlZGl0b3IsIG9uXSwgJFswXSA9IGVkaXRvciwgJFsxXSA9IG9uLCAkWzJdID0gdDAsICRbM10gPSB0MSkgOiAodDAgPSAkWzJdLCB0MSA9ICRbM10pLCB1c2VFZmZlY3QodDAsIHQxKSwgbnVsbDtcbn1cbmV4cG9ydCB7XG4gIEVkaXRvckV2ZW50TGlzdGVuZXIsXG4gIEVkaXRvclByb3ZpZGVyLFxuICBQb3J0YWJsZVRleHRFZGl0YWJsZSxcbiAgUG9ydGFibGVUZXh0RWRpdG9yLFxuICBkZWZpbmVTY2hlbWEsXG4gIGVkaXRvck1hY2hpbmUsXG4gIGRlZmF1bHRLZXlHZW5lcmF0b3IgYXMga2V5R2VuZXJhdG9yLFxuICB1c2VFZGl0b3IsXG4gIHVzZUVkaXRvclNlbGVjdG9yLFxuICB1c2VQb3J0YWJsZVRleHRFZGl0b3IsXG4gIHVzZVBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIlNjaGVtYSIsImRlZmluZVR5cGUiLCJkZWZpbmVGaWVsZCIsImlzS2V5U2VnbWVudCIsImlzUG9ydGFibGVUZXh0VGV4dEJsb2NrIiwiaXNQb3J0YWJsZVRleHRTcGFuIiwiaXNQb3J0YWJsZVRleHRTcGFuJDEiLCJpc1BvcnRhYmxlVGV4dExpc3RCbG9jayIsInN0YXJ0Q2FzZSIsImpzeCIsIkZyYWdtZW50IiwianN4cyIsInVzZVNlbGVjdG9yIiwidXNlQWN0b3JSZWYiLCJpc0VxdWFsIiwibm9vcCIsIlJlYWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJzdGFydFRyYW5zaXRpb24iLCJDb21wb25lbnQiLCJ1c2VDYWxsYmFjayIsImZvcndhcmRSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiRWRpdG9yIiwiRWxlbWVudCIsIkVsZW1lbnQkMSIsIlJhbmdlIiwiUG9pbnQiLCJUZXh0IiwiUGF0aCIsIlRyYW5zZm9ybXMiLCJPcGVyYXRpb24iLCJOb2RlIiwiY3JlYXRlRWRpdG9yIiwiY3JlYXRlRWRpdG9yJDEiLCJkZWxldGVCYWNrd2FyZCIsImRlbGV0ZUZvcndhcmQiLCJpbnNlcnRUZXh0IiwidXNlU2xhdGVTdGF0aWMiLCJSZWFjdEVkaXRvciIsInVzZVNlbGVjdGVkIiwid2l0aFJlYWN0IiwiU2xhdGUiLCJ1c2VTbGF0ZSIsIkVkaXRhYmxlIiwiZGVidWckbCIsImMiLCJzdHlsZWQiLCJ1bmlxIiwiU3ViamVjdCIsInVzZUVmZmVjdEV2ZW50Iiwic2V0dXAiLCJlbWl0IiwiYXNzaWduIiwiZnJvbUNhbGxiYWNrIiwiYXNzZXJ0RXZlbnQiLCJlbnF1ZXVlQWN0aW9ucyIsImNyZWF0ZUFjdG9yIiwidW5zZXQiLCJzZXQiLCJzZXRJZk1pc3NpbmciLCJpbnNlcnQiLCJkaWZmTWF0Y2hQYXRjaCIsImRpZmZNYXRjaFBhdGNoJDEiLCJhcHBseUFsbCIsImZsYXR0ZW4iLCJpc1BsYWluT2JqZWN0IiwiZ2V0IiwiaXNVbmRlZmluZWQiLCJvbWl0QnkiLCJjcmVhdGVHdWFyZHMiLCJibG9ja09mZnNldFRvU3BhblNlbGVjdGlvblBvaW50IiwiY29yZUJlaGF2aW9ycyIsImlzSG90a2V5IiwiZ2V0UmFuZG9tVmFsdWVzIiwiaHRtbFRvQmxvY2tzIiwibm9ybWFsaXplQmxvY2siLCJjcmVhdGVFZGl0b3JTY2hlbWEiLCJwb3J0YWJsZVRleHRUeXBlIiwiRXJyb3IiLCJibG9ja1R5cGUiLCJvZiIsImZpbmQiLCJmaW5kQmxvY2tUeXBlIiwiY2hpbGRyZW5GaWVsZCIsImZpZWxkcyIsImZpZWxkIiwibmFtZSIsIm9mVHlwZSIsInR5cGUiLCJzcGFuVHlwZSIsIm1lbWJlclR5cGUiLCJpbmxpbmVPYmplY3RUeXBlcyIsImZpbHRlciIsImJsb2NrT2JqZWN0VHlwZXMiLCJzdHlsZXMiLCJyZXNvbHZlRW5hYmxlZFN0eWxlcyIsImRlY29yYXRvcnMiLCJyZXNvbHZlRW5hYmxlZERlY29yYXRvcnMiLCJsaXN0cyIsInJlc29sdmVFbmFibGVkTGlzdEl0ZW1zIiwiYmxvY2siLCJzcGFuIiwicG9ydGFibGVUZXh0IiwiaW5saW5lT2JqZWN0cyIsImJsb2NrT2JqZWN0cyIsImFubm90YXRpb25zIiwic3R5bGVGaWVsZCIsImJ0RmllbGQiLCJ0ZXh0U3R5bGVzIiwib3B0aW9ucyIsImxpc3QiLCJzdHlsZSIsInZhbHVlIiwibGVuZ3RoIiwibGlzdEZpZWxkIiwibGlzdEl0ZW1zIiwiZGVmaW5lU2NoZW1hIiwiZGVmaW5pdGlvbiIsImNvbXBpbGVTY2hlbWFEZWZpbml0aW9uIiwibWFwIiwiYmxvY2tPYmplY3QiLCJ0aXRsZSIsImlubGluZU9iamVjdCIsInBvcnRhYmxlVGV4dFNjaGVtYSIsIm1hcmtzIiwiZGVjb3JhdG9yIiwiYW5ub3RhdGlvbiIsInNjaGVtYSIsImNvbXBpbGUiLCJ0eXBlcyIsInB0ZVNjaGVtYSIsInJvb3ROYW1lIiwiZGVidWdXaXRoTmFtZSIsIm5hbWVzcGFjZSIsImVuYWJsZWQiLCJjcmVhdGVLZXllZFBhdGgiLCJwb2ludCIsImJsb2NrUGF0aCIsInBhdGgiLCJrZXllZEJsb2NrUGF0aCIsIl9rZXkiLCJfdHlwZSIsImtleWVkQ2hpbGRQYXRoIiwiY2hpbGRQYXRoIiwic2xpY2UiLCJjaGlsZCIsIkFycmF5IiwiaXNBcnJheSIsImNoaWxkcmVuIiwidG9TbGF0ZVBhdGgiLCJlZGl0b3IiLCJmcm9tIiwibm9kZXMiLCJhdCIsIm1hdGNoIiwibiIsImlzRWxlbWVudCIsImlzVm9pZCIsImNoaWxkSW5kZXgiLCJmaW5kSW5kZXgiLCJjb25jYXQiLCJ0b1BvcnRhYmxlVGV4dFJhbmdlIiwicmFuZ2UiLCJhbmNob3IiLCJmb2N1cyIsImFuY2hvclBhdGgiLCJvZmZzZXQiLCJmb2N1c1BhdGgiLCJiYWNrd2FyZCIsImlzUmFuZ2UiLCJpc0JhY2t3YXJkIiwidG9TbGF0ZVJhbmdlIiwic2VsZWN0aW9uIiwibW92ZVJhbmdlQnlPcGVyYXRpb24iLCJvcGVyYXRpb24iLCJ0cmFuc2Zvcm0iLCJlcXVhbHMiLCJub3JtYWxpemVQb2ludCIsIm5ld1BhdGgiLCJuZXdPZmZzZXQiLCJibG9ja0tleSIsImNoaWxkS2V5IiwiYmxrIiwicHVzaCIsImNsZCIsInRleHQiLCJub3JtYWxpemVTZWxlY3Rpb24iLCJuZXdBbmNob3IiLCJuZXdGb2N1cyIsIlZPSURfQ0hJTERfS0VZIiwia2VlcE9iamVjdEVxdWFsaXR5Iiwib2JqZWN0Iiwia2V5TWFwIiwidG9TbGF0ZVZhbHVlIiwic2NoZW1hVHlwZXMiLCJyZXN0Iiwidm9pZENoaWxkcmVuIiwidGV4dEJsb2NrIiwiaGFzSW5saW5lcyIsImhhc01pc3NpbmdTdHlsZSIsImhhc01pc3NpbmdNYXJrRGVmcyIsIm1hcmtEZWZzIiwiaGFzTWlzc2luZ0NoaWxkcmVuIiwiY1R5cGUiLCJjS2V5IiwiY1Jlc3QiLCJfX2lubGluZSIsImZyb21TbGF0ZVZhbHVlIiwidGV4dEJsb2NrVHlwZSIsIl9jVHlwZSIsInYiLCJrIiwidCIsIl9pIiwiX2MiLCJibG9ja1ZhbHVlIiwiaXNFcXVhbFRvRW1wdHlFZGl0b3IiLCJpc1RleHQiLCJqb2luIiwiSVNfUFJPQ0VTU0lOR19SRU1PVEVfQ0hBTkdFUyIsIldlYWtNYXAiLCJJU19EUkFHR0lORyIsIklTX0RSQUdHSU5HX0JMT0NLX0VMRU1FTlQiLCJJU19EUkFHR0lOR19FTEVNRU5UX1RBUkdFVCIsIklTX0RSQUdHSU5HX0JMT0NLX1RBUkdFVF9QT1NJVElPTiIsIktFWV9UT19TTEFURV9FTEVNRU5UIiwiS0VZX1RPX1ZBTFVFX0VMRU1FTlQiLCJTTEFURV9UT19QT1JUQUJMRV9URVhUX1JBTkdFIiwiRGVmYXVsdE9iamVjdCIsInByb3BzIiwiJCIsInQwIiwiSlNPTiIsInN0cmluZ2lmeSIsInQxIiwiZGlzcGxheU5hbWUiLCJEZWZhdWx0QmxvY2tPYmplY3QiLCJkaXYiLCJzZWxlY3RlZCIsIkRlZmF1bHRMaXN0SXRlbSIsImdldExlZnRQb3NpdGlvbkZvckxpc3RMZXZlbCIsImxpc3RMZXZlbCIsImdldENvbnRlbnRGb3JMaXN0TGV2ZWxBbmRTdHlsZSIsImxpc3RTdHlsZSIsImdldENvdW50ZXJJbmNyZW1lbnRGb3JMaXN0TGV2ZWwiLCJnZXRDb3VudGVyUmVzZXRGb3JMaXN0TGV2ZWwiLCJnZXRDb3VudGVyQ29udGVudEZvckxpc3RMZXZlbCIsIkRlZmF1bHRMaXN0SXRlbUlubmVyIiwibGV2ZWwiLCJOdW1iZXIiLCJidWxsZXRzIiwibm9ybWFsaXplZExldmVsIiwiZGVidWckayIsIkRyYWdnYWJsZUJsb2NrIiwiZWxlbWVudCIsInJlYWRPbmx5IiwiYmxvY2tSZWYiLCJkcmFnR2hvc3RSZWYiLCJpc0RyYWdPdmVyIiwic2V0SXNEcmFnT3ZlciIsInQyIiwidDMiLCJ0NCIsImlzSW5saW5lIiwiYmxvY2tFbGVtZW50Iiwic2V0QmxvY2tFbGVtZW50IiwidDUiLCJ0NiIsImN1cnJlbnQiLCJ0b0RPTU5vZGUiLCJ0NyIsImV2ZW50IiwiaXNNeURyYWdPdmVyIiwicHJldmVudERlZmF1bHQiLCJkYXRhVHJhbnNmZXIiLCJkcm9wRWZmZWN0IiwiZWxlbWVudFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJoZWlnaHQiLCJZIiwicGFnZVkiLCJsb2MiLCJNYXRoIiwiYWJzIiwiaGFuZGxlRHJhZ092ZXIiLCJ0OCIsIlN5bWJvbCIsImZvciIsImhhbmRsZURyYWdMZWF2ZSIsInQ5IiwiZXZlbnRfMCIsInRhcmdldEJsb2NrIiwic3RvcFByb3BhZ2F0aW9uIiwiZGVsZXRlIiwiZG9jdW1lbnQiLCJib2R5IiwicmVtb3ZlQ2hpbGQiLCJkcmFnUG9zaXRpb24iLCJ0YXJnZXRQYXRoIiwiZmluZFBhdGgiLCJteVBhdGgiLCJpc0JlZm9yZSIsIm9yaWdpbmFsUGF0aCIsIm5leHQiLCJvcmlnaW5hbFBhdGhfMCIsInByZXZpb3VzIiwibW92ZU5vZGVzIiwidG8iLCJvbkNoYW5nZSIsImhhbmRsZURyYWdFbmQiLCJ0MTAiLCJldmVudF8xIiwiaGFuZGxlRHJvcCIsInQxMSIsImV2ZW50XzIiLCJ0YXJnZXQiLCJIVE1MRWxlbWVudCIsIm9wYWNpdHkiLCJoYW5kbGVEcmFnIiwidDEyIiwiZXZlbnRfMyIsInNldERhdGEiLCJlZmZlY3RBbGxvd2VkIiwiZHJhZ0dob3N0IiwiY2xvbmVOb2RlIiwiY3VzdG9tR2hvc3QiLCJxdWVyeVNlbGVjdG9yIiwic2V0QXR0cmlidXRlIiwicG9zaXRpb24iLCJsZWZ0IiwiYm94U2l6aW5nIiwiYXBwZW5kQ2hpbGQiLCJyZWN0IiwieCIsImNsaWVudFgiLCJ5IiwiY2xpZW50WSIsIndpZHRoIiwic2V0RHJhZ0ltYWdlIiwiaGFuZGxlRHJhZ1N0YXJ0IiwidDEzIiwiaXNEcmFnZ2luZ092ZXJGaXJzdEJsb2NrIiwidDE0IiwiaXNEcmFnZ2luZ092ZXJMYXN0QmxvY2siLCJkcmFnUG9zaXRpb25fMCIsImlzRHJhZ2dpbmdPdmVyVG9wIiwiaXNEcmFnZ2luZ092ZXJCb3R0b20iLCJ0MTUiLCJ0MTYiLCJjbGFzc05hbWUiLCJib3JkZXJCb3R0b20iLCJ6SW5kZXgiLCJkcm9wSW5kaWNhdG9yIiwidDE3MiIsInQxNyIsInQxOCIsInQxOSIsImRyYWdnYWJsZSIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnIiwib25EcmFnT3ZlciIsIm9uRHJhZ0xlYXZlIiwib25EcmFnRW5kIiwib25Ecm9wIiwiRU1QVFlfQU5OT1RBVElPTlMiLCJpbmxpbmVCbG9ja1N0eWxlIiwiZGlzcGxheSIsImF0dHJpYnV0ZXMiLCJyZW5kZXJCbG9jayIsInJlbmRlckNoaWxkIiwicmVuZGVyTGlzdEl0ZW0iLCJyZW5kZXJTdHlsZSIsInNwZWxsQ2hlY2siLCJpbmxpbmVCbG9ja09iamVjdFJlZiIsImZvY3VzZWQiLCJpc0NvbGxhcHNlZCIsInJlbmRlcmVkQmxvY2siLCJub2RlIiwiZGVwdGgiLCJzY2hlbWFUeXBlIiwiZWxtUGF0aCIsInJlZiIsImNvbnRlbnRFZGl0YWJsZSIsImVkaXRvckVsZW1lbnRSZWYiLCJpc0xpc3RJdGVtIiwiYmxvY2tTdHlsZVR5cGUiLCJpdGVtIiwibGlzdEl0ZW0iLCJpc0xpc3RCbG9jayIsImxpc3RUeXBlIiwiaXRlbV8wIiwicmVuZGVyUHJvcHMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25zb2xlIiwid2FybiIsInByb3BzT3JEZWZhdWx0UmVuZGVyZWQiLCJzY2hlbWFUeXBlXzAiLCJfdHlwZV8wIiwiYmxvY2tfMCIsInJlbmRlcmVkQmxvY2tGcm9tUHJvcHMiLCJfcHJvcHMiLCJQb3J0YWJsZVRleHRFZGl0b3JDb250ZXh0IiwidXNlUG9ydGFibGVUZXh0RWRpdG9yIiwiRGVmYXVsdEFubm90YXRpb24iLCJhbGVydCIsImhhbmRsZUNsaWNrIiwiY29sb3IiLCJvbkNsaWNrIiwiY29tcGlsZVR5cGUiLCJyYXdUeXBlIiwiRkxVU0hfUEFUQ0hFU19USFJPVFRMRURfTVMiLCJwcm9jZXNzIiwibXV0YXRpb25NYWNoaW5lIiwiY29udGV4dCIsImV2ZW50cyIsImlucHV0IiwiZW1pdHRlZCIsImFjdGlvbnMiLCJwYXRjaGVzIiwicGVuZGluZ1BhdGNoZXMiLCJzbmFwc2hvdCIsInNsYXRlRWRpdG9yIiwicGF0Y2giLCJndWFyZHMiLCJpc05vcm1hbGl6aW5nIiwiY3JlYXRlTWFjaGluZSIsImlkIiwiaW5pdGlhbCIsInN0YXRlcyIsImlkbGUiLCJvbiIsImFmdGVyIiwiZ3VhcmQiLCJyZWVudGVyIiwidmFsaWRhdGVWYWx1ZSIsImtleUdlbmVyYXRvciIsInJlc29sdXRpb24iLCJ2YWxpZCIsInZhbGlkQ2hpbGRUeXBlcyIsInZhbGlkQmxvY2tUeXBlcyIsImRlc2NyaXB0aW9uIiwiYWN0aW9uIiwiaTE4biIsInNvbWUiLCJpbmRleCIsIlN0cmluZyIsInZhbHVlcyIsImluY2x1ZGVzIiwiY3VycmVudEJsb2NrVHlwZU5hbWUiLCJrZXkiLCJleHBlY3RlZFR5cGVOYW1lIiwidHlwZU5hbWUiLCJuZXdTcGFuIiwiYXV0b1Jlc29sdmUiLCJhbGxVc2VkTWFya3MiLCJ1bnVzZWRNYXJrRGVmcyIsImRlZiIsIm1hcmtEZWZLZXkiLCJtIiwidG9TdHJpbmciLCJvcnBoYW5lZE1hcmtzIiwibWFyayIsImRlYyIsInNwYW5DaGlsZHJlbiIsIm9ycGhhbmVkIiwiY01yayIsImNJbmRleCIsIm5ld0NoaWxkIiwiY2hpbGRUeXBlIiwid2l0aFJlbW90ZUNoYW5nZXMiLCJmbiIsInByZXYiLCJpc0NoYW5naW5nUmVtb3RlbHkiLCJQQVRDSElORyIsIndpdGhvdXRQYXRjaGluZyIsImlzUGF0Y2hpbmciLCJjbG9uZURpZmYiLCJkaWZmMiIsImdldENvbW1vbk92ZXJsYXAiLCJ0ZXh0QSIsInRleHRCIiwidGV4dDEiLCJ0ZXh0MiIsInRleHQxTGVuZ3RoIiwidGV4dDJMZW5ndGgiLCJzdWJzdHJpbmciLCJ0ZXh0TGVuZ3RoIiwibWluIiwiYmVzdCIsImZvdW5kIiwicGF0dGVybiIsImluZGV4T2YiLCJnZXRDb21tb25QcmVmaXgiLCJwb2ludGVyTWluIiwicG9pbnRlck1heCIsInBvaW50ZXJNaWQiLCJwb2ludGVyU3RhcnQiLCJmbG9vciIsImdldENvbW1vblN1ZmZpeCIsInBvaW50ZXJFbmQiLCJpc0hpZ2hTdXJyb2dhdGUiLCJjaGFyIiwiY2hhckNvZGUiLCJjaGFyQ29kZUF0IiwiaXNMb3dTdXJyb2dhdGUiLCJiaXNlY3QiLCJkZWFkbGluZSIsIm1heEQiLCJjZWlsIiwidk9mZnNldCIsInZMZW5ndGgiLCJ2MSIsInYyIiwiZGVsdGEiLCJmcm9udCIsImsxc3RhcnQiLCJrMWVuZCIsImsyc3RhcnQiLCJrMmVuZCIsImQiLCJEYXRlIiwibm93IiwiazEiLCJrMU9mZnNldCIsIngxIiwieTEiLCJjaGFyQXQiLCJrMk9mZnNldCIsIngyIiwiYmlzZWN0U3BsaXQiLCJrMiIsInkyIiwiRElGRl9ERUxFVEUiLCJESUZGX0lOU0VSVCIsInRleHQxYSIsInRleHQyYSIsInRleHQxYiIsInRleHQyYiIsImRpZmZzIiwiZG9EaWZmIiwiY2hlY2tMaW5lcyIsImRpZmZzYiIsImZpbmRIYWxmTWF0Y2giLCJ0aW1lb3V0IiwibG9uZ1RleHQiLCJzaG9ydFRleHQiLCJoYWxmTWF0Y2gxIiwiaGFsZk1hdGNoSSIsImhhbGZNYXRjaDIiLCJoYWxmTWF0Y2giLCJ0ZXh0MUEiLCJ0ZXh0MUIiLCJ0ZXh0MkEiLCJ0ZXh0MkIiLCJtaWRDb21tb24iLCJpIiwic2VlZCIsImoiLCJiZXN0Q29tbW9uIiwiYmVzdExvbmdUZXh0QSIsImJlc3RMb25nVGV4dEIiLCJiZXN0U2hvcnRUZXh0QSIsImJlc3RTaG9ydFRleHRCIiwicHJlZml4TGVuZ3RoIiwic3VmZml4TGVuZ3RoIiwiY2hhcnNUb0xpbmVzIiwibGluZUFycmF5IiwiY2hhcnMiLCJsaW5lc1RvQ2hhcnMiLCJsaW5lSGFzaCIsImRpZmZMaW5lc1RvTXVuZ2UiLCJsaW5lU3RhcnQiLCJsaW5lRW5kIiwibGluZUFycmF5TGVuZ3RoIiwibGluZSIsImhhc093blByb3BlcnR5IiwiZnJvbUNoYXJDb2RlIiwibWF4TGluZXMiLCJjaGFyczEiLCJjaGFyczIiLCJkb0xpbmVNb2RlRGlmZiIsIm9wdHMiLCJhIiwibGluZWFycmF5IiwiY2xlYW51cFNlbWFudGljIiwiRElGRl9FUVVBTCIsInBvaW50ZXIiLCJjb3VudERlbGV0ZSIsImNvdW50SW5zZXJ0IiwidGV4dERlbGV0ZSIsInRleHRJbnNlcnQiLCJzcGxpY2UiLCJhYSIsInBvcCIsImNvbXB1dGVEaWZmIiwibG9uZ3RleHQiLCJzaG9ydHRleHQiLCJkaWZmc0EiLCJkaWZmc0IiLCJfX2RlZlByb3AkMiIsIl9fZ2V0T3duUHJvcFN5bWJvbHMkMiIsImdldE93blByb3BlcnR5U3ltYm9scyIsIl9faGFzT3duUHJvcCQyIiwicHJvdG90eXBlIiwiX19wcm9wSXNFbnVtJDIiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCQyIiwib2JqIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3NwcmVhZFZhbHVlcyQyIiwiYiIsInByb3AiLCJjYWxsIiwiZGlmZiIsImNyZWF0ZUludGVybmFsT3B0cyIsImFkanVzdERpZmZGb3JTdXJyb2dhdGVQYWlycyIsImNvbW1vbmxlbmd0aCIsImNvbW1vbnByZWZpeCIsImNvbW1vbnN1ZmZpeCIsInVuc2hpZnQiLCJjbGVhbnVwTWVyZ2UiLCJjcmVhdGVEZWFkTGluZSIsIk1BWF9WQUxVRSIsImNvbWJpbmVDaGFyIiwiZGF0YSIsImRpciIsInNwbGl0Q2hhciIsImhhc1NoYXJlZENoYXIiLCJkZWlzb2xhdGVDaGFyIiwiaW52IiwiaW5zZXJ0SWR4IiwiZGVsZXRlSWR4Iiwib3AiLCJjaGFyMiIsImluc2VydFRleHQyIiwiaW5zZXJ0Q2hhciIsImRlbGV0ZVRleHQiLCJkaWZmVHlwZSIsImRpZmZUZXh0IiwiZmlyc3RDaGFyIiwibGFzdENoYXIiLCJyYXdEaWZmcyIsImhhc0NoYW5nZXMiLCJlcXVhbGl0aWVzIiwiZXF1YWxpdGllc0xlbmd0aCIsImxhc3RFcXVhbGl0eSIsImxlbmd0aEluc2VydGlvbnMxIiwibGVuZ3RoRGVsZXRpb25zMSIsImxlbmd0aEluc2VydGlvbnMyIiwibGVuZ3RoRGVsZXRpb25zMiIsIm1heCIsImNsZWFudXBTZW1hbnRpY0xvc3NsZXNzIiwiZGVsZXRpb24iLCJpbnNlcnRpb24iLCJvdmVybGFwTGVuZ3RoMSIsIm92ZXJsYXBMZW5ndGgyIiwibm9uQWxwaGFOdW1lcmljUmVnZXgiLCJ3aGl0ZXNwYWNlUmVnZXgiLCJsaW5lYnJlYWtSZWdleCIsImJsYW5rbGluZUVuZFJlZ2V4IiwiYmxhbmtsaW5lU3RhcnRSZWdleCIsImRpZmZDbGVhbnVwU2VtYW50aWNTY29yZSIsIm9uZSIsInR3byIsImNoYXIxIiwibm9uQWxwaGFOdW1lcmljMSIsIm5vbkFscGhhTnVtZXJpYzIiLCJ3aGl0ZXNwYWNlMSIsIndoaXRlc3BhY2UyIiwibGluZUJyZWFrMSIsImxpbmVCcmVhazIiLCJibGFua0xpbmUxIiwiYmxhbmtMaW5lMiIsImVxdWFsaXR5MSIsImVkaXQiLCJlcXVhbGl0eTIiLCJjb21tb25PZmZzZXQiLCJjb21tb25TdHJpbmciLCJiZXN0RXF1YWxpdHkxIiwiYmVzdEVkaXQiLCJiZXN0RXF1YWxpdHkyIiwiYmVzdFNjb3JlIiwic2NvcmUiLCJ0cnVlQ291bnQiLCJhcmdzIiwicmVkdWNlIiwiYm9vbCIsImNsZWFudXBFZmZpY2llbmN5IiwiZWRpdENvc3QiLCJwcmVJbnMiLCJwcmVEZWwiLCJwb3N0SW5zIiwicG9zdERlbCIsIl9fZGVmUHJvcCQxIiwiX19nZXRPd25Qcm9wU3ltYm9scyQxIiwiX19oYXNPd25Qcm9wJDEiLCJfX3Byb3BJc0VudW0kMSIsIl9fZGVmTm9ybWFsUHJvcCQxIiwiX19zcHJlYWRWYWx1ZXMkMSIsIkRFRkFVTFRfT1BUSU9OUyIsInRocmVzaG9sZCIsImRpc3RhbmNlIiwiYXBwbHlEZWZhdWx0cyIsIk1BWF9CSVRTJDEiLCJiaXRhcCIsInMiLCJnZXRBbHBoYWJldEZyb21QYXR0ZXJuIiwiZ2V0Qml0YXBTY29yZSIsImUiLCJhY2N1cmFjeSIsInByb3hpbWl0eSIsInNjb3JlVGhyZXNob2xkIiwiYmVzdExvYyIsImxhc3RJbmRleE9mIiwibWF0Y2htYXNrIiwiYmluTWluIiwiYmluTWlkIiwiYmluTWF4IiwibGFzdFJkIiwic3RhcnQiLCJmaW5pc2giLCJyZCIsImNoYXJNYXRjaCIsInNlYXJjaExvY2F0aW9uIiwiZGlmZlRleHQxIiwiZGlmZlRleHQyIiwibGV2ZW5zaHRlaW4iLCJsZXZlbiIsImluc2VydGlvbnMiLCJkZWxldGlvbnMiLCJ4SW5kZXgiLCJsYXN0Q2hhcnMxIiwibGFzdENoYXJzMiIsImNvdW50VXRmOEJ5dGVzIiwic3RyIiwiYnl0ZXMiLCJjb2RlUG9pbnQiLCJjb2RlUG9pbnRBdCIsInV0ZjhsZW4iLCJhZGp1c3RJbmRpY2llc1RvVWNzMiIsImJhc2UiLCJieXRlT2Zmc2V0IiwiaWR4IiwiYWR2YW5jZVRvIiwiYWxsb3dFeGNlZWRpbmdJbmRpY2VzIiwiYWRqdXN0ZWQiLCJzdGFydDEiLCJzdGFydDIiLCJ1dGY4U3RhcnQxIiwidXRmOFN0YXJ0MiIsImxlbmd0aDEiLCJsZW5ndGgyIiwidXRmOExlbmd0aDEiLCJ1dGY4TGVuZ3RoMiIsIk1BWF9CSVRTIiwiREVGQVVMVF9NQVJHSU4iLCJhZGRQYWRkaW5nIiwibWFyZ2luIiwicGFkZGluZ0xlbmd0aCIsIm51bGxQYWRkaW5nIiwicCIsImZpcnN0RGlmZkxlbmd0aCIsImV4dHJhTGVuZ3RoIiwiY3JlYXRlUGF0Y2hPYmplY3QiLCJzcGxpdE1heCIsInBhdGNoU2l6ZSIsImJpZ3BhdGNoIiwicHJlQ29udGV4dCIsImVtcHR5IiwicHJlY29udGV4dEJ5dGVDb3VudCIsImRpZmZUZXh0Qnl0ZUNvdW50Iiwic2hpZnQiLCJwb3N0Q29udGV4dCIsInBvc3RDb250ZXh0Qnl0ZUNvdW50IiwiYXBwbHkiLCJvcmlnaW5hbFRleHQiLCJwYXJzZWQiLCJkZWxldGVUaHJlc2hvbGQiLCJyZXN1bHRzIiwiZXhwZWN0ZWRMb2MiLCJzdGFydExvYyIsImVuZExvYyIsImluZGV4MSIsImluZGV4MiIsIm1vZCIsInBhdGNoSGVhZGVyIiwicGFyc2UiLCJ0ZXh0bGluZSIsImxpbmVzIiwic3BsaXQiLCJ0ZXh0UG9pbnRlciIsInRvSW50IiwiY3VycmVudExpbmUiLCJzaWduIiwiZGVjb2RlVVJJIiwidXRmOERpZmYiLCJudW0iLCJwYXJzZUludCIsIklTX1VET0lORyIsIklTX1JFRE9JTkciLCJ3aXRoVW5kb2luZyIsImlzVW5kb2luZyIsInNldElzVW5kb2luZyIsImlzVW5kb2luZzIiLCJ3aXRoUmVkb2luZyIsImlzUmVkb2luZyIsInNldElzUmVkb2luZyIsImlzUmVkb2luZzIiLCJkZWJ1ZyRqIiwiZGVidWdWZXJib3NlJDMiLCJTQVZJTkciLCJSRU1PVEVfUEFUQ0hFUyIsIlVORE9fU1RFUF9MSU1JVCIsImlzU2F2aW5nIiwic3RhdGUiLCJnZXRSZW1vdGVQYXRjaGVzIiwiY3JlYXRlV2l0aFVuZG9SZWRvIiwiZWRpdG9yQWN0b3IiLCJibG9ja1NjaGVtYVR5cGUiLCJwcmV2aW91c1NuYXBzaG90IiwicmVtb3RlUGF0Y2hlcyIsInN1YnNjcmlwdGlvbnMiLCJzdWIiLCJyZXNldCIsImZvckVhY2giLCJvcmlnaW4iLCJoaXN0b3J5IiwidW5kb3MiLCJyZWRvcyIsInRpbWUiLCJ1bnN1YnNjcmliZSIsImFwcGx5MiIsImdldFNuYXBzaG90IiwibWF0Y2hlcyIsIm9wZXJhdGlvbnMiLCJzdGVwIiwibGFzdE9wIiwib3ZlcndyaXRlIiwic2hvdWxkT3ZlcndyaXRlIiwic2F2ZSIsIm1lcmdlIiwic2hvdWxkTWVyZ2UiLCJuZXdTdGVwIiwiY3JlYXRlU2VsZWN0T3BlcmF0aW9uIiwidGltZXN0YW1wIiwic2hvdWxkQ2xlYXIiLCJ1bmRvIiwib3RoZXJQYXRjaGVzIiwidHJhbnNmb3JtZWRPcGVyYXRpb25zIiwidHJhbnNmb3JtT3BlcmF0aW9uIiwicmV2ZXJzZWRPcGVyYXRpb25zIiwiaW52ZXJzZSIsInJldmVyc2UiLCJ3aXRob3V0Tm9ybWFsaXppbmciLCJ3aXRob3V0U2F2aW5nIiwibm9ybWFsaXplIiwiZXJyIiwiZGVzZWxlY3QiLCJyZWRvIiwidHJhbnNmb3JtZWRPcGVyYXRpb24iLCJpbnNlcnRCbG9ja0luZGV4IiwiaXRlbXMiLCJhZGp1c3RCbG9ja1BhdGgiLCJ1bnNldEJsb2NrSW5kZXgiLCJvcGVyYXRpb25UYXJnZXRCbG9jayIsImZpbmRPcGVyYXRpb25UYXJnZXRCbG9jayIsImRpZmZQYXRjaCIsImFkanVzdE9mZnNldEJ5IiwiY2hhbmdlZE9mZnNldCIsImV2ZXJ5IiwiZFR5cGUiLCJjdXJyZW50Rm9jdXMiLCJwcm9wZXJ0aWVzIiwiY3VycmVudEFuY2hvciIsIm5ld1Byb3BlcnRpZXMiLCJibG9ja0luZGV4Iiwic3luY1ZhbHVlQ2FsbGJhY2siLCJzZW5kQmFjayIsInVwZGF0ZVZhbHVlIiwic3RyZWFtQmxvY2tzIiwic3luY1ZhbHVlTG9naWMiLCJzeW5jTWFjaGluZSIsImluaXRpYWxWYWx1ZVN5bmNlZCIsInBlbmRpbmdWYWx1ZSIsInByZXZpb3VzVmFsdWUiLCJpc1Byb2Nlc3NpbmdMb2NhbENoYW5nZXMiLCJhY3RvcnMiLCJtdXRhdGlvbiIsImFsd2F5cyIsImVudHJ5Iiwic3luY2luZyIsImJ1c3kiLCJpbnZva2UiLCJzcmMiLCJkZWJ1ZyRpIiwiaXNDaGFuZ2VkIiwiaXNWYWxpZCIsImhhZFNlbGVjdGlvbiIsImNoaWxkcmVuTGVuZ3RoIiwiXyIsInJlbW92ZU5vZGVzIiwiaW5zZXJ0Tm9kZXMiLCJwdGVDcmVhdGVUZXh0QmxvY2siLCJzZWxlY3QiLCJzbGF0ZVZhbHVlRnJvbVByb3BzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjdXJyZW50QmxvY2siLCJjdXJyZW50QmxvY2tJbmRleCIsImdldEJsb2NrcyIsInNsYXRlVmFsdWUiLCJibG9ja0NoYW5nZWQiLCJibG9ja1ZhbGlkIiwic3luY0Jsb2NrIiwiZXJyb3IiLCJzZXRUaW1lb3V0Iiwib2xkQmxvY2siLCJ2YWxpZGF0aW9uVmFsdWUiLCJ2YWxpZGF0aW9uIiwiX3VwZGF0ZUJsb2NrIiwiX3JlcGxhY2VCbG9jayIsImN1cnJlbnRTZWxlY3Rpb24iLCJzZWxlY3Rpb25Gb2N1c09uQmxvY2siLCJzZXROb2RlcyIsImlzVGV4dEJsb2NrIiwib2xkQmxvY2tDaGlsZHJlbkxlbmd0aCIsImN1cnJlbnRCbG9ja0NoaWxkIiwiY3VycmVudEJsb2NrQ2hpbGRJbmRleCIsIm9sZEJsb2NrQ2hpbGQiLCJpc0NoaWxkQ2hhbmdlZCIsImlzVGV4dENoYW5nZWQiLCJpc1NwYW5Ob2RlIiwidm9pZHMiLCJkZWJ1ZyRoIiwiU3luY2hyb25pemVyIiwiX3RlbXAiLCJfdGVtcDIiLCJzeW5jQWN0b3JSZWYiLCJtdXRhdGlvbkFjdG9yUmVmIiwic3Vic2NyaXB0aW9uIiwic2VuZCIsInN1YnNjcmlwdGlvbl8wIiwic18wIiwiZGVidWckZyIsImNyZWF0ZU9wZXJhdGlvblRvUGF0Y2hlcyIsInRleHRCbG9ja05hbWUiLCJpbnNlcnRUZXh0UGF0Y2giLCJiZWZvcmVWYWx1ZSIsInRleHRDaGlsZCIsImlzVGV4dFNwYW4iLCJwcmV2QmxvY2siLCJwcmV2Q2hpbGQiLCJwcmV2VGV4dCIsInJlbW92ZVRleHRQYXRjaCIsImJlZm9yZUJsb2NrIiwicHJldlRleHRDaGlsZCIsInNldE5vZGVQYXRjaCIsInNldE5vZGUiLCJrZXlzIiwia2V5TmFtZSIsInZhbCIsImluc2VydE5vZGVQYXRjaCIsInRhcmdldEtleSIsInNwbGl0Tm9kZVBhdGNoIiwic3BsaXRCbG9jayIsInRhcmdldFZhbHVlIiwic3BsaXRTcGFuIiwidGFyZ2V0U3BhbnMiLCJyZW1vdmVOb2RlUGF0Y2giLCJzcGFuVG9SZW1vdmUiLCJtZXJnZU5vZGVQYXRjaCIsInVwZGF0ZWRCbG9jayIsIm5ld0Jsb2NrIiwidXBkYXRlZFNwYW4iLCJyZW1vdmVkU3BhbiIsIm1vdmVOb2RlUGF0Y2giLCJ0YXJnZXRDaGlsZCIsImNoaWxkVG9JbnNlcnQiLCJjcmVhdGVXaXRoRXZlbnRMaXN0ZW5lcnMiLCJtYXhCbG9ja3MiLCJiZWhhdmlvckV2ZW50IiwicGxhY2VtZW50IiwiYWRkTWFyayIsInJlbW92ZU1hcmsiLCJ1bml0IiwiaW5zZXJ0QnJlYWsiLCJpbnNlcnRTb2Z0QnJlYWsiLCJjcmVhdGVXaXRoTWF4QmxvY2tzIiwicm93cyIsImNyZWF0ZVdpdGhPYmplY3RLZXlzIiwibm9ybWFsaXplTm9kZSIsImlzRWRpdG9yIiwiZGVidWckZiIsImRlYnVnVmVyYm9zZSQyIiwiY3JlYXRlQXBwbHlQYXRjaCIsImNoYW5nZWQiLCJpbnNlcnRQYXRjaCIsInVuc2V0UGF0Y2giLCJzZXRQYXRjaCIsImZpbmRCbG9ja0FuZENoaWxkRnJvbVBhdGgiLCJuZXdWYWx1ZSIsImRpZmYkMSIsImRlYnVnU3RhdGUiLCJ0YXJnZXRCbG9ja1BhdGgiLCJ0YXJnZXRDaGlsZFBhdGgiLCJpdGVtczIiLCJwb3NpdGlvbjIiLCJibG9ja3NUb0luc2VydCIsInRhcmdldEJsb2NrSW5kZXgiLCJub3JtYWxpemVkSWR4MiIsImNoaWxkcmVuVG9JbnNlcnQiLCJ0YXJnZXRDaGlsZEluZGV4Iiwibm9ybWFsaXplZElkeCIsImNoaWxkSW5zZXJ0UGF0aCIsIm5ld1RleHQiLCJuZXh0UmVzdCIsInByZXZDaGlsZHJlbiIsInByZXZSZXN0IiwiYzIiLCJuZXdWYWwiLCJwcmV2aW91c1NlbGVjdGlvbiIsIl9jaGlsZCIsImlzS2V5ZWRTZWdtZW50Iiwic2VnbWVudCIsInN0YXRlTmFtZSIsImZpbmRCbG9ja0Zyb21QYXRoIiwiaXNNYXRjaCIsImRlYnVnJGUiLCJjcmVhdGVXaXRoUGF0Y2hlcyIsInBhdGNoRnVuY3Rpb25zIiwicHJldmlvdXNDaGlsZHJlbiIsImFwcGx5UGF0Y2giLCJidWZmZXJlZFBhdGNoZXMiLCJoYW5kbGVCdWZmZXJlZFJlbW90ZVBhdGNoZXMiLCJoYW5kbGVQYXRjaGVzIiwiZWRpdG9yV2FzRW1wdHkiLCJlZGl0b3JJc0VtcHR5IiwiZGVidWckZCIsImNyZWF0ZVdpdGhQbGFjZWhvbGRlckJsb2NrIiwibmV4dFBhdGgiLCJpbnNlcnROb2RlIiwiZGVidWckYyIsImNyZWF0ZVdpdGhQb3J0YWJsZVRleHRCbG9ja1N0eWxlIiwiZGVmYXVsdFN0eWxlIiwibm9kZUVudHJ5IiwiaXNQb3J0YWJsZVRleHRCbG9jayIsImdldFByZXZpb3VzU3BhbiIsInNwYW5QYXRoIiwicHJldmlvdXNTcGFuIiwiZ2V0TmV4dFNwYW4iLCJuZXh0U3BhbiIsImlzQWZ0ZXIiLCJkZWJ1ZyRiIiwiY3JlYXRlV2l0aFBvcnRhYmxlVGV4dE1hcmtNb2RlbCIsIm5leHROb2RlIiwibWVyZ2VOb2RlcyIsInBhcmVudCIsImRlY29yYXRvcnMyIiwib3JwaGFuZWRBbm5vdGF0aW9ucyIsIm1hcmtEZWZLZXlzIiwiU2V0IiwibmV3TWFya0RlZnMiLCJtYXJrRGVmIiwiaGFzIiwiYWRkIiwicHJldmlvdXNTZWxlY3Rpb25Jc0NvbGxhcHNlZCIsIm5ld1NlbGVjdGlvbklzQ29sbGFwc2VkIiwiZm9jdXNTcGFuIiwibW9kZSIsIm5ld0ZvY3VzU3BhbiIsIm1vdmVkVG9OZXh0U3BhbiIsIm1vdmVkVG9QcmV2aW91c1NwYW4iLCJfYmxvY2siLCJwcmV2aW91c1NwYW5Bbm5vdGF0aW9ucyIsIm5leHRTcGFuQW5ub3RhdGlvbnMiLCJhbm5vdGF0aW9uc0VuZGluZyIsImF0VGhlRW5kT2ZBbm5vdGF0aW9uIiwiYW5ub3RhdGlvbnNTdGFydGluZyIsImF0VGhlU3RhcnRPZkFubm90YXRpb24iLCJuZXh0U3BhbkRlY29yYXRvcnMiLCJjb2xsYXBzZWRTZWxlY3Rpb24iLCJtYXJrc1dpdGhvdXRBbm5vdGF0aW9ucyIsInNwYW5IYXNBbm5vdGF0aW9ucyIsInNwYW5Jc0VtcHR5IiwiYXRUaGVCZWdpbm5pbmdPZlNwYW4iLCJhdFRoZUVuZE9mU3BhbiIsInNwYW5Bbm5vdGF0aW9ucyIsInByZXZpb3VzU3Bhbkhhc0Fubm90YXRpb25zIiwicHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb25zIiwicHJldmlvdXNTcGFuSGFzU2FtZUFubm90YXRpb24iLCJwcmV2aW91c1NwYW5IYXNTYW1lTWFya3MiLCJuZXh0U3BhblNoYXJlc1NvbWVBbm5vdGF0aW9ucyIsImlzRXhwYW5kZWQiLCJkZWxldGluZ0Zyb21UaGVFbmQiLCJkZWxldGluZ0FsbFRleHQiLCJuZXh0U3Bhbkhhc1NhbWVBbm5vdGF0aW9uIiwibWFya3NXaXRob3V0QW5ub3RhdGlvbk1hcmtzIiwib2xkRGVmcyIsImFkZERlY29yYXRvckFjdGlvbkltcGxlbWVudGF0aW9uIiwiaGFuZ2luZyIsInNwbGl0VGV4dE5vZGVzIiwiZU1hcmsiLCJsb25lbHlFbXB0eVNwYW4iLCJleGlzdGluZ01hcmtzIiwiZXhpc3RpbmdNYXJrc1dpdGhvdXREZWNvcmF0b3IiLCJleGlzdGluZ01hcmsiLCJyZW1vdmVEZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbiIsImlzRGVjb3JhdG9yQWN0aXZlIiwic2VsZWN0ZWRUZXh0Tm9kZXMiLCJ0b2dnbGVEZWNvcmF0b3JBY3Rpb25JbXBsZW1lbnRhdGlvbiIsImRlYnVnJGEiLCJkZWJ1Z1ZlcmJvc2UkMSIsImNyZWF0ZVdpdGhQb3J0YWJsZVRleHRTZWxlY3Rpb25zIiwicHJldlNlbGVjdGlvbiIsImVtaXRQb3J0YWJsZVRleHRTZWxlY3Rpb24iLCJwdFJhbmdlIiwiZXhpc3RpbmciLCJkZWJ1ZyQ5IiwiY3JlYXRlV2l0aFNjaGVtYVR5cGVzIiwiZGVidWckOCIsImNyZWF0ZVdpdGhVdGlscyIsInB0ZUV4cGFuZFRvV29yZCIsInRleHROb2RlIiwiZm9jdXNPZmZzZXQiLCJjaGFyc0JlZm9yZSIsImNoYXJzQWZ0ZXIiLCJpc0VtcHR5Iiwid2hpdGVTcGFjZUJlZm9yZUluZGV4IiwibmV3U3RhcnRPZmZzZXQiLCJ3aGl0ZVNwYWNlQWZ0ZXJJbmRleCIsIm5ld0VuZE9mZnNldCIsImlzTmFOIiwic2V0U2VsZWN0aW9uIiwid2l0aFBsdWdpbnMiLCJvcGVyYXRpb25Ub1BhdGNoZXMiLCJ3aXRoT2JqZWN0S2V5cyIsIndpdGhTY2hlbWFUeXBlcyIsIndpdGhQYXRjaGVzIiwid2l0aE1heEJsb2NrcyIsIndpdGhVbmRvUmVkbyIsIndpdGhQb3J0YWJsZVRleHRNYXJrTW9kZWwiLCJ3aXRoUG9ydGFibGVUZXh0QmxvY2tTdHlsZSIsIndpdGhQbGFjZWhvbGRlckJsb2NrIiwid2l0aFV0aWxzIiwid2l0aFBvcnRhYmxlVGV4dFNlbGVjdGlvbnMiLCJkZWJ1ZyQ3Iiwic2xhdGVFZGl0b3JzIiwiY3JlYXRlU2xhdGVFZGl0b3IiLCJjb25maWciLCJleGlzdGluZ1NsYXRlRWRpdG9yIiwidW5zdWJzY3JpcHRpb25zIiwiaW5zdGFuY2UiLCJpbml0aWFsVmFsdWUiLCJ0b2dnbGVMaXN0SXRlbUFjdGlvbkltcGxlbWVudGF0aW9uIiwiaXNMaXN0SXRlbUFjdGl2ZSIsInJlbW92ZUxpc3RJdGVtQWN0aW9uSW1wbGVtZW50YXRpb24iLCJhZGRMaXN0SXRlbUFjdGlvbkltcGxlbWVudGF0aW9uIiwic2VsZWN0ZWRCbG9ja3MiLCJ1bnNldE5vZGVzIiwidG9nZ2xlU3R5bGVBY3Rpb25JbXBsZW1lbnRhdGlvbiIsImlzU3R5bGVBY3RpdmUiLCJyZW1vdmVTdHlsZUFjdGlvbkltcGxlbWVudGF0aW9uIiwiYWRkU3R5bGVBY3Rpb25JbXBsZW1lbnRhdGlvbiIsImRlYnVnJDYiLCJjcmVhdGVFZGl0YWJsZUFQSSIsImJsdXIiLCJ0b2dnbGVNYXJrIiwidG9nZ2xlTGlzdCIsInRvZ2dsZUJsb2NrU3R5bGUiLCJpc01hcmtBY3RpdmUiLCJzbGF0ZVNlbGVjdGlvbiIsImZvY3VzQmxvY2siLCJkZXNjZW5kYW50IiwiZm9jdXNDaGlsZCIsImluc2VydENoaWxkIiwiZm9jdXNDaGlsZFBhdGgiLCJmb2N1c05vZGUiLCJtb3ZlIiwiaW5zZXJ0QmxvY2siLCJoYXNCbG9ja1N0eWxlIiwiaGFzTGlzdFN0eWxlIiwiZmluZEJ5UGF0aCIsInNsYXRlUGF0aCIsInB0QmxvY2siLCJwdENoaWxkIiwiZmluZERPTU5vZGUiLCJhY3RpdmVBbm5vdGF0aW9ucyIsInNwYW5zIiwiaXNBbm5vdGF0aW9uQWN0aXZlIiwiYW5ub3RhdGlvblR5cGUiLCJhZGRBbm5vdGF0aW9uIiwicGF0aHMiLCJhZGRBbm5vdGF0aW9uQWN0aW9uSW1wbGVtZW50YXRpb24iLCJyZW1vdmVBbm5vdGF0aW9uIiwiZ2V0U2VsZWN0aW9uIiwiZ2V0VmFsdWUiLCJpc0NvbGxhcHNlZFNlbGVjdGlvbiIsImlzRXhwYW5kZWRTZWxlY3Rpb24iLCJnZXRGcmFnbWVudCIsImlzU2VsZWN0aW9uc092ZXJsYXBwaW5nIiwic2VsZWN0aW9uQSIsInNlbGVjdGlvbkIiLCJyYW5nZUEiLCJyYW5nZUIiLCJzZWxlY3Rpb25NYXJrRGVmcyIsImFjY01hcmtEZWZzIiwibWFya0tleSIsIm9yaWdpbmFsU2VsZWN0aW9uIiwibWFya0RlZlBhdGgiLCJtYXJrRGVmUGF0aHMiLCJhbm5vdGF0aW9uS2V5IiwiZXhpc3RpbmdTYW1lVHlwZUFubm90YXRpb25zIiwicmVtb3ZlQW5ub3RhdGlvbkFjdGlvbkltcGxlbWVudGF0aW9uIiwicG90ZW50aWFsQW5ub3RhdGlvbnMiLCJzZWxlY3RlZENoaWxkIiwic2VsZWN0ZWRDaGlsZFBhdGgiLCJhbm5vdGF0aW9uVG9SZW1vdmUiLCJwcmV2aW91c1NwYW5zV2l0aFNhbWVBbm5vdGF0aW9uIiwibmV4dFNwYW5zV2l0aFNhbWVBbm5vdGF0aW9uIiwiYmxvY2tzIiwibWFya3NXaXRob3V0QW5ub3RhdGlvbiIsIm1hcmtEZWYyIiwidG9nZ2xlQW5ub3RhdGlvbkFjdGlvbkltcGxlbWVudGF0aW9uIiwiZm9jdXNCbG9ja1BhdGgiLCJsYXN0QmxvY2siLCJpbnNlcnRCbG9ja09iamVjdEFjdGlvbkltcGxlbWVudGF0aW9uIiwiaW5zZXJ0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbiIsImZvY3VzRGVjb3JhdG9ycyIsImZvY3VzQW5ub3RhdGlvbnMiLCJhbmNob3JCbG9ja1BhdGgiLCJlbmQiLCJlZGdlcyIsImxhc3RGb2N1c0Jsb2NrQ2hpbGQiLCJhdFRoZUVuZE9mQmxvY2siLCJhdFRoZVN0YXJ0T2ZCbG9jayIsIm5leHRCbG9ja1BhdGgiLCJzZWxlY3Rpb25BY3Jvc3NCbG9ja3MiLCJzcGxpdE5vZGVzIiwibmV4dE5vZGVQYXRoIiwibmV3TWFya0RlZktleXMiLCJNYXAiLCJwcmV2Tm9kZVNwYW5zIiwicHJldk5vZGVTcGFuIiwibmV3TWFya3MiLCJpbnNlcnRTb2Z0QnJlYWtBY3Rpb25JbXBsZW1lbnRhdGlvbiIsImluc2VydElubGluZU9iamVjdEFjdGlvbkltcGxlbWVudGF0aW9uIiwiZm9jdXNUZXh0QmxvY2siLCJpbnNlcnRTcGFuQWN0aW9uSW1wbGVtZW50YXRpb24iLCJ0ZXh0QmxvY2tTZXRBY3Rpb25JbXBsZW1lbnRhdGlvbiIsInRleHRCbG9ja1Vuc2V0QWN0aW9uSW1wbGVtZW50YXRpb24iLCJiZWhhdmlvckFjdGlvbkltcGxlbWVudGF0aW9ucyIsImJsb2NrT2Zmc2V0IiwiZWZmZWN0IiwiaGFzUHJldmlvdXMiLCJuZXdTZWxlY3Rpb24iLCJwcmV2aW91c0Jsb2NrUGF0aCIsInJlc2VsZWN0IiwicGVyZm9ybUFjdGlvbiIsInBlcmZvcm1EZWZhdWx0QWN0aW9uIiwiZ2V0QWN0aXZlRGVjb3JhdG9ycyIsInNsYXRlRWRpdG9ySW5zdGFuY2UiLCJlZGl0b3JNYWNoaW5lIiwiYmVoYXZpb3JzIiwicGVuZGluZ0V2ZW50cyIsImVucXVldWUiLCJkZWZhdWx0QWN0aW9uIiwiZXZlbnRCZWhhdmlvcnMiLCJiZWhhdmlvciIsImVkaXRvckNvbnRleHQiLCJhY3RpdmVEZWNvcmF0b3JzIiwiYmVoYXZpb3JPdmVyd3JpdHRlbiIsImV2ZW50QmVoYXZpb3IiLCJzaG91bGRSdW4iLCJhY3Rpb25JbnRlbmRTZXRzIiwiYWN0aW9uU2V0IiwiYWN0aW9uSW50ZW5kcyIsImFjdGlvbkludGVuZCIsInJhaXNlIiwibmF0aXZlRXZlbnQiLCJpbml0aWFsUmVhZE9ubHkiLCJibHVycmVkIiwibG9hZGluZyIsImVkaXRhYmxlIiwiZXhpdCIsInByaXN0aW5lIiwibm9ybWFsaXppbmciLCJkaXJ0eSIsImVkaXRvckFjdG9yU25hcHNob3QiLCJkZWZhdWx0Q29tcGFyZSIsInVzZUVkaXRvclNlbGVjdG9yIiwic2VsZWN0b3IiLCJjb21wYXJlIiwiX2ludGVybmFsIiwiZ2V0RWRpdG9yU25hcHNob3QiLCJkZWZhdWx0S2V5R2VuZXJhdG9yIiwicmFuZG9tS2V5IiwiZ2V0Qnl0ZUhleFRhYmxlIiwidGFibGUiLCJ3aGF0d2dSTkciLCJybmRzOCIsIlVpbnQ4QXJyYXkiLCJlZGl0b3JDb25maWdUb01hY2hpbmVJbnB1dCIsImNyZWF0ZUVkaXRvckZyb21BY3RvciIsInVzZUNyZWF0ZUVkaXRvciIsInNjaGVtYURlZmluaXRpb24iLCJsaXN0ZW5lciIsIkVkaXRvckFjdG9yQ29udGV4dCIsIlBvcnRhYmxlVGV4dEVkaXRvclNlbGVjdGlvbkNvbnRleHQiLCJ1c2VQb3J0YWJsZVRleHRFZGl0b3JTZWxlY3Rpb24iLCJkZWJ1ZyQ1IiwiZGVidWdWZXJib3NlIiwiUG9ydGFibGVUZXh0RWRpdG9yU2VsZWN0aW9uUHJvdmlkZXIiLCJQcm92aWRlciIsImRlYnVnJDQiLCJQb3J0YWJsZVRleHRFZGl0b3IiLCJjb25zdHJ1Y3RvciIsImNoYW5nZSQiLCJzZXRFZGl0YWJsZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsImVkaXRvclJlZiIsInJlbmRlciIsImxlZ2FjeVBhdGNoZXMiLCJpbmNvbWluZ1BhdGNoZXMkIiwicGF0Y2hlcyQiLCJSb3V0ZVBhdGNoZXNPYnNlcnZhYmxlVG9FZGl0b3JBY3RvciIsIlJvdXRlRXZlbnRzVG9DaGFuZ2VzIiwiY2hhbmdlIiwiYmxvY2tTdHlsZSIsImlzT2JqZWN0UGF0aCIsIl9lZGl0b3IiLCJpc0NoaWxkT2JqZWN0RWRpdFBhdGgiLCJzdWJzY3JpYmUiLCJwYXlsb2FkIiwiaGFuZGxlQ2hhbmdlIiwiYmI1IiwiaXNMb2FkaW5nIiwiZGVidWckMyIsIkVNUFRZX01BUktTIiwiTGVhZiIsImxlYWYiLCJyZW5kZXJEZWNvcmF0b3IiLCJyZW5kZXJBbm5vdGF0aW9uIiwic3BhblJlZiIsInBvcnRhYmxlVGV4dEVkaXRvciIsImJsb2NrU2VsZWN0ZWQiLCJzZXRGb2N1c2VkIiwic2V0U2VsZWN0ZWQiLCJkZWNvcmF0b3JWYWx1ZXMiLCJhbm5vdGF0aW9uTWFya3MiLCJtYXJrXzAiLCJCb29sZWFuIiwic2hvdWxkVHJhY2tTZWxlY3Rpb25BbmRGb2N1cyIsInNlbCIsInNldFNlbGVjdGVkRnJvbVJhbmdlIiwid2luU2VsZWN0aW9uIiwid2luZG93IiwicmFuZ2VDb3VudCIsImdldFJhbmdlQXQiLCJpbnRlcnNlY3RzTm9kZSIsIm9uQmx1ciIsIm9uRm9jdXMiLCJzZWxfMCIsIm9uU2VsZWN0aW9uIiwiY29udGVudCIsInJldHVybmVkQ2hpbGRyZW4iLCJtYXJrXzEiLCJkZWNfMCIsIl9wcm9wc18wIiwiX3Byb3BzXzEiLCJkZWJ1ZyQyIiwiREVGQVVMVF9IT1RLRVlTIiwiY3VzdG9tIiwiY3JlYXRlV2l0aEhvdGtleXMiLCJob3RrZXlzRnJvbU9wdGlvbnMiLCJyZXNlcnZlZEhvdGtleXMiLCJhY3RpdmVIb3RrZXlzIiwicHRlV2l0aEhvdEtleXMiLCJjYXQiLCJob3RrZXkiLCJwb3NzaWJsZU1hcmsiLCJwb3NzaWJsZUNvbW1hbmQiLCJjb21tYW5kIiwiZGVidWckMSIsImNyZWF0ZVdpdGhJbnNlcnREYXRhIiwiYmxvY2tUeXBlTmFtZSIsInNwYW5UeXBlTmFtZSIsIndoaXRlc3BhY2VPblBhc3RlTW9kZSIsInVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZSIsInRvUGxhaW5UZXh0Iiwic2V0RnJhZ21lbnREYXRhIiwib3JpZ2luRXZlbnQiLCJzdGFydFZvaWQiLCJ2b2lkIiwiZW5kVm9pZCIsImRvbVJhbmdlIiwidG9ET01SYW5nZSIsImNvbnRlbnRzIiwiY2xvbmVDb250ZW50cyIsInZvaWROb2RlIiwiciIsImNsb25lUmFuZ2UiLCJkb21Ob2RlIiwic2V0RW5kQWZ0ZXIiLCJxdWVyeVNlbGVjdG9yQWxsIiwienciLCJpc05ld2xpbmUiLCJnZXRBdHRyaWJ1dGUiLCJ0ZXh0Q29udGVudCIsImVsbSIsInJlbW92ZUF0dHJpYnV0ZSIsImhhc0F0dHJpYnV0ZSIsIm93bmVyRG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXNIVE1MIiwiaW5uZXJIVE1MIiwiZnJhZ21lbnQiLCJhc0pTT04iLCJhc1BsYWluVGV4dCIsImNsZWFyRGF0YSIsImluc2VydFBvcnRhYmxlVGV4dERhdGEiLCJwVGV4dCIsImdldERhdGEiLCJfcmVnZW5lcmF0ZUtleXMiLCJlcnJvckRlc2NyaXB0aW9uIiwiX2luc2VydEZyYWdtZW50IiwiaW5zZXJ0VGV4dE9ySFRNTERhdGEiLCJodG1sIiwiaW5zZXJ0ZWRUeXBlIiwidGV4dFRvSHRtbCIsImVzY2FwZUh0bWwiLCJyZXBsYWNlIiwiaW5zZXJ0RGF0YSIsImluc2VydEZyYWdtZW50RGF0YSIsImluc2VydEZyYWdtZW50IiwiZW50aXR5TWFwIiwiZWRpdG9yVHlwZXMiLCJuZXdOb2RlIiwiTmV3Tm9kZU5vRGVmcyIsImFsbG93ZWRBbm5vdGF0aW9ucyIsIm9sZEtleSIsIm5ld0tleSIsIm5vZGVXaXRoTmV3S2V5cyIsIndpdGhTeW5jUmFuZ2VEZWNvcmF0aW9ucyIsInN5bmNSYW5nZURlY29yYXRpb25zIiwib3JpZ2luYWxBcHBseSIsImRlYnVnIiwiUExBQ0VIT0xERVJfU1RZTEUiLCJ1c2VyU2VsZWN0IiwicG9pbnRlckV2ZW50cyIsInJpZ2h0IiwiUG9ydGFibGVUZXh0RWRpdGFibGUiLCJmb3J3YXJkZWRSZWYiLCJob3RrZXlzIiwib25CZWZvcmVJbnB1dCIsIm9uUGFzdGUiLCJvbkNvcHkiLCJyYW5nZURlY29yYXRpb25zIiwicmVuZGVyUGxhY2Vob2xkZXIiLCJwcm9wc1NlbGVjdGlvbiIsInNjcm9sbFNlbGVjdGlvbkludG9WaWV3IiwicmVzdFByb3BzIiwiZWRpdGFibGVFbGVtZW50Iiwic2V0RWRpdGFibGVFbGVtZW50IiwiaGFzSW52YWxpZFZhbHVlIiwic2V0SGFzSW52YWxpZFZhbHVlIiwicmFuZ2VEZWNvcmF0aW9uU3RhdGUiLCJzZXRSYW5nZURlY29yYXRpb25zU3RhdGUiLCJyYW5nZURlY29yYXRpb25zUmVmIiwid2l0aEluc2VydERhdGEiLCJ3aXRoSG90S2V5cyIsInJlbmRlckVsZW1lbnQiLCJlUHJvcHMiLCJyZW5kZXJMZWFmIiwibFByb3BzIiwicmVuZGVyZWQiLCJwbGFjZWhvbGRlciIsImRlY29yYXRpb24iLCJyYW5nZURlY29yYXRpb24iLCJjb21wb25lbnQiLCJyZXN0b3JlU2VsZWN0aW9uRnJvbVByb3BzIiwibm9ybWFsaXplZFNlbGVjdGlvbiIsInNsYXRlUmFuZ2UiLCJvIiwibmV3U2xhdGVSYW5nZXMiLCJyYW5nZURlY29yYXRpb25JdGVtIiwic2xhdGVSYW5nZV8wIiwib25Nb3ZlZCIsIm5ld1JhbmdlIiwibmV3UmFuZ2VTZWxlY3Rpb24iLCJyYW5nZURlY29yYXRpb25TdGF0ZV8wIiwib25SZWFkeSIsIm9uSW52YWxpZFZhbHVlIiwib25WYWx1ZUNoYW5nZWQiLCJzeW5jZWRSYW5nZURlY29yYXRpb25zIiwic2V0U3luY2VkUmFuZ2VEZWNvcmF0aW9ucyIsInRlYXJkb3duIiwiaGFuZGxlQ29weSIsImNsaXBib2FyZERhdGEiLCJoYW5kbGVQYXN0ZSIsInZhbHVlXzAiLCJvblBhc3RlUmVzdWx0IiwidGhlbiIsInJlc3VsdF8wIiwiY2F0Y2giLCJmaW5hbGx5IiwiaGFuZGxlT25Gb2N1cyIsImlzRGVmYXVsdFByZXZlbnRlZCIsImxhc3ROb2RlUGF0aCIsImxhc3QiLCJsYXN0QmxvY2tQYXRoIiwibGFzdE5vZGVGb2N1c2VkIiwibGFzdEJsb2NrSXNWb2lkIiwiaGFuZGxlT25CbHVyIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJoYW5kbGVPbkJlZm9yZUlucHV0IiwiZXZlbnRfNCIsInZhbGlkYXRlU2VsZWN0aW9uIiwicm9vdCIsImZpbmREb2N1bWVudE9yU2hhZG93Um9vdCIsImFjdGl2ZUVsZW1lbnQiLCJkb21TZWxlY3Rpb24iLCJnZXRXaW5kb3ciLCJleGlzdGluZ0RPTVJhbmdlIiwibmV3RE9NUmFuZ2UiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwibXV0YXRpb25PYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYXR0cmlidXRlT2xkVmFsdWUiLCJjaGFyYWN0ZXJEYXRhIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImRpc2Nvbm5lY3QiLCJoYW5kbGVLZXlEb3duIiwiZXZlbnRfNSIsIm9uS2V5RG93biIsImtleWJvYXJkRXZlbnQiLCJjb2RlIiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImhhbmRsZUtleVVwIiwiZXZlbnRfNiIsIm9uS2V5VXAiLCJzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1RvU2xhdGUiLCJkZWNvcmF0ZSIsInBhdGhfMCIsInJlc3VsdF8xIiwiaW50ZXJzZWN0aW9uIiwiYXV0b0ZvY3VzIiwib25ET01CZWZvcmVJbnB1dCIsIkVkaXRvckNvbnRleHQiLCJFZGl0b3JQcm92aWRlciIsImluaXRpYWxDb25maWciLCJ1c2VFZGl0b3IiLCJFZGl0b3JFdmVudExpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/editor/node_modules/use-effect-event/dist/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@portabletext/editor/node_modules/use-effect-event/dist/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEffectEvent: () => (/* binding */ useEffectEvent)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction useEffectEvent(fn) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect)(()=>{\n        ref.current = fn;\n    }, [\n        fn\n    ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        const latestFn = ref.current;\n        return latestFn(...args);\n    }, []);\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3VzZS1lZmZlY3QtZXZlbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnRTtBQUNoRSxTQUFTRyxlQUFlQyxFQUFFO0lBQ3hCLE1BQU1DLE1BQU1MLDZDQUFNQSxDQUFDO0lBQ25CLE9BQU9DLHlEQUFrQkEsQ0FBQztRQUN4QkksSUFBSUMsT0FBTyxHQUFHRjtJQUNoQixHQUFHO1FBQUNBO0tBQUcsR0FBR0Ysa0RBQVdBLENBQUMsQ0FBQyxHQUFHSztRQUN4QixNQUFNQyxXQUFXSCxJQUFJQyxPQUFPO1FBQzVCLE9BQU9FLFlBQVlEO0lBQ3JCLEdBQUcsRUFBRTtBQUNQO0FBR0UsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L2VkaXRvci9ub2RlX21vZHVsZXMvdXNlLWVmZmVjdC1ldmVudC9kaXN0L2luZGV4LmpzPzI3N2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VJbnNlcnRpb25FZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VFZmZlY3RFdmVudChmbikge1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHJldHVybiB1c2VJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gZm47XG4gIH0sIFtmbl0pLCB1c2VDYWxsYmFjaygoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGxhdGVzdEZuID0gcmVmLmN1cnJlbnQ7XG4gICAgcmV0dXJuIGxhdGVzdEZuKC4uLmFyZ3MpO1xuICB9LCBbXSk7XG59XG5leHBvcnQge1xuICB1c2VFZmZlY3RFdmVudFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbInVzZVJlZiIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0RXZlbnQiLCJmbiIsInJlZiIsImN1cnJlbnQiLCJhcmdzIiwibGF0ZXN0Rm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/editor/node_modules/use-effect-event/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/patches/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/patches/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyAll: () => (/* binding */ applyAll),\n/* harmony export */   diffMatchPatch: () => (/* binding */ diffMatchPatch),\n/* harmony export */   insert: () => (/* binding */ insert),\n/* harmony export */   prefixPath: () => (/* binding */ prefixPath),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setIfMissing: () => (/* binding */ setIfMissing),\n/* harmony export */   unset: () => (/* binding */ unset)\n/* harmony export */ });\n/* harmony import */ var lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isObject.js */ \"(ssr)/./node_modules/lodash/isObject.js\");\n/* harmony import */ var lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isString.js */ \"(ssr)/./node_modules/lodash/isString.js\");\n/* harmony import */ var lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/findIndex.js */ \"(ssr)/./node_modules/lodash/findIndex.js\");\n/* harmony import */ var lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/clone.js */ \"(ssr)/./node_modules/lodash/clone.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/./node_modules/lodash/omit.js\");\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\n\n\n\n\n\nconst BEFORE = \"before\", AFTER = \"after\";\nfunction insert$1(array, position, index, ...args) {\n    if (position !== BEFORE && position !== AFTER) throw new Error(`Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`);\n    const items = flatten(...args);\n    if (array.length === 0) return items;\n    const len = array.length, idx = Math.abs((len + index) % len) % len, normalizedIdx = position === \"after\" ? idx + 1 : idx, copy = array.slice();\n    return copy.splice(normalizedIdx, 0, ...flatten(items)), copy;\n}\nfunction flatten(...values) {\n    return values.reduce((prev, item)=>prev.concat(item), []);\n}\nconst hasOwn = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\nfunction move(arr, from, to) {\n    const nextValue = arr.slice(), val = nextValue[from];\n    return nextValue.splice(from, 1), nextValue.splice(to, 0, val), nextValue;\n}\nfunction findTargetIndex(array, pathSegment) {\n    if (typeof pathSegment == \"number\") return pathSegment;\n    const index = lodash_findIndex_js__WEBPACK_IMPORTED_MODULE_2__(array, pathSegment);\n    return index === -1 ? !1 : index;\n}\nfunction apply$3(value, patch) {\n    const nextValue = value.slice();\n    if (patch.path.length === 0) {\n        if (patch.type === \"setIfMissing\") {\n            if (!Array.isArray(patch.value)) throw new Error(\"Cannot set value of an array to a non-array\");\n            return value === void 0 ? patch.value : value;\n        } else if (patch.type === \"set\") {\n            if (!Array.isArray(patch.value)) throw new Error(\"Cannot set value of an array to a non-array\");\n            return patch.value;\n        } else {\n            if (patch.type === \"unset\") return;\n            if (patch.type === \"move\") {\n                if (!patch.value || !hasOwn(patch.value, \"from\") || !hasOwn(patch.value, \"to\")) throw new Error(`Invalid value of 'move' patch. Expected a value with \"from\" and \"to\" indexes, instead got: ${JSON.stringify(patch.value)}`);\n                return move(nextValue, patch.value.from, patch.value.to);\n            }\n        }\n        throw new Error(`Invalid array operation: ${patch.type}`);\n    }\n    const [head, ...tail] = patch.path, index = findTargetIndex(value, head);\n    if (index === !1) return nextValue;\n    if (tail.length === 0) {\n        if (patch.type === \"insert\") {\n            const { position, items } = patch;\n            return insert$1(value, position, index, items);\n        } else if (patch.type === \"unset\") {\n            if (typeof index != \"number\") throw new Error(`Expected array index to be a number, instead got \"${index}\"`);\n            return nextValue.splice(index, 1), nextValue;\n        }\n    }\n    return nextValue[index] = _apply(nextValue[index], {\n        ...patch,\n        path: tail\n    }), nextValue;\n}\nfunction apply$2(value, patch) {\n    const nextValue = lodash_clone_js__WEBPACK_IMPORTED_MODULE_3__(value);\n    if (patch.path.length === 0) {\n        if (patch.type === \"set\") {\n            if (!lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(patch.value)) throw new Error(\"Cannot set value of an object to a non-object\");\n            return patch.value;\n        } else {\n            if (patch.type === \"unset\") return;\n            if (patch.type === \"setIfMissing\") return value === void 0 ? patch.value : value;\n        }\n        throw new Error(`Invalid object operation: ${patch.type}`);\n    }\n    const [head, ...tail] = patch.path;\n    if (typeof head != \"string\") throw new Error(`Expected field name to be a string, instad got: ${head}`);\n    return tail.length === 0 && patch.type === \"unset\" ? lodash_omit_js__WEBPACK_IMPORTED_MODULE_4__(nextValue, head) : (nextValue[head] = _apply(nextValue[head], {\n        ...patch,\n        path: tail\n    }), nextValue);\n}\nconst OPERATIONS$1 = {\n    replace (_currentValue, nextValue) {\n        return nextValue;\n    },\n    set (_currentValue, nextValue) {\n        return nextValue;\n    },\n    setIfMissing (currentValue, nextValue) {\n        return currentValue === void 0 ? nextValue : currentValue;\n    },\n    unset (_currentValue, _nextValue) {},\n    inc (currentValue, nextValue) {\n        return currentValue + nextValue;\n    },\n    dec (currentValue, nextValue) {\n        return currentValue - nextValue;\n    }\n}, SUPPORTED_PATCH_TYPES$1 = Object.keys(OPERATIONS$1);\nfunction apply$1(value, patch) {\n    if (!SUPPORTED_PATCH_TYPES$1.includes(patch.type)) throw new Error(`Received patch of unsupported type: \"${JSON.stringify(patch.type)}\" for primitives. This is most likely a bug.`);\n    if (patch.path.length > 0) throw new Error(`Cannot apply deep operations on primitive values. Received patch with type \"${patch.type}\" and path \"${patch.path.map((path)=>JSON.stringify(path)).join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`);\n    return OPERATIONS$1[patch.type](value, patch.value);\n}\nconst OPERATIONS = {\n    replace (_currentValue, nextValue) {\n        return nextValue;\n    },\n    set (_currentValue, nextValue) {\n        return nextValue;\n    },\n    setIfMissing (currentValue, nextValue) {\n        return currentValue === void 0 ? nextValue : currentValue;\n    },\n    unset (_currentValue, _nextValue) {},\n    diffMatchPatch (currentValue, nextValue) {\n        const [result] = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.applyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.parsePatch)(nextValue), currentValue, {\n            allowExceedingIndices: !0\n        });\n        return result;\n    }\n}, SUPPORTED_PATCH_TYPES = Object.keys(OPERATIONS);\nfunction apply(value, patch) {\n    if (!SUPPORTED_PATCH_TYPES.includes(patch.type)) throw new Error(`Received patch of unsupported type: \"${JSON.stringify(patch.type)}\" for string. This is most likely a bug.`);\n    if (patch.path.length > 0) throw new Error(`Cannot apply deep operations on string values. Received patch with type \"${patch.type}\" and path \"${patch.path.join(\".\")} that targeted the value \"${JSON.stringify(value)}\"`);\n    const func = OPERATIONS[patch.type];\n    if (func) return func(value, patch.value);\n    throw new Error(\"Unknown patch type\");\n}\nfunction applyAll(value, patches) {\n    return patches.reduce(_apply, value);\n}\nfunction applyPatch(value, patch) {\n    return Array.isArray(value) ? apply$3(value, patch) : lodash_isString_js__WEBPACK_IMPORTED_MODULE_1__(value) ? apply(value, patch) : lodash_isObject_js__WEBPACK_IMPORTED_MODULE_0__(value) ? apply$2(value, patch) : apply$1(value, patch);\n}\nfunction _apply(value, patch) {\n    return applyPatch(value, patch);\n}\nfunction setIfMissing(value, path = []) {\n    return {\n        type: \"setIfMissing\",\n        path,\n        value\n    };\n}\nfunction diffMatchPatch(currentValue, nextValue, path = []) {\n    const patches = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.makePatches)(currentValue, nextValue), patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_5__.stringifyPatches)(patches);\n    return {\n        type: \"diffMatchPatch\",\n        path,\n        value: patch\n    };\n}\nfunction insert(items, position, path = []) {\n    return {\n        type: \"insert\",\n        path,\n        position,\n        items\n    };\n}\nfunction set(value, path = []) {\n    return {\n        type: \"set\",\n        path,\n        value\n    };\n}\nfunction unset(path = []) {\n    return {\n        type: \"unset\",\n        path\n    };\n}\nfunction prefixPath(patch, segment) {\n    return {\n        ...patch,\n        path: [\n            segment,\n            ...patch.path\n        ]\n    };\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9wYXRjaGVzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0U7QUFDUjtBQUNGO0FBQ2lFO0FBQ25HLE1BQU1TLFNBQVMsVUFBVUMsUUFBUTtBQUNqQyxTQUFTQyxTQUFTQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFLEdBQUdDLElBQUk7SUFDL0MsSUFBSUYsYUFBYUosVUFBVUksYUFBYUgsT0FDdEMsTUFBTSxJQUFJTSxNQUNSLENBQUMsa0JBQWtCLEVBQUVILFNBQVMsa0JBQWtCLEVBQUVKLE9BQU8sSUFBSSxFQUFFQyxNQUFNLENBQUM7SUFFMUUsTUFBTU8sUUFBUUMsV0FBV0g7SUFDekIsSUFBSUgsTUFBTU8sTUFBTSxLQUFLLEdBQ25CLE9BQU9GO0lBQ1QsTUFBTUcsTUFBTVIsTUFBTU8sTUFBTSxFQUFFRSxNQUFNQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0gsTUFBTU4sS0FBSSxJQUFLTSxPQUFPQSxLQUFLSSxnQkFBZ0JYLGFBQWEsVUFBVVEsTUFBTSxJQUFJQSxLQUFLSSxPQUFPYixNQUFNYyxLQUFLO0lBQzdJLE9BQU9ELEtBQUtFLE1BQU0sQ0FBQ0gsZUFBZSxNQUFNTixRQUFRRCxTQUFTUTtBQUMzRDtBQUNBLFNBQVNQLFFBQVEsR0FBR1UsTUFBTTtJQUN4QixPQUFPQSxPQUFPQyxNQUFNLENBQUMsQ0FBQ0MsTUFBTUMsT0FBU0QsS0FBS0UsTUFBTSxDQUFDRCxPQUFPLEVBQUU7QUFDNUQ7QUFDQSxNQUFNRSxTQUFTQyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLENBQ3RESixPQUFPQyxTQUFTLENBQUNDLGNBQWM7QUFFakMsU0FBU0csS0FBS0MsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLEVBQUU7SUFDekIsTUFBTUMsWUFBWUgsSUFBSWQsS0FBSyxJQUFJa0IsTUFBTUQsU0FBUyxDQUFD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QUFFTyxPQUFPLEVBQUU7SUFDeEQsTUFBTWtDLFVBQVU3RSxxRUFBV0EsQ0FBQzBELGNBQWN0QixZQUFZTSxRQUFRekMsMEVBQWdCQSxDQUFDNEU7SUFDL0UsT0FBTztRQUFFakMsTUFBTTtRQUFrQkQ7UUFBTUYsT0FBT0M7SUFBTTtBQUN0RDtBQUNBLFNBQVNxQyxPQUFPckUsS0FBSyxFQUFFSixRQUFRLEVBQUVxQyxPQUFPLEVBQUU7SUFDeEMsT0FBTztRQUNMQyxNQUFNO1FBQ05EO1FBQ0FyQztRQUNBSTtJQUNGO0FBQ0Y7QUFDQSxTQUFTOEMsSUFBSWYsS0FBSyxFQUFFRSxPQUFPLEVBQUU7SUFDM0IsT0FBTztRQUFFQyxNQUFNO1FBQU9EO1FBQU1GO0lBQU07QUFDcEM7QUFDQSxTQUFTa0IsTUFBTWhCLE9BQU8sRUFBRTtJQUN0QixPQUFPO1FBQUVDLE1BQU07UUFBU0Q7SUFBSztBQUMvQjtBQUNBLFNBQVNxQyxXQUFXdEMsS0FBSyxFQUFFdUMsT0FBTztJQUNoQyxPQUFPO1FBQ0wsR0FBR3ZDLEtBQUs7UUFDUkMsTUFBTTtZQUFDc0M7ZUFBWXZDLE1BQU1DLElBQUk7U0FBQztJQUNoQztBQUNGO0FBU0UsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3BhdGNoZXMvZGlzdC9pbmRleC5qcz9iZGU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpc09iamVjdCBmcm9tIFwibG9kYXNoL2lzT2JqZWN0LmpzXCI7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSBcImxvZGFzaC9pc1N0cmluZy5qc1wiO1xuaW1wb3J0IGZpbmRJbmRleCBmcm9tIFwibG9kYXNoL2ZpbmRJbmRleC5qc1wiO1xuaW1wb3J0IGNsb25lIGZyb20gXCJsb2Rhc2gvY2xvbmUuanNcIjtcbmltcG9ydCBvbWl0IGZyb20gXCJsb2Rhc2gvb21pdC5qc1wiO1xuaW1wb3J0IHsgYXBwbHlQYXRjaGVzLCBwYXJzZVBhdGNoLCBtYWtlUGF0Y2hlcywgc3RyaW5naWZ5UGF0Y2hlcyB9IGZyb20gXCJAc2FuaXR5L2RpZmYtbWF0Y2gtcGF0Y2hcIjtcbmNvbnN0IEJFRk9SRSA9IFwiYmVmb3JlXCIsIEFGVEVSID0gXCJhZnRlclwiO1xuZnVuY3Rpb24gaW5zZXJ0JDEoYXJyYXksIHBvc2l0aW9uLCBpbmRleCwgLi4uYXJncykge1xuICBpZiAocG9zaXRpb24gIT09IEJFRk9SRSAmJiBwb3NpdGlvbiAhPT0gQUZURVIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgcG9zaXRpb24gXCIke3Bvc2l0aW9ufVwiLCBtdXN0IGJlIGVpdGhlciAke0JFRk9SRX0gb3IgJHtBRlRFUn1gXG4gICAgKTtcbiAgY29uc3QgaXRlbXMgPSBmbGF0dGVuKC4uLmFyZ3MpO1xuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBpdGVtcztcbiAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoLCBpZHggPSBNYXRoLmFicygobGVuICsgaW5kZXgpICUgbGVuKSAlIGxlbiwgbm9ybWFsaXplZElkeCA9IHBvc2l0aW9uID09PSBcImFmdGVyXCIgPyBpZHggKyAxIDogaWR4LCBjb3B5ID0gYXJyYXkuc2xpY2UoKTtcbiAgcmV0dXJuIGNvcHkuc3BsaWNlKG5vcm1hbGl6ZWRJZHgsIDAsIC4uLmZsYXR0ZW4oaXRlbXMpKSwgY29weTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW4oLi4udmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMucmVkdWNlKChwcmV2LCBpdGVtKSA9PiBwcmV2LmNvbmNhdChpdGVtKSwgW10pO1xufVxuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsLmJpbmQoXG4gIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbik7XG5mdW5jdGlvbiBtb3ZlKGFyciwgZnJvbSwgdG8pIHtcbiAgY29uc3QgbmV4dFZhbHVlID0gYXJyLnNsaWNlKCksIHZhbCA9IG5leHRWYWx1ZVtmcm9tXTtcbiAgcmV0dXJuIG5leHRWYWx1ZS5zcGxpY2UoZnJvbSwgMSksIG5leHRWYWx1ZS5zcGxpY2UodG8sIDAsIHZhbCksIG5leHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRUYXJnZXRJbmRleChhcnJheSwgcGF0aFNlZ21lbnQpIHtcbiAgaWYgKHR5cGVvZiBwYXRoU2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBwYXRoU2VnbWVudDtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXgoYXJyYXksIHBhdGhTZWdtZW50KTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICExIDogaW5kZXg7XG59XG5mdW5jdGlvbiBhcHBseSQzKHZhbHVlLCBwYXRjaCkge1xuICBjb25zdCBuZXh0VmFsdWUgPSB2YWx1ZS5zbGljZSgpO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJzZXRJZk1pc3NpbmdcIikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoLnZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB2YWx1ZSBvZiBhbiBhcnJheSB0byBhIG5vbi1hcnJheVwiKTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8gcGF0Y2gudmFsdWUgOiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXRjaC52YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdmFsdWUgb2YgYW4gYXJyYXkgdG8gYSBub24tYXJyYXlcIik7XG4gICAgICByZXR1cm4gcGF0Y2gudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcIm1vdmVcIikge1xuICAgICAgICBpZiAoIXBhdGNoLnZhbHVlIHx8ICFoYXNPd24ocGF0Y2gudmFsdWUsIFwiZnJvbVwiKSB8fCAhaGFzT3duKHBhdGNoLnZhbHVlLCBcInRvXCIpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIG9mICdtb3ZlJyBwYXRjaC4gRXhwZWN0ZWQgYSB2YWx1ZSB3aXRoIFwiZnJvbVwiIGFuZCBcInRvXCIgaW5kZXhlcywgaW5zdGVhZCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHBhdGNoLnZhbHVlXG4gICAgICAgICAgICApfWBcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gbW92ZShuZXh0VmFsdWUsIHBhdGNoLnZhbHVlLmZyb20sIHBhdGNoLnZhbHVlLnRvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFycmF5IG9wZXJhdGlvbjogJHtwYXRjaC50eXBlfWApO1xuICB9XG4gIGNvbnN0IFtoZWFkLCAuLi50YWlsXSA9IHBhdGNoLnBhdGgsIGluZGV4ID0gZmluZFRhcmdldEluZGV4KHZhbHVlLCBoZWFkKTtcbiAgaWYgKGluZGV4ID09PSAhMSlcbiAgICByZXR1cm4gbmV4dFZhbHVlO1xuICBpZiAodGFpbC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAocGF0Y2gudHlwZSA9PT0gXCJpbnNlcnRcIikge1xuICAgICAgY29uc3QgeyBwb3NpdGlvbiwgaXRlbXMgfSA9IHBhdGNoO1xuICAgICAgcmV0dXJuIGluc2VydCQxKHZhbHVlLCBwb3NpdGlvbiwgaW5kZXgsIGl0ZW1zKTtcbiAgICB9IGVsc2UgaWYgKHBhdGNoLnR5cGUgPT09IFwidW5zZXRcIikge1xuICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIGFycmF5IGluZGV4IHRvIGJlIGEgbnVtYmVyLCBpbnN0ZWFkIGdvdCBcIiR7aW5kZXh9XCJgXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gbmV4dFZhbHVlLnNwbGljZShpbmRleCwgMSksIG5leHRWYWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHRWYWx1ZVtpbmRleF0gPSBfYXBwbHkobmV4dFZhbHVlW2luZGV4XSwge1xuICAgIC4uLnBhdGNoLFxuICAgIHBhdGg6IHRhaWxcbiAgfSksIG5leHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGFwcGx5JDIodmFsdWUsIHBhdGNoKSB7XG4gIGNvbnN0IG5leHRWYWx1ZSA9IGNsb25lKHZhbHVlKTtcbiAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHBhdGNoLnR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgIGlmICghaXNPYmplY3QocGF0Y2gudmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHZhbHVlIG9mIGFuIG9iamVjdCB0byBhIG5vbi1vYmplY3RcIik7XG4gICAgICByZXR1cm4gcGF0Y2gudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInVuc2V0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChwYXRjaC50eXBlID09PSBcInNldElmTWlzc2luZ1wiKVxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHBhdGNoLnZhbHVlIDogdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvYmplY3Qgb3BlcmF0aW9uOiAke3BhdGNoLnR5cGV9YCk7XG4gIH1cbiAgY29uc3QgW2hlYWQsIC4uLnRhaWxdID0gcGF0Y2gucGF0aDtcbiAgaWYgKHR5cGVvZiBoZWFkICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBmaWVsZCBuYW1lIHRvIGJlIGEgc3RyaW5nLCBpbnN0YWQgZ290OiAke2hlYWR9YCk7XG4gIHJldHVybiB0YWlsLmxlbmd0aCA9PT0gMCAmJiBwYXRjaC50eXBlID09PSBcInVuc2V0XCIgPyBvbWl0KG5leHRWYWx1ZSwgaGVhZCkgOiAobmV4dFZhbHVlW2hlYWRdID0gX2FwcGx5KG5leHRWYWx1ZVtoZWFkXSwge1xuICAgIC4uLnBhdGNoLFxuICAgIHBhdGg6IHRhaWxcbiAgfSksIG5leHRWYWx1ZSk7XG59XG5jb25zdCBPUEVSQVRJT05TJDEgPSB7XG4gIHJlcGxhY2UoX2N1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgfSxcbiAgc2V0KF9jdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHNldElmTWlzc2luZyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHZvaWQgMCA/IG5leHRWYWx1ZSA6IGN1cnJlbnRWYWx1ZTtcbiAgfSxcbiAgdW5zZXQoX2N1cnJlbnRWYWx1ZSwgX25leHRWYWx1ZSkge1xuICB9LFxuICBpbmMoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlICsgbmV4dFZhbHVlO1xuICB9LFxuICBkZWMoY3VycmVudFZhbHVlLCBuZXh0VmFsdWUpIHtcbiAgICByZXR1cm4gY3VycmVudFZhbHVlIC0gbmV4dFZhbHVlO1xuICB9XG59LCBTVVBQT1JURURfUEFUQ0hfVFlQRVMkMSA9IE9iamVjdC5rZXlzKE9QRVJBVElPTlMkMSk7XG5mdW5jdGlvbiBhcHBseSQxKHZhbHVlLCBwYXRjaCkge1xuICBpZiAoIVNVUFBPUlRFRF9QQVRDSF9UWVBFUyQxLmluY2x1ZGVzKHBhdGNoLnR5cGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZWNlaXZlZCBwYXRjaCBvZiB1bnN1cHBvcnRlZCB0eXBlOiBcIiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIHBhdGNoLnR5cGVcbiAgICAgICl9XCIgZm9yIHByaW1pdGl2ZXMuIFRoaXMgaXMgbW9zdCBsaWtlbHkgYSBidWcuYFxuICAgICk7XG4gIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBhcHBseSBkZWVwIG9wZXJhdGlvbnMgb24gcHJpbWl0aXZlIHZhbHVlcy4gUmVjZWl2ZWQgcGF0Y2ggd2l0aCB0eXBlIFwiJHtwYXRjaC50eXBlfVwiIGFuZCBwYXRoIFwiJHtwYXRjaC5wYXRoLm1hcCgocGF0aCkgPT4gSlNPTi5zdHJpbmdpZnkocGF0aCkpLmpvaW4oXCIuXCIpfSB0aGF0IHRhcmdldGVkIHRoZSB2YWx1ZSBcIiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVwiYFxuICAgICk7XG4gIHJldHVybiBPUEVSQVRJT05TJDFbcGF0Y2gudHlwZV0odmFsdWUsIHBhdGNoLnZhbHVlKTtcbn1cbmNvbnN0IE9QRVJBVElPTlMgPSB7XG4gIHJlcGxhY2UoX2N1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlKSB7XG4gICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgfSxcbiAgc2V0KF9jdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHNldElmTWlzc2luZyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHZvaWQgMCA/IG5leHRWYWx1ZSA6IGN1cnJlbnRWYWx1ZTtcbiAgfSxcbiAgdW5zZXQoX2N1cnJlbnRWYWx1ZSwgX25leHRWYWx1ZSkge1xuICB9LFxuICBkaWZmTWF0Y2hQYXRjaChjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSkge1xuICAgIGNvbnN0IFtyZXN1bHRdID0gYXBwbHlQYXRjaGVzKHBhcnNlUGF0Y2gobmV4dFZhbHVlKSwgY3VycmVudFZhbHVlLCB7XG4gICAgICBhbGxvd0V4Y2VlZGluZ0luZGljZXM6ICEwXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSwgU1VQUE9SVEVEX1BBVENIX1RZUEVTID0gT2JqZWN0LmtleXMoT1BFUkFUSU9OUyk7XG5mdW5jdGlvbiBhcHBseSh2YWx1ZSwgcGF0Y2gpIHtcbiAgaWYgKCFTVVBQT1JURURfUEFUQ0hfVFlQRVMuaW5jbHVkZXMocGF0Y2gudHlwZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFJlY2VpdmVkIHBhdGNoIG9mIHVuc3VwcG9ydGVkIHR5cGU6IFwiJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgcGF0Y2gudHlwZVxuICAgICAgKX1cIiBmb3Igc3RyaW5nLiBUaGlzIGlzIG1vc3QgbGlrZWx5IGEgYnVnLmBcbiAgICApO1xuICBpZiAocGF0Y2gucGF0aC5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgYXBwbHkgZGVlcCBvcGVyYXRpb25zIG9uIHN0cmluZyB2YWx1ZXMuIFJlY2VpdmVkIHBhdGNoIHdpdGggdHlwZSBcIiR7cGF0Y2gudHlwZX1cIiBhbmQgcGF0aCBcIiR7cGF0Y2gucGF0aC5qb2luKFwiLlwiKX0gdGhhdCB0YXJnZXRlZCB0aGUgdmFsdWUgXCIke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cImBcbiAgICApO1xuICBjb25zdCBmdW5jID0gT1BFUkFUSU9OU1twYXRjaC50eXBlXTtcbiAgaWYgKGZ1bmMpXG4gICAgcmV0dXJuIGZ1bmModmFsdWUsIHBhdGNoLnZhbHVlKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwYXRjaCB0eXBlXCIpO1xufVxuZnVuY3Rpb24gYXBwbHlBbGwodmFsdWUsIHBhdGNoZXMpIHtcbiAgcmV0dXJuIHBhdGNoZXMucmVkdWNlKF9hcHBseSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYXBwbHlQYXRjaCh2YWx1ZSwgcGF0Y2gpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gYXBwbHkkMyh2YWx1ZSwgcGF0Y2gpIDogaXNTdHJpbmcodmFsdWUpID8gYXBwbHkodmFsdWUsIHBhdGNoKSA6IGlzT2JqZWN0KHZhbHVlKSA/IGFwcGx5JDIodmFsdWUsIHBhdGNoKSA6IGFwcGx5JDEodmFsdWUsIHBhdGNoKTtcbn1cbmZ1bmN0aW9uIF9hcHBseSh2YWx1ZSwgcGF0Y2gpIHtcbiAgcmV0dXJuIGFwcGx5UGF0Y2godmFsdWUsIHBhdGNoKTtcbn1cbmZ1bmN0aW9uIHNldElmTWlzc2luZyh2YWx1ZSwgcGF0aCA9IFtdKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzZXRJZk1pc3NpbmdcIixcbiAgICBwYXRoLFxuICAgIHZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBkaWZmTWF0Y2hQYXRjaChjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSwgcGF0aCA9IFtdKSB7XG4gIGNvbnN0IHBhdGNoZXMgPSBtYWtlUGF0Y2hlcyhjdXJyZW50VmFsdWUsIG5leHRWYWx1ZSksIHBhdGNoID0gc3RyaW5naWZ5UGF0Y2hlcyhwYXRjaGVzKTtcbiAgcmV0dXJuIHsgdHlwZTogXCJkaWZmTWF0Y2hQYXRjaFwiLCBwYXRoLCB2YWx1ZTogcGF0Y2ggfTtcbn1cbmZ1bmN0aW9uIGluc2VydChpdGVtcywgcG9zaXRpb24sIHBhdGggPSBbXSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiaW5zZXJ0XCIsXG4gICAgcGF0aCxcbiAgICBwb3NpdGlvbixcbiAgICBpdGVtc1xuICB9O1xufVxuZnVuY3Rpb24gc2V0KHZhbHVlLCBwYXRoID0gW10pIHtcbiAgcmV0dXJuIHsgdHlwZTogXCJzZXRcIiwgcGF0aCwgdmFsdWUgfTtcbn1cbmZ1bmN0aW9uIHVuc2V0KHBhdGggPSBbXSkge1xuICByZXR1cm4geyB0eXBlOiBcInVuc2V0XCIsIHBhdGggfTtcbn1cbmZ1bmN0aW9uIHByZWZpeFBhdGgocGF0Y2gsIHNlZ21lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYXRjaCxcbiAgICBwYXRoOiBbc2VnbWVudCwgLi4ucGF0Y2gucGF0aF1cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGFwcGx5QWxsLFxuICBkaWZmTWF0Y2hQYXRjaCxcbiAgaW5zZXJ0LFxuICBwcmVmaXhQYXRoLFxuICBzZXQsXG4gIHNldElmTWlzc2luZyxcbiAgdW5zZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc09iamVjdCIsImlzU3RyaW5nIiwiZmluZEluZGV4IiwiY2xvbmUiLCJvbWl0IiwiYXBwbHlQYXRjaGVzIiwicGFyc2VQYXRjaCIsIm1ha2VQYXRjaGVzIiwic3RyaW5naWZ5UGF0Y2hlcyIsIkJFRk9SRSIsIkFGVEVSIiwiaW5zZXJ0JDEiLCJhcnJheSIsInBvc2l0aW9uIiwiaW5kZXgiLCJhcmdzIiwiRXJyb3IiLCJpdGVtcyIsImZsYXR0ZW4iLCJsZW5ndGgiLCJsZW4iLCJpZHgiLCJNYXRoIiwiYWJzIiwibm9ybWFsaXplZElkeCIsImNvcHkiLCJzbGljZSIsInNwbGljZSIsInZhbHVlcyIsInJlZHVjZSIsInByZXYiLCJpdGVtIiwiY29uY2F0IiwiaGFzT3duIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYmluZCIsIm1vdmUiLCJhcnIiLCJmcm9tIiwidG8iLCJuZXh0VmFsdWUiLCJ2YWwiLCJmaW5kVGFyZ2V0SW5kZXgiLCJwYXRoU2VnbWVudCIsImFwcGx5JDMiLCJ2YWx1ZSIsInBhdGNoIiwicGF0aCIsInR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJKU09OIiwic3RyaW5naWZ5IiwiaGVhZCIsInRhaWwiLCJfYXBwbHkiLCJhcHBseSQyIiwiT1BFUkFUSU9OUyQxIiwicmVwbGFjZSIsIl9jdXJyZW50VmFsdWUiLCJzZXQiLCJzZXRJZk1pc3NpbmciLCJjdXJyZW50VmFsdWUiLCJ1bnNldCIsIl9uZXh0VmFsdWUiLCJpbmMiLCJkZWMiLCJTVVBQT1JURURfUEFUQ0hfVFlQRVMkMSIsImtleXMiLCJhcHBseSQxIiwiaW5jbHVkZXMiLCJtYXAiLCJqb2luIiwiT1BFUkFUSU9OUyIsImRpZmZNYXRjaFBhdGNoIiwicmVzdWx0IiwiYWxsb3dFeGNlZWRpbmdJbmRpY2VzIiwiU1VQUE9SVEVEX1BBVENIX1RZUEVTIiwiYXBwbHkiLCJmdW5jIiwiYXBwbHlBbGwiLCJwYXRjaGVzIiwiYXBwbHlQYXRjaCIsImluc2VydCIsInByZWZpeFBhdGgiLCJzZWdtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/patches/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/react/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@portabletext/react/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PortableText: () => (/* binding */ PortableText),\n/* harmony export */   defaultComponents: () => (/* binding */ defaultComponents),\n/* harmony export */   mergeComponents: () => (/* binding */ mergeComponents),\n/* harmony export */   toPlainText: () => (/* reexport safe */ _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.toPlainText)\n/* harmony export */ });\n/* harmony import */ var _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @portabletext/toolkit */ \"(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst _excluded = [\n    \"block\",\n    \"list\",\n    \"listItem\",\n    \"marks\",\n    \"types\"\n], _excluded2 = [\n    \"listItem\"\n], _excluded3 = [\n    \"_key\"\n];\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\n\n\n\n\nfunction mergeComponents(parent, overrides) {\n    const { block, list, listItem, marks, types } = overrides, rest = _objectWithoutProperties(overrides, _excluded);\n    return _objectSpread(_objectSpread({}, parent), {}, {\n        block: mergeDeeply(parent, overrides, \"block\"),\n        list: mergeDeeply(parent, overrides, \"list\"),\n        listItem: mergeDeeply(parent, overrides, \"listItem\"),\n        marks: mergeDeeply(parent, overrides, \"marks\"),\n        types: mergeDeeply(parent, overrides, \"types\")\n    }, rest);\n}\nfunction mergeDeeply(parent, overrides, key) {\n    const override = overrides[key];\n    const parentVal = parent[key];\n    if (typeof override === \"function\") {\n        return override;\n    }\n    if (override && typeof parentVal === \"function\") {\n        return override;\n    }\n    if (override) {\n        return _objectSpread(_objectSpread({}, parentVal), override);\n    }\n    return parentVal;\n}\nconst link = (_ref)=>{\n    let { children, value } = _ref;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"a\", {\n        href: value == null ? void 0 : value.href,\n        children\n    });\n};\nconst underlineStyle = {\n    textDecoration: \"underline\"\n};\nconst defaultMarks = {\n    em: (_ref2)=>{\n        let { children } = _ref2;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"em\", {\n            children\n        });\n    },\n    strong: (_ref3)=>{\n        let { children } = _ref3;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"strong\", {\n            children\n        });\n    },\n    code: (_ref4)=>{\n        let { children } = _ref4;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"code\", {\n            children\n        });\n    },\n    underline: (_ref5)=>{\n        let { children } = _ref5;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n            style: underlineStyle,\n            children\n        });\n    },\n    \"strike-through\": (_ref6)=>{\n        let { children } = _ref6;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"del\", {\n            children\n        });\n    },\n    link\n};\nconst defaultLists = {\n    number: (_ref7)=>{\n        let { children } = _ref7;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"ol\", {\n            children\n        });\n    },\n    bullet: (_ref8)=>{\n        let { children } = _ref8;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"ul\", {\n            children\n        });\n    }\n};\nconst DefaultListItem = (_ref9)=>{\n    let { children } = _ref9;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"li\", {\n        children\n    });\n};\nconst getTemplate = (type, prop)=>\"[@portabletext/react] Unknown \".concat(type, \", specify a component for it in the `components.\").concat(prop, \"` prop\");\nconst unknownTypeWarning = (typeName)=>getTemplate('block type \"'.concat(typeName, '\"'), \"types\");\nconst unknownMarkWarning = (markType)=>getTemplate('mark type \"'.concat(markType, '\"'), \"marks\");\nconst unknownBlockStyleWarning = (blockStyle)=>getTemplate('block style \"'.concat(blockStyle, '\"'), \"block\");\nconst unknownListStyleWarning = (listStyle)=>getTemplate('list style \"'.concat(listStyle, '\"'), \"list\");\nconst unknownListItemStyleWarning = (listStyle)=>getTemplate('list item style \"'.concat(listStyle, '\"'), \"listItem\");\nfunction printWarning(message) {\n    console.warn(message);\n}\nconst hidden = {\n    display: \"none\"\n};\nconst DefaultUnknownType = (_ref10)=>{\n    let { value, isInline } = _ref10;\n    const warning = unknownTypeWarning(value._type);\n    return isInline ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n        style: hidden,\n        children: warning\n    }) : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        style: hidden,\n        children: warning\n    });\n};\nconst DefaultUnknownMark = (_ref11)=>{\n    let { markType, children } = _ref11;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n        className: \"unknown__pt__mark__\".concat(markType),\n        children\n    });\n};\nconst DefaultUnknownBlockStyle = (_ref12)=>{\n    let { children } = _ref12;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", {\n        children\n    });\n};\nconst DefaultUnknownList = (_ref13)=>{\n    let { children } = _ref13;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"ul\", {\n        children\n    });\n};\nconst DefaultUnknownListItem = (_ref14)=>{\n    let { children } = _ref14;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"li\", {\n        children\n    });\n};\nconst DefaultHardBreak = ()=>/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"br\", {});\nconst defaultBlockStyles = {\n    normal: (_ref15)=>{\n        let { children } = _ref15;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"p\", {\n            children\n        });\n    },\n    blockquote: (_ref16)=>{\n        let { children } = _ref16;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"blockquote\", {\n            children\n        });\n    },\n    h1: (_ref17)=>{\n        let { children } = _ref17;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h1\", {\n            children\n        });\n    },\n    h2: (_ref18)=>{\n        let { children } = _ref18;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h2\", {\n            children\n        });\n    },\n    h3: (_ref19)=>{\n        let { children } = _ref19;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h3\", {\n            children\n        });\n    },\n    h4: (_ref20)=>{\n        let { children } = _ref20;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h4\", {\n            children\n        });\n    },\n    h5: (_ref21)=>{\n        let { children } = _ref21;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h5\", {\n            children\n        });\n    },\n    h6: (_ref22)=>{\n        let { children } = _ref22;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"h6\", {\n            children\n        });\n    }\n};\nconst defaultComponents = {\n    types: {},\n    block: defaultBlockStyles,\n    marks: defaultMarks,\n    list: defaultLists,\n    listItem: DefaultListItem,\n    hardBreak: DefaultHardBreak,\n    unknownType: DefaultUnknownType,\n    unknownMark: DefaultUnknownMark,\n    unknownList: DefaultUnknownList,\n    unknownListItem: DefaultUnknownListItem,\n    unknownBlockStyle: DefaultUnknownBlockStyle\n};\nfunction PortableText(_ref23) {\n    let { value: input, components: componentOverrides, listNestingMode, onMissingComponent: missingComponentHandler = printWarning } = _ref23;\n    const handleMissingComponent = missingComponentHandler || noop;\n    const blocks = Array.isArray(input) ? input : [\n        input\n    ];\n    const nested = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.nestLists)(blocks, listNestingMode || _portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.LIST_NEST_MODE_HTML);\n    const components = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>{\n        return componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents;\n    }, [\n        componentOverrides\n    ]);\n    const renderNode = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>getNodeRenderer(components, handleMissingComponent), [\n        components,\n        handleMissingComponent\n    ]);\n    const rendered = nested.map((node, index)=>renderNode({\n            node,\n            index,\n            isInline: false,\n            renderNode\n        }));\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n        children: rendered\n    });\n}\nconst getNodeRenderer = (components, handleMissingComponent)=>{\n    function renderNode(options) {\n        const { node, index, isInline } = options;\n        const key = node._key || \"node-\".concat(index);\n        if ((0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitList)(node)) {\n            return renderList(node, index, key);\n        }\n        if ((0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextListItemBlock)(node)) {\n            return renderListItem(node, index, key);\n        }\n        if ((0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitSpan)(node)) {\n            return renderSpan(node, index, key);\n        }\n        if (hasCustomComponentForNode(node)) {\n            return renderCustomBlock(node, index, key, isInline);\n        }\n        if ((0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextBlock)(node)) {\n            return renderBlock(node, index, key, isInline);\n        }\n        if ((0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPortableTextToolkitTextNode)(node)) {\n            return renderText(node, key);\n        }\n        return renderUnknownType(node, index, key, isInline);\n    }\n    function hasCustomComponentForNode(node) {\n        return node._type in components.types;\n    }\n    function renderListItem(node, index, key) {\n        const tree = serializeBlock({\n            node,\n            index,\n            isInline: false,\n            renderNode\n        });\n        const renderer = components.listItem;\n        const handler = typeof renderer === \"function\" ? renderer : renderer[node.listItem];\n        const Li = handler || components.unknownListItem;\n        if (Li === components.unknownListItem) {\n            const style = node.listItem || \"bullet\";\n            handleMissingComponent(unknownListItemStyleWarning(style), {\n                type: style,\n                nodeType: \"listItemStyle\"\n            });\n        }\n        let children = tree.children;\n        if (node.style && node.style !== \"normal\") {\n            const { listItem } = node, blockNode = _objectWithoutProperties(node, _excluded2);\n            children = renderNode({\n                node: blockNode,\n                index,\n                isInline: false,\n                renderNode\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Li, {\n            value: node,\n            index,\n            isInline: false,\n            renderNode,\n            children\n        }, key);\n    }\n    function renderList(node, index, key) {\n        const children = node.children.map((child, childIndex)=>renderNode({\n                node: child._key ? child : _objectSpread(_objectSpread({}, child), {}, {\n                    _key: \"li-\".concat(index, \"-\").concat(childIndex)\n                }),\n                index: childIndex,\n                isInline: false,\n                renderNode\n            }));\n        const component = components.list;\n        const handler = typeof component === \"function\" ? component : component[node.listItem];\n        const List = handler || components.unknownList;\n        if (List === components.unknownList) {\n            const style = node.listItem || \"bullet\";\n            handleMissingComponent(unknownListStyleWarning(style), {\n                nodeType: \"listStyle\",\n                type: style\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(List, {\n            value: node,\n            index,\n            isInline: false,\n            renderNode,\n            children\n        }, key);\n    }\n    function renderSpan(node, _index, key) {\n        const { markDef, markType, markKey } = node;\n        const Span = components.marks[markType] || components.unknownMark;\n        const children = node.children.map((child, childIndex)=>renderNode({\n                node: child,\n                index: childIndex,\n                isInline: true,\n                renderNode\n            }));\n        if (Span === components.unknownMark) {\n            handleMissingComponent(unknownMarkWarning(markType), {\n                nodeType: \"mark\",\n                type: markType\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Span, {\n            text: (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.spanToPlainText)(node),\n            value: markDef,\n            markType,\n            markKey,\n            renderNode,\n            children\n        }, key);\n    }\n    function renderBlock(node, index, key, isInline) {\n        const _serializeBlock = serializeBlock({\n            node,\n            index,\n            isInline,\n            renderNode\n        }), { _key } = _serializeBlock, props = _objectWithoutProperties(_serializeBlock, _excluded3);\n        const style = props.node.style || \"normal\";\n        const handler = typeof components.block === \"function\" ? components.block : components.block[style];\n        const Block = handler || components.unknownBlockStyle;\n        if (Block === components.unknownBlockStyle) {\n            handleMissingComponent(unknownBlockStyleWarning(style), {\n                nodeType: \"blockStyle\",\n                type: style\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Block, _objectSpread(_objectSpread({}, props), {}, {\n            value: props.node,\n            renderNode\n        }), key);\n    }\n    function renderText(node, key) {\n        if (node.text === \"\\n\") {\n            const HardBreak = components.hardBreak;\n            return HardBreak ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(HardBreak, {}, key) : \"\\n\";\n        }\n        return node.text;\n    }\n    function renderUnknownType(node, index, key, isInline) {\n        const nodeOptions = {\n            value: node,\n            isInline,\n            index,\n            renderNode\n        };\n        handleMissingComponent(unknownTypeWarning(node._type), {\n            nodeType: \"block\",\n            type: node._type\n        });\n        const UnknownType = components.unknownType;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(UnknownType, _objectSpread({}, nodeOptions), key);\n    }\n    function renderCustomBlock(node, index, key, isInline) {\n        const nodeOptions = {\n            value: node,\n            isInline,\n            index,\n            renderNode\n        };\n        const Node = components.types[node._type];\n        return Node ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Node, _objectSpread({}, nodeOptions), key) : null;\n    }\n    return renderNode;\n};\nfunction serializeBlock(options) {\n    const { node, index, isInline, renderNode } = options;\n    const tree = (0,_portabletext_toolkit__WEBPACK_IMPORTED_MODULE_0__.buildMarksTree)(node);\n    const children = tree.map((child, i)=>renderNode({\n            node: child,\n            isInline: true,\n            index: i,\n            renderNode\n        }));\n    return {\n        _key: node._key || \"block-\".concat(index),\n        children,\n        index,\n        isInline,\n        node\n    };\n}\nfunction noop() {}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxNQUFNQSxZQUFZO0lBQUM7SUFBUztJQUFRO0lBQVk7SUFBUztDQUFRLEVBQy9EQyxhQUFhO0lBQUM7Q0FBVyxFQUN6QkMsYUFBYTtJQUFDO0NBQU87QUFDdkIsU0FBU0MsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSUMsT0FBT0MsSUFBSSxDQUFDSjtJQUFJLElBQUlHLE9BQU9FLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsSUFBSUgsT0FBT0UscUJBQXFCLENBQUNMO1FBQUlDLEtBQU1LLENBQUFBLElBQUlBLEVBQUVDLE1BQU0sQ0FBQyxTQUFVTixDQUFDO1lBQUksT0FBT0UsT0FBT0ssd0JBQXdCLENBQUNSLEdBQUdDLEdBQUdRLFVBQVU7UUFBRSxFQUFDLEdBQUlQLEVBQUVRLElBQUksQ0FBQ0MsS0FBSyxDQUFDVCxHQUFHSTtJQUFJO0lBQUUsT0FBT0o7QUFBRztBQUM5UCxTQUFTVSxjQUFjWixDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlZLFVBQVVDLE1BQU0sRUFBRWIsSUFBSztRQUFFLElBQUlDLElBQUksUUFBUVcsU0FBUyxDQUFDWixFQUFFLEdBQUdZLFNBQVMsQ0FBQ1osRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJRixRQUFRSSxPQUFPRCxJQUFJLENBQUMsR0FBR2EsT0FBTyxDQUFDLFNBQVVkLENBQUM7WUFBSWUsZ0JBQWdCaEIsR0FBR0MsR0FBR0MsQ0FBQyxDQUFDRCxFQUFFO1FBQUcsS0FBS0UsT0FBT2MseUJBQXlCLEdBQUdkLE9BQU9lLGdCQUFnQixDQUFDbEIsR0FBR0csT0FBT2MseUJBQXlCLENBQUNmLE1BQU1ILFFBQVFJLE9BQU9ELElBQUlhLE9BQU8sQ0FBQyxTQUFVZCxDQUFDO1lBQUlFLE9BQU9nQixjQUFjLENBQUNuQixHQUFHQyxH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LEtBQUssR0FBRztZQUNyRHFFLFVBQVU7WUFDVjNGLE1BQU0wRSxLQUFLcEQsS0FBSztRQUNsQjtRQUNBLE1BQU1xRixjQUFjaEQsV0FBV1AsV0FBVztRQUMxQyxPQUFPLGFBQWEsR0FBRTVGLHNEQUFHQSxDQUFDbUosYUFBYW5NLGNBQWMsQ0FBQyxHQUFHa00sY0FBY3pMO0lBQ3pFO0lBQ0EsU0FBU2lLLGtCQUFrQlIsSUFBSSxFQUFFQyxLQUFLLEVBQUUxSixHQUFHLEVBQUVtRyxRQUFRO1FBQ25ELE1BQU1zRixjQUFjO1lBQ2xCeEwsT0FBT3dKO1lBQ1B0RDtZQUNBdUQ7WUFDQUw7UUFDRjtRQUNBLE1BQU1zQyxPQUFPakQsV0FBV3pGLEtBQUssQ0FBQ3dHLEtBQUtwRCxLQUFLLENBQUM7UUFDekMsT0FBT3NGLE9BQU8sYUFBYSxHQUFFcEosc0RBQUdBLENBQUNvSixNQUFNcE0sY0FBYyxDQUFDLEdBQUdrTSxjQUFjekwsT0FBTztJQUNoRjtJQUNBLE9BQU9xSjtBQUNUO0FBQ0EsU0FBU2lCLGVBQWVYLE9BQU87SUFDN0IsTUFBTSxFQUNKRixJQUFJLEVBQ0pDLEtBQUssRUFDTHZELFFBQVEsRUFDUmtELFVBQVUsRUFDWCxHQUFHTTtJQUNKLE1BQU1VLE9BQU9oSSxxRUFBY0EsQ0FBQ29IO0lBQzVCLE1BQU1qRyxXQUFXNkcsS0FBS2IsR0FBRyxDQUFDLENBQUNvQixPQUFPckosSUFBTThILFdBQVc7WUFDakRJLE1BQU1tQjtZQUNOekUsVUFBVTtZQUNWdUQsT0FBT25JO1lBQ1A4SDtRQUNGO0lBQ0EsT0FBTztRQUNMTyxNQUFNSCxLQUFLRyxJQUFJLElBQUksU0FBUzNFLE1BQU0sQ0FBQ3lFO1FBQ25DbEc7UUFDQWtHO1FBQ0F2RDtRQUNBc0Q7SUFDRjtBQUNGO0FBQ0EsU0FBU1QsUUFBUTtBQUMyQyxDQUM1RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy9AcG9ydGFibGV0ZXh0L3JlYWN0L2Rpc3QvaW5kZXguanM/YmZjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBfZXhjbHVkZWQgPSBbXCJibG9ja1wiLCBcImxpc3RcIiwgXCJsaXN0SXRlbVwiLCBcIm1hcmtzXCIsIFwidHlwZXNcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJsaXN0SXRlbVwiXSxcbiAgX2V4Y2x1ZGVkMyA9IFtcIl9rZXlcIl07XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuaW1wb3J0IHsgbmVzdExpc3RzLCBMSVNUX05FU1RfTU9ERV9IVE1MLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0LCBpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4sIGlzUG9ydGFibGVUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlLCBzcGFuVG9QbGFpblRleHQsIGJ1aWxkTWFya3NUcmVlIH0gZnJvbSAnQHBvcnRhYmxldGV4dC90b29sa2l0JztcbmV4cG9ydCB7IHRvUGxhaW5UZXh0IH0gZnJvbSAnQHBvcnRhYmxldGV4dC90b29sa2l0JztcbmltcG9ydCB7IGpzeCwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuZnVuY3Rpb24gbWVyZ2VDb21wb25lbnRzKHBhcmVudCwgb3ZlcnJpZGVzKSB7XG4gIGNvbnN0IHtcbiAgICAgIGJsb2NrLFxuICAgICAgbGlzdCxcbiAgICAgIGxpc3RJdGVtLFxuICAgICAgbWFya3MsXG4gICAgICB0eXBlc1xuICAgIH0gPSBvdmVycmlkZXMsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdmVycmlkZXMsIF9leGNsdWRlZCk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudCksIHt9LCB7XG4gICAgYmxvY2s6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImJsb2NrXCIpLFxuICAgIGxpc3Q6IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RcIiksXG4gICAgbGlzdEl0ZW06IG1lcmdlRGVlcGx5KHBhcmVudCwgb3ZlcnJpZGVzLCBcImxpc3RJdGVtXCIpLFxuICAgIG1hcmtzOiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywgXCJtYXJrc1wiKSxcbiAgICB0eXBlczogbWVyZ2VEZWVwbHkocGFyZW50LCBvdmVycmlkZXMsIFwidHlwZXNcIilcbiAgfSwgcmVzdCk7XG59XG5mdW5jdGlvbiBtZXJnZURlZXBseShwYXJlbnQsIG92ZXJyaWRlcywga2V5KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gb3ZlcnJpZGVzW2tleV07XG4gIGNvbnN0IHBhcmVudFZhbCA9IHBhcmVudFtrZXldO1xuICBpZiAodHlwZW9mIG92ZXJyaWRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGU7XG4gIH1cbiAgaWYgKG92ZXJyaWRlICYmIHR5cGVvZiBwYXJlbnRWYWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBvdmVycmlkZTtcbiAgfVxuICBpZiAob3ZlcnJpZGUpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwYXJlbnRWYWwpLCBvdmVycmlkZSk7XG4gIH1cbiAgcmV0dXJuIHBhcmVudFZhbDtcbn1cbmNvbnN0IGxpbmsgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICB2YWx1ZVxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImFcIiwge1xuICAgIGhyZWY6IHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5ocmVmLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbmNvbnN0IHVuZGVybGluZVN0eWxlID0ge1xuICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxufTtcbmNvbnN0IGRlZmF1bHRNYXJrcyA9IHtcbiAgZW06IF9yZWYyID0+IHtcbiAgICBsZXQge1xuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gX3JlZjI7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImVtXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH0sXG4gIHN0cm9uZzogX3JlZjMgPT4ge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmMztcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwic3Ryb25nXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH0sXG4gIGNvZGU6IF9yZWY0ID0+IHtcbiAgICBsZXQge1xuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gX3JlZjQ7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImNvZGVcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KTtcbiAgfSxcbiAgdW5kZXJsaW5lOiBfcmVmNSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IF9yZWY1O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJzcGFuXCIsIHtcbiAgICAgIHN0eWxlOiB1bmRlcmxpbmVTdHlsZSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH0sXG4gIFwic3RyaWtlLXRocm91Z2hcIjogX3JlZjYgPT4ge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmNjtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwiZGVsXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH0sXG4gIGxpbmtcbn07XG5jb25zdCBkZWZhdWx0TGlzdHMgPSB7XG4gIG51bWJlcjogX3JlZjcgPT4ge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmNztcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwib2xcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KTtcbiAgfSxcbiAgYnVsbGV0OiBfcmVmOCA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IF9yZWY4O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJ1bFwiLCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0pO1xuICB9XG59O1xuY29uc3QgRGVmYXVsdExpc3RJdGVtID0gX3JlZjkgPT4ge1xuICBsZXQge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmOTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImxpXCIsIHtcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5jb25zdCBnZXRUZW1wbGF0ZSA9ICh0eXBlLCBwcm9wKSA9PiBcIltAcG9ydGFibGV0ZXh0L3JlYWN0XSBVbmtub3duIFwiLmNvbmNhdCh0eXBlLCBcIiwgc3BlY2lmeSBhIGNvbXBvbmVudCBmb3IgaXQgaW4gdGhlIGBjb21wb25lbnRzLlwiKS5jb25jYXQocHJvcCwgXCJgIHByb3BcIik7XG5jb25zdCB1bmtub3duVHlwZVdhcm5pbmcgPSB0eXBlTmFtZSA9PiBnZXRUZW1wbGF0ZSgnYmxvY2sgdHlwZSBcIicuY29uY2F0KHR5cGVOYW1lLCAnXCInKSwgXCJ0eXBlc1wiKTtcbmNvbnN0IHVua25vd25NYXJrV2FybmluZyA9IG1hcmtUeXBlID0+IGdldFRlbXBsYXRlKCdtYXJrIHR5cGUgXCInLmNvbmNhdChtYXJrVHlwZSwgJ1wiJyksIFwibWFya3NcIik7XG5jb25zdCB1bmtub3duQmxvY2tTdHlsZVdhcm5pbmcgPSBibG9ja1N0eWxlID0+IGdldFRlbXBsYXRlKCdibG9jayBzdHlsZSBcIicuY29uY2F0KGJsb2NrU3R5bGUsICdcIicpLCBcImJsb2NrXCIpO1xuY29uc3QgdW5rbm93bkxpc3RTdHlsZVdhcm5pbmcgPSBsaXN0U3R5bGUgPT4gZ2V0VGVtcGxhdGUoJ2xpc3Qgc3R5bGUgXCInLmNvbmNhdChsaXN0U3R5bGUsICdcIicpLCBcImxpc3RcIik7XG5jb25zdCB1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmcgPSBsaXN0U3R5bGUgPT4gZ2V0VGVtcGxhdGUoJ2xpc3QgaXRlbSBzdHlsZSBcIicuY29uY2F0KGxpc3RTdHlsZSwgJ1wiJyksIFwibGlzdEl0ZW1cIik7XG5mdW5jdGlvbiBwcmludFdhcm5pbmcobWVzc2FnZSkge1xuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59XG5jb25zdCBoaWRkZW4gPSB7XG4gIGRpc3BsYXk6IFwibm9uZVwiXG59O1xuY29uc3QgRGVmYXVsdFVua25vd25UeXBlID0gX3JlZjEwID0+IHtcbiAgbGV0IHtcbiAgICB2YWx1ZSxcbiAgICBpc0lubGluZVxuICB9ID0gX3JlZjEwO1xuICBjb25zdCB3YXJuaW5nID0gdW5rbm93blR5cGVXYXJuaW5nKHZhbHVlLl90eXBlKTtcbiAgcmV0dXJuIGlzSW5saW5lID8gLyogQF9fUFVSRV9fICovanN4KFwic3BhblwiLCB7XG4gICAgc3R5bGU6IGhpZGRlbixcbiAgICBjaGlsZHJlbjogd2FybmluZ1xuICB9KSA6IC8qIEBfX1BVUkVfXyAqL2pzeChcImRpdlwiLCB7XG4gICAgc3R5bGU6IGhpZGRlbixcbiAgICBjaGlsZHJlbjogd2FybmluZ1xuICB9KTtcbn07XG5jb25zdCBEZWZhdWx0VW5rbm93bk1hcmsgPSBfcmVmMTEgPT4ge1xuICBsZXQge1xuICAgIG1hcmtUeXBlLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmMTE7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IFwidW5rbm93bl9fcHRfX21hcmtfX1wiLmNvbmNhdChtYXJrVHlwZSksXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuY29uc3QgRGVmYXVsdFVua25vd25CbG9ja1N0eWxlID0gX3JlZjEyID0+IHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjEyO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwicFwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuY29uc3QgRGVmYXVsdFVua25vd25MaXN0ID0gX3JlZjEzID0+IHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjEzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovanN4KFwidWxcIiwge1xuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbmNvbnN0IERlZmF1bHRVbmtub3duTGlzdEl0ZW0gPSBfcmVmMTQgPT4ge1xuICBsZXQge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmMTQ7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJsaVwiLCB7XG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuY29uc3QgRGVmYXVsdEhhcmRCcmVhayA9ICgpID0+IC8qIEBfX1BVUkVfXyAqL2pzeChcImJyXCIsIHt9KTtcbmNvbnN0IGRlZmF1bHRCbG9ja1N0eWxlcyA9IHtcbiAgbm9ybWFsOiBfcmVmMTUgPT4ge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmMTU7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcInBcIiwge1xuICAgICAgY2hpbGRyZW5cbiAgICB9KTtcbiAgfSxcbiAgYmxvY2txdW90ZTogX3JlZjE2ID0+IHtcbiAgICBsZXQge1xuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gX3JlZjE2O1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goXCJibG9ja3F1b3RlXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH0sXG4gIGgxOiBfcmVmMTcgPT4ge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmMTc7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImgxXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH0sXG4gIGgyOiBfcmVmMTggPT4ge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmMTg7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImgyXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH0sXG4gIGgzOiBfcmVmMTkgPT4ge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmMTk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImgzXCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH0sXG4gIGg0OiBfcmVmMjAgPT4ge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmMjA7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImg0XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH0sXG4gIGg1OiBfcmVmMjEgPT4ge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmMjE7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImg1XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH0sXG4gIGg2OiBfcmVmMjIgPT4ge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmMjI7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChcImg2XCIsIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSk7XG4gIH1cbn07XG5jb25zdCBkZWZhdWx0Q29tcG9uZW50cyA9IHtcbiAgdHlwZXM6IHt9LFxuICBibG9jazogZGVmYXVsdEJsb2NrU3R5bGVzLFxuICBtYXJrczogZGVmYXVsdE1hcmtzLFxuICBsaXN0OiBkZWZhdWx0TGlzdHMsXG4gIGxpc3RJdGVtOiBEZWZhdWx0TGlzdEl0ZW0sXG4gIGhhcmRCcmVhazogRGVmYXVsdEhhcmRCcmVhayxcbiAgdW5rbm93blR5cGU6IERlZmF1bHRVbmtub3duVHlwZSxcbiAgdW5rbm93bk1hcms6IERlZmF1bHRVbmtub3duTWFyayxcbiAgdW5rbm93bkxpc3Q6IERlZmF1bHRVbmtub3duTGlzdCxcbiAgdW5rbm93bkxpc3RJdGVtOiBEZWZhdWx0VW5rbm93bkxpc3RJdGVtLFxuICB1bmtub3duQmxvY2tTdHlsZTogRGVmYXVsdFVua25vd25CbG9ja1N0eWxlXG59O1xuZnVuY3Rpb24gUG9ydGFibGVUZXh0KF9yZWYyMykge1xuICBsZXQge1xuICAgIHZhbHVlOiBpbnB1dCxcbiAgICBjb21wb25lbnRzOiBjb21wb25lbnRPdmVycmlkZXMsXG4gICAgbGlzdE5lc3RpbmdNb2RlLFxuICAgIG9uTWlzc2luZ0NvbXBvbmVudDogbWlzc2luZ0NvbXBvbmVudEhhbmRsZXIgPSBwcmludFdhcm5pbmdcbiAgfSA9IF9yZWYyMztcbiAgY29uc3QgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCA9IG1pc3NpbmdDb21wb25lbnRIYW5kbGVyIHx8IG5vb3A7XG4gIGNvbnN0IGJsb2NrcyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICBjb25zdCBuZXN0ZWQgPSBuZXN0TGlzdHMoYmxvY2tzLCBsaXN0TmVzdGluZ01vZGUgfHwgTElTVF9ORVNUX01PREVfSFRNTCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gY29tcG9uZW50T3ZlcnJpZGVzID8gbWVyZ2VDb21wb25lbnRzKGRlZmF1bHRDb21wb25lbnRzLCBjb21wb25lbnRPdmVycmlkZXMpIDogZGVmYXVsdENvbXBvbmVudHM7XG4gIH0sIFtjb21wb25lbnRPdmVycmlkZXNdKTtcbiAgY29uc3QgcmVuZGVyTm9kZSA9IHVzZU1lbW8oKCkgPT4gZ2V0Tm9kZVJlbmRlcmVyKGNvbXBvbmVudHMsIGhhbmRsZU1pc3NpbmdDb21wb25lbnQpLCBbY29tcG9uZW50cywgaGFuZGxlTWlzc2luZ0NvbXBvbmVudF0pO1xuICBjb25zdCByZW5kZXJlZCA9IG5lc3RlZC5tYXAoKG5vZGUsIGluZGV4KSA9PiByZW5kZXJOb2RlKHtcbiAgICBub2RlLFxuICAgIGluZGV4LFxuICAgIGlzSW5saW5lOiBmYWxzZSxcbiAgICByZW5kZXJOb2RlXG4gIH0pKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiByZW5kZXJlZFxuICB9KTtcbn1cbmNvbnN0IGdldE5vZGVSZW5kZXJlciA9IChjb21wb25lbnRzLCBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KSA9PiB7XG4gIGZ1bmN0aW9uIHJlbmRlck5vZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qga2V5ID0gbm9kZS5fa2V5IHx8IFwibm9kZS1cIi5jb25jYXQoaW5kZXgpO1xuICAgIGlmIChpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gcmVuZGVyTGlzdChub2RlLCBpbmRleCwga2V5KTtcbiAgICB9XG4gICAgaWYgKGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhub2RlKSkge1xuICAgICAgcmV0dXJuIHJlbmRlckxpc3RJdGVtKG5vZGUsIGluZGV4LCBrZXkpO1xuICAgIH1cbiAgICBpZiAoaXNQb3J0YWJsZVRleHRUb29sa2l0U3Bhbihub2RlKSkge1xuICAgICAgcmV0dXJuIHJlbmRlclNwYW4obm9kZSwgaW5kZXgsIGtleSk7XG4gICAgfVxuICAgIGlmIChoYXNDdXN0b21Db21wb25lbnRGb3JOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gcmVuZGVyQ3VzdG9tQmxvY2sobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpO1xuICAgIH1cbiAgICBpZiAoaXNQb3J0YWJsZVRleHRCbG9jayhub2RlKSkge1xuICAgICAgcmV0dXJuIHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKTtcbiAgICB9XG4gICAgaWYgKGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gcmVuZGVyVGV4dChub2RlLCBrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyVW5rbm93blR5cGUobm9kZSwgaW5kZXgsIGtleSwgaXNJbmxpbmUpO1xuICB9XG4gIGZ1bmN0aW9uIGhhc0N1c3RvbUNvbXBvbmVudEZvck5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLl90eXBlIGluIGNvbXBvbmVudHMudHlwZXM7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdEl0ZW0obm9kZSwgaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHRyZWUgPSBzZXJpYWxpemVCbG9jayh7XG4gICAgICBub2RlLFxuICAgICAgaW5kZXgsXG4gICAgICBpc0lubGluZTogZmFsc2UsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSk7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBjb21wb25lbnRzLmxpc3RJdGVtO1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0eXBlb2YgcmVuZGVyZXIgPT09IFwiZnVuY3Rpb25cIiA/IHJlbmRlcmVyIDogcmVuZGVyZXJbbm9kZS5saXN0SXRlbV07XG4gICAgY29uc3QgTGkgPSBoYW5kbGVyIHx8IGNvbXBvbmVudHMudW5rbm93bkxpc3RJdGVtO1xuICAgIGlmIChMaSA9PT0gY29tcG9uZW50cy51bmtub3duTGlzdEl0ZW0pIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5saXN0SXRlbSB8fCBcImJ1bGxldFwiO1xuICAgICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICAgIHR5cGU6IHN0eWxlLFxuICAgICAgICBub2RlVHlwZTogXCJsaXN0SXRlbVN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xuICAgIGlmIChub2RlLnN0eWxlICYmIG5vZGUuc3R5bGUgIT09IFwibm9ybWFsXCIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsaXN0SXRlbVxuICAgICAgICB9ID0gbm9kZSxcbiAgICAgICAgYmxvY2tOb2RlID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIpO1xuICAgICAgY2hpbGRyZW4gPSByZW5kZXJOb2RlKHtcbiAgICAgICAgbm9kZTogYmxvY2tOb2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmU6IGZhbHNlLFxuICAgICAgICByZW5kZXJOb2RlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChMaSwge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lOiBmYWxzZSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0sIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdChub2RlLCBpbmRleCwga2V5KSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHJlbmRlck5vZGUoe1xuICAgICAgbm9kZTogY2hpbGQuX2tleSA/IGNoaWxkIDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjaGlsZCksIHt9LCB7XG4gICAgICAgIF9rZXk6IFwibGktXCIuY29uY2F0KGluZGV4LCBcIi1cIikuY29uY2F0KGNoaWxkSW5kZXgpXG4gICAgICB9KSxcbiAgICAgIGluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgaXNJbmxpbmU6IGZhbHNlLFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH0pKTtcbiAgICBjb25zdCBjb21wb25lbnQgPSBjb21wb25lbnRzLmxpc3Q7XG4gICAgY29uc3QgaGFuZGxlciA9IHR5cGVvZiBjb21wb25lbnQgPT09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudCA6IGNvbXBvbmVudFtub2RlLmxpc3RJdGVtXTtcbiAgICBjb25zdCBMaXN0ID0gaGFuZGxlciB8fCBjb21wb25lbnRzLnVua25vd25MaXN0O1xuICAgIGlmIChMaXN0ID09PSBjb21wb25lbnRzLnVua25vd25MaXN0KSB7XG4gICAgICBjb25zdCBzdHlsZSA9IG5vZGUubGlzdEl0ZW0gfHwgXCJidWxsZXRcIjtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkxpc3RTdHlsZVdhcm5pbmcoc3R5bGUpLCB7XG4gICAgICAgIG5vZGVUeXBlOiBcImxpc3RTdHlsZVwiLFxuICAgICAgICB0eXBlOiBzdHlsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goTGlzdCwge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpbmRleCxcbiAgICAgIGlzSW5saW5lOiBmYWxzZSxcbiAgICAgIHJlbmRlck5vZGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0sIGtleSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVuZGVyU3Bhbihub2RlLCBfaW5kZXgsIGtleSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcmtEZWYsXG4gICAgICBtYXJrVHlwZSxcbiAgICAgIG1hcmtLZXlcbiAgICB9ID0gbm9kZTtcbiAgICBjb25zdCBTcGFuID0gY29tcG9uZW50cy5tYXJrc1ttYXJrVHlwZV0gfHwgY29tcG9uZW50cy51bmtub3duTWFyaztcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4ubWFwKChjaGlsZCwgY2hpbGRJbmRleCkgPT4gcmVuZGVyTm9kZSh7XG4gICAgICBub2RlOiBjaGlsZCxcbiAgICAgIGluZGV4OiBjaGlsZEluZGV4LFxuICAgICAgaXNJbmxpbmU6IHRydWUsXG4gICAgICByZW5kZXJOb2RlXG4gICAgfSkpO1xuICAgIGlmIChTcGFuID09PSBjb21wb25lbnRzLnVua25vd25NYXJrKSB7XG4gICAgICBoYW5kbGVNaXNzaW5nQ29tcG9uZW50KHVua25vd25NYXJrV2FybmluZyhtYXJrVHlwZSksIHtcbiAgICAgICAgbm9kZVR5cGU6IFwibWFya1wiLFxuICAgICAgICB0eXBlOiBtYXJrVHlwZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goU3Bhbiwge1xuICAgICAgdGV4dDogc3BhblRvUGxhaW5UZXh0KG5vZGUpLFxuICAgICAgdmFsdWU6IG1hcmtEZWYsXG4gICAgICBtYXJrVHlwZSxcbiAgICAgIG1hcmtLZXksXG4gICAgICByZW5kZXJOb2RlLFxuICAgICAgY2hpbGRyZW5cbiAgICB9LCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbmRlckJsb2NrKG5vZGUsIGluZGV4LCBrZXksIGlzSW5saW5lKSB7XG4gICAgY29uc3QgX3NlcmlhbGl6ZUJsb2NrID0gc2VyaWFsaXplQmxvY2soe1xuICAgICAgICBub2RlLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaXNJbmxpbmUsXG4gICAgICAgIHJlbmRlck5vZGVcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBfa2V5XG4gICAgICB9ID0gX3NlcmlhbGl6ZUJsb2NrLFxuICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3NlcmlhbGl6ZUJsb2NrLCBfZXhjbHVkZWQzKTtcbiAgICBjb25zdCBzdHlsZSA9IHByb3BzLm5vZGUuc3R5bGUgfHwgXCJub3JtYWxcIjtcbiAgICBjb25zdCBoYW5kbGVyID0gdHlwZW9mIGNvbXBvbmVudHMuYmxvY2sgPT09IFwiZnVuY3Rpb25cIiA/IGNvbXBvbmVudHMuYmxvY2sgOiBjb21wb25lbnRzLmJsb2NrW3N0eWxlXTtcbiAgICBjb25zdCBCbG9jayA9IGhhbmRsZXIgfHwgY29tcG9uZW50cy51bmtub3duQmxvY2tTdHlsZTtcbiAgICBpZiAoQmxvY2sgPT09IGNvbXBvbmVudHMudW5rbm93bkJsb2NrU3R5bGUpIHtcbiAgICAgIGhhbmRsZU1pc3NpbmdDb21wb25lbnQodW5rbm93bkJsb2NrU3R5bGVXYXJuaW5nKHN0eWxlKSwge1xuICAgICAgICBub2RlVHlwZTogXCJibG9ja1N0eWxlXCIsXG4gICAgICAgIHR5cGU6IHN0eWxlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqL2pzeChCbG9jaywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICB2YWx1ZTogcHJvcHMubm9kZSxcbiAgICAgIHJlbmRlck5vZGVcbiAgICB9KSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJUZXh0KG5vZGUsIGtleSkge1xuICAgIGlmIChub2RlLnRleHQgPT09IFwiXFxuXCIpIHtcbiAgICAgIGNvbnN0IEhhcmRCcmVhayA9IGNvbXBvbmVudHMuaGFyZEJyZWFrO1xuICAgICAgcmV0dXJuIEhhcmRCcmVhayA/IC8qIEBfX1BVUkVfXyAqL2pzeChIYXJkQnJlYWssIHt9LCBrZXkpIDogXCJcXG5cIjtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudGV4dDtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJVbmtub3duVHlwZShub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGVPcHRpb25zID0ge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpc0lubGluZSxcbiAgICAgIGluZGV4LFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH07XG4gICAgaGFuZGxlTWlzc2luZ0NvbXBvbmVudCh1bmtub3duVHlwZVdhcm5pbmcobm9kZS5fdHlwZSksIHtcbiAgICAgIG5vZGVUeXBlOiBcImJsb2NrXCIsXG4gICAgICB0eXBlOiBub2RlLl90eXBlXG4gICAgfSk7XG4gICAgY29uc3QgVW5rbm93blR5cGUgPSBjb21wb25lbnRzLnVua25vd25UeXBlO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi9qc3goVW5rbm93blR5cGUsIF9vYmplY3RTcHJlYWQoe30sIG5vZGVPcHRpb25zKSwga2V5KTtcbiAgfVxuICBmdW5jdGlvbiByZW5kZXJDdXN0b21CbG9jayhub2RlLCBpbmRleCwga2V5LCBpc0lubGluZSkge1xuICAgIGNvbnN0IG5vZGVPcHRpb25zID0ge1xuICAgICAgdmFsdWU6IG5vZGUsXG4gICAgICBpc0lubGluZSxcbiAgICAgIGluZGV4LFxuICAgICAgcmVuZGVyTm9kZVxuICAgIH07XG4gICAgY29uc3QgTm9kZSA9IGNvbXBvbmVudHMudHlwZXNbbm9kZS5fdHlwZV07XG4gICAgcmV0dXJuIE5vZGUgPyAvKiBAX19QVVJFX18gKi9qc3goTm9kZSwgX29iamVjdFNwcmVhZCh7fSwgbm9kZU9wdGlvbnMpLCBrZXkpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gcmVuZGVyTm9kZTtcbn07XG5mdW5jdGlvbiBzZXJpYWxpemVCbG9jayhvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlLFxuICAgIGluZGV4LFxuICAgIGlzSW5saW5lLFxuICAgIHJlbmRlck5vZGVcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHRyZWUgPSBidWlsZE1hcmtzVHJlZShub2RlKTtcbiAgY29uc3QgY2hpbGRyZW4gPSB0cmVlLm1hcCgoY2hpbGQsIGkpID0+IHJlbmRlck5vZGUoe1xuICAgIG5vZGU6IGNoaWxkLFxuICAgIGlzSW5saW5lOiB0cnVlLFxuICAgIGluZGV4OiBpLFxuICAgIHJlbmRlck5vZGVcbiAgfSkpO1xuICByZXR1cm4ge1xuICAgIF9rZXk6IG5vZGUuX2tleSB8fCBcImJsb2NrLVwiLmNvbmNhdChpbmRleCksXG4gICAgY2hpbGRyZW4sXG4gICAgaW5kZXgsXG4gICAgaXNJbmxpbmUsXG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHt9XG5leHBvcnQgeyBQb3J0YWJsZVRleHQsIGRlZmF1bHRDb21wb25lbnRzLCBtZXJnZUNvbXBvbmVudHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJfZXhjbHVkZWQzIiwib3duS2V5cyIsImUiLCJyIiwidCIsIk9iamVjdCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJvIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsImtleSIsInZhbHVlIiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFyZyIsIl90b1ByaW1pdGl2ZSIsIlN0cmluZyIsImlucHV0IiwiaGludCIsInByaW0iLCJTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsInJlcyIsImNhbGwiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2UiLCJleGNsdWRlZCIsInRhcmdldCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiaSIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvdG90eXBlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzb3VyY2VLZXlzIiwibmVzdExpc3RzIiwiTElTVF9ORVNUX01PREVfSFRNTCIsImlzUG9ydGFibGVUZXh0VG9vbGtpdExpc3QiLCJpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2siLCJpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuIiwiaXNQb3J0YWJsZVRleHRCbG9jayIsImlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlIiwic3BhblRvUGxhaW5UZXh0IiwiYnVpbGRNYXJrc1RyZWUiLCJ0b1BsYWluVGV4dCIsImpzeCIsIkZyYWdtZW50IiwidXNlTWVtbyIsIm1lcmdlQ29tcG9uZW50cyIsInBhcmVudCIsIm92ZXJyaWRlcyIsImJsb2NrIiwibGlzdCIsImxpc3RJdGVtIiwibWFya3MiLCJ0eXBlcyIsInJlc3QiLCJtZXJnZURlZXBseSIsIm92ZXJyaWRlIiwicGFyZW50VmFsIiwibGluayIsIl9yZWYiLCJjaGlsZHJlbiIsImhyZWYiLCJ1bmRlcmxpbmVTdHlsZSIsInRleHREZWNvcmF0aW9uIiwiZGVmYXVsdE1hcmtzIiwiZW0iLCJfcmVmMiIsInN0cm9uZyIsIl9yZWYzIiwiY29kZSIsIl9yZWY0IiwidW5kZXJsaW5lIiwiX3JlZjUiLCJzdHlsZSIsIl9yZWY2IiwiZGVmYXVsdExpc3RzIiwibnVtYmVyIiwiX3JlZjciLCJidWxsZXQiLCJfcmVmOCIsIkRlZmF1bHRMaXN0SXRlbSIsIl9yZWY5IiwiZ2V0VGVtcGxhdGUiLCJ0eXBlIiwicHJvcCIsImNvbmNhdCIsInVua25vd25UeXBlV2FybmluZyIsInR5cGVOYW1lIiwidW5rbm93bk1hcmtXYXJuaW5nIiwibWFya1R5cGUiLCJ1bmtub3duQmxvY2tTdHlsZVdhcm5pbmciLCJibG9ja1N0eWxlIiwidW5rbm93bkxpc3RTdHlsZVdhcm5pbmciLCJsaXN0U3R5bGUiLCJ1bmtub3duTGlzdEl0ZW1TdHlsZVdhcm5pbmciLCJwcmludFdhcm5pbmciLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iLCJoaWRkZW4iLCJkaXNwbGF5IiwiRGVmYXVsdFVua25vd25UeXBlIiwiX3JlZjEwIiwiaXNJbmxpbmUiLCJ3YXJuaW5nIiwiX3R5cGUiLCJEZWZhdWx0VW5rbm93bk1hcmsiLCJfcmVmMTEiLCJjbGFzc05hbWUiLCJEZWZhdWx0VW5rbm93bkJsb2NrU3R5bGUiLCJfcmVmMTIiLCJEZWZhdWx0VW5rbm93bkxpc3QiLCJfcmVmMTMiLCJEZWZhdWx0VW5rbm93bkxpc3RJdGVtIiwiX3JlZjE0IiwiRGVmYXVsdEhhcmRCcmVhayIsImRlZmF1bHRCbG9ja1N0eWxlcyIsIm5vcm1hbCIsIl9yZWYxNSIsImJsb2NrcXVvdGUiLCJfcmVmMTYiLCJoMSIsIl9yZWYxNyIsImgyIiwiX3JlZjE4IiwiaDMiLCJfcmVmMTkiLCJoNCIsIl9yZWYyMCIsImg1IiwiX3JlZjIxIiwiaDYiLCJfcmVmMjIiLCJkZWZhdWx0Q29tcG9uZW50cyIsImhhcmRCcmVhayIsInVua25vd25UeXBlIiwidW5rbm93bk1hcmsiLCJ1bmtub3duTGlzdCIsInVua25vd25MaXN0SXRlbSIsInVua25vd25CbG9ja1N0eWxlIiwiUG9ydGFibGVUZXh0IiwiX3JlZjIzIiwiY29tcG9uZW50cyIsImNvbXBvbmVudE92ZXJyaWRlcyIsImxpc3ROZXN0aW5nTW9kZSIsIm9uTWlzc2luZ0NvbXBvbmVudCIsIm1pc3NpbmdDb21wb25lbnRIYW5kbGVyIiwiaGFuZGxlTWlzc2luZ0NvbXBvbmVudCIsIm5vb3AiLCJibG9ja3MiLCJBcnJheSIsImlzQXJyYXkiLCJuZXN0ZWQiLCJyZW5kZXJOb2RlIiwiZ2V0Tm9kZVJlbmRlcmVyIiwicmVuZGVyZWQiLCJtYXAiLCJub2RlIiwiaW5kZXgiLCJvcHRpb25zIiwiX2tleSIsInJlbmRlckxpc3QiLCJyZW5kZXJMaXN0SXRlbSIsInJlbmRlclNwYW4iLCJoYXNDdXN0b21Db21wb25lbnRGb3JOb2RlIiwicmVuZGVyQ3VzdG9tQmxvY2siLCJyZW5kZXJCbG9jayIsInJlbmRlclRleHQiLCJyZW5kZXJVbmtub3duVHlwZSIsInRyZWUiLCJzZXJpYWxpemVCbG9jayIsInJlbmRlcmVyIiwiaGFuZGxlciIsIkxpIiwibm9kZVR5cGUiLCJibG9ja05vZGUiLCJjaGlsZCIsImNoaWxkSW5kZXgiLCJjb21wb25lbnQiLCJMaXN0IiwiX2luZGV4IiwibWFya0RlZiIsIm1hcmtLZXkiLCJTcGFuIiwidGV4dCIsIl9zZXJpYWxpemVCbG9jayIsInByb3BzIiwiQmxvY2siLCJIYXJkQnJlYWsiLCJub2RlT3B0aW9ucyIsIlVua25vd25UeXBlIiwiTm9kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@portabletext/toolkit/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@portabletext/toolkit/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LIST_NEST_MODE_DIRECT: () => (/* binding */ LIST_NEST_MODE_DIRECT),\n/* harmony export */   LIST_NEST_MODE_HTML: () => (/* binding */ LIST_NEST_MODE_HTML),\n/* harmony export */   buildMarksTree: () => (/* binding */ buildMarksTree),\n/* harmony export */   isPortableTextBlock: () => (/* binding */ isPortableTextBlock),\n/* harmony export */   isPortableTextListItemBlock: () => (/* binding */ isPortableTextListItemBlock),\n/* harmony export */   isPortableTextSpan: () => (/* binding */ isPortableTextSpan),\n/* harmony export */   isPortableTextToolkitList: () => (/* binding */ isPortableTextToolkitList),\n/* harmony export */   isPortableTextToolkitSpan: () => (/* binding */ isPortableTextToolkitSpan),\n/* harmony export */   isPortableTextToolkitTextNode: () => (/* binding */ isPortableTextToolkitTextNode),\n/* harmony export */   nestLists: () => (/* binding */ nestLists),\n/* harmony export */   sortMarksByOccurences: () => (/* binding */ sortMarksByOccurences),\n/* harmony export */   spanToPlainText: () => (/* binding */ spanToPlainText),\n/* harmony export */   toPlainText: () => (/* binding */ toPlainText)\n/* harmony export */ });\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction isPortableTextSpan(node) {\n    return node._type === \"span\" && \"text\" in node && typeof node.text === \"string\" && (typeof node.marks === \"undefined\" || Array.isArray(node.marks) && node.marks.every((mark)=>typeof mark === \"string\"));\n}\nfunction isPortableTextBlock(node) {\n    return(// A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === \"string\" && // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== \"@\" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!(\"markDefs\" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans\n    node.markDefs.every((def)=>typeof def._key === \"string\")) && // `children` is required and needs to be an array\n    \"children\" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child)=>typeof child === \"object\" && \"_type\" in child));\n}\nfunction isPortableTextListItemBlock(block) {\n    return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem === \"string\" && (typeof block.level === \"undefined\" || typeof block.level === \"number\");\n}\nfunction isPortableTextToolkitList(block) {\n    return block._type === \"@list\";\n}\nfunction isPortableTextToolkitSpan(span) {\n    return span._type === \"@span\";\n}\nfunction isPortableTextToolkitTextNode(node) {\n    return node._type === \"@text\";\n}\nconst knownDecorators = [\n    \"strong\",\n    \"em\",\n    \"code\",\n    \"underline\",\n    \"strike-through\"\n];\nfunction sortMarksByOccurences(span, index, blockChildren) {\n    if (!isPortableTextSpan(span) || !span.marks) {\n        return [];\n    }\n    if (!span.marks.length) {\n        return [];\n    }\n    const marks = span.marks.slice();\n    const occurences = {};\n    marks.forEach((mark)=>{\n        occurences[mark] = 1;\n        for(let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++){\n            const sibling = blockChildren[siblingIndex];\n            if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n                occurences[mark]++;\n            } else {\n                break;\n            }\n        }\n    });\n    return marks.sort((markA, markB)=>sortMarks(occurences, markA, markB));\n}\nfunction sortMarks(occurences, markA, markB) {\n    const aOccurences = occurences[markA];\n    const bOccurences = occurences[markB];\n    if (aOccurences !== bOccurences) {\n        return bOccurences - aOccurences;\n    }\n    const aKnownPos = knownDecorators.indexOf(markA);\n    const bKnownPos = knownDecorators.indexOf(markB);\n    if (aKnownPos !== bKnownPos) {\n        return aKnownPos - bKnownPos;\n    }\n    return markA.localeCompare(markB);\n}\nfunction buildMarksTree(block) {\n    var _a;\n    const { children, markDefs = [] } = block;\n    if (!children || !children.length) {\n        return [];\n    }\n    const sortedMarks = children.map(sortMarksByOccurences);\n    const rootNode = {\n        _type: \"@span\",\n        children: [],\n        markType: \"<unknown>\"\n    };\n    let nodeStack = [\n        rootNode\n    ];\n    for(let i = 0; i < children.length; i++){\n        const span = children[i];\n        if (!span) {\n            continue;\n        }\n        const marksNeeded = sortedMarks[i] || [];\n        let pos = 1;\n        if (nodeStack.length > 1) {\n            for(pos; pos < nodeStack.length; pos++){\n                const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\";\n                const index = marksNeeded.indexOf(mark);\n                if (index === -1) {\n                    break;\n                }\n                marksNeeded.splice(index, 1);\n            }\n        }\n        nodeStack = nodeStack.slice(0, pos);\n        let currentNode = nodeStack[nodeStack.length - 1];\n        if (!currentNode) {\n            continue;\n        }\n        for (const markKey of marksNeeded){\n            const markDef = markDefs.find((def)=>def._key === markKey);\n            const markType = markDef ? markDef._type : markKey;\n            const node = {\n                _type: \"@span\",\n                _key: span._key,\n                children: [],\n                markDef,\n                markType,\n                markKey\n            };\n            currentNode.children.push(node);\n            nodeStack.push(node);\n            currentNode = node;\n        }\n        if (isPortableTextSpan(span)) {\n            const lines = span.text.split(\"\\n\");\n            for(let line = lines.length; line-- > 1;){\n                lines.splice(line, 0, \"\\n\");\n            }\n            currentNode.children = currentNode.children.concat(lines.map((text)=>({\n                    _type: \"@text\",\n                    text\n                })));\n        } else {\n            currentNode.children = currentNode.children.concat(span);\n        }\n    }\n    return rootNode.children;\n}\nfunction nestLists(blocks, mode) {\n    const tree = [];\n    let currentList;\n    for(let i = 0; i < blocks.length; i++){\n        const block = blocks[i];\n        if (!block) {\n            continue;\n        }\n        if (!isPortableTextListItemBlock(block)) {\n            tree.push(block);\n            currentList = void 0;\n            continue;\n        }\n        if (!currentList) {\n            currentList = listFromBlock(block, i, mode);\n            tree.push(currentList);\n            continue;\n        }\n        if (blockMatchesList(block, currentList)) {\n            currentList.children.push(block);\n            continue;\n        }\n        if ((block.level || 1) > currentList.level) {\n            const newList = listFromBlock(block, i, mode);\n            if (mode === \"html\") {\n                const lastListItem = currentList.children[currentList.children.length - 1];\n                const newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {\n                    children: [\n                        ...lastListItem.children,\n                        newList\n                    ]\n                });\n                currentList.children[currentList.children.length - 1] = newLastChild;\n            } else {\n                currentList.children.push(newList);\n            }\n            currentList = newList;\n            continue;\n        }\n        if ((block.level || 1) < currentList.level) {\n            const matchingBranch = tree[tree.length - 1];\n            const match = matchingBranch && findListMatching(matchingBranch, block);\n            if (match) {\n                currentList = match;\n                currentList.children.push(block);\n                continue;\n            }\n            currentList = listFromBlock(block, i, mode);\n            tree.push(currentList);\n            continue;\n        }\n        if (block.listItem !== currentList.listItem) {\n            const matchingBranch = tree[tree.length - 1];\n            const match = matchingBranch && findListMatching(matchingBranch, {\n                level: block.level || 1\n            });\n            if (match && match.listItem === block.listItem) {\n                currentList = match;\n                currentList.children.push(block);\n                continue;\n            } else {\n                currentList = listFromBlock(block, i, mode);\n                tree.push(currentList);\n                continue;\n            }\n        }\n        console.warn(\"Unknown state encountered for block\", block);\n        tree.push(block);\n    }\n    return tree;\n}\nfunction blockMatchesList(block, list) {\n    return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\nfunction listFromBlock(block, index, mode) {\n    return {\n        _type: \"@list\",\n        _key: \"\".concat(block._key || \"\".concat(index), \"-parent\"),\n        mode,\n        level: block.level || 1,\n        listItem: block.listItem,\n        children: [\n            block\n        ]\n    };\n}\nfunction findListMatching(rootNode, matching) {\n    const level = matching.level || 1;\n    const style = matching.listItem || \"normal\";\n    const filterOnType = typeof matching.listItem === \"string\";\n    if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) {\n        return rootNode;\n    }\n    if (!(\"children\" in rootNode)) {\n        return void 0;\n    }\n    const node = rootNode.children[rootNode.children.length - 1];\n    return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\nconst leadingSpace = /^\\s/;\nconst trailingSpace = /^\\s/;\nfunction toPlainText(block) {\n    const blocks = Array.isArray(block) ? block : [\n        block\n    ];\n    let text = \"\";\n    blocks.forEach((current, index)=>{\n        if (!isPortableTextBlock(current)) {\n            return;\n        }\n        let pad = false;\n        current.children.forEach((span)=>{\n            if (isPortableTextSpan(span)) {\n                text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\";\n                text += span.text;\n                pad = false;\n            } else {\n                pad = true;\n            }\n        });\n        if (index !== blocks.length - 1) {\n            text += \"\\n\\n\";\n        }\n    });\n    return text;\n}\nfunction spanToPlainText(span) {\n    let text = \"\";\n    span.children.forEach((current)=>{\n        if (isPortableTextToolkitTextNode(current)) {\n            text += current.text;\n        } else if (isPortableTextToolkitSpan(current)) {\n            text += spanToPlainText(current);\n        }\n    });\n    return text;\n}\nconst LIST_NEST_MODE_HTML = \"html\";\nconst LIST_NEST_MODE_DIRECT = \"direct\";\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLFFBQVFDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUlDLElBQUlDLE9BQU9DLElBQUksQ0FBQ0o7SUFBSSxJQUFJRyxPQUFPRSxxQkFBcUIsRUFBRTtRQUFFLElBQUlDLElBQUlILE9BQU9FLHFCQUFxQixDQUFDTDtRQUFJQyxLQUFNSyxDQUFBQSxJQUFJQSxFQUFFQyxNQUFNLENBQUMsU0FBVU4sQ0FBQztZQUFJLE9BQU9FLE9BQU9LLHdCQUF3QixDQUFDUixHQUFHQyxHQUFHUSxVQUFVO1FBQUUsRUFBQyxHQUFJUCxFQUFFUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsR0FBR0k7SUFBSTtJQUFFLE9BQU9KO0FBQUc7QUFDOVAsU0FBU1UsY0FBY1osQ0FBQztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJWSxVQUFVQyxNQUFNLEVBQUViLElBQUs7UUFBRSxJQUFJQyxJQUFJLFFBQVFXLFNBQVMsQ0FBQ1osRUFBRSxHQUFHWSxTQUFTLENBQUNaLEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSUYsUUFBUUksT0FBT0QsSUFBSSxDQUFDLEdBQUdhLE9BQU8sQ0FBQyxTQUFVZCxDQUFDO1lBQUllLGdCQUFnQmhCLEdBQUdDLEdBQUdDLENBQUMsQ0FBQ0QsRUFBRTtRQUFHLEtBQUtFLE9BQU9jLHlCQUF5QixHQUFHZCxPQUFPZSxnQkFBZ0IsQ0FBQ2xCLEdBQUdHLE9BQU9jLHlCQUF5QixDQUFDZixNQUFNSCxRQUFRSSxPQUFPRCxJQUFJYSxPQUFPLENBQUMsU0FBVWQsQ0FBQztZQUFJRSxPQUFPZ0IsY0FBYyxDQUFDbkIsR0FBR0MsR0FBR0UsT0FBT0ssd0JBQXdCLENBQUNOLEdBQUdEO1FBQUs7SUFBSTtJQUFFLE9BQU9EO0FBQUc7QUFDdGIsU0FBU2dCLGdCQUFnQkksR0FBRyxF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QUFJMUQsVUFBVW9DLE9BQU90RixNQUFNLEdBQUcsR0FBRztZQUMvQjRCLFFBQVE7UUFDVjtJQUNGO0lBQ0EsT0FBT0E7QUFDVDtBQUNBLFNBQVNrRixnQkFBZ0JoRSxJQUFJO0lBQzNCLElBQUlsQixPQUFPO0lBQ1hrQixLQUFLUixRQUFRLENBQUNyQyxPQUFPLENBQUMwRyxDQUFBQTtRQUNwQixJQUFJNUQsOEJBQThCNEQsVUFBVTtZQUMxQy9FLFFBQVErRSxRQUFRL0UsSUFBSTtRQUN0QixPQUFPLElBQUlpQiwwQkFBMEI4RCxVQUFVO1lBQzdDL0UsUUFBUWtGLGdCQUFnQkg7UUFDMUI7SUFDRjtJQUNBLE9BQU8vRTtBQUNUO0FBQ0EsTUFBTW1GLHNCQUFzQjtBQUM1QixNQUFNQyx3QkFBd0I7QUFDbVEsQ0FDalMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC90b29sa2l0L2Rpc3QvaW5kZXguanM/YjA0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHsgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpOyByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7IH1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcInNwYW5cIiAmJiBcInRleHRcIiBpbiBub2RlICYmIHR5cGVvZiBub2RlLnRleHQgPT09IFwic3RyaW5nXCIgJiYgKHR5cGVvZiBub2RlLm1hcmtzID09PSBcInVuZGVmaW5lZFwiIHx8IEFycmF5LmlzQXJyYXkobm9kZS5tYXJrcykgJiYgbm9kZS5tYXJrcy5ldmVyeShtYXJrID0+IHR5cGVvZiBtYXJrID09PSBcInN0cmluZ1wiKSk7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dEJsb2NrKG5vZGUpIHtcbiAgcmV0dXJuIChcbiAgICAvLyBBIGJsb2NrIGRvZXNuJ3QgX2hhdmVfIHRvIGJlIG5hbWVkICdibG9jaycgLSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW5cbiAgICAvLyBhbGxvd2VkIGNoaWxkIHR5cGVzIGFuZCBtYXJrcywgb25lIG1pZ2h0IG5hbWUgdGhlbSBkaWZmZXJlbnRseVxuICAgIHR5cGVvZiBub2RlLl90eXBlID09PSBcInN0cmluZ1wiICYmXG4gICAgLy8gVG9vbGtpdC10eXBlcyBsaWtlIG5lc3RlZCBzcGFucyBhcmUgQC1wcmVmaXhlZFxuICAgIG5vZGUuX3R5cGVbMF0gIT09IFwiQFwiICYmIChcbiAgICAvLyBgbWFya0RlZnNgIGlzbid0IF9yZXF1aXJlZF8gcGVyIHNheSwgYnV0IGlmIGl0J3MgdGhlcmUsIGl0IG5lZWRzIHRvIGJlIGFuIGFycmF5XG4gICAgIShcIm1hcmtEZWZzXCIgaW4gbm9kZSkgfHwgIW5vZGUubWFya0RlZnMgfHwgQXJyYXkuaXNBcnJheShub2RlLm1hcmtEZWZzKSAmJlxuICAgIC8vIEV2ZXJ5IG1hcmsgZGVmaW5pdGlvbiBuZWVkcyB0byBoYXZlIGFuIGBfa2V5YCB0byBiZSBtYXBwYWJsZSBpbiBjaGlsZCBzcGFuc1xuICAgIG5vZGUubWFya0RlZnMuZXZlcnkoZGVmID0+IHR5cGVvZiBkZWYuX2tleSA9PT0gXCJzdHJpbmdcIikpICYmXG4gICAgLy8gYGNoaWxkcmVuYCBpcyByZXF1aXJlZCBhbmQgbmVlZHMgdG8gYmUgYW4gYXJyYXlcbiAgICBcImNoaWxkcmVuXCIgaW4gbm9kZSAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pICYmXG4gICAgLy8gQWxsIGNoaWxkcmVuIGFyZSBvYmplY3RzIHdpdGggYF90eXBlYCAodXN1YWxseSBzcGFucywgYnV0IGNhbiBjb250YWluIG90aGVyIHN0dWZmKVxuICAgIG5vZGUuY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gdHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiICYmIFwiX3R5cGVcIiBpbiBjaGlsZClcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jayhibG9jaykge1xuICByZXR1cm4gaXNQb3J0YWJsZVRleHRCbG9jayhibG9jaykgJiYgXCJsaXN0SXRlbVwiIGluIGJsb2NrICYmIHR5cGVvZiBibG9jay5saXN0SXRlbSA9PT0gXCJzdHJpbmdcIiAmJiAodHlwZW9mIGJsb2NrLmxldmVsID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBibG9jay5sZXZlbCA9PT0gXCJudW1iZXJcIik7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KGJsb2NrKSB7XG4gIHJldHVybiBibG9jay5fdHlwZSA9PT0gXCJAbGlzdFwiO1xufVxuZnVuY3Rpb24gaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbihzcGFuKSB7XG4gIHJldHVybiBzcGFuLl90eXBlID09PSBcIkBzcGFuXCI7XG59XG5mdW5jdGlvbiBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcIkB0ZXh0XCI7XG59XG5jb25zdCBrbm93bkRlY29yYXRvcnMgPSBbXCJzdHJvbmdcIiwgXCJlbVwiLCBcImNvZGVcIiwgXCJ1bmRlcmxpbmVcIiwgXCJzdHJpa2UtdGhyb3VnaFwiXTtcbmZ1bmN0aW9uIHNvcnRNYXJrc0J5T2NjdXJlbmNlcyhzcGFuLCBpbmRleCwgYmxvY2tDaGlsZHJlbikge1xuICBpZiAoIWlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSB8fCAhc3Bhbi5tYXJrcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIXNwYW4ubWFya3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IG1hcmtzID0gc3Bhbi5tYXJrcy5zbGljZSgpO1xuICBjb25zdCBvY2N1cmVuY2VzID0ge307XG4gIG1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgb2NjdXJlbmNlc1ttYXJrXSA9IDE7XG4gICAgZm9yIChsZXQgc2libGluZ0luZGV4ID0gaW5kZXggKyAxOyBzaWJsaW5nSW5kZXggPCBibG9ja0NoaWxkcmVuLmxlbmd0aDsgc2libGluZ0luZGV4KyspIHtcbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBibG9ja0NoaWxkcmVuW3NpYmxpbmdJbmRleF07XG4gICAgICBpZiAoc2libGluZyAmJiBpc1BvcnRhYmxlVGV4dFNwYW4oc2libGluZykgJiYgQXJyYXkuaXNBcnJheShzaWJsaW5nLm1hcmtzKSAmJiBzaWJsaW5nLm1hcmtzLmluZGV4T2YobWFyaykgIT09IC0xKSB7XG4gICAgICAgIG9jY3VyZW5jZXNbbWFya10rKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXJrcy5zb3J0KChtYXJrQSwgbWFya0IpID0+IHNvcnRNYXJrcyhvY2N1cmVuY2VzLCBtYXJrQSwgbWFya0IpKTtcbn1cbmZ1bmN0aW9uIHNvcnRNYXJrcyhvY2N1cmVuY2VzLCBtYXJrQSwgbWFya0IpIHtcbiAgY29uc3QgYU9jY3VyZW5jZXMgPSBvY2N1cmVuY2VzW21hcmtBXTtcbiAgY29uc3QgYk9jY3VyZW5jZXMgPSBvY2N1cmVuY2VzW21hcmtCXTtcbiAgaWYgKGFPY2N1cmVuY2VzICE9PSBiT2NjdXJlbmNlcykge1xuICAgIHJldHVybiBiT2NjdXJlbmNlcyAtIGFPY2N1cmVuY2VzO1xuICB9XG4gIGNvbnN0IGFLbm93blBvcyA9IGtub3duRGVjb3JhdG9ycy5pbmRleE9mKG1hcmtBKTtcbiAgY29uc3QgYktub3duUG9zID0ga25vd25EZWNvcmF0b3JzLmluZGV4T2YobWFya0IpO1xuICBpZiAoYUtub3duUG9zICE9PSBiS25vd25Qb3MpIHtcbiAgICByZXR1cm4gYUtub3duUG9zIC0gYktub3duUG9zO1xuICB9XG4gIHJldHVybiBtYXJrQS5sb2NhbGVDb21wYXJlKG1hcmtCKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTWFya3NUcmVlKGJsb2NrKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIG1hcmtEZWZzID0gW11cbiAgfSA9IGJsb2NrO1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qgc29ydGVkTWFya3MgPSBjaGlsZHJlbi5tYXAoc29ydE1hcmtzQnlPY2N1cmVuY2VzKTtcbiAgY29uc3Qgcm9vdE5vZGUgPSB7XG4gICAgX3R5cGU6IFwiQHNwYW5cIixcbiAgICBjaGlsZHJlbjogW10sXG4gICAgbWFya1R5cGU6IFwiPHVua25vd24+XCJcbiAgfTtcbiAgbGV0IG5vZGVTdGFjayA9IFtyb290Tm9kZV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzcGFuID0gY2hpbGRyZW5baV07XG4gICAgaWYgKCFzcGFuKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbWFya3NOZWVkZWQgPSBzb3J0ZWRNYXJrc1tpXSB8fCBbXTtcbiAgICBsZXQgcG9zID0gMTtcbiAgICBpZiAobm9kZVN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAocG9zOyBwb3MgPCBub2RlU3RhY2subGVuZ3RoOyBwb3MrKykge1xuICAgICAgICBjb25zdCBtYXJrID0gKChfYSA9IG5vZGVTdGFja1twb3NdKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWFya0tleSkgfHwgXCJcIjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBtYXJrc05lZWRlZC5pbmRleE9mKG1hcmspO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWFya3NOZWVkZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZVN0YWNrID0gbm9kZVN0YWNrLnNsaWNlKDAsIHBvcyk7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZVN0YWNrW25vZGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWN1cnJlbnROb2RlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtYXJrS2V5IG9mIG1hcmtzTmVlZGVkKSB7XG4gICAgICBjb25zdCBtYXJrRGVmID0gbWFya0RlZnMuZmluZChkZWYgPT4gZGVmLl9rZXkgPT09IG1hcmtLZXkpO1xuICAgICAgY29uc3QgbWFya1R5cGUgPSBtYXJrRGVmID8gbWFya0RlZi5fdHlwZSA6IG1hcmtLZXk7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICBfdHlwZTogXCJAc3BhblwiLFxuICAgICAgICBfa2V5OiBzcGFuLl9rZXksXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgbWFya0RlZixcbiAgICAgICAgbWFya1R5cGUsXG4gICAgICAgIG1hcmtLZXlcbiAgICAgIH07XG4gICAgICBjdXJyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgbm9kZVN0YWNrLnB1c2gobm9kZSk7XG4gICAgICBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIGlmIChpc1BvcnRhYmxlVGV4dFNwYW4oc3BhbikpIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gc3Bhbi50ZXh0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgZm9yIChsZXQgbGluZSA9IGxpbmVzLmxlbmd0aDsgbGluZS0tID4gMTspIHtcbiAgICAgICAgbGluZXMuc3BsaWNlKGxpbmUsIDAsIFwiXFxuXCIpO1xuICAgICAgfVxuICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQobGluZXMubWFwKHRleHQgPT4gKHtcbiAgICAgICAgX3R5cGU6IFwiQHRleHRcIixcbiAgICAgICAgdGV4dFxuICAgICAgfSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUuY2hpbGRyZW4gPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5jb25jYXQoc3Bhbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIG5lc3RMaXN0cyhibG9ja3MsIG1vZGUpIHtcbiAgY29uc3QgdHJlZSA9IFtdO1xuICBsZXQgY3VycmVudExpc3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYmxvY2sgPSBibG9ja3NbaV07XG4gICAgaWYgKCFibG9jaykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghaXNQb3J0YWJsZVRleHRMaXN0SXRlbUJsb2NrKGJsb2NrKSkge1xuICAgICAgdHJlZS5wdXNoKGJsb2NrKTtcbiAgICAgIGN1cnJlbnRMaXN0ID0gdm9pZCAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghY3VycmVudExpc3QpIHtcbiAgICAgIGN1cnJlbnRMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSk7XG4gICAgICB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChibG9ja01hdGNoZXNMaXN0KGJsb2NrLCBjdXJyZW50TGlzdCkpIHtcbiAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goYmxvY2spO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgoYmxvY2subGV2ZWwgfHwgMSkgPiBjdXJyZW50TGlzdC5sZXZlbCkge1xuICAgICAgY29uc3QgbmV3TGlzdCA9IGxpc3RGcm9tQmxvY2soYmxvY2ssIGksIG1vZGUpO1xuICAgICAgaWYgKG1vZGUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIGNvbnN0IGxhc3RMaXN0SXRlbSA9IGN1cnJlbnRMaXN0LmNoaWxkcmVuW2N1cnJlbnRMaXN0LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBuZXdMYXN0Q2hpbGQgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGxhc3RMaXN0SXRlbSksIHt9LCB7XG4gICAgICAgICAgY2hpbGRyZW46IFsuLi5sYXN0TGlzdEl0ZW0uY2hpbGRyZW4sIG5ld0xpc3RdXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50TGlzdC5jaGlsZHJlbltjdXJyZW50TGlzdC5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IG5ld0xhc3RDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2gobmV3TGlzdCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50TGlzdCA9IG5ld0xpc3Q7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKChibG9jay5sZXZlbCB8fCAxKSA8IGN1cnJlbnRMaXN0LmxldmVsKSB7XG4gICAgICBjb25zdCBtYXRjaGluZ0JyYW5jaCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hpbmdCcmFuY2ggJiYgZmluZExpc3RNYXRjaGluZyhtYXRjaGluZ0JyYW5jaCwgYmxvY2spO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGN1cnJlbnRMaXN0ID0gbWF0Y2g7XG4gICAgICAgIGN1cnJlbnRMaXN0LmNoaWxkcmVuLnB1c2goYmxvY2spO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRMaXN0ID0gbGlzdEZyb21CbG9jayhibG9jaywgaSwgbW9kZSk7XG4gICAgICB0cmVlLnB1c2goY3VycmVudExpc3QpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChibG9jay5saXN0SXRlbSAhPT0gY3VycmVudExpc3QubGlzdEl0ZW0pIHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nQnJhbmNoID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGluZ0JyYW5jaCAmJiBmaW5kTGlzdE1hdGNoaW5nKG1hdGNoaW5nQnJhbmNoLCB7XG4gICAgICAgIGxldmVsOiBibG9jay5sZXZlbCB8fCAxXG4gICAgICB9KTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5saXN0SXRlbSA9PT0gYmxvY2subGlzdEl0ZW0pIHtcbiAgICAgICAgY3VycmVudExpc3QgPSBtYXRjaDtcbiAgICAgICAgY3VycmVudExpc3QuY2hpbGRyZW4ucHVzaChibG9jayk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudExpc3QgPSBsaXN0RnJvbUJsb2NrKGJsb2NrLCBpLCBtb2RlKTtcbiAgICAgICAgdHJlZS5wdXNoKGN1cnJlbnRMaXN0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihcIlVua25vd24gc3RhdGUgZW5jb3VudGVyZWQgZm9yIGJsb2NrXCIsIGJsb2NrKTtcbiAgICB0cmVlLnB1c2goYmxvY2spO1xuICB9XG4gIHJldHVybiB0cmVlO1xufVxuZnVuY3Rpb24gYmxvY2tNYXRjaGVzTGlzdChibG9jaywgbGlzdCkge1xuICByZXR1cm4gKGJsb2NrLmxldmVsIHx8IDEpID09PSBsaXN0LmxldmVsICYmIGJsb2NrLmxpc3RJdGVtID09PSBsaXN0Lmxpc3RJdGVtO1xufVxuZnVuY3Rpb24gbGlzdEZyb21CbG9jayhibG9jaywgaW5kZXgsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBfdHlwZTogXCJAbGlzdFwiLFxuICAgIF9rZXk6IFwiXCIuY29uY2F0KGJsb2NrLl9rZXkgfHwgXCJcIi5jb25jYXQoaW5kZXgpLCBcIi1wYXJlbnRcIiksXG4gICAgbW9kZSxcbiAgICBsZXZlbDogYmxvY2subGV2ZWwgfHwgMSxcbiAgICBsaXN0SXRlbTogYmxvY2subGlzdEl0ZW0sXG4gICAgY2hpbGRyZW46IFtibG9ja11cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRMaXN0TWF0Y2hpbmcocm9vdE5vZGUsIG1hdGNoaW5nKSB7XG4gIGNvbnN0IGxldmVsID0gbWF0Y2hpbmcubGV2ZWwgfHwgMTtcbiAgY29uc3Qgc3R5bGUgPSBtYXRjaGluZy5saXN0SXRlbSB8fCBcIm5vcm1hbFwiO1xuICBjb25zdCBmaWx0ZXJPblR5cGUgPSB0eXBlb2YgbWF0Y2hpbmcubGlzdEl0ZW0gPT09IFwic3RyaW5nXCI7XG4gIGlmIChpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0KHJvb3ROb2RlKSAmJiAocm9vdE5vZGUubGV2ZWwgfHwgMSkgPT09IGxldmVsICYmIGZpbHRlck9uVHlwZSAmJiAocm9vdE5vZGUubGlzdEl0ZW0gfHwgXCJub3JtYWxcIikgPT09IHN0eWxlKSB7XG4gICAgcmV0dXJuIHJvb3ROb2RlO1xuICB9XG4gIGlmICghKFwiY2hpbGRyZW5cIiBpbiByb290Tm9kZSkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IG5vZGUgPSByb290Tm9kZS5jaGlsZHJlbltyb290Tm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIG5vZGUgJiYgIWlzUG9ydGFibGVUZXh0U3Bhbihub2RlKSA/IGZpbmRMaXN0TWF0Y2hpbmcobm9kZSwgbWF0Y2hpbmcpIDogdm9pZCAwO1xufVxuY29uc3QgbGVhZGluZ1NwYWNlID0gL15cXHMvO1xuY29uc3QgdHJhaWxpbmdTcGFjZSA9IC9eXFxzLztcbmZ1bmN0aW9uIHRvUGxhaW5UZXh0KGJsb2NrKSB7XG4gIGNvbnN0IGJsb2NrcyA9IEFycmF5LmlzQXJyYXkoYmxvY2spID8gYmxvY2sgOiBbYmxvY2tdO1xuICBsZXQgdGV4dCA9IFwiXCI7XG4gIGJsb2Nrcy5mb3JFYWNoKChjdXJyZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghaXNQb3J0YWJsZVRleHRCbG9jayhjdXJyZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGFkID0gZmFsc2U7XG4gICAgY3VycmVudC5jaGlsZHJlbi5mb3JFYWNoKHNwYW4gPT4ge1xuICAgICAgaWYgKGlzUG9ydGFibGVUZXh0U3BhbihzcGFuKSkge1xuICAgICAgICB0ZXh0ICs9IHBhZCAmJiB0ZXh0ICYmICF0cmFpbGluZ1NwYWNlLnRlc3QodGV4dCkgJiYgIWxlYWRpbmdTcGFjZS50ZXN0KHNwYW4udGV4dCkgPyBcIiBcIiA6IFwiXCI7XG4gICAgICAgIHRleHQgKz0gc3Bhbi50ZXh0O1xuICAgICAgICBwYWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGluZGV4ICE9PSBibG9ja3MubGVuZ3RoIC0gMSkge1xuICAgICAgdGV4dCArPSBcIlxcblxcblwiO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gc3BhblRvUGxhaW5UZXh0KHNwYW4pIHtcbiAgbGV0IHRleHQgPSBcIlwiO1xuICBzcGFuLmNoaWxkcmVuLmZvckVhY2goY3VycmVudCA9PiB7XG4gICAgaWYgKGlzUG9ydGFibGVUZXh0VG9vbGtpdFRleHROb2RlKGN1cnJlbnQpKSB7XG4gICAgICB0ZXh0ICs9IGN1cnJlbnQudGV4dDtcbiAgICB9IGVsc2UgaWYgKGlzUG9ydGFibGVUZXh0VG9vbGtpdFNwYW4oY3VycmVudCkpIHtcbiAgICAgIHRleHQgKz0gc3BhblRvUGxhaW5UZXh0KGN1cnJlbnQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0ZXh0O1xufVxuY29uc3QgTElTVF9ORVNUX01PREVfSFRNTCA9IFwiaHRtbFwiO1xuY29uc3QgTElTVF9ORVNUX01PREVfRElSRUNUID0gXCJkaXJlY3RcIjtcbmV4cG9ydCB7IExJU1RfTkVTVF9NT0RFX0RJUkVDVCwgTElTVF9ORVNUX01PREVfSFRNTCwgYnVpbGRNYXJrc1RyZWUsIGlzUG9ydGFibGVUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0TGlzdEl0ZW1CbG9jaywgaXNQb3J0YWJsZVRleHRTcGFuLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0LCBpc1BvcnRhYmxlVGV4dFRvb2xraXRTcGFuLCBpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZSwgbmVzdExpc3RzLCBzb3J0TWFya3NCeU9jY3VyZW5jZXMsIHNwYW5Ub1BsYWluVGV4dCwgdG9QbGFpblRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIm93bktleXMiLCJlIiwiciIsInQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiaXNQb3J0YWJsZVRleHRTcGFuIiwibm9kZSIsIl90eXBlIiwidGV4dCIsIm1hcmtzIiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJtYXJrIiwiaXNQb3J0YWJsZVRleHRCbG9jayIsIm1hcmtEZWZzIiwiZGVmIiwiX2tleSIsImNoaWxkcmVuIiwiY2hpbGQiLCJpc1BvcnRhYmxlVGV4dExpc3RJdGVtQmxvY2siLCJibG9jayIsImxpc3RJdGVtIiwibGV2ZWwiLCJpc1BvcnRhYmxlVGV4dFRvb2xraXRMaXN0IiwiaXNQb3J0YWJsZVRleHRUb29sa2l0U3BhbiIsInNwYW4iLCJpc1BvcnRhYmxlVGV4dFRvb2xraXRUZXh0Tm9kZSIsImtub3duRGVjb3JhdG9ycyIsInNvcnRNYXJrc0J5T2NjdXJlbmNlcyIsImluZGV4IiwiYmxvY2tDaGlsZHJlbiIsInNsaWNlIiwib2NjdXJlbmNlcyIsInNpYmxpbmdJbmRleCIsInNpYmxpbmciLCJpbmRleE9mIiwic29ydCIsIm1hcmtBIiwibWFya0IiLCJzb3J0TWFya3MiLCJhT2NjdXJlbmNlcyIsImJPY2N1cmVuY2VzIiwiYUtub3duUG9zIiwiYktub3duUG9zIiwibG9jYWxlQ29tcGFyZSIsImJ1aWxkTWFya3NUcmVlIiwiX2EiLCJzb3J0ZWRNYXJrcyIsIm1hcCIsInJvb3ROb2RlIiwibWFya1R5cGUiLCJub2RlU3RhY2siLCJpIiwibWFya3NOZWVkZWQiLCJwb3MiLCJtYXJrS2V5Iiwic3BsaWNlIiwiY3VycmVudE5vZGUiLCJtYXJrRGVmIiwiZmluZCIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwiY29uY2F0IiwibmVzdExpc3RzIiwiYmxvY2tzIiwibW9kZSIsInRyZWUiLCJjdXJyZW50TGlzdCIsImxpc3RGcm9tQmxvY2siLCJibG9ja01hdGNoZXNMaXN0IiwibmV3TGlzdCIsImxhc3RMaXN0SXRlbSIsIm5ld0xhc3RDaGlsZCIsIm1hdGNoaW5nQnJhbmNoIiwibWF0Y2giLCJmaW5kTGlzdE1hdGNoaW5nIiwiY29uc29sZSIsIndhcm4iLCJsaXN0IiwibWF0Y2hpbmciLCJzdHlsZSIsImZpbHRlck9uVHlwZSIsImxlYWRpbmdTcGFjZSIsInRyYWlsaW5nU3BhY2UiLCJ0b1BsYWluVGV4dCIsImN1cnJlbnQiLCJwYWQiLCJ0ZXN0Iiwic3BhblRvUGxhaW5UZXh0IiwiTElTVF9ORVNUX01PREVfSFRNTCIsIkxJU1RfTkVTVF9NT0RFX0RJUkVDVCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@portabletext/toolkit/dist/index.js\n");

/***/ })

};
;