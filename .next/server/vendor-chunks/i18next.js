"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/i18next";
exports.ids = ["vendor-chunks/i18next"];
exports.modules = {

/***/ "(ssr)/./node_modules/i18next/dist/esm/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/esm/i18next.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   \"default\": () => (/* binding */ instance),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   getFixedT: () => (/* binding */ getFixedT),\n/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),\n/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),\n/* harmony export */   loadResources: () => (/* binding */ loadResources),\n/* harmony export */   reloadResources: () => (/* binding */ reloadResources),\n/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),\n/* harmony export */   t: () => (/* binding */ t),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\nconst isString = (obj)=>typeof obj === \"string\";\nconst defer = ()=>{\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    return promise;\n};\nconst makeString = (object)=>{\n    if (object == null) return \"\";\n    return \"\" + object;\n};\nconst copy = (a, s, t)=>{\n    a.forEach((m)=>{\n        if (s[m]) t[m] = s[m];\n    });\n};\nconst lastOfPathSeparatorRegExp = /###/g;\nconst cleanKey = (key)=>key && key.indexOf(\"###\") > -1 ? key.replace(lastOfPathSeparatorRegExp, \".\") : key;\nconst canNotTraverseDeeper = (object)=>!object || isString(object);\nconst getLastOfPath = (object, path, Empty)=>{\n    const stack = !isString(path) ? path : path.split(\".\");\n    let stackIndex = 0;\n    while(stackIndex < stack.length - 1){\n        if (canNotTraverseDeeper(object)) return {};\n        const key = cleanKey(stack[stackIndex]);\n        if (!object[key] && Empty) object[key] = new Empty();\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            object = object[key];\n        } else {\n            object = {};\n        }\n        ++stackIndex;\n    }\n    if (canNotTraverseDeeper(object)) return {};\n    return {\n        obj: object,\n        k: cleanKey(stack[stackIndex])\n    };\n};\nconst setPath = (object, path, newValue)=>{\n    const { obj, k } = getLastOfPath(object, path, Object);\n    if (obj !== undefined || path.length === 1) {\n        obj[k] = newValue;\n        return;\n    }\n    let e = path[path.length - 1];\n    let p = path.slice(0, path.length - 1);\n    let last = getLastOfPath(object, p, Object);\n    while(last.obj === undefined && p.length){\n        e = `${p[p.length - 1]}.${e}`;\n        p = p.slice(0, p.length - 1);\n        last = getLastOfPath(object, p, Object);\n        if (last && last.obj && typeof last.obj[`${last.k}.${e}`] !== \"undefined\") {\n            last.obj = undefined;\n        }\n    }\n    last.obj[`${last.k}.${e}`] = newValue;\n};\nconst pushPath = (object, path, newValue, concat)=>{\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = obj[k] || [];\n    obj[k].push(newValue);\n};\nconst getPath = (object, path)=>{\n    const { obj, k } = getLastOfPath(object, path);\n    if (!obj) return undefined;\n    return obj[k];\n};\nconst getPathWithDefaults = (data, defaultData, key)=>{\n    const value = getPath(data, key);\n    if (value !== undefined) {\n        return value;\n    }\n    return getPath(defaultData, key);\n};\nconst deepExtend = (target, source, overwrite)=>{\n    for(const prop in source){\n        if (prop !== \"__proto__\" && prop !== \"constructor\") {\n            if (prop in target) {\n                if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {\n                    if (overwrite) target[prop] = source[prop];\n                } else {\n                    deepExtend(target[prop], source[prop], overwrite);\n                }\n            } else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n};\nconst regexEscape = (str)=>str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\nvar _entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\"\n};\nconst escape = (data)=>{\n    if (isString(data)) {\n        return data.replace(/[&<>\"'\\/]/g, (s)=>_entityMap[s]);\n    }\n    return data;\n};\nclass RegExpCache {\n    constructor(capacity){\n        this.capacity = capacity;\n        this.regExpMap = new Map();\n        this.regExpQueue = [];\n    }\n    getRegExp(pattern) {\n        const regExpFromCache = this.regExpMap.get(pattern);\n        if (regExpFromCache !== undefined) {\n            return regExpFromCache;\n        }\n        const regExpNew = new RegExp(pattern);\n        if (this.regExpQueue.length === this.capacity) {\n            this.regExpMap.delete(this.regExpQueue.shift());\n        }\n        this.regExpMap.set(pattern, regExpNew);\n        this.regExpQueue.push(pattern);\n        return regExpNew;\n    }\n}\nconst chars = [\n    \" \",\n    \",\",\n    \"?\",\n    \"!\",\n    \";\"\n];\nconst looksLikeObjectPathRegExpCache = new RegExpCache(20);\nconst looksLikeObjectPath = (key, nsSeparator, keySeparator)=>{\n    nsSeparator = nsSeparator || \"\";\n    keySeparator = keySeparator || \"\";\n    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n    if (possibleChars.length === 0) return true;\n    const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c)=>c === \"?\" ? \"\\\\?\" : c).join(\"|\")})`);\n    let matched = !r.test(key);\n    if (!matched) {\n        const ki = key.indexOf(keySeparator);\n        if (ki > 0 && !r.test(key.substring(0, ki))) {\n            matched = true;\n        }\n    }\n    return matched;\n};\nconst deepFind = function(obj, path) {\n    let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n    if (!obj) return undefined;\n    if (obj[path]) return obj[path];\n    const tokens = path.split(keySeparator);\n    let current = obj;\n    for(let i = 0; i < tokens.length;){\n        if (!current || typeof current !== \"object\") {\n            return undefined;\n        }\n        let next;\n        let nextPath = \"\";\n        for(let j = i; j < tokens.length; ++j){\n            if (j !== i) {\n                nextPath += keySeparator;\n            }\n            nextPath += tokens[j];\n            next = current[nextPath];\n            if (next !== undefined) {\n                if ([\n                    \"string\",\n                    \"number\",\n                    \"boolean\"\n                ].indexOf(typeof next) > -1 && j < tokens.length - 1) {\n                    continue;\n                }\n                i += j - i + 1;\n                break;\n            }\n        }\n        current = next;\n    }\n    return current;\n};\nconst getCleanedCode = (code)=>code && code.replace(\"_\", \"-\");\nconst consoleLogger = {\n    type: \"logger\",\n    log (args) {\n        this.output(\"log\", args);\n    },\n    warn (args) {\n        this.output(\"warn\", args);\n    },\n    error (args) {\n        this.output(\"error\", args);\n    },\n    output (type, args) {\n        if (console && console[type]) console[type].apply(console, args);\n    }\n};\nclass Logger {\n    constructor(concreteLogger){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.init(concreteLogger, options);\n    }\n    init(concreteLogger) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.prefix = options.prefix || \"i18next:\";\n        this.logger = concreteLogger || consoleLogger;\n        this.options = options;\n        this.debug = options.debug;\n    }\n    log() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return this.forward(args, \"log\", \"\", true);\n    }\n    warn() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return this.forward(args, \"warn\", \"\", true);\n    }\n    error() {\n        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            args[_key3] = arguments[_key3];\n        }\n        return this.forward(args, \"error\", \"\");\n    }\n    deprecate() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return this.forward(args, \"warn\", \"WARNING DEPRECATED: \", true);\n    }\n    forward(args, lvl, prefix, debugOnly) {\n        if (debugOnly && !this.debug) return null;\n        if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;\n        return this.logger[lvl](args);\n    }\n    create(moduleName) {\n        return new Logger(this.logger, {\n            ...{\n                prefix: `${this.prefix}:${moduleName}:`\n            },\n            ...this.options\n        });\n    }\n    clone(options) {\n        options = options || this.options;\n        options.prefix = options.prefix || this.prefix;\n        return new Logger(this.logger, options);\n    }\n}\nvar baseLogger = new Logger();\nclass EventEmitter {\n    constructor(){\n        this.observers = {};\n    }\n    on(events, listener) {\n        events.split(\" \").forEach((event)=>{\n            if (!this.observers[event]) this.observers[event] = new Map();\n            const numListeners = this.observers[event].get(listener) || 0;\n            this.observers[event].set(listener, numListeners + 1);\n        });\n        return this;\n    }\n    off(event, listener) {\n        if (!this.observers[event]) return;\n        if (!listener) {\n            delete this.observers[event];\n            return;\n        }\n        this.observers[event].delete(listener);\n    }\n    emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (this.observers[event]) {\n            const cloned = Array.from(this.observers[event].entries());\n            cloned.forEach((_ref)=>{\n                let [observer, numTimesAdded] = _ref;\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer(...args);\n                }\n            });\n        }\n        if (this.observers[\"*\"]) {\n            const cloned = Array.from(this.observers[\"*\"].entries());\n            cloned.forEach((_ref2)=>{\n                let [observer, numTimesAdded] = _ref2;\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer.apply(observer, [\n                        event,\n                        ...args\n                    ]);\n                }\n            });\n        }\n    }\n}\nclass ResourceStore extends EventEmitter {\n    constructor(data){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            ns: [\n                \"translation\"\n            ],\n            defaultNS: \"translation\"\n        };\n        super();\n        this.data = data || {};\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        if (this.options.ignoreJSONStructure === undefined) {\n            this.options.ignoreJSONStructure = true;\n        }\n    }\n    addNamespaces(ns) {\n        if (this.options.ns.indexOf(ns) < 0) {\n            this.options.ns.push(ns);\n        }\n    }\n    removeNamespaces(ns) {\n        const index = this.options.ns.indexOf(ns);\n        if (index > -1) {\n            this.options.ns.splice(index, 1);\n        }\n    }\n    getResource(lng, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n        let path;\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n        } else {\n            path = [\n                lng,\n                ns\n            ];\n            if (key) {\n                if (Array.isArray(key)) {\n                    path.push(...key);\n                } else if (isString(key) && keySeparator) {\n                    path.push(...key.split(keySeparator));\n                } else {\n                    path.push(key);\n                }\n            }\n        }\n        const result = getPath(this.data, path);\n        if (!result && !ns && !key && lng.indexOf(\".\") > -1) {\n            lng = path[0];\n            ns = path[1];\n            key = path.slice(2).join(\".\");\n        }\n        if (result || !ignoreJSONStructure || !isString(key)) return result;\n        return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);\n    }\n    addResource(lng, ns, key, value) {\n        let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n            silent: false\n        };\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            value = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        setPath(this.data, path, value);\n        if (!options.silent) this.emit(\"added\", lng, ns, key, value);\n    }\n    addResources(lng, ns, resources) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n            silent: false\n        };\n        for(const m in resources){\n            if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {\n                silent: true\n            });\n        }\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    addResourceBundle(lng, ns, resources, deep, overwrite) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n            silent: false,\n            skipCopy: false\n        };\n        let path = [\n            lng,\n            ns\n        ];\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            deep = resources;\n            resources = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        let pack = getPath(this.data, path) || {};\n        if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));\n        if (deep) {\n            deepExtend(pack, resources, overwrite);\n        } else {\n            pack = {\n                ...pack,\n                ...resources\n            };\n        }\n        setPath(this.data, path, pack);\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    removeResourceBundle(lng, ns) {\n        if (this.hasResourceBundle(lng, ns)) {\n            delete this.data[lng][ns];\n        }\n        this.removeNamespaces(ns);\n        this.emit(\"removed\", lng, ns);\n    }\n    hasResourceBundle(lng, ns) {\n        return this.getResource(lng, ns) !== undefined;\n    }\n    getResourceBundle(lng, ns) {\n        if (!ns) ns = this.options.defaultNS;\n        if (this.options.compatibilityAPI === \"v1\") return {\n            ...{},\n            ...this.getResource(lng, ns)\n        };\n        return this.getResource(lng, ns);\n    }\n    getDataByLanguage(lng) {\n        return this.data[lng];\n    }\n    hasLanguageSomeTranslations(lng) {\n        const data = this.getDataByLanguage(lng);\n        const n = data && Object.keys(data) || [];\n        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);\n    }\n    toJSON() {\n        return this.data;\n    }\n}\nvar postProcessor = {\n    processors: {},\n    addPostProcessor (module) {\n        this.processors[module.name] = module;\n    },\n    handle (processors, value, key, options, translator) {\n        processors.forEach((processor)=>{\n            if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);\n        });\n        return value;\n    }\n};\nconst checkedLoadedFor = {};\nclass Translator extends EventEmitter {\n    constructor(services){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super();\n        copy([\n            \"resourceStore\",\n            \"languageUtils\",\n            \"pluralResolver\",\n            \"interpolator\",\n            \"backendConnector\",\n            \"i18nFormat\",\n            \"utils\"\n        ], services, this);\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        this.logger = baseLogger.create(\"translator\");\n    }\n    changeLanguage(lng) {\n        if (lng) this.language = lng;\n    }\n    exists(key) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        if (key === undefined || key === null) {\n            return false;\n        }\n        const resolved = this.resolve(key, options);\n        return resolved && resolved.res !== undefined;\n    }\n    extractFromKey(key, options) {\n        let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let namespaces = options.ns || this.options.defaultNS || [];\n        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n            const m = key.match(this.interpolator.nestingRegexp);\n            if (m && m.length > 0) {\n                return {\n                    key,\n                    namespaces: isString(namespaces) ? [\n                        namespaces\n                    ] : namespaces\n                };\n            }\n            const parts = key.split(nsSeparator);\n            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n            key = parts.join(keySeparator);\n        }\n        return {\n            key,\n            namespaces: isString(namespaces) ? [\n                namespaces\n            ] : namespaces\n        };\n    }\n    translate(keys, options, lastKey) {\n        if (typeof options !== \"object\" && this.options.overloadTranslationOptionHandler) {\n            options = this.options.overloadTranslationOptionHandler(arguments);\n        }\n        if (typeof options === \"object\") options = {\n            ...options\n        };\n        if (!options) options = {};\n        if (keys === undefined || keys === null) return \"\";\n        if (!Array.isArray(keys)) keys = [\n            String(keys)\n        ];\n        const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], options);\n        const namespace = namespaces[namespaces.length - 1];\n        const lng = options.lng || this.language;\n        const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n        if (lng && lng.toLowerCase() === \"cimode\") {\n            if (appendNamespaceToCIMode) {\n                const nsSeparator = options.nsSeparator || this.options.nsSeparator;\n                if (returnDetails) {\n                    return {\n                        res: `${namespace}${nsSeparator}${key}`,\n                        usedKey: key,\n                        exactUsedKey: key,\n                        usedLng: lng,\n                        usedNS: namespace,\n                        usedParams: this.getUsedParamsDetails(options)\n                    };\n                }\n                return `${namespace}${nsSeparator}${key}`;\n            }\n            if (returnDetails) {\n                return {\n                    res: key,\n                    usedKey: key,\n                    exactUsedKey: key,\n                    usedLng: lng,\n                    usedNS: namespace,\n                    usedParams: this.getUsedParamsDetails(options)\n                };\n            }\n            return key;\n        }\n        const resolved = this.resolve(keys, options);\n        let res = resolved && resolved.res;\n        const resUsedKey = resolved && resolved.usedKey || key;\n        const resExactUsedKey = resolved && resolved.exactUsedKey || key;\n        const resType = Object.prototype.toString.apply(res);\n        const noObject = [\n            \"[object Number]\",\n            \"[object Function]\",\n            \"[object RegExp]\"\n        ];\n        const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n        const handleAsObject = !isString(res) && typeof res !== \"boolean\" && typeof res !== \"number\";\n        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(res))) {\n            if (!options.returnObjects && !this.options.returnObjects) {\n                if (!this.options.returnedObjectHandler) {\n                    this.logger.warn(\"accessing an object - but returnObjects options is not enabled!\");\n                }\n                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {\n                    ...options,\n                    ns: namespaces\n                }) : `key '${key} (${this.language})' returned an object instead of string.`;\n                if (returnDetails) {\n                    resolved.res = r;\n                    resolved.usedParams = this.getUsedParamsDetails(options);\n                    return resolved;\n                }\n                return r;\n            }\n            if (keySeparator) {\n                const resTypeIsArray = Array.isArray(res);\n                const copy = resTypeIsArray ? [] : {};\n                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                for(const m in res){\n                    if (Object.prototype.hasOwnProperty.call(res, m)) {\n                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n                        copy[m] = this.translate(deepKey, {\n                            ...options,\n                            ...{\n                                joinArrays: false,\n                                ns: namespaces\n                            }\n                        });\n                        if (copy[m] === deepKey) copy[m] = res[m];\n                    }\n                }\n                res = copy;\n            }\n        } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {\n            res = res.join(joinArrays);\n            if (res) res = this.extendTranslation(res, keys, options, lastKey);\n        } else {\n            let usedDefault = false;\n            let usedKey = false;\n            const needsPluralHandling = options.count !== undefined && !isString(options.count);\n            const hasDefaultValue = Translator.hasDefaultValue(options);\n            const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : \"\";\n            const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {\n                ordinal: false\n            }) : \"\";\n            const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n            const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;\n            if (!this.isValidLookup(res) && hasDefaultValue) {\n                usedDefault = true;\n                res = defaultValue;\n            }\n            if (!this.isValidLookup(res)) {\n                usedKey = true;\n                res = key;\n            }\n            const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n            if (usedKey || usedDefault || updateMissing) {\n                this.logger.log(updateMissing ? \"updateKey\" : \"missingKey\", lng, namespace, key, updateMissing ? defaultValue : res);\n                if (keySeparator) {\n                    const fk = this.resolve(key, {\n                        ...options,\n                        keySeparator: false\n                    });\n                    if (fk && fk.res) this.logger.warn(\"Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.\");\n                }\n                let lngs = [];\n                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n                if (this.options.saveMissingTo === \"fallback\" && fallbackLngs && fallbackLngs[0]) {\n                    for(let i = 0; i < fallbackLngs.length; i++){\n                        lngs.push(fallbackLngs[i]);\n                    }\n                } else if (this.options.saveMissingTo === \"all\") {\n                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n                } else {\n                    lngs.push(options.lng || this.language);\n                }\n                const send = (l, k, specificDefaultValue)=>{\n                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n                    if (this.options.missingKeyHandler) {\n                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);\n                    } else if (this.backendConnector && this.backendConnector.saveMissing) {\n                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);\n                    }\n                    this.emit(\"missingKey\", l, namespace, k, res);\n                };\n                if (this.options.saveMissing) {\n                    if (this.options.saveMissingPlurals && needsPluralHandling) {\n                        lngs.forEach((language)=>{\n                            const suffixes = this.pluralResolver.getSuffixes(language, options);\n                            if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {\n                                suffixes.push(`${this.options.pluralSeparator}zero`);\n                            }\n                            suffixes.forEach((suffix)=>{\n                                send([\n                                    language\n                                ], key + suffix, options[`defaultValue${suffix}`] || defaultValue);\n                            });\n                        });\n                    } else {\n                        send(lngs, key, defaultValue);\n                    }\n                }\n            }\n            res = this.extendTranslation(res, keys, options, resolved, lastKey);\n            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;\n            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n                if (this.options.compatibilityAPI !== \"v1\") {\n                    res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);\n                } else {\n                    res = this.options.parseMissingKeyHandler(res);\n                }\n            }\n        }\n        if (returnDetails) {\n            resolved.res = res;\n            resolved.usedParams = this.getUsedParamsDetails(options);\n            return resolved;\n        }\n        return res;\n    }\n    extendTranslation(res, key, options, resolved, lastKey) {\n        var _this = this;\n        if (this.i18nFormat && this.i18nFormat.parse) {\n            res = this.i18nFormat.parse(res, {\n                ...this.options.interpolation.defaultVariables,\n                ...options\n            }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n                resolved\n            });\n        } else if (!options.skipInterpolation) {\n            if (options.interpolation) this.interpolator.init({\n                ...options,\n                ...{\n                    interpolation: {\n                        ...this.options.interpolation,\n                        ...options.interpolation\n                    }\n                }\n            });\n            const skipOnVariables = isString(res) && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n            let nestBef;\n            if (skipOnVariables) {\n                const nb = res.match(this.interpolator.nestingRegexp);\n                nestBef = nb && nb.length;\n            }\n            let data = options.replace && !isString(options.replace) ? options.replace : options;\n            if (this.options.interpolation.defaultVariables) data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n            res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);\n            if (skipOnVariables) {\n                const na = res.match(this.interpolator.nestingRegexp);\n                const nestAft = na && na.length;\n                if (nestBef < nestAft) options.nest = false;\n            }\n            if (!options.lng && this.options.compatibilityAPI !== \"v1\" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;\n            if (options.nest !== false) res = this.interpolator.nest(res, function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (lastKey && lastKey[0] === args[0] && !options.context) {\n                    _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n                    return null;\n                }\n                return _this.translate(...args, key);\n            }, options);\n            if (options.interpolation) this.interpolator.reset();\n        }\n        const postProcess = options.postProcess || this.options.postProcess;\n        const postProcessorNames = isString(postProcess) ? [\n            postProcess\n        ] : postProcess;\n        if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                i18nResolved: {\n                    ...resolved,\n                    usedParams: this.getUsedParamsDetails(options)\n                },\n                ...options\n            } : options, this);\n        }\n        return res;\n    }\n    resolve(keys) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let found;\n        let usedKey;\n        let exactUsedKey;\n        let usedLng;\n        let usedNS;\n        if (isString(keys)) keys = [\n            keys\n        ];\n        keys.forEach((k)=>{\n            if (this.isValidLookup(found)) return;\n            const extracted = this.extractFromKey(k, options);\n            const key = extracted.key;\n            usedKey = key;\n            let namespaces = extracted.namespaces;\n            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n            const needsPluralHandling = options.count !== undefined && !isString(options.count);\n            const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n            const needsContextHandling = options.context !== undefined && (isString(options.context) || typeof options.context === \"number\") && options.context !== \"\";\n            const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);\n            namespaces.forEach((ns)=>{\n                if (this.isValidLookup(found)) return;\n                usedNS = ns;\n                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {\n                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n                    this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(\", \")}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n                }\n                codes.forEach((code)=>{\n                    if (this.isValidLookup(found)) return;\n                    usedLng = code;\n                    const finalKeys = [\n                        key\n                    ];\n                    if (this.i18nFormat && this.i18nFormat.addLookupKeys) {\n                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n                    } else {\n                        let pluralSuffix;\n                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);\n                        const zeroSuffix = `${this.options.pluralSeparator}zero`;\n                        const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n                        if (needsPluralHandling) {\n                            finalKeys.push(key + pluralSuffix);\n                            if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                            }\n                            if (needsZeroSuffixLookup) {\n                                finalKeys.push(key + zeroSuffix);\n                            }\n                        }\n                        if (needsContextHandling) {\n                            const contextKey = `${key}${this.options.contextSeparator}${options.context}`;\n                            finalKeys.push(contextKey);\n                            if (needsPluralHandling) {\n                                finalKeys.push(contextKey + pluralSuffix);\n                                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                                }\n                                if (needsZeroSuffixLookup) {\n                                    finalKeys.push(contextKey + zeroSuffix);\n                                }\n                            }\n                        }\n                    }\n                    let possibleKey;\n                    while(possibleKey = finalKeys.pop()){\n                        if (!this.isValidLookup(found)) {\n                            exactUsedKey = possibleKey;\n                            found = this.getResource(code, ns, possibleKey, options);\n                        }\n                    }\n                });\n            });\n        });\n        return {\n            res: found,\n            usedKey,\n            exactUsedKey,\n            usedLng,\n            usedNS\n        };\n    }\n    isValidLookup(res) {\n        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === \"\");\n    }\n    getResource(code, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n        return this.resourceStore.getResource(code, ns, key, options);\n    }\n    getUsedParamsDetails() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const optionsKeys = [\n            \"defaultValue\",\n            \"ordinal\",\n            \"context\",\n            \"replace\",\n            \"lng\",\n            \"lngs\",\n            \"fallbackLng\",\n            \"ns\",\n            \"keySeparator\",\n            \"nsSeparator\",\n            \"returnObjects\",\n            \"returnDetails\",\n            \"joinArrays\",\n            \"postProcess\",\n            \"interpolation\"\n        ];\n        const useOptionsReplaceForData = options.replace && !isString(options.replace);\n        let data = useOptionsReplaceForData ? options.replace : options;\n        if (useOptionsReplaceForData && typeof options.count !== \"undefined\") {\n            data.count = options.count;\n        }\n        if (this.options.interpolation.defaultVariables) {\n            data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n        }\n        if (!useOptionsReplaceForData) {\n            data = {\n                ...data\n            };\n            for (const key of optionsKeys){\n                delete data[key];\n            }\n        }\n        return data;\n    }\n    static hasDefaultValue(options) {\n        const prefix = \"defaultValue\";\n        for(const option in options){\n            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nconst capitalize = (string)=>string.charAt(0).toUpperCase() + string.slice(1);\nclass LanguageUtil {\n    constructor(options){\n        this.options = options;\n        this.supportedLngs = this.options.supportedLngs || false;\n        this.logger = baseLogger.create(\"languageUtils\");\n    }\n    getScriptPartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return null;\n        const p = code.split(\"-\");\n        if (p.length === 2) return null;\n        p.pop();\n        if (p[p.length - 1].toLowerCase() === \"x\") return null;\n        return this.formatLanguageCode(p.join(\"-\"));\n    }\n    getLanguagePartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return code;\n        const p = code.split(\"-\");\n        return this.formatLanguageCode(p[0]);\n    }\n    formatLanguageCode(code) {\n        if (isString(code) && code.indexOf(\"-\") > -1) {\n            if (typeof Intl !== \"undefined\" && typeof Intl.getCanonicalLocales !== \"undefined\") {\n                try {\n                    let formattedCode = Intl.getCanonicalLocales(code)[0];\n                    if (formattedCode && this.options.lowerCaseLng) {\n                        formattedCode = formattedCode.toLowerCase();\n                    }\n                    if (formattedCode) return formattedCode;\n                } catch (e) {}\n            }\n            const specialCases = [\n                \"hans\",\n                \"hant\",\n                \"latn\",\n                \"cyrl\",\n                \"cans\",\n                \"mong\",\n                \"arab\"\n            ];\n            let p = code.split(\"-\");\n            if (this.options.lowerCaseLng) {\n                p = p.map((part)=>part.toLowerCase());\n            } else if (p.length === 2) {\n                p[0] = p[0].toLowerCase();\n                p[1] = p[1].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n            } else if (p.length === 3) {\n                p[0] = p[0].toLowerCase();\n                if (p[1].length === 2) p[1] = p[1].toUpperCase();\n                if (p[0] !== \"sgn\" && p[2].length === 2) p[2] = p[2].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n                if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());\n            }\n            return p.join(\"-\");\n        }\n        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n    isSupportedCode(code) {\n        if (this.options.load === \"languageOnly\" || this.options.nonExplicitSupportedLngs) {\n            code = this.getLanguagePartFromCode(code);\n        }\n        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n    getBestMatchFromCodes(codes) {\n        if (!codes) return null;\n        let found;\n        codes.forEach((code)=>{\n            if (found) return;\n            const cleanedLng = this.formatLanguageCode(code);\n            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n        });\n        if (!found && this.options.supportedLngs) {\n            codes.forEach((code)=>{\n                if (found) return;\n                const lngOnly = this.getLanguagePartFromCode(code);\n                if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n                found = this.options.supportedLngs.find((supportedLng)=>{\n                    if (supportedLng === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(\"-\") < 0 && lngOnly.indexOf(\"-\") < 0) return;\n                    if (supportedLng.indexOf(\"-\") > 0 && lngOnly.indexOf(\"-\") < 0 && supportedLng.substring(0, supportedLng.indexOf(\"-\")) === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;\n                });\n            });\n        }\n        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n        return found;\n    }\n    getFallbackCodes(fallbacks, code) {\n        if (!fallbacks) return [];\n        if (typeof fallbacks === \"function\") fallbacks = fallbacks(code);\n        if (isString(fallbacks)) fallbacks = [\n            fallbacks\n        ];\n        if (Array.isArray(fallbacks)) return fallbacks;\n        if (!code) return fallbacks.default || [];\n        let found = fallbacks[code];\n        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n        if (!found) found = fallbacks[this.formatLanguageCode(code)];\n        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n        if (!found) found = fallbacks.default;\n        return found || [];\n    }\n    toResolveHierarchy(code, fallbackCode) {\n        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n        const codes = [];\n        const addCode = (c)=>{\n            if (!c) return;\n            if (this.isSupportedCode(c)) {\n                codes.push(c);\n            } else {\n                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n            }\n        };\n        if (isString(code) && (code.indexOf(\"-\") > -1 || code.indexOf(\"_\") > -1)) {\n            if (this.options.load !== \"languageOnly\") addCode(this.formatLanguageCode(code));\n            if (this.options.load !== \"languageOnly\" && this.options.load !== \"currentOnly\") addCode(this.getScriptPartFromCode(code));\n            if (this.options.load !== \"currentOnly\") addCode(this.getLanguagePartFromCode(code));\n        } else if (isString(code)) {\n            addCode(this.formatLanguageCode(code));\n        }\n        fallbackCodes.forEach((fc)=>{\n            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n        });\n        return codes;\n    }\n}\nlet sets = [\n    {\n        lngs: [\n            \"ach\",\n            \"ak\",\n            \"am\",\n            \"arn\",\n            \"br\",\n            \"fil\",\n            \"gun\",\n            \"ln\",\n            \"mfe\",\n            \"mg\",\n            \"mi\",\n            \"oc\",\n            \"pt\",\n            \"pt-BR\",\n            \"tg\",\n            \"tl\",\n            \"ti\",\n            \"tr\",\n            \"uz\",\n            \"wa\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 1\n    },\n    {\n        lngs: [\n            \"af\",\n            \"an\",\n            \"ast\",\n            \"az\",\n            \"bg\",\n            \"bn\",\n            \"ca\",\n            \"da\",\n            \"de\",\n            \"dev\",\n            \"el\",\n            \"en\",\n            \"eo\",\n            \"es\",\n            \"et\",\n            \"eu\",\n            \"fi\",\n            \"fo\",\n            \"fur\",\n            \"fy\",\n            \"gl\",\n            \"gu\",\n            \"ha\",\n            \"hi\",\n            \"hu\",\n            \"hy\",\n            \"ia\",\n            \"it\",\n            \"kk\",\n            \"kn\",\n            \"ku\",\n            \"lb\",\n            \"mai\",\n            \"ml\",\n            \"mn\",\n            \"mr\",\n            \"nah\",\n            \"nap\",\n            \"nb\",\n            \"ne\",\n            \"nl\",\n            \"nn\",\n            \"no\",\n            \"nso\",\n            \"pa\",\n            \"pap\",\n            \"pms\",\n            \"ps\",\n            \"pt-PT\",\n            \"rm\",\n            \"sco\",\n            \"se\",\n            \"si\",\n            \"so\",\n            \"son\",\n            \"sq\",\n            \"sv\",\n            \"sw\",\n            \"ta\",\n            \"te\",\n            \"tk\",\n            \"ur\",\n            \"yo\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ay\",\n            \"bo\",\n            \"cgg\",\n            \"fa\",\n            \"ht\",\n            \"id\",\n            \"ja\",\n            \"jbo\",\n            \"ka\",\n            \"km\",\n            \"ko\",\n            \"ky\",\n            \"lo\",\n            \"ms\",\n            \"sah\",\n            \"su\",\n            \"th\",\n            \"tt\",\n            \"ug\",\n            \"vi\",\n            \"wo\",\n            \"zh\"\n        ],\n        nr: [\n            1\n        ],\n        fc: 3\n    },\n    {\n        lngs: [\n            \"be\",\n            \"bs\",\n            \"cnr\",\n            \"dz\",\n            \"hr\",\n            \"ru\",\n            \"sr\",\n            \"uk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 4\n    },\n    {\n        lngs: [\n            \"ar\"\n        ],\n        nr: [\n            0,\n            1,\n            2,\n            3,\n            11,\n            100\n        ],\n        fc: 5\n    },\n    {\n        lngs: [\n            \"cs\",\n            \"sk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 6\n    },\n    {\n        lngs: [\n            \"csb\",\n            \"pl\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 7\n    },\n    {\n        lngs: [\n            \"cy\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            8\n        ],\n        fc: 8\n    },\n    {\n        lngs: [\n            \"fr\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 9\n    },\n    {\n        lngs: [\n            \"ga\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            7,\n            11\n        ],\n        fc: 10\n    },\n    {\n        lngs: [\n            \"gd\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            20\n        ],\n        fc: 11\n    },\n    {\n        lngs: [\n            \"is\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 12\n    },\n    {\n        lngs: [\n            \"jv\"\n        ],\n        nr: [\n            0,\n            1\n        ],\n        fc: 13\n    },\n    {\n        lngs: [\n            \"kw\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            4\n        ],\n        fc: 14\n    },\n    {\n        lngs: [\n            \"lt\"\n        ],\n        nr: [\n            1,\n            2,\n            10\n        ],\n        fc: 15\n    },\n    {\n        lngs: [\n            \"lv\"\n        ],\n        nr: [\n            1,\n            2,\n            0\n        ],\n        fc: 16\n    },\n    {\n        lngs: [\n            \"mk\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 17\n    },\n    {\n        lngs: [\n            \"mnk\"\n        ],\n        nr: [\n            0,\n            1,\n            2\n        ],\n        fc: 18\n    },\n    {\n        lngs: [\n            \"mt\"\n        ],\n        nr: [\n            1,\n            2,\n            11,\n            20\n        ],\n        fc: 19\n    },\n    {\n        lngs: [\n            \"or\"\n        ],\n        nr: [\n            2,\n            1\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ro\"\n        ],\n        nr: [\n            1,\n            2,\n            20\n        ],\n        fc: 20\n    },\n    {\n        lngs: [\n            \"sl\"\n        ],\n        nr: [\n            5,\n            1,\n            2,\n            3\n        ],\n        fc: 21\n    },\n    {\n        lngs: [\n            \"he\",\n            \"iw\"\n        ],\n        nr: [\n            1,\n            2,\n            20,\n            21\n        ],\n        fc: 22\n    }\n];\nlet _rulesPluralsTypes = {\n    1: (n)=>Number(n > 1),\n    2: (n)=>Number(n != 1),\n    3: (n)=>0,\n    4: (n)=>Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),\n    5: (n)=>Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5),\n    6: (n)=>Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2),\n    7: (n)=>Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),\n    8: (n)=>Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3),\n    9: (n)=>Number(n >= 2),\n    10: (n)=>Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4),\n    11: (n)=>Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3),\n    12: (n)=>Number(n % 10 != 1 || n % 100 == 11),\n    13: (n)=>Number(n !== 0),\n    14: (n)=>Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3),\n    15: (n)=>Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2),\n    16: (n)=>Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2),\n    17: (n)=>Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1),\n    18: (n)=>Number(n == 0 ? 0 : n == 1 ? 1 : 2),\n    19: (n)=>Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3),\n    20: (n)=>Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2),\n    21: (n)=>Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0),\n    22: (n)=>Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3)\n};\nconst nonIntlVersions = [\n    \"v1\",\n    \"v2\",\n    \"v3\"\n];\nconst intlVersions = [\n    \"v4\"\n];\nconst suffixesOrder = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    few: 3,\n    many: 4,\n    other: 5\n};\nconst createRules = ()=>{\n    const rules = {};\n    sets.forEach((set)=>{\n        set.lngs.forEach((l)=>{\n            rules[l] = {\n                numbers: set.nr,\n                plurals: _rulesPluralsTypes[set.fc]\n            };\n        });\n    });\n    return rules;\n};\nclass PluralResolver {\n    constructor(languageUtils){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.languageUtils = languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"pluralResolver\");\n        if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === \"undefined\" || !Intl.PluralRules)) {\n            this.options.compatibilityJSON = \"v3\";\n            this.logger.error(\"Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.\");\n        }\n        this.rules = createRules();\n        this.pluralRulesCache = {};\n    }\n    addRule(lng, obj) {\n        this.rules[lng] = obj;\n    }\n    clearCache() {\n        this.pluralRulesCache = {};\n    }\n    getRule(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (this.shouldUseIntlApi()) {\n            const cleanedCode = getCleanedCode(code === \"dev\" ? \"en\" : code);\n            const type = options.ordinal ? \"ordinal\" : \"cardinal\";\n            const cacheKey = JSON.stringify({\n                cleanedCode,\n                type\n            });\n            if (cacheKey in this.pluralRulesCache) {\n                return this.pluralRulesCache[cacheKey];\n            }\n            let rule;\n            try {\n                rule = new Intl.PluralRules(cleanedCode, {\n                    type\n                });\n            } catch (err) {\n                if (!code.match(/-|_/)) return;\n                const lngPart = this.languageUtils.getLanguagePartFromCode(code);\n                rule = this.getRule(lngPart, options);\n            }\n            this.pluralRulesCache[cacheKey] = rule;\n            return rule;\n        }\n        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n    }\n    needsPlural(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (this.shouldUseIntlApi()) {\n            return rule && rule.resolvedOptions().pluralCategories.length > 1;\n        }\n        return rule && rule.numbers.length > 1;\n    }\n    getPluralFormsOfKey(code, key) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return this.getSuffixes(code, options).map((suffix)=>`${key}${suffix}`);\n    }\n    getSuffixes(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (!rule) {\n            return [];\n        }\n        if (this.shouldUseIntlApi()) {\n            return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>`${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${pluralCategory}`);\n        }\n        return rule.numbers.map((number)=>this.getSuffix(code, number, options));\n    }\n    getSuffix(code, count) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        const rule = this.getRule(code, options);\n        if (rule) {\n            if (this.shouldUseIntlApi()) {\n                return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${rule.select(count)}`;\n            }\n            return this.getSuffixRetroCompatible(rule, count);\n        }\n        this.logger.warn(`no plural rule found for: ${code}`);\n        return \"\";\n    }\n    getSuffixRetroCompatible(rule, count) {\n        const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n        let suffix = rule.numbers[idx];\n        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            if (suffix === 2) {\n                suffix = \"plural\";\n            } else if (suffix === 1) {\n                suffix = \"\";\n            }\n        }\n        const returnSuffix = ()=>this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();\n        if (this.options.compatibilityJSON === \"v1\") {\n            if (suffix === 1) return \"\";\n            if (typeof suffix === \"number\") return `_plural_${suffix.toString()}`;\n            return returnSuffix();\n        } else if (this.options.compatibilityJSON === \"v2\") {\n            return returnSuffix();\n        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            return returnSuffix();\n        }\n        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n    }\n    shouldUseIntlApi() {\n        return !nonIntlVersions.includes(this.options.compatibilityJSON);\n    }\n}\nconst deepFindWithDefaults = function(data, defaultData, key) {\n    let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n    let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let path = getPathWithDefaults(data, defaultData, key);\n    if (!path && ignoreJSONStructure && isString(key)) {\n        path = deepFind(data, key, keySeparator);\n        if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n    }\n    return path;\n};\nconst regexSafe = (val)=>val.replace(/\\$/g, \"$$$$\");\nclass Interpolator {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"interpolator\");\n        this.options = options;\n        this.format = options.interpolation && options.interpolation.format || ((value)=>value);\n        this.init(options);\n    }\n    init() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!options.interpolation) options.interpolation = {\n            escapeValue: true\n        };\n        const { escape: escape$1, escapeValue, useRawValueToEscape, prefix, prefixEscaped, suffix, suffixEscaped, formatSeparator, unescapeSuffix, unescapePrefix, nestingPrefix, nestingPrefixEscaped, nestingSuffix, nestingSuffixEscaped, nestingOptionsSeparator, maxReplaces, alwaysFormat } = options.interpolation;\n        this.escape = escape$1 !== undefined ? escape$1 : escape;\n        this.escapeValue = escapeValue !== undefined ? escapeValue : true;\n        this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;\n        this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || \"{{\";\n        this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || \"}}\";\n        this.formatSeparator = formatSeparator || \",\";\n        this.unescapePrefix = unescapeSuffix ? \"\" : unescapePrefix || \"-\";\n        this.unescapeSuffix = this.unescapePrefix ? \"\" : unescapeSuffix || \"\";\n        this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape(\"$t(\");\n        this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(\")\");\n        this.nestingOptionsSeparator = nestingOptionsSeparator || \",\";\n        this.maxReplaces = maxReplaces || 1000;\n        this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;\n        this.resetRegExp();\n    }\n    reset() {\n        if (this.options) this.init(this.options);\n    }\n    resetRegExp() {\n        const getOrResetRegExp = (existingRegExp, pattern)=>{\n            if (existingRegExp && existingRegExp.source === pattern) {\n                existingRegExp.lastIndex = 0;\n                return existingRegExp;\n            }\n            return new RegExp(pattern, \"g\");\n        };\n        this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);\n        this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);\n        this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);\n    }\n    interpolate(str, data, lng, options) {\n        let match;\n        let value;\n        let replaces;\n        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n        const handleFormat = (key)=>{\n            if (key.indexOf(this.formatSeparator) < 0) {\n                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n                return this.alwaysFormat ? this.format(path, undefined, lng, {\n                    ...options,\n                    ...data,\n                    interpolationkey: key\n                }) : path;\n            }\n            const p = key.split(this.formatSeparator);\n            const k = p.shift().trim();\n            const f = p.join(this.formatSeparator).trim();\n            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n                ...options,\n                ...data,\n                interpolationkey: k\n            });\n        };\n        this.resetRegExp();\n        const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n        const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n        const todos = [\n            {\n                regex: this.regexpUnescape,\n                safeValue: (val)=>regexSafe(val)\n            },\n            {\n                regex: this.regexp,\n                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n            }\n        ];\n        todos.forEach((todo)=>{\n            replaces = 0;\n            while(match = todo.regex.exec(str)){\n                const matchedVar = match[1].trim();\n                value = handleFormat(matchedVar);\n                if (value === undefined) {\n                    if (typeof missingInterpolationHandler === \"function\") {\n                        const temp = missingInterpolationHandler(str, match, options);\n                        value = isString(temp) ? temp : \"\";\n                    } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n                        value = \"\";\n                    } else if (skipOnVariables) {\n                        value = match[0];\n                        continue;\n                    } else {\n                        this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n                        value = \"\";\n                    }\n                } else if (!isString(value) && !this.useRawValueToEscape) {\n                    value = makeString(value);\n                }\n                const safeValue = todo.safeValue(value);\n                str = str.replace(match[0], safeValue);\n                if (skipOnVariables) {\n                    todo.regex.lastIndex += value.length;\n                    todo.regex.lastIndex -= match[0].length;\n                } else {\n                    todo.regex.lastIndex = 0;\n                }\n                replaces++;\n                if (replaces >= this.maxReplaces) {\n                    break;\n                }\n            }\n        });\n        return str;\n    }\n    nest(str, fc) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let match;\n        let value;\n        let clonedOptions;\n        const handleHasOptions = (key, inheritedOptions)=>{\n            const sep = this.nestingOptionsSeparator;\n            if (key.indexOf(sep) < 0) return key;\n            const c = key.split(new RegExp(`${sep}[ ]*{`));\n            let optionsString = `{${c[1]}`;\n            key = c[0];\n            optionsString = this.interpolate(optionsString, clonedOptions);\n            const matchedSingleQuotes = optionsString.match(/'/g);\n            const matchedDoubleQuotes = optionsString.match(/\"/g);\n            if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n                optionsString = optionsString.replace(/'/g, '\"');\n            }\n            try {\n                clonedOptions = JSON.parse(optionsString);\n                if (inheritedOptions) clonedOptions = {\n                    ...inheritedOptions,\n                    ...clonedOptions\n                };\n            } catch (e) {\n                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n                return `${key}${sep}${optionsString}`;\n            }\n            if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;\n            return key;\n        };\n        while(match = this.nestingRegexp.exec(str)){\n            let formatters = [];\n            clonedOptions = {\n                ...options\n            };\n            clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            let doReduce = false;\n            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n                const r = match[1].split(this.formatSeparator).map((elem)=>elem.trim());\n                match[1] = r.shift();\n                formatters = r;\n                doReduce = true;\n            }\n            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n            if (value && match[0] === str && !isString(value)) return value;\n            if (!isString(value)) value = makeString(value);\n            if (!value) {\n                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n                value = \"\";\n            }\n            if (doReduce) {\n                value = formatters.reduce((v, f)=>this.format(v, f, options.lng, {\n                        ...options,\n                        interpolationkey: match[1].trim()\n                    }), value.trim());\n            }\n            str = str.replace(match[0], value);\n            this.regexp.lastIndex = 0;\n        }\n        return str;\n    }\n}\nconst parseFormatStr = (formatStr)=>{\n    let formatName = formatStr.toLowerCase().trim();\n    const formatOptions = {};\n    if (formatStr.indexOf(\"(\") > -1) {\n        const p = formatStr.split(\"(\");\n        formatName = p[0].toLowerCase().trim();\n        const optStr = p[1].substring(0, p[1].length - 1);\n        if (formatName === \"currency\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n        } else if (formatName === \"relativetime\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.range) formatOptions.range = optStr.trim();\n        } else {\n            const opts = optStr.split(\";\");\n            opts.forEach((opt)=>{\n                if (opt) {\n                    const [key, ...rest] = opt.split(\":\");\n                    const val = rest.join(\":\").trim().replace(/^'+|'+$/g, \"\");\n                    const trimmedKey = key.trim();\n                    if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;\n                    if (val === \"false\") formatOptions[trimmedKey] = false;\n                    if (val === \"true\") formatOptions[trimmedKey] = true;\n                    if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);\n                }\n            });\n        }\n    }\n    return {\n        formatName,\n        formatOptions\n    };\n};\nconst createCachedFormatter = (fn)=>{\n    const cache = {};\n    return (val, lng, options)=>{\n        let optForCache = options;\n        if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {\n            optForCache = {\n                ...optForCache,\n                [options.interpolationkey]: undefined\n            };\n        }\n        const key = lng + JSON.stringify(optForCache);\n        let formatter = cache[key];\n        if (!formatter) {\n            formatter = fn(getCleanedCode(lng), options);\n            cache[key] = formatter;\n        }\n        return formatter(val);\n    };\n};\nclass Formatter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"formatter\");\n        this.options = options;\n        this.formats = {\n            number: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            currency: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt,\n                    style: \"currency\"\n                });\n                return (val)=>formatter.format(val);\n            }),\n            datetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.DateTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            relativetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.RelativeTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val, opt.range || \"day\");\n            }),\n            list: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.ListFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            })\n        };\n        this.init(options);\n    }\n    init(services) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        this.formatSeparator = options.interpolation.formatSeparator || \",\";\n    }\n    add(name, fc) {\n        this.formats[name.toLowerCase().trim()] = fc;\n    }\n    addCached(name, fc) {\n        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n    }\n    format(value, format, lng) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const formats = format.split(this.formatSeparator);\n        if (formats.length > 1 && formats[0].indexOf(\"(\") > 1 && formats[0].indexOf(\")\") < 0 && formats.find((f)=>f.indexOf(\")\") > -1)) {\n            const lastIndex = formats.findIndex((f)=>f.indexOf(\")\") > -1);\n            formats[0] = [\n                formats[0],\n                ...formats.splice(1, lastIndex)\n            ].join(this.formatSeparator);\n        }\n        const result = formats.reduce((mem, f)=>{\n            const { formatName, formatOptions } = parseFormatStr(f);\n            if (this.formats[formatName]) {\n                let formatted = mem;\n                try {\n                    const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};\n                    const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n                    formatted = this.formats[formatName](mem, l, {\n                        ...formatOptions,\n                        ...options,\n                        ...valOptions\n                    });\n                } catch (error) {\n                    this.logger.warn(error);\n                }\n                return formatted;\n            } else {\n                this.logger.warn(`there was no format function for ${formatName}`);\n            }\n            return mem;\n        }, value);\n        return result;\n    }\n}\nconst removePending = (q, name)=>{\n    if (q.pending[name] !== undefined) {\n        delete q.pending[name];\n        q.pendingCount--;\n    }\n};\nclass Connector extends EventEmitter {\n    constructor(backend, store, services){\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        super();\n        this.backend = backend;\n        this.store = store;\n        this.services = services;\n        this.languageUtils = services.languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"backendConnector\");\n        this.waitingReads = [];\n        this.maxParallelReads = options.maxParallelReads || 10;\n        this.readingCalls = 0;\n        this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n        this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n        this.state = {};\n        this.queue = [];\n        if (this.backend && this.backend.init) {\n            this.backend.init(services, options.backend, options);\n        }\n    }\n    queueLoad(languages, namespaces, options, callback) {\n        const toLoad = {};\n        const pending = {};\n        const toLoadLanguages = {};\n        const toLoadNamespaces = {};\n        languages.forEach((lng)=>{\n            let hasAllNamespaces = true;\n            namespaces.forEach((ns)=>{\n                const name = `${lng}|${ns}`;\n                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n                    this.state[name] = 2;\n                } else if (this.state[name] < 0) ;\n                else if (this.state[name] === 1) {\n                    if (pending[name] === undefined) pending[name] = true;\n                } else {\n                    this.state[name] = 1;\n                    hasAllNamespaces = false;\n                    if (pending[name] === undefined) pending[name] = true;\n                    if (toLoad[name] === undefined) toLoad[name] = true;\n                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n                }\n            });\n            if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n        });\n        if (Object.keys(toLoad).length || Object.keys(pending).length) {\n            this.queue.push({\n                pending,\n                pendingCount: Object.keys(pending).length,\n                loaded: {},\n                errors: [],\n                callback\n            });\n        }\n        return {\n            toLoad: Object.keys(toLoad),\n            pending: Object.keys(pending),\n            toLoadLanguages: Object.keys(toLoadLanguages),\n            toLoadNamespaces: Object.keys(toLoadNamespaces)\n        };\n    }\n    loaded(name, err, data) {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        if (err) this.emit(\"failedLoading\", lng, ns, err);\n        if (!err && data) {\n            this.store.addResourceBundle(lng, ns, data, undefined, undefined, {\n                skipCopy: true\n            });\n        }\n        this.state[name] = err ? -1 : 2;\n        if (err && data) this.state[name] = 0;\n        const loaded = {};\n        this.queue.forEach((q)=>{\n            pushPath(q.loaded, [\n                lng\n            ], ns);\n            removePending(q, name);\n            if (err) q.errors.push(err);\n            if (q.pendingCount === 0 && !q.done) {\n                Object.keys(q.loaded).forEach((l)=>{\n                    if (!loaded[l]) loaded[l] = {};\n                    const loadedKeys = q.loaded[l];\n                    if (loadedKeys.length) {\n                        loadedKeys.forEach((n)=>{\n                            if (loaded[l][n] === undefined) loaded[l][n] = true;\n                        });\n                    }\n                });\n                q.done = true;\n                if (q.errors.length) {\n                    q.callback(q.errors);\n                } else {\n                    q.callback();\n                }\n            }\n        });\n        this.emit(\"loaded\", loaded);\n        this.queue = this.queue.filter((q)=>!q.done);\n    }\n    read(lng, ns, fcName) {\n        let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;\n        let callback = arguments.length > 5 ? arguments[5] : undefined;\n        if (!lng.length) return callback(null, {});\n        if (this.readingCalls >= this.maxParallelReads) {\n            this.waitingReads.push({\n                lng,\n                ns,\n                fcName,\n                tried,\n                wait,\n                callback\n            });\n            return;\n        }\n        this.readingCalls++;\n        const resolver = (err, data)=>{\n            this.readingCalls--;\n            if (this.waitingReads.length > 0) {\n                const next = this.waitingReads.shift();\n                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n            }\n            if (err && data && tried < this.maxRetries) {\n                setTimeout(()=>{\n                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                }, wait);\n                return;\n            }\n            callback(err, data);\n        };\n        const fc = this.backend[fcName].bind(this.backend);\n        if (fc.length === 2) {\n            try {\n                const r = fc(lng, ns);\n                if (r && typeof r.then === \"function\") {\n                    r.then((data)=>resolver(null, data)).catch(resolver);\n                } else {\n                    resolver(null, r);\n                }\n            } catch (err) {\n                resolver(err);\n            }\n            return;\n        }\n        return fc(lng, ns, resolver);\n    }\n    prepareLoading(languages, namespaces) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let callback = arguments.length > 3 ? arguments[3] : undefined;\n        if (!this.backend) {\n            this.logger.warn(\"No backend was added via i18next.use. Will not load resources.\");\n            return callback && callback();\n        }\n        if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);\n        if (isString(namespaces)) namespaces = [\n            namespaces\n        ];\n        const toLoad = this.queueLoad(languages, namespaces, options, callback);\n        if (!toLoad.toLoad.length) {\n            if (!toLoad.pending.length) callback();\n            return null;\n        }\n        toLoad.toLoad.forEach((name)=>{\n            this.loadOne(name);\n        });\n    }\n    load(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {}, callback);\n    }\n    reload(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {\n            reload: true\n        }, callback);\n    }\n    loadOne(name) {\n        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        this.read(lng, ns, \"read\", undefined, undefined, (err, data)=>{\n            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n            this.loaded(name, err, data);\n        });\n    }\n    saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n        let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ()=>{};\n        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n            this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n            return;\n        }\n        if (key === undefined || key === null || key === \"\") return;\n        if (this.backend && this.backend.create) {\n            const opts = {\n                ...options,\n                isUpdate\n            };\n            const fc = this.backend.create.bind(this.backend);\n            if (fc.length < 6) {\n                try {\n                    let r;\n                    if (fc.length === 5) {\n                        r = fc(languages, namespace, key, fallbackValue, opts);\n                    } else {\n                        r = fc(languages, namespace, key, fallbackValue);\n                    }\n                    if (r && typeof r.then === \"function\") {\n                        r.then((data)=>clb(null, data)).catch(clb);\n                    } else {\n                        clb(null, r);\n                    }\n                } catch (err) {\n                    clb(err);\n                }\n            } else {\n                fc(languages, namespace, key, fallbackValue, clb, opts);\n            }\n        }\n        if (!languages || !languages[0]) return;\n        this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n}\nconst get = ()=>({\n        debug: false,\n        initImmediate: true,\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: [\n            \"translation\"\n        ],\n        fallbackLng: [\n            \"dev\"\n        ],\n        fallbackNS: false,\n        supportedLngs: false,\n        nonExplicitSupportedLngs: false,\n        load: \"all\",\n        preload: false,\n        simplifyPluralSuffix: true,\n        keySeparator: \".\",\n        nsSeparator: \":\",\n        pluralSeparator: \"_\",\n        contextSeparator: \"_\",\n        partialBundledLanguages: false,\n        saveMissing: false,\n        updateMissing: false,\n        saveMissingTo: \"fallback\",\n        saveMissingPlurals: true,\n        missingKeyHandler: false,\n        missingInterpolationHandler: false,\n        postProcess: false,\n        postProcessPassResolved: false,\n        returnNull: false,\n        returnEmptyString: true,\n        returnObjects: false,\n        joinArrays: false,\n        returnedObjectHandler: false,\n        parseMissingKeyHandler: false,\n        appendNamespaceToMissingKey: false,\n        appendNamespaceToCIMode: false,\n        overloadTranslationOptionHandler: (args)=>{\n            let ret = {};\n            if (typeof args[1] === \"object\") ret = args[1];\n            if (isString(args[1])) ret.defaultValue = args[1];\n            if (isString(args[2])) ret.tDescription = args[2];\n            if (typeof args[2] === \"object\" || typeof args[3] === \"object\") {\n                const options = args[3] || args[2];\n                Object.keys(options).forEach((key)=>{\n                    ret[key] = options[key];\n                });\n            }\n            return ret;\n        },\n        interpolation: {\n            escapeValue: true,\n            format: (value)=>value,\n            prefix: \"{{\",\n            suffix: \"}}\",\n            formatSeparator: \",\",\n            unescapePrefix: \"-\",\n            nestingPrefix: \"$t(\",\n            nestingSuffix: \")\",\n            nestingOptionsSeparator: \",\",\n            maxReplaces: 1000,\n            skipOnVariables: true\n        }\n    });\nconst transformOptions = (options)=>{\n    if (isString(options.ns)) options.ns = [\n        options.ns\n    ];\n    if (isString(options.fallbackLng)) options.fallbackLng = [\n        options.fallbackLng\n    ];\n    if (isString(options.fallbackNS)) options.fallbackNS = [\n        options.fallbackNS\n    ];\n    if (options.supportedLngs && options.supportedLngs.indexOf(\"cimode\") < 0) {\n        options.supportedLngs = options.supportedLngs.concat([\n            \"cimode\"\n        ]);\n    }\n    return options;\n};\nconst noop = ()=>{};\nconst bindMemberFunctions = (inst)=>{\n    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n    mems.forEach((mem)=>{\n        if (typeof inst[mem] === \"function\") {\n            inst[mem] = inst[mem].bind(inst);\n        }\n    });\n};\nclass I18n extends EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        super();\n        this.options = transformOptions(options);\n        this.services = {};\n        this.logger = baseLogger;\n        this.modules = {\n            external: []\n        };\n        bindMemberFunctions(this);\n        if (callback && !this.isInitialized && !options.isClone) {\n            if (!this.options.initImmediate) {\n                this.init(options, callback);\n                return this;\n            }\n            setTimeout(()=>{\n                this.init(options, callback);\n            }, 0);\n        }\n    }\n    init() {\n        var _this = this;\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        this.isInitializing = true;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (!options.defaultNS && options.defaultNS !== false && options.ns) {\n            if (isString(options.ns)) {\n                options.defaultNS = options.ns;\n            } else if (options.ns.indexOf(\"translation\") < 0) {\n                options.defaultNS = options.ns[0];\n            }\n        }\n        const defOpts = get();\n        this.options = {\n            ...defOpts,\n            ...this.options,\n            ...transformOptions(options)\n        };\n        if (this.options.compatibilityAPI !== \"v1\") {\n            this.options.interpolation = {\n                ...defOpts.interpolation,\n                ...this.options.interpolation\n            };\n        }\n        if (options.keySeparator !== undefined) {\n            this.options.userDefinedKeySeparator = options.keySeparator;\n        }\n        if (options.nsSeparator !== undefined) {\n            this.options.userDefinedNsSeparator = options.nsSeparator;\n        }\n        const createClassOnDemand = (ClassOrObject)=>{\n            if (!ClassOrObject) return null;\n            if (typeof ClassOrObject === \"function\") return new ClassOrObject();\n            return ClassOrObject;\n        };\n        if (!this.options.isClone) {\n            if (this.modules.logger) {\n                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n            } else {\n                baseLogger.init(null, this.options);\n            }\n            let formatter;\n            if (this.modules.formatter) {\n                formatter = this.modules.formatter;\n            } else if (typeof Intl !== \"undefined\") {\n                formatter = Formatter;\n            }\n            const lu = new LanguageUtil(this.options);\n            this.store = new ResourceStore(this.options.resources, this.options);\n            const s = this.services;\n            s.logger = baseLogger;\n            s.resourceStore = this.store;\n            s.languageUtils = lu;\n            s.pluralResolver = new PluralResolver(lu, {\n                prepend: this.options.pluralSeparator,\n                compatibilityJSON: this.options.compatibilityJSON,\n                simplifyPluralSuffix: this.options.simplifyPluralSuffix\n            });\n            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n                s.formatter = createClassOnDemand(formatter);\n                s.formatter.init(s, this.options);\n                this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n            }\n            s.interpolator = new Interpolator(this.options);\n            s.utils = {\n                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n            };\n            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n            s.backendConnector.on(\"*\", function(event) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                _this.emit(event, ...args);\n            });\n            if (this.modules.languageDetector) {\n                s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n            }\n            if (this.modules.i18nFormat) {\n                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                if (s.i18nFormat.init) s.i18nFormat.init(this);\n            }\n            this.translator = new Translator(this.services, this.options);\n            this.translator.on(\"*\", function(event) {\n                for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                _this.emit(event, ...args);\n            });\n            this.modules.external.forEach((m)=>{\n                if (m.init) m.init(this);\n            });\n        }\n        this.format = this.options.interpolation.format;\n        if (!callback) callback = noop;\n        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n            if (codes.length > 0 && codes[0] !== \"dev\") this.options.lng = codes[0];\n        }\n        if (!this.services.languageDetector && !this.options.lng) {\n            this.logger.warn(\"init: no languageDetector is used and no lng is defined\");\n        }\n        const storeApi = [\n            \"getResource\",\n            \"hasResourceBundle\",\n            \"getResourceBundle\",\n            \"getDataByLanguage\"\n        ];\n        storeApi.forEach((fcName)=>{\n            this[fcName] = function() {\n                return _this.store[fcName](...arguments);\n            };\n        });\n        const storeApiChained = [\n            \"addResource\",\n            \"addResources\",\n            \"addResourceBundle\",\n            \"removeResourceBundle\"\n        ];\n        storeApiChained.forEach((fcName)=>{\n            this[fcName] = function() {\n                _this.store[fcName](...arguments);\n                return _this;\n            };\n        });\n        const deferred = defer();\n        const load = ()=>{\n            const finish = (err, t)=>{\n                this.isInitializing = false;\n                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn(\"init: i18next is already initialized. You should call init just once!\");\n                this.isInitialized = true;\n                if (!this.options.isClone) this.logger.log(\"initialized\", this.options);\n                this.emit(\"initialized\", this.options);\n                deferred.resolve(t);\n                callback(err, t);\n            };\n            if (this.languages && this.options.compatibilityAPI !== \"v1\" && !this.isInitialized) return finish(null, this.t.bind(this));\n            this.changeLanguage(this.options.lng, finish);\n        };\n        if (this.options.resources || !this.options.initImmediate) {\n            load();\n        } else {\n            setTimeout(load, 0);\n        }\n        return deferred;\n    }\n    loadResources(language) {\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        let usedCallback = callback;\n        const usedLng = isString(language) ? language : this.language;\n        if (typeof language === \"function\") usedCallback = language;\n        if (!this.options.resources || this.options.partialBundledLanguages) {\n            if (usedLng && usedLng.toLowerCase() === \"cimode\" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n            const toLoad = [];\n            const append = (lng)=>{\n                if (!lng) return;\n                if (lng === \"cimode\") return;\n                const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n                lngs.forEach((l)=>{\n                    if (l === \"cimode\") return;\n                    if (toLoad.indexOf(l) < 0) toLoad.push(l);\n                });\n            };\n            if (!usedLng) {\n                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                fallbacks.forEach((l)=>append(l));\n            } else {\n                append(usedLng);\n            }\n            if (this.options.preload) {\n                this.options.preload.forEach((l)=>append(l));\n            }\n            this.services.backendConnector.load(toLoad, this.options.ns, (e)=>{\n                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n                usedCallback(e);\n            });\n        } else {\n            usedCallback(null);\n        }\n    }\n    reloadResources(lngs, ns, callback) {\n        const deferred = defer();\n        if (typeof lngs === \"function\") {\n            callback = lngs;\n            lngs = undefined;\n        }\n        if (typeof ns === \"function\") {\n            callback = ns;\n            ns = undefined;\n        }\n        if (!lngs) lngs = this.languages;\n        if (!ns) ns = this.options.ns;\n        if (!callback) callback = noop;\n        this.services.backendConnector.reload(lngs, ns, (err)=>{\n            deferred.resolve();\n            callback(err);\n        });\n        return deferred;\n    }\n    use(module) {\n        if (!module) throw new Error(\"You are passing an undefined module! Please check the object you are passing to i18next.use()\");\n        if (!module.type) throw new Error(\"You are passing a wrong module! Please check the object you are passing to i18next.use()\");\n        if (module.type === \"backend\") {\n            this.modules.backend = module;\n        }\n        if (module.type === \"logger\" || module.log && module.warn && module.error) {\n            this.modules.logger = module;\n        }\n        if (module.type === \"languageDetector\") {\n            this.modules.languageDetector = module;\n        }\n        if (module.type === \"i18nFormat\") {\n            this.modules.i18nFormat = module;\n        }\n        if (module.type === \"postProcessor\") {\n            postProcessor.addPostProcessor(module);\n        }\n        if (module.type === \"formatter\") {\n            this.modules.formatter = module;\n        }\n        if (module.type === \"3rdParty\") {\n            this.modules.external.push(module);\n        }\n        return this;\n    }\n    setResolvedLanguage(l) {\n        if (!l || !this.languages) return;\n        if ([\n            \"cimode\",\n            \"dev\"\n        ].indexOf(l) > -1) return;\n        for(let li = 0; li < this.languages.length; li++){\n            const lngInLngs = this.languages[li];\n            if ([\n                \"cimode\",\n                \"dev\"\n            ].indexOf(lngInLngs) > -1) continue;\n            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n                this.resolvedLanguage = lngInLngs;\n                break;\n            }\n        }\n    }\n    changeLanguage(lng, callback) {\n        var _this2 = this;\n        this.isLanguageChangingTo = lng;\n        const deferred = defer();\n        this.emit(\"languageChanging\", lng);\n        const setLngProps = (l)=>{\n            this.language = l;\n            this.languages = this.services.languageUtils.toResolveHierarchy(l);\n            this.resolvedLanguage = undefined;\n            this.setResolvedLanguage(l);\n        };\n        const done = (err, l)=>{\n            if (l) {\n                setLngProps(l);\n                this.translator.changeLanguage(l);\n                this.isLanguageChangingTo = undefined;\n                this.emit(\"languageChanged\", l);\n                this.logger.log(\"languageChanged\", l);\n            } else {\n                this.isLanguageChangingTo = undefined;\n            }\n            deferred.resolve(function() {\n                return _this2.t(...arguments);\n            });\n            if (callback) callback(err, function() {\n                return _this2.t(...arguments);\n            });\n        };\n        const setLng = (lngs)=>{\n            if (!lng && !lngs && this.services.languageDetector) lngs = [];\n            const l = isString(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);\n            if (l) {\n                if (!this.language) {\n                    setLngProps(l);\n                }\n                if (!this.translator.language) this.translator.changeLanguage(l);\n                if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);\n            }\n            this.loadResources(l, (err)=>{\n                done(err, l);\n            });\n        };\n        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n            setLng(this.services.languageDetector.detect());\n        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n            if (this.services.languageDetector.detect.length === 0) {\n                this.services.languageDetector.detect().then(setLng);\n            } else {\n                this.services.languageDetector.detect(setLng);\n            }\n        } else {\n            setLng(lng);\n        }\n        return deferred;\n    }\n    getFixedT(lng, ns, keyPrefix) {\n        var _this3 = this;\n        const fixedT = function(key, opts) {\n            let options;\n            if (typeof opts !== \"object\") {\n                for(var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){\n                    rest[_key3 - 2] = arguments[_key3];\n                }\n                options = _this3.options.overloadTranslationOptionHandler([\n                    key,\n                    opts\n                ].concat(rest));\n            } else {\n                options = {\n                    ...opts\n                };\n            }\n            options.lng = options.lng || fixedT.lng;\n            options.lngs = options.lngs || fixedT.lngs;\n            options.ns = options.ns || fixedT.ns;\n            if (options.keyPrefix !== \"\") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;\n            const keySeparator = _this3.options.keySeparator || \".\";\n            let resultKey;\n            if (options.keyPrefix && Array.isArray(key)) {\n                resultKey = key.map((k)=>`${options.keyPrefix}${keySeparator}${k}`);\n            } else {\n                resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;\n            }\n            return _this3.t(resultKey, options);\n        };\n        if (isString(lng)) {\n            fixedT.lng = lng;\n        } else {\n            fixedT.lngs = lng;\n        }\n        fixedT.ns = ns;\n        fixedT.keyPrefix = keyPrefix;\n        return fixedT;\n    }\n    t() {\n        return this.translator && this.translator.translate(...arguments);\n    }\n    exists() {\n        return this.translator && this.translator.exists(...arguments);\n    }\n    setDefaultNamespace(ns) {\n        this.options.defaultNS = ns;\n    }\n    hasLoadedNamespace(ns) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (!this.isInitialized) {\n            this.logger.warn(\"hasLoadedNamespace: i18next was not initialized\", this.languages);\n            return false;\n        }\n        if (!this.languages || !this.languages.length) {\n            this.logger.warn(\"hasLoadedNamespace: i18n.languages were undefined or empty\", this.languages);\n            return false;\n        }\n        const lng = options.lng || this.resolvedLanguage || this.languages[0];\n        const fallbackLng = this.options ? this.options.fallbackLng : false;\n        const lastLng = this.languages[this.languages.length - 1];\n        if (lng.toLowerCase() === \"cimode\") return true;\n        const loadNotPending = (l, n)=>{\n            const loadState = this.services.backendConnector.state[`${l}|${n}`];\n            return loadState === -1 || loadState === 0 || loadState === 2;\n        };\n        if (options.precheck) {\n            const preResult = options.precheck(this, loadNotPending);\n            if (preResult !== undefined) return preResult;\n        }\n        if (this.hasResourceBundle(lng, ns)) return true;\n        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n        return false;\n    }\n    loadNamespaces(ns, callback) {\n        const deferred = defer();\n        if (!this.options.ns) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        if (isString(ns)) ns = [\n            ns\n        ];\n        ns.forEach((n)=>{\n            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n        });\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    loadLanguages(lngs, callback) {\n        const deferred = defer();\n        if (isString(lngs)) lngs = [\n            lngs\n        ];\n        const preloaded = this.options.preload || [];\n        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));\n        if (!newLngs.length) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        this.options.preload = preloaded.concat(newLngs);\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    dir(lng) {\n        if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);\n        if (!lng) return \"rtl\";\n        const rtlLngs = [\n            \"ar\",\n            \"shu\",\n            \"sqr\",\n            \"ssh\",\n            \"xaa\",\n            \"yhd\",\n            \"yud\",\n            \"aao\",\n            \"abh\",\n            \"abv\",\n            \"acm\",\n            \"acq\",\n            \"acw\",\n            \"acx\",\n            \"acy\",\n            \"adf\",\n            \"ads\",\n            \"aeb\",\n            \"aec\",\n            \"afb\",\n            \"ajp\",\n            \"apc\",\n            \"apd\",\n            \"arb\",\n            \"arq\",\n            \"ars\",\n            \"ary\",\n            \"arz\",\n            \"auz\",\n            \"avl\",\n            \"ayh\",\n            \"ayl\",\n            \"ayn\",\n            \"ayp\",\n            \"bbz\",\n            \"pga\",\n            \"he\",\n            \"iw\",\n            \"ps\",\n            \"pbt\",\n            \"pbu\",\n            \"pst\",\n            \"prp\",\n            \"prd\",\n            \"ug\",\n            \"ur\",\n            \"ydd\",\n            \"yds\",\n            \"yih\",\n            \"ji\",\n            \"yi\",\n            \"hbo\",\n            \"men\",\n            \"xmn\",\n            \"fa\",\n            \"jpr\",\n            \"peo\",\n            \"pes\",\n            \"prs\",\n            \"dv\",\n            \"sam\",\n            \"ckb\"\n        ];\n        const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());\n        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf(\"-arab\") > 1 ? \"rtl\" : \"ltr\";\n    }\n    static createInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        return new I18n(options, callback);\n    }\n    cloneInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        const forkResourceStore = options.forkResourceStore;\n        if (forkResourceStore) delete options.forkResourceStore;\n        const mergedOptions = {\n            ...this.options,\n            ...options,\n            ...{\n                isClone: true\n            }\n        };\n        const clone = new I18n(mergedOptions);\n        if (options.debug !== undefined || options.prefix !== undefined) {\n            clone.logger = clone.logger.clone(options);\n        }\n        const membersToCopy = [\n            \"store\",\n            \"services\",\n            \"language\"\n        ];\n        membersToCopy.forEach((m)=>{\n            clone[m] = this[m];\n        });\n        clone.services = {\n            ...this.services\n        };\n        clone.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        if (forkResourceStore) {\n            clone.store = new ResourceStore(this.store.data, mergedOptions);\n            clone.services.resourceStore = clone.store;\n        }\n        clone.translator = new Translator(clone.services, mergedOptions);\n        clone.translator.on(\"*\", function(event) {\n            for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){\n                args[_key4 - 1] = arguments[_key4];\n            }\n            clone.emit(event, ...args);\n        });\n        clone.init(mergedOptions, callback);\n        clone.translator.options = mergedOptions;\n        clone.translator.backendConnector.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        return clone;\n    }\n    toJSON() {\n        return {\n            options: this.options,\n            store: this.store,\n            language: this.language,\n            languages: this.languages,\n            resolvedLanguage: this.resolvedLanguage\n        };\n    }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2VzbS9pMThuZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLFdBQVdDLENBQUFBLE1BQU8sT0FBT0EsUUFBUTtBQUN2QyxNQUFNQyxRQUFRO0lBQ1osSUFBSUM7SUFDSixJQUFJQztJQUNKLE1BQU1DLFVBQVUsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUNwQ0wsTUFBTUk7UUFDTkgsTUFBTUk7SUFDUjtJQUNBSCxRQUFRRSxPQUFPLEdBQUdKO0lBQ2xCRSxRQUFRRyxNQUFNLEdBQUdKO0lBQ2pCLE9BQU9DO0FBQ1Q7QUFDQSxNQUFNSSxhQUFhQyxDQUFBQTtJQUNqQixJQUFJQSxVQUFVLE1BQU0sT0FBTztJQUMzQixPQUFPLEtBQUtBO0FBQ2Q7QUFDQSxNQUFNQyxPQUFPLENBQUNDLEdBQUdDLEdBQUdDO0lBQ2xCRixFQUFFRyxPQUFPLENBQUNDLENBQUFBO1FBQ1IsSUFBSUgsQ0FBQyxDQUFDRyxFQUFFLEVBQUVGLENBQUMsQ0FBQ0UsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDdkI7QUFDRjtBQUNBLE1BQU1DLDRCQUE0QjtBQUNsQyxNQUFNQyxXQUFXQyxDQUFBQSxNQUFPQSxPQUFPQSxJQUFJQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUlELElBQUlFLE9BQU8sQ0FBQ0osMkJBQTJCLE9BQU9FO0FBQ3ZHLE1BQU1HLHVCQUF1QlosQ0FBQUEsU0FBVSxDQUFDQSxVQUFVVixTQUFTVTtBQUMzRCxNQUFNYSxnQkFBZ0IsQ0FBQ2IsUUFBUWMsTUFBTUM7SUFDbkMsTUFBTUMsUUFBUSxDQUFDMUIsU0FBU3dCLFFBQVFBLE9BQU9BLEtBQUtHLEtBQUssQ0FBQztJQUNsRCxJQUFJQyxhQUFhO0lBQ2pCLE1BQU9BLGFBQWFGLE1BQU1HLE1BQU0sR0FBRyxFQUFHO1FBQ3BDLElBQUlQLHFCQUFxQlosU0FBUyxPQUFPLENBQUM7UUFDMUMsTUFBTVMsTUFBTUQs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O0FBQzlDLE1BQU1DLGdCQUFnQlUsU0FBU1YsYUFBYTtBQUVpSyIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL2kxOG5leHQvZGlzdC9lc20vaTE4bmV4dC5qcz82OGU1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzU3RyaW5nID0gb2JqID0+IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuY29uc3QgZGVmZXIgPSAoKSA9PiB7XG4gIGxldCByZXM7XG4gIGxldCByZWo7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzID0gcmVzb2x2ZTtcbiAgICByZWogPSByZWplY3Q7XG4gIH0pO1xuICBwcm9taXNlLnJlc29sdmUgPSByZXM7XG4gIHByb21pc2UucmVqZWN0ID0gcmVqO1xuICByZXR1cm4gcHJvbWlzZTtcbn07XG5jb25zdCBtYWtlU3RyaW5nID0gb2JqZWN0ID0+IHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gJyc7XG4gIHJldHVybiAnJyArIG9iamVjdDtcbn07XG5jb25zdCBjb3B5ID0gKGEsIHMsIHQpID0+IHtcbiAgYS5mb3JFYWNoKG0gPT4ge1xuICAgIGlmIChzW21dKSB0W21dID0gc1ttXTtcbiAgfSk7XG59O1xuY29uc3QgbGFzdE9mUGF0aFNlcGFyYXRvclJlZ0V4cCA9IC8jIyMvZztcbmNvbnN0IGNsZWFuS2V5ID0ga2V5ID0+IGtleSAmJiBrZXkuaW5kZXhPZignIyMjJykgPiAtMSA/IGtleS5yZXBsYWNlKGxhc3RPZlBhdGhTZXBhcmF0b3JSZWdFeHAsICcuJykgOiBrZXk7XG5jb25zdCBjYW5Ob3RUcmF2ZXJzZURlZXBlciA9IG9iamVjdCA9PiAhb2JqZWN0IHx8IGlzU3RyaW5nKG9iamVjdCk7XG5jb25zdCBnZXRMYXN0T2ZQYXRoID0gKG9iamVjdCwgcGF0aCwgRW1wdHkpID0+IHtcbiAgY29uc3Qgc3RhY2sgPSAhaXNTdHJpbmcocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgc3RhY2tJbmRleCA9IDA7XG4gIHdoaWxlIChzdGFja0luZGV4IDwgc3RhY2subGVuZ3RoIC0gMSkge1xuICAgIGlmIChjYW5Ob3RUcmF2ZXJzZURlZXBlcihvYmplY3QpKSByZXR1cm4ge307XG4gICAgY29uc3Qga2V5ID0gY2xlYW5LZXkoc3RhY2tbc3RhY2tJbmRleF0pO1xuICAgIGlmICghb2JqZWN0W2tleV0gJiYgRW1wdHkpIG9iamVjdFtrZXldID0gbmV3IEVtcHR5KCk7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3QgPSB7fTtcbiAgICB9XG4gICAgKytzdGFja0luZGV4O1xuICB9XG4gIGlmIChjYW5Ob3RUcmF2ZXJzZURlZXBlcihvYmplY3QpKSByZXR1cm4ge307XG4gIHJldHVybiB7XG4gICAgb2JqOiBvYmplY3QsXG4gICAgazogY2xlYW5LZXkoc3RhY2tbc3RhY2tJbmRleF0pXG4gIH07XG59O1xuY29uc3Qgc2V0UGF0aCA9IChvYmplY3QsIHBhdGgsIG5ld1ZhbHVlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgsIE9iamVjdCk7XG4gIGlmIChvYmogIT09IHVuZGVmaW5lZCB8fCBwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIG9ialtrXSA9IG5ld1ZhbHVlO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgbGV0IHAgPSBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSk7XG4gIGxldCBsYXN0ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHAsIE9iamVjdCk7XG4gIHdoaWxlIChsYXN0Lm9iaiA9PT0gdW5kZWZpbmVkICYmIHAubGVuZ3RoKSB7XG4gICAgZSA9IGAke3BbcC5sZW5ndGggLSAxXX0uJHtlfWA7XG4gICAgcCA9IHAuc2xpY2UoMCwgcC5sZW5ndGggLSAxKTtcbiAgICBsYXN0ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHAsIE9iamVjdCk7XG4gICAgaWYgKGxhc3QgJiYgbGFzdC5vYmogJiYgdHlwZW9mIGxhc3Qub2JqW2Ake2xhc3Qua30uJHtlfWBdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbGFzdC5vYmogPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGxhc3Qub2JqW2Ake2xhc3Qua30uJHtlfWBdID0gbmV3VmFsdWU7XG59O1xuY29uc3QgcHVzaFBhdGggPSAob2JqZWN0LCBwYXRoLCBuZXdWYWx1ZSwgY29uY2F0KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgsIE9iamVjdCk7XG4gIG9ialtrXSA9IG9ialtrXSB8fCBbXTtcbiAgb2JqW2tdLnB1c2gobmV3VmFsdWUpO1xufTtcbmNvbnN0IGdldFBhdGggPSAob2JqZWN0LCBwYXRoKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgpO1xuICBpZiAoIW9iaikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgcmV0dXJuIG9ialtrXTtcbn07XG5jb25zdCBnZXRQYXRoV2l0aERlZmF1bHRzID0gKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpID0+IHtcbiAgY29uc3QgdmFsdWUgPSBnZXRQYXRoKGRhdGEsIGtleSk7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBnZXRQYXRoKGRlZmF1bHREYXRhLCBrZXkpO1xufTtcbmNvbnN0IGRlZXBFeHRlbmQgPSAodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkgPT4ge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XG4gICAgaWYgKHByb3AgIT09ICdfX3Byb3RvX18nICYmIHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIGlmIChwcm9wIGluIHRhcmdldCkge1xuICAgICAgICBpZiAoaXNTdHJpbmcodGFyZ2V0W3Byb3BdKSB8fCB0YXJnZXRbcHJvcF0gaW5zdGFuY2VvZiBTdHJpbmcgfHwgaXNTdHJpbmcoc291cmNlW3Byb3BdKSB8fCBzb3VyY2VbcHJvcF0gaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICBpZiAob3ZlcndyaXRlKSB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSwgb3ZlcndyaXRlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmNvbnN0IHJlZ2V4RXNjYXBlID0gc3RyID0+IHN0ci5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgJ1xcXFwkJicpO1xudmFyIF9lbnRpdHlNYXAgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5OycsXG4gICcvJzogJyYjeDJGOydcbn07XG5jb25zdCBlc2NhcGUgPSBkYXRhID0+IHtcbiAgaWYgKGlzU3RyaW5nKGRhdGEpKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvWyY8PlwiJ1xcL10vZywgcyA9PiBfZW50aXR5TWFwW3NdKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn07XG5jbGFzcyBSZWdFeHBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHRoaXMucmVnRXhwTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVnRXhwUXVldWUgPSBbXTtcbiAgfVxuICBnZXRSZWdFeHAocGF0dGVybikge1xuICAgIGNvbnN0IHJlZ0V4cEZyb21DYWNoZSA9IHRoaXMucmVnRXhwTWFwLmdldChwYXR0ZXJuKTtcbiAgICBpZiAocmVnRXhwRnJvbUNhY2hlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZWdFeHBGcm9tQ2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IHJlZ0V4cE5ldyA9IG5ldyBSZWdFeHAocGF0dGVybik7XG4gICAgaWYgKHRoaXMucmVnRXhwUXVldWUubGVuZ3RoID09PSB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICB0aGlzLnJlZ0V4cE1hcC5kZWxldGUodGhpcy5yZWdFeHBRdWV1ZS5zaGlmdCgpKTtcbiAgICB9XG4gICAgdGhpcy5yZWdFeHBNYXAuc2V0KHBhdHRlcm4sIHJlZ0V4cE5ldyk7XG4gICAgdGhpcy5yZWdFeHBRdWV1ZS5wdXNoKHBhdHRlcm4pO1xuICAgIHJldHVybiByZWdFeHBOZXc7XG4gIH1cbn1cbmNvbnN0IGNoYXJzID0gWycgJywgJywnLCAnPycsICchJywgJzsnXTtcbmNvbnN0IGxvb2tzTGlrZU9iamVjdFBhdGhSZWdFeHBDYWNoZSA9IG5ldyBSZWdFeHBDYWNoZSgyMCk7XG5jb25zdCBsb29rc0xpa2VPYmplY3RQYXRoID0gKGtleSwgbnNTZXBhcmF0b3IsIGtleVNlcGFyYXRvcikgPT4ge1xuICBuc1NlcGFyYXRvciA9IG5zU2VwYXJhdG9yIHx8ICcnO1xuICBrZXlTZXBhcmF0b3IgPSBrZXlTZXBhcmF0b3IgfHwgJyc7XG4gIGNvbnN0IHBvc3NpYmxlQ2hhcnMgPSBjaGFycy5maWx0ZXIoYyA9PiBuc1NlcGFyYXRvci5pbmRleE9mKGMpIDwgMCAmJiBrZXlTZXBhcmF0b3IuaW5kZXhPZihjKSA8IDApO1xuICBpZiAocG9zc2libGVDaGFycy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICBjb25zdCByID0gbG9va3NMaWtlT2JqZWN0UGF0aFJlZ0V4cENhY2hlLmdldFJlZ0V4cChgKCR7cG9zc2libGVDaGFycy5tYXAoYyA9PiBjID09PSAnPycgPyAnXFxcXD8nIDogYykuam9pbignfCcpfSlgKTtcbiAgbGV0IG1hdGNoZWQgPSAhci50ZXN0KGtleSk7XG4gIGlmICghbWF0Y2hlZCkge1xuICAgIGNvbnN0IGtpID0ga2V5LmluZGV4T2Yoa2V5U2VwYXJhdG9yKTtcbiAgICBpZiAoa2kgPiAwICYmICFyLnRlc3Qoa2V5LnN1YnN0cmluZygwLCBraSkpKSB7XG4gICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZWQ7XG59O1xuY29uc3QgZGVlcEZpbmQgPSBmdW5jdGlvbiAob2JqLCBwYXRoKSB7XG4gIGxldCBrZXlTZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcuJztcbiAgaWYgKCFvYmopIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChvYmpbcGF0aF0pIHJldHVybiBvYmpbcGF0aF07XG4gIGNvbnN0IHRva2VucyA9IHBhdGguc3BsaXQoa2V5U2VwYXJhdG9yKTtcbiAgbGV0IGN1cnJlbnQgPSBvYmo7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDspIHtcbiAgICBpZiAoIWN1cnJlbnQgfHwgdHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgbmV4dDtcbiAgICBsZXQgbmV4dFBhdGggPSAnJztcbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRva2Vucy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGogIT09IGkpIHtcbiAgICAgICAgbmV4dFBhdGggKz0ga2V5U2VwYXJhdG9yO1xuICAgICAgfVxuICAgICAgbmV4dFBhdGggKz0gdG9rZW5zW2pdO1xuICAgICAgbmV4dCA9IGN1cnJlbnRbbmV4dFBhdGhdO1xuICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXS5pbmRleE9mKHR5cGVvZiBuZXh0KSA+IC0xICYmIGogPCB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGkgKz0gaiAtIGkgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudCA9IG5leHQ7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnQ7XG59O1xuY29uc3QgZ2V0Q2xlYW5lZENvZGUgPSBjb2RlID0+IGNvZGUgJiYgY29kZS5yZXBsYWNlKCdfJywgJy0nKTtcblxuY29uc3QgY29uc29sZUxvZ2dlciA9IHtcbiAgdHlwZTogJ2xvZ2dlcicsXG4gIGxvZyhhcmdzKSB7XG4gICAgdGhpcy5vdXRwdXQoJ2xvZycsIGFyZ3MpO1xuICB9LFxuICB3YXJuKGFyZ3MpIHtcbiAgICB0aGlzLm91dHB1dCgnd2FybicsIGFyZ3MpO1xuICB9LFxuICBlcnJvcihhcmdzKSB7XG4gICAgdGhpcy5vdXRwdXQoJ2Vycm9yJywgYXJncyk7XG4gIH0sXG4gIG91dHB1dCh0eXBlLCBhcmdzKSB7XG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZVt0eXBlXSkgY29uc29sZVt0eXBlXS5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgfVxufTtcbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmNyZXRlTG9nZ2VyKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuaW5pdChjb25jcmV0ZUxvZ2dlciwgb3B0aW9ucyk7XG4gIH1cbiAgaW5pdChjb25jcmV0ZUxvZ2dlcikge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLnByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8ICdpMThuZXh0Oic7XG4gICAgdGhpcy5sb2dnZXIgPSBjb25jcmV0ZUxvZ2dlciB8fCBjb25zb2xlTG9nZ2VyO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gIH1cbiAgbG9nKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnbG9nJywgJycsIHRydWUpO1xuICB9XG4gIHdhcm4oKSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ3dhcm4nLCAnJywgdHJ1ZSk7XG4gIH1cbiAgZXJyb3IoKSB7XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ2Vycm9yJywgJycpO1xuICB9XG4gIGRlcHJlY2F0ZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZChhcmdzLCAnd2FybicsICdXQVJOSU5HIERFUFJFQ0FURUQ6ICcsIHRydWUpO1xuICB9XG4gIGZvcndhcmQoYXJncywgbHZsLCBwcmVmaXgsIGRlYnVnT25seSkge1xuICAgIGlmIChkZWJ1Z09ubHkgJiYgIXRoaXMuZGVidWcpIHJldHVybiBudWxsO1xuICAgIGlmIChpc1N0cmluZyhhcmdzWzBdKSkgYXJnc1swXSA9IGAke3ByZWZpeH0ke3RoaXMucHJlZml4fSAke2FyZ3NbMF19YDtcbiAgICByZXR1cm4gdGhpcy5sb2dnZXJbbHZsXShhcmdzKTtcbiAgfVxuICBjcmVhdGUobW9kdWxlTmFtZSkge1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKHRoaXMubG9nZ2VyLCB7XG4gICAgICAuLi57XG4gICAgICAgIHByZWZpeDogYCR7dGhpcy5wcmVmaXh9OiR7bW9kdWxlTmFtZX06YFxuICAgICAgfSxcbiAgICAgIC4uLnRoaXMub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIGNsb25lKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnM7XG4gICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCB0aGlzLnByZWZpeDtcbiAgICByZXR1cm4gbmV3IExvZ2dlcih0aGlzLmxvZ2dlciwgb3B0aW9ucyk7XG4gIH1cbn1cbnZhciBiYXNlTG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9ic2VydmVycyA9IHt9O1xuICB9XG4gIG9uKGV2ZW50cywgbGlzdGVuZXIpIHtcbiAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGlmICghdGhpcy5vYnNlcnZlcnNbZXZlbnRdKSB0aGlzLm9ic2VydmVyc1tldmVudF0gPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBudW1MaXN0ZW5lcnMgPSB0aGlzLm9ic2VydmVyc1tldmVudF0uZ2V0KGxpc3RlbmVyKSB8fCAwO1xuICAgICAgdGhpcy5vYnNlcnZlcnNbZXZlbnRdLnNldChsaXN0ZW5lciwgbnVtTGlzdGVuZXJzICsgMSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnNbZXZlbnRdKSByZXR1cm47XG4gICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlcnNbZXZlbnRdLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgZW1pdChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAodGhpcy5vYnNlcnZlcnNbZXZlbnRdKSB7XG4gICAgICBjb25zdCBjbG9uZWQgPSBBcnJheS5mcm9tKHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5lbnRyaWVzKCkpO1xuICAgICAgY2xvbmVkLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICAgIGxldCBbb2JzZXJ2ZXIsIG51bVRpbWVzQWRkZWRdID0gX3JlZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UaW1lc0FkZGVkOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9ic2VydmVyc1snKiddKSB7XG4gICAgICBjb25zdCBjbG9uZWQgPSBBcnJheS5mcm9tKHRoaXMub2JzZXJ2ZXJzWycqJ10uZW50cmllcygpKTtcbiAgICAgIGNsb25lZC5mb3JFYWNoKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IFtvYnNlcnZlciwgbnVtVGltZXNBZGRlZF0gPSBfcmVmMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UaW1lc0FkZGVkOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlci5hcHBseShvYnNlcnZlciwgW2V2ZW50LCAuLi5hcmdzXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBSZXNvdXJjZVN0b3JlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBuczogWyd0cmFuc2xhdGlvbiddLFxuICAgICAgZGVmYXVsdE5TOiAndHJhbnNsYXRpb24nXG4gICAgfTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAodGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yID0gJy4nO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBhZGROYW1lc3BhY2VzKG5zKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG5zKSA8IDApIHtcbiAgICAgIHRoaXMub3B0aW9ucy5ucy5wdXNoKG5zKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTmFtZXNwYWNlcyhucykge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcHRpb25zLm5zLmluZGV4T2YobnMpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVzb3VyY2UobG5nLCBucywga2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgY29uc3QgaWdub3JlSlNPTlN0cnVjdHVyZSA9IG9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlIDogdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmU7XG4gICAgbGV0IHBhdGg7XG4gICAgaWYgKGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcGF0aCA9IGxuZy5zcGxpdCgnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gW2xuZywgbnNdO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgcGF0aC5wdXNoKC4uLmtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoa2V5KSAmJiBrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgICBwYXRoLnB1c2goLi4ua2V5LnNwbGl0KGtleVNlcGFyYXRvcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGdldFBhdGgodGhpcy5kYXRhLCBwYXRoKTtcbiAgICBpZiAoIXJlc3VsdCAmJiAhbnMgJiYgIWtleSAmJiBsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIGxuZyA9IHBhdGhbMF07XG4gICAgICBucyA9IHBhdGhbMV07XG4gICAgICBrZXkgPSBwYXRoLnNsaWNlKDIpLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCB8fCAhaWdub3JlSlNPTlN0cnVjdHVyZSB8fCAhaXNTdHJpbmcoa2V5KSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gZGVlcEZpbmQodGhpcy5kYXRhICYmIHRoaXMuZGF0YVtsbmddICYmIHRoaXMuZGF0YVtsbmddW25zXSwga2V5LCBrZXlTZXBhcmF0b3IpO1xuICB9XG4gIGFkZFJlc291cmNlKGxuZywgbnMsIGtleSwgdmFsdWUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge1xuICAgICAgc2lsZW50OiBmYWxzZVxuICAgIH07XG4gICAgY29uc3Qga2V5U2VwYXJhdG9yID0gb3B0aW9ucy5rZXlTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMua2V5U2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvcjtcbiAgICBsZXQgcGF0aCA9IFtsbmcsIG5zXTtcbiAgICBpZiAoa2V5KSBwYXRoID0gcGF0aC5jb25jYXQoa2V5U2VwYXJhdG9yID8ga2V5LnNwbGl0KGtleVNlcGFyYXRvcikgOiBrZXkpO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICAgIHZhbHVlID0gbnM7XG4gICAgICBucyA9IHBhdGhbMV07XG4gICAgfVxuICAgIHRoaXMuYWRkTmFtZXNwYWNlcyhucyk7XG4gICAgc2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgsIHZhbHVlKTtcbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywga2V5LCB2YWx1ZSk7XG4gIH1cbiAgYWRkUmVzb3VyY2VzKGxuZywgbnMsIHJlc291cmNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7XG4gICAgICBzaWxlbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG0gaW4gcmVzb3VyY2VzKSB7XG4gICAgICBpZiAoaXNTdHJpbmcocmVzb3VyY2VzW21dKSB8fCBBcnJheS5pc0FycmF5KHJlc291cmNlc1ttXSkpIHRoaXMuYWRkUmVzb3VyY2UobG5nLCBucywgbSwgcmVzb3VyY2VzW21dLCB7XG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCByZXNvdXJjZXMpO1xuICB9XG4gIGFkZFJlc291cmNlQnVuZGxlKGxuZywgbnMsIHJlc291cmNlcywgZGVlcCwgb3ZlcndyaXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHtcbiAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgICBza2lwQ29weTogZmFsc2VcbiAgICB9O1xuICAgIGxldCBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICAgIGRlZXAgPSByZXNvdXJjZXM7XG4gICAgICByZXNvdXJjZXMgPSBucztcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICB9XG4gICAgdGhpcy5hZGROYW1lc3BhY2VzKG5zKTtcbiAgICBsZXQgcGFjayA9IGdldFBhdGgodGhpcy5kYXRhLCBwYXRoKSB8fCB7fTtcbiAgICBpZiAoIW9wdGlvbnMuc2tpcENvcHkpIHJlc291cmNlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzb3VyY2VzKSk7XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGRlZXBFeHRlbmQocGFjaywgcmVzb3VyY2VzLCBvdmVyd3JpdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrID0ge1xuICAgICAgICAuLi5wYWNrLFxuICAgICAgICAuLi5yZXNvdXJjZXNcbiAgICAgIH07XG4gICAgfVxuICAgIHNldFBhdGgodGhpcy5kYXRhLCBwYXRoLCBwYWNrKTtcbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywgcmVzb3VyY2VzKTtcbiAgfVxuICByZW1vdmVSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgaWYgKHRoaXMuaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbbG5nXVtuc107XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlTmFtZXNwYWNlcyhucyk7XG4gICAgdGhpcy5lbWl0KCdyZW1vdmVkJywgbG5nLCBucyk7XG4gIH1cbiAgaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIHJldHVybiB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0UmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIGlmICghbnMpIG5zID0gdGhpcy5vcHRpb25zLmRlZmF1bHROUztcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgPT09ICd2MScpIHJldHVybiB7XG4gICAgICAuLi57fSxcbiAgICAgIC4uLnRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucylcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpO1xuICB9XG4gIGdldERhdGFCeUxhbmd1YWdlKGxuZykge1xuICAgIHJldHVybiB0aGlzLmRhdGFbbG5nXTtcbiAgfVxuICBoYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMobG5nKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YUJ5TGFuZ3VhZ2UobG5nKTtcbiAgICBjb25zdCBuID0gZGF0YSAmJiBPYmplY3Qua2V5cyhkYXRhKSB8fCBbXTtcbiAgICByZXR1cm4gISFuLmZpbmQodiA9PiBkYXRhW3ZdICYmIE9iamVjdC5rZXlzKGRhdGFbdl0pLmxlbmd0aCA+IDApO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG59XG5cbnZhciBwb3N0UHJvY2Vzc29yID0ge1xuICBwcm9jZXNzb3JzOiB7fSxcbiAgYWRkUG9zdFByb2Nlc3Nvcihtb2R1bGUpIHtcbiAgICB0aGlzLnByb2Nlc3NvcnNbbW9kdWxlLm5hbWVdID0gbW9kdWxlO1xuICB9LFxuICBoYW5kbGUocHJvY2Vzc29ycywgdmFsdWUsIGtleSwgb3B0aW9ucywgdHJhbnNsYXRvcikge1xuICAgIHByb2Nlc3NvcnMuZm9yRWFjaChwcm9jZXNzb3IgPT4ge1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yc1twcm9jZXNzb3JdKSB2YWx1ZSA9IHRoaXMucHJvY2Vzc29yc1twcm9jZXNzb3JdLnByb2Nlc3ModmFsdWUsIGtleSwgb3B0aW9ucywgdHJhbnNsYXRvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG5jb25zdCBjaGVja2VkTG9hZGVkRm9yID0ge307XG5jbGFzcyBUcmFuc2xhdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICBjb3B5KFsncmVzb3VyY2VTdG9yZScsICdsYW5ndWFnZVV0aWxzJywgJ3BsdXJhbFJlc29sdmVyJywgJ2ludGVycG9sYXRvcicsICdiYWNrZW5kQ29ubmVjdG9yJywgJ2kxOG5Gb3JtYXQnLCAndXRpbHMnXSwgc2VydmljZXMsIHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9ICcuJztcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgndHJhbnNsYXRvcicpO1xuICB9XG4gIGNoYW5nZUxhbmd1YWdlKGxuZykge1xuICAgIGlmIChsbmcpIHRoaXMubGFuZ3VhZ2UgPSBsbmc7XG4gIH1cbiAgZXhpc3RzKGtleSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBpbnRlcnBvbGF0aW9uOiB7fVxuICAgIH07XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZShrZXksIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXNvbHZlZCAmJiByZXNvbHZlZC5yZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBleHRyYWN0RnJvbUtleShrZXksIG9wdGlvbnMpIHtcbiAgICBsZXQgbnNTZXBhcmF0b3IgPSBvcHRpb25zLm5zU2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zU2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLm5zU2VwYXJhdG9yO1xuICAgIGlmIChuc1NlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSBuc1NlcGFyYXRvciA9ICc6JztcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGxldCBuYW1lc3BhY2VzID0gb3B0aW9ucy5ucyB8fCB0aGlzLm9wdGlvbnMuZGVmYXVsdE5TIHx8IFtdO1xuICAgIGNvbnN0IHdvdWxkQ2hlY2tGb3JOc0luS2V5ID0gbnNTZXBhcmF0b3IgJiYga2V5LmluZGV4T2YobnNTZXBhcmF0b3IpID4gLTE7XG4gICAgY29uc3Qgc2VlbXNOYXR1cmFsTGFuZ3VhZ2UgPSAhdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkS2V5U2VwYXJhdG9yICYmICFvcHRpb25zLmtleVNlcGFyYXRvciAmJiAhdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkTnNTZXBhcmF0b3IgJiYgIW9wdGlvbnMubnNTZXBhcmF0b3IgJiYgIWxvb2tzTGlrZU9iamVjdFBhdGgoa2V5LCBuc1NlcGFyYXRvciwga2V5U2VwYXJhdG9yKTtcbiAgICBpZiAod291bGRDaGVja0Zvck5zSW5LZXkgJiYgIXNlZW1zTmF0dXJhbExhbmd1YWdlKSB7XG4gICAgICBjb25zdCBtID0ga2V5Lm1hdGNoKHRoaXMuaW50ZXJwb2xhdG9yLm5lc3RpbmdSZWdleHApO1xuICAgICAgaWYgKG0gJiYgbS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5hbWVzcGFjZXM6IGlzU3RyaW5nKG5hbWVzcGFjZXMpID8gW25hbWVzcGFjZXNdIDogbmFtZXNwYWNlc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQobnNTZXBhcmF0b3IpO1xuICAgICAgaWYgKG5zU2VwYXJhdG9yICE9PSBrZXlTZXBhcmF0b3IgfHwgbnNTZXBhcmF0b3IgPT09IGtleVNlcGFyYXRvciAmJiB0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihwYXJ0c1swXSkgPiAtMSkgbmFtZXNwYWNlcyA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICBrZXkgPSBwYXJ0cy5qb2luKGtleVNlcGFyYXRvcik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VzOiBpc1N0cmluZyhuYW1lc3BhY2VzKSA/IFtuYW1lc3BhY2VzXSA6IG5hbWVzcGFjZXNcbiAgICB9O1xuICB9XG4gIHRyYW5zbGF0ZShrZXlzLCBvcHRpb25zLCBsYXN0S2V5KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyAmJiB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIoYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykgb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIGlmIChrZXlzID09PSB1bmRlZmluZWQgfHwga2V5cyA9PT0gbnVsbCkgcmV0dXJuICcnO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkga2V5cyA9IFtTdHJpbmcoa2V5cyldO1xuICAgIGNvbnN0IHJldHVybkRldGFpbHMgPSBvcHRpb25zLnJldHVybkRldGFpbHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmV0dXJuRGV0YWlscyA6IHRoaXMub3B0aW9ucy5yZXR1cm5EZXRhaWxzO1xuICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IG9wdGlvbnMua2V5U2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmtleVNlcGFyYXRvciA6IHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgY29uc3Qge1xuICAgICAga2V5LFxuICAgICAgbmFtZXNwYWNlc1xuICAgIH0gPSB0aGlzLmV4dHJhY3RGcm9tS2V5KGtleXNba2V5cy5sZW5ndGggLSAxXSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGxuZyA9IG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2U7XG4gICAgY29uc3QgYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUgPSBvcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlIHx8IHRoaXMub3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb0NJTW9kZTtcbiAgICBpZiAobG5nICYmIGxuZy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJykge1xuICAgICAgaWYgKGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlKSB7XG4gICAgICAgIGNvbnN0IG5zU2VwYXJhdG9yID0gb3B0aW9ucy5uc1NlcGFyYXRvciB8fCB0aGlzLm9wdGlvbnMubnNTZXBhcmF0b3I7XG4gICAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlczogYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YCxcbiAgICAgICAgICAgIHVzZWRLZXk6IGtleSxcbiAgICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgICAgdXNlZExuZzogbG5nLFxuICAgICAgICAgICAgdXNlZE5TOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bmFtZXNwYWNlfSR7bnNTZXBhcmF0b3J9JHtrZXl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChyZXR1cm5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzOiBrZXksXG4gICAgICAgICAgdXNlZEtleToga2V5LFxuICAgICAgICAgIGV4YWN0VXNlZEtleToga2V5LFxuICAgICAgICAgIHVzZWRMbmc6IGxuZyxcbiAgICAgICAgICB1c2VkTlM6IG5hbWVzcGFjZSxcbiAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZShrZXlzLCBvcHRpb25zKTtcbiAgICBsZXQgcmVzID0gcmVzb2x2ZWQgJiYgcmVzb2x2ZWQucmVzO1xuICAgIGNvbnN0IHJlc1VzZWRLZXkgPSByZXNvbHZlZCAmJiByZXNvbHZlZC51c2VkS2V5IHx8IGtleTtcbiAgICBjb25zdCByZXNFeGFjdFVzZWRLZXkgPSByZXNvbHZlZCAmJiByZXNvbHZlZC5leGFjdFVzZWRLZXkgfHwga2V5O1xuICAgIGNvbnN0IHJlc1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHJlcyk7XG4gICAgY29uc3Qgbm9PYmplY3QgPSBbJ1tvYmplY3QgTnVtYmVyXScsICdbb2JqZWN0IEZ1bmN0aW9uXScsICdbb2JqZWN0IFJlZ0V4cF0nXTtcbiAgICBjb25zdCBqb2luQXJyYXlzID0gb3B0aW9ucy5qb2luQXJyYXlzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmpvaW5BcnJheXMgOiB0aGlzLm9wdGlvbnMuam9pbkFycmF5cztcbiAgICBjb25zdCBoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCA9ICF0aGlzLmkxOG5Gb3JtYXQgfHwgdGhpcy5pMThuRm9ybWF0LmhhbmRsZUFzT2JqZWN0O1xuICAgIGNvbnN0IGhhbmRsZUFzT2JqZWN0ID0gIWlzU3RyaW5nKHJlcykgJiYgdHlwZW9mIHJlcyAhPT0gJ2Jvb2xlYW4nICYmIHR5cGVvZiByZXMgIT09ICdudW1iZXInO1xuICAgIGlmIChoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCAmJiByZXMgJiYgaGFuZGxlQXNPYmplY3QgJiYgbm9PYmplY3QuaW5kZXhPZihyZXNUeXBlKSA8IDAgJiYgIShpc1N0cmluZyhqb2luQXJyYXlzKSAmJiBBcnJheS5pc0FycmF5KHJlcykpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMucmV0dXJuT2JqZWN0cyAmJiAhdGhpcy5vcHRpb25zLnJldHVybk9iamVjdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmV0dXJuZWRPYmplY3RIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybignYWNjZXNzaW5nIGFuIG9iamVjdCAtIGJ1dCByZXR1cm5PYmplY3RzIG9wdGlvbnMgaXMgbm90IGVuYWJsZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5yZXR1cm5lZE9iamVjdEhhbmRsZXIgPyB0aGlzLm9wdGlvbnMucmV0dXJuZWRPYmplY3RIYW5kbGVyKHJlc1VzZWRLZXksIHJlcywge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgbnM6IG5hbWVzcGFjZXNcbiAgICAgICAgfSkgOiBga2V5ICcke2tleX0gKCR7dGhpcy5sYW5ndWFnZX0pJyByZXR1cm5lZCBhbiBvYmplY3QgaW5zdGVhZCBvZiBzdHJpbmcuYDtcbiAgICAgICAgaWYgKHJldHVybkRldGFpbHMpIHtcbiAgICAgICAgICByZXNvbHZlZC5yZXMgPSByO1xuICAgICAgICAgIHJlc29sdmVkLnVzZWRQYXJhbXMgPSB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgY29uc3QgcmVzVHlwZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHJlcyk7XG4gICAgICAgIGNvbnN0IGNvcHkgPSByZXNUeXBlSXNBcnJheSA/IFtdIDoge307XG4gICAgICAgIGNvbnN0IG5ld0tleVRvVXNlID0gcmVzVHlwZUlzQXJyYXkgPyByZXNFeGFjdFVzZWRLZXkgOiByZXNVc2VkS2V5O1xuICAgICAgICBmb3IgKGNvbnN0IG0gaW4gcmVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXMsIG0pKSB7XG4gICAgICAgICAgICBjb25zdCBkZWVwS2V5ID0gYCR7bmV3S2V5VG9Vc2V9JHtrZXlTZXBhcmF0b3J9JHttfWA7XG4gICAgICAgICAgICBjb3B5W21dID0gdGhpcy50cmFuc2xhdGUoZGVlcEtleSwge1xuICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgam9pbkFycmF5czogZmFsc2UsXG4gICAgICAgICAgICAgICAgbnM6IG5hbWVzcGFjZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY29weVttXSA9PT0gZGVlcEtleSkgY29weVttXSA9IHJlc1ttXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gY29weTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0ICYmIGlzU3RyaW5nKGpvaW5BcnJheXMpICYmIEFycmF5LmlzQXJyYXkocmVzKSkge1xuICAgICAgcmVzID0gcmVzLmpvaW4oam9pbkFycmF5cyk7XG4gICAgICBpZiAocmVzKSByZXMgPSB0aGlzLmV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5cywgb3B0aW9ucywgbGFzdEtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB1c2VkRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgbGV0IHVzZWRLZXkgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG5lZWRzUGx1cmFsSGFuZGxpbmcgPSBvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQgJiYgIWlzU3RyaW5nKG9wdGlvbnMuY291bnQpO1xuICAgICAgY29uc3QgaGFzRGVmYXVsdFZhbHVlID0gVHJhbnNsYXRvci5oYXNEZWZhdWx0VmFsdWUob3B0aW9ucyk7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWVTdWZmaXggPSBuZWVkc1BsdXJhbEhhbmRsaW5nID8gdGhpcy5wbHVyYWxSZXNvbHZlci5nZXRTdWZmaXgobG5nLCBvcHRpb25zLmNvdW50LCBvcHRpb25zKSA6ICcnO1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrID0gb3B0aW9ucy5vcmRpbmFsICYmIG5lZWRzUGx1cmFsSGFuZGxpbmcgPyB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChsbmcsIG9wdGlvbnMuY291bnQsIHtcbiAgICAgICAgb3JkaW5hbDogZmFsc2VcbiAgICAgIH0pIDogJyc7XG4gICAgICBjb25zdCBuZWVkc1plcm9TdWZmaXhMb29rdXAgPSBuZWVkc1BsdXJhbEhhbmRsaW5nICYmICFvcHRpb25zLm9yZGluYWwgJiYgb3B0aW9ucy5jb3VudCA9PT0gMCAmJiB0aGlzLnBsdXJhbFJlc29sdmVyLnNob3VsZFVzZUludGxBcGkoKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG5lZWRzWmVyb1N1ZmZpeExvb2t1cCAmJiBvcHRpb25zW2BkZWZhdWx0VmFsdWUke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2BdIHx8IG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4fWBdIHx8IG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrfWBdIHx8IG9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAocmVzKSAmJiBoYXNEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdXNlZERlZmF1bHQgPSB0cnVlO1xuICAgICAgICByZXMgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZExvb2t1cChyZXMpKSB7XG4gICAgICAgIHVzZWRLZXkgPSB0cnVlO1xuICAgICAgICByZXMgPSBrZXk7XG4gICAgICB9XG4gICAgICBjb25zdCBtaXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXkgPSBvcHRpb25zLm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5O1xuICAgICAgY29uc3QgcmVzRm9yTWlzc2luZyA9IG1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSAmJiB1c2VkS2V5ID8gdW5kZWZpbmVkIDogcmVzO1xuICAgICAgY29uc3QgdXBkYXRlTWlzc2luZyA9IGhhc0RlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUgIT09IHJlcyAmJiB0aGlzLm9wdGlvbnMudXBkYXRlTWlzc2luZztcbiAgICAgIGlmICh1c2VkS2V5IHx8IHVzZWREZWZhdWx0IHx8IHVwZGF0ZU1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKHVwZGF0ZU1pc3NpbmcgPyAndXBkYXRlS2V5JyA6ICdtaXNzaW5nS2V5JywgbG5nLCBuYW1lc3BhY2UsIGtleSwgdXBkYXRlTWlzc2luZyA/IGRlZmF1bHRWYWx1ZSA6IHJlcyk7XG4gICAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgICBjb25zdCBmayA9IHRoaXMucmVzb2x2ZShrZXksIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBrZXlTZXBhcmF0b3I6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGZrICYmIGZrLnJlcykgdGhpcy5sb2dnZXIud2FybignU2VlbXMgdGhlIGxvYWRlZCB0cmFuc2xhdGlvbnMgd2VyZSBpbiBmbGF0IEpTT04gZm9ybWF0IGluc3RlYWQgb2YgbmVzdGVkLiBFaXRoZXIgc2V0IGtleVNlcGFyYXRvcjogZmFsc2Ugb24gaW5pdCBvciBtYWtlIHN1cmUgeW91ciB0cmFuc2xhdGlvbnMgYXJlIHB1Ymxpc2hlZCBpbiBuZXN0ZWQgZm9ybWF0LicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsbmdzID0gW107XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrTG5ncyA9IHRoaXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZywgb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdUbyA9PT0gJ2ZhbGxiYWNrJyAmJiBmYWxsYmFja0xuZ3MgJiYgZmFsbGJhY2tMbmdzWzBdKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWxsYmFja0xuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxuZ3MucHVzaChmYWxsYmFja0xuZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdUbyA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBsbmdzID0gdGhpcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsbmdzLnB1c2gob3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZCA9IChsLCBrLCBzcGVjaWZpY0RlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRGb3JNaXNzaW5nID0gaGFzRGVmYXVsdFZhbHVlICYmIHNwZWNpZmljRGVmYXVsdFZhbHVlICE9PSByZXMgPyBzcGVjaWZpY0RlZmF1bHRWYWx1ZSA6IHJlc0Zvck1pc3Npbmc7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taXNzaW5nS2V5SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1pc3NpbmdLZXlIYW5kbGVyKGwsIG5hbWVzcGFjZSwgaywgZGVmYXVsdEZvck1pc3NpbmcsIHVwZGF0ZU1pc3NpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kQ29ubmVjdG9yICYmIHRoaXMuYmFja2VuZENvbm5lY3Rvci5zYXZlTWlzc2luZykge1xuICAgICAgICAgICAgdGhpcy5iYWNrZW5kQ29ubmVjdG9yLnNhdmVNaXNzaW5nKGwsIG5hbWVzcGFjZSwgaywgZGVmYXVsdEZvck1pc3NpbmcsIHVwZGF0ZU1pc3NpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ21pc3NpbmdLZXknLCBsLCBuYW1lc3BhY2UsIGssIHJlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nUGx1cmFscyAmJiBuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICBsbmdzLmZvckVhY2gobGFuZ3VhZ2UgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzdWZmaXhlcyA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4ZXMobGFuZ3VhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBpZiAobmVlZHNaZXJvU3VmZml4TG9va3VwICYmIG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYF0gJiYgc3VmZml4ZXMuaW5kZXhPZihgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gKSA8IDApIHtcbiAgICAgICAgICAgICAgICBzdWZmaXhlcy5wdXNoKGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN1ZmZpeGVzLmZvckVhY2goc3VmZml4ID0+IHtcbiAgICAgICAgICAgICAgICBzZW5kKFtsYW5ndWFnZV0sIGtleSArIHN1ZmZpeCwgb3B0aW9uc1tgZGVmYXVsdFZhbHVlJHtzdWZmaXh9YF0gfHwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZChsbmdzLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMgPSB0aGlzLmV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5cywgb3B0aW9ucywgcmVzb2x2ZWQsIGxhc3RLZXkpO1xuICAgICAgaWYgKHVzZWRLZXkgJiYgcmVzID09PSBrZXkgJiYgdGhpcy5vcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleSkgcmVzID0gYCR7bmFtZXNwYWNlfToke2tleX1gO1xuICAgICAgaWYgKCh1c2VkS2V5IHx8IHVzZWREZWZhdWx0KSAmJiB0aGlzLm9wdGlvbnMucGFyc2VNaXNzaW5nS2V5SGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgIT09ICd2MScpIHtcbiAgICAgICAgICByZXMgPSB0aGlzLm9wdGlvbnMucGFyc2VNaXNzaW5nS2V5SGFuZGxlcih0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5ID8gYCR7bmFtZXNwYWNlfToke2tleX1gIDoga2V5LCB1c2VkRGVmYXVsdCA/IHJlcyA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5vcHRpb25zLnBhcnNlTWlzc2luZ0tleUhhbmRsZXIocmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmV0dXJuRGV0YWlscykge1xuICAgICAgcmVzb2x2ZWQucmVzID0gcmVzO1xuICAgICAgcmVzb2x2ZWQudXNlZFBhcmFtcyA9IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXksIG9wdGlvbnMsIHJlc29sdmVkLCBsYXN0S2V5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5pMThuRm9ybWF0ICYmIHRoaXMuaTE4bkZvcm1hdC5wYXJzZSkge1xuICAgICAgcmVzID0gdGhpcy5pMThuRm9ybWF0LnBhcnNlKHJlcywge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9LCBvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlIHx8IHJlc29sdmVkLnVzZWRMbmcsIHJlc29sdmVkLnVzZWROUywgcmVzb2x2ZWQudXNlZEtleSwge1xuICAgICAgICByZXNvbHZlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5za2lwSW50ZXJwb2xhdGlvbikge1xuICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikgdGhpcy5pbnRlcnBvbGF0b3IuaW5pdCh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLntcbiAgICAgICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuaW50ZXJwb2xhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBza2lwT25WYXJpYWJsZXMgPSBpc1N0cmluZyhyZXMpICYmIChvcHRpb25zICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbiAmJiBvcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzIDogdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzKTtcbiAgICAgIGxldCBuZXN0QmVmO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYiA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgbmVzdEJlZiA9IG5iICYmIG5iLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxldCBkYXRhID0gb3B0aW9ucy5yZXBsYWNlICYmICFpc1N0cmluZyhvcHRpb25zLnJlcGxhY2UpID8gb3B0aW9ucy5yZXBsYWNlIDogb3B0aW9ucztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzKSBkYXRhID0ge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9O1xuICAgICAgcmVzID0gdGhpcy5pbnRlcnBvbGF0b3IuaW50ZXJwb2xhdGUocmVzLCBkYXRhLCBvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlIHx8IHJlc29sdmVkLnVzZWRMbmcsIG9wdGlvbnMpO1xuICAgICAgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICBjb25zdCBuYSA9IHJlcy5tYXRjaCh0aGlzLmludGVycG9sYXRvci5uZXN0aW5nUmVnZXhwKTtcbiAgICAgICAgY29uc3QgbmVzdEFmdCA9IG5hICYmIG5hLmxlbmd0aDtcbiAgICAgICAgaWYgKG5lc3RCZWYgPCBuZXN0QWZ0KSBvcHRpb25zLm5lc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5sbmcgJiYgdGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgIT09ICd2MScgJiYgcmVzb2x2ZWQgJiYgcmVzb2x2ZWQucmVzKSBvcHRpb25zLmxuZyA9IHRoaXMubGFuZ3VhZ2UgfHwgcmVzb2x2ZWQudXNlZExuZztcbiAgICAgIGlmIChvcHRpb25zLm5lc3QgIT09IGZhbHNlKSByZXMgPSB0aGlzLmludGVycG9sYXRvci5uZXN0KHJlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0S2V5ICYmIGxhc3RLZXlbMF0gPT09IGFyZ3NbMF0gJiYgIW9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKGBJdCBzZWVtcyB5b3UgYXJlIG5lc3RpbmcgcmVjdXJzaXZlbHkga2V5OiAke2FyZ3NbMF19IGluIGtleTogJHtrZXlbMF19YCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zbGF0ZSguLi5hcmdzLCBrZXkpO1xuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5pbnRlcnBvbGF0aW9uKSB0aGlzLmludGVycG9sYXRvci5yZXNldCgpO1xuICAgIH1cbiAgICBjb25zdCBwb3N0UHJvY2VzcyA9IG9wdGlvbnMucG9zdFByb2Nlc3MgfHwgdGhpcy5vcHRpb25zLnBvc3RQcm9jZXNzO1xuICAgIGNvbnN0IHBvc3RQcm9jZXNzb3JOYW1lcyA9IGlzU3RyaW5nKHBvc3RQcm9jZXNzKSA/IFtwb3N0UHJvY2Vzc10gOiBwb3N0UHJvY2VzcztcbiAgICBpZiAocmVzICE9PSB1bmRlZmluZWQgJiYgcmVzICE9PSBudWxsICYmIHBvc3RQcm9jZXNzb3JOYW1lcyAmJiBwb3N0UHJvY2Vzc29yTmFtZXMubGVuZ3RoICYmIG9wdGlvbnMuYXBwbHlQb3N0UHJvY2Vzc29yICE9PSBmYWxzZSkge1xuICAgICAgcmVzID0gcG9zdFByb2Nlc3Nvci5oYW5kbGUocG9zdFByb2Nlc3Nvck5hbWVzLCByZXMsIGtleSwgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5wb3N0UHJvY2Vzc1Bhc3NSZXNvbHZlZCA/IHtcbiAgICAgICAgaTE4blJlc29sdmVkOiB7XG4gICAgICAgICAgLi4ucmVzb2x2ZWQsXG4gICAgICAgICAgdXNlZFBhcmFtczogdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKVxuICAgICAgICB9LFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9IDogb3B0aW9ucywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgcmVzb2x2ZShrZXlzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCBmb3VuZDtcbiAgICBsZXQgdXNlZEtleTtcbiAgICBsZXQgZXhhY3RVc2VkS2V5O1xuICAgIGxldCB1c2VkTG5nO1xuICAgIGxldCB1c2VkTlM7XG4gICAgaWYgKGlzU3RyaW5nKGtleXMpKSBrZXlzID0gW2tleXNdO1xuICAgIGtleXMuZm9yRWFjaChrID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICBjb25zdCBleHRyYWN0ZWQgPSB0aGlzLmV4dHJhY3RGcm9tS2V5KGssIG9wdGlvbnMpO1xuICAgICAgY29uc3Qga2V5ID0gZXh0cmFjdGVkLmtleTtcbiAgICAgIHVzZWRLZXkgPSBrZXk7XG4gICAgICBsZXQgbmFtZXNwYWNlcyA9IGV4dHJhY3RlZC5uYW1lc3BhY2VzO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mYWxsYmFja05TKSBuYW1lc3BhY2VzID0gbmFtZXNwYWNlcy5jb25jYXQodGhpcy5vcHRpb25zLmZhbGxiYWNrTlMpO1xuICAgICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCAmJiAhaXNTdHJpbmcob3B0aW9ucy5jb3VudCk7XG4gICAgICBjb25zdCBuZWVkc1plcm9TdWZmaXhMb29rdXAgPSBuZWVkc1BsdXJhbEhhbmRsaW5nICYmICFvcHRpb25zLm9yZGluYWwgJiYgb3B0aW9ucy5jb3VudCA9PT0gMCAmJiB0aGlzLnBsdXJhbFJlc29sdmVyLnNob3VsZFVzZUludGxBcGkoKTtcbiAgICAgIGNvbnN0IG5lZWRzQ29udGV4dEhhbmRsaW5nID0gb3B0aW9ucy5jb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgKGlzU3RyaW5nKG9wdGlvbnMuY29udGV4dCkgfHwgdHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ251bWJlcicpICYmIG9wdGlvbnMuY29udGV4dCAhPT0gJyc7XG4gICAgICBjb25zdCBjb2RlcyA9IG9wdGlvbnMubG5ncyA/IG9wdGlvbnMubG5ncyA6IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkob3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSwgb3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICBuYW1lc3BhY2VzLmZvckVhY2gobnMgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkTG9va3VwKGZvdW5kKSkgcmV0dXJuO1xuICAgICAgICB1c2VkTlMgPSBucztcbiAgICAgICAgaWYgKCFjaGVja2VkTG9hZGVkRm9yW2Ake2NvZGVzWzBdfS0ke25zfWBdICYmIHRoaXMudXRpbHMgJiYgdGhpcy51dGlscy5oYXNMb2FkZWROYW1lc3BhY2UgJiYgIXRoaXMudXRpbHMuaGFzTG9hZGVkTmFtZXNwYWNlKHVzZWROUykpIHtcbiAgICAgICAgICBjaGVja2VkTG9hZGVkRm9yW2Ake2NvZGVzWzBdfS0ke25zfWBdID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBrZXkgXCIke3VzZWRLZXl9XCIgZm9yIGxhbmd1YWdlcyBcIiR7Y29kZXMuam9pbignLCAnKX1cIiB3b24ndCBnZXQgcmVzb2x2ZWQgYXMgbmFtZXNwYWNlIFwiJHt1c2VkTlN9XCIgd2FzIG5vdCB5ZXQgbG9hZGVkYCwgJ1RoaXMgbWVhbnMgc29tZXRoaW5nIElTIFdST05HIGluIHlvdXIgc2V0dXAuIFlvdSBhY2Nlc3MgdGhlIHQgZnVuY3Rpb24gYmVmb3JlIGkxOG5leHQuaW5pdCAvIGkxOG5leHQubG9hZE5hbWVzcGFjZSAvIGkxOG5leHQuY2hhbmdlTGFuZ3VhZ2Ugd2FzIGRvbmUuIFdhaXQgZm9yIHRoZSBjYWxsYmFjayBvciBQcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGFjY2Vzc2luZyBpdCEhIScpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVzLmZvckVhY2goY29kZSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgICAgICB1c2VkTG5nID0gY29kZTtcbiAgICAgICAgICBjb25zdCBmaW5hbEtleXMgPSBba2V5XTtcbiAgICAgICAgICBpZiAodGhpcy5pMThuRm9ybWF0ICYmIHRoaXMuaTE4bkZvcm1hdC5hZGRMb29rdXBLZXlzKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5Gb3JtYXQuYWRkTG9va3VwS2V5cyhmaW5hbEtleXMsIGtleSwgY29kZSwgbnMsIG9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGx1cmFsU3VmZml4O1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHBsdXJhbFN1ZmZpeCA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4KGNvZGUsIG9wdGlvbnMuY291bnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgemVyb1N1ZmZpeCA9IGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2A7XG4gICAgICAgICAgICBjb25zdCBvcmRpbmFsUHJlZml4ID0gYCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn1vcmRpbmFsJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfWA7XG4gICAgICAgICAgICBpZiAobmVlZHNQbHVyYWxIYW5kbGluZykge1xuICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChrZXkgKyBwbHVyYWxTdWZmaXgpO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vcmRpbmFsICYmIHBsdXJhbFN1ZmZpeC5pbmRleE9mKG9yZGluYWxQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgcGx1cmFsU3VmZml4LnJlcGxhY2Uob3JkaW5hbFByZWZpeCwgdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZWVkc1plcm9TdWZmaXhMb29rdXApIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChrZXkgKyB6ZXJvU3VmZml4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRzQ29udGV4dEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRLZXkgPSBgJHtrZXl9JHt0aGlzLm9wdGlvbnMuY29udGV4dFNlcGFyYXRvcn0ke29wdGlvbnMuY29udGV4dH1gO1xuICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5KTtcbiAgICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5ICsgcGx1cmFsU3VmZml4KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vcmRpbmFsICYmIHBsdXJhbFN1ZmZpeC5pbmRleE9mKG9yZGluYWxQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5ICsgcGx1cmFsU3VmZml4LnJlcGxhY2Uob3JkaW5hbFByZWZpeCwgdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmVlZHNaZXJvU3VmZml4TG9va3VwKSB7XG4gICAgICAgICAgICAgICAgICBmaW5hbEtleXMucHVzaChjb250ZXh0S2V5ICsgemVyb1N1ZmZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBwb3NzaWJsZUtleTtcbiAgICAgICAgICB3aGlsZSAocG9zc2libGVLZXkgPSBmaW5hbEtleXMucG9wKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ZhbGlkTG9va3VwKGZvdW5kKSkge1xuICAgICAgICAgICAgICBleGFjdFVzZWRLZXkgPSBwb3NzaWJsZUtleTtcbiAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLmdldFJlc291cmNlKGNvZGUsIG5zLCBwb3NzaWJsZUtleSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXM6IGZvdW5kLFxuICAgICAgdXNlZEtleSxcbiAgICAgIGV4YWN0VXNlZEtleSxcbiAgICAgIHVzZWRMbmcsXG4gICAgICB1c2VkTlNcbiAgICB9O1xuICB9XG4gIGlzVmFsaWRMb29rdXAocmVzKSB7XG4gICAgcmV0dXJuIHJlcyAhPT0gdW5kZWZpbmVkICYmICEoIXRoaXMub3B0aW9ucy5yZXR1cm5OdWxsICYmIHJlcyA9PT0gbnVsbCkgJiYgISghdGhpcy5vcHRpb25zLnJldHVybkVtcHR5U3RyaW5nICYmIHJlcyA9PT0gJycpO1xuICB9XG4gIGdldFJlc291cmNlKGNvZGUsIG5zLCBrZXkpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgaWYgKHRoaXMuaTE4bkZvcm1hdCAmJiB0aGlzLmkxOG5Gb3JtYXQuZ2V0UmVzb3VyY2UpIHJldHVybiB0aGlzLmkxOG5Gb3JtYXQuZ2V0UmVzb3VyY2UoY29kZSwgbnMsIGtleSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMucmVzb3VyY2VTdG9yZS5nZXRSZXNvdXJjZShjb2RlLCBucywga2V5LCBvcHRpb25zKTtcbiAgfVxuICBnZXRVc2VkUGFyYW1zRGV0YWlscygpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3Qgb3B0aW9uc0tleXMgPSBbJ2RlZmF1bHRWYWx1ZScsICdvcmRpbmFsJywgJ2NvbnRleHQnLCAncmVwbGFjZScsICdsbmcnLCAnbG5ncycsICdmYWxsYmFja0xuZycsICducycsICdrZXlTZXBhcmF0b3InLCAnbnNTZXBhcmF0b3InLCAncmV0dXJuT2JqZWN0cycsICdyZXR1cm5EZXRhaWxzJywgJ2pvaW5BcnJheXMnLCAncG9zdFByb2Nlc3MnLCAnaW50ZXJwb2xhdGlvbiddO1xuICAgIGNvbnN0IHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSA9IG9wdGlvbnMucmVwbGFjZSAmJiAhaXNTdHJpbmcob3B0aW9ucy5yZXBsYWNlKTtcbiAgICBsZXQgZGF0YSA9IHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSA/IG9wdGlvbnMucmVwbGFjZSA6IG9wdGlvbnM7XG4gICAgaWYgKHVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhdGEuY291bnQgPSBvcHRpb25zLmNvdW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcykge1xuICAgICAgZGF0YSA9IHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcyxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCF1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEpIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBvcHRpb25zS2V5cykge1xuICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBzdGF0aWMgaGFzRGVmYXVsdFZhbHVlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmVmaXggPSAnZGVmYXVsdFZhbHVlJztcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG9wdGlvbikgJiYgcHJlZml4ID09PSBvcHRpb24uc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpICYmIHVuZGVmaW5lZCAhPT0gb3B0aW9uc1tvcHRpb25dKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuY29uc3QgY2FwaXRhbGl6ZSA9IHN0cmluZyA9PiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG5jbGFzcyBMYW5ndWFnZVV0aWwge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN1cHBvcnRlZExuZ3MgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncyB8fCBmYWxzZTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdsYW5ndWFnZVV0aWxzJyk7XG4gIH1cbiAgZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpIHtcbiAgICBjb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSk7XG4gICAgaWYgKCFjb2RlIHx8IGNvZGUuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICBpZiAocC5sZW5ndGggPT09IDIpIHJldHVybiBudWxsO1xuICAgIHAucG9wKCk7XG4gICAgaWYgKHBbcC5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpID09PSAneCcpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShwLmpvaW4oJy0nKSk7XG4gIH1cbiAgZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSkge1xuICAgIGNvZGUgPSBnZXRDbGVhbmVkQ29kZShjb2RlKTtcbiAgICBpZiAoIWNvZGUgfHwgY29kZS5pbmRleE9mKCctJykgPCAwKSByZXR1cm4gY29kZTtcbiAgICBjb25zdCBwID0gY29kZS5zcGxpdCgnLScpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShwWzBdKTtcbiAgfVxuICBmb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkge1xuICAgIGlmIChpc1N0cmluZyhjb2RlKSAmJiBjb2RlLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICBpZiAodHlwZW9mIEludGwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBJbnRsLmdldENhbm9uaWNhbExvY2FsZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGZvcm1hdHRlZENvZGUgPSBJbnRsLmdldENhbm9uaWNhbExvY2FsZXMoY29kZSlbMF07XG4gICAgICAgICAgaWYgKGZvcm1hdHRlZENvZGUgJiYgdGhpcy5vcHRpb25zLmxvd2VyQ2FzZUxuZykge1xuICAgICAgICAgICAgZm9ybWF0dGVkQ29kZSA9IGZvcm1hdHRlZENvZGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcm1hdHRlZENvZGUpIHJldHVybiBmb3JtYXR0ZWRDb2RlO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgY29uc3Qgc3BlY2lhbENhc2VzID0gWydoYW5zJywgJ2hhbnQnLCAnbGF0bicsICdjeXJsJywgJ2NhbnMnLCAnbW9uZycsICdhcmFiJ107XG4gICAgICBsZXQgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nKSB7XG4gICAgICAgIHAgPSBwLm1hcChwYXJ0ID0+IHBhcnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHBbMV0gPSBwWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChzcGVjaWFsQ2FzZXMuaW5kZXhPZihwWzFdLnRvTG93ZXJDYXNlKCkpID4gLTEpIHBbMV0gPSBjYXBpdGFsaXplKHBbMV0udG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwWzFdLmxlbmd0aCA9PT0gMikgcFsxXSA9IHBbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHBbMF0gIT09ICdzZ24nICYmIHBbMl0ubGVuZ3RoID09PSAyKSBwWzJdID0gcFsyXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsxXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzFdID0gY2FwaXRhbGl6ZShwWzFdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsyXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzJdID0gY2FwaXRhbGl6ZShwWzJdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHAuam9pbignLScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsZWFuQ29kZSB8fCB0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nID8gY29kZS50b0xvd2VyQ2FzZSgpIDogY29kZTtcbiAgfVxuICBpc1N1cHBvcnRlZENvZGUoY29kZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCA9PT0gJ2xhbmd1YWdlT25seScgfHwgdGhpcy5vcHRpb25zLm5vbkV4cGxpY2l0U3VwcG9ydGVkTG5ncykge1xuICAgICAgY29kZSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5zdXBwb3J0ZWRMbmdzIHx8ICF0aGlzLnN1cHBvcnRlZExuZ3MubGVuZ3RoIHx8IHRoaXMuc3VwcG9ydGVkTG5ncy5pbmRleE9mKGNvZGUpID4gLTE7XG4gIH1cbiAgZ2V0QmVzdE1hdGNoRnJvbUNvZGVzKGNvZGVzKSB7XG4gICAgaWYgKCFjb2RlcykgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZvdW5kO1xuICAgIGNvZGVzLmZvckVhY2goY29kZSA9PiB7XG4gICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICAgIGNvbnN0IGNsZWFuZWRMbmcgPSB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MgfHwgdGhpcy5pc1N1cHBvcnRlZENvZGUoY2xlYW5lZExuZykpIGZvdW5kID0gY2xlYW5lZExuZztcbiAgICB9KTtcbiAgICBpZiAoIWZvdW5kICYmIHRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzKSB7XG4gICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICAgICAgY29uc3QgbG5nT25seSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShsbmdPbmx5KSkgcmV0dXJuIGZvdW5kID0gbG5nT25seTtcbiAgICAgICAgZm91bmQgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncy5maW5kKHN1cHBvcnRlZExuZyA9PiB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZyA9PT0gbG5nT25seSkgcmV0dXJuIHN1cHBvcnRlZExuZztcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkTG5nLmluZGV4T2YoJy0nKSA8IDAgJiYgbG5nT25seS5pbmRleE9mKCctJykgPCAwKSByZXR1cm47XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykgPiAwICYmIGxuZ09ubHkuaW5kZXhPZignLScpIDwgMCAmJiBzdXBwb3J0ZWRMbmcuc3Vic3RyaW5nKDAsIHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykpID09PSBsbmdPbmx5KSByZXR1cm4gc3VwcG9ydGVkTG5nO1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRMbmcuaW5kZXhPZihsbmdPbmx5KSA9PT0gMCAmJiBsbmdPbmx5Lmxlbmd0aCA+IDEpIHJldHVybiBzdXBwb3J0ZWRMbmc7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghZm91bmQpIGZvdW5kID0gdGhpcy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZylbMF07XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG4gIGdldEZhbGxiYWNrQ29kZXMoZmFsbGJhY2tzLCBjb2RlKSB7XG4gICAgaWYgKCFmYWxsYmFja3MpIHJldHVybiBbXTtcbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrcyA9PT0gJ2Z1bmN0aW9uJykgZmFsbGJhY2tzID0gZmFsbGJhY2tzKGNvZGUpO1xuICAgIGlmIChpc1N0cmluZyhmYWxsYmFja3MpKSBmYWxsYmFja3MgPSBbZmFsbGJhY2tzXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmYWxsYmFja3MpKSByZXR1cm4gZmFsbGJhY2tzO1xuICAgIGlmICghY29kZSkgcmV0dXJuIGZhbGxiYWNrcy5kZWZhdWx0IHx8IFtdO1xuICAgIGxldCBmb3VuZCA9IGZhbGxiYWNrc1tjb2RlXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzW3RoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzLmRlZmF1bHQ7XG4gICAgcmV0dXJuIGZvdW5kIHx8IFtdO1xuICB9XG4gIHRvUmVzb2x2ZUhpZXJhcmNoeShjb2RlLCBmYWxsYmFja0NvZGUpIHtcbiAgICBjb25zdCBmYWxsYmFja0NvZGVzID0gdGhpcy5nZXRGYWxsYmFja0NvZGVzKGZhbGxiYWNrQ29kZSB8fCB0aGlzLm9wdGlvbnMuZmFsbGJhY2tMbmcgfHwgW10sIGNvZGUpO1xuICAgIGNvbnN0IGNvZGVzID0gW107XG4gICAgY29uc3QgYWRkQ29kZSA9IGMgPT4ge1xuICAgICAgaWYgKCFjKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5pc1N1cHBvcnRlZENvZGUoYykpIHtcbiAgICAgICAgY29kZXMucHVzaChjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHJlamVjdGluZyBsYW5ndWFnZSBjb2RlIG5vdCBmb3VuZCBpbiBzdXBwb3J0ZWRMbmdzOiAke2N9YCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNTdHJpbmcoY29kZSkgJiYgKGNvZGUuaW5kZXhPZignLScpID4gLTEgfHwgY29kZS5pbmRleE9mKCdfJykgPiAtMSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2xhbmd1YWdlT25seScpIGFkZENvZGUodGhpcy5mb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnbGFuZ3VhZ2VPbmx5JyAmJiB0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2N1cnJlbnRPbmx5JykgYWRkQ29kZSh0aGlzLmdldFNjcmlwdFBhcnRGcm9tQ29kZShjb2RlKSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdjdXJyZW50T25seScpIGFkZENvZGUodGhpcy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhjb2RlKSkge1xuICAgICAgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKSk7XG4gICAgfVxuICAgIGZhbGxiYWNrQ29kZXMuZm9yRWFjaChmYyA9PiB7XG4gICAgICBpZiAoY29kZXMuaW5kZXhPZihmYykgPCAwKSBhZGRDb2RlKHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGZjKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvZGVzO1xuICB9XG59XG5cbmxldCBzZXRzID0gW3tcbiAgbG5nczogWydhY2gnLCAnYWsnLCAnYW0nLCAnYXJuJywgJ2JyJywgJ2ZpbCcsICdndW4nLCAnbG4nLCAnbWZlJywgJ21nJywgJ21pJywgJ29jJywgJ3B0JywgJ3B0LUJSJywgJ3RnJywgJ3RsJywgJ3RpJywgJ3RyJywgJ3V6JywgJ3dhJ10sXG4gIG5yOiBbMSwgMl0sXG4gIGZjOiAxXG59LCB7XG4gIGxuZ3M6IFsnYWYnLCAnYW4nLCAnYXN0JywgJ2F6JywgJ2JnJywgJ2JuJywgJ2NhJywgJ2RhJywgJ2RlJywgJ2RldicsICdlbCcsICdlbicsICdlbycsICdlcycsICdldCcsICdldScsICdmaScsICdmbycsICdmdXInLCAnZnknLCAnZ2wnLCAnZ3UnLCAnaGEnLCAnaGknLCAnaHUnLCAnaHknLCAnaWEnLCAnaXQnLCAna2snLCAna24nLCAna3UnLCAnbGInLCAnbWFpJywgJ21sJywgJ21uJywgJ21yJywgJ25haCcsICduYXAnLCAnbmInLCAnbmUnLCAnbmwnLCAnbm4nLCAnbm8nLCAnbnNvJywgJ3BhJywgJ3BhcCcsICdwbXMnLCAncHMnLCAncHQtUFQnLCAncm0nLCAnc2NvJywgJ3NlJywgJ3NpJywgJ3NvJywgJ3NvbicsICdzcScsICdzdicsICdzdycsICd0YScsICd0ZScsICd0aycsICd1cicsICd5byddLFxuICBucjogWzEsIDJdLFxuICBmYzogMlxufSwge1xuICBsbmdzOiBbJ2F5JywgJ2JvJywgJ2NnZycsICdmYScsICdodCcsICdpZCcsICdqYScsICdqYm8nLCAna2EnLCAna20nLCAna28nLCAna3knLCAnbG8nLCAnbXMnLCAnc2FoJywgJ3N1JywgJ3RoJywgJ3R0JywgJ3VnJywgJ3ZpJywgJ3dvJywgJ3poJ10sXG4gIG5yOiBbMV0sXG4gIGZjOiAzXG59LCB7XG4gIGxuZ3M6IFsnYmUnLCAnYnMnLCAnY25yJywgJ2R6JywgJ2hyJywgJ3J1JywgJ3NyJywgJ3VrJ10sXG4gIG5yOiBbMSwgMiwgNV0sXG4gIGZjOiA0XG59LCB7XG4gIGxuZ3M6IFsnYXInXSxcbiAgbnI6IFswLCAxLCAyLCAzLCAxMSwgMTAwXSxcbiAgZmM6IDVcbn0sIHtcbiAgbG5nczogWydjcycsICdzayddLFxuICBucjogWzEsIDIsIDVdLFxuICBmYzogNlxufSwge1xuICBsbmdzOiBbJ2NzYicsICdwbCddLFxuICBucjogWzEsIDIsIDVdLFxuICBmYzogN1xufSwge1xuICBsbmdzOiBbJ2N5J10sXG4gIG5yOiBbMSwgMiwgMywgOF0sXG4gIGZjOiA4XG59LCB7XG4gIGxuZ3M6IFsnZnInXSxcbiAgbnI6IFsxLCAyXSxcbiAgZmM6IDlcbn0sIHtcbiAgbG5nczogWydnYSddLFxuICBucjogWzEsIDIsIDMsIDcsIDExXSxcbiAgZmM6IDEwXG59LCB7XG4gIGxuZ3M6IFsnZ2QnXSxcbiAgbnI6IFsxLCAyLCAzLCAyMF0sXG4gIGZjOiAxMVxufSwge1xuICBsbmdzOiBbJ2lzJ10sXG4gIG5yOiBbMSwgMl0sXG4gIGZjOiAxMlxufSwge1xuICBsbmdzOiBbJ2p2J10sXG4gIG5yOiBbMCwgMV0sXG4gIGZjOiAxM1xufSwge1xuICBsbmdzOiBbJ2t3J10sXG4gIG5yOiBbMSwgMiwgMywgNF0sXG4gIGZjOiAxNFxufSwge1xuICBsbmdzOiBbJ2x0J10sXG4gIG5yOiBbMSwgMiwgMTBdLFxuICBmYzogMTVcbn0sIHtcbiAgbG5nczogWydsdiddLFxuICBucjogWzEsIDIsIDBdLFxuICBmYzogMTZcbn0sIHtcbiAgbG5nczogWydtayddLFxuICBucjogWzEsIDJdLFxuICBmYzogMTdcbn0sIHtcbiAgbG5nczogWydtbmsnXSxcbiAgbnI6IFswLCAxLCAyXSxcbiAgZmM6IDE4XG59LCB7XG4gIGxuZ3M6IFsnbXQnXSxcbiAgbnI6IFsxLCAyLCAxMSwgMjBdLFxuICBmYzogMTlcbn0sIHtcbiAgbG5nczogWydvciddLFxuICBucjogWzIsIDFdLFxuICBmYzogMlxufSwge1xuICBsbmdzOiBbJ3JvJ10sXG4gIG5yOiBbMSwgMiwgMjBdLFxuICBmYzogMjBcbn0sIHtcbiAgbG5nczogWydzbCddLFxuICBucjogWzUsIDEsIDIsIDNdLFxuICBmYzogMjFcbn0sIHtcbiAgbG5nczogWydoZScsICdpdyddLFxuICBucjogWzEsIDIsIDIwLCAyMV0sXG4gIGZjOiAyMlxufV07XG5sZXQgX3J1bGVzUGx1cmFsc1R5cGVzID0ge1xuICAxOiBuID0+IE51bWJlcihuID4gMSksXG4gIDI6IG4gPT4gTnVtYmVyKG4gIT0gMSksXG4gIDM6IG4gPT4gMCxcbiAgNDogbiA9PiBOdW1iZXIobiAlIDEwID09IDEgJiYgbiAlIDEwMCAhPSAxMSA/IDAgOiBuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gNCAmJiAobiAlIDEwMCA8IDEwIHx8IG4gJSAxMDAgPj0gMjApID8gMSA6IDIpLFxuICA1OiBuID0+IE51bWJlcihuID09IDAgPyAwIDogbiA9PSAxID8gMSA6IG4gPT0gMiA/IDIgOiBuICUgMTAwID49IDMgJiYgbiAlIDEwMCA8PSAxMCA/IDMgOiBuICUgMTAwID49IDExID8gNCA6IDUpLFxuICA2OiBuID0+IE51bWJlcihuID09IDEgPyAwIDogbiA+PSAyICYmIG4gPD0gNCA/IDEgOiAyKSxcbiAgNzogbiA9PiBOdW1iZXIobiA9PSAxID8gMCA6IG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMiksXG4gIDg6IG4gPT4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogbiAhPSA4ICYmIG4gIT0gMTEgPyAyIDogMyksXG4gIDk6IG4gPT4gTnVtYmVyKG4gPj0gMiksXG4gIDEwOiBuID0+IE51bWJlcihuID09IDEgPyAwIDogbiA9PSAyID8gMSA6IG4gPCA3ID8gMiA6IG4gPCAxMSA/IDMgOiA0KSxcbiAgMTE6IG4gPT4gTnVtYmVyKG4gPT0gMSB8fCBuID09IDExID8gMCA6IG4gPT0gMiB8fCBuID09IDEyID8gMSA6IG4gPiAyICYmIG4gPCAyMCA/IDIgOiAzKSxcbiAgMTI6IG4gPT4gTnVtYmVyKG4gJSAxMCAhPSAxIHx8IG4gJSAxMDAgPT0gMTEpLFxuICAxMzogbiA9PiBOdW1iZXIobiAhPT0gMCksXG4gIDE0OiBuID0+IE51bWJlcihuID09IDEgPyAwIDogbiA9PSAyID8gMSA6IG4gPT0gMyA/IDIgOiAzKSxcbiAgMTU6IG4gPT4gTnVtYmVyKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAwIDogbiAlIDEwID49IDIgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyKSxcbiAgMTY6IG4gPT4gTnVtYmVyKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAwIDogbiAhPT0gMCA/IDEgOiAyKSxcbiAgMTc6IG4gPT4gTnVtYmVyKG4gPT0gMSB8fCBuICUgMTAgPT0gMSAmJiBuICUgMTAwICE9IDExID8gMCA6IDEpLFxuICAxODogbiA9PiBOdW1iZXIobiA9PSAwID8gMCA6IG4gPT0gMSA/IDEgOiAyKSxcbiAgMTk6IG4gPT4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDAgfHwgbiAlIDEwMCA+IDEgJiYgbiAlIDEwMCA8IDExID8gMSA6IG4gJSAxMDAgPiAxMCAmJiBuICUgMTAwIDwgMjAgPyAyIDogMyksXG4gIDIwOiBuID0+IE51bWJlcihuID09IDEgPyAwIDogbiA9PSAwIHx8IG4gJSAxMDAgPiAwICYmIG4gJSAxMDAgPCAyMCA/IDEgOiAyKSxcbiAgMjE6IG4gPT4gTnVtYmVyKG4gJSAxMDAgPT0gMSA/IDEgOiBuICUgMTAwID09IDIgPyAyIDogbiAlIDEwMCA9PSAzIHx8IG4gJSAxMDAgPT0gNCA/IDMgOiAwKSxcbiAgMjI6IG4gPT4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogKG4gPCAwIHx8IG4gPiAxMCkgJiYgbiAlIDEwID09IDAgPyAyIDogMylcbn07XG5jb25zdCBub25JbnRsVmVyc2lvbnMgPSBbJ3YxJywgJ3YyJywgJ3YzJ107XG5jb25zdCBpbnRsVmVyc2lvbnMgPSBbJ3Y0J107XG5jb25zdCBzdWZmaXhlc09yZGVyID0ge1xuICB6ZXJvOiAwLFxuICBvbmU6IDEsXG4gIHR3bzogMixcbiAgZmV3OiAzLFxuICBtYW55OiA0LFxuICBvdGhlcjogNVxufTtcbmNvbnN0IGNyZWF0ZVJ1bGVzID0gKCkgPT4ge1xuICBjb25zdCBydWxlcyA9IHt9O1xuICBzZXRzLmZvckVhY2goc2V0ID0+IHtcbiAgICBzZXQubG5ncy5mb3JFYWNoKGwgPT4ge1xuICAgICAgcnVsZXNbbF0gPSB7XG4gICAgICAgIG51bWJlcnM6IHNldC5ucixcbiAgICAgICAgcGx1cmFsczogX3J1bGVzUGx1cmFsc1R5cGVzW3NldC5mY11cbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcnVsZXM7XG59O1xuY2xhc3MgUGx1cmFsUmVzb2x2ZXIge1xuICBjb25zdHJ1Y3RvcihsYW5ndWFnZVV0aWxzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMubGFuZ3VhZ2VVdGlscyA9IGxhbmd1YWdlVXRpbHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdwbHVyYWxSZXNvbHZlcicpO1xuICAgIGlmICgoIXRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTiB8fCBpbnRsVmVyc2lvbnMuaW5jbHVkZXModGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OKSkgJiYgKHR5cGVvZiBJbnRsID09PSAndW5kZWZpbmVkJyB8fCAhSW50bC5QbHVyYWxSdWxlcykpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTiA9ICd2Myc7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignWW91ciBlbnZpcm9ubWVudCBzZWVtcyBub3QgdG8gYmUgSW50bCBBUEkgY29tcGF0aWJsZSwgdXNlIGFuIEludGwuUGx1cmFsUnVsZXMgcG9seWZpbGwuIFdpbGwgZmFsbGJhY2sgdG8gdGhlIGNvbXBhdGliaWxpdHlKU09OIHYzIGZvcm1hdCBoYW5kbGluZy4nKTtcbiAgICB9XG4gICAgdGhpcy5ydWxlcyA9IGNyZWF0ZVJ1bGVzKCk7XG4gICAgdGhpcy5wbHVyYWxSdWxlc0NhY2hlID0ge307XG4gIH1cbiAgYWRkUnVsZShsbmcsIG9iaikge1xuICAgIHRoaXMucnVsZXNbbG5nXSA9IG9iajtcbiAgfVxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMucGx1cmFsUnVsZXNDYWNoZSA9IHt9O1xuICB9XG4gIGdldFJ1bGUoY29kZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBpZiAodGhpcy5zaG91bGRVc2VJbnRsQXBpKCkpIHtcbiAgICAgIGNvbnN0IGNsZWFuZWRDb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSA9PT0gJ2RldicgPyAnZW4nIDogY29kZSk7XG4gICAgICBjb25zdCB0eXBlID0gb3B0aW9ucy5vcmRpbmFsID8gJ29yZGluYWwnIDogJ2NhcmRpbmFsJztcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBjbGVhbmVkQ29kZSxcbiAgICAgICAgdHlwZVxuICAgICAgfSk7XG4gICAgICBpZiAoY2FjaGVLZXkgaW4gdGhpcy5wbHVyYWxSdWxlc0NhY2hlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsdXJhbFJ1bGVzQ2FjaGVbY2FjaGVLZXldO1xuICAgICAgfVxuICAgICAgbGV0IHJ1bGU7XG4gICAgICB0cnkge1xuICAgICAgICBydWxlID0gbmV3IEludGwuUGx1cmFsUnVsZXMoY2xlYW5lZENvZGUsIHtcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghY29kZS5tYXRjaCgvLXxfLykpIHJldHVybjtcbiAgICAgICAgY29uc3QgbG5nUGFydCA9IHRoaXMubGFuZ3VhZ2VVdGlscy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShjb2RlKTtcbiAgICAgICAgcnVsZSA9IHRoaXMuZ2V0UnVsZShsbmdQYXJ0LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGx1cmFsUnVsZXNDYWNoZVtjYWNoZUtleV0gPSBydWxlO1xuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJ1bGVzW2NvZGVdIHx8IHRoaXMucnVsZXNbdGhpcy5sYW5ndWFnZVV0aWxzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpXTtcbiAgfVxuICBuZWVkc1BsdXJhbChjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkVXNlSW50bEFwaSgpKSB7XG4gICAgICByZXR1cm4gcnVsZSAmJiBydWxlLnJlc29sdmVkT3B0aW9ucygpLnBsdXJhbENhdGVnb3JpZXMubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bGUgJiYgcnVsZS5udW1iZXJzLmxlbmd0aCA+IDE7XG4gIH1cbiAgZ2V0UGx1cmFsRm9ybXNPZktleShjb2RlLCBrZXkpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3VmZml4ZXMoY29kZSwgb3B0aW9ucykubWFwKHN1ZmZpeCA9PiBgJHtrZXl9JHtzdWZmaXh9YCk7XG4gIH1cbiAgZ2V0U3VmZml4ZXMoY29kZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBydWxlID0gdGhpcy5nZXRSdWxlKGNvZGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRVc2VJbnRsQXBpKCkpIHtcbiAgICAgIHJldHVybiBydWxlLnJlc29sdmVkT3B0aW9ucygpLnBsdXJhbENhdGVnb3JpZXMuc29ydCgocGx1cmFsQ2F0ZWdvcnkxLCBwbHVyYWxDYXRlZ29yeTIpID0+IHN1ZmZpeGVzT3JkZXJbcGx1cmFsQ2F0ZWdvcnkxXSAtIHN1ZmZpeGVzT3JkZXJbcGx1cmFsQ2F0ZWdvcnkyXSkubWFwKHBsdXJhbENhdGVnb3J5ID0+IGAke3RoaXMub3B0aW9ucy5wcmVwZW5kfSR7b3B0aW9ucy5vcmRpbmFsID8gYG9yZGluYWwke3RoaXMub3B0aW9ucy5wcmVwZW5kfWAgOiAnJ30ke3BsdXJhbENhdGVnb3J5fWApO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZS5udW1iZXJzLm1hcChudW1iZXIgPT4gdGhpcy5nZXRTdWZmaXgoY29kZSwgbnVtYmVyLCBvcHRpb25zKSk7XG4gIH1cbiAgZ2V0U3VmZml4KGNvZGUsIGNvdW50KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFVzZUludGxBcGkoKSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLnByZXBlbmR9JHtvcHRpb25zLm9yZGluYWwgPyBgb3JkaW5hbCR7dGhpcy5vcHRpb25zLnByZXBlbmR9YCA6ICcnfSR7cnVsZS5zZWxlY3QoY291bnQpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdWZmaXhSZXRyb0NvbXBhdGlibGUocnVsZSwgY291bnQpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci53YXJuKGBubyBwbHVyYWwgcnVsZSBmb3VuZCBmb3I6ICR7Y29kZX1gKTtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgZ2V0U3VmZml4UmV0cm9Db21wYXRpYmxlKHJ1bGUsIGNvdW50KSB7XG4gICAgY29uc3QgaWR4ID0gcnVsZS5ub0FicyA/IHJ1bGUucGx1cmFscyhjb3VudCkgOiBydWxlLnBsdXJhbHMoTWF0aC5hYnMoY291bnQpKTtcbiAgICBsZXQgc3VmZml4ID0gcnVsZS5udW1iZXJzW2lkeF07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaW1wbGlmeVBsdXJhbFN1ZmZpeCAmJiBydWxlLm51bWJlcnMubGVuZ3RoID09PSAyICYmIHJ1bGUubnVtYmVyc1swXSA9PT0gMSkge1xuICAgICAgaWYgKHN1ZmZpeCA9PT0gMikge1xuICAgICAgICBzdWZmaXggPSAncGx1cmFsJztcbiAgICAgIH0gZWxzZSBpZiAoc3VmZml4ID09PSAxKSB7XG4gICAgICAgIHN1ZmZpeCA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXR1cm5TdWZmaXggPSAoKSA9PiB0aGlzLm9wdGlvbnMucHJlcGVuZCAmJiBzdWZmaXgudG9TdHJpbmcoKSA/IHRoaXMub3B0aW9ucy5wcmVwZW5kICsgc3VmZml4LnRvU3RyaW5nKCkgOiBzdWZmaXgudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OID09PSAndjEnKSB7XG4gICAgICBpZiAoc3VmZml4ID09PSAxKSByZXR1cm4gJyc7XG4gICAgICBpZiAodHlwZW9mIHN1ZmZpeCA9PT0gJ251bWJlcicpIHJldHVybiBgX3BsdXJhbF8ke3N1ZmZpeC50b1N0cmluZygpfWA7XG4gICAgICByZXR1cm4gcmV0dXJuU3VmZml4KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gPT09ICd2MicpIHtcbiAgICAgIHJldHVybiByZXR1cm5TdWZmaXgoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zaW1wbGlmeVBsdXJhbFN1ZmZpeCAmJiBydWxlLm51bWJlcnMubGVuZ3RoID09PSAyICYmIHJ1bGUubnVtYmVyc1swXSA9PT0gMSkge1xuICAgICAgcmV0dXJuIHJldHVyblN1ZmZpeCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnByZXBlbmQgJiYgaWR4LnRvU3RyaW5nKCkgPyB0aGlzLm9wdGlvbnMucHJlcGVuZCArIGlkeC50b1N0cmluZygpIDogaWR4LnRvU3RyaW5nKCk7XG4gIH1cbiAgc2hvdWxkVXNlSW50bEFwaSgpIHtcbiAgICByZXR1cm4gIW5vbkludGxWZXJzaW9ucy5pbmNsdWRlcyh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04pO1xuICB9XG59XG5cbmNvbnN0IGRlZXBGaW5kV2l0aERlZmF1bHRzID0gZnVuY3Rpb24gKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpIHtcbiAgbGV0IGtleVNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJy4nO1xuICBsZXQgaWdub3JlSlNPTlN0cnVjdHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgbGV0IHBhdGggPSBnZXRQYXRoV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrZXkpO1xuICBpZiAoIXBhdGggJiYgaWdub3JlSlNPTlN0cnVjdHVyZSAmJiBpc1N0cmluZyhrZXkpKSB7XG4gICAgcGF0aCA9IGRlZXBGaW5kKGRhdGEsIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSBwYXRoID0gZGVlcEZpbmQoZGVmYXVsdERhdGEsIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG5jb25zdCByZWdleFNhZmUgPSB2YWwgPT4gdmFsLnJlcGxhY2UoL1xcJC9nLCAnJCQkJCcpO1xuY2xhc3MgSW50ZXJwb2xhdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ2ludGVycG9sYXRvcicpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLmludGVycG9sYXRpb24gJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCB8fCAodmFsdWUgPT4gdmFsdWUpO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBpZiAoIW9wdGlvbnMuaW50ZXJwb2xhdGlvbikgb3B0aW9ucy5pbnRlcnBvbGF0aW9uID0ge1xuICAgICAgZXNjYXBlVmFsdWU6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGVzY2FwZTogZXNjYXBlJDEsXG4gICAgICBlc2NhcGVWYWx1ZSxcbiAgICAgIHVzZVJhd1ZhbHVlVG9Fc2NhcGUsXG4gICAgICBwcmVmaXgsXG4gICAgICBwcmVmaXhFc2NhcGVkLFxuICAgICAgc3VmZml4LFxuICAgICAgc3VmZml4RXNjYXBlZCxcbiAgICAgIGZvcm1hdFNlcGFyYXRvcixcbiAgICAgIHVuZXNjYXBlU3VmZml4LFxuICAgICAgdW5lc2NhcGVQcmVmaXgsXG4gICAgICBuZXN0aW5nUHJlZml4LFxuICAgICAgbmVzdGluZ1ByZWZpeEVzY2FwZWQsXG4gICAgICBuZXN0aW5nU3VmZml4LFxuICAgICAgbmVzdGluZ1N1ZmZpeEVzY2FwZWQsXG4gICAgICBuZXN0aW5nT3B0aW9uc1NlcGFyYXRvcixcbiAgICAgIG1heFJlcGxhY2VzLFxuICAgICAgYWx3YXlzRm9ybWF0XG4gICAgfSA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbjtcbiAgICB0aGlzLmVzY2FwZSA9IGVzY2FwZSQxICE9PSB1bmRlZmluZWQgPyBlc2NhcGUkMSA6IGVzY2FwZTtcbiAgICB0aGlzLmVzY2FwZVZhbHVlID0gZXNjYXBlVmFsdWUgIT09IHVuZGVmaW5lZCA/IGVzY2FwZVZhbHVlIDogdHJ1ZTtcbiAgICB0aGlzLnVzZVJhd1ZhbHVlVG9Fc2NhcGUgPSB1c2VSYXdWYWx1ZVRvRXNjYXBlICE9PSB1bmRlZmluZWQgPyB1c2VSYXdWYWx1ZVRvRXNjYXBlIDogZmFsc2U7XG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXggPyByZWdleEVzY2FwZShwcmVmaXgpIDogcHJlZml4RXNjYXBlZCB8fCAne3snO1xuICAgIHRoaXMuc3VmZml4ID0gc3VmZml4ID8gcmVnZXhFc2NhcGUoc3VmZml4KSA6IHN1ZmZpeEVzY2FwZWQgfHwgJ319JztcbiAgICB0aGlzLmZvcm1hdFNlcGFyYXRvciA9IGZvcm1hdFNlcGFyYXRvciB8fCAnLCc7XG4gICAgdGhpcy51bmVzY2FwZVByZWZpeCA9IHVuZXNjYXBlU3VmZml4ID8gJycgOiB1bmVzY2FwZVByZWZpeCB8fCAnLSc7XG4gICAgdGhpcy51bmVzY2FwZVN1ZmZpeCA9IHRoaXMudW5lc2NhcGVQcmVmaXggPyAnJyA6IHVuZXNjYXBlU3VmZml4IHx8ICcnO1xuICAgIHRoaXMubmVzdGluZ1ByZWZpeCA9IG5lc3RpbmdQcmVmaXggPyByZWdleEVzY2FwZShuZXN0aW5nUHJlZml4KSA6IG5lc3RpbmdQcmVmaXhFc2NhcGVkIHx8IHJlZ2V4RXNjYXBlKCckdCgnKTtcbiAgICB0aGlzLm5lc3RpbmdTdWZmaXggPSBuZXN0aW5nU3VmZml4ID8gcmVnZXhFc2NhcGUobmVzdGluZ1N1ZmZpeCkgOiBuZXN0aW5nU3VmZml4RXNjYXBlZCB8fCByZWdleEVzY2FwZSgnKScpO1xuICAgIHRoaXMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3IgPSBuZXN0aW5nT3B0aW9uc1NlcGFyYXRvciB8fCAnLCc7XG4gICAgdGhpcy5tYXhSZXBsYWNlcyA9IG1heFJlcGxhY2VzIHx8IDEwMDA7XG4gICAgdGhpcy5hbHdheXNGb3JtYXQgPSBhbHdheXNGb3JtYXQgIT09IHVuZGVmaW5lZCA/IGFsd2F5c0Zvcm1hdCA6IGZhbHNlO1xuICAgIHRoaXMucmVzZXRSZWdFeHAoKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zKSB0aGlzLmluaXQodGhpcy5vcHRpb25zKTtcbiAgfVxuICByZXNldFJlZ0V4cCgpIHtcbiAgICBjb25zdCBnZXRPclJlc2V0UmVnRXhwID0gKGV4aXN0aW5nUmVnRXhwLCBwYXR0ZXJuKSA9PiB7XG4gICAgICBpZiAoZXhpc3RpbmdSZWdFeHAgJiYgZXhpc3RpbmdSZWdFeHAuc291cmNlID09PSBwYXR0ZXJuKSB7XG4gICAgICAgIGV4aXN0aW5nUmVnRXhwLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1JlZ0V4cDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sICdnJyk7XG4gICAgfTtcbiAgICB0aGlzLnJlZ2V4cCA9IGdldE9yUmVzZXRSZWdFeHAodGhpcy5yZWdleHAsIGAke3RoaXMucHJlZml4fSguKz8pJHt0aGlzLnN1ZmZpeH1gKTtcbiAgICB0aGlzLnJlZ2V4cFVuZXNjYXBlID0gZ2V0T3JSZXNldFJlZ0V4cCh0aGlzLnJlZ2V4cFVuZXNjYXBlLCBgJHt0aGlzLnByZWZpeH0ke3RoaXMudW5lc2NhcGVQcmVmaXh9KC4rPykke3RoaXMudW5lc2NhcGVTdWZmaXh9JHt0aGlzLnN1ZmZpeH1gKTtcbiAgICB0aGlzLm5lc3RpbmdSZWdleHAgPSBnZXRPclJlc2V0UmVnRXhwKHRoaXMubmVzdGluZ1JlZ2V4cCwgYCR7dGhpcy5uZXN0aW5nUHJlZml4fSguKz8pJHt0aGlzLm5lc3RpbmdTdWZmaXh9YCk7XG4gIH1cbiAgaW50ZXJwb2xhdGUoc3RyLCBkYXRhLCBsbmcsIG9wdGlvbnMpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCByZXBsYWNlcztcbiAgICBjb25zdCBkZWZhdWx0RGF0YSA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbiAmJiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzIHx8IHt9O1xuICAgIGNvbnN0IGhhbmRsZUZvcm1hdCA9IGtleSA9PiB7XG4gICAgICBpZiAoa2V5LmluZGV4T2YodGhpcy5mb3JtYXRTZXBhcmF0b3IpIDwgMCkge1xuICAgICAgICBjb25zdCBwYXRoID0gZGVlcEZpbmRXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGtleSwgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciwgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5hbHdheXNGb3JtYXQgPyB0aGlzLmZvcm1hdChwYXRoLCB1bmRlZmluZWQsIGxuZywge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9ua2V5OiBrZXlcbiAgICAgICAgfSkgOiBwYXRoO1xuICAgICAgfVxuICAgICAgY29uc3QgcCA9IGtleS5zcGxpdCh0aGlzLmZvcm1hdFNlcGFyYXRvcik7XG4gICAgICBjb25zdCBrID0gcC5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIGNvbnN0IGYgPSBwLmpvaW4odGhpcy5mb3JtYXRTZXBhcmF0b3IpLnRyaW0oKTtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdChkZWVwRmluZFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwgaywgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciwgdGhpcy5vcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUpLCBmLCBsbmcsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgaW50ZXJwb2xhdGlvbmtleToga1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0UmVnRXhwKCk7XG4gICAgY29uc3QgbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyO1xuICAgIGNvbnN0IHNraXBPblZhcmlhYmxlcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXMgOiB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5za2lwT25WYXJpYWJsZXM7XG4gICAgY29uc3QgdG9kb3MgPSBbe1xuICAgICAgcmVnZXg6IHRoaXMucmVnZXhwVW5lc2NhcGUsXG4gICAgICBzYWZlVmFsdWU6IHZhbCA9PiByZWdleFNhZmUodmFsKVxuICAgIH0sIHtcbiAgICAgIHJlZ2V4OiB0aGlzLnJlZ2V4cCxcbiAgICAgIHNhZmVWYWx1ZTogdmFsID0+IHRoaXMuZXNjYXBlVmFsdWUgPyByZWdleFNhZmUodGhpcy5lc2NhcGUodmFsKSkgOiByZWdleFNhZmUodmFsKVxuICAgIH1dO1xuICAgIHRvZG9zLmZvckVhY2godG9kbyA9PiB7XG4gICAgICByZXBsYWNlcyA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2ggPSB0b2RvLnJlZ2V4LmV4ZWMoc3RyKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVkVmFyID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgICB2YWx1ZSA9IGhhbmRsZUZvcm1hdChtYXRjaGVkVmFyKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdGVtcCA9IG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcihzdHIsIG1hdGNoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhbHVlID0gaXNTdHJpbmcodGVtcCkgPyB0ZW1wIDogJyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBtYXRjaGVkVmFyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHNraXBPblZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBtaXNzZWQgdG8gcGFzcyBpbiB2YXJpYWJsZSAke21hdGNoZWRWYXJ9IGZvciBpbnRlcnBvbGF0aW5nICR7c3RyfWApO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaW5nKHZhbHVlKSAmJiAhdGhpcy51c2VSYXdWYWx1ZVRvRXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSBtYWtlU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYWZlVmFsdWUgPSB0b2RvLnNhZmVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG1hdGNoWzBdLCBzYWZlVmFsdWUpO1xuICAgICAgICBpZiAoc2tpcE9uVmFyaWFibGVzKSB7XG4gICAgICAgICAgdG9kby5yZWdleC5sYXN0SW5kZXggKz0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHRvZG8ucmVnZXgubGFzdEluZGV4IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2RvLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZXMrKztcbiAgICAgICAgaWYgKHJlcGxhY2VzID49IHRoaXMubWF4UmVwbGFjZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgbmVzdChzdHIsIGZjKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgdmFsdWU7XG4gICAgbGV0IGNsb25lZE9wdGlvbnM7XG4gICAgY29uc3QgaGFuZGxlSGFzT3B0aW9ucyA9IChrZXksIGluaGVyaXRlZE9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHNlcCA9IHRoaXMubmVzdGluZ09wdGlvbnNTZXBhcmF0b3I7XG4gICAgICBpZiAoa2V5LmluZGV4T2Yoc2VwKSA8IDApIHJldHVybiBrZXk7XG4gICAgICBjb25zdCBjID0ga2V5LnNwbGl0KG5ldyBSZWdFeHAoYCR7c2VwfVsgXSp7YCkpO1xuICAgICAgbGV0IG9wdGlvbnNTdHJpbmcgPSBgeyR7Y1sxXX1gO1xuICAgICAga2V5ID0gY1swXTtcbiAgICAgIG9wdGlvbnNTdHJpbmcgPSB0aGlzLmludGVycG9sYXRlKG9wdGlvbnNTdHJpbmcsIGNsb25lZE9wdGlvbnMpO1xuICAgICAgY29uc3QgbWF0Y2hlZFNpbmdsZVF1b3RlcyA9IG9wdGlvbnNTdHJpbmcubWF0Y2goLycvZyk7XG4gICAgICBjb25zdCBtYXRjaGVkRG91YmxlUXVvdGVzID0gb3B0aW9uc1N0cmluZy5tYXRjaCgvXCIvZyk7XG4gICAgICBpZiAobWF0Y2hlZFNpbmdsZVF1b3RlcyAmJiBtYXRjaGVkU2luZ2xlUXVvdGVzLmxlbmd0aCAlIDIgPT09IDAgJiYgIW1hdGNoZWREb3VibGVRdW90ZXMgfHwgbWF0Y2hlZERvdWJsZVF1b3Rlcy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIG9wdGlvbnNTdHJpbmcgPSBvcHRpb25zU3RyaW5nLnJlcGxhY2UoLycvZywgJ1wiJyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjbG9uZWRPcHRpb25zID0gSlNPTi5wYXJzZShvcHRpb25zU3RyaW5nKTtcbiAgICAgICAgaWYgKGluaGVyaXRlZE9wdGlvbnMpIGNsb25lZE9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4uaW5oZXJpdGVkT3B0aW9ucyxcbiAgICAgICAgICAuLi5jbG9uZWRPcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYGZhaWxlZCBwYXJzaW5nIG9wdGlvbnMgc3RyaW5nIGluIG5lc3RpbmcgZm9yIGtleSAke2tleX1gLCBlKTtcbiAgICAgICAgcmV0dXJuIGAke2tleX0ke3NlcH0ke29wdGlvbnNTdHJpbmd9YDtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9uZWRPcHRpb25zLmRlZmF1bHRWYWx1ZSAmJiBjbG9uZWRPcHRpb25zLmRlZmF1bHRWYWx1ZS5pbmRleE9mKHRoaXMucHJlZml4KSA+IC0xKSBkZWxldGUgY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWU7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gICAgd2hpbGUgKG1hdGNoID0gdGhpcy5uZXN0aW5nUmVnZXhwLmV4ZWMoc3RyKSkge1xuICAgICAgbGV0IGZvcm1hdHRlcnMgPSBbXTtcbiAgICAgIGNsb25lZE9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjbG9uZWRPcHRpb25zID0gY2xvbmVkT3B0aW9ucy5yZXBsYWNlICYmICFpc1N0cmluZyhjbG9uZWRPcHRpb25zLnJlcGxhY2UpID8gY2xvbmVkT3B0aW9ucy5yZXBsYWNlIDogY2xvbmVkT3B0aW9ucztcbiAgICAgIGNsb25lZE9wdGlvbnMuYXBwbHlQb3N0UHJvY2Vzc29yID0gZmFsc2U7XG4gICAgICBkZWxldGUgY2xvbmVkT3B0aW9ucy5kZWZhdWx0VmFsdWU7XG4gICAgICBsZXQgZG9SZWR1Y2UgPSBmYWxzZTtcbiAgICAgIGlmIChtYXRjaFswXS5pbmRleE9mKHRoaXMuZm9ybWF0U2VwYXJhdG9yKSAhPT0gLTEgJiYgIS97Lip9Ly50ZXN0KG1hdGNoWzFdKSkge1xuICAgICAgICBjb25zdCByID0gbWF0Y2hbMV0uc3BsaXQodGhpcy5mb3JtYXRTZXBhcmF0b3IpLm1hcChlbGVtID0+IGVsZW0udHJpbSgpKTtcbiAgICAgICAgbWF0Y2hbMV0gPSByLnNoaWZ0KCk7XG4gICAgICAgIGZvcm1hdHRlcnMgPSByO1xuICAgICAgICBkb1JlZHVjZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGZjKGhhbmRsZUhhc09wdGlvbnMuY2FsbCh0aGlzLCBtYXRjaFsxXS50cmltKCksIGNsb25lZE9wdGlvbnMpLCBjbG9uZWRPcHRpb25zKTtcbiAgICAgIGlmICh2YWx1ZSAmJiBtYXRjaFswXSA9PT0gc3RyICYmICFpc1N0cmluZyh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgIGlmICghaXNTdHJpbmcodmFsdWUpKSB2YWx1ZSA9IG1ha2VTdHJpbmcodmFsdWUpO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBtaXNzZWQgdG8gcmVzb2x2ZSAke21hdGNoWzFdfSBmb3IgbmVzdGluZyAke3N0cn1gKTtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChkb1JlZHVjZSkge1xuICAgICAgICB2YWx1ZSA9IGZvcm1hdHRlcnMucmVkdWNlKCh2LCBmKSA9PiB0aGlzLmZvcm1hdCh2LCBmLCBvcHRpb25zLmxuZywge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgaW50ZXJwb2xhdGlvbmtleTogbWF0Y2hbMV0udHJpbSgpXG4gICAgICAgIH0pLCB2YWx1ZS50cmltKCkpO1xuICAgICAgfVxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UobWF0Y2hbMF0sIHZhbHVlKTtcbiAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuY29uc3QgcGFyc2VGb3JtYXRTdHIgPSBmb3JtYXRTdHIgPT4ge1xuICBsZXQgZm9ybWF0TmFtZSA9IGZvcm1hdFN0ci50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgY29uc3QgZm9ybWF0T3B0aW9ucyA9IHt9O1xuICBpZiAoZm9ybWF0U3RyLmluZGV4T2YoJygnKSA+IC0xKSB7XG4gICAgY29uc3QgcCA9IGZvcm1hdFN0ci5zcGxpdCgnKCcpO1xuICAgIGZvcm1hdE5hbWUgPSBwWzBdLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIGNvbnN0IG9wdFN0ciA9IHBbMV0uc3Vic3RyaW5nKDAsIHBbMV0ubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGZvcm1hdE5hbWUgPT09ICdjdXJyZW5jeScgJiYgb3B0U3RyLmluZGV4T2YoJzonKSA8IDApIHtcbiAgICAgIGlmICghZm9ybWF0T3B0aW9ucy5jdXJyZW5jeSkgZm9ybWF0T3B0aW9ucy5jdXJyZW5jeSA9IG9wdFN0ci50cmltKCk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXROYW1lID09PSAncmVsYXRpdmV0aW1lJyAmJiBvcHRTdHIuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgaWYgKCFmb3JtYXRPcHRpb25zLnJhbmdlKSBmb3JtYXRPcHRpb25zLnJhbmdlID0gb3B0U3RyLnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3B0cyA9IG9wdFN0ci5zcGxpdCgnOycpO1xuICAgICAgb3B0cy5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IG9wdC5zcGxpdCgnOicpO1xuICAgICAgICAgIGNvbnN0IHZhbCA9IHJlc3Quam9pbignOicpLnRyaW0oKS5yZXBsYWNlKC9eJyt8JyskL2csICcnKTtcbiAgICAgICAgICBjb25zdCB0cmltbWVkS2V5ID0ga2V5LnRyaW0oKTtcbiAgICAgICAgICBpZiAoIWZvcm1hdE9wdGlvbnNbdHJpbW1lZEtleV0pIGZvcm1hdE9wdGlvbnNbdHJpbW1lZEtleV0gPSB2YWw7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gJ2ZhbHNlJykgZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSA9IGZhbHNlO1xuICAgICAgICAgIGlmICh2YWwgPT09ICd0cnVlJykgZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSA9IHRydWU7XG4gICAgICAgICAgaWYgKCFpc05hTih2YWwpKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGZvcm1hdE5hbWUsXG4gICAgZm9ybWF0T3B0aW9uc1xuICB9O1xufTtcbmNvbnN0IGNyZWF0ZUNhY2hlZEZvcm1hdHRlciA9IGZuID0+IHtcbiAgY29uc3QgY2FjaGUgPSB7fTtcbiAgcmV0dXJuICh2YWwsIGxuZywgb3B0aW9ucykgPT4ge1xuICAgIGxldCBvcHRGb3JDYWNoZSA9IG9wdGlvbnM7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9ua2V5ICYmIG9wdGlvbnMuZm9ybWF0UGFyYW1zICYmIG9wdGlvbnMuZm9ybWF0UGFyYW1zW29wdGlvbnMuaW50ZXJwb2xhdGlvbmtleV0gJiYgb3B0aW9uc1tvcHRpb25zLmludGVycG9sYXRpb25rZXldKSB7XG4gICAgICBvcHRGb3JDYWNoZSA9IHtcbiAgICAgICAgLi4ub3B0Rm9yQ2FjaGUsXG4gICAgICAgIFtvcHRpb25zLmludGVycG9sYXRpb25rZXldOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGxuZyArIEpTT04uc3RyaW5naWZ5KG9wdEZvckNhY2hlKTtcbiAgICBsZXQgZm9ybWF0dGVyID0gY2FjaGVba2V5XTtcbiAgICBpZiAoIWZvcm1hdHRlcikge1xuICAgICAgZm9ybWF0dGVyID0gZm4oZ2V0Q2xlYW5lZENvZGUobG5nKSwgb3B0aW9ucyk7XG4gICAgICBjYWNoZVtrZXldID0gZm9ybWF0dGVyO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0dGVyKHZhbCk7XG4gIH07XG59O1xuY2xhc3MgRm9ybWF0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlci5jcmVhdGUoJ2Zvcm1hdHRlcicpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5mb3JtYXRzID0ge1xuICAgICAgbnVtYmVyOiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICBjdXJyZW5jeTogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0LFxuICAgICAgICAgIHN0eWxlOiAnY3VycmVuY3knXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsKTtcbiAgICAgIH0pLFxuICAgICAgZGF0ZXRpbWU6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG5nLCB7XG4gICAgICAgICAgLi4ub3B0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsID0+IGZvcm1hdHRlci5mb3JtYXQodmFsKTtcbiAgICAgIH0pLFxuICAgICAgcmVsYXRpdmV0aW1lOiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwsIG9wdC5yYW5nZSB8fCAnZGF5Jyk7XG4gICAgICB9KSxcbiAgICAgIGxpc3Q6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuTGlzdEZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSlcbiAgICB9O1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KHNlcnZpY2VzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIGludGVycG9sYXRpb246IHt9XG4gICAgfTtcbiAgICB0aGlzLmZvcm1hdFNlcGFyYXRvciA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXRTZXBhcmF0b3IgfHwgJywnO1xuICB9XG4gIGFkZChuYW1lLCBmYykge1xuICAgIHRoaXMuZm9ybWF0c1tuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXSA9IGZjO1xuICB9XG4gIGFkZENhY2hlZChuYW1lLCBmYykge1xuICAgIHRoaXMuZm9ybWF0c1tuYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpXSA9IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcihmYyk7XG4gIH1cbiAgZm9ybWF0KHZhbHVlLCBmb3JtYXQsIGxuZykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBjb25zdCBmb3JtYXRzID0gZm9ybWF0LnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKTtcbiAgICBpZiAoZm9ybWF0cy5sZW5ndGggPiAxICYmIGZvcm1hdHNbMF0uaW5kZXhPZignKCcpID4gMSAmJiBmb3JtYXRzWzBdLmluZGV4T2YoJyknKSA8IDAgJiYgZm9ybWF0cy5maW5kKGYgPT4gZi5pbmRleE9mKCcpJykgPiAtMSkpIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGZvcm1hdHMuZmluZEluZGV4KGYgPT4gZi5pbmRleE9mKCcpJykgPiAtMSk7XG4gICAgICBmb3JtYXRzWzBdID0gW2Zvcm1hdHNbMF0sIC4uLmZvcm1hdHMuc3BsaWNlKDEsIGxhc3RJbmRleCldLmpvaW4odGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRzLnJlZHVjZSgobWVtLCBmKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvcm1hdE5hbWUsXG4gICAgICAgIGZvcm1hdE9wdGlvbnNcbiAgICAgIH0gPSBwYXJzZUZvcm1hdFN0cihmKTtcbiAgICAgIGlmICh0aGlzLmZvcm1hdHNbZm9ybWF0TmFtZV0pIHtcbiAgICAgICAgbGV0IGZvcm1hdHRlZCA9IG1lbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB2YWxPcHRpb25zID0gb3B0aW9ucyAmJiBvcHRpb25zLmZvcm1hdFBhcmFtcyAmJiBvcHRpb25zLmZvcm1hdFBhcmFtc1tvcHRpb25zLmludGVycG9sYXRpb25rZXldIHx8IHt9O1xuICAgICAgICAgIGNvbnN0IGwgPSB2YWxPcHRpb25zLmxvY2FsZSB8fCB2YWxPcHRpb25zLmxuZyB8fCBvcHRpb25zLmxvY2FsZSB8fCBvcHRpb25zLmxuZyB8fCBsbmc7XG4gICAgICAgICAgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXRzW2Zvcm1hdE5hbWVdKG1lbSwgbCwge1xuICAgICAgICAgICAgLi4uZm9ybWF0T3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi52YWxPcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYHRoZXJlIHdhcyBubyBmb3JtYXQgZnVuY3Rpb24gZm9yICR7Zm9ybWF0TmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW07XG4gICAgfSwgdmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuY29uc3QgcmVtb3ZlUGVuZGluZyA9IChxLCBuYW1lKSA9PiB7XG4gIGlmIChxLnBlbmRpbmdbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgIGRlbGV0ZSBxLnBlbmRpbmdbbmFtZV07XG4gICAgcS5wZW5kaW5nQ291bnQtLTtcbiAgfVxufTtcbmNsYXNzIENvbm5lY3RvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGJhY2tlbmQsIHN0b3JlLCBzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMuc2VydmljZXMgPSBzZXJ2aWNlcztcbiAgICB0aGlzLmxhbmd1YWdlVXRpbHMgPSBzZXJ2aWNlcy5sYW5ndWFnZVV0aWxzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnYmFja2VuZENvbm5lY3RvcicpO1xuICAgIHRoaXMud2FpdGluZ1JlYWRzID0gW107XG4gICAgdGhpcy5tYXhQYXJhbGxlbFJlYWRzID0gb3B0aW9ucy5tYXhQYXJhbGxlbFJlYWRzIHx8IDEwO1xuICAgIHRoaXMucmVhZGluZ0NhbGxzID0gMDtcbiAgICB0aGlzLm1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPj0gMCA/IG9wdGlvbnMubWF4UmV0cmllcyA6IDU7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBvcHRpb25zLnJldHJ5VGltZW91dCA+PSAxID8gb3B0aW9ucy5yZXRyeVRpbWVvdXQgOiAzNTA7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICBpZiAodGhpcy5iYWNrZW5kICYmIHRoaXMuYmFja2VuZC5pbml0KSB7XG4gICAgICB0aGlzLmJhY2tlbmQuaW5pdChzZXJ2aWNlcywgb3B0aW9ucy5iYWNrZW5kLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcXVldWVMb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0b0xvYWQgPSB7fTtcbiAgICBjb25zdCBwZW5kaW5nID0ge307XG4gICAgY29uc3QgdG9Mb2FkTGFuZ3VhZ2VzID0ge307XG4gICAgY29uc3QgdG9Mb2FkTmFtZXNwYWNlcyA9IHt9O1xuICAgIGxhbmd1YWdlcy5mb3JFYWNoKGxuZyA9PiB7XG4gICAgICBsZXQgaGFzQWxsTmFtZXNwYWNlcyA9IHRydWU7XG4gICAgICBuYW1lc3BhY2VzLmZvckVhY2gobnMgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gYCR7bG5nfXwke25zfWA7XG4gICAgICAgIGlmICghb3B0aW9ucy5yZWxvYWQgJiYgdGhpcy5zdG9yZS5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVbbmFtZV0gPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGVbbmFtZV0gPCAwKSA7IGVsc2UgaWYgKHRoaXMuc3RhdGVbbmFtZV0gPT09IDEpIHtcbiAgICAgICAgICBpZiAocGVuZGluZ1tuYW1lXSA9PT0gdW5kZWZpbmVkKSBwZW5kaW5nW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlW25hbWVdID0gMTtcbiAgICAgICAgICBoYXNBbGxOYW1lc3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHBlbmRpbmdbbmFtZV0gPT09IHVuZGVmaW5lZCkgcGVuZGluZ1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgaWYgKHRvTG9hZFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB0b0xvYWRbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGlmICh0b0xvYWROYW1lc3BhY2VzW25zXSA9PT0gdW5kZWZpbmVkKSB0b0xvYWROYW1lc3BhY2VzW25zXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFoYXNBbGxOYW1lc3BhY2VzKSB0b0xvYWRMYW5ndWFnZXNbbG5nXSA9IHRydWU7XG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRvTG9hZCkubGVuZ3RoIHx8IE9iamVjdC5rZXlzKHBlbmRpbmcpLmxlbmd0aCkge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHtcbiAgICAgICAgcGVuZGluZyxcbiAgICAgICAgcGVuZGluZ0NvdW50OiBPYmplY3Qua2V5cyhwZW5kaW5nKS5sZW5ndGgsXG4gICAgICAgIGxvYWRlZDoge30sXG4gICAgICAgIGVycm9yczogW10sXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvTG9hZDogT2JqZWN0LmtleXModG9Mb2FkKSxcbiAgICAgIHBlbmRpbmc6IE9iamVjdC5rZXlzKHBlbmRpbmcpLFxuICAgICAgdG9Mb2FkTGFuZ3VhZ2VzOiBPYmplY3Qua2V5cyh0b0xvYWRMYW5ndWFnZXMpLFxuICAgICAgdG9Mb2FkTmFtZXNwYWNlczogT2JqZWN0LmtleXModG9Mb2FkTmFtZXNwYWNlcylcbiAgICB9O1xuICB9XG4gIGxvYWRlZChuYW1lLCBlcnIsIGRhdGEpIHtcbiAgICBjb25zdCBzID0gbmFtZS5zcGxpdCgnfCcpO1xuICAgIGNvbnN0IGxuZyA9IHNbMF07XG4gICAgY29uc3QgbnMgPSBzWzFdO1xuICAgIGlmIChlcnIpIHRoaXMuZW1pdCgnZmFpbGVkTG9hZGluZycsIGxuZywgbnMsIGVycik7XG4gICAgaWYgKCFlcnIgJiYgZGF0YSkge1xuICAgICAgdGhpcy5zdG9yZS5hZGRSZXNvdXJjZUJ1bmRsZShsbmcsIG5zLCBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICBza2lwQ29weTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVbbmFtZV0gPSBlcnIgPyAtMSA6IDI7XG4gICAgaWYgKGVyciAmJiBkYXRhKSB0aGlzLnN0YXRlW25hbWVdID0gMDtcbiAgICBjb25zdCBsb2FkZWQgPSB7fTtcbiAgICB0aGlzLnF1ZXVlLmZvckVhY2gocSA9PiB7XG4gICAgICBwdXNoUGF0aChxLmxvYWRlZCwgW2xuZ10sIG5zKTtcbiAgICAgIHJlbW92ZVBlbmRpbmcocSwgbmFtZSk7XG4gICAgICBpZiAoZXJyKSBxLmVycm9ycy5wdXNoKGVycik7XG4gICAgICBpZiAocS5wZW5kaW5nQ291bnQgPT09IDAgJiYgIXEuZG9uZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhxLmxvYWRlZCkuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICBpZiAoIWxvYWRlZFtsXSkgbG9hZGVkW2xdID0ge307XG4gICAgICAgICAgY29uc3QgbG9hZGVkS2V5cyA9IHEubG9hZGVkW2xdO1xuICAgICAgICAgIGlmIChsb2FkZWRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9hZGVkS2V5cy5mb3JFYWNoKG4gPT4ge1xuICAgICAgICAgICAgICBpZiAobG9hZGVkW2xdW25dID09PSB1bmRlZmluZWQpIGxvYWRlZFtsXVtuXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBxLmRvbmUgPSB0cnVlO1xuICAgICAgICBpZiAocS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgcS5jYWxsYmFjayhxLmVycm9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcS5jYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCdsb2FkZWQnLCBsb2FkZWQpO1xuICAgIHRoaXMucXVldWUgPSB0aGlzLnF1ZXVlLmZpbHRlcihxID0+ICFxLmRvbmUpO1xuICB9XG4gIHJlYWQobG5nLCBucywgZmNOYW1lKSB7XG4gICAgbGV0IHRyaWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgIGxldCB3YWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0aGlzLnJldHJ5VGltZW91dDtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIWxuZy5sZW5ndGgpIHJldHVybiBjYWxsYmFjayhudWxsLCB7fSk7XG4gICAgaWYgKHRoaXMucmVhZGluZ0NhbGxzID49IHRoaXMubWF4UGFyYWxsZWxSZWFkcykge1xuICAgICAgdGhpcy53YWl0aW5nUmVhZHMucHVzaCh7XG4gICAgICAgIGxuZyxcbiAgICAgICAgbnMsXG4gICAgICAgIGZjTmFtZSxcbiAgICAgICAgdHJpZWQsXG4gICAgICAgIHdhaXQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWFkaW5nQ2FsbHMrKztcbiAgICBjb25zdCByZXNvbHZlciA9IChlcnIsIGRhdGEpID0+IHtcbiAgICAgIHRoaXMucmVhZGluZ0NhbGxzLS07XG4gICAgICBpZiAodGhpcy53YWl0aW5nUmVhZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy53YWl0aW5nUmVhZHMuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5yZWFkKG5leHQubG5nLCBuZXh0Lm5zLCBuZXh0LmZjTmFtZSwgbmV4dC50cmllZCwgbmV4dC53YWl0LCBuZXh0LmNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgJiYgZGF0YSAmJiB0cmllZCA8IHRoaXMubWF4UmV0cmllcykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlYWQuY2FsbCh0aGlzLCBsbmcsIG5zLCBmY05hbWUsIHRyaWVkICsgMSwgd2FpdCAqIDIsIGNhbGxiYWNrKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7XG4gICAgfTtcbiAgICBjb25zdCBmYyA9IHRoaXMuYmFja2VuZFtmY05hbWVdLmJpbmQodGhpcy5iYWNrZW5kKTtcbiAgICBpZiAoZmMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByID0gZmMobG5nLCBucyk7XG4gICAgICAgIGlmIChyICYmIHR5cGVvZiByLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByLnRoZW4oZGF0YSA9PiByZXNvbHZlcihudWxsLCBkYXRhKSkuY2F0Y2gocmVzb2x2ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmVyKG51bGwsIHIpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzb2x2ZXIoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGZjKGxuZywgbnMsIHJlc29sdmVyKTtcbiAgfVxuICBwcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCF0aGlzLmJhY2tlbmQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ05vIGJhY2tlbmQgd2FzIGFkZGVkIHZpYSBpMThuZXh0LnVzZS4gV2lsbCBub3QgbG9hZCByZXNvdXJjZXMuJyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGxhbmd1YWdlcykpIGxhbmd1YWdlcyA9IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobGFuZ3VhZ2VzKTtcbiAgICBpZiAoaXNTdHJpbmcobmFtZXNwYWNlcykpIG5hbWVzcGFjZXMgPSBbbmFtZXNwYWNlc107XG4gICAgY29uc3QgdG9Mb2FkID0gdGhpcy5xdWV1ZUxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgaWYgKCF0b0xvYWQudG9Mb2FkLmxlbmd0aCkge1xuICAgICAgaWYgKCF0b0xvYWQucGVuZGluZy5sZW5ndGgpIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9Mb2FkLnRvTG9hZC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgdGhpcy5sb2FkT25lKG5hbWUpO1xuICAgIH0pO1xuICB9XG4gIGxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBjYWxsYmFjaykge1xuICAgIHRoaXMucHJlcGFyZUxvYWRpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCB7fSwgY2FsbGJhY2spO1xuICB9XG4gIHJlbG9hZChsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wcmVwYXJlTG9hZGluZyhsYW5ndWFnZXMsIG5hbWVzcGFjZXMsIHtcbiAgICAgIHJlbG9hZDogdHJ1ZVxuICAgIH0sIGNhbGxiYWNrKTtcbiAgfVxuICBsb2FkT25lKG5hbWUpIHtcbiAgICBsZXQgcHJlZml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcbiAgICBjb25zdCBzID0gbmFtZS5zcGxpdCgnfCcpO1xuICAgIGNvbnN0IGxuZyA9IHNbMF07XG4gICAgY29uc3QgbnMgPSBzWzFdO1xuICAgIHRoaXMucmVhZChsbmcsIG5zLCAncmVhZCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyKSB0aGlzLmxvZ2dlci53YXJuKGAke3ByZWZpeH1sb2FkaW5nIG5hbWVzcGFjZSAke25zfSBmb3IgbGFuZ3VhZ2UgJHtsbmd9IGZhaWxlZGAsIGVycik7XG4gICAgICBpZiAoIWVyciAmJiBkYXRhKSB0aGlzLmxvZ2dlci5sb2coYCR7cHJlZml4fWxvYWRlZCBuYW1lc3BhY2UgJHtuc30gZm9yIGxhbmd1YWdlICR7bG5nfWAsIGRhdGEpO1xuICAgICAgdGhpcy5sb2FkZWQobmFtZSwgZXJyLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuICBzYXZlTWlzc2luZyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlLCBpc1VwZGF0ZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICBsZXQgY2xiID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiAoKSA9PiB7fTtcbiAgICBpZiAodGhpcy5zZXJ2aWNlcy51dGlscyAmJiB0aGlzLnNlcnZpY2VzLnV0aWxzLmhhc0xvYWRlZE5hbWVzcGFjZSAmJiAhdGhpcy5zZXJ2aWNlcy51dGlscy5oYXNMb2FkZWROYW1lc3BhY2UobmFtZXNwYWNlKSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgZGlkIG5vdCBzYXZlIGtleSBcIiR7a2V5fVwiIGFzIHRoZSBuYW1lc3BhY2UgXCIke25hbWVzcGFjZX1cIiB3YXMgbm90IHlldCBsb2FkZWRgLCAnVGhpcyBtZWFucyBzb21ldGhpbmcgSVMgV1JPTkcgaW4geW91ciBzZXR1cC4gWW91IGFjY2VzcyB0aGUgdCBmdW5jdGlvbiBiZWZvcmUgaTE4bmV4dC5pbml0IC8gaTE4bmV4dC5sb2FkTmFtZXNwYWNlIC8gaTE4bmV4dC5jaGFuZ2VMYW5ndWFnZSB3YXMgZG9uZS4gV2FpdCBmb3IgdGhlIGNhbGxiYWNrIG9yIFByb21pc2UgdG8gcmVzb2x2ZSBiZWZvcmUgYWNjZXNzaW5nIGl0ISEhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09IG51bGwgfHwga2V5ID09PSAnJykgcmV0dXJuO1xuICAgIGlmICh0aGlzLmJhY2tlbmQgJiYgdGhpcy5iYWNrZW5kLmNyZWF0ZSkge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgaXNVcGRhdGVcbiAgICAgIH07XG4gICAgICBjb25zdCBmYyA9IHRoaXMuYmFja2VuZC5jcmVhdGUuYmluZCh0aGlzLmJhY2tlbmQpO1xuICAgICAgaWYgKGZjLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgcjtcbiAgICAgICAgICBpZiAoZmMubGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICByID0gZmMobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSwgb3B0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHIgPSBmYyhsYW5ndWFnZXMsIG5hbWVzcGFjZSwga2V5LCBmYWxsYmFja1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHIgJiYgdHlwZW9mIHIudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgci50aGVuKGRhdGEgPT4gY2xiKG51bGwsIGRhdGEpKS5jYXRjaChjbGIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGIobnVsbCwgcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjbGIoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmMobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSwgY2xiLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsYW5ndWFnZXMgfHwgIWxhbmd1YWdlc1swXSkgcmV0dXJuO1xuICAgIHRoaXMuc3RvcmUuYWRkUmVzb3VyY2UobGFuZ3VhZ2VzWzBdLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSk7XG4gIH1cbn1cblxuY29uc3QgZ2V0ID0gKCkgPT4gKHtcbiAgZGVidWc6IGZhbHNlLFxuICBpbml0SW1tZWRpYXRlOiB0cnVlLFxuICBuczogWyd0cmFuc2xhdGlvbiddLFxuICBkZWZhdWx0TlM6IFsndHJhbnNsYXRpb24nXSxcbiAgZmFsbGJhY2tMbmc6IFsnZGV2J10sXG4gIGZhbGxiYWNrTlM6IGZhbHNlLFxuICBzdXBwb3J0ZWRMbmdzOiBmYWxzZSxcbiAgbm9uRXhwbGljaXRTdXBwb3J0ZWRMbmdzOiBmYWxzZSxcbiAgbG9hZDogJ2FsbCcsXG4gIHByZWxvYWQ6IGZhbHNlLFxuICBzaW1wbGlmeVBsdXJhbFN1ZmZpeDogdHJ1ZSxcbiAga2V5U2VwYXJhdG9yOiAnLicsXG4gIG5zU2VwYXJhdG9yOiAnOicsXG4gIHBsdXJhbFNlcGFyYXRvcjogJ18nLFxuICBjb250ZXh0U2VwYXJhdG9yOiAnXycsXG4gIHBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzOiBmYWxzZSxcbiAgc2F2ZU1pc3Npbmc6IGZhbHNlLFxuICB1cGRhdGVNaXNzaW5nOiBmYWxzZSxcbiAgc2F2ZU1pc3NpbmdUbzogJ2ZhbGxiYWNrJyxcbiAgc2F2ZU1pc3NpbmdQbHVyYWxzOiB0cnVlLFxuICBtaXNzaW5nS2V5SGFuZGxlcjogZmFsc2UsXG4gIG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcjogZmFsc2UsXG4gIHBvc3RQcm9jZXNzOiBmYWxzZSxcbiAgcG9zdFByb2Nlc3NQYXNzUmVzb2x2ZWQ6IGZhbHNlLFxuICByZXR1cm5OdWxsOiBmYWxzZSxcbiAgcmV0dXJuRW1wdHlTdHJpbmc6IHRydWUsXG4gIHJldHVybk9iamVjdHM6IGZhbHNlLFxuICBqb2luQXJyYXlzOiBmYWxzZSxcbiAgcmV0dXJuZWRPYmplY3RIYW5kbGVyOiBmYWxzZSxcbiAgcGFyc2VNaXNzaW5nS2V5SGFuZGxlcjogZmFsc2UsXG4gIGFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleTogZmFsc2UsXG4gIGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlOiBmYWxzZSxcbiAgb3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXI6IGFyZ3MgPT4ge1xuICAgIGxldCByZXQgPSB7fTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdvYmplY3QnKSByZXQgPSBhcmdzWzFdO1xuICAgIGlmIChpc1N0cmluZyhhcmdzWzFdKSkgcmV0LmRlZmF1bHRWYWx1ZSA9IGFyZ3NbMV07XG4gICAgaWYgKGlzU3RyaW5nKGFyZ3NbMl0pKSByZXQudERlc2NyaXB0aW9uID0gYXJnc1syXTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBhcmdzWzNdID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3NbM10gfHwgYXJnc1syXTtcbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgcmV0W2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgaW50ZXJwb2xhdGlvbjoge1xuICAgIGVzY2FwZVZhbHVlOiB0cnVlLFxuICAgIGZvcm1hdDogdmFsdWUgPT4gdmFsdWUsXG4gICAgcHJlZml4OiAne3snLFxuICAgIHN1ZmZpeDogJ319JyxcbiAgICBmb3JtYXRTZXBhcmF0b3I6ICcsJyxcbiAgICB1bmVzY2FwZVByZWZpeDogJy0nLFxuICAgIG5lc3RpbmdQcmVmaXg6ICckdCgnLFxuICAgIG5lc3RpbmdTdWZmaXg6ICcpJyxcbiAgICBuZXN0aW5nT3B0aW9uc1NlcGFyYXRvcjogJywnLFxuICAgIG1heFJlcGxhY2VzOiAxMDAwLFxuICAgIHNraXBPblZhcmlhYmxlczogdHJ1ZVxuICB9XG59KTtcbmNvbnN0IHRyYW5zZm9ybU9wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgaWYgKGlzU3RyaW5nKG9wdGlvbnMubnMpKSBvcHRpb25zLm5zID0gW29wdGlvbnMubnNdO1xuICBpZiAoaXNTdHJpbmcob3B0aW9ucy5mYWxsYmFja0xuZykpIG9wdGlvbnMuZmFsbGJhY2tMbmcgPSBbb3B0aW9ucy5mYWxsYmFja0xuZ107XG4gIGlmIChpc1N0cmluZyhvcHRpb25zLmZhbGxiYWNrTlMpKSBvcHRpb25zLmZhbGxiYWNrTlMgPSBbb3B0aW9ucy5mYWxsYmFja05TXTtcbiAgaWYgKG9wdGlvbnMuc3VwcG9ydGVkTG5ncyAmJiBvcHRpb25zLnN1cHBvcnRlZExuZ3MuaW5kZXhPZignY2ltb2RlJykgPCAwKSB7XG4gICAgb3B0aW9ucy5zdXBwb3J0ZWRMbmdzID0gb3B0aW9ucy5zdXBwb3J0ZWRMbmdzLmNvbmNhdChbJ2NpbW9kZSddKTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbmNvbnN0IGJpbmRNZW1iZXJGdW5jdGlvbnMgPSBpbnN0ID0+IHtcbiAgY29uc3QgbWVtcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0KSk7XG4gIG1lbXMuZm9yRWFjaChtZW0gPT4ge1xuICAgIGlmICh0eXBlb2YgaW5zdFttZW1dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnN0W21lbV0gPSBpbnN0W21lbV0uYmluZChpbnN0KTtcbiAgICB9XG4gIH0pO1xufTtcbmNsYXNzIEkxOG4gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB0cmFuc2Zvcm1PcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMuc2VydmljZXMgPSB7fTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXI7XG4gICAgdGhpcy5tb2R1bGVzID0ge1xuICAgICAgZXh0ZXJuYWw6IFtdXG4gICAgfTtcbiAgICBiaW5kTWVtYmVyRnVuY3Rpb25zKHRoaXMpO1xuICAgIGlmIChjYWxsYmFjayAmJiAhdGhpcy5pc0luaXRpYWxpemVkICYmICFvcHRpb25zLmlzQ2xvbmUpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmluaXRJbW1lZGlhdGUpIHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5pbml0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxuICBpbml0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSB0cnVlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuZGVmYXVsdE5TICYmIG9wdGlvbnMuZGVmYXVsdE5TICE9PSBmYWxzZSAmJiBvcHRpb25zLm5zKSB7XG4gICAgICBpZiAoaXNTdHJpbmcob3B0aW9ucy5ucykpIHtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0TlMgPSBvcHRpb25zLm5zO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm5zLmluZGV4T2YoJ3RyYW5zbGF0aW9uJykgPCAwKSB7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdE5TID0gb3B0aW9ucy5uc1swXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVmT3B0cyA9IGdldCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZk9wdHMsXG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi50cmFuc2Zvcm1PcHRpb25zKG9wdGlvbnMpXG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgIT09ICd2MScpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uID0ge1xuICAgICAgICAuLi5kZWZPcHRzLmludGVycG9sYXRpb24sXG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5rZXlTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkS2V5U2VwYXJhdG9yID0gb3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5zU2VwYXJhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51c2VyRGVmaW5lZE5zU2VwYXJhdG9yID0gb3B0aW9ucy5uc1NlcGFyYXRvcjtcbiAgICB9XG4gICAgY29uc3QgY3JlYXRlQ2xhc3NPbkRlbWFuZCA9IENsYXNzT3JPYmplY3QgPT4ge1xuICAgICAgaWYgKCFDbGFzc09yT2JqZWN0KSByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgQ2xhc3NPck9iamVjdCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBDbGFzc09yT2JqZWN0KCk7XG4gICAgICByZXR1cm4gQ2xhc3NPck9iamVjdDtcbiAgICB9O1xuICAgIGlmICghdGhpcy5vcHRpb25zLmlzQ2xvbmUpIHtcbiAgICAgIGlmICh0aGlzLm1vZHVsZXMubG9nZ2VyKSB7XG4gICAgICAgIGJhc2VMb2dnZXIuaW5pdChjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5sb2dnZXIpLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUxvZ2dlci5pbml0KG51bGwsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBsZXQgZm9ybWF0dGVyO1xuICAgICAgaWYgKHRoaXMubW9kdWxlcy5mb3JtYXR0ZXIpIHtcbiAgICAgICAgZm9ybWF0dGVyID0gdGhpcy5tb2R1bGVzLmZvcm1hdHRlcjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEludGwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IEZvcm1hdHRlcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGx1ID0gbmV3IExhbmd1YWdlVXRpbCh0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5zdG9yZSA9IG5ldyBSZXNvdXJjZVN0b3JlKHRoaXMub3B0aW9ucy5yZXNvdXJjZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICBjb25zdCBzID0gdGhpcy5zZXJ2aWNlcztcbiAgICAgIHMubG9nZ2VyID0gYmFzZUxvZ2dlcjtcbiAgICAgIHMucmVzb3VyY2VTdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICBzLmxhbmd1YWdlVXRpbHMgPSBsdTtcbiAgICAgIHMucGx1cmFsUmVzb2x2ZXIgPSBuZXcgUGx1cmFsUmVzb2x2ZXIobHUsIHtcbiAgICAgICAgcHJlcGVuZDogdGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcixcbiAgICAgICAgY29tcGF0aWJpbGl0eUpTT046IHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTixcbiAgICAgICAgc2ltcGxpZnlQbHVyYWxTdWZmaXg6IHRoaXMub3B0aW9ucy5zaW1wbGlmeVBsdXJhbFN1ZmZpeFxuICAgICAgfSk7XG4gICAgICBpZiAoZm9ybWF0dGVyICYmICghdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0IHx8IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCA9PT0gZGVmT3B0cy5pbnRlcnBvbGF0aW9uLmZvcm1hdCkpIHtcbiAgICAgICAgcy5mb3JtYXR0ZXIgPSBjcmVhdGVDbGFzc09uRGVtYW5kKGZvcm1hdHRlcik7XG4gICAgICAgIHMuZm9ybWF0dGVyLmluaXQocywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0ID0gcy5mb3JtYXR0ZXIuZm9ybWF0LmJpbmQocy5mb3JtYXR0ZXIpO1xuICAgICAgfVxuICAgICAgcy5pbnRlcnBvbGF0b3IgPSBuZXcgSW50ZXJwb2xhdG9yKHRoaXMub3B0aW9ucyk7XG4gICAgICBzLnV0aWxzID0ge1xuICAgICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IHRoaXMuaGFzTG9hZGVkTmFtZXNwYWNlLmJpbmQodGhpcylcbiAgICAgIH07XG4gICAgICBzLmJhY2tlbmRDb25uZWN0b3IgPSBuZXcgQ29ubmVjdG9yKGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmJhY2tlbmQpLCBzLnJlc291cmNlU3RvcmUsIHMsIHRoaXMub3B0aW9ucyk7XG4gICAgICBzLmJhY2tlbmRDb25uZWN0b3Iub24oJyonLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmxhbmd1YWdlRGV0ZWN0b3IpIHtcbiAgICAgICAgcy5sYW5ndWFnZURldGVjdG9yID0gY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3Rvcik7XG4gICAgICAgIGlmIChzLmxhbmd1YWdlRGV0ZWN0b3IuaW5pdCkgcy5sYW5ndWFnZURldGVjdG9yLmluaXQocywgdGhpcy5vcHRpb25zLmRldGVjdGlvbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1vZHVsZXMuaTE4bkZvcm1hdCkge1xuICAgICAgICBzLmkxOG5Gb3JtYXQgPSBjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5pMThuRm9ybWF0KTtcbiAgICAgICAgaWYgKHMuaTE4bkZvcm1hdC5pbml0KSBzLmkxOG5Gb3JtYXQuaW5pdCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKHRoaXMuc2VydmljZXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnRyYW5zbGF0b3Iub24oJyonLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1vZHVsZXMuZXh0ZXJuYWwuZm9yRWFjaChtID0+IHtcbiAgICAgICAgaWYgKG0uaW5pdCkgbS5pbml0KHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZm9ybWF0ID0gdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZm9ybWF0O1xuICAgIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gbm9vcDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nICYmICF0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgIXRoaXMub3B0aW9ucy5sbmcpIHtcbiAgICAgIGNvbnN0IGNvZGVzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLmdldEZhbGxiYWNrQ29kZXModGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nKTtcbiAgICAgIGlmIChjb2Rlcy5sZW5ndGggPiAwICYmIGNvZGVzWzBdICE9PSAnZGV2JykgdGhpcy5vcHRpb25zLmxuZyA9IGNvZGVzWzBdO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiAhdGhpcy5vcHRpb25zLmxuZykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignaW5pdDogbm8gbGFuZ3VhZ2VEZXRlY3RvciBpcyB1c2VkIGFuZCBubyBsbmcgaXMgZGVmaW5lZCcpO1xuICAgIH1cbiAgICBjb25zdCBzdG9yZUFwaSA9IFsnZ2V0UmVzb3VyY2UnLCAnaGFzUmVzb3VyY2VCdW5kbGUnLCAnZ2V0UmVzb3VyY2VCdW5kbGUnLCAnZ2V0RGF0YUJ5TGFuZ3VhZ2UnXTtcbiAgICBzdG9yZUFwaS5mb3JFYWNoKGZjTmFtZSA9PiB7XG4gICAgICB0aGlzW2ZjTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5zdG9yZVtmY05hbWVdKC4uLmFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHN0b3JlQXBpQ2hhaW5lZCA9IFsnYWRkUmVzb3VyY2UnLCAnYWRkUmVzb3VyY2VzJywgJ2FkZFJlc291cmNlQnVuZGxlJywgJ3JlbW92ZVJlc291cmNlQnVuZGxlJ107XG4gICAgc3RvcmVBcGlDaGFpbmVkLmZvckVhY2goZmNOYW1lID0+IHtcbiAgICAgIHRoaXNbZmNOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc3RvcmVbZmNOYW1lXSguLi5hcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmluaXNoID0gKGVyciwgdCkgPT4ge1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQgJiYgIXRoaXMuaW5pdGlhbGl6ZWRTdG9yZU9uY2UpIHRoaXMubG9nZ2VyLndhcm4oJ2luaXQ6IGkxOG5leHQgaXMgYWxyZWFkeSBpbml0aWFsaXplZC4gWW91IHNob3VsZCBjYWxsIGluaXQganVzdCBvbmNlIScpO1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0Nsb25lKSB0aGlzLmxvZ2dlci5sb2coJ2luaXRpYWxpemVkJywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5lbWl0KCdpbml0aWFsaXplZCcsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgdCk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGFuZ3VhZ2VzICYmIHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJICE9PSAndjEnICYmICF0aGlzLmlzSW5pdGlhbGl6ZWQpIHJldHVybiBmaW5pc2gobnVsbCwgdGhpcy50LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5jaGFuZ2VMYW5ndWFnZSh0aGlzLm9wdGlvbnMubG5nLCBmaW5pc2gpO1xuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNvdXJjZXMgfHwgIXRoaXMub3B0aW9ucy5pbml0SW1tZWRpYXRlKSB7XG4gICAgICBsb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQobG9hZCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBsb2FkUmVzb3VyY2VzKGxhbmd1YWdlKSB7XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wO1xuICAgIGxldCB1c2VkQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBjb25zdCB1c2VkTG5nID0gaXNTdHJpbmcobGFuZ3VhZ2UpID8gbGFuZ3VhZ2UgOiB0aGlzLmxhbmd1YWdlO1xuICAgIGlmICh0eXBlb2YgbGFuZ3VhZ2UgPT09ICdmdW5jdGlvbicpIHVzZWRDYWxsYmFjayA9IGxhbmd1YWdlO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnJlc291cmNlcyB8fCB0aGlzLm9wdGlvbnMucGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMpIHtcbiAgICAgIGlmICh1c2VkTG5nICYmIHVzZWRMbmcudG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScgJiYgKCF0aGlzLm9wdGlvbnMucHJlbG9hZCB8fCB0aGlzLm9wdGlvbnMucHJlbG9hZC5sZW5ndGggPT09IDApKSByZXR1cm4gdXNlZENhbGxiYWNrKCk7XG4gICAgICBjb25zdCB0b0xvYWQgPSBbXTtcbiAgICAgIGNvbnN0IGFwcGVuZCA9IGxuZyA9PiB7XG4gICAgICAgIGlmICghbG5nKSByZXR1cm47XG4gICAgICAgIGlmIChsbmcgPT09ICdjaW1vZGUnKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxuZ3MgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGxuZyk7XG4gICAgICAgIGxuZ3MuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICBpZiAobCA9PT0gJ2NpbW9kZScpIHJldHVybjtcbiAgICAgICAgICBpZiAodG9Mb2FkLmluZGV4T2YobCkgPCAwKSB0b0xvYWQucHVzaChsKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKCF1c2VkTG5nKSB7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICAgIGZhbGxiYWNrcy5mb3JFYWNoKGwgPT4gYXBwZW5kKGwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCh1c2VkTG5nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJlbG9hZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMucHJlbG9hZC5mb3JFYWNoKGwgPT4gYXBwZW5kKGwpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5sb2FkKHRvTG9hZCwgdGhpcy5vcHRpb25zLm5zLCBlID0+IHtcbiAgICAgICAgaWYgKCFlICYmICF0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgJiYgdGhpcy5sYW5ndWFnZSkgdGhpcy5zZXRSZXNvbHZlZExhbmd1YWdlKHRoaXMubGFuZ3VhZ2UpO1xuICAgICAgICB1c2VkQ2FsbGJhY2soZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXNlZENhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgfVxuICByZWxvYWRSZXNvdXJjZXMobG5ncywgbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGlmICh0eXBlb2YgbG5ncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBsbmdzO1xuICAgICAgbG5ncyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBucztcbiAgICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWxuZ3MpIGxuZ3MgPSB0aGlzLmxhbmd1YWdlcztcbiAgICBpZiAoIW5zKSBucyA9IHRoaXMub3B0aW9ucy5ucztcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLnJlbG9hZChsbmdzLCBucywgZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIHVzZShtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZSkgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHBhc3NpbmcgYW4gdW5kZWZpbmVkIG1vZHVsZSEgUGxlYXNlIGNoZWNrIHRoZSBvYmplY3QgeW91IGFyZSBwYXNzaW5nIHRvIGkxOG5leHQudXNlKCknKTtcbiAgICBpZiAoIW1vZHVsZS50eXBlKSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgcGFzc2luZyBhIHdyb25nIG1vZHVsZSEgUGxlYXNlIGNoZWNrIHRoZSBvYmplY3QgeW91IGFyZSBwYXNzaW5nIHRvIGkxOG5leHQudXNlKCknKTtcbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdiYWNrZW5kJykge1xuICAgICAgdGhpcy5tb2R1bGVzLmJhY2tlbmQgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2xvZ2dlcicgfHwgbW9kdWxlLmxvZyAmJiBtb2R1bGUud2FybiAmJiBtb2R1bGUuZXJyb3IpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5sb2dnZXIgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2xhbmd1YWdlRGV0ZWN0b3InKSB7XG4gICAgICB0aGlzLm1vZHVsZXMubGFuZ3VhZ2VEZXRlY3RvciA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnaTE4bkZvcm1hdCcpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5pMThuRm9ybWF0ID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdwb3N0UHJvY2Vzc29yJykge1xuICAgICAgcG9zdFByb2Nlc3Nvci5hZGRQb3N0UHJvY2Vzc29yKG1vZHVsZSk7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2Zvcm1hdHRlcicpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5mb3JtYXR0ZXIgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJzNyZFBhcnR5Jykge1xuICAgICAgdGhpcy5tb2R1bGVzLmV4dGVybmFsLnB1c2gobW9kdWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0UmVzb2x2ZWRMYW5ndWFnZShsKSB7XG4gICAgaWYgKCFsIHx8ICF0aGlzLmxhbmd1YWdlcykgcmV0dXJuO1xuICAgIGlmIChbJ2NpbW9kZScsICdkZXYnXS5pbmRleE9mKGwpID4gLTEpIHJldHVybjtcbiAgICBmb3IgKGxldCBsaSA9IDA7IGxpIDwgdGhpcy5sYW5ndWFnZXMubGVuZ3RoOyBsaSsrKSB7XG4gICAgICBjb25zdCBsbmdJbkxuZ3MgPSB0aGlzLmxhbmd1YWdlc1tsaV07XG4gICAgICBpZiAoWydjaW1vZGUnLCAnZGV2J10uaW5kZXhPZihsbmdJbkxuZ3MpID4gLTEpIGNvbnRpbnVlO1xuICAgICAgaWYgKHRoaXMuc3RvcmUuaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zKGxuZ0luTG5ncykpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gbG5nSW5MbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hhbmdlTGFuZ3VhZ2UobG5nLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSBsbmc7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRoaXMuZW1pdCgnbGFuZ3VhZ2VDaGFuZ2luZycsIGxuZyk7XG4gICAgY29uc3Qgc2V0TG5nUHJvcHMgPSBsID0+IHtcbiAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsO1xuICAgICAgdGhpcy5sYW5ndWFnZXMgPSB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KGwpO1xuICAgICAgdGhpcy5yZXNvbHZlZExhbmd1YWdlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zZXRSZXNvbHZlZExhbmd1YWdlKGwpO1xuICAgIH07XG4gICAgY29uc3QgZG9uZSA9IChlcnIsIGwpID0+IHtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIHNldExuZ1Byb3BzKGwpO1xuICAgICAgICB0aGlzLnRyYW5zbGF0b3IuY2hhbmdlTGFuZ3VhZ2UobCk7XG4gICAgICAgIHRoaXMuaXNMYW5ndWFnZUNoYW5naW5nVG8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZW1pdCgnbGFuZ3VhZ2VDaGFuZ2VkJywgbCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygnbGFuZ3VhZ2VDaGFuZ2VkJywgbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIudCguLi5hcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnQoLi4uYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc2V0TG5nID0gbG5ncyA9PiB7XG4gICAgICBpZiAoIWxuZyAmJiAhbG5ncyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IpIGxuZ3MgPSBbXTtcbiAgICAgIGNvbnN0IGwgPSBpc1N0cmluZyhsbmdzKSA/IGxuZ3MgOiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlVXRpbHMuZ2V0QmVzdE1hdGNoRnJvbUNvZGVzKGxuZ3MpO1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhbmd1YWdlKSB7XG4gICAgICAgICAgc2V0TG5nUHJvcHMobCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRyYW5zbGF0b3IubGFuZ3VhZ2UpIHRoaXMudHJhbnNsYXRvci5jaGFuZ2VMYW5ndWFnZShsKTtcbiAgICAgICAgaWYgKHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuY2FjaGVVc2VyTGFuZ3VhZ2UpIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5jYWNoZVVzZXJMYW5ndWFnZShsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZFJlc291cmNlcyhsLCBlcnIgPT4ge1xuICAgICAgICBkb25lKGVyciwgbCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmICghbG5nICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3RvciAmJiAhdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmFzeW5jKSB7XG4gICAgICBzZXRMbmcodGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdCgpKTtcbiAgICB9IGVsc2UgaWYgKCFsbmcgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5hc3luYykge1xuICAgICAgaWYgKHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3QoKS50aGVuKHNldExuZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0KHNldExuZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldExuZyhsbmcpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgZ2V0Rml4ZWRUKGxuZywgbnMsIGtleVByZWZpeCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIGNvbnN0IGZpeGVkVCA9IGZ1bmN0aW9uIChrZXksIG9wdHMpIHtcbiAgICAgIGxldCBvcHRpb25zO1xuICAgICAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbjMgPiAyID8gX2xlbjMgLSAyIDogMCksIF9rZXkzID0gMjsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICAgIHJlc3RbX2tleTMgLSAyXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IF90aGlzMy5vcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyKFtrZXksIG9wdHNdLmNvbmNhdChyZXN0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMubG5nID0gb3B0aW9ucy5sbmcgfHwgZml4ZWRULmxuZztcbiAgICAgIG9wdGlvbnMubG5ncyA9IG9wdGlvbnMubG5ncyB8fCBmaXhlZFQubG5ncztcbiAgICAgIG9wdGlvbnMubnMgPSBvcHRpb25zLm5zIHx8IGZpeGVkVC5ucztcbiAgICAgIGlmIChvcHRpb25zLmtleVByZWZpeCAhPT0gJycpIG9wdGlvbnMua2V5UHJlZml4ID0gb3B0aW9ucy5rZXlQcmVmaXggfHwga2V5UHJlZml4IHx8IGZpeGVkVC5rZXlQcmVmaXg7XG4gICAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBfdGhpczMub3B0aW9ucy5rZXlTZXBhcmF0b3IgfHwgJy4nO1xuICAgICAgbGV0IHJlc3VsdEtleTtcbiAgICAgIGlmIChvcHRpb25zLmtleVByZWZpeCAmJiBBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgcmVzdWx0S2V5ID0ga2V5Lm1hcChrID0+IGAke29wdGlvbnMua2V5UHJlZml4fSR7a2V5U2VwYXJhdG9yfSR7a31gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdEtleSA9IG9wdGlvbnMua2V5UHJlZml4ID8gYCR7b3B0aW9ucy5rZXlQcmVmaXh9JHtrZXlTZXBhcmF0b3J9JHtrZXl9YCA6IGtleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdGhpczMudChyZXN1bHRLZXksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgaWYgKGlzU3RyaW5nKGxuZykpIHtcbiAgICAgIGZpeGVkVC5sbmcgPSBsbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpeGVkVC5sbmdzID0gbG5nO1xuICAgIH1cbiAgICBmaXhlZFQubnMgPSBucztcbiAgICBmaXhlZFQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHJldHVybiBmaXhlZFQ7XG4gIH1cbiAgdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yICYmIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUoLi4uYXJndW1lbnRzKTtcbiAgfVxuICBleGlzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRvciAmJiB0aGlzLnRyYW5zbGF0b3IuZXhpc3RzKC4uLmFyZ3VtZW50cyk7XG4gIH1cbiAgc2V0RGVmYXVsdE5hbWVzcGFjZShucykge1xuICAgIHRoaXMub3B0aW9ucy5kZWZhdWx0TlMgPSBucztcbiAgfVxuICBoYXNMb2FkZWROYW1lc3BhY2UobnMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2hhc0xvYWRlZE5hbWVzcGFjZTogaTE4bmV4dCB3YXMgbm90IGluaXRpYWxpemVkJywgdGhpcy5sYW5ndWFnZXMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubGFuZ3VhZ2VzIHx8ICF0aGlzLmxhbmd1YWdlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2hhc0xvYWRlZE5hbWVzcGFjZTogaTE4bi5sYW5ndWFnZXMgd2VyZSB1bmRlZmluZWQgb3IgZW1wdHknLCB0aGlzLmxhbmd1YWdlcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxuZyA9IG9wdGlvbnMubG5nIHx8IHRoaXMucmVzb2x2ZWRMYW5ndWFnZSB8fCB0aGlzLmxhbmd1YWdlc1swXTtcbiAgICBjb25zdCBmYWxsYmFja0xuZyA9IHRoaXMub3B0aW9ucyA/IHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyA6IGZhbHNlO1xuICAgIGNvbnN0IGxhc3RMbmcgPSB0aGlzLmxhbmd1YWdlc1t0aGlzLmxhbmd1YWdlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAobG5nLnRvTG93ZXJDYXNlKCkgPT09ICdjaW1vZGUnKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBsb2FkTm90UGVuZGluZyA9IChsLCBuKSA9PiB7XG4gICAgICBjb25zdCBsb2FkU3RhdGUgPSB0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3Iuc3RhdGVbYCR7bH18JHtufWBdO1xuICAgICAgcmV0dXJuIGxvYWRTdGF0ZSA9PT0gLTEgfHwgbG9hZFN0YXRlID09PSAwIHx8IGxvYWRTdGF0ZSA9PT0gMjtcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLnByZWNoZWNrKSB7XG4gICAgICBjb25zdCBwcmVSZXN1bHQgPSBvcHRpb25zLnByZWNoZWNrKHRoaXMsIGxvYWROb3RQZW5kaW5nKTtcbiAgICAgIGlmIChwcmVSZXN1bHQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHByZVJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykpIHJldHVybiB0cnVlO1xuICAgIGlmICghdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLmJhY2tlbmQgfHwgdGhpcy5vcHRpb25zLnJlc291cmNlcyAmJiAhdGhpcy5vcHRpb25zLnBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobG9hZE5vdFBlbmRpbmcobG5nLCBucykgJiYgKCFmYWxsYmFja0xuZyB8fCBsb2FkTm90UGVuZGluZyhsYXN0TG5nLCBucykpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbG9hZE5hbWVzcGFjZXMobnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLm5zKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhucykpIG5zID0gW25zXTtcbiAgICBucy5mb3JFYWNoKG4gPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG4pIDwgMCkgdGhpcy5vcHRpb25zLm5zLnB1c2gobik7XG4gICAgfSk7XG4gICAgdGhpcy5sb2FkUmVzb3VyY2VzKGVyciA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGxvYWRMYW5ndWFnZXMobG5ncywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKGlzU3RyaW5nKGxuZ3MpKSBsbmdzID0gW2xuZ3NdO1xuICAgIGNvbnN0IHByZWxvYWRlZCA9IHRoaXMub3B0aW9ucy5wcmVsb2FkIHx8IFtdO1xuICAgIGNvbnN0IG5ld0xuZ3MgPSBsbmdzLmZpbHRlcihsbmcgPT4gcHJlbG9hZGVkLmluZGV4T2YobG5nKSA8IDAgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLmlzU3VwcG9ydGVkQ29kZShsbmcpKTtcbiAgICBpZiAoIW5ld0xuZ3MubGVuZ3RoKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucy5wcmVsb2FkID0gcHJlbG9hZGVkLmNvbmNhdChuZXdMbmdzKTtcbiAgICB0aGlzLmxvYWRSZXNvdXJjZXMoZXJyID0+IHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgZGlyKGxuZykge1xuICAgIGlmICghbG5nKSBsbmcgPSB0aGlzLnJlc29sdmVkTGFuZ3VhZ2UgfHwgKHRoaXMubGFuZ3VhZ2VzICYmIHRoaXMubGFuZ3VhZ2VzLmxlbmd0aCA+IDAgPyB0aGlzLmxhbmd1YWdlc1swXSA6IHRoaXMubGFuZ3VhZ2UpO1xuICAgIGlmICghbG5nKSByZXR1cm4gJ3J0bCc7XG4gICAgY29uc3QgcnRsTG5ncyA9IFsnYXInLCAnc2h1JywgJ3NxcicsICdzc2gnLCAneGFhJywgJ3loZCcsICd5dWQnLCAnYWFvJywgJ2FiaCcsICdhYnYnLCAnYWNtJywgJ2FjcScsICdhY3cnLCAnYWN4JywgJ2FjeScsICdhZGYnLCAnYWRzJywgJ2FlYicsICdhZWMnLCAnYWZiJywgJ2FqcCcsICdhcGMnLCAnYXBkJywgJ2FyYicsICdhcnEnLCAnYXJzJywgJ2FyeScsICdhcnonLCAnYXV6JywgJ2F2bCcsICdheWgnLCAnYXlsJywgJ2F5bicsICdheXAnLCAnYmJ6JywgJ3BnYScsICdoZScsICdpdycsICdwcycsICdwYnQnLCAncGJ1JywgJ3BzdCcsICdwcnAnLCAncHJkJywgJ3VnJywgJ3VyJywgJ3lkZCcsICd5ZHMnLCAneWloJywgJ2ppJywgJ3lpJywgJ2hibycsICdtZW4nLCAneG1uJywgJ2ZhJywgJ2pwcicsICdwZW8nLCAncGVzJywgJ3BycycsICdkdicsICdzYW0nLCAnY2tiJ107XG4gICAgY29uc3QgbGFuZ3VhZ2VVdGlscyA9IHRoaXMuc2VydmljZXMgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzIHx8IG5ldyBMYW5ndWFnZVV0aWwoZ2V0KCkpO1xuICAgIHJldHVybiBydGxMbmdzLmluZGV4T2YobGFuZ3VhZ2VVdGlscy5nZXRMYW5ndWFnZVBhcnRGcm9tQ29kZShsbmcpKSA+IC0xIHx8IGxuZy50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJy1hcmFiJykgPiAxID8gJ3J0bCcgOiAnbHRyJztcbiAgfVxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBuZXcgSTE4bihvcHRpb25zLCBjYWxsYmFjayk7XG4gIH1cbiAgY2xvbmVJbnN0YW5jZSgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wO1xuICAgIGNvbnN0IGZvcmtSZXNvdXJjZVN0b3JlID0gb3B0aW9ucy5mb3JrUmVzb3VyY2VTdG9yZTtcbiAgICBpZiAoZm9ya1Jlc291cmNlU3RvcmUpIGRlbGV0ZSBvcHRpb25zLmZvcmtSZXNvdXJjZVN0b3JlO1xuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgLi4ue1xuICAgICAgICBpc0Nsb25lOiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBJMThuKG1lcmdlZE9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmRlYnVnICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5wcmVmaXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xvbmUubG9nZ2VyID0gY2xvbmUubG9nZ2VyLmNsb25lKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBtZW1iZXJzVG9Db3B5ID0gWydzdG9yZScsICdzZXJ2aWNlcycsICdsYW5ndWFnZSddO1xuICAgIG1lbWJlcnNUb0NvcHkuZm9yRWFjaChtID0+IHtcbiAgICAgIGNsb25lW21dID0gdGhpc1ttXTtcbiAgICB9KTtcbiAgICBjbG9uZS5zZXJ2aWNlcyA9IHtcbiAgICAgIC4uLnRoaXMuc2VydmljZXNcbiAgICB9O1xuICAgIGNsb25lLnNlcnZpY2VzLnV0aWxzID0ge1xuICAgICAgaGFzTG9hZGVkTmFtZXNwYWNlOiBjbG9uZS5oYXNMb2FkZWROYW1lc3BhY2UuYmluZChjbG9uZSlcbiAgICB9O1xuICAgIGlmIChmb3JrUmVzb3VyY2VTdG9yZSkge1xuICAgICAgY2xvbmUuc3RvcmUgPSBuZXcgUmVzb3VyY2VTdG9yZSh0aGlzLnN0b3JlLmRhdGEsIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgY2xvbmUuc2VydmljZXMucmVzb3VyY2VTdG9yZSA9IGNsb25lLnN0b3JlO1xuICAgIH1cbiAgICBjbG9uZS50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoY2xvbmUuc2VydmljZXMsIG1lcmdlZE9wdGlvbnMpO1xuICAgIGNsb25lLnRyYW5zbGF0b3Iub24oJyonLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG4gICAgICBjbG9uZS5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9KTtcbiAgICBjbG9uZS5pbml0KG1lcmdlZE9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICBjbG9uZS50cmFuc2xhdG9yLm9wdGlvbnMgPSBtZXJnZWRPcHRpb25zO1xuICAgIGNsb25lLnRyYW5zbGF0b3IuYmFja2VuZENvbm5lY3Rvci5zZXJ2aWNlcy51dGlscyA9IHtcbiAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogY2xvbmUuaGFzTG9hZGVkTmFtZXNwYWNlLmJpbmQoY2xvbmUpXG4gICAgfTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICBzdG9yZTogdGhpcy5zdG9yZSxcbiAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgbGFuZ3VhZ2VzOiB0aGlzLmxhbmd1YWdlcyxcbiAgICAgIHJlc29sdmVkTGFuZ3VhZ2U6IHRoaXMucmVzb2x2ZWRMYW5ndWFnZVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IGluc3RhbmNlID0gSTE4bi5jcmVhdGVJbnN0YW5jZSgpO1xuaW5zdGFuY2UuY3JlYXRlSW5zdGFuY2UgPSBJMThuLmNyZWF0ZUluc3RhbmNlO1xuXG5jb25zdCBjcmVhdGVJbnN0YW5jZSA9IGluc3RhbmNlLmNyZWF0ZUluc3RhbmNlO1xuY29uc3QgZGlyID0gaW5zdGFuY2UuZGlyO1xuY29uc3QgaW5pdCA9IGluc3RhbmNlLmluaXQ7XG5jb25zdCBsb2FkUmVzb3VyY2VzID0gaW5zdGFuY2UubG9hZFJlc291cmNlcztcbmNvbnN0IHJlbG9hZFJlc291cmNlcyA9IGluc3RhbmNlLnJlbG9hZFJlc291cmNlcztcbmNvbnN0IHVzZSA9IGluc3RhbmNlLnVzZTtcbmNvbnN0IGNoYW5nZUxhbmd1YWdlID0gaW5zdGFuY2UuY2hhbmdlTGFuZ3VhZ2U7XG5jb25zdCBnZXRGaXhlZFQgPSBpbnN0YW5jZS5nZXRGaXhlZFQ7XG5jb25zdCB0ID0gaW5zdGFuY2UudDtcbmNvbnN0IGV4aXN0cyA9IGluc3RhbmNlLmV4aXN0cztcbmNvbnN0IHNldERlZmF1bHROYW1lc3BhY2UgPSBpbnN0YW5jZS5zZXREZWZhdWx0TmFtZXNwYWNlO1xuY29uc3QgaGFzTG9hZGVkTmFtZXNwYWNlID0gaW5zdGFuY2UuaGFzTG9hZGVkTmFtZXNwYWNlO1xuY29uc3QgbG9hZE5hbWVzcGFjZXMgPSBpbnN0YW5jZS5sb2FkTmFtZXNwYWNlcztcbmNvbnN0IGxvYWRMYW5ndWFnZXMgPSBpbnN0YW5jZS5sb2FkTGFuZ3VhZ2VzO1xuXG5leHBvcnQgeyBjaGFuZ2VMYW5ndWFnZSwgY3JlYXRlSW5zdGFuY2UsIGluc3RhbmNlIGFzIGRlZmF1bHQsIGRpciwgZXhpc3RzLCBnZXRGaXhlZFQsIGhhc0xvYWRlZE5hbWVzcGFjZSwgaW5pdCwgbG9hZExhbmd1YWdlcywgbG9hZE5hbWVzcGFjZXMsIGxvYWRSZXNvdXJjZXMsIHJlbG9hZFJlc291cmNlcywgc2V0RGVmYXVsdE5hbWVzcGFjZSwgdCwgdXNlIH07XG4iXSwibmFtZXMiOlsiaXNTdHJpbmciLCJvYmoiLCJkZWZlciIsInJlcyIsInJlaiIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm1ha2VTdHJpbmciLCJvYmplY3QiLCJjb3B5IiwiYSIsInMiLCJ0IiwiZm9yRWFjaCIsIm0iLCJsYXN0T2ZQYXRoU2VwYXJhdG9yUmVnRXhwIiwiY2xlYW5LZXkiLCJrZXkiLCJpbmRleE9mIiwicmVwbGFjZSIsImNhbk5vdFRyYXZlcnNlRGVlcGVyIiwiZ2V0TGFzdE9mUGF0aCIsInBhdGgiLCJFbXB0eSIsInN0YWNrIiwic3BsaXQiLCJzdGFja0luZGV4IiwibGVuZ3RoIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiayIsInNldFBhdGgiLCJuZXdWYWx1ZSIsInVuZGVmaW5lZCIsImUiLCJwIiwic2xpY2UiLCJsYXN0IiwicHVzaFBhdGgiLCJjb25jYXQiLCJwdXNoIiwiZ2V0UGF0aCIsImdldFBhdGhXaXRoRGVmYXVsdHMiLCJkYXRhIiwiZGVmYXVsdERhdGEiLCJ2YWx1ZSIsImRlZXBFeHRlbmQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJvdmVyd3JpdGUiLCJwcm9wIiwiU3RyaW5nIiwicmVnZXhFc2NhcGUiLCJzdHIiLCJfZW50aXR5TWFwIiwiZXNjYXBlIiwiUmVnRXhwQ2FjaGUiLCJjb25zdHJ1Y3RvciIsImNhcGFjaXR5IiwicmVnRXhwTWFwIiwiTWFwIiwicmVnRXhwUXVldWUiLCJnZXRSZWdFeHAiLCJwYXR0ZXJuIiwicmVnRXhwRnJvbUNhY2hlIiwiZ2V0IiwicmVnRXhwTmV3IiwiUmVnRXhwIiwiZGVsZXRlIiwic2hpZnQiLCJzZXQiLCJjaGFycyIsImxvb2tzTGlrZU9iamVjdFBhdGhSZWdFeHBDYWNoZSIsImxvb2tzTGlrZU9iamVjdFBhdGgiLCJuc1NlcGFyYXRvciIsImtleVNlcGFyYXRvciIsInBvc3NpYmxlQ2hhcnMiLCJmaWx0ZXIiLCJjIiwiciIsIm1hcCIsImpvaW4iLCJtYXRjaGVkIiwidGVzdCIsImtpIiwic3Vic3RyaW5nIiwiZGVlcEZpbmQiLCJhcmd1bWVudHMiLCJ0b2tlbnMiLCJjdXJyZW50IiwiaSIsIm5leHQiLCJuZXh0UGF0aCIsImoiLCJnZXRDbGVhbmVkQ29kZSIsImNvZGUiLCJjb25zb2xlTG9nZ2VyIiwidHlwZSIsImxvZyIsImFyZ3MiLCJvdXRwdXQiLCJ3YXJuIiwiZXJyb3IiLCJjb25zb2xlIiwiYXBwbHkiLCJMb2dnZXIiLCJjb25jcmV0ZUxvZ2dlciIsIm9wdGlvbnMiLCJpbml0IiwicHJlZml4IiwibG9nZ2VyIiwiZGVidWciLCJfbGVuIiwiQXJyYXkiLCJfa2V5IiwiZm9yd2FyZCIsIl9sZW4yIiwiX2tleTIiLCJfbGVuMyIsIl9rZXkzIiwiZGVwcmVjYXRlIiwiX2xlbjQiLCJfa2V5NCIsImx2bCIsImRlYnVnT25seSIsImNyZWF0ZSIsIm1vZHVsZU5hbWUiLCJjbG9uZSIsImJhc2VMb2dnZXIiLCJFdmVudEVtaXR0ZXIiLCJvYnNlcnZlcnMiLCJvbiIsImV2ZW50cyIsImxpc3RlbmVyIiwiZXZlbnQiLCJudW1MaXN0ZW5lcnMiLCJvZmYiLCJlbWl0IiwiY2xvbmVkIiwiZnJvbSIsImVudHJpZXMiLCJfcmVmIiwib2JzZXJ2ZXIiLCJudW1UaW1lc0FkZGVkIiwiX3JlZjIiLCJSZXNvdXJjZVN0b3JlIiwibnMiLCJkZWZhdWx0TlMiLCJpZ25vcmVKU09OU3RydWN0dXJlIiwiYWRkTmFtZXNwYWNlcyIsInJlbW92ZU5hbWVzcGFjZXMiLCJpbmRleCIsInNwbGljZSIsImdldFJlc291cmNlIiwibG5nIiwiaXNBcnJheSIsInJlc3VsdCIsImFkZFJlc291cmNlIiwic2lsZW50IiwiYWRkUmVzb3VyY2VzIiwicmVzb3VyY2VzIiwiYWRkUmVzb3VyY2VCdW5kbGUiLCJkZWVwIiwic2tpcENvcHkiLCJwYWNrIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicmVtb3ZlUmVzb3VyY2VCdW5kbGUiLCJoYXNSZXNvdXJjZUJ1bmRsZSIsImdldFJlc291cmNlQnVuZGxlIiwiY29tcGF0aWJpbGl0eUFQSSIsImdldERhdGFCeUxhbmd1YWdlIiwiaGFzTGFuZ3VhZ2VTb21lVHJhbnNsYXRpb25zIiwibiIsImtleXMiLCJmaW5kIiwidiIsInRvSlNPTiIsInBvc3RQcm9jZXNzb3IiLCJwcm9jZXNzb3JzIiwiYWRkUG9zdFByb2Nlc3NvciIsIm1vZHVsZSIsIm5hbWUiLCJoYW5kbGUiLCJ0cmFuc2xhdG9yIiwicHJvY2Vzc29yIiwicHJvY2VzcyIsImNoZWNrZWRMb2FkZWRGb3IiLCJUcmFuc2xhdG9yIiwic2VydmljZXMiLCJjaGFuZ2VMYW5ndWFnZSIsImxhbmd1YWdlIiwiZXhpc3RzIiwiaW50ZXJwb2xhdGlvbiIsInJlc29sdmVkIiwiZXh0cmFjdEZyb21LZXkiLCJuYW1lc3BhY2VzIiwid291bGRDaGVja0Zvck5zSW5LZXkiLCJzZWVtc05hdHVyYWxMYW5ndWFnZSIsInVzZXJEZWZpbmVkS2V5U2VwYXJhdG9yIiwidXNlckRlZmluZWROc1NlcGFyYXRvciIsIm1hdGNoIiwiaW50ZXJwb2xhdG9yIiwibmVzdGluZ1JlZ2V4cCIsInBhcnRzIiwidHJhbnNsYXRlIiwibGFzdEtleSIsIm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyIiwicmV0dXJuRGV0YWlscyIsIm5hbWVzcGFjZSIsImFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlIiwidG9Mb3dlckNhc2UiLCJ1c2VkS2V5IiwiZXhhY3RVc2VkS2V5IiwidXNlZExuZyIsInVzZWROUyIsInVzZWRQYXJhbXMiLCJnZXRVc2VkUGFyYW1zRGV0YWlscyIsInJlc1VzZWRLZXkiLCJyZXNFeGFjdFVzZWRLZXkiLCJyZXNUeXBlIiwidG9TdHJpbmciLCJub09iamVjdCIsImpvaW5BcnJheXMiLCJoYW5kbGVBc09iamVjdEluSTE4bkZvcm1hdCIsImkxOG5Gb3JtYXQiLCJoYW5kbGVBc09iamVjdCIsInJldHVybk9iamVjdHMiLCJyZXR1cm5lZE9iamVjdEhhbmRsZXIiLCJyZXNUeXBlSXNBcnJheSIsIm5ld0tleVRvVXNlIiwiZGVlcEtleSIsImV4dGVuZFRyYW5zbGF0aW9uIiwidXNlZERlZmF1bHQiLCJuZWVkc1BsdXJhbEhhbmRsaW5nIiwiY291bnQiLCJoYXNEZWZhdWx0VmFsdWUiLCJkZWZhdWx0VmFsdWVTdWZmaXgiLCJwbHVyYWxSZXNvbHZlciIsImdldFN1ZmZpeCIsImRlZmF1bHRWYWx1ZVN1ZmZpeE9yZGluYWxGYWxsYmFjayIsIm9yZGluYWwiLCJuZWVkc1plcm9TdWZmaXhMb29rdXAiLCJzaG91bGRVc2VJbnRsQXBpIiwiZGVmYXVsdFZhbHVlIiwicGx1cmFsU2VwYXJhdG9yIiwiaXNWYWxpZExvb2t1cCIsIm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSIsInJlc0Zvck1pc3NpbmciLCJ1cGRhdGVNaXNzaW5nIiwiZmsiLCJsbmdzIiwiZmFsbGJhY2tMbmdzIiwibGFuZ3VhZ2VVdGlscyIsImdldEZhbGxiYWNrQ29kZXMiLCJmYWxsYmFja0xuZyIsInNhdmVNaXNzaW5nVG8iLCJ0b1Jlc29sdmVIaWVyYXJjaHkiLCJzZW5kIiwibCIsInNwZWNpZmljRGVmYXVsdFZhbHVlIiwiZGVmYXVsdEZvck1pc3NpbmciLCJtaXNzaW5nS2V5SGFuZGxlciIsImJhY2tlbmRDb25uZWN0b3IiLCJzYXZlTWlzc2luZyIsInNhdmVNaXNzaW5nUGx1cmFscyIsInN1ZmZpeGVzIiwiZ2V0U3VmZml4ZXMiLCJzdWZmaXgiLCJhcHBlbmROYW1lc3BhY2VUb01pc3NpbmdLZXkiLCJwYXJzZU1pc3NpbmdLZXlIYW5kbGVyIiwiX3RoaXMiLCJkZWZhdWx0VmFyaWFibGVzIiwic2tpcEludGVycG9sYXRpb24iLCJza2lwT25WYXJpYWJsZXMiLCJuZXN0QmVmIiwibmIiLCJpbnRlcnBvbGF0ZSIsIm5hIiwibmVzdEFmdCIsIm5lc3QiLCJjb250ZXh0IiwicmVzZXQiLCJwb3N0UHJvY2VzcyIsInBvc3RQcm9jZXNzb3JOYW1lcyIsImFwcGx5UG9zdFByb2Nlc3NvciIsInBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkIiwiaTE4blJlc29sdmVkIiwiZm91bmQiLCJleHRyYWN0ZWQiLCJmYWxsYmFja05TIiwibmVlZHNDb250ZXh0SGFuZGxpbmciLCJjb2RlcyIsInV0aWxzIiwiaGFzTG9hZGVkTmFtZXNwYWNlIiwiZmluYWxLZXlzIiwiYWRkTG9va3VwS2V5cyIsInBsdXJhbFN1ZmZpeCIsInplcm9TdWZmaXgiLCJvcmRpbmFsUHJlZml4IiwiY29udGV4dEtleSIsImNvbnRleHRTZXBhcmF0b3IiLCJwb3NzaWJsZUtleSIsInBvcCIsInJldHVybk51bGwiLCJyZXR1cm5FbXB0eVN0cmluZyIsInJlc291cmNlU3RvcmUiLCJvcHRpb25zS2V5cyIsInVzZU9wdGlvbnNSZXBsYWNlRm9yRGF0YSIsIm9wdGlvbiIsImNhcGl0YWxpemUiLCJzdHJpbmciLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsIkxhbmd1YWdlVXRpbCIsInN1cHBvcnRlZExuZ3MiLCJnZXRTY3JpcHRQYXJ0RnJvbUNvZGUiLCJmb3JtYXRMYW5ndWFnZUNvZGUiLCJnZXRMYW5ndWFnZVBhcnRGcm9tQ29kZSIsIkludGwiLCJnZXRDYW5vbmljYWxMb2NhbGVzIiwiZm9ybWF0dGVkQ29kZSIsImxvd2VyQ2FzZUxuZyIsInNwZWNpYWxDYXNlcyIsInBhcnQiLCJjbGVhbkNvZGUiLCJpc1N1cHBvcnRlZENvZGUiLCJsb2FkIiwibm9uRXhwbGljaXRTdXBwb3J0ZWRMbmdzIiwiZ2V0QmVzdE1hdGNoRnJvbUNvZGVzIiwiY2xlYW5lZExuZyIsImxuZ09ubHkiLCJzdXBwb3J0ZWRMbmciLCJmYWxsYmFja3MiLCJkZWZhdWx0IiwiZmFsbGJhY2tDb2RlIiwiZmFsbGJhY2tDb2RlcyIsImFkZENvZGUiLCJmYyIsInNldHMiLCJuciIsIl9ydWxlc1BsdXJhbHNUeXBlcyIsIk51bWJlciIsIm5vbkludGxWZXJzaW9ucyIsImludGxWZXJzaW9ucyIsInN1ZmZpeGVzT3JkZXIiLCJ6ZXJvIiwib25lIiwidHdvIiwiZmV3IiwibWFueSIsIm90aGVyIiwiY3JlYXRlUnVsZXMiLCJydWxlcyIsIm51bWJlcnMiLCJwbHVyYWxzIiwiUGx1cmFsUmVzb2x2ZXIiLCJjb21wYXRpYmlsaXR5SlNPTiIsImluY2x1ZGVzIiwiUGx1cmFsUnVsZXMiLCJwbHVyYWxSdWxlc0NhY2hlIiwiYWRkUnVsZSIsImNsZWFyQ2FjaGUiLCJnZXRSdWxlIiwiY2xlYW5lZENvZGUiLCJjYWNoZUtleSIsInJ1bGUiLCJlcnIiLCJsbmdQYXJ0IiwibmVlZHNQbHVyYWwiLCJyZXNvbHZlZE9wdGlvbnMiLCJwbHVyYWxDYXRlZ29yaWVzIiwiZ2V0UGx1cmFsRm9ybXNPZktleSIsInNvcnQiLCJwbHVyYWxDYXRlZ29yeTEiLCJwbHVyYWxDYXRlZ29yeTIiLCJwbHVyYWxDYXRlZ29yeSIsInByZXBlbmQiLCJudW1iZXIiLCJzZWxlY3QiLCJnZXRTdWZmaXhSZXRyb0NvbXBhdGlibGUiLCJpZHgiLCJub0FicyIsIk1hdGgiLCJhYnMiLCJzaW1wbGlmeVBsdXJhbFN1ZmZpeCIsInJldHVyblN1ZmZpeCIsImRlZXBGaW5kV2l0aERlZmF1bHRzIiwicmVnZXhTYWZlIiwidmFsIiwiSW50ZXJwb2xhdG9yIiwiZm9ybWF0IiwiZXNjYXBlVmFsdWUiLCJlc2NhcGUkMSIsInVzZVJhd1ZhbHVlVG9Fc2NhcGUiLCJwcmVmaXhFc2NhcGVkIiwic3VmZml4RXNjYXBlZCIsImZvcm1hdFNlcGFyYXRvciIsInVuZXNjYXBlU3VmZml4IiwidW5lc2NhcGVQcmVmaXgiLCJuZXN0aW5nUHJlZml4IiwibmVzdGluZ1ByZWZpeEVzY2FwZWQiLCJuZXN0aW5nU3VmZml4IiwibmVzdGluZ1N1ZmZpeEVzY2FwZWQiLCJuZXN0aW5nT3B0aW9uc1NlcGFyYXRvciIsIm1heFJlcGxhY2VzIiwiYWx3YXlzRm9ybWF0IiwicmVzZXRSZWdFeHAiLCJnZXRPclJlc2V0UmVnRXhwIiwiZXhpc3RpbmdSZWdFeHAiLCJsYXN0SW5kZXgiLCJyZWdleHAiLCJyZWdleHBVbmVzY2FwZSIsInJlcGxhY2VzIiwiaGFuZGxlRm9ybWF0IiwiaW50ZXJwb2xhdGlvbmtleSIsInRyaW0iLCJmIiwibWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyIiwidG9kb3MiLCJyZWdleCIsInNhZmVWYWx1ZSIsInRvZG8iLCJleGVjIiwibWF0Y2hlZFZhciIsInRlbXAiLCJjbG9uZWRPcHRpb25zIiwiaGFuZGxlSGFzT3B0aW9ucyIsImluaGVyaXRlZE9wdGlvbnMiLCJzZXAiLCJvcHRpb25zU3RyaW5nIiwibWF0Y2hlZFNpbmdsZVF1b3RlcyIsIm1hdGNoZWREb3VibGVRdW90ZXMiLCJmb3JtYXR0ZXJzIiwiZG9SZWR1Y2UiLCJlbGVtIiwicmVkdWNlIiwicGFyc2VGb3JtYXRTdHIiLCJmb3JtYXRTdHIiLCJmb3JtYXROYW1lIiwiZm9ybWF0T3B0aW9ucyIsIm9wdFN0ciIsImN1cnJlbmN5IiwicmFuZ2UiLCJvcHRzIiwib3B0IiwicmVzdCIsInRyaW1tZWRLZXkiLCJpc05hTiIsInBhcnNlSW50IiwiY3JlYXRlQ2FjaGVkRm9ybWF0dGVyIiwiZm4iLCJjYWNoZSIsIm9wdEZvckNhY2hlIiwiZm9ybWF0UGFyYW1zIiwiZm9ybWF0dGVyIiwiRm9ybWF0dGVyIiwiZm9ybWF0cyIsIk51bWJlckZvcm1hdCIsInN0eWxlIiwiZGF0ZXRpbWUiLCJEYXRlVGltZUZvcm1hdCIsInJlbGF0aXZldGltZSIsIlJlbGF0aXZlVGltZUZvcm1hdCIsImxpc3QiLCJMaXN0Rm9ybWF0IiwiYWRkIiwiYWRkQ2FjaGVkIiwiZmluZEluZGV4IiwibWVtIiwiZm9ybWF0dGVkIiwidmFsT3B0aW9ucyIsImxvY2FsZSIsInJlbW92ZVBlbmRpbmciLCJxIiwicGVuZGluZyIsInBlbmRpbmdDb3VudCIsIkNvbm5lY3RvciIsImJhY2tlbmQiLCJzdG9yZSIsIndhaXRpbmdSZWFkcyIsIm1heFBhcmFsbGVsUmVhZHMiLCJyZWFkaW5nQ2FsbHMiLCJtYXhSZXRyaWVzIiwicmV0cnlUaW1lb3V0Iiwic3RhdGUiLCJxdWV1ZSIsInF1ZXVlTG9hZCIsImxhbmd1YWdlcyIsImNhbGxiYWNrIiwidG9Mb2FkIiwidG9Mb2FkTGFuZ3VhZ2VzIiwidG9Mb2FkTmFtZXNwYWNlcyIsImhhc0FsbE5hbWVzcGFjZXMiLCJyZWxvYWQiLCJsb2FkZWQiLCJlcnJvcnMiLCJkb25lIiwibG9hZGVkS2V5cyIsInJlYWQiLCJmY05hbWUiLCJ0cmllZCIsIndhaXQiLCJyZXNvbHZlciIsInNldFRpbWVvdXQiLCJiaW5kIiwidGhlbiIsImNhdGNoIiwicHJlcGFyZUxvYWRpbmciLCJsb2FkT25lIiwiZmFsbGJhY2tWYWx1ZSIsImlzVXBkYXRlIiwiY2xiIiwiaW5pdEltbWVkaWF0ZSIsInByZWxvYWQiLCJwYXJ0aWFsQnVuZGxlZExhbmd1YWdlcyIsInJldCIsInREZXNjcmlwdGlvbiIsInRyYW5zZm9ybU9wdGlvbnMiLCJub29wIiwiYmluZE1lbWJlckZ1bmN0aW9ucyIsImluc3QiLCJtZW1zIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldFByb3RvdHlwZU9mIiwiSTE4biIsIm1vZHVsZXMiLCJleHRlcm5hbCIsImlzSW5pdGlhbGl6ZWQiLCJpc0Nsb25lIiwiaXNJbml0aWFsaXppbmciLCJkZWZPcHRzIiwiY3JlYXRlQ2xhc3NPbkRlbWFuZCIsIkNsYXNzT3JPYmplY3QiLCJsdSIsImxhbmd1YWdlRGV0ZWN0b3IiLCJkZXRlY3Rpb24iLCJzdG9yZUFwaSIsInN0b3JlQXBpQ2hhaW5lZCIsImRlZmVycmVkIiwiZmluaXNoIiwiaW5pdGlhbGl6ZWRTdG9yZU9uY2UiLCJsb2FkUmVzb3VyY2VzIiwidXNlZENhbGxiYWNrIiwiYXBwZW5kIiwicmVzb2x2ZWRMYW5ndWFnZSIsInNldFJlc29sdmVkTGFuZ3VhZ2UiLCJyZWxvYWRSZXNvdXJjZXMiLCJ1c2UiLCJFcnJvciIsImxpIiwibG5nSW5MbmdzIiwiX3RoaXMyIiwiaXNMYW5ndWFnZUNoYW5naW5nVG8iLCJzZXRMbmdQcm9wcyIsInNldExuZyIsImNhY2hlVXNlckxhbmd1YWdlIiwiYXN5bmMiLCJkZXRlY3QiLCJnZXRGaXhlZFQiLCJrZXlQcmVmaXgiLCJfdGhpczMiLCJmaXhlZFQiLCJyZXN1bHRLZXkiLCJzZXREZWZhdWx0TmFtZXNwYWNlIiwibGFzdExuZyIsImxvYWROb3RQZW5kaW5nIiwibG9hZFN0YXRlIiwicHJlY2hlY2siLCJwcmVSZXN1bHQiLCJsb2FkTmFtZXNwYWNlcyIsImxvYWRMYW5ndWFnZXMiLCJwcmVsb2FkZWQiLCJuZXdMbmdzIiwiZGlyIiwicnRsTG5ncyIsImNyZWF0ZUluc3RhbmNlIiwiY2xvbmVJbnN0YW5jZSIsImZvcmtSZXNvdXJjZVN0b3JlIiwibWVyZ2VkT3B0aW9ucyIsIm1lbWJlcnNUb0NvcHkiLCJpbnN0YW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/i18next/dist/esm/i18next.js\n");

/***/ })

};
;