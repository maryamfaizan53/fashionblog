"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror";
exports.ids = ["vendor-chunks/@codemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompletionContext: () => (/* binding */ CompletionContext),\n/* harmony export */   acceptCompletion: () => (/* binding */ acceptCompletion),\n/* harmony export */   autocompletion: () => (/* binding */ autocompletion),\n/* harmony export */   clearSnippet: () => (/* binding */ clearSnippet),\n/* harmony export */   closeBrackets: () => (/* binding */ closeBrackets),\n/* harmony export */   closeBracketsKeymap: () => (/* binding */ closeBracketsKeymap),\n/* harmony export */   closeCompletion: () => (/* binding */ closeCompletion),\n/* harmony export */   completeAnyWord: () => (/* binding */ completeAnyWord),\n/* harmony export */   completeFromList: () => (/* binding */ completeFromList),\n/* harmony export */   completionKeymap: () => (/* binding */ completionKeymap),\n/* harmony export */   completionStatus: () => (/* binding */ completionStatus),\n/* harmony export */   currentCompletions: () => (/* binding */ currentCompletions),\n/* harmony export */   deleteBracketPair: () => (/* binding */ deleteBracketPair),\n/* harmony export */   hasNextSnippetField: () => (/* binding */ hasNextSnippetField),\n/* harmony export */   hasPrevSnippetField: () => (/* binding */ hasPrevSnippetField),\n/* harmony export */   ifIn: () => (/* binding */ ifIn),\n/* harmony export */   ifNotIn: () => (/* binding */ ifNotIn),\n/* harmony export */   insertBracket: () => (/* binding */ insertBracket),\n/* harmony export */   insertCompletionText: () => (/* binding */ insertCompletionText),\n/* harmony export */   moveCompletionSelection: () => (/* binding */ moveCompletionSelection),\n/* harmony export */   nextSnippetField: () => (/* binding */ nextSnippetField),\n/* harmony export */   pickedCompletion: () => (/* binding */ pickedCompletion),\n/* harmony export */   prevSnippetField: () => (/* binding */ prevSnippetField),\n/* harmony export */   selectedCompletion: () => (/* binding */ selectedCompletion),\n/* harmony export */   selectedCompletionIndex: () => (/* binding */ selectedCompletionIndex),\n/* harmony export */   setSelectedCompletion: () => (/* binding */ setSelectedCompletion),\n/* harmony export */   snippet: () => (/* binding */ snippet),\n/* harmony export */   snippetCompletion: () => (/* binding */ snippetCompletion),\n/* harmony export */   snippetKeymap: () => (/* binding */ snippetKeymap),\n/* harmony export */   startCompletion: () => (/* binding */ startCompletion)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n\n\n\n/**\nAn instance of this is passed to completion source functions.\n*/ class CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sources—in the editor, the extension will create\n    these for you.)\n    */ constructor(/**\n    The editor state that the completion happens in.\n    */ state, /**\n    The position at which the completion is happening.\n    */ pos, /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */ explicit){\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        /**\n        @internal\n        */ this.abortListeners = [];\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */ tokenBefore(types) {\n        let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\n        while(token && types.indexOf(token.name) < 0)token = token.parent;\n        return token ? {\n            from: token.from,\n            to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type\n        } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */ matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : {\n            from: start + found,\n            to: this.pos,\n            text: str.slice(found)\n        };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */ get aborted() {\n        return this.abortListeners == null;\n    }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    */ addEventListener(type, listener) {\n        if (type == \"abort\" && this.abortListeners) this.abortListeners.push(listener);\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words) flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options){\n        first[label[0]] = true;\n        for(let i = 1; i < label.length; i++)rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [\n        new RegExp(\"^\" + source),\n        new RegExp(source)\n    ];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/ function completeFromList(list) {\n    let options = list.map((o)=>typeof o == \"string\" ? {\n            label: o\n        } : o);\n    let [validFor, match] = options.every((o)=>/^\\w+$/.test(o.label)) ? [\n        /\\w*$/,\n        /\\w+$/\n    ] : prefixMatch(options);\n    return (context)=>{\n        let token = context.matchBefore(match);\n        return token || context.explicit ? {\n            from: token ? token.from : context.pos,\n            options,\n            validFor\n        } : null;\n    };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return source(context);\n            if (pos.type.isTop) break;\n        }\n        return null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifNotIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return null;\n            if (pos.type.isTop) break;\n        }\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match, score){\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n        this.score = score;\n    }\n}\nfunction cur(state) {\n    return state.selection.main.from;\n}\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd) return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/ const pickedCompletion = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/ function insertCompletionText(state, text, from, to) {\n    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;\n    return Object.assign(Object.assign({}, state.changeByRange((range)=>{\n        if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to)) return {\n            range\n        };\n        return {\n            changes: {\n                from: range.from + fromOff,\n                to: to == main.from ? range.to : range.from + toOff,\n                insert: text\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + fromOff + text.length)\n        };\n    })), {\n        scrollIntoView: true,\n        userEvent: \"input.complete\"\n    });\n}\nconst SourceCache = /*@__PURE__*/ new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source)) return source;\n    let known = SourceCache.get(source);\n    if (!known) SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\nconst startCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern){\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        this.score = 0;\n        this.matched = [];\n        for(let p = 0; p < pattern.length;){\n            let char = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p), size = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    ret(score, matched) {\n        this.score = score;\n        this.matched = matched;\n        return true;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return a boolean indicating whether there was a match and,\n    // on success, set `this.score` to the score, `this.matched` to an\n    // array of `from, to` pairs indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0) return this.ret(-100 /* Penalty.NotFull */ , []);\n        if (word.length < this.pattern.length) return false;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0), firstSize = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first);\n            let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */ ;\n            if (first == chars[0]) ;\n            else if (first == folded[0]) score += -200 /* Penalty.CaseFold */ ;\n            else return false;\n            return this.ret(score, [\n                0,\n                firstSize\n            ]);\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0) return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */ , [\n            0,\n            this.pattern.length\n        ]);\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for(let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;){\n                let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n                i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len) return false;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word), wordAdjacent = true;\n        // Go over the option's text, scanning for the various kinds of matches\n        for(let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */ ; i < e && byWordTo < len;){\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0) adjacentStart = i;\n                        adjacentEnd = i + 1;\n                        adjacentTo++;\n                    } else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */  : next >= 65 && next <= 90 ? 1 /* Tp.Upper */  : 0 /* Tp.NonWord */  : (ch = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */  : ch != ch.toUpperCase() ? 2 /* Tp.Lower */  : 0 /* Tp.NonWord */ ;\n            if (!i || type == 1 /* Tp.Upper */  && hasLower || prevType == 0 /* Tp.NonWord */  && type != 0 /* Tp.NonWord */ ) {\n                if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i;\n                else if (byWord.length) wordAdjacent = false;\n            }\n            prevType = type;\n            i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n        }\n        if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0) return this.ret(-200 /* Penalty.CaseFold */  - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */ ), [\n            0,\n            adjacentEnd\n        ]);\n        if (direct > -1) return this.ret(-700 /* Penalty.NotStart */  - word.length, [\n            direct,\n            direct + this.pattern.length\n        ]);\n        if (adjacentTo == len) return this.ret(-200 /* Penalty.CaseFold */  + -700 /* Penalty.NotStart */  - word.length, [\n            adjacentStart,\n            adjacentEnd\n        ]);\n        if (byWordTo == len) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0) + -700 /* Penalty.NotStart */  + (wordAdjacent ? 0 : -1100 /* Penalty.Gap */ ), byWord, word);\n        return chars.length == 2 ? false : this.result((any[0] ? -700 /* Penalty.NotStart */  : 0) + -200 /* Penalty.CaseFold */  + -1100 /* Penalty.Gap */ , any, word);\n    }\n    result(score, positions, word) {\n        let result = [], i = 0;\n        for (let pos of positions){\n            let to = pos + (this.astral ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);\n            if (i && result[i - 1] == pos) result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return this.ret(score - word.length, result);\n    }\n}\nconst completionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            activateOnTyping: true,\n            activateOnTypingDelay: 100,\n            selectOnOpen: true,\n            override: null,\n            closeOnBlur: true,\n            maxRenderedOptions: 100,\n            defaultKeymap: true,\n            tooltipClass: ()=>\"\",\n            optionClass: ()=>\"\",\n            aboveCursor: false,\n            icons: true,\n            addToOptions: [],\n            positionInfo: defaultPositionInfo,\n            compareCompletions: (a, b)=>a.label.localeCompare(b.label),\n            interactionDelay: 75,\n            updateSyncTime: 100\n        }, {\n            defaultKeymap: (a, b)=>a && b,\n            closeOnBlur: (a, b)=>a && b,\n            icons: (a, b)=>a && b,\n            tooltipClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            optionClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            addToOptions: (a, b)=>a.concat(b)\n        });\n    }\n});\nfunction joinClass(a, b) {\n    return a ? b ? a + \" \" + b : a : b;\n}\nfunction defaultPositionInfo(view, list, option, info, space, tooltip) {\n    let rtl = view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.RTL, left = rtl, narrow = false;\n    let side = \"top\", offset, maxWidth;\n    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;\n    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;\n    if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false;\n    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true;\n    if (infoWidth <= (left ? spaceLeft : spaceRight)) {\n        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;\n        maxWidth = Math.min(400 /* Info.Width */ , left ? spaceLeft : spaceRight);\n    } else {\n        narrow = true;\n        maxWidth = Math.min(400 /* Info.Width */ , (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */ );\n        let spaceBelow = space.bottom - list.bottom;\n        if (spaceBelow >= infoHeight || spaceBelow > list.top) {\n            offset = option.bottom - list.top;\n        } else {\n            side = \"bottom\";\n            offset = list.bottom - option.top;\n        }\n    }\n    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;\n    let scaleX = (list.right - list.left) / tooltip.offsetWidth;\n    return {\n        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,\n        class: \"cm-completionInfo-\" + (narrow ? rtl ? \"left-narrow\" : \"right-narrow\" : left ? \"left\" : \"right\")\n    };\n}\nfunction optionContent(config) {\n    let content = config.addToOptions.slice();\n    if (config.icons) content.push({\n        render (completion) {\n            let icon = document.createElement(\"div\");\n            icon.classList.add(\"cm-completionIcon\");\n            if (completion.type) icon.classList.add(...completion.type.split(/\\s+/g).map((cls)=>\"cm-completionIcon-\" + cls));\n            icon.setAttribute(\"aria-hidden\", \"true\");\n            return icon;\n        },\n        position: 20\n    });\n    content.push({\n        render (completion, _s, _v, match) {\n            let labelElt = document.createElement(\"span\");\n            labelElt.className = \"cm-completionLabel\";\n            let label = completion.displayLabel || completion.label, off = 0;\n            for(let j = 0; j < match.length;){\n                let from = match[j++], to = match[j++];\n                if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n                let span = labelElt.appendChild(document.createElement(\"span\"));\n                span.appendChild(document.createTextNode(label.slice(from, to)));\n                span.className = \"cm-completionMatchedText\";\n                off = to;\n            }\n            if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n            return labelElt;\n        },\n        position: 50\n    }, {\n        render (completion) {\n            if (!completion.detail) return null;\n            let detailElt = document.createElement(\"span\");\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = completion.detail;\n            return detailElt;\n        },\n        position: 80\n    });\n    return content.sort((a, b)=>a.position - b.position).map((a)=>a.render);\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max) return {\n        from: 0,\n        to: total\n    };\n    if (selected < 0) selected = 0;\n    if (selected <= total >> 1) {\n        let off = Math.floor(selected / max);\n        return {\n            from: off * max,\n            to: (off + 1) * max\n        };\n    }\n    let off = Math.floor((total - selected) / max);\n    return {\n        from: total - (off + 1) * max,\n        to: total - off * max\n    };\n}\nclass CompletionTooltip {\n    constructor(view, stateField, applyCompletion){\n        this.view = view;\n        this.stateField = stateField;\n        this.applyCompletion = applyCompletion;\n        this.info = null;\n        this.infoDestroy = null;\n        this.placeInfoReq = {\n            read: ()=>this.measureInfo(),\n            write: (pos)=>this.placeInfo(pos),\n            key: this\n        };\n        this.space = null;\n        this.currentClass = \"\";\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.optionContent = optionContent(config);\n        this.optionClass = config.optionClass;\n        this.tooltipClass = config.tooltipClass;\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.updateTooltipClass(view.state);\n        this.dom.addEventListener(\"mousedown\", (e)=>{\n            let { options } = view.state.field(stateField).open;\n            for(let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode){\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    this.applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.dom.addEventListener(\"focusout\", (e)=>{\n            let state = view.state.field(this.stateField, false);\n            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM) view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n        });\n        this.showOptions(options, cState.id);\n    }\n    mount() {\n        this.updateSel();\n    }\n    showOptions(options, id) {\n        if (this.list) this.list.remove();\n        this.list = this.dom.appendChild(this.createListBox(options, id, this.range));\n        this.list.addEventListener(\"scroll\", ()=>{\n            if (this.info) this.view.requestMeasure(this.placeInfoReq);\n        });\n    }\n    update(update) {\n        var _a;\n        let cState = update.state.field(this.stateField);\n        let prevState = update.startState.field(this.stateField);\n        this.updateTooltipClass(update.state);\n        if (cState != prevState) {\n            let { options, selected, disabled } = cState.open;\n            if (!prevState.open || prevState.open.options != options) {\n                this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);\n                this.showOptions(options, cState.id);\n            }\n            this.updateSel();\n            if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled)) this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!disabled);\n        }\n    }\n    updateTooltipClass(state) {\n        let cls = this.tooltipClass(state);\n        if (cls != this.currentClass) {\n            for (let c of this.currentClass.split(\" \"))if (c) this.dom.classList.remove(c);\n            for (let c of cls.split(\" \"))if (c) this.dom.classList.add(c);\n            this.currentClass = cls;\n        }\n    }\n    positioned(space) {\n        this.space = space;\n        if (this.info) this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.showOptions(open.options, cState.id);\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            this.destroyInfo();\n            let { completion } = open.options[open.selected];\n            let { info } = completion;\n            if (!info) return;\n            let infoResult = typeof info === \"string\" ? document.createTextNode(info) : info(completion);\n            if (!infoResult) return;\n            if (\"then\" in infoResult) {\n                infoResult.then((obj)=>{\n                    if (obj && this.view.state.field(this.stateField, false) == cState) this.addInfoPane(obj, completion);\n                }).catch((e)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e, \"completion info\"));\n            } else {\n                this.addInfoPane(infoResult, completion);\n            }\n        }\n    }\n    addInfoPane(content, completion) {\n        this.destroyInfo();\n        let wrap = this.info = document.createElement(\"div\");\n        wrap.className = \"cm-tooltip cm-completionInfo\";\n        if (content.nodeType != null) {\n            wrap.appendChild(content);\n            this.infoDestroy = null;\n        } else {\n            let { dom, destroy } = content;\n            wrap.appendChild(dom);\n            this.infoDestroy = destroy || null;\n        }\n        this.dom.appendChild(wrap);\n        this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for(let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++){\n            if (opt.nodeName != \"LI\" || !opt.id) {\n                i--; // A section header\n            } else if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            } else {\n                if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set) scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel || !this.info) return null;\n        let listRect = this.dom.getBoundingClientRect();\n        let infoRect = this.info.getBoundingClientRect();\n        let selRect = sel.getBoundingClientRect();\n        let space = this.space;\n        if (!space) {\n            let win = this.dom.ownerDocument.defaultView || window;\n            space = {\n                left: 0,\n                top: 0,\n                right: win.innerWidth,\n                bottom: win.innerHeight\n            };\n        }\n        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;\n        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);\n    }\n    placeInfo(pos) {\n        if (this.info) {\n            if (pos) {\n                if (pos.style) this.info.style.cssText = pos.style;\n                this.info.className = \"cm-tooltip cm-completionInfo \" + (pos.class || \"\");\n            } else {\n                this.info.style.cssText = \"top: -1e6px\";\n            }\n        }\n    }\n    createListBox(options, id, range) {\n        const ul = document.createElement(\"ul\");\n        ul.id = id;\n        ul.setAttribute(\"role\", \"listbox\");\n        ul.setAttribute(\"aria-expanded\", \"true\");\n        ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n        let curSection = null;\n        for(let i = range.from; i < range.to; i++){\n            let { completion, match } = options[i], { section } = completion;\n            if (section) {\n                let name = typeof section == \"string\" ? section : section.name;\n                if (name != curSection && (i > range.from || range.from == 0)) {\n                    curSection = name;\n                    if (typeof section != \"string\" && section.header) {\n                        ul.appendChild(section.header(section));\n                    } else {\n                        let header = ul.appendChild(document.createElement(\"completion-section\"));\n                        header.textContent = name;\n                    }\n                }\n            }\n            const li = ul.appendChild(document.createElement(\"li\"));\n            li.id = id + \"-\" + i;\n            li.setAttribute(\"role\", \"option\");\n            let cls = this.optionClass(completion);\n            if (cls) li.className = cls;\n            for (let source of this.optionContent){\n                let node = source(completion, this.view.state, this.view, match);\n                if (node) li.appendChild(node);\n            }\n        }\n        if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n        if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n        return ul;\n    }\n    destroyInfo() {\n        if (this.info) {\n            if (this.infoDestroy) this.infoDestroy();\n            this.info.remove();\n            this.info = null;\n        }\n    }\n    destroy() {\n        this.destroyInfo();\n    }\n}\nfunction completionTooltip(stateField, applyCompletion) {\n    return (view)=>new CompletionTooltip(view, stateField, applyCompletion);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    let scaleY = parent.height / container.offsetHeight;\n    if (self.top < parent.top) container.scrollTop -= (parent.top - self.top) / scaleY;\n    else if (self.bottom > parent.bottom) container.scrollTop += (self.bottom - parent.bottom) / scaleY;\n}\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    let sections = null;\n    let addOption = (option)=>{\n        options.push(option);\n        let { section } = option.completion;\n        if (section) {\n            if (!sections) sections = [];\n            let name = typeof section == \"string\" ? section : section.name;\n            if (!sections.some((s)=>s.name == name)) sections.push(typeof section == \"string\" ? {\n                name\n            } : section);\n        }\n    };\n    for (let a of active)if (a.hasResult()) {\n        let getMatch = a.result.getMatch;\n        if (a.result.filter === false) {\n            for (let option of a.result.options){\n                addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));\n            }\n        } else {\n            let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to));\n            for (let option of a.result.options)if (matcher.match(option.label)) {\n                let matched = !option.displayLabel ? matcher.matched : getMatch ? getMatch(option, matcher.matched) : [];\n                addOption(new Option(option, a.source, matched, matcher.score + (option.boost || 0)));\n            }\n        }\n    }\n    if (sections) {\n        let sectionOrder = Object.create(null), pos = 0;\n        let cmp = (a, b)=>{\n            var _a, _b;\n            return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1);\n        };\n        for (let s of sections.sort(cmp)){\n            pos -= 1e5;\n            sectionOrder[s.name] = pos;\n        }\n        for (let option of options){\n            let { section } = option.completion;\n            if (section) option.score += sectionOrder[typeof section == \"string\" ? section : section.name];\n        }\n    }\n    let result = [], prev = null;\n    let compare = state.facet(completionConfig).compareCompletions;\n    for (let opt of options.sort((a, b)=>b.score - a.score || compare(a.completion, b.completion))){\n        let cur = opt.completion;\n        if (!prev || prev.label != cur.label || prev.detail != cur.detail || prev.type != null && cur.type != null && prev.type != cur.type || prev.apply != cur.apply || prev.boost != cur.boost) result.push(opt);\n        else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected, disabled){\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n        this.disabled = disabled;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n    }\n    static build(active, state, id, prev, conf) {\n        let options = sortOptions(active, state);\n        if (!options.length) {\n            return prev && active.some((a)=>a.state == 1 /* State.Pending */ ) ? new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;\n        }\n        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n        if (prev && prev.selected != selected && prev.selected != -1) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for(let i = 0; i < options.length; i++)if (options[i].completion == selectedValue) {\n                selected = i;\n                break;\n            }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b)=>b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: createTooltip,\n            above: conf.aboveCursor\n        }, prev ? prev.timestamp : Date.now(), selected, false);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n            pos: changes.mapPos(this.tooltip.pos)\n        }), this.timestamp, this.selected, this.disabled);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open){\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map((source)=>{\n            let value = this.active.find((s)=>s.source == source) || new ActiveSource(source, this.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i)=>a == this.active[i])) active = this.active;\n        let open = this.open;\n        if (open && tr.docChanged) open = open.map(tr.changes);\n        if (tr.selection || active.some((a)=>a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active)) open = CompletionDialog.build(active, state, this.id, open, conf);\n        else if (open && open.disabled && !active.some((a)=>a.state == 1 /* State.Pending */ )) open = null;\n        if (!open && active.every((a)=>a.state != 1 /* State.Pending */ ) && active.some((a)=>a.hasResult())) active = active.map((a)=>a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */ ) : a);\n        for (let effect of tr.effects)if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() {\n        return this.open ? this.open.tooltip : null;\n    }\n    get attrs() {\n        return this.open ? this.open.attrs : baseAttrs;\n    }\n}\nfunction sameResults(a, b) {\n    if (a == b) return true;\n    for(let iA = 0, iB = 0;;){\n        while(iA < a.length && !a[iA].hasResult)iA++;\n        while(iB < b.length && !b[iB].hasResult)iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB) return endA == endB;\n        if (a[iA++].result != b[iB++].result) return false;\n    }\n}\nconst baseAttrs = {\n    \"aria-autocomplete\": \"list\"\n};\nfunction makeAttrs(id, selected) {\n    let result = {\n        \"aria-autocomplete\": \"list\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-controls\": id\n    };\n    if (selected > -1) result[\"aria-activedescendant\"] = id + \"-\" + selected;\n    return result;\n}\nconst none = [];\nfunction getUserEvent(tr) {\n    return tr.isUserEvent(\"input.type\") ? \"input\" : tr.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\nclass ActiveSource {\n    constructor(source, state, explicitPos = -1){\n        this.source = source;\n        this.state = state;\n        this.explicitPos = explicitPos;\n    }\n    hasResult() {\n        return false;\n    }\n    update(tr, conf) {\n        let event = getUserEvent(tr), value = this;\n        if (event) value = value.handleUserEvent(tr, event, conf);\n        else if (tr.docChanged) value = value.handleChange(tr);\n        else if (tr.selection && value.state != 0 /* State.Inactive */ ) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n        for (let effect of tr.effects){\n            if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1 /* State.Pending */ , effect.value ? cur(tr.state) : -1);\n            else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n            else if (effect.is(setActiveEffect)) {\n                for (let active of effect.value)if (active.source == value.source) value = active;\n            }\n        }\n        return value;\n    }\n    handleUserEvent(tr, type, conf) {\n        return type == \"delete\" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* State.Pending */ );\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* State.Inactive */ ) : this.map(tr.changes);\n    }\n    map(changes) {\n        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicitPos, result, from, to){\n        super(source, 2 /* State.Result */ , explicitPos);\n        this.result = result;\n        this.from = from;\n        this.to = to;\n    }\n    hasResult() {\n        return true;\n    }\n    handleUserEvent(tr, type, conf) {\n        var _a;\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == \"delete\" && cur(tr.startState) == this.from) return new ActiveSource(this.source, type == \"input\" && conf.activateOnTyping ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n        let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;\n        if (checkValid(this.result.validFor, tr.state, from, to)) return new ActiveResult(this.source, explicitPos, this.result, from, to);\n        if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0)))) return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n        return new ActiveSource(this.source, 1 /* State.Pending */ , explicitPos);\n    }\n    handleChange(tr) {\n        return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* State.Inactive */ ) : this.map(tr.changes);\n    }\n    map(mapping) {\n        return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n}\nfunction checkValid(validFor, state, from, to) {\n    if (!validFor) return false;\n    let text = state.sliceDoc(from, to);\n    return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\nconst setActiveEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (sources, mapping) {\n        return sources.map((s)=>s.map(mapping));\n    }\n});\nconst setSelectedEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst completionState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return CompletionState.start();\n    },\n    update (value, tr) {\n        return value.update(tr);\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(f, (val)=>val.tooltip),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.contentAttributes.from(f, (state)=>state.attrs)\n        ]\n});\nfunction applyCompletion(view, option) {\n    const apply = option.completion.apply || option.completion.label;\n    let result = view.state.field(completionState).active.find((a)=>a.source == option.source);\n    if (!(result instanceof ActiveResult)) return false;\n    if (typeof apply == \"string\") view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {\n        annotations: pickedCompletion.of(option.completion)\n    }));\n    else apply(view, option.completion, result.from, result.to);\n    return true;\n}\nconst createTooltip = /*@__PURE__*/ completionTooltip(completionState, applyCompletion);\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/ function moveCompletionSelection(forward, by = \"option\") {\n    return (view)=>{\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n        let { length } = cState.open.options;\n        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n        if (selected < 0) selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({\n            effects: setSelectedEffect.of(selected)\n        });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/ const acceptCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n    return applyCompletion(view, cState.open.options[cState.open.selected]);\n};\n/**\nExplicitly start autocompletion.\n*/ const startCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState) return false;\n    view.dispatch({\n        effects: startCompletionEffect.of(true)\n    });\n    return true;\n};\n/**\nClose the currently active completion.\n*/ const closeCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some((a)=>a.state != 0 /* State.Inactive */ )) return false;\n    view.dispatch({\n        effects: closeCompletionEffect.of(null)\n    });\n    return true;\n};\nclass RunningQuery {\n    constructor(active, context){\n        this.active = active;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.pendingStart = false;\n        this.composing = 0 /* CompositionState.None */ ;\n        for (let active of view.state.field(completionState).active)if (active.state == 1 /* State.Pending */ ) this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;\n        let doesReset = update.transactions.some((tr)=>{\n            return (tr.selection || tr.docChanged) && !getUserEvent(tr);\n        });\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n                for (let handler of query.context.abortListeners){\n                    try {\n                        handler();\n                    } catch (e) {\n                        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            } else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n        if (update.transactions.some((tr)=>tr.effects.some((e)=>e.is(startCompletionEffect)))) this.pendingStart = true;\n        let delay = this.pendingStart ? 50 : update.state.facet(completionConfig).activateOnTypingDelay;\n        this.debounceUpdate = cState.active.some((a)=>a.state == 1 /* State.Pending */  && !this.running.some((q)=>q.active.source == a.source)) ? setTimeout(()=>this.startUpdate(), delay) : -1;\n        if (this.composing != 0 /* CompositionState.None */ ) for (let tr of update.transactions){\n            if (getUserEvent(tr) == \"input\") this.composing = 2 /* CompositionState.Changed */ ;\n            else if (this.composing == 2 /* CompositionState.Changed */  && tr.selection) this.composing = 3 /* CompositionState.ChangedAndMoved */ ;\n        }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        this.pendingStart = false;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active){\n            if (active.state == 1 /* State.Pending */  && !this.running.some((r)=>r.active.source == active.source)) this.startQuery(active);\n        }\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicitPos == pos);\n        let pending = new RunningQuery(active, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then((result)=>{\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, (err)=>{\n            this.view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every((q)=>q.done !== undefined)) this.accept();\n        else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(()=>this.accept(), this.view.state.facet(completionConfig).updateSyncTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig);\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (query.done === undefined) continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = this.view.state.field(completionState).active.find((a)=>a.source == query.active.source);\n            if (current && current.state == 1 /* State.Pending */ ) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.active.source, 0 /* State.Inactive */ );\n                    for (let tr of query.updates)active = active.update(tr, conf);\n                    if (active.state != 1 /* State.Pending */ ) updated.push(active);\n                } else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length) this.view.dispatch({\n            effects: setActiveEffect.of(updated)\n        });\n    }\n}, {\n    eventHandlers: {\n        blur (event) {\n            let state = this.view.state.field(completionState, false);\n            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {\n                let dialog = state.open && (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(this.view, state.open.tooltip);\n                if (!dialog || !dialog.dom.contains(event.relatedTarget)) setTimeout(()=>this.view.dispatch({\n                        effects: closeCompletionEffect.of(null)\n                    }), 10);\n            }\n        },\n        compositionstart () {\n            this.composing = 1 /* CompositionState.Started */ ;\n        },\n        compositionend () {\n            if (this.composing == 3 /* CompositionState.ChangedAndMoved */ ) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(()=>this.view.dispatch({\n                        effects: startCompletionEffect.of(false)\n                    }), 20);\n            }\n            this.composing = 0 /* CompositionState.None */ ;\n        }\n    }\n});\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            minWidth: \"250px\",\n            maxHeight: \"10em\",\n            height: \"100%\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li, & > completion-section\": {\n                padding: \"1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li\": {\n                overflowX: \"hidden\",\n                textOverflow: \"ellipsis\",\n                cursor: \"pointer\"\n            },\n            \"& > completion-section\": {\n                display: \"list-item\",\n                borderBottom: \"1px solid silver\",\n                paddingLeft: \"0.5em\",\n                opacity: 0.7\n            }\n        }\n    },\n    \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#17c\",\n        color: \"white\"\n    },\n    \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#777\"\n    },\n    \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#347\",\n        color: \"white\"\n    },\n    \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#444\"\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"\\xb7\\xb7\\xb7\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: `${400 /* Info.Width */ }px`,\n        boxSizing: \"border-box\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": {\n        right: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-right\": {\n        left: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left-narrow\": {\n        right: `${30 /* Info.Margin */ }px`\n    },\n    \".cm-completionInfo.cm-completionInfo-right-narrow\": {\n        left: `${30 /* Info.Margin */ }px`\n    },\n    \"&light .cm-snippetField\": {\n        backgroundColor: \"#00000022\"\n    },\n    \"&dark .cm-snippetField\": {\n        backgroundColor: \"#ffffff22\"\n    },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        display: \"inline-block\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\",\n        boxSizing: \"content-box\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": {\n            content: \"'ƒ'\"\n        }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": {\n            content: \"'○'\"\n        }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": {\n            content: \"'◌'\"\n        }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC65'\"\n        }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC36'\"\n        }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC61'\"\n        }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": {\n            content: \"'∪'\"\n        }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": {\n            content: \"'□'\"\n        }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": {\n            content: \"'\\uD83D\\uDD11︎'\"\n        } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": {\n            content: \"'▢'\"\n        }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": {\n            content: \"'abc'\",\n            fontSize: \"50%\",\n            verticalAlign: \"middle\"\n        }\n    }\n});\nclass FieldPos {\n    constructor(field, line, from, to){\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to){\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        let from = changes.mapPos(this.from, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        let to = changes.mapPos(this.to, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions){\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [\n            pos\n        ];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines){\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for(let i = 0; i < tabs; i++)indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map((pos)=>new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return {\n            text,\n            ranges\n        };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)){\n            while(m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(line)){\n                let seq = m[1] ? +m[1] : null, name = m[2] || m[3] || \"\", found = -1;\n                for(let i = 0; i < fields.length; i++){\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while(i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))i++;\n                    fields.splice(i, 0, {\n                        seq,\n                        name\n                    });\n                    found = i;\n                    for (let pos of positions)if (pos.field >= found) pos.field++;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);\n            }\n            for(let esc; esc = /\\\\([{}])/.exec(line);){\n                line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);\n                for (let pos of positions)if (pos.line == lines.length && pos.from > esc.index) {\n                    pos.from--;\n                    pos.to--;\n                }\n            }\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() {\n            return false;\n        }\n    }\n});\nlet fieldRange = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-snippetField\"\n});\nclass ActiveSnippet {\n    constructor(ranges, active){\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(ranges.map((r)=>(r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        let ranges = [];\n        for (let r of this.ranges){\n            let mapped = r.map(changes);\n            if (!mapped) return null;\n            ranges.push(mapped);\n        }\n        return new ActiveSnippet(ranges, this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every((range)=>this.ranges.some((r)=>r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, changes) {\n        return value && value.map(changes);\n    }\n});\nconst moveToField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst snippetState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return null;\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setActive)) return effect.value;\n            if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged) value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, (val)=>val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter((r)=>r.field == field).map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/ function snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, completion, from, to)=>{\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let spec = {\n            changes: {\n                from,\n                to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(text)\n            },\n            scrollIntoView: true,\n            annotations: completion ? [\n                pickedCompletion.of(completion),\n                _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent.of(\"input.complete\")\n            ] : undefined\n        };\n        if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n        if (ranges.some((r)=>r.field > 0)) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [\n                setActive.of(active)\n            ];\n            if (editor.state.field(snippetState, false) === undefined) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n                snippetState,\n                addSnippetKeymap,\n                snippetPointerHandler,\n                baseTheme\n            ]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch })=>{\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0) return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some((r)=>r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),\n            scrollIntoView: true\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/ const clearSnippet = ({ state, dispatch })=>{\n    let active = state.field(snippetState, false);\n    if (!active) return false;\n    dispatch(state.update({\n        effects: setActive.of(null)\n    }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/ const nextSnippetField = /*@__PURE__*/ moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/ const prevSnippetField = /*@__PURE__*/ moveField(-1);\n/**\nCheck if there is an active snippet with a next field for\n`nextSnippetField` to move to.\n*/ function hasNextSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.ranges.some((r)=>r.field == active.active + 1));\n}\n/**\nReturns true if there is an active snippet and a previous field\nfor `prevSnippetField` to move to.\n*/ function hasPrevSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.active > 0);\n}\nconst defaultSnippetKeymap = [\n    {\n        key: \"Tab\",\n        run: nextSnippetField,\n        shift: prevSnippetField\n    },\n    {\n        key: \"Escape\",\n        run: clearSnippet\n    }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/ const snippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (maps) {\n        return maps.length ? maps[0] : defaultSnippetKeymap;\n    }\n});\nconst addSnippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.compute([\n    snippetKeymap\n], (state)=>state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/ function snippetCompletion(template, completion) {\n    return Object.assign(Object.assign({}, completion), {\n        apply: snippet(template)\n    });\n}\nconst snippetPointerHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    mousedown (event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({\n            x: event.clientX,\n            y: event.clientY\n        })) == null) return false;\n        let match = active.ranges.find((r)=>r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active) return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some((r)=>r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),\n            scrollIntoView: true\n        });\n        return true;\n    }\n});\nfunction wordRE(wordChars) {\n    let escaped = wordChars.replace(/[\\]\\-\\\\]/g, \"\\\\$&\");\n    try {\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n    } catch (_a) {\n        return new RegExp(`[\\w${escaped}]`, \"g\");\n    }\n}\nfunction mapRE(re, f) {\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/ Object.create(null);\nfunction wordCache(wordChars) {\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n    for(let lines = doc.iterLines(), pos = 0; !lines.next().done;){\n        let { value } = lines, m;\n        wordRE.lastIndex = 0;\n        while(m = wordRE.exec(value)){\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\n                result.push({\n                    type: \"text\",\n                    label: m[0]\n                });\n                seen[m[0]] = true;\n                if (result.length >= 2000 /* C.MaxList */ ) return;\n            }\n        }\n        pos += value.length + 1;\n    }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n    let big = doc.length >= 1000 /* C.MinCacheLen */ ;\n    let cached = big && cache.get(doc);\n    if (cached) return cached;\n    let result = [], seen = Object.create(null);\n    if (doc.children) {\n        let pos = 0;\n        for (let ch of doc.children){\n            if (ch.length >= 1000 /* C.MinCacheLen */ ) {\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)){\n                    if (!seen[c.label]) {\n                        seen[c.label] = true;\n                        result.push(c);\n                    }\n                }\n            } else {\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n            }\n            pos += ch.length + 1;\n        }\n    } else {\n        storeWords(doc, wordRE, result, seen, ignoreAt);\n    }\n    if (big && result.length < 2000 /* C.MaxList */ ) cache.set(doc, result);\n    return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/ const completeAnyWord = (context)=>{\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n    let re = wordRE(wordChars);\n    let token = context.matchBefore(mapRE(re, (s)=>s + \"$\"));\n    if (!token && !context.explicit) return null;\n    let from = token ? token.from : context.pos;\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */ , from);\n    return {\n        from,\n        options,\n        validFor: mapRE(re, (s)=>\"^\" + s)\n    };\n};\nconst defaults = {\n    brackets: [\n        \"(\",\n        \"[\",\n        \"{\",\n        \"'\",\n        '\"'\n    ],\n    before: \")]}:;>\",\n    stringPrefixes: []\n};\nconst closeBracketEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, mapping) {\n        let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst closedBracket = /*@__PURE__*/ new class extends _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n    },\n    update (value, tr) {\n        value = value.map(tr.changes);\n        if (tr.selection) {\n            let line = tr.state.doc.lineAt(tr.selection.main.head);\n            value = value.update({\n                filter: (from)=>from >= line.from && from <= line.to\n            });\n        }\n        for (let effect of tr.effects)if (effect.is(closeBracketEffect)) value = value.update({\n            add: [\n                closedBracket.range(effect.value, effect.value + 1)\n            ]\n        });\n        return value;\n    }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/ function closeBrackets() {\n    return [\n        inputHandler,\n        bracketState\n    ];\n}\nconst definedClosing = \"()[]{}<>\";\nfunction closing(ch) {\n    for(let i = 0; i < definedClosing.length; i += 2)if (definedClosing.charCodeAt(i) == ch) return definedClosing.charAt(i + 1);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\nconst inputHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of((view, from, to, insert)=>{\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;\n    let tr = insertBracket(view.state, insert);\n    if (!tr) return false;\n    view.dispatch(tr);\n    return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/ const deleteBracketPair = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens){\n                if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(token, 0))) return {\n                    changes: {\n                        from: range.head - token.length,\n                        to: range.head + token.length\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head - token.length)\n                };\n            }\n        }\n        return {\n            range: dont = range\n        };\n    });\n    if (!dont) dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"delete.backward\"\n    }));\n    return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/ const closeBracketsKeymap = [\n    {\n        key: \"Backspace\",\n        run: deleteBracketPair\n    }\n];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert brackets—the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/ function insertBracket(state, bracket) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens){\n        let closed = closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(tok, 0));\n        if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, (from)=>{\n        if (from == pos) found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: open,\n                    from: range.from\n                },\n                {\n                    insert: close,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + open.length, range.head + open.length)\n        };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) return {\n            changes: {\n                insert: open + close,\n                from: range.head\n            },\n            effects: closeBracketEffect.of(range.head + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + open.length)\n        };\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty && nextChar(state.doc, range.head) == close) return {\n            changes: {\n                from: range.head,\n                to: range.head + close.length,\n                insert: close\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + close.length)\n        };\n        return dont = {\n            range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple, config) {\n    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: token,\n                    from: range.from\n                },\n                {\n                    insert: token,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + token.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + token.length, range.head + token.length)\n        };\n        let pos = range.head, next = nextChar(state.doc, pos), start;\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return {\n                    changes: {\n                        insert: token + token,\n                        from: pos\n                    },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n                };\n            } else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                let content = isTriple ? token + token + token : token;\n                return {\n                    changes: {\n                        from: pos,\n                        to: pos + content.length,\n                        insert: content\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + content.length)\n                };\n            }\n        } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {\n            return {\n                changes: {\n                    insert: token + token + token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        } else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {\n                changes: {\n                    insert: token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        }\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos + 1);\n    return tree.parent && tree.from == pos;\n}\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n    let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos, -1);\n    let maxPrefix = prefixes.reduce((m, p)=>Math.max(m, p.length), 0);\n    for(let i = 0; i < 5; i++){\n        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n        let quotePos = start.indexOf(quoteToken);\n        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n            let first = node.firstChild;\n            while(first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos){\n                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;\n                first = first.firstChild;\n            }\n            return true;\n        }\n        let parent = node.to == pos && node.parent;\n        if (!parent) break;\n        node = parent;\n    }\n    return false;\n}\nfunction canStartStringAt(state, pos, prefixes) {\n    let charCat = state.charCategorizer(pos);\n    if (charCat(state.sliceDoc(pos - 1, pos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return pos;\n    for (let prefix of prefixes){\n        let start = pos - prefix.length;\n        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return start;\n    }\n    return -1;\n}\n/**\nReturns an extension that enables autocompletion.\n*/ function autocompletion(config = {}) {\n    return [\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/ const completionKeymap = [\n    {\n        key: \"Ctrl-Space\",\n        run: startCompletion\n    },\n    {\n        key: \"Escape\",\n        run: closeCompletion\n    },\n    {\n        key: \"ArrowDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true)\n    },\n    {\n        key: \"ArrowUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false)\n    },\n    {\n        key: \"PageDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true, \"page\")\n    },\n    {\n        key: \"PageUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false, \"page\")\n    },\n    {\n        key: \"Enter\",\n        run: acceptCompletion\n    }\n];\nconst completionKeymapExt = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.computeN([\n    completionConfig\n], (state)=>state.facet(completionConfig).defaultKeymap ? [\n        completionKeymap\n    ] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/ function completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some((a)=>a.state == 1 /* State.Pending */ ) ? \"pending\" : cState && cState.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? \"active\" : null;\n}\nconst completionArrayCache = /*@__PURE__*/ new WeakMap;\n/**\nReturns the available completions as an array.\n*/ function currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    if (!open || open.disabled) return [];\n    let completions = completionArrayCache.get(open.options);\n    if (!completions) completionArrayCache.set(open.options, completions = open.options.map((o)=>o.completion));\n    return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/ function selectedCompletion(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/ function selectedCompletionIndex(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/ function setSelectedCompletion(index) {\n    return setSelectedEffect.of(index);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdPO0FBQ3BGO0FBQzlFO0FBRTlEOztBQUVBLEdBQ0EsTUFBTTJCO0lBQ0Y7Ozs7SUFJQSxHQUNBQyxZQUNBOztJQUVBLEdBQ0FDLEtBQUssRUFDTDs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7Ozs7O0lBS0EsR0FDQUMsUUFBUSxDQUFFO1FBQ04sSUFBSSxDQUFDRixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCOztRQUVBLEdBQ0EsSUFBSSxDQUFDQyxjQUFjLEdBQUcsRUFBRTtJQUM1QjtJQUNBOzs7SUFHQSxHQUNBQyxZQUFZQyxLQUFLLEVBQUU7UUFDZixJQUFJQyxRQUFRVixnRUFBVUEsQ0FBQyxJQUFJLENBQUNJLEtBQUssRUFBRU8sWUFBWSxDQUFDLElBQUksQ0FBQ04sR0FBRyxFQUFFLENBQUM7UUFDM0QsTUFBT0ssU0FBU0QsTUFBTUcsT0FBTyxDQUFDRixNQUFNRyxJQUFJLElBQUksRUFDeENILFFBQVFBLE1BQU1JLE1BQU07UUFDeEIsT0FBT0osUUFBUTtZQUFFSyxNQUFNTCxNQUFNSyxJQUFJO1lBQUVDLElBQUksSUFBSSxDQUFDWCxHQUFHO1lBQzNDWSxNQUFNLElBQUksQ0FBQ2IsS0FBSyxDQUFDYyxRQUFRLENBQUNSLE1BQU1LLElBQUksRUFBRSxJQUFJLENBQUNWLEdBQUc7WUFDOUNjLE1BQU1ULE1BQU1TLElBQUk7UUFBQyxJQUFJO0lBQzdCO0lBQ0E7OztJQUdBLEdBQ0FDLFlBQVlDLElBQUksRUFBRTtRQUNkLElBQUlDLE9BQU8sSUFBSSxDQUFDbEIsS0FBSyxDQUFDbUIsR0FBRyxDQUFDQyxNQUFNLENBQUMsSUFBSSxDQUFDbkIsR0FBRztRQUN6QyxJQUFJb0Is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QzRMLEtBQUtmLFFBQVEsQ0FBQyxDQUFDdkosVUFBVSxHQUFHO0FBQ25HO0FBQ0E7OztBQUdBLEdBQ0EsU0FBU2toQix3QkFBd0JubEIsS0FBSztJQUNsQyxJQUFJc0U7SUFDSixJQUFJaUssT0FBTyxDQUFDakssS0FBS3RFLE1BQU1zTyxLQUFLLENBQUNzSSxpQkFBaUIsTUFBSyxNQUFPLFFBQVF0UyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdpSyxJQUFJO0lBQ2xHLE9BQU9BLFFBQVEsQ0FBQ0EsS0FBS3dCLFFBQVEsSUFBSXhCLEtBQUtmLFFBQVEsSUFBSSxJQUFJZSxLQUFLZixRQUFRLEdBQUc7QUFDMUU7QUFDQTs7O0FBR0EsR0FDQSxTQUFTNFgsc0JBQXNCbEksS0FBSztJQUNoQyxPQUFPeEgsa0JBQWtCckcsRUFBRSxDQUFDNk47QUFDaEM7QUFFNmhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanM/YTEwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbm5vdGF0aW9uLCBTdGF0ZUVmZmVjdCwgRWRpdG9yU2VsZWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgZnJvbUNvZGVQb2ludCwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFByZWMsIFRleHQsIFRyYW5zYWN0aW9uLCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBSYW5nZVNldCwgQ2hhckNhdGVnb3J5IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRGlyZWN0aW9uLCBsb2dFeGNlcHRpb24sIHNob3dUb29sdGlwLCBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBnZXRUb29sdGlwLCBEZWNvcmF0aW9uLCBXaWRnZXRUeXBlLCBrZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHN5bnRheFRyZWUsIGluZGVudFVuaXQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5cbi8qKlxuQW4gaW5zdGFuY2Ugb2YgdGhpcyBpcyBwYXNzZWQgdG8gY29tcGxldGlvbiBzb3VyY2UgZnVuY3Rpb25zLlxuKi9cbmNsYXNzIENvbXBsZXRpb25Db250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgY29tcGxldGlvbiBjb250ZXh0LiAoTW9zdGx5IHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgIGNvbXBsZXRpb24gc291cmNlc+KAlGluIHRoZSBlZGl0b3IsIHRoZSBleHRlbnNpb24gd2lsbCBjcmVhdGVcbiAgICB0aGVzZSBmb3IgeW91LilcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUgdGhhdCB0aGUgY29tcGxldGlvbiBoYXBwZW5zIGluLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgY29tcGxldGlvbiBpcyBoYXBwZW5pbmcuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIGNvbXBsZXRpb24gd2FzIGFjdGl2YXRlZCBleHBsaWNpdGx5LCBvclxuICAgIGltcGxpY2l0bHkgYnkgdHlwaW5nLiBUaGUgdXN1YWwgd2F5IHRvIHJlc3BvbmQgdG8gdGhpcyBpcyB0b1xuICAgIG9ubHkgcmV0dXJuIGNvbXBsZXRpb25zIHdoZW4gZWl0aGVyIHRoZXJlIGlzIHBhcnQgb2YgYVxuICAgIGNvbXBsZXRhYmxlIGVudGl0eSBiZWZvcmUgdGhlIGN1cnNvciwgb3IgYGV4cGxpY2l0YCBpcyB0cnVlLlxuICAgICovXG4gICAgZXhwbGljaXQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5leHBsaWNpdCA9IGV4cGxpY2l0O1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYWJvcnRMaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBleHRlbnQsIGNvbnRlbnQsIGFuZCAoaWYgdGhlcmUgaXMgYSB0b2tlbikgdHlwZSBvZiB0aGVcbiAgICB0b2tlbiBiZWZvcmUgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIHRva2VuQmVmb3JlKHR5cGVzKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHN5bnRheFRyZWUodGhpcy5zdGF0ZSkucmVzb2x2ZUlubmVyKHRoaXMucG9zLCAtMSk7XG4gICAgICAgIHdoaWxlICh0b2tlbiAmJiB0eXBlcy5pbmRleE9mKHRva2VuLm5hbWUpIDwgMClcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4ucGFyZW50O1xuICAgICAgICByZXR1cm4gdG9rZW4gPyB7IGZyb206IHRva2VuLmZyb20sIHRvOiB0aGlzLnBvcyxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuc3RhdGUuc2xpY2VEb2ModG9rZW4uZnJvbSwgdGhpcy5wb3MpLFxuICAgICAgICAgICAgdHlwZTogdG9rZW4udHlwZSB9IDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXRjaCBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBkaXJlY3RseSBiZWZvcmUgdGhlXG4gICAgY3Vyc29yLlxuICAgICovXG4gICAgbWF0Y2hCZWZvcmUoZXhwcikge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgdGhpcy5wb3MgLSAyNTApO1xuICAgICAgICBsZXQgc3RyID0gbGluZS50ZXh0LnNsaWNlKHN0YXJ0IC0gbGluZS5mcm9tLCB0aGlzLnBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBmb3VuZCA9IHN0ci5zZWFyY2goZW5zdXJlQW5jaG9yKGV4cHIsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiBmb3VuZCA8IDAgPyBudWxsIDogeyBmcm9tOiBzdGFydCArIGZvdW5kLCB0bzogdGhpcy5wb3MsIHRleHQ6IHN0ci5zbGljZShmb3VuZCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgWWllbGRzIHRydWUgd2hlbiB0aGUgcXVlcnkgaGFzIGJlZW4gYWJvcnRlZC4gQ2FuIGJlIHVzZWZ1bCBpblxuICAgIGFzeW5jaHJvbm91cyBxdWVyaWVzIHRvIGF2b2lkIGRvaW5nIHdvcmsgdGhhdCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgKi9cbiAgICBnZXQgYWJvcnRlZCgpIHsgcmV0dXJuIHRoaXMuYWJvcnRMaXN0ZW5lcnMgPT0gbnVsbDsgfVxuICAgIC8qKlxuICAgIEFsbG93cyB5b3UgdG8gcmVnaXN0ZXIgYWJvcnQgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICB0aGUgcXVlcnkgaXNcbiAgICBbYWJvcnRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvbkNvbnRleHQuYWJvcnRlZCkuXG4gICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlID09IFwiYWJvcnRcIiAmJiB0aGlzLmFib3J0TGlzdGVuZXJzKVxuICAgICAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1NldChjaGFycykge1xuICAgIGxldCBmbGF0ID0gT2JqZWN0LmtleXMoY2hhcnMpLmpvaW4oXCJcIik7XG4gICAgbGV0IHdvcmRzID0gL1xcdy8udGVzdChmbGF0KTtcbiAgICBpZiAod29yZHMpXG4gICAgICAgIGZsYXQgPSBmbGF0LnJlcGxhY2UoL1xcdy9nLCBcIlwiKTtcbiAgICByZXR1cm4gYFske3dvcmRzID8gXCJcXFxcd1wiIDogXCJcIn0ke2ZsYXQucmVwbGFjZSgvW15cXHdcXHNdL2csIFwiXFxcXCQmXCIpfV1gO1xufVxuZnVuY3Rpb24gcHJlZml4TWF0Y2gob3B0aW9ucykge1xuICAgIGxldCBmaXJzdCA9IE9iamVjdC5jcmVhdGUobnVsbCksIHJlc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHsgbGFiZWwgfSBvZiBvcHRpb25zKSB7XG4gICAgICAgIGZpcnN0W2xhYmVsWzBdXSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN0W2xhYmVsW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGxldCBzb3VyY2UgPSB0b1NldChmaXJzdCkgKyB0b1NldChyZXN0KSArIFwiKiRcIjtcbiAgICByZXR1cm4gW25ldyBSZWdFeHAoXCJeXCIgKyBzb3VyY2UpLCBuZXcgUmVnRXhwKHNvdXJjZSldO1xufVxuLyoqXG5HaXZlbiBhIGEgZml4ZWQgYXJyYXkgb2Ygb3B0aW9ucywgcmV0dXJuIGFuIGF1dG9jb21wbGV0ZXIgdGhhdFxuY29tcGxldGVzIHRoZW0uXG4qL1xuZnVuY3Rpb24gY29tcGxldGVGcm9tTGlzdChsaXN0KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBsaXN0Lm1hcChvID0+IHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyB7IGxhYmVsOiBvIH0gOiBvKTtcbiAgICBsZXQgW3ZhbGlkRm9yLCBtYXRjaF0gPSBvcHRpb25zLmV2ZXJ5KG8gPT4gL15cXHcrJC8udGVzdChvLmxhYmVsKSkgPyBbL1xcdyokLywgL1xcdyskL10gOiBwcmVmaXhNYXRjaChvcHRpb25zKTtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IHRva2VuID0gY29udGV4dC5tYXRjaEJlZm9yZShtYXRjaCk7XG4gICAgICAgIHJldHVybiB0b2tlbiB8fCBjb250ZXh0LmV4cGxpY2l0ID8geyBmcm9tOiB0b2tlbiA/IHRva2VuLmZyb20gOiBjb250ZXh0LnBvcywgb3B0aW9ucywgdmFsaWRGb3IgfSA6IG51bGw7XG4gICAgfTtcbn1cbi8qKlxuV3JhcCB0aGUgZ2l2ZW4gY29tcGxldGlvbiBzb3VyY2Ugc28gdGhhdCBpdCB3aWxsIG9ubHkgZmlyZSB3aGVuIHRoZVxuY3Vyc29yIGlzIGluIGEgc3ludGF4IG5vZGUgd2l0aCBvbmUgb2YgdGhlIGdpdmVuIG5hbWVzLlxuKi9cbmZ1bmN0aW9uIGlmSW4obm9kZXMsIHNvdXJjZSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpLnJlc29sdmVJbm5lcihjb250ZXh0LnBvcywgLTEpOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2Rlcy5pbmRleE9mKHBvcy5uYW1lKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UoY29udGV4dCk7XG4gICAgICAgICAgICBpZiAocG9zLnR5cGUuaXNUb3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cbi8qKlxuV3JhcCB0aGUgZ2l2ZW4gY29tcGxldGlvbiBzb3VyY2Ugc28gdGhhdCBpdCB3aWxsIG5vdCBmaXJlIHdoZW4gdGhlXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXG4qL1xuZnVuY3Rpb24gaWZOb3RJbihub2Rlcywgc291cmNlKSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocG9zLnR5cGUuaXNUb3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZShjb250ZXh0KTtcbiAgICB9O1xufVxuY2xhc3MgT3B0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wbGV0aW9uLCBzb3VyY2UsIG1hdGNoLCBzY29yZSkge1xuICAgICAgICB0aGlzLmNvbXBsZXRpb24gPSBjb21wbGV0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgfVxufVxuZnVuY3Rpb24gY3VyKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5mcm9tOyB9XG4vLyBNYWtlIHN1cmUgdGhlIGdpdmVuIHJlZ2V4cCBoYXMgYSAkIGF0IGl0cyBlbmQgYW5kLCBpZiBgc3RhcnRgIGlzXG4vLyB0cnVlLCBhIF4gYXQgaXRzIHN0YXJ0LlxuZnVuY3Rpb24gZW5zdXJlQW5jaG9yKGV4cHIsIHN0YXJ0KSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IHNvdXJjZSB9ID0gZXhwcjtcbiAgICBsZXQgYWRkU3RhcnQgPSBzdGFydCAmJiBzb3VyY2VbMF0gIT0gXCJeXCIsIGFkZEVuZCA9IHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT0gXCIkXCI7XG4gICAgaWYgKCFhZGRTdGFydCAmJiAhYWRkRW5kKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgJHthZGRTdGFydCA/IFwiXlwiIDogXCJcIn0oPzoke3NvdXJjZX0pJHthZGRFbmQgPyBcIiRcIiA6IFwiXCJ9YCwgKF9hID0gZXhwci5mbGFncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGV4cHIuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikpO1xufVxuLyoqXG5UaGlzIGFubm90YXRpb24gaXMgYWRkZWQgdG8gdHJhbnNhY3Rpb25zIHRoYXQgYXJlIHByb2R1Y2VkIGJ5XG5waWNraW5nIGEgY29tcGxldGlvbi5cbiovXG5jb25zdCBwaWNrZWRDb21wbGV0aW9uID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB0cmFuc2FjdGlvbiBzcGVjIHdoaWNoIGluc2VydHMgYVxuY29tcGxldGlvbidzIHRleHQgaW4gdGhlIG1haW4gc2VsZWN0aW9uIHJhbmdlLCBhbmQgYW55IG90aGVyXG5zZWxlY3Rpb24gcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgdGV4dCBpbiBmcm9udCBvZiBpdC5cbiovXG5mdW5jdGlvbiBpbnNlcnRDb21wbGV0aW9uVGV4dChzdGF0ZSwgdGV4dCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgeyBtYWluIH0gPSBzdGF0ZS5zZWxlY3Rpb24sIGZyb21PZmYgPSBmcm9tIC0gbWFpbi5mcm9tLCB0b09mZiA9IHRvIC0gbWFpbi5mcm9tO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UgIT0gbWFpbiAmJiBmcm9tICE9IHRvICYmXG4gICAgICAgICAgICBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tICsgZnJvbU9mZiwgcmFuZ2UuZnJvbSArIHRvT2ZmKSAhPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpXG4gICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tICsgZnJvbU9mZiwgdG86IHRvID09IG1haW4uZnJvbSA/IHJhbmdlLnRvIDogcmFuZ2UuZnJvbSArIHRvT2ZmLCBpbnNlcnQ6IHRleHQgfSxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBmcm9tT2ZmICsgdGV4dC5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgfSkpLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIiB9KTtcbn1cbmNvbnN0IFNvdXJjZUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhc1NvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICBsZXQga25vd24gPSBTb3VyY2VDYWNoZS5nZXQoc291cmNlKTtcbiAgICBpZiAoIWtub3duKVxuICAgICAgICBTb3VyY2VDYWNoZS5zZXQoc291cmNlLCBrbm93biA9IGNvbXBsZXRlRnJvbUxpc3Qoc291cmNlKSk7XG4gICAgcmV0dXJuIGtub3duO1xufVxuY29uc3Qgc3RhcnRDb21wbGV0aW9uRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgY2xvc2VDb21wbGV0aW9uRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuXG4vLyBBIHBhdHRlcm4gbWF0Y2hlciBmb3IgZnV6enkgY29tcGxldGlvbiBtYXRjaGluZy4gQ3JlYXRlIGFuIGluc3RhbmNlXG4vLyBvbmNlIGZvciBhIHBhdHRlcm4sIGFuZCB0aGVuIHVzZSB0aGF0IHRvIG1hdGNoIGFueSBudW1iZXIgb2Zcbi8vIGNvbXBsZXRpb25zLlxuY2xhc3MgRnV6enlNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgICAgdGhpcy5mb2xkZWQgPSBbXTtcbiAgICAgICAgLy8gQnVmZmVycyByZXVzZWQgYnkgY2FsbHMgdG8gYG1hdGNoYCB0byB0cmFjayBtYXRjaGVkIGNoYXJhY3RlclxuICAgICAgICAvLyBwb3NpdGlvbnMuXG4gICAgICAgIHRoaXMuYW55ID0gW107XG4gICAgICAgIHRoaXMucHJlY2lzZSA9IFtdO1xuICAgICAgICB0aGlzLmJ5V29yZCA9IFtdO1xuICAgICAgICB0aGlzLnNjb3JlID0gMDtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcGF0dGVybi5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGNvZGVQb2ludEF0KHBhdHRlcm4sIHApLCBzaXplID0gY29kZVBvaW50U2l6ZShjaGFyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gcGF0dGVybi5zbGljZShwLCBwICsgc2l6ZSksIHVwcGVyID0gcGFydC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5mb2xkZWQucHVzaChjb2RlUG9pbnRBdCh1cHBlciA9PSBwYXJ0ID8gcGFydC50b0xvd2VyQ2FzZSgpIDogdXBwZXIsIDApKTtcbiAgICAgICAgICAgIHAgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzdHJhbCA9IHBhdHRlcm4ubGVuZ3RoICE9IHRoaXMuY2hhcnMubGVuZ3RoO1xuICAgIH1cbiAgICByZXQoc2NvcmUsIG1hdGNoZWQpIHtcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBtYXRjaGVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gTWF0Y2hlcyBhIGdpdmVuIHdvcmQgKGNvbXBsZXRpb24pIGFnYWluc3QgdGhlIHBhdHRlcm4gKGlucHV0KS5cbiAgICAvLyBXaWxsIHJldHVybiBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIHdhcyBhIG1hdGNoIGFuZCxcbiAgICAvLyBvbiBzdWNjZXNzLCBzZXQgYHRoaXMuc2NvcmVgIHRvIHRoZSBzY29yZSwgYHRoaXMubWF0Y2hlZGAgdG8gYW5cbiAgICAvLyBhcnJheSBvZiBgZnJvbSwgdG9gIHBhaXJzIGluZGljYXRpbmcgdGhlIG1hdGNoZWQgcGFydHMgb2YgYHdvcmRgLlxuICAgIC8vXG4gICAgLy8gVGhlIHNjb3JlIGlzIGEgbnVtYmVyIHRoYXQgaXMgbW9yZSBuZWdhdGl2ZSB0aGUgd29yc2UgdGhlIG1hdGNoXG4gICAgLy8gaXMuIFNlZSBgUGVuYWx0eWAgYWJvdmUuXG4gICAgbWF0Y2god29yZCkge1xuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovLCBbXSk7XG4gICAgICAgIGlmICh3b3JkLmxlbmd0aCA8IHRoaXMucGF0dGVybi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB7IGNoYXJzLCBmb2xkZWQsIGFueSwgcHJlY2lzZSwgYnlXb3JkIH0gPSB0aGlzO1xuICAgICAgICAvLyBGb3Igc2luZ2xlLWNoYXJhY3RlciBxdWVyaWVzLCBvbmx5IG1hdGNoIHdoZW4gdGhleSBvY2N1ciByaWdodFxuICAgICAgICAvLyBhdCB0aGUgc3RhcnRcbiAgICAgICAgaWYgKGNoYXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBjb2RlUG9pbnRBdCh3b3JkLCAwKSwgZmlyc3RTaXplID0gY29kZVBvaW50U2l6ZShmaXJzdCk7XG4gICAgICAgICAgICBsZXQgc2NvcmUgPSBmaXJzdFNpemUgPT0gd29yZC5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi87XG4gICAgICAgICAgICBpZiAoZmlyc3QgPT0gY2hhcnNbMF0pIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0ID09IGZvbGRlZFswXSlcbiAgICAgICAgICAgICAgICBzY29yZSArPSAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi87XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KHNjb3JlLCBbMCwgZmlyc3RTaXplXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpcmVjdCA9IHdvcmQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgICAgICBpZiAoZGlyZWN0ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQod29yZC5sZW5ndGggPT0gdGhpcy5wYXR0ZXJuLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLywgWzAsIHRoaXMucGF0dGVybi5sZW5ndGhdKTtcbiAgICAgICAgbGV0IGxlbiA9IGNoYXJzLmxlbmd0aCwgYW55VG8gPSAwO1xuICAgICAgICBpZiAoZGlyZWN0IDwgMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGUgPSBNYXRoLm1pbih3b3JkLmxlbmd0aCwgMjAwKTsgaSA8IGUgJiYgYW55VG8gPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjb2RlUG9pbnRBdCh3b3JkLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PSBjaGFyc1thbnlUb10gfHwgbmV4dCA9PSBmb2xkZWRbYW55VG9dKVxuICAgICAgICAgICAgICAgICAgICBhbnlbYW55VG8rK10gPSBpO1xuICAgICAgICAgICAgICAgIGkgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vIG1hdGNoLCBleGl0IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoYW55VG8gPCBsZW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgdHJhY2tzIHRoZSBleHRlbnQgb2YgdGhlIHByZWNpc2UgKG5vbi1mb2xkZWQsIG5vdFxuICAgICAgICAvLyBuZWNlc3NhcmlseSBhZGphY2VudCkgbWF0Y2hcbiAgICAgICAgbGV0IHByZWNpc2VUbyA9IDA7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZXJlIGlzIGEgbWF0Y2ggdGhhdCBoaXRzIG9ubHkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgIC8vIGFwcGVhciB0byBiZSBzdGFydGluZyB3b3Jkcy4gYGJ5V29yZEZvbGRlZGAgaXMgc2V0IHRvIHRydWUgd2hlblxuICAgICAgICAvLyBhIGNhc2UgZm9sZGVkIGNoYXJhY3RlciBpcyBlbmNvdW50ZXJlZCBpbiBzdWNoIGEgbWF0Y2hcbiAgICAgICAgbGV0IGJ5V29yZFRvID0gMCwgYnlXb3JkRm9sZGVkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGZvdW5kIGEgcGFydGlhbCBhZGphY2VudCBtYXRjaCwgdGhlc2UgdHJhY2sgaXRzIHN0YXRlXG4gICAgICAgIGxldCBhZGphY2VudFRvID0gMCwgYWRqYWNlbnRTdGFydCA9IC0xLCBhZGphY2VudEVuZCA9IC0xO1xuICAgICAgICBsZXQgaGFzTG93ZXIgPSAvW2Etel0vLnRlc3Qod29yZCksIHdvcmRBZGphY2VudCA9IHRydWU7XG4gICAgICAgIC8vIEdvIG92ZXIgdGhlIG9wdGlvbidzIHRleHQsIHNjYW5uaW5nIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBtYXRjaGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCksIHByZXZUeXBlID0gMCAvKiBUcC5Ob25Xb3JkICovOyBpIDwgZSAmJiBieVdvcmRUbyA8IGxlbjspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVjaXNlVG8gPCBsZW4gJiYgbmV4dCA9PSBjaGFyc1twcmVjaXNlVG9dKVxuICAgICAgICAgICAgICAgICAgICBwcmVjaXNlW3ByZWNpc2VUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGFkamFjZW50VG8gPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYWRqYWNlbnRUb10gfHwgbmV4dCA9PSBmb2xkZWRbYWRqYWNlbnRUb10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudEVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2gsIHR5cGUgPSBuZXh0IDwgMHhmZlxuICAgICAgICAgICAgICAgID8gKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NyB8fCBuZXh0ID49IDk3ICYmIG5leHQgPD0gMTIyID8gMiAvKiBUcC5Mb3dlciAqLyA6IG5leHQgPj0gNjUgJiYgbmV4dCA8PSA5MCA/IDEgLyogVHAuVXBwZXIgKi8gOiAwIC8qIFRwLk5vbldvcmQgKi8pXG4gICAgICAgICAgICAgICAgOiAoKGNoID0gZnJvbUNvZGVQb2ludChuZXh0KSkgIT0gY2gudG9Mb3dlckNhc2UoKSA/IDEgLyogVHAuVXBwZXIgKi8gOiBjaCAhPSBjaC50b1VwcGVyQ2FzZSgpID8gMiAvKiBUcC5Mb3dlciAqLyA6IDAgLyogVHAuTm9uV29yZCAqLyk7XG4gICAgICAgICAgICBpZiAoIWkgfHwgdHlwZSA9PSAxIC8qIFRwLlVwcGVyICovICYmIGhhc0xvd2VyIHx8IHByZXZUeXBlID09IDAgLyogVHAuTm9uV29yZCAqLyAmJiB0eXBlICE9IDAgLyogVHAuTm9uV29yZCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyc1tieVdvcmRUb10gPT0gbmV4dCB8fCAoZm9sZGVkW2J5V29yZFRvXSA9PSBuZXh0ICYmIChieVdvcmRGb2xkZWQgPSB0cnVlKSkpXG4gICAgICAgICAgICAgICAgICAgIGJ5V29yZFtieVdvcmRUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYnlXb3JkLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd29yZEFkamFjZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5V29yZFRvID09IGxlbiAmJiBieVdvcmRbMF0gPT0gMCAmJiB3b3JkQWRqYWNlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBQZW5hbHR5LkJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiAwKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuICYmIGFkamFjZW50U3RhcnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gLSB3b3JkLmxlbmd0aCArIChhZGphY2VudEVuZCA9PSB3b3JkLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLyksIFswLCBhZGphY2VudEVuZF0pO1xuICAgICAgICBpZiAoZGlyZWN0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIFtkaXJlY3QsIGRpcmVjdCArIHRoaXMucGF0dGVybi5sZW5ndGhdKTtcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyAtIHdvcmQubGVuZ3RoLCBbYWRqYWNlbnRTdGFydCwgYWRqYWNlbnRFbmRdKTtcbiAgICAgICAgaWYgKGJ5V29yZFRvID09IGxlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgtMTAwIC8qIFBlbmFsdHkuQnlXb3JkICovICsgKGJ5V29yZEZvbGRlZCA/IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyA6IDApICsgLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovICtcbiAgICAgICAgICAgICAgICAod29yZEFkamFjZW50ID8gMCA6IC0xMTAwIC8qIFBlbmFsdHkuR2FwICovKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmxlbmd0aCA9PSAyID8gZmFsc2VcbiAgICAgICAgICAgIDogdGhpcy5yZXN1bHQoKGFueVswXSA/IC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyA6IDApICsgLTIwMCAvKiBQZW5hbHR5LkNhc2VGb2xkICovICsgLTExMDAgLyogUGVuYWx0eS5HYXAgKi8sIGFueSwgd29yZCk7XG4gICAgfVxuICAgIHJlc3VsdChzY29yZSwgcG9zaXRpb25zLCB3b3JkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB0byA9IHBvcyArICh0aGlzLmFzdHJhbCA/IGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQod29yZCwgcG9zKSkgOiAxKTtcbiAgICAgICAgICAgIGlmIChpICYmIHJlc3VsdFtpIC0gMV0gPT0gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpIC0gMV0gPSB0bztcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gcG9zO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpKytdID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmV0KHNjb3JlIC0gd29yZC5sZW5ndGgsIHJlc3VsdCk7XG4gICAgfVxufVxuXG5jb25zdCBjb21wbGV0aW9uQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGFjdGl2YXRlT25UeXBpbmc6IHRydWUsXG4gICAgICAgICAgICBhY3RpdmF0ZU9uVHlwaW5nRGVsYXk6IDEwMCxcbiAgICAgICAgICAgIHNlbGVjdE9uT3BlbjogdHJ1ZSxcbiAgICAgICAgICAgIG92ZXJyaWRlOiBudWxsLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IHRydWUsXG4gICAgICAgICAgICBtYXhSZW5kZXJlZE9wdGlvbnM6IDEwMCxcbiAgICAgICAgICAgIGRlZmF1bHRLZXltYXA6IHRydWUsXG4gICAgICAgICAgICB0b29sdGlwQ2xhc3M6ICgpID0+IFwiXCIsXG4gICAgICAgICAgICBvcHRpb25DbGFzczogKCkgPT4gXCJcIixcbiAgICAgICAgICAgIGFib3ZlQ3Vyc29yOiBmYWxzZSxcbiAgICAgICAgICAgIGljb25zOiB0cnVlLFxuICAgICAgICAgICAgYWRkVG9PcHRpb25zOiBbXSxcbiAgICAgICAgICAgIHBvc2l0aW9uSW5mbzogZGVmYXVsdFBvc2l0aW9uSW5mbyxcbiAgICAgICAgICAgIGNvbXBhcmVDb21wbGV0aW9uczogKGEsIGIpID0+IGEubGFiZWwubG9jYWxlQ29tcGFyZShiLmxhYmVsKSxcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGVsYXk6IDc1LFxuICAgICAgICAgICAgdXBkYXRlU3luY1RpbWU6IDEwMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgY2xvc2VPbkJsdXI6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBpY29uczogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIHRvb2x0aXBDbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6IChhLCBiKSA9PiBjID0+IGpvaW5DbGFzcyhhKGMpLCBiKGMpKSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogKGEsIGIpID0+IGEuY29uY2F0KGIpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gam9pbkNsYXNzKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IGIgPyBhICsgXCIgXCIgKyBiIDogYSA6IGI7XG59XG5mdW5jdGlvbiBkZWZhdWx0UG9zaXRpb25JbmZvKHZpZXcsIGxpc3QsIG9wdGlvbiwgaW5mbywgc3BhY2UsIHRvb2x0aXApIHtcbiAgICBsZXQgcnRsID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5SVEwsIGxlZnQgPSBydGwsIG5hcnJvdyA9IGZhbHNlO1xuICAgIGxldCBzaWRlID0gXCJ0b3BcIiwgb2Zmc2V0LCBtYXhXaWR0aDtcbiAgICBsZXQgc3BhY2VMZWZ0ID0gbGlzdC5sZWZ0IC0gc3BhY2UubGVmdCwgc3BhY2VSaWdodCA9IHNwYWNlLnJpZ2h0IC0gbGlzdC5yaWdodDtcbiAgICBsZXQgaW5mb1dpZHRoID0gaW5mby5yaWdodCAtIGluZm8ubGVmdCwgaW5mb0hlaWdodCA9IGluZm8uYm90dG9tIC0gaW5mby50b3A7XG4gICAgaWYgKGxlZnQgJiYgc3BhY2VMZWZ0IDwgTWF0aC5taW4oaW5mb1dpZHRoLCBzcGFjZVJpZ2h0KSlcbiAgICAgICAgbGVmdCA9IGZhbHNlO1xuICAgIGVsc2UgaWYgKCFsZWZ0ICYmIHNwYWNlUmlnaHQgPCBNYXRoLm1pbihpbmZvV2lkdGgsIHNwYWNlTGVmdCkpXG4gICAgICAgIGxlZnQgPSB0cnVlO1xuICAgIGlmIChpbmZvV2lkdGggPD0gKGxlZnQgPyBzcGFjZUxlZnQgOiBzcGFjZVJpZ2h0KSkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChzcGFjZS50b3AsIE1hdGgubWluKG9wdGlvbi50b3AsIHNwYWNlLmJvdHRvbSAtIGluZm9IZWlnaHQpKSAtIGxpc3QudG9wO1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCBsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuYXJyb3cgPSB0cnVlO1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCAocnRsID8gbGlzdC5yaWdodCA6IHNwYWNlLnJpZ2h0IC0gbGlzdC5sZWZ0KSAtIDMwIC8qIEluZm8uTWFyZ2luICovKTtcbiAgICAgICAgbGV0IHNwYWNlQmVsb3cgPSBzcGFjZS5ib3R0b20gLSBsaXN0LmJvdHRvbTtcbiAgICAgICAgaWYgKHNwYWNlQmVsb3cgPj0gaW5mb0hlaWdodCB8fCBzcGFjZUJlbG93ID4gbGlzdC50b3ApIHsgLy8gQmVsb3cgdGhlIGNvbXBsZXRpb25cbiAgICAgICAgICAgIG9mZnNldCA9IG9wdGlvbi5ib3R0b20gLSBsaXN0LnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gQWJvdmUgaXRcbiAgICAgICAgICAgIHNpZGUgPSBcImJvdHRvbVwiO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbGlzdC5ib3R0b20gLSBvcHRpb24udG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzY2FsZVkgPSAobGlzdC5ib3R0b20gLSBsaXN0LnRvcCkgLyB0b29sdGlwLm9mZnNldEhlaWdodDtcbiAgICBsZXQgc2NhbGVYID0gKGxpc3QucmlnaHQgLSBsaXN0LmxlZnQpIC8gdG9vbHRpcC5vZmZzZXRXaWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogYCR7c2lkZX06ICR7b2Zmc2V0IC8gc2NhbGVZfXB4OyBtYXgtd2lkdGg6ICR7bWF4V2lkdGggLyBzY2FsZVh9cHhgLFxuICAgICAgICBjbGFzczogXCJjbS1jb21wbGV0aW9uSW5mby1cIiArIChuYXJyb3cgPyAocnRsID8gXCJsZWZ0LW5hcnJvd1wiIDogXCJyaWdodC1uYXJyb3dcIikgOiBsZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gb3B0aW9uQ29udGVudChjb25maWcpIHtcbiAgICBsZXQgY29udGVudCA9IGNvbmZpZy5hZGRUb09wdGlvbnMuc2xpY2UoKTtcbiAgICBpZiAoY29uZmlnLmljb25zKVxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkljb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRpb24udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKC4uLmNvbXBsZXRpb24udHlwZS5zcGxpdCgvXFxzKy9nKS5tYXAoY2xzID0+IFwiY20tY29tcGxldGlvbkljb24tXCIgKyBjbHMpKTtcbiAgICAgICAgICAgICAgICBpY29uLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWNvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjogMjBcbiAgICAgICAgfSk7XG4gICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24sIF9zLCBfdiwgbWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgbGFiZWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTGFiZWxcIjtcbiAgICAgICAgICAgIGxldCBsYWJlbCA9IGNvbXBsZXRpb24uZGlzcGxheUxhYmVsIHx8IGNvbXBsZXRpb24ubGFiZWwsIG9mZiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IG1hdGNoW2orK10sIHRvID0gbWF0Y2hbaisrXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IG9mZilcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmLCBmcm9tKSkpO1xuICAgICAgICAgICAgICAgIGxldCBzcGFuID0gbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpO1xuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2UoZnJvbSwgdG8pKSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLWNvbXBsZXRpb25NYXRjaGVkVGV4dFwiO1xuICAgICAgICAgICAgICAgIG9mZiA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZiA8IGxhYmVsLmxlbmd0aClcbiAgICAgICAgICAgICAgICBsYWJlbEVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbC5zbGljZShvZmYpKSk7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxFbHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiA1MFxuICAgIH0sIHtcbiAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgIGlmICghY29tcGxldGlvbi5kZXRhaWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgZGV0YWlsRWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBkZXRhaWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uRGV0YWlsXCI7XG4gICAgICAgICAgICBkZXRhaWxFbHQudGV4dENvbnRlbnQgPSBjb21wbGV0aW9uLmRldGFpbDtcbiAgICAgICAgICAgIHJldHVybiBkZXRhaWxFbHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiA4MFxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50LnNvcnQoKGEsIGIpID0+IGEucG9zaXRpb24gLSBiLnBvc2l0aW9uKS5tYXAoYSA9PiBhLnJlbmRlcik7XG59XG5mdW5jdGlvbiByYW5nZUFyb3VuZFNlbGVjdGVkKHRvdGFsLCBzZWxlY3RlZCwgbWF4KSB7XG4gICAgaWYgKHRvdGFsIDw9IG1heClcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogMCwgdG86IHRvdGFsIH07XG4gICAgaWYgKHNlbGVjdGVkIDwgMClcbiAgICAgICAgc2VsZWN0ZWQgPSAwO1xuICAgIGlmIChzZWxlY3RlZCA8PSAodG90YWwgPj4gMSkpIHtcbiAgICAgICAgbGV0IG9mZiA9IE1hdGguZmxvb3Ioc2VsZWN0ZWQgLyBtYXgpO1xuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmYgKiBtYXgsIHRvOiAob2ZmICsgMSkgKiBtYXggfTtcbiAgICB9XG4gICAgbGV0IG9mZiA9IE1hdGguZmxvb3IoKHRvdGFsIC0gc2VsZWN0ZWQpIC8gbWF4KTtcbiAgICByZXR1cm4geyBmcm9tOiB0b3RhbCAtIChvZmYgKyAxKSAqIG1heCwgdG86IHRvdGFsIC0gb2ZmICogbWF4IH07XG59XG5jbGFzcyBDb21wbGV0aW9uVG9vbHRpcCB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhdGVGaWVsZCwgYXBwbHlDb21wbGV0aW9uKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGVGaWVsZCA9IHN0YXRlRmllbGQ7XG4gICAgICAgIHRoaXMuYXBwbHlDb21wbGV0aW9uID0gYXBwbHlDb21wbGV0aW9uO1xuICAgICAgICB0aGlzLmluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLmluZm9EZXN0cm95ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbGFjZUluZm9SZXEgPSB7XG4gICAgICAgICAgICByZWFkOiAoKSA9PiB0aGlzLm1lYXN1cmVJbmZvKCksXG4gICAgICAgICAgICB3cml0ZTogKHBvcykgPT4gdGhpcy5wbGFjZUluZm8ocG9zKSxcbiAgICAgICAgICAgIGtleTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNwYWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3MgPSBcIlwiO1xuICAgICAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzdGF0ZUZpZWxkKTtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgc2VsZWN0ZWQgfSA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25Db250ZW50ID0gb3B0aW9uQ29udGVudChjb25maWcpO1xuICAgICAgICB0aGlzLm9wdGlvbkNsYXNzID0gY29uZmlnLm9wdGlvbkNsYXNzO1xuICAgICAgICB0aGlzLnRvb2x0aXBDbGFzcyA9IGNvbmZpZy50b29sdGlwQ2xhc3M7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgY29uZmlnLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBDbGFzcyh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gdmlldy5zdGF0ZS5maWVsZChzdGF0ZUZpZWxkKS5vcGVuO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tID0gZS50YXJnZXQsIG1hdGNoOyBkb20gJiYgZG9tICE9IHRoaXMuZG9tOyBkb20gPSBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJMSVwiICYmIChtYXRjaCA9IC8tKFxcZCspJC8uZXhlYyhkb20uaWQpKSAmJiArbWF0Y2hbMV0gPCBvcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb25zWyttYXRjaFsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmNsb3NlT25CbHVyICYmXG4gICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcHRpb25zLCBjU3RhdGUuaWQpO1xuICAgIH1cbiAgICBtb3VudCgpIHsgdGhpcy51cGRhdGVTZWwoKTsgfVxuICAgIHNob3dPcHRpb25zKG9wdGlvbnMsIGlkKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3QpXG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChvcHRpb25zLCBpZCwgdGhpcy5yYW5nZSkpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpO1xuICAgICAgICBsZXQgcHJldlN0YXRlID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3ModXBkYXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKGNTdGF0ZSAhPSBwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkLCBkaXNhYmxlZCB9ID0gY1N0YXRlLm9wZW47XG4gICAgICAgICAgICBpZiAoIXByZXZTdGF0ZS5vcGVuIHx8IHByZXZTdGF0ZS5vcGVuLm9wdGlvbnMgIT0gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgdXBkYXRlLnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcHRpb25zLCBjU3RhdGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWwoKTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCAhPSAoKF9hID0gcHJldlN0YXRlLm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlZCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkXCIsICEhZGlzYWJsZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVRvb2x0aXBDbGFzcyhzdGF0ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy50b29sdGlwQ2xhc3Moc3RhdGUpO1xuICAgICAgICBpZiAoY2xzICE9IHRoaXMuY3VycmVudENsYXNzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuY3VycmVudENsYXNzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY2xzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENsYXNzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc2l0aW9uZWQoc3BhY2UpIHtcbiAgICAgICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsKCkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCksIG9wZW4gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgaWYgKG9wZW4uc2VsZWN0ZWQgPiAtMSAmJiBvcGVuLnNlbGVjdGVkIDwgdGhpcy5yYW5nZS5mcm9tIHx8IG9wZW4uc2VsZWN0ZWQgPj0gdGhpcy5yYW5nZS50bykge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlQXJvdW5kU2VsZWN0ZWQob3Blbi5vcHRpb25zLmxlbmd0aCwgb3Blbi5zZWxlY3RlZCwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNob3dPcHRpb25zKG9wZW4ub3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51cGRhdGVTZWxlY3RlZE9wdGlvbihvcGVuLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgICAgICAgICAgbGV0IHsgY29tcGxldGlvbiB9ID0gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdO1xuICAgICAgICAgICAgbGV0IHsgaW5mbyB9ID0gY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgaW5mb1Jlc3VsdCA9IHR5cGVvZiBpbmZvID09PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaW5mbykgOiBpbmZvKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKCFpbmZvUmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChcInRoZW5cIiBpbiBpbmZvUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW5mb1Jlc3VsdC50aGVuKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogJiYgdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpID09IGNTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUob2JqLCBjb21wbGV0aW9uKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUsIFwiY29tcGxldGlvbiBpbmZvXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUoaW5mb1Jlc3VsdCwgY29tcGxldGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSW5mb1BhbmUoY29udGVudCwgY29tcGxldGlvbikge1xuICAgICAgICB0aGlzLmRlc3Ryb3lJbmZvKCk7XG4gICAgICAgIGxldCB3cmFwID0gdGhpcy5pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm9cIjtcbiAgICAgICAgaWYgKGNvbnRlbnQubm9kZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgZG9tLCBkZXN0cm95IH0gPSBjb250ZW50O1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IGRlc3Ryb3kgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh3cmFwKTtcbiAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgbGV0IHNldCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IG9wdCA9IHRoaXMubGlzdC5maXJzdENoaWxkLCBpID0gdGhpcy5yYW5nZS5mcm9tOyBvcHQ7IG9wdCA9IG9wdC5uZXh0U2libGluZywgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3B0Lm5vZGVOYW1lICE9IFwiTElcIiB8fCAhb3B0LmlkKSB7XG4gICAgICAgICAgICAgICAgaS0tOyAvLyBBIHNlY3Rpb24gaGVhZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IG9wdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpXG4gICAgICAgICAgICAgICAgICAgIG9wdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQpXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLmxpc3QsIHNldCk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIG1lYXN1cmVJbmZvKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIlthcmlhLXNlbGVjdGVkXVwiKTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIXRoaXMuaW5mbylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGlzdFJlY3QgPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGluZm9SZWN0ID0gdGhpcy5pbmZvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2VsUmVjdCA9IHNlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNwYWNlID0gdGhpcy5zcGFjZTtcbiAgICAgICAgaWYgKCFzcGFjZSkge1xuICAgICAgICAgICAgbGV0IHdpbiA9IHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgICAgICAgICAgc3BhY2UgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxSZWN0LnRvcCA+IE1hdGgubWluKHNwYWNlLmJvdHRvbSwgbGlzdFJlY3QuYm90dG9tKSAtIDEwIHx8XG4gICAgICAgICAgICBzZWxSZWN0LmJvdHRvbSA8IE1hdGgubWF4KHNwYWNlLnRvcCwgbGlzdFJlY3QudG9wKSArIDEwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykucG9zaXRpb25JbmZvKHRoaXMudmlldywgbGlzdFJlY3QsIHNlbFJlY3QsIGluZm9SZWN0LCBzcGFjZSwgdGhpcy5kb20pO1xuICAgIH1cbiAgICBwbGFjZUluZm8ocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZm8uc3R5bGUuY3NzVGV4dCA9IHBvcy5zdHlsZTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvIFwiICsgKHBvcy5jbGFzcyB8fCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6IC0xZTZweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUxpc3RCb3gob3B0aW9ucywgaWQsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgICAgICB1bC5pZCA9IGlkO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibGlzdGJveFwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkNvbXBsZXRpb25zXCIpKTtcbiAgICAgICAgbGV0IGN1clNlY3Rpb24gPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2UuZnJvbTsgaSA8IHJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24sIG1hdGNoIH0gPSBvcHRpb25zW2ldLCB7IHNlY3Rpb24gfSA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT0gY3VyU2VjdGlvbiAmJiAoaSA+IHJhbmdlLmZyb20gfHwgcmFuZ2UuZnJvbSA9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJTZWN0aW9uID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWN0aW9uICE9IFwic3RyaW5nXCIgJiYgc2VjdGlvbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVsLmFwcGVuZENoaWxkKHNlY3Rpb24uaGVhZGVyKHNlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoZWFkZXIgPSB1bC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY29tcGxldGlvbi1zZWN0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaSA9IHVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICAgICAgICBsaS5pZCA9IGlkICsgXCItXCIgKyBpO1xuICAgICAgICAgICAgbGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIGxldCBjbHMgPSB0aGlzLm9wdGlvbkNsYXNzKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBsaS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgdGhpcy5vcHRpb25Db250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBzb3VyY2UoY29tcGxldGlvbiwgdGhpcy52aWV3LnN0YXRlLCB0aGlzLnZpZXcsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmZyb20pXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wXCIpO1xuICAgICAgICBpZiAocmFuZ2UudG8gPCBvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b21cIik7XG4gICAgICAgIHJldHVybiB1bDtcbiAgICB9XG4gICAgZGVzdHJveUluZm8oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm9EZXN0cm95KVxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5mby5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBsZXRpb25Ub29sdGlwKHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgIHJldHVybiAodmlldykgPT4gbmV3IENvbXBsZXRpb25Ub29sdGlwKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzZWxmID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc2NhbGVZID0gcGFyZW50LmhlaWdodCAvIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKHNlbGYudG9wIDwgcGFyZW50LnRvcClcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCAtPSAocGFyZW50LnRvcCAtIHNlbGYudG9wKSAvIHNjYWxlWTtcbiAgICBlbHNlIGlmIChzZWxmLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gKHNlbGYuYm90dG9tIC0gcGFyZW50LmJvdHRvbSkgLyBzY2FsZVk7XG59XG5cbi8vIFVzZWQgdG8gcGljayBhIHByZWZlcnJlZCBvcHRpb24gd2hlbiB0d28gb3B0aW9ucyB3aXRoIHRoZSBzYW1lXG4vLyBsYWJlbCBvY2N1ciBpbiB0aGUgcmVzdWx0LlxuZnVuY3Rpb24gc2NvcmUob3B0aW9uKSB7XG4gICAgcmV0dXJuIChvcHRpb24uYm9vc3QgfHwgMCkgKiAxMDAgKyAob3B0aW9uLmFwcGx5ID8gMTAgOiAwKSArIChvcHRpb24uaW5mbyA/IDUgOiAwKSArXG4gICAgICAgIChvcHRpb24udHlwZSA/IDEgOiAwKTtcbn1cbmZ1bmN0aW9uIHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdO1xuICAgIGxldCBzZWN0aW9ucyA9IG51bGw7XG4gICAgbGV0IGFkZE9wdGlvbiA9IChvcHRpb24pID0+IHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKG9wdGlvbik7XG4gICAgICAgIGxldCB7IHNlY3Rpb24gfSA9IG9wdGlvbi5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgaWYgKCFzZWN0aW9ucylcbiAgICAgICAgICAgICAgICBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSB0eXBlb2Ygc2VjdGlvbiA9PSBcInN0cmluZ1wiID8gc2VjdGlvbiA6IHNlY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIGlmICghc2VjdGlvbnMuc29tZShzID0+IHMubmFtZSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHR5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyB7IG5hbWUgfSA6IHNlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGxldCBhIG9mIGFjdGl2ZSlcbiAgICAgICAgaWYgKGEuaGFzUmVzdWx0KCkpIHtcbiAgICAgICAgICAgIGxldCBnZXRNYXRjaCA9IGEucmVzdWx0LmdldE1hdGNoO1xuICAgICAgICAgICAgaWYgKGEucmVzdWx0LmZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgYS5yZXN1bHQub3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcHRpb24obmV3IE9wdGlvbihvcHRpb24sIGEuc291cmNlLCBnZXRNYXRjaCA/IGdldE1hdGNoKG9wdGlvbikgOiBbXSwgMWU5IC0gb3B0aW9ucy5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlciA9IG5ldyBGdXp6eU1hdGNoZXIoc3RhdGUuc2xpY2VEb2MoYS5mcm9tLCBhLnRvKSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIGEucmVzdWx0Lm9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyLm1hdGNoKG9wdGlvbi5sYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaGVkID0gIW9wdGlvbi5kaXNwbGF5TGFiZWwgPyBtYXRjaGVyLm1hdGNoZWQgOiBnZXRNYXRjaCA/IGdldE1hdGNoKG9wdGlvbiwgbWF0Y2hlci5tYXRjaGVkKSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW9uKG5ldyBPcHRpb24ob3B0aW9uLCBhLnNvdXJjZSwgbWF0Y2hlZCwgbWF0Y2hlci5zY29yZSArIChvcHRpb24uYm9vc3QgfHwgMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgaWYgKHNlY3Rpb25zKSB7XG4gICAgICAgIGxldCBzZWN0aW9uT3JkZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBwb3MgPSAwO1xuICAgICAgICBsZXQgY21wID0gKGEsIGIpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuICgoX2EgPSBhLnJhbmspICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDFlOSkgLSAoKF9iID0gYi5yYW5rKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxZTkpIHx8IChhLm5hbWUgPCBiLm5hbWUgPyAtMSA6IDEpOyB9O1xuICAgICAgICBmb3IgKGxldCBzIG9mIHNlY3Rpb25zLnNvcnQoY21wKSkge1xuICAgICAgICAgICAgcG9zIC09IDFlNTtcbiAgICAgICAgICAgIHNlY3Rpb25PcmRlcltzLm5hbWVdID0gcG9zO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBsZXQgeyBzZWN0aW9uIH0gPSBvcHRpb24uY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uKVxuICAgICAgICAgICAgICAgIG9wdGlvbi5zY29yZSArPSBzZWN0aW9uT3JkZXJbdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXSwgcHJldiA9IG51bGw7XG4gICAgbGV0IGNvbXBhcmUgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jb21wYXJlQ29tcGxldGlvbnM7XG4gICAgZm9yIChsZXQgb3B0IG9mIG9wdGlvbnMuc29ydCgoYSwgYikgPT4gKGIuc2NvcmUgLSBhLnNjb3JlKSB8fCBjb21wYXJlKGEuY29tcGxldGlvbiwgYi5jb21wbGV0aW9uKSkpIHtcbiAgICAgICAgbGV0IGN1ciA9IG9wdC5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5sYWJlbCAhPSBjdXIubGFiZWwgfHwgcHJldi5kZXRhaWwgIT0gY3VyLmRldGFpbCB8fFxuICAgICAgICAgICAgKHByZXYudHlwZSAhPSBudWxsICYmIGN1ci50eXBlICE9IG51bGwgJiYgcHJldi50eXBlICE9IGN1ci50eXBlKSB8fFxuICAgICAgICAgICAgcHJldi5hcHBseSAhPSBjdXIuYXBwbHkgfHwgcHJldi5ib29zdCAhPSBjdXIuYm9vc3QpXG4gICAgICAgICAgICByZXN1bHQucHVzaChvcHQpO1xuICAgICAgICBlbHNlIGlmIChzY29yZShvcHQuY29tcGxldGlvbikgPiBzY29yZShwcmV2KSlcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBvcHQ7XG4gICAgICAgIHByZXYgPSBvcHQuY29tcGxldGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIENvbXBsZXRpb25EaWFsb2cge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGF0dHJzLCB0b29sdGlwLCB0aW1lc3RhbXAsIHNlbGVjdGVkLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZCA9PSB0aGlzLnNlbGVjdGVkIHx8IHNlbGVjdGVkID49IHRoaXMub3B0aW9ucy5sZW5ndGggPyB0aGlzXG4gICAgICAgICAgICA6IG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCksIHRoaXMudG9vbHRpcCwgdGhpcy50aW1lc3RhbXAsIHNlbGVjdGVkLCB0aGlzLmRpc2FibGVkKTtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKGFjdGl2ZSwgc3RhdGUsIGlkLCBwcmV2LCBjb25mKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gc29ydE9wdGlvbnMoYWN0aXZlLCBzdGF0ZSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2ICYmIGFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pID9cbiAgICAgICAgICAgICAgICBuZXcgQ29tcGxldGlvbkRpYWxvZyhwcmV2Lm9wdGlvbnMsIHByZXYuYXR0cnMsIHByZXYudG9vbHRpcCwgcHJldi50aW1lc3RhbXAsIHByZXYuc2VsZWN0ZWQsIHRydWUpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5zZWxlY3RPbk9wZW4gPyAwIDogLTE7XG4gICAgICAgIGlmIChwcmV2ICYmIHByZXYuc2VsZWN0ZWQgIT0gc2VsZWN0ZWQgJiYgcHJldi5zZWxlY3RlZCAhPSAtMSkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkVmFsdWUgPSBwcmV2Lm9wdGlvbnNbcHJldi5zZWxlY3RlZF0uY29tcGxldGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1tpXS5jb21wbGV0aW9uID09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV0aW9uRGlhbG9nKG9wdGlvbnMsIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpLCB7XG4gICAgICAgICAgICBwb3M6IGFjdGl2ZS5yZWR1Y2UoKGEsIGIpID0+IGIuaGFzUmVzdWx0KCkgPyBNYXRoLm1pbihhLCBiLmZyb20pIDogYSwgMWU4KSxcbiAgICAgICAgICAgIGNyZWF0ZTogY3JlYXRlVG9vbHRpcCxcbiAgICAgICAgICAgIGFib3ZlOiBjb25mLmFib3ZlQ3Vyc29yLFxuICAgICAgICB9LCBwcmV2ID8gcHJldi50aW1lc3RhbXAgOiBEYXRlLm5vdygpLCBzZWxlY3RlZCwgZmFsc2UpO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCB0aGlzLmF0dHJzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMudG9vbHRpcCksIHsgcG9zOiBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvb2x0aXAucG9zKSB9KSwgdGhpcy50aW1lc3RhbXAsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuZGlzYWJsZWQpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBsZXRpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoYWN0aXZlLCBpZCwgb3Blbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBzdGF0aWMgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvblN0YXRlKG5vbmUsIFwiY20tYWMtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyZTYpLnRvU3RyaW5nKDM2KSwgbnVsbCk7XG4gICAgfVxuICAgIHVwZGF0ZSh0cikge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGNvbmYgPSBzdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IHNvdXJjZXMgPSBjb25mLm92ZXJyaWRlIHx8XG4gICAgICAgICAgICBzdGF0ZS5sYW5ndWFnZURhdGFBdChcImF1dG9jb21wbGV0ZVwiLCBjdXIoc3RhdGUpKS5tYXAoYXNTb3VyY2UpO1xuICAgICAgICBsZXQgYWN0aXZlID0gc291cmNlcy5tYXAoc291cmNlID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYWN0aXZlLmZpbmQocyA9PiBzLnNvdXJjZSA9PSBzb3VyY2UpIHx8XG4gICAgICAgICAgICAgICAgbmV3IEFjdGl2ZVNvdXJjZShzb3VyY2UsIHRoaXMuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pID8gMSAvKiBTdGF0ZS5QZW5kaW5nICovIDogMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoID09IHRoaXMuYWN0aXZlLmxlbmd0aCAmJiBhY3RpdmUuZXZlcnkoKGEsIGkpID0+IGEgPT0gdGhpcy5hY3RpdmVbaV0pKVxuICAgICAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5vcGVuO1xuICAgICAgICBpZiAob3BlbiAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgb3BlbiA9IG9wZW4ubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBpZiAodHIuc2VsZWN0aW9uIHx8IGFjdGl2ZS5zb21lKGEgPT4gYS5oYXNSZXN1bHQoKSAmJiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShhLmZyb20sIGEudG8pKSB8fFxuICAgICAgICAgICAgIXNhbWVSZXN1bHRzKGFjdGl2ZSwgdGhpcy5hY3RpdmUpKVxuICAgICAgICAgICAgb3BlbiA9IENvbXBsZXRpb25EaWFsb2cuYnVpbGQoYWN0aXZlLCBzdGF0ZSwgdGhpcy5pZCwgb3BlbiwgY29uZik7XG4gICAgICAgIGVsc2UgaWYgKG9wZW4gJiYgb3Blbi5kaXNhYmxlZCAmJiAhYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLykpXG4gICAgICAgICAgICBvcGVuID0gbnVsbDtcbiAgICAgICAgaWYgKCFvcGVuICYmIGFjdGl2ZS5ldmVyeShhID0+IGEuc3RhdGUgIT0gMSAvKiBTdGF0ZS5QZW5kaW5nICovKSAmJiBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkpKVxuICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLm1hcChhID0+IGEuaGFzUmVzdWx0KCkgPyBuZXcgQWN0aXZlU291cmNlKGEuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA6IGEpO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VsZWN0ZWRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIG9wZW4gPSBvcGVuICYmIG9wZW4uc2V0U2VsZWN0ZWQoZWZmZWN0LnZhbHVlLCB0aGlzLmlkKTtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZSA9PSB0aGlzLmFjdGl2ZSAmJiBvcGVuID09IHRoaXMub3BlbiA/IHRoaXMgOiBuZXcgQ29tcGxldGlvblN0YXRlKGFjdGl2ZSwgdGhpcy5pZCwgb3Blbik7XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLnRvb2x0aXAgOiBudWxsOyB9XG4gICAgZ2V0IGF0dHJzKCkgeyByZXR1cm4gdGhpcy5vcGVuID8gdGhpcy5vcGVuLmF0dHJzIDogYmFzZUF0dHJzOyB9XG59XG5mdW5jdGlvbiBzYW1lUmVzdWx0cyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICB3aGlsZSAoaUEgPCBhLmxlbmd0aCAmJiAhYVtpQV0uaGFzUmVzdWx0KVxuICAgICAgICAgICAgaUErKztcbiAgICAgICAgd2hpbGUgKGlCIDwgYi5sZW5ndGggJiYgIWJbaUJdLmhhc1Jlc3VsdClcbiAgICAgICAgICAgIGlCKys7XG4gICAgICAgIGxldCBlbmRBID0gaUEgPT0gYS5sZW5ndGgsIGVuZEIgPSBpQiA9PSBiLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZEEgfHwgZW5kQilcbiAgICAgICAgICAgIHJldHVybiBlbmRBID09IGVuZEI7XG4gICAgICAgIGlmIChhW2lBKytdLnJlc3VsdCAhPSBiW2lCKytdLnJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBiYXNlQXR0cnMgPSB7XG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIlxufTtcbmZ1bmN0aW9uIG1ha2VBdHRycyhpZCwgc2VsZWN0ZWQpIHtcbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiLFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogXCJsaXN0Ym94XCIsXG4gICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBpZFxuICAgIH07XG4gICAgaWYgKHNlbGVjdGVkID4gLTEpXG4gICAgICAgIHJlc3VsdFtcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiXSA9IGlkICsgXCItXCIgKyBzZWxlY3RlZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gZ2V0VXNlckV2ZW50KHRyKSB7XG4gICAgcmV0dXJuIHRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSA/IFwiaW5wdXRcIiA6IHRyLmlzVXNlckV2ZW50KFwiZGVsZXRlLmJhY2t3YXJkXCIpID8gXCJkZWxldGVcIiA6IG51bGw7XG59XG5jbGFzcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgc3RhdGUsIGV4cGxpY2l0UG9zID0gLTEpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5leHBsaWNpdFBvcyA9IGV4cGxpY2l0UG9zO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHVwZGF0ZSh0ciwgY29uZikge1xuICAgICAgICBsZXQgZXZlbnQgPSBnZXRVc2VyRXZlbnQodHIpLCB2YWx1ZSA9IHRoaXM7XG4gICAgICAgIGlmIChldmVudClcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuaGFuZGxlVXNlckV2ZW50KHRyLCBldmVudCwgY29uZik7XG4gICAgICAgIGVsc2UgaWYgKHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmhhbmRsZUNoYW5nZSh0cik7XG4gICAgICAgIGVsc2UgaWYgKHRyLnNlbGVjdGlvbiAmJiB2YWx1ZS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBlZmZlY3QudmFsdWUgPyBjdXIodHIuc3RhdGUpIDogLTEpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKGNsb3NlQ29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgZWZmZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnNvdXJjZSA9PSB2YWx1ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGhhbmRsZVVzZXJFdmVudCh0ciwgdHlwZSwgY29uZikge1xuICAgICAgICByZXR1cm4gdHlwZSA9PSBcImRlbGV0ZVwiIHx8ICFjb25mLmFjdGl2YXRlT25UeXBpbmcgPyB0aGlzLm1hcCh0ci5jaGFuZ2VzKSA6IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDEgLyogU3RhdGUuUGVuZGluZyAqLyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoY3VyKHRyLnN0YXJ0U3RhdGUpKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5IHx8IHRoaXMuZXhwbGljaXRQb3MgPCAwID8gdGhpcyA6IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIHRoaXMuc3RhdGUsIGNoYW5nZXMubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpKTtcbiAgICB9XG59XG5jbGFzcyBBY3RpdmVSZXN1bHQgZXh0ZW5kcyBBY3RpdmVTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZXhwbGljaXRQb3MsIHJlc3VsdCwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoc291cmNlLCAyIC8qIFN0YXRlLlJlc3VsdCAqLywgZXhwbGljaXRQb3MpO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBoYXNSZXN1bHQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaGFuZGxlVXNlckV2ZW50KHRyLCB0eXBlLCBjb25mKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGZyb20gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20pLCB0byA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpO1xuICAgICAgICBsZXQgcG9zID0gY3VyKHRyLnN0YXRlKTtcbiAgICAgICAgaWYgKCh0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IHBvcyA8PSBmcm9tIDogcG9zIDwgdGhpcy5mcm9tKSB8fFxuICAgICAgICAgICAgcG9zID4gdG8gfHxcbiAgICAgICAgICAgIHR5cGUgPT0gXCJkZWxldGVcIiAmJiBjdXIodHIuc3RhcnRTdGF0ZSkgPT0gdGhpcy5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIHR5cGUgPT0gXCJpbnB1dFwiICYmIGNvbmYuYWN0aXZhdGVPblR5cGluZyA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICBsZXQgZXhwbGljaXRQb3MgPSB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogdHIuY2hhbmdlcy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHVwZGF0ZWQ7XG4gICAgICAgIGlmIChjaGVja1ZhbGlkKHRoaXMucmVzdWx0LnZhbGlkRm9yLCB0ci5zdGF0ZSwgZnJvbSwgdG8pKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIGV4cGxpY2l0UG9zLCB0aGlzLnJlc3VsdCwgZnJvbSwgdG8pO1xuICAgICAgICBpZiAodGhpcy5yZXN1bHQudXBkYXRlICYmXG4gICAgICAgICAgICAodXBkYXRlZCA9IHRoaXMucmVzdWx0LnVwZGF0ZSh0aGlzLnJlc3VsdCwgZnJvbSwgdG8sIG5ldyBDb21wbGV0aW9uQ29udGV4dCh0ci5zdGF0ZSwgcG9zLCBleHBsaWNpdFBvcyA+PSAwKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIGV4cGxpY2l0UG9zLCB1cGRhdGVkLCB1cGRhdGVkLmZyb20sIChfYSA9IHVwZGF0ZWQudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cih0ci5zdGF0ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBleHBsaWNpdFBvcyk7XG4gICAgfVxuICAgIGhhbmRsZUNoYW5nZSh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKSA/IG5ldyBBY3RpdmVTb3VyY2UodGhpcy5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogdGhpcy5tYXAodHIuY2hhbmdlcyk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nLmVtcHR5ID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IC0xIDogbWFwcGluZy5tYXBQb3ModGhpcy5leHBsaWNpdFBvcyksIHRoaXMucmVzdWx0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmZyb20pLCBtYXBwaW5nLm1hcFBvcyh0aGlzLnRvLCAxKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tWYWxpZCh2YWxpZEZvciwgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgaWYgKCF2YWxpZEZvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIHJldHVybiB0eXBlb2YgdmFsaWRGb3IgPT0gXCJmdW5jdGlvblwiID8gdmFsaWRGb3IodGV4dCwgZnJvbSwgdG8sIHN0YXRlKSA6IGVuc3VyZUFuY2hvcih2YWxpZEZvciwgdHJ1ZSkudGVzdCh0ZXh0KTtcbn1cbmNvbnN0IHNldEFjdGl2ZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcChzb3VyY2VzLCBtYXBwaW5nKSB7IHJldHVybiBzb3VyY2VzLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKTsgfVxufSk7XG5jb25zdCBzZXRTZWxlY3RlZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGNvbXBsZXRpb25TdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gQ29tcGxldGlvblN0YXRlLnN0YXJ0KCk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikgeyByZXR1cm4gdmFsdWUudXBkYXRlKHRyKTsgfSxcbiAgICBwcm92aWRlOiBmID0+IFtcbiAgICAgICAgc2hvd1Rvb2x0aXAuZnJvbShmLCB2YWwgPT4gdmFsLnRvb2x0aXApLFxuICAgICAgICBFZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLmZyb20oZiwgc3RhdGUgPT4gc3RhdGUuYXR0cnMpXG4gICAgXVxufSk7XG5mdW5jdGlvbiBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uKSB7XG4gICAgY29uc3QgYXBwbHkgPSBvcHRpb24uY29tcGxldGlvbi5hcHBseSB8fCBvcHRpb24uY29tcGxldGlvbi5sYWJlbDtcbiAgICBsZXQgcmVzdWx0ID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gb3B0aW9uLnNvdXJjZSk7XG4gICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgQWN0aXZlUmVzdWx0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYXBwbHkgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgdmlldy5kaXNwYXRjaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc2VydENvbXBsZXRpb25UZXh0KHZpZXcuc3RhdGUsIGFwcGx5LCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKSksIHsgYW5ub3RhdGlvbnM6IHBpY2tlZENvbXBsZXRpb24ub2Yob3B0aW9uLmNvbXBsZXRpb24pIH0pKTtcbiAgICBlbHNlXG4gICAgICAgIGFwcGx5KHZpZXcsIG9wdGlvbi5jb21wbGV0aW9uLCByZXN1bHQuZnJvbSwgcmVzdWx0LnRvKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IGNyZWF0ZVRvb2x0aXAgPSAvKkBfX1BVUkVfXyovY29tcGxldGlvblRvb2x0aXAoY29tcGxldGlvblN0YXRlLCBhcHBseUNvbXBsZXRpb24pO1xuXG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgbW92ZXMgdGhlIGNvbXBsZXRpb24gc2VsZWN0aW9uIGZvcndhcmQgb3JcbmJhY2t3YXJkIGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4qL1xuZnVuY3Rpb24gbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZm9yd2FyZCwgYnkgPSBcIm9wdGlvblwiKSB7XG4gICAgcmV0dXJuICh2aWV3KSA9PiB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLm9wZW4gfHwgY1N0YXRlLm9wZW4uZGlzYWJsZWQgfHxcbiAgICAgICAgICAgIERhdGUubm93KCkgLSBjU3RhdGUub3Blbi50aW1lc3RhbXAgPCB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmludGVyYWN0aW9uRGVsYXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGVwID0gMSwgdG9vbHRpcDtcbiAgICAgICAgaWYgKGJ5ID09IFwicGFnZVwiICYmICh0b29sdGlwID0gZ2V0VG9vbHRpcCh2aWV3LCBjU3RhdGUub3Blbi50b29sdGlwKSkpXG4gICAgICAgICAgICBzdGVwID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcih0b29sdGlwLmRvbS5vZmZzZXRIZWlnaHQgL1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJsaVwiKS5vZmZzZXRIZWlnaHQpIC0gMSk7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gY1N0YXRlLm9wZW4ub3B0aW9ucztcbiAgICAgICAgbGV0IHNlbGVjdGVkID0gY1N0YXRlLm9wZW4uc2VsZWN0ZWQgPiAtMSA/IGNTdGF0ZS5vcGVuLnNlbGVjdGVkICsgc3RlcCAqIChmb3J3YXJkID8gMSA6IC0xKSA6IGZvcndhcmQgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHNlbGVjdGVkIDwgMClcbiAgICAgICAgICAgIHNlbGVjdGVkID0gYnkgPT0gXCJwYWdlXCIgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWQgPj0gbGVuZ3RoKVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBieSA9PSBcInBhZ2VcIiA/IGxlbmd0aCAtIDEgOiAwO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VsZWN0ZWRFZmZlY3Qub2Yoc2VsZWN0ZWQpIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BY2NlcHQgdGhlIGN1cnJlbnQgY29tcGxldGlvbi5cbiovXG5jb25zdCBhY2NlcHRDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSB8fCAhY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBjU3RhdGUub3Blbi5zZWxlY3RlZCA8IDAgfHwgY1N0YXRlLm9wZW4uZGlzYWJsZWQgfHxcbiAgICAgICAgRGF0ZS5ub3coKSAtIGNTdGF0ZS5vcGVuLnRpbWVzdGFtcCA8IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuaW50ZXJhY3Rpb25EZWxheSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBhcHBseUNvbXBsZXRpb24odmlldywgY1N0YXRlLm9wZW4ub3B0aW9uc1tjU3RhdGUub3Blbi5zZWxlY3RlZF0pO1xufTtcbi8qKlxuRXhwbGljaXRseSBzdGFydCBhdXRvY29tcGxldGlvbi5cbiovXG5jb25zdCBzdGFydENvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghY1N0YXRlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZih0cnVlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNsb3NlIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNvbXBsZXRpb24uXG4qL1xuY29uc3QgY2xvc2VDb21wbGV0aW9uID0gKHZpZXcpID0+IHtcbiAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWNTdGF0ZSB8fCAhY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY2xhc3MgUnVubmluZ1F1ZXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihhY3RpdmUsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudXBkYXRlcyA9IFtdO1xuICAgICAgICAvLyBOb3RlIHRoYXQgJ3VuZGVmaW5lZCcgbWVhbnMgJ25vdCBkb25lIHlldCcsIHdoZXJlYXMgJ251bGwnIG1lYW5zXG4gICAgICAgIC8vICdxdWVyeSByZXR1cm5lZCBudWxsJy5cbiAgICAgICAgdGhpcy5kb25lID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNvbnN0IE1heFVwZGF0ZUNvdW50ID0gNTAsIE1pbkFib3J0VGltZSA9IDEwMDA7XG5jb25zdCBjb21wbGV0aW9uUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSAtMTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gW107XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcbiAgICAgICAgZm9yIChsZXQgYWN0aXZlIG9mIHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKS5hY3RpdmUpXG4gICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkoYWN0aXZlKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGlmICghdXBkYXRlLnNlbGVjdGlvblNldCAmJiAhdXBkYXRlLmRvY0NoYW5nZWQgJiYgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb2VzUmVzZXQgPSB1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0ci5zZWxlY3Rpb24gfHwgdHIuZG9jQ2hhbmdlZCkgJiYgIWdldFVzZXJFdmVudCh0cik7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKGRvZXNSZXNldCB8fFxuICAgICAgICAgICAgICAgIHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoICsgdXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiBNYXhVcGRhdGVDb3VudCAmJiBEYXRlLm5vdygpIC0gcXVlcnkudGltZSA+IE1pbkFib3J0VGltZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxdWVyeS5jb250ZXh0LmFib3J0TGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeS51cGRhdGVzLnB1c2goLi4udXBkYXRlLnRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VVcGRhdGUgPiAtMSlcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVXBkYXRlKTtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5lZmZlY3RzLnNvbWUoZSA9PiBlLmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpKSlcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy5wZW5kaW5nU3RhcnQgPyA1MCA6IHVwZGF0ZS5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5hY3RpdmF0ZU9uVHlwaW5nRGVsYXk7XG4gICAgICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPSBjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLyAmJiAhdGhpcy5ydW5uaW5nLnNvbWUocSA9PiBxLmFjdGl2ZS5zb3VyY2UgPT0gYS5zb3VyY2UpKVxuICAgICAgICAgICAgPyBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnRVcGRhdGUoKSwgZGVsYXkpIDogLTE7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyAhPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLylcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHVwZGF0ZS50cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VXNlckV2ZW50KHRyKSA9PSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi87XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb21wb3NpbmcgPT0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi8gJiYgdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDMgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkQW5kTW92ZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VXBkYXRlKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiBjU3RhdGUuYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlLnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLyAmJiAhdGhpcy5ydW5uaW5nLnNvbWUociA9PiByLmFjdGl2ZS5zb3VyY2UgPT0gYWN0aXZlLnNvdXJjZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRRdWVyeShhY3RpdmUpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgcG9zID0gY3VyKHN0YXRlKTtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgQ29tcGxldGlvbkNvbnRleHQoc3RhdGUsIHBvcywgYWN0aXZlLmV4cGxpY2l0UG9zID09IHBvcyk7XG4gICAgICAgIGxldCBwZW5kaW5nID0gbmV3IFJ1bm5pbmdRdWVyeShhY3RpdmUsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcucHVzaChwZW5kaW5nKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGFjdGl2ZS5zb3VyY2UoY29udGV4dCkpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmICghcGVuZGluZy5jb250ZXh0LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLmRvbmUgPSByZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQWNjZXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NoZWR1bGVBY2NlcHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcuZXZlcnkocSA9PiBxLmRvbmUgIT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0IDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWNjZXB0KCksIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS51cGRhdGVTeW5jVGltZSk7XG4gICAgfVxuICAgIC8vIEZvciBlYWNoIGZpbmlzaGVkIHF1ZXJ5IGluIHRoaXMucnVubmluZywgdHJ5IHRvIGNyZWF0ZSBhIHJlc3VsdFxuICAgIC8vIG9yLCBpZiBhcHByb3ByaWF0ZSwgcmVzdGFydCB0aGUgcXVlcnkuXG4gICAgYWNjZXB0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0ID4gLTEpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZUFjY2VwdCk7XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBbXTtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICAgICAgICBpZiAocXVlcnkuZG9uZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVJlc3VsdChxdWVyeS5hY3RpdmUuc291cmNlLCBxdWVyeS5hY3RpdmUuZXhwbGljaXRQb3MsIHF1ZXJ5LmRvbmUsIHF1ZXJ5LmRvbmUuZnJvbSwgKF9hID0gcXVlcnkuZG9uZS50bykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VyKHF1ZXJ5LnVwZGF0ZXMubGVuZ3RoID8gcXVlcnkudXBkYXRlc1swXS5zdGFydFN0YXRlIDogdGhpcy52aWV3LnN0YXRlKSk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHRoZSB0cmFuc2FjdGlvbnMgdGhhdCBoYXBwZW5lZCBzaW5jZSB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBhbmQgc2VlIGlmIHRoYXQgcHJlc2VydmVzIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ciBvZiBxdWVyeS51cGRhdGVzKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gcXVlcnkuYWN0aXZlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LnN0YXRlID09IDEgLyogU3RhdGUuUGVuZGluZyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeS5kb25lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBmYWlsZWQuIFNob3VsZCBjbGVhciB0aGUgcGVuZGluZyBzdGF0dXMgaWYgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzbid0IGJlZW4gcmUtc2V0IGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IG5ldyBBY3RpdmVTb3VyY2UocXVlcnkuYWN0aXZlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHF1ZXJ5LnVwZGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZS5zdGF0ZSAhPSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLnB1c2goYWN0aXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyZWQgYnkgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMuIFJlc3RhcnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0QWN0aXZlRWZmZWN0Lm9mKHVwZGF0ZWQpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7XG4gICAgICAgIGJsdXIoZXZlbnQpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50b29sdGlwICYmIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5jbG9zZU9uQmx1cikge1xuICAgICAgICAgICAgICAgIGxldCBkaWFsb2cgPSBzdGF0ZS5vcGVuICYmIGdldFRvb2x0aXAodGhpcy52aWV3LCBzdGF0ZS5vcGVuLnRvb2x0aXApO1xuICAgICAgICAgICAgICAgIGlmICghZGlhbG9nIHx8ICFkaWFsb2cuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wb3NpdGlvbnN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAxIC8qIENvbXBvc2l0aW9uU3RhdGUuU3RhcnRlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9zaXRpb25lbmQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcgPT0gMyAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWRBbmRNb3ZlZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBjb21wb3NpdGlvbmVuZCBldmVudHMgc3luY2hyb25vdXNseSwgcG9zc2libHlcbiAgICAgICAgICAgICAgICAvLyBmcm9tIGluc2lkZSBhbiB1cGRhdGUsIHNvIGRpc3BhdGNoIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHJlZW50cmFuY3lcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHN0YXJ0Q29tcGxldGlvbkVmZmVjdC5vZihmYWxzZSkgfSksIDIwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMCAvKiBDb21wb3NpdGlvblN0YXRlLk5vbmUgKi87XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWxcIjoge1xuICAgICAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW4gYXV0b1wiLFxuICAgICAgICAgICAgbWF4V2lkdGhfZmFsbGJhY2s6IFwiNzAwcHhcIixcbiAgICAgICAgICAgIG1heFdpZHRoOiBcIm1pbig3MDBweCwgOTV2dylcIixcbiAgICAgICAgICAgIG1pbldpZHRoOiBcIjI1MHB4XCIsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTBlbVwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgICAgIGxpc3RTdHlsZTogXCJub25lXCIsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgXCImID4gbGksICYgPiBjb21wbGV0aW9uLXNlY3Rpb25cIjoge1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMXB4IDNweFwiLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiA+IGxpXCI6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1g6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCIsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiA+IGNvbXBsZXRpb24tc2VjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJsaXN0LWl0ZW1cIixcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiBcIjAuNWVtXCIsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC43XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzE3Y1wiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNzc3XCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzM0N1wiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUtZGlzYWJsZWQgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM0NDRcIixcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcDpiZWZvcmUsIC5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b206YWZ0ZXJcIjoge1xuICAgICAgICBjb250ZW50OiAnXCLCt8K3wrdcIicsXG4gICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAuY20tY29tcGxldGlvbkluZm9cIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjNweCA5cHhcIixcbiAgICAgICAgd2lkdGg6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgICAgbWF4V2lkdGg6IGAkezQwMCAvKiBJbmZvLldpZHRoICovfXB4YCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdFwiOiB7IHJpZ2h0OiBcIjEwMCVcIiB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLXJpZ2h0XCI6IHsgbGVmdDogXCIxMDAlXCIgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1sZWZ0LW5hcnJvd1wiOiB7IHJpZ2h0OiBgJHszMCAvKiBJbmZvLk1hcmdpbiAqL31weGAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1yaWdodC1uYXJyb3dcIjogeyBsZWZ0OiBgJHszMCAvKiBJbmZvLk1hcmdpbiAqL31weGAgfSxcbiAgICBcIiZsaWdodCAuY20tc25pcHBldEZpZWxkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMwMDAwMDAyMlwiIH0sXG4gICAgXCImZGFyayAuY20tc25pcHBldEZpZWxkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmZmYyMlwiIH0sXG4gICAgXCIuY20tc25pcHBldEZpZWxkUG9zaXRpb25cIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRleHQtdG9wXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IFwiMS4xNWVtXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIG1hcmdpbjogXCIwIC0wLjdweCAtLjdlbVwiLFxuICAgICAgICBib3JkZXJMZWZ0OiBcIjEuNHB4IGRvdHRlZCAjODg4XCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25NYXRjaGVkVGV4dFwiOiB7XG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uRGV0YWlsXCI6IHtcbiAgICAgICAgbWFyZ2luTGVmdDogXCIwLjVlbVwiLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uXCI6IHtcbiAgICAgICAgZm9udFNpemU6IFwiOTAlXCIsXG4gICAgICAgIHdpZHRoOiBcIi44ZW1cIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IFwiLjZlbVwiLFxuICAgICAgICBvcGFjaXR5OiBcIjAuNlwiLFxuICAgICAgICBib3hTaXppbmc6IFwiY29udGVudC1ib3hcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tZnVuY3Rpb24sIC5jbS1jb21wbGV0aW9uSWNvbi1tZXRob2RcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifGkidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1jbGFzc1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KXiydcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1pbnRlcmZhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifil4wnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdmFyaWFibGVcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGlJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNvbnN0YW50XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2QtidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10eXBlXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn8J2RoSdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1lbnVtXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4oiqJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXByb3BlcnR5XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4pahJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWtleXdvcmRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwn5SRXFx1RkUwRSdcIiB9IC8vIERpc2FibGUgZW1vamkgcmVuZGVyaW5nXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1uYW1lc3BhY2VcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifilqInXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tdGV4dFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ2FiYydcIiwgZm9udFNpemU6IFwiNTAlXCIsIHZlcnRpY2FsQWxpZ246IFwibWlkZGxlXCIgfVxuICAgIH1cbn0pO1xuXG5jbGFzcyBGaWVsZFBvcyB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGxpbmUsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmNsYXNzIEZpZWxkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb20gPSBjaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20sIC0xLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgbGV0IHRvID0gY2hhbmdlcy5tYXBQb3ModGhpcy50bywgMSwgTWFwTW9kZS5UcmFja0RlbCk7XG4gICAgICAgIHJldHVybiBmcm9tID09IG51bGwgfHwgdG8gPT0gbnVsbCA/IG51bGwgOiBuZXcgRmllbGRSYW5nZSh0aGlzLmZpZWxkLCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IobGluZXMsIGZpZWxkUG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5maWVsZFBvc2l0aW9ucyA9IGZpZWxkUG9zaXRpb25zO1xuICAgIH1cbiAgICBpbnN0YW50aWF0ZShzdGF0ZSwgcG9zKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gW10sIGxpbmVTdGFydCA9IFtwb3NdO1xuICAgICAgICBsZXQgbGluZU9iaiA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgYmFzZUluZGVudCA9IC9eXFxzKi8uZXhlYyhsaW5lT2JqLnRleHQpWzBdO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMubGluZXMpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSBiYXNlSW5kZW50LCB0YWJzID0gL15cXHQqLy5leGVjKGxpbmUpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnM7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydC5wdXNoKHBvcyArIGluZGVudC5sZW5ndGggLSB0YWJzKTtcbiAgICAgICAgICAgICAgICBsaW5lID0gaW5kZW50ICsgbGluZS5zbGljZSh0YWJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMuZmllbGRQb3NpdGlvbnMubWFwKHBvcyA9PiBuZXcgRmllbGRSYW5nZShwb3MuZmllbGQsIGxpbmVTdGFydFtwb3MubGluZV0gKyBwb3MuZnJvbSwgbGluZVN0YXJ0W3Bvcy5saW5lXSArIHBvcy50bykpO1xuICAgICAgICByZXR1cm4geyB0ZXh0LCByYW5nZXMgfTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHRlbXBsYXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGxpbmVzID0gW10sIHBvc2l0aW9ucyA9IFtdLCBtO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRlbXBsYXRlLnNwbGl0KC9cXHJcXG4/fFxcbi8pKSB7XG4gICAgICAgICAgICB3aGlsZSAobSA9IC9bIyRdXFx7KD86KFxcZCspKD86OihbXn1dKikpP3woW159XSopKVxcfS8uZXhlYyhsaW5lKSkge1xuICAgICAgICAgICAgICAgIGxldCBzZXEgPSBtWzFdID8gK21bMV0gOiBudWxsLCBuYW1lID0gbVsyXSB8fCBtWzNdIHx8IFwiXCIsIGZvdW5kID0gLTE7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcSAhPSBudWxsID8gZmllbGRzW2ldLnNlcSA9PSBzZXEgOiBuYW1lID8gZmllbGRzW2ldLm5hbWUgPT0gbmFtZSA6IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBmaWVsZHMubGVuZ3RoICYmIChzZXEgPT0gbnVsbCB8fCAoZmllbGRzW2ldLnNlcSAhPSBudWxsICYmIGZpZWxkc1tpXS5zZXEgPCBzZXEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnNwbGljZShpLCAwLCB7IHNlcSwgbmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5maWVsZCA+PSBmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MuZmllbGQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IEZpZWxkUG9zKGZvdW5kLCBsaW5lcy5sZW5ndGgsIG0uaW5kZXgsIG0uaW5kZXggKyBuYW1lLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIG0uaW5kZXgpICsgbmFtZSArIGxpbmUuc2xpY2UobS5pbmRleCArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGVzYzsgZXNjID0gL1xcXFwoW3t9XSkvLmV4ZWMobGluZSk7KSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgZXNjLmluZGV4KSArIGVzY1sxXSArIGxpbmUuc2xpY2UoZXNjLmluZGV4ICsgZXNjWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5saW5lID09IGxpbmVzLmxlbmd0aCAmJiBwb3MuZnJvbSA+IGVzYy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZyb20tLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy50by0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU25pcHBldChsaW5lcywgcG9zaXRpb25zKTtcbiAgICB9XG59XG5sZXQgZmllbGRNYXJrZXIgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi53aWRnZXQoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00oKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfSB9KTtcbmxldCBmaWVsZFJhbmdlID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNuaXBwZXRGaWVsZFwiIH0pO1xuY2xhc3MgQWN0aXZlU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2VzLCBhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmRlY28gPSBEZWNvcmF0aW9uLnNldChyYW5nZXMubWFwKHIgPT4gKHIuZnJvbSA9PSByLnRvID8gZmllbGRNYXJrZXIgOiBmaWVsZFJhbmdlKS5yYW5nZShyLmZyb20sIHIudG8pKSk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHIubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCFtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIHRoaXMuYWN0aXZlKTtcbiAgICB9XG4gICAgc2VsZWN0aW9uSW5zaWRlRmllbGQoc2VsKSB7XG4gICAgICAgIHJldHVybiBzZWwucmFuZ2VzLmV2ZXJ5KHJhbmdlID0+IHRoaXMucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IHRoaXMuYWN0aXZlICYmIHIuZnJvbSA8PSByYW5nZS5mcm9tICYmIHIudG8gPj0gcmFuZ2UudG8pKTtcbiAgICB9XG59XG5jb25zdCBzZXRBY3RpdmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIGNoYW5nZXMpIHsgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm1hcChjaGFuZ2VzKTsgfVxufSk7XG5jb25zdCBtb3ZlVG9GaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNuaXBwZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMobW92ZVRvRmllbGQpICYmIHZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldCh2YWx1ZS5yYW5nZXMsIGVmZmVjdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLnNlbGVjdGlvbiAmJiAhdmFsdWUuc2VsZWN0aW9uSW5zaWRlRmllbGQodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgdmFsID0+IHZhbCA/IHZhbC5kZWNvIDogRGVjb3JhdGlvbi5ub25lKVxufSk7XG5mdW5jdGlvbiBmaWVsZFNlbGVjdGlvbihyYW5nZXMsIGZpZWxkKSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmZpbHRlcihyID0+IHIuZmllbGQgPT0gZmllbGQpLm1hcChyID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmZyb20sIHIudG8pKSk7XG59XG4vKipcbkNvbnZlcnQgYSBzbmlwcGV0IHRlbXBsYXRlIHRvIGEgZnVuY3Rpb24gdGhhdCBjYW5cblthcHBseV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvbi5hcHBseSkgaXQuIFNuaXBwZXRzIGFyZSB3cml0dGVuXG51c2luZyBzeW50YXggbGlrZSB0aGlzOlxuXG4gICAgXCJmb3IgKGxldCAke2luZGV4fSA9IDA7ICR7aW5kZXh9IDwgJHtlbmR9OyAke2luZGV4fSsrKSB7XFxuXFx0JHt9XFxufVwiXG5cbkVhY2ggYCR7fWAgcGxhY2Vob2xkZXIgKHlvdSBtYXkgYWxzbyB1c2UgYCN7fWApIGluZGljYXRlcyBhIGZpZWxkXG50aGF0IHRoZSB1c2VyIGNhbiBmaWxsIGluLiBJdHMgbmFtZSwgaWYgYW55LCB3aWxsIGJlIHRoZSBkZWZhdWx0XG5jb250ZW50IGZvciB0aGUgZmllbGQuXG5cbldoZW4gdGhlIHNuaXBwZXQgaXMgYWN0aXZhdGVkIGJ5IGNhbGxpbmcgdGhlIHJldHVybmVkIGZ1bmN0aW9uLFxudGhlIGNvZGUgaXMgaW5zZXJ0ZWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBOZXdsaW5lcyBpbiB0aGVcbnRlbXBsYXRlIGFyZSBpbmRlbnRlZCBieSB0aGUgaW5kZW50YXRpb24gb2YgdGhlIHN0YXJ0IGxpbmUsIHBsdXNcbm9uZSBbaW5kZW50IHVuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgcGVyIHRhYiBjaGFyYWN0ZXIgYWZ0ZXJcbnRoZSBuZXdsaW5lLlxuXG5PbiBhY3RpdmF0aW9uLCAoYWxsIGluc3RhbmNlcyBvZikgdGhlIGZpcnN0IGZpZWxkIGFyZSBzZWxlY3RlZC5cblRoZSB1c2VyIGNhbiBtb3ZlIGJldHdlZW4gZmllbGRzIHdpdGggVGFiIGFuZCBTaGlmdC1UYWIgYXMgbG9uZyBhc1xudGhlIGZpZWxkcyBhcmUgYWN0aXZlLiBNb3ZpbmcgdG8gdGhlIGxhc3QgZmllbGQgb3IgbW92aW5nIHRoZVxuY3Vyc29yIG91dCBvZiB0aGUgY3VycmVudCBmaWVsZCBkZWFjdGl2YXRlcyB0aGUgZmllbGRzLlxuXG5UaGUgb3JkZXIgb2YgZmllbGRzIGRlZmF1bHRzIHRvIHRleHR1YWwgb3JkZXIsIGJ1dCB5b3UgY2FuIGFkZFxubnVtYmVycyB0byBwbGFjZWhvbGRlcnMgKGAkezF9YCBvciBgJHsxOmRlZmF1bHRUZXh0fWApIHRvIHByb3ZpZGVcbmEgY3VzdG9tIG9yZGVyLlxuXG5UbyBpbmNsdWRlIGEgbGl0ZXJhbCBge2Agb3IgYH1gIGluIHlvdXIgdGVtcGxhdGUsIHB1dCBhIGJhY2tzbGFzaFxuaW4gZnJvbnQgb2YgaXQuIFRoaXMgd2lsbCBiZSByZW1vdmVkIGFuZCB0aGUgYnJhY2Ugd2lsbCBub3QgYmVcbmludGVycHJldGVkIGFzIGluZGljYXRpbmcgYSBwbGFjZWhvbGRlci5cbiovXG5mdW5jdGlvbiBzbmlwcGV0KHRlbXBsYXRlKSB7XG4gICAgbGV0IHNuaXBwZXQgPSBTbmlwcGV0LnBhcnNlKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gKGVkaXRvciwgY29tcGxldGlvbiwgZnJvbSwgdG8pID0+IHtcbiAgICAgICAgbGV0IHsgdGV4dCwgcmFuZ2VzIH0gPSBzbmlwcGV0Lmluc3RhbnRpYXRlKGVkaXRvci5zdGF0ZSwgZnJvbSk7XG4gICAgICAgIGxldCBzcGVjID0ge1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKHRleHQpIH0sXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIGFubm90YXRpb25zOiBjb21wbGV0aW9uID8gW3BpY2tlZENvbXBsZXRpb24ub2YoY29tcGxldGlvbiksIFRyYW5zYWN0aW9uLnVzZXJFdmVudC5vZihcImlucHV0LmNvbXBsZXRlXCIpXSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMuc2VsZWN0aW9uID0gZmllbGRTZWxlY3Rpb24ocmFuZ2VzLCAwKTtcbiAgICAgICAgaWYgKHJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA+IDApKSB7XG4gICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVNuaXBwZXQocmFuZ2VzLCAwKTtcbiAgICAgICAgICAgIGxldCBlZmZlY3RzID0gc3BlYy5lZmZlY3RzID0gW3NldEFjdGl2ZS5vZihhY3RpdmUpXTtcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKFtzbmlwcGV0U3RhdGUsIGFkZFNuaXBwZXRLZXltYXAsIHNuaXBwZXRQb2ludGVySGFuZGxlciwgYmFzZVRoZW1lXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaChlZGl0b3Iuc3RhdGUudXBkYXRlKHNwZWMpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZUZpZWxkKGRpcikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghYWN0aXZlIHx8IGRpciA8IDAgJiYgYWN0aXZlLmFjdGl2ZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbmV4dCA9IGFjdGl2ZS5hY3RpdmUgKyBkaXIsIGxhc3QgPSBkaXIgPiAwICYmICFhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IG5leHQgKyBkaXIpO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBuZXh0KSxcbiAgICAgICAgICAgIGVmZmVjdHM6IHNldEFjdGl2ZS5vZihsYXN0ID8gbnVsbCA6IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG5leHQpKSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQSBjb21tYW5kIHRoYXQgY2xlYXJzIHRoZSBhY3RpdmUgc25pcHBldCwgaWYgYW55LlxuKi9cbmNvbnN0IGNsZWFyU25pcHBldCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGFjdGl2ZSA9IHN0YXRlLmZpZWxkKHNuaXBwZXRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghYWN0aXZlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgZWZmZWN0czogc2V0QWN0aXZlLm9mKG51bGwpIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdG8gdGhlIG5leHQgc25pcHBldCBmaWVsZCwgaWYgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IG5leHRTbmlwcGV0RmllbGQgPSAvKkBfX1BVUkVfXyovbW92ZUZpZWxkKDEpO1xuLyoqXG5Nb3ZlIHRvIHRoZSBwcmV2aW91cyBzbmlwcGV0IGZpZWxkLCBpZiBhdmFpbGFibGUuXG4qL1xuY29uc3QgcHJldlNuaXBwZXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9tb3ZlRmllbGQoLTEpO1xuLyoqXG5DaGVjayBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgc25pcHBldCB3aXRoIGEgbmV4dCBmaWVsZCBmb3JcbmBuZXh0U25pcHBldEZpZWxkYCB0byBtb3ZlIHRvLlxuKi9cbmZ1bmN0aW9uIGhhc05leHRTbmlwcGV0RmllbGQoc3RhdGUpIHtcbiAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuICEhKGFjdGl2ZSAmJiBhY3RpdmUucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IGFjdGl2ZS5hY3RpdmUgKyAxKSk7XG59XG4vKipcblJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgc25pcHBldCBhbmQgYSBwcmV2aW91cyBmaWVsZFxuZm9yIGBwcmV2U25pcHBldEZpZWxkYCB0byBtb3ZlIHRvLlxuKi9cbmZ1bmN0aW9uIGhhc1ByZXZTbmlwcGV0RmllbGQoc3RhdGUpIHtcbiAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuICEhKGFjdGl2ZSAmJiBhY3RpdmUuYWN0aXZlID4gMCk7XG59XG5jb25zdCBkZWZhdWx0U25pcHBldEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJUYWJcIiwgcnVuOiBuZXh0U25pcHBldEZpZWxkLCBzaGlmdDogcHJldlNuaXBwZXRGaWVsZCB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IGNsZWFyU25pcHBldCB9XG5dO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHRoZSBrZXkgYmluZGluZ3MgdXNlZCBieVxuc25pcHBldHMuIFRoZSBkZWZhdWx0IGJpbmRzIFRhYiB0b1xuW2BuZXh0U25pcHBldEZpZWxkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubmV4dFNuaXBwZXRGaWVsZCksIFNoaWZ0LVRhYiB0b1xuW2BwcmV2U25pcHBldEZpZWxkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUucHJldlNuaXBwZXRGaWVsZCksIGFuZCBFc2NhcGVcbnRvIFtgY2xlYXJTbmlwcGV0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xlYXJTbmlwcGV0KS5cbiovXG5jb25zdCBzbmlwcGV0S2V5bWFwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShtYXBzKSB7IHJldHVybiBtYXBzLmxlbmd0aCA/IG1hcHNbMF0gOiBkZWZhdWx0U25pcHBldEtleW1hcDsgfVxufSk7XG5jb25zdCBhZGRTbmlwcGV0S2V5bWFwID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyova2V5bWFwLmNvbXB1dGUoW3NuaXBwZXRLZXltYXBdLCBzdGF0ZSA9PiBzdGF0ZS5mYWNldChzbmlwcGV0S2V5bWFwKSkpO1xuLyoqXG5DcmVhdGUgYSBjb21wbGV0aW9uIGZyb20gYSBzbmlwcGV0LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZVxucHJvcGVydGllcyBmcm9tIGBjb21wbGV0aW9uYCwgcGx1cyBhbiBgYXBwbHlgIGZ1bmN0aW9uIHRoYXRcbmFwcGxpZXMgdGhlIHNuaXBwZXQuXG4qL1xuZnVuY3Rpb24gc25pcHBldENvbXBsZXRpb24odGVtcGxhdGUsIGNvbXBsZXRpb24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb21wbGV0aW9uKSwgeyBhcHBseTogc25pcHBldCh0ZW1wbGF0ZSkgfSk7XG59XG5jb25zdCBzbmlwcGV0UG9pbnRlckhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICBtb3VzZWRvd24oZXZlbnQsIHZpZXcpIHtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHZpZXcuc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSksIHBvcztcbiAgICAgICAgaWYgKCFhY3RpdmUgfHwgKHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pKSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgbWF0Y2ggPSBhY3RpdmUucmFuZ2VzLmZpbmQociA9PiByLmZyb20gPD0gcG9zICYmIHIudG8gPj0gcG9zKTtcbiAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaC5maWVsZCA9PSBhY3RpdmUuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogZmllbGRTZWxlY3Rpb24oYWN0aXZlLnJhbmdlcywgbWF0Y2guZmllbGQpLFxuICAgICAgICAgICAgZWZmZWN0czogc2V0QWN0aXZlLm9mKGFjdGl2ZS5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPiBtYXRjaC5maWVsZClcbiAgICAgICAgICAgICAgICA/IG5ldyBBY3RpdmVTbmlwcGV0KGFjdGl2ZS5yYW5nZXMsIG1hdGNoLmZpZWxkKSA6IG51bGwpLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiB3b3JkUkUod29yZENoYXJzKSB7XG4gICAgbGV0IGVzY2FwZWQgPSB3b3JkQ2hhcnMucmVwbGFjZSgvW1xcXVxcLVxcXFxdL2csIFwiXFxcXCQmXCIpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBbXFxcXHB7QWxwaGFiZXRpY31cXFxccHtOdW1iZXJ9XyR7ZXNjYXBlZH1dK2AsIFwidWdcIik7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgW1xcdyR7ZXNjYXBlZH1dYCwgXCJnXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFJFKHJlLCBmKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoZihyZS5zb3VyY2UpLCByZS51bmljb2RlID8gXCJ1XCIgOiBcIlwiKTtcbn1cbmNvbnN0IHdvcmRDYWNoZXMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIHdvcmRDYWNoZSh3b3JkQ2hhcnMpIHtcbiAgICByZXR1cm4gd29yZENhY2hlc1t3b3JkQ2hhcnNdIHx8ICh3b3JkQ2FjaGVzW3dvcmRDaGFyc10gPSBuZXcgV2Vha01hcCk7XG59XG5mdW5jdGlvbiBzdG9yZVdvcmRzKGRvYywgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0KSB7XG4gICAgZm9yIChsZXQgbGluZXMgPSBkb2MuaXRlckxpbmVzKCksIHBvcyA9IDA7ICFsaW5lcy5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgbGV0IHsgdmFsdWUgfSA9IGxpbmVzLCBtO1xuICAgICAgICB3b3JkUkUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKG0gPSB3b3JkUkUuZXhlYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghc2VlblttWzBdXSAmJiBwb3MgKyBtLmluZGV4ICE9IGlnbm9yZUF0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyB0eXBlOiBcInRleHRcIiwgbGFiZWw6IG1bMF0gfSk7XG4gICAgICAgICAgICAgICAgc2VlblttWzBdXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPj0gMjAwMCAvKiBDLk1heExpc3QgKi8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gdmFsdWUubGVuZ3RoICsgMTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0V29yZHMoZG9jLCBjYWNoZSwgd29yZFJFLCB0bywgaWdub3JlQXQpIHtcbiAgICBsZXQgYmlnID0gZG9jLmxlbmd0aCA+PSAxMDAwIC8qIEMuTWluQ2FjaGVMZW4gKi87XG4gICAgbGV0IGNhY2hlZCA9IGJpZyAmJiBjYWNoZS5nZXQoZG9jKTtcbiAgICBpZiAoY2FjaGVkKVxuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIGxldCByZXN1bHQgPSBbXSwgc2VlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGRvYy5jaGlsZHJlbikge1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgZG9jLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2gubGVuZ3RoID49IDEwMDAgLyogQy5NaW5DYWNoZUxlbiAqLykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY29sbGVjdFdvcmRzKGNoLCBjYWNoZSwgd29yZFJFLCB0byAtIHBvcywgaWdub3JlQXQgLSBwb3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VlbltjLmxhYmVsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VlbltjLmxhYmVsXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlV29yZHMoY2gsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCAtIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gY2gubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RvcmVXb3Jkcyhkb2MsIHdvcmRSRSwgcmVzdWx0LCBzZWVuLCBpZ25vcmVBdCk7XG4gICAgfVxuICAgIGlmIChiaWcgJiYgcmVzdWx0Lmxlbmd0aCA8IDIwMDAgLyogQy5NYXhMaXN0ICovKVxuICAgICAgICBjYWNoZS5zZXQoZG9jLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkEgY29tcGxldGlvbiBzb3VyY2UgdGhhdCB3aWxsIHNjYW4gdGhlIGRvY3VtZW50IGZvciB3b3JkcyAodXNpbmcgYVxuW2NoYXJhY3RlciBjYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpKSwgYW5kXG5yZXR1cm4gdGhvc2UgYXMgY29tcGxldGlvbnMuXG4qL1xuY29uc3QgY29tcGxldGVBbnlXb3JkID0gY29udGV4dCA9PiB7XG4gICAgbGV0IHdvcmRDaGFycyA9IGNvbnRleHQuc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgY29udGV4dC5wb3MpLmpvaW4oXCJcIik7XG4gICAgbGV0IHJlID0gd29yZFJFKHdvcmRDaGFycyk7XG4gICAgbGV0IHRva2VuID0gY29udGV4dC5tYXRjaEJlZm9yZShtYXBSRShyZSwgcyA9PiBzICsgXCIkXCIpKTtcbiAgICBpZiAoIXRva2VuICYmICFjb250ZXh0LmV4cGxpY2l0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZnJvbSA9IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zO1xuICAgIGxldCBvcHRpb25zID0gY29sbGVjdFdvcmRzKGNvbnRleHQuc3RhdGUuZG9jLCB3b3JkQ2FjaGUod29yZENoYXJzKSwgcmUsIDUwMDAwIC8qIEMuUmFuZ2UgKi8sIGZyb20pO1xuICAgIHJldHVybiB7IGZyb20sIG9wdGlvbnMsIHZhbGlkRm9yOiBtYXBSRShyZSwgcyA9PiBcIl5cIiArIHMpIH07XG59O1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgICBicmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsIFwiJ1wiLCAnXCInXSxcbiAgICBiZWZvcmU6IFwiKV19Ojs+XCIsXG4gICAgc3RyaW5nUHJlZml4ZXM6IFtdXG59O1xuY29uc3QgY2xvc2VCcmFja2V0RWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHZhbHVlLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSBtYXBwaW5nLm1hcFBvcyh2YWx1ZSwgLTEsIE1hcE1vZGUuVHJhY2tBZnRlcik7XG4gICAgICAgIHJldHVybiBtYXBwZWQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG1hcHBlZDtcbiAgICB9XG59KTtcbmNvbnN0IGNsb3NlZEJyYWNrZXQgPSAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG59O1xuY2xvc2VkQnJhY2tldC5zdGFydFNpZGUgPSAxO1xuY2xvc2VkQnJhY2tldC5lbmRTaWRlID0gLTE7XG5jb25zdCBicmFja2V0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIFJhbmdlU2V0LmVtcHR5OyB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdHIuc3RhdGUuZG9jLmxpbmVBdCh0ci5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlKHsgZmlsdGVyOiBmcm9tID0+IGZyb20gPj0gbGluZS5mcm9tICYmIGZyb20gPD0gbGluZS50byB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VCcmFja2V0RWZmZWN0KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZSh7IGFkZDogW2Nsb3NlZEJyYWNrZXQucmFuZ2UoZWZmZWN0LnZhbHVlLCBlZmZlY3QudmFsdWUgKyAxKV0gfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59KTtcbi8qKlxuRXh0ZW5zaW9uIHRvIGVuYWJsZSBicmFja2V0LWNsb3NpbmcgYmVoYXZpb3IuIFdoZW4gYSBjbG9zZWFibGVcbmJyYWNrZXQgaXMgdHlwZWQsIGl0cyBjbG9zaW5nIGJyYWNrZXQgaXMgaW1tZWRpYXRlbHkgaW5zZXJ0ZWRcbmFmdGVyIHRoZSBjdXJzb3IuIFdoZW4gY2xvc2luZyBhIGJyYWNrZXQgZGlyZWN0bHkgaW4gZnJvbnQgb2YgYVxuY2xvc2luZyBicmFja2V0IGluc2VydGVkIGJ5IHRoZSBleHRlbnNpb24sIHRoZSBjdXJzb3IgbW92ZXMgb3ZlclxudGhhdCBicmFja2V0LlxuKi9cbmZ1bmN0aW9uIGNsb3NlQnJhY2tldHMoKSB7XG4gICAgcmV0dXJuIFtpbnB1dEhhbmRsZXIsIGJyYWNrZXRTdGF0ZV07XG59XG5jb25zdCBkZWZpbmVkQ2xvc2luZyA9IFwiKClbXXt9PD5cIjtcbmZ1bmN0aW9uIGNsb3NpbmcoY2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmluZWRDbG9zaW5nLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBpZiAoZGVmaW5lZENsb3NpbmcuY2hhckNvZGVBdChpKSA9PSBjaClcbiAgICAgICAgICAgIHJldHVybiBkZWZpbmVkQ2xvc2luZy5jaGFyQXQoaSArIDEpO1xuICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNoIDwgMTI4ID8gY2ggOiBjaCArIDEpO1xufVxuZnVuY3Rpb24gY29uZmlnKHN0YXRlLCBwb3MpIHtcbiAgICByZXR1cm4gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjbG9zZUJyYWNrZXRzXCIsIHBvcylbMF0gfHwgZGVmYXVsdHM7XG59XG5jb25zdCBhbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IGlucHV0SGFuZGxlciA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmlucHV0SGFuZGxlci5vZigodmlldywgZnJvbSwgdG8sIGluc2VydCkgPT4ge1xuICAgIGlmICgoYW5kcm9pZCA/IHZpZXcuY29tcG9zaW5nIDogdmlldy5jb21wb3NpdGlvblN0YXJ0ZWQpIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoaW5zZXJ0Lmxlbmd0aCA+IDIgfHwgaW5zZXJ0Lmxlbmd0aCA9PSAyICYmIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQoaW5zZXJ0LCAwKSkgPT0gMSB8fFxuICAgICAgICBmcm9tICE9IHNlbC5mcm9tIHx8IHRvICE9IHNlbC50bylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0ciA9IGluc2VydEJyYWNrZXQodmlldy5zdGF0ZSwgaW5zZXJ0KTtcbiAgICBpZiAoIXRyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuQ29tbWFuZCB0aGF0IGltcGxlbWVudHMgZGVsZXRpbmcgYSBwYWlyIG9mIG1hdGNoaW5nIGJyYWNrZXRzIHdoZW5cbnRoZSBjdXJzb3IgaXMgYmV0d2VlbiB0aGVtLlxuKi9cbmNvbnN0IGRlbGV0ZUJyYWNrZXRQYWlyID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY29uZiA9IGNvbmZpZyhzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgbGV0IHRva2VucyA9IGNvbmYuYnJhY2tldHMgfHwgZGVmYXVsdHMuYnJhY2tldHM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHByZXZDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gYmVmb3JlICYmIG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCkgPT0gY2xvc2luZyhjb2RlUG9pbnRBdCh0b2tlbiwgMCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmhlYWQgLSB0b2tlbi5sZW5ndGgsIHRvOiByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICBpZiAoIWRvbnQpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiZGVsZXRlLmJhY2t3YXJkXCIgfSkpO1xuICAgIHJldHVybiAhZG9udDtcbn07XG4vKipcbkNsb3NlLWJyYWNrZXRzIHJlbGF0ZWQga2V5IGJpbmRpbmdzLiBCaW5kcyBCYWNrc3BhY2UgdG9cbltgZGVsZXRlQnJhY2tldFBhaXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5kZWxldGVCcmFja2V0UGFpcikuXG4qL1xuY29uc3QgY2xvc2VCcmFja2V0c0tleW1hcCA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVCcmFja2V0UGFpciB9XG5dO1xuLyoqXG5JbXBsZW1lbnRzIHRoZSBleHRlbnNpb24ncyBiZWhhdmlvciBvbiB0ZXh0IGluc2VydGlvbi4gSWYgdGhlXG5naXZlbiBzdHJpbmcgY291bnRzIGFzIGEgYnJhY2tldCBpbiB0aGUgbGFuZ3VhZ2UgYXJvdW5kIHRoZVxuc2VsZWN0aW9uLCBhbmQgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBpdCByZXF1aXJlcyBjdXN0b21cbmJlaGF2aW9yIChpbnNlcnRpbmcgYSBjbG9zaW5nIHZlcnNpb24gb3Igc2tpcHBpbmcgcGFzdCBhXG5wcmV2aW91c2x5LWNsb3NlZCBicmFja2V0KSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudGluZyB0aGF0IGN1c3RvbSBiZWhhdmlvci4gKFlvdSBvbmx5IG5lZWQgdGhpcyBpZiB5b3Ugd2FudFxudG8gcHJvZ3JhbW1hdGljYWxseSBpbnNlcnQgYnJhY2tldHPigJR0aGVcbltgY2xvc2VCcmFja2V0c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmNsb3NlQnJhY2tldHMpIGV4dGVuc2lvbiB3aWxsXG50YWtlIGNhcmUgb2YgcnVubmluZyB0aGlzIGZvciB1c2VyIGlucHV0LilcbiovXG5mdW5jdGlvbiBpbnNlcnRCcmFja2V0KHN0YXRlLCBicmFja2V0KSB7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGZvciAobGV0IHRvayBvZiB0b2tlbnMpIHtcbiAgICAgICAgbGV0IGNsb3NlZCA9IGNsb3NpbmcoY29kZVBvaW50QXQodG9rLCAwKSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IHRvaylcbiAgICAgICAgICAgIHJldHVybiBjbG9zZWQgPT0gdG9rID8gaGFuZGxlU2FtZShzdGF0ZSwgdG9rLCB0b2tlbnMuaW5kZXhPZih0b2sgKyB0b2sgKyB0b2spID4gLTEsIGNvbmYpXG4gICAgICAgICAgICAgICAgOiBoYW5kbGVPcGVuKHN0YXRlLCB0b2ssIGNsb3NlZCwgY29uZi5iZWZvcmUgfHwgZGVmYXVsdHMuYmVmb3JlKTtcbiAgICAgICAgaWYgKGJyYWNrZXQgPT0gY2xvc2VkICYmIGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2xvc2Uoc3RhdGUsIHRvaywgY2xvc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHBvcykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIHN0YXRlLmZpZWxkKGJyYWNrZXRTdGF0ZSkuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCBmcm9tID0+IHtcbiAgICAgICAgaWYgKGZyb20gPT0gcG9zKVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG5leHRDaGFyKGRvYywgcG9zKSB7XG4gICAgbGV0IG5leHQgPSBkb2Muc2xpY2VTdHJpbmcocG9zLCBwb3MgKyAyKTtcbiAgICByZXR1cm4gbmV4dC5zbGljZSgwLCBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KG5leHQsIDApKSk7XG59XG5mdW5jdGlvbiBwcmV2Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBwcmV2ID0gZG9jLnNsaWNlU3RyaW5nKHBvcyAtIDIsIHBvcyk7XG4gICAgcmV0dXJuIGNvZGVQb2ludFNpemUoY29kZVBvaW50QXQocHJldiwgMCkpID09IHByZXYubGVuZ3RoID8gcHJldiA6IHByZXYuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBoYW5kbGVPcGVuKHN0YXRlLCBvcGVuLCBjbG9zZSwgY2xvc2VCZWZvcmUpIHtcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogb3BlbiwgZnJvbTogcmFuZ2UuZnJvbSB9LCB7IGluc2VydDogY2xvc2UsIGZyb206IHJhbmdlLnRvIH1dLFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS50byArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIG9wZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIGxldCBuZXh0ID0gbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IC9cXHMvLnRlc3QobmV4dCkgfHwgY2xvc2VCZWZvcmUuaW5kZXhPZihuZXh0KSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IG9wZW4gKyBjbG9zZSwgZnJvbTogcmFuZ2UuaGVhZCB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBvcGVuLmxlbmd0aCkgfTtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVDbG9zZShzdGF0ZSwgX29wZW4sIGNsb3NlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3NlKVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkLCB0bzogcmFuZ2UuaGVhZCArIGNsb3NlLmxlbmd0aCwgaW5zZXJ0OiBjbG9zZSB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBjbG9zZS5sZW5ndGgpIH07XG4gICAgICAgIHJldHVybiBkb250ID0geyByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG4vLyBIYW5kbGVzIGNhc2VzIHdoZXJlIHRoZSBvcGVuIGFuZCBjbG9zZSB0b2tlbiBhcmUgdGhlIHNhbWUsIGFuZFxuLy8gcG9zc2libHkgdHJpcGxlIHF1b3RlcyAoYXMgaW4gYFwiXCJcImFiY1wiXCJcImAtc3R5bGUgcXVvdGluZykuXG5mdW5jdGlvbiBoYW5kbGVTYW1lKHN0YXRlLCB0b2tlbiwgYWxsb3dUcmlwbGUsIGNvbmZpZykge1xuICAgIGxldCBzdHJpbmdQcmVmaXhlcyA9IGNvbmZpZy5zdHJpbmdQcmVmaXhlcyB8fCBkZWZhdWx0cy5zdHJpbmdQcmVmaXhlcztcbiAgICBsZXQgZG9udCA9IG51bGwsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFt7IGluc2VydDogdG9rZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yICsgdG9rZW4ubGVuZ3RoLCByYW5nZS5oZWFkICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcG9zKSwgc3RhcnQ7XG4gICAgICAgIGlmIChuZXh0ID09IHRva2VuKSB7XG4gICAgICAgICAgICBpZiAobm9kZVN0YXJ0KHN0YXRlLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBpbnNlcnQ6IHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocG9zICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBwb3MpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzVHJpcGxlID0gYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyB0b2tlbi5sZW5ndGggKiAzKSA9PSB0b2tlbiArIHRva2VuICsgdG9rZW47XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBpc1RyaXBsZSA/IHRva2VuICsgdG9rZW4gKyB0b2tlbiA6IHRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcG9zLCB0bzogcG9zICsgY29udGVudC5sZW5ndGgsIGluc2VydDogY29udGVudCB9LFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyBjb250ZW50Lmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGxvd1RyaXBsZSAmJiBzdGF0ZS5zbGljZURvYyhwb3MgLSAyICogdG9rZW4ubGVuZ3RoLCBwb3MpID09IHRva2VuICsgdG9rZW4gJiZcbiAgICAgICAgICAgIChzdGFydCA9IGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcyAtIDIgKiB0b2tlbi5sZW5ndGgsIHN0cmluZ1ByZWZpeGVzKSkgPiAtMSAmJlxuICAgICAgICAgICAgbm9kZVN0YXJ0KHN0YXRlLCBzdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuICsgdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgdG9rZW4ubGVuZ3RoKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpKG5leHQpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSB7XG4gICAgICAgICAgICBpZiAoY2FuU3RhcnRTdHJpbmdBdChzdGF0ZSwgcG9zLCBzdHJpbmdQcmVmaXhlcykgPiAtMSAmJiAhcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCB0b2tlbiwgc3RyaW5nUHJlZml4ZXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGRvbnQgPyBudWxsIDogc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC50eXBlXCJcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vZGVTdGFydChzdGF0ZSwgcG9zKSB7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zICsgMSk7XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ICYmIHRyZWUuZnJvbSA9PSBwb3M7XG59XG5mdW5jdGlvbiBwcm9iYWJseUluU3RyaW5nKHN0YXRlLCBwb3MsIHF1b3RlVG9rZW4sIHByZWZpeGVzKSB7XG4gICAgbGV0IG5vZGUgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zLCAtMSk7XG4gICAgbGV0IG1heFByZWZpeCA9IHByZWZpeGVzLnJlZHVjZSgobSwgcCkgPT4gTWF0aC5tYXgobSwgcC5sZW5ndGgpLCAwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBsZXQgc3RhcnQgPSBzdGF0ZS5zbGljZURvYyhub2RlLmZyb20sIE1hdGgubWluKG5vZGUudG8sIG5vZGUuZnJvbSArIHF1b3RlVG9rZW4ubGVuZ3RoICsgbWF4UHJlZml4KSk7XG4gICAgICAgIGxldCBxdW90ZVBvcyA9IHN0YXJ0LmluZGV4T2YocXVvdGVUb2tlbik7XG4gICAgICAgIGlmICghcXVvdGVQb3MgfHwgcXVvdGVQb3MgPiAtMSAmJiBwcmVmaXhlcy5pbmRleE9mKHN0YXJ0LnNsaWNlKDAsIHF1b3RlUG9zKSkgPiAtMSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGZpcnN0ICYmIGZpcnN0LmZyb20gPT0gbm9kZS5mcm9tICYmIGZpcnN0LnRvIC0gZmlyc3QuZnJvbSA+IHF1b3RlVG9rZW4ubGVuZ3RoICsgcXVvdGVQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2xpY2VEb2MoZmlyc3QudG8gLSBxdW90ZVRva2VuLmxlbmd0aCwgZmlyc3QudG8pID09IHF1b3RlVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZpcnN0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS50byA9PSBwb3MgJiYgbm9kZS5wYXJlbnQ7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgcHJlZml4ZXMpIHtcbiAgICBsZXQgY2hhckNhdCA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGlmIChjaGFyQ2F0KHN0YXRlLnNsaWNlRG9jKHBvcyAtIDEsIHBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGZvciAobGV0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3MgLSBwcmVmaXgubGVuZ3RoO1xuICAgICAgICBpZiAoc3RhdGUuc2xpY2VEb2Moc3RhcnQsIHBvcykgPT0gcHJlZml4ICYmIGNoYXJDYXQoc3RhdGUuc2xpY2VEb2Moc3RhcnQgLSAxLCBzdGFydCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGF1dG9jb21wbGV0aW9uLlxuKi9cbmZ1bmN0aW9uIGF1dG9jb21wbGV0aW9uKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29tcGxldGlvblN0YXRlLFxuICAgICAgICBjb21wbGV0aW9uQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGNvbXBsZXRpb25QbHVnaW4sXG4gICAgICAgIGNvbXBsZXRpb25LZXltYXBFeHQsXG4gICAgICAgIGJhc2VUaGVtZVxuICAgIF07XG59XG4vKipcbkJhc2ljIGtleWJpbmRpbmdzIGZvciBhdXRvY29tcGxldGlvbi5cblxuIC0gQ3RybC1TcGFjZTogW2BzdGFydENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5zdGFydENvbXBsZXRpb24pXG4gLSBFc2NhcGU6IFtgY2xvc2VDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VDb21wbGV0aW9uKVxuIC0gQXJyb3dEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlKWBcbiAtIEFycm93VXA6IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKGZhbHNlKWBcbiAtIFBhZ2VEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlLCBcInBhZ2VcIilgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gRW50ZXI6IFtgYWNjZXB0Q29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmFjY2VwdENvbXBsZXRpb24pXG4qL1xuY29uc3QgY29tcGxldGlvbktleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLVNwYWNlXCIsIHJ1bjogc3RhcnRDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VDb21wbGV0aW9uIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dEb3duXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKHRydWUpIH0sXG4gICAgeyBrZXk6IFwiQXJyb3dVcFwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmYWxzZSkgfSxcbiAgICB7IGtleTogXCJQYWdlRG93blwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbih0cnVlLCBcInBhZ2VcIikgfSxcbiAgICB7IGtleTogXCJQYWdlVXBcIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24oZmFsc2UsIFwicGFnZVwiKSB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogYWNjZXB0Q29tcGxldGlvbiB9XG5dO1xuY29uc3QgY29tcGxldGlvbktleW1hcEV4dCA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL2tleW1hcC5jb21wdXRlTihbY29tcGxldGlvbkNvbmZpZ10sIHN0YXRlID0+IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmRlZmF1bHRLZXltYXAgPyBbY29tcGxldGlvbktleW1hcF0gOiBbXSkpO1xuLyoqXG5HZXQgdGhlIGN1cnJlbnQgY29tcGxldGlvbiBzdGF0dXMuIFdoZW4gY29tcGxldGlvbnMgYXJlIGF2YWlsYWJsZSxcbnRoaXMgd2lsbCByZXR1cm4gYFwiYWN0aXZlXCJgLiBXaGVuIGNvbXBsZXRpb25zIGFyZSBwZW5kaW5nIChpbiB0aGVcbnByb2Nlc3Mgb2YgYmVpbmcgcXVlcmllZCksIHRoaXMgcmV0dXJucyBgXCJwZW5kaW5nXCJgLiBPdGhlcndpc2UsIGl0XG5yZXR1cm5zIGBudWxsYC5cbiovXG5mdW5jdGlvbiBjb21wbGV0aW9uU3RhdHVzKHN0YXRlKSB7XG4gICAgbGV0IGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pID8gXCJwZW5kaW5nXCJcbiAgICAgICAgOiBjU3RhdGUgJiYgY1N0YXRlLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IFwiYWN0aXZlXCIgOiBudWxsO1xufVxuY29uc3QgY29tcGxldGlvbkFycmF5Q2FjaGUgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXA7XG4vKipcblJldHVybnMgdGhlIGF2YWlsYWJsZSBjb21wbGV0aW9ucyBhcyBhbiBhcnJheS5cbiovXG5mdW5jdGlvbiBjdXJyZW50Q29tcGxldGlvbnMoc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgaWYgKCFvcGVuIHx8IG9wZW4uZGlzYWJsZWQpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBjb21wbGV0aW9uQXJyYXlDYWNoZS5nZXQob3Blbi5vcHRpb25zKTtcbiAgICBpZiAoIWNvbXBsZXRpb25zKVxuICAgICAgICBjb21wbGV0aW9uQXJyYXlDYWNoZS5zZXQob3Blbi5vcHRpb25zLCBjb21wbGV0aW9ucyA9IG9wZW4ub3B0aW9ucy5tYXAobyA9PiBvLmNvbXBsZXRpb24pKTtcbiAgICByZXR1cm4gY29tcGxldGlvbnM7XG59XG4vKipcblJldHVybiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbXBsZXRpb24sIGlmIGFueS5cbiovXG5mdW5jdGlvbiBzZWxlY3RlZENvbXBsZXRpb24oc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgcmV0dXJuIG9wZW4gJiYgIW9wZW4uZGlzYWJsZWQgJiYgb3Blbi5zZWxlY3RlZCA+PSAwID8gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdLmNvbXBsZXRpb24gOiBudWxsO1xufVxuLyoqXG5SZXR1cm5zIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcG9zaXRpb24gaW4gdGhlIGFjdGl2ZSBjb21wbGV0aW9uXG5saXN0LCBvciBudWxsIGlmIG5vIGNvbXBsZXRpb25zIGFyZSBhY3RpdmUuXG4qL1xuZnVuY3Rpb24gc2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgoc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG9wZW4gPSAoX2EgPSBzdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wZW47XG4gICAgcmV0dXJuIG9wZW4gJiYgIW9wZW4uZGlzYWJsZWQgJiYgb3Blbi5zZWxlY3RlZCA+PSAwID8gb3Blbi5zZWxlY3RlZCA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhbiBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBjaGFuZ2VcbnRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBzZXRTZWxlY3RlZENvbXBsZXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gc2V0U2VsZWN0ZWRFZmZlY3Qub2YoaW5kZXgpO1xufVxuXG5leHBvcnQgeyBDb21wbGV0aW9uQ29udGV4dCwgYWNjZXB0Q29tcGxldGlvbiwgYXV0b2NvbXBsZXRpb24sIGNsZWFyU25pcHBldCwgY2xvc2VCcmFja2V0cywgY2xvc2VCcmFja2V0c0tleW1hcCwgY2xvc2VDb21wbGV0aW9uLCBjb21wbGV0ZUFueVdvcmQsIGNvbXBsZXRlRnJvbUxpc3QsIGNvbXBsZXRpb25LZXltYXAsIGNvbXBsZXRpb25TdGF0dXMsIGN1cnJlbnRDb21wbGV0aW9ucywgZGVsZXRlQnJhY2tldFBhaXIsIGhhc05leHRTbmlwcGV0RmllbGQsIGhhc1ByZXZTbmlwcGV0RmllbGQsIGlmSW4sIGlmTm90SW4sIGluc2VydEJyYWNrZXQsIGluc2VydENvbXBsZXRpb25UZXh0LCBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbiwgbmV4dFNuaXBwZXRGaWVsZCwgcGlja2VkQ29tcGxldGlvbiwgcHJldlNuaXBwZXRGaWVsZCwgc2VsZWN0ZWRDb21wbGV0aW9uLCBzZWxlY3RlZENvbXBsZXRpb25JbmRleCwgc2V0U2VsZWN0ZWRDb21wbGV0aW9uLCBzbmlwcGV0LCBzbmlwcGV0Q29tcGxldGlvbiwgc25pcHBldEtleW1hcCwgc3RhcnRDb21wbGV0aW9uIH07XG4iXSwibmFtZXMiOlsiQW5ub3RhdGlvbiIsIlN0YXRlRWZmZWN0IiwiRWRpdG9yU2VsZWN0aW9uIiwiY29kZVBvaW50QXQiLCJjb2RlUG9pbnRTaXplIiwiZnJvbUNvZGVQb2ludCIsIkZhY2V0IiwiY29tYmluZUNvbmZpZyIsIlN0YXRlRmllbGQiLCJQcmVjIiwiVGV4dCIsIlRyYW5zYWN0aW9uIiwiTWFwTW9kZSIsIlJhbmdlVmFsdWUiLCJSYW5nZVNldCIsIkNoYXJDYXRlZ29yeSIsIkRpcmVjdGlvbiIsImxvZ0V4Y2VwdGlvbiIsInNob3dUb29sdGlwIiwiRWRpdG9yVmlldyIsIlZpZXdQbHVnaW4iLCJnZXRUb29sdGlwIiwiRGVjb3JhdGlvbiIsIldpZGdldFR5cGUiLCJrZXltYXAiLCJzeW50YXhUcmVlIiwiaW5kZW50VW5pdCIsIkNvbXBsZXRpb25Db250ZXh0IiwiY29uc3RydWN0b3IiLCJzdGF0ZSIsInBvcyIsImV4cGxpY2l0IiwiYWJvcnRMaXN0ZW5lcnMiLCJ0b2tlbkJlZm9yZSIsInR5cGVzIiwidG9rZW4iLCJyZXNvbHZlSW5uZXIiLCJpbmRleE9mIiwibmFtZSIsInBhcmVudCIsImZyb20iLCJ0byIsInRleHQiLCJzbGljZURvYyIsInR5cGUiLCJtYXRjaEJlZm9yZSIsImV4cHIiLCJsaW5lIiwiZG9jIiwibGluZUF0Iiwic3RhcnQiLCJNYXRoIiwibWF4Iiwic3RyIiwic2xpY2UiLCJmb3VuZCIsInNlYXJjaCIsImVuc3VyZUFuY2hvciIsImFib3J0ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJwdXNoIiwidG9TZXQiLCJjaGFycyIsImZsYXQiLCJPYmplY3QiLCJrZXlzIiwiam9pbiIsIndvcmRzIiwidGVzdCIsInJlcGxhY2UiLCJwcmVmaXhNYXRjaCIsIm9wdGlvbnMiLCJmaXJzdCIsImNyZWF0ZSIsInJlc3QiLCJsYWJlbCIsImkiLCJsZW5ndGgiLCJzb3VyY2UiLCJSZWdFeHAiLCJjb21wbGV0ZUZyb21MaXN0IiwibGlzdCIsIm1hcCIsIm8iLCJ2YWxpZEZvciIsIm1hdGNoIiwiZXZlcnkiLCJjb250ZXh0IiwiaWZJbiIsIm5vZGVzIiwiaXNUb3AiLCJpZk5vdEluIiwiT3B0aW9uIiwiY29tcGxldGlvbiIsInNjb3JlIiwiY3VyIiwic2VsZWN0aW9uIiwibWFpbiIsIl9hIiwiYWRkU3RhcnQiLCJhZGRFbmQiLCJmbGFncyIsImlnbm9yZUNhc2UiLCJwaWNrZWRDb21wbGV0aW9uIiwiZGVmaW5lIiwiaW5zZXJ0Q29tcGxldGlvblRleHQiLCJmcm9tT2ZmIiwidG9PZmYiLCJhc3NpZ24iLCJjaGFuZ2VCeVJhbmdlIiwicmFuZ2UiLCJjaGFuZ2VzIiwiaW5zZXJ0IiwiY3Vyc29yIiwic2Nyb2xsSW50b1ZpZXciLCJ1c2VyRXZlbnQiLCJTb3VyY2VDYWNoZSIsIldlYWtNYXAiLCJhc1NvdXJjZSIsIkFycmF5IiwiaXNBcnJheSIsImtub3duIiwiZ2V0Iiwic2V0Iiwic3RhcnRDb21wbGV0aW9uRWZmZWN0IiwiY2xvc2VDb21wbGV0aW9uRWZmZWN0IiwiRnV6enlNYXRjaGVyIiwicGF0dGVybiIsImZvbGRlZCIsImFueSIsInByZWNpc2UiLCJieVdvcmQiLCJtYXRjaGVkIiwicCIsImNoYXIiLCJzaXplIiwicGFydCIsInVwcGVyIiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsImFzdHJhbCIsInJldCIsIndvcmQiLCJmaXJzdFNpemUiLCJkaXJlY3QiLCJsZW4iLCJhbnlUbyIsImUiLCJtaW4iLCJuZXh0IiwicHJlY2lzZVRvIiwiYnlXb3JkVG8iLCJieVdvcmRGb2xkZWQiLCJhZGphY2VudFRvIiwiYWRqYWNlbnRTdGFydCIsImFkamFjZW50RW5kIiwiaGFzTG93ZXIiLCJ3b3JkQWRqYWNlbnQiLCJwcmV2VHlwZSIsImNoIiwicmVzdWx0IiwicG9zaXRpb25zIiwiY29tcGxldGlvbkNvbmZpZyIsImNvbWJpbmUiLCJjb25maWdzIiwiYWN0aXZhdGVPblR5cGluZyIsImFjdGl2YXRlT25UeXBpbmdEZWxheSIsInNlbGVjdE9uT3BlbiIsIm92ZXJyaWRlIiwiY2xvc2VPbkJsdXIiLCJtYXhSZW5kZXJlZE9wdGlvbnMiLCJkZWZhdWx0S2V5bWFwIiwidG9vbHRpcENsYXNzIiwib3B0aW9uQ2xhc3MiLCJhYm92ZUN1cnNvciIsImljb25zIiwiYWRkVG9PcHRpb25zIiwicG9zaXRpb25JbmZvIiwiZGVmYXVsdFBvc2l0aW9uSW5mbyIsImNvbXBhcmVDb21wbGV0aW9ucyIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsImludGVyYWN0aW9uRGVsYXkiLCJ1cGRhdGVTeW5jVGltZSIsImMiLCJqb2luQ2xhc3MiLCJjb25jYXQiLCJ2aWV3Iiwib3B0aW9uIiwiaW5mbyIsInNwYWNlIiwidG9vbHRpcCIsInJ0bCIsInRleHREaXJlY3Rpb24iLCJSVEwiLCJsZWZ0IiwibmFycm93Iiwic2lkZSIsIm9mZnNldCIsIm1heFdpZHRoIiwic3BhY2VMZWZ0Iiwic3BhY2VSaWdodCIsInJpZ2h0IiwiaW5mb1dpZHRoIiwiaW5mb0hlaWdodCIsImJvdHRvbSIsInRvcCIsInNwYWNlQmVsb3ciLCJzY2FsZVkiLCJvZmZzZXRIZWlnaHQiLCJzY2FsZVgiLCJvZmZzZXRXaWR0aCIsInN0eWxlIiwiY2xhc3MiLCJvcHRpb25Db250ZW50IiwiY29uZmlnIiwiY29udGVudCIsInJlbmRlciIsImljb24iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJzcGxpdCIsImNscyIsInNldEF0dHJpYnV0ZSIsInBvc2l0aW9uIiwiX3MiLCJfdiIsImxhYmVsRWx0IiwiY2xhc3NOYW1lIiwiZGlzcGxheUxhYmVsIiwib2ZmIiwiaiIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJzcGFuIiwiZGV0YWlsIiwiZGV0YWlsRWx0IiwidGV4dENvbnRlbnQiLCJzb3J0IiwicmFuZ2VBcm91bmRTZWxlY3RlZCIsInRvdGFsIiwic2VsZWN0ZWQiLCJmbG9vciIsIkNvbXBsZXRpb25Ub29sdGlwIiwic3RhdGVGaWVsZCIsImFwcGx5Q29tcGxldGlvbiIsImluZm9EZXN0cm95IiwicGxhY2VJbmZvUmVxIiwicmVhZCIsIm1lYXN1cmVJbmZvIiwid3JpdGUiLCJwbGFjZUluZm8iLCJrZXkiLCJjdXJyZW50Q2xhc3MiLCJjU3RhdGUiLCJmaWVsZCIsIm9wZW4iLCJmYWNldCIsImRvbSIsInVwZGF0ZVRvb2x0aXBDbGFzcyIsInRhcmdldCIsInBhcmVudE5vZGUiLCJub2RlTmFtZSIsImV4ZWMiLCJpZCIsInByZXZlbnREZWZhdWx0IiwicmVsYXRlZFRhcmdldCIsImNvbnRlbnRET00iLCJkaXNwYXRjaCIsImVmZmVjdHMiLCJvZiIsInNob3dPcHRpb25zIiwibW91bnQiLCJ1cGRhdGVTZWwiLCJyZW1vdmUiLCJjcmVhdGVMaXN0Qm94IiwicmVxdWVzdE1lYXN1cmUiLCJ1cGRhdGUiLCJwcmV2U3RhdGUiLCJzdGFydFN0YXRlIiwiZGlzYWJsZWQiLCJ0b2dnbGUiLCJwb3NpdGlvbmVkIiwidXBkYXRlU2VsZWN0ZWRPcHRpb24iLCJkZXN0cm95SW5mbyIsImluZm9SZXN1bHQiLCJ0aGVuIiwib2JqIiwiYWRkSW5mb1BhbmUiLCJjYXRjaCIsIndyYXAiLCJub2RlVHlwZSIsImRlc3Ryb3kiLCJvcHQiLCJmaXJzdENoaWxkIiwibmV4dFNpYmxpbmciLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZWwiLCJxdWVyeVNlbGVjdG9yIiwibGlzdFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpbmZvUmVjdCIsInNlbFJlY3QiLCJ3aW4iLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJjc3NUZXh0IiwidWwiLCJwaHJhc2UiLCJjdXJTZWN0aW9uIiwic2VjdGlvbiIsImhlYWRlciIsImxpIiwibm9kZSIsImNvbXBsZXRpb25Ub29sdGlwIiwiY29udGFpbmVyIiwiZWxlbWVudCIsInNlbGYiLCJoZWlnaHQiLCJzY3JvbGxUb3AiLCJib29zdCIsImFwcGx5Iiwic29ydE9wdGlvbnMiLCJhY3RpdmUiLCJzZWN0aW9ucyIsImFkZE9wdGlvbiIsInNvbWUiLCJzIiwiaGFzUmVzdWx0IiwiZ2V0TWF0Y2giLCJmaWx0ZXIiLCJtYXRjaGVyIiwic2VjdGlvbk9yZGVyIiwiY21wIiwiX2IiLCJyYW5rIiwicHJldiIsImNvbXBhcmUiLCJDb21wbGV0aW9uRGlhbG9nIiwiYXR0cnMiLCJ0aW1lc3RhbXAiLCJzZXRTZWxlY3RlZCIsIm1ha2VBdHRycyIsImJ1aWxkIiwiY29uZiIsInNlbGVjdGVkVmFsdWUiLCJyZWR1Y2UiLCJjcmVhdGVUb29sdGlwIiwiYWJvdmUiLCJEYXRlIiwibm93IiwibWFwUG9zIiwiQ29tcGxldGlvblN0YXRlIiwibm9uZSIsInJhbmRvbSIsInRvU3RyaW5nIiwidHIiLCJzb3VyY2VzIiwibGFuZ3VhZ2VEYXRhQXQiLCJ2YWx1ZSIsImZpbmQiLCJBY3RpdmVTb3VyY2UiLCJkb2NDaGFuZ2VkIiwidG91Y2hlc1JhbmdlIiwic2FtZVJlc3VsdHMiLCJlZmZlY3QiLCJpcyIsInNldFNlbGVjdGVkRWZmZWN0IiwiYmFzZUF0dHJzIiwiaUEiLCJpQiIsImVuZEEiLCJlbmRCIiwiZ2V0VXNlckV2ZW50IiwiaXNVc2VyRXZlbnQiLCJleHBsaWNpdFBvcyIsImV2ZW50IiwiaGFuZGxlVXNlckV2ZW50IiwiaGFuZGxlQ2hhbmdlIiwic2V0QWN0aXZlRWZmZWN0IiwiZW1wdHkiLCJBY3RpdmVSZXN1bHQiLCJ1cGRhdGVkIiwiY2hlY2tWYWxpZCIsIm1hcHBpbmciLCJjb21wbGV0aW9uU3RhdGUiLCJwcm92aWRlIiwiZiIsInZhbCIsImNvbnRlbnRBdHRyaWJ1dGVzIiwiYW5ub3RhdGlvbnMiLCJtb3ZlQ29tcGxldGlvblNlbGVjdGlvbiIsImZvcndhcmQiLCJieSIsInN0ZXAiLCJhY2NlcHRDb21wbGV0aW9uIiwicmVhZE9ubHkiLCJzdGFydENvbXBsZXRpb24iLCJjbG9zZUNvbXBsZXRpb24iLCJSdW5uaW5nUXVlcnkiLCJ0aW1lIiwidXBkYXRlcyIsImRvbmUiLCJ1bmRlZmluZWQiLCJNYXhVcGRhdGVDb3VudCIsIk1pbkFib3J0VGltZSIsImNvbXBsZXRpb25QbHVnaW4iLCJmcm9tQ2xhc3MiLCJkZWJvdW5jZVVwZGF0ZSIsInJ1bm5pbmciLCJkZWJvdW5jZUFjY2VwdCIsInBlbmRpbmdTdGFydCIsImNvbXBvc2luZyIsInN0YXJ0UXVlcnkiLCJzZWxlY3Rpb25TZXQiLCJkb2VzUmVzZXQiLCJ0cmFuc2FjdGlvbnMiLCJxdWVyeSIsImhhbmRsZXIiLCJzcGxpY2UiLCJjbGVhclRpbWVvdXQiLCJkZWxheSIsInEiLCJzZXRUaW1lb3V0Iiwic3RhcnRVcGRhdGUiLCJyIiwicGVuZGluZyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2NoZWR1bGVBY2NlcHQiLCJlcnIiLCJhY2NlcHQiLCJjdXJyZW50IiwiZXZlbnRIYW5kbGVycyIsImJsdXIiLCJkaWFsb2ciLCJjb250YWlucyIsImNvbXBvc2l0aW9uc3RhcnQiLCJjb21wb3NpdGlvbmVuZCIsImJhc2VUaGVtZSIsImZvbnRGYW1pbHkiLCJ3aGl0ZVNwYWNlIiwib3ZlcmZsb3ciLCJtYXhXaWR0aF9mYWxsYmFjayIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwibGlzdFN0eWxlIiwibWFyZ2luIiwicGFkZGluZyIsImxpbmVIZWlnaHQiLCJvdmVyZmxvd1giLCJ0ZXh0T3ZlcmZsb3ciLCJkaXNwbGF5IiwiYm9yZGVyQm90dG9tIiwicGFkZGluZ0xlZnQiLCJvcGFjaXR5IiwiYmFja2dyb3VuZCIsImNvbG9yIiwidGV4dEFsaWduIiwid2lkdGgiLCJib3hTaXppbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJ2ZXJ0aWNhbEFsaWduIiwiYm9yZGVyTGVmdCIsInRleHREZWNvcmF0aW9uIiwibWFyZ2luTGVmdCIsImZvbnRTdHlsZSIsImZvbnRTaXplIiwicGFkZGluZ1JpZ2h0IiwiRmllbGRQb3MiLCJGaWVsZFJhbmdlIiwiVHJhY2tEZWwiLCJTbmlwcGV0IiwibGluZXMiLCJmaWVsZFBvc2l0aW9ucyIsImluc3RhbnRpYXRlIiwibGluZVN0YXJ0IiwibGluZU9iaiIsImJhc2VJbmRlbnQiLCJpbmRlbnQiLCJ0YWJzIiwicmFuZ2VzIiwicGFyc2UiLCJ0ZW1wbGF0ZSIsImZpZWxkcyIsIm0iLCJzZXEiLCJpbmRleCIsImVzYyIsImZpZWxkTWFya2VyIiwid2lkZ2V0IiwidG9ET00iLCJpZ25vcmVFdmVudCIsImZpZWxkUmFuZ2UiLCJtYXJrIiwiQWN0aXZlU25pcHBldCIsImRlY28iLCJtYXBwZWQiLCJzZWxlY3Rpb25JbnNpZGVGaWVsZCIsInNldEFjdGl2ZSIsIm1vdmVUb0ZpZWxkIiwic25pcHBldFN0YXRlIiwiZGVjb3JhdGlvbnMiLCJmaWVsZFNlbGVjdGlvbiIsInNuaXBwZXQiLCJlZGl0b3IiLCJzcGVjIiwiYXBwZW5kQ29uZmlnIiwiYWRkU25pcHBldEtleW1hcCIsInNuaXBwZXRQb2ludGVySGFuZGxlciIsIm1vdmVGaWVsZCIsImRpciIsImxhc3QiLCJjbGVhclNuaXBwZXQiLCJuZXh0U25pcHBldEZpZWxkIiwicHJldlNuaXBwZXRGaWVsZCIsImhhc05leHRTbmlwcGV0RmllbGQiLCJoYXNQcmV2U25pcHBldEZpZWxkIiwiZGVmYXVsdFNuaXBwZXRLZXltYXAiLCJydW4iLCJzaGlmdCIsInNuaXBwZXRLZXltYXAiLCJtYXBzIiwiaGlnaGVzdCIsImNvbXB1dGUiLCJzbmlwcGV0Q29tcGxldGlvbiIsImRvbUV2ZW50SGFuZGxlcnMiLCJtb3VzZWRvd24iLCJwb3NBdENvb3JkcyIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJ3b3JkUkUiLCJ3b3JkQ2hhcnMiLCJlc2NhcGVkIiwibWFwUkUiLCJyZSIsInVuaWNvZGUiLCJ3b3JkQ2FjaGVzIiwid29yZENhY2hlIiwic3RvcmVXb3JkcyIsInNlZW4iLCJpZ25vcmVBdCIsIml0ZXJMaW5lcyIsImxhc3RJbmRleCIsImNvbGxlY3RXb3JkcyIsImNhY2hlIiwiYmlnIiwiY2FjaGVkIiwiY2hpbGRyZW4iLCJjb21wbGV0ZUFueVdvcmQiLCJkZWZhdWx0cyIsImJyYWNrZXRzIiwiYmVmb3JlIiwic3RyaW5nUHJlZml4ZXMiLCJjbG9zZUJyYWNrZXRFZmZlY3QiLCJUcmFja0FmdGVyIiwiY2xvc2VkQnJhY2tldCIsInN0YXJ0U2lkZSIsImVuZFNpZGUiLCJicmFja2V0U3RhdGUiLCJoZWFkIiwiY2xvc2VCcmFja2V0cyIsImlucHV0SGFuZGxlciIsImRlZmluZWRDbG9zaW5nIiwiY2xvc2luZyIsImNoYXJDb2RlQXQiLCJjaGFyQXQiLCJhbmRyb2lkIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiY29tcG9zaXRpb25TdGFydGVkIiwiaW5zZXJ0QnJhY2tldCIsImRlbGV0ZUJyYWNrZXRQYWlyIiwidG9rZW5zIiwiZG9udCIsInByZXZDaGFyIiwibmV4dENoYXIiLCJjbG9zZUJyYWNrZXRzS2V5bWFwIiwiYnJhY2tldCIsInRvayIsImNsb3NlZCIsImhhbmRsZVNhbWUiLCJoYW5kbGVPcGVuIiwiY2xvc2VkQnJhY2tldEF0IiwiaGFuZGxlQ2xvc2UiLCJiZXR3ZWVuIiwic2xpY2VTdHJpbmciLCJjbG9zZSIsImNsb3NlQmVmb3JlIiwiYW5jaG9yIiwiX29wZW4iLCJhbGxvd1RyaXBsZSIsIm5vZGVTdGFydCIsImlzVHJpcGxlIiwiY2FuU3RhcnRTdHJpbmdBdCIsImNoYXJDYXRlZ29yaXplciIsIldvcmQiLCJwcm9iYWJseUluU3RyaW5nIiwidHJlZSIsInF1b3RlVG9rZW4iLCJwcmVmaXhlcyIsIm1heFByZWZpeCIsInF1b3RlUG9zIiwiY2hhckNhdCIsInByZWZpeCIsImF1dG9jb21wbGV0aW9uIiwiY29tcGxldGlvbktleW1hcEV4dCIsImNvbXBsZXRpb25LZXltYXAiLCJjb21wdXRlTiIsImNvbXBsZXRpb25TdGF0dXMiLCJjb21wbGV0aW9uQXJyYXlDYWNoZSIsImN1cnJlbnRDb21wbGV0aW9ucyIsImNvbXBsZXRpb25zIiwic2VsZWN0ZWRDb21wbGV0aW9uIiwic2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgiLCJzZXRTZWxlY3RlZENvbXBsZXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockComment: () => (/* binding */ blockComment),\n/* harmony export */   blockUncomment: () => (/* binding */ blockUncomment),\n/* harmony export */   copyLineDown: () => (/* binding */ copyLineDown),\n/* harmony export */   copyLineUp: () => (/* binding */ copyLineUp),\n/* harmony export */   cursorCharBackward: () => (/* binding */ cursorCharBackward),\n/* harmony export */   cursorCharForward: () => (/* binding */ cursorCharForward),\n/* harmony export */   cursorCharLeft: () => (/* binding */ cursorCharLeft),\n/* harmony export */   cursorCharRight: () => (/* binding */ cursorCharRight),\n/* harmony export */   cursorDocEnd: () => (/* binding */ cursorDocEnd),\n/* harmony export */   cursorDocStart: () => (/* binding */ cursorDocStart),\n/* harmony export */   cursorGroupBackward: () => (/* binding */ cursorGroupBackward),\n/* harmony export */   cursorGroupForward: () => (/* binding */ cursorGroupForward),\n/* harmony export */   cursorGroupLeft: () => (/* binding */ cursorGroupLeft),\n/* harmony export */   cursorGroupRight: () => (/* binding */ cursorGroupRight),\n/* harmony export */   cursorLineBoundaryBackward: () => (/* binding */ cursorLineBoundaryBackward),\n/* harmony export */   cursorLineBoundaryForward: () => (/* binding */ cursorLineBoundaryForward),\n/* harmony export */   cursorLineBoundaryLeft: () => (/* binding */ cursorLineBoundaryLeft),\n/* harmony export */   cursorLineBoundaryRight: () => (/* binding */ cursorLineBoundaryRight),\n/* harmony export */   cursorLineDown: () => (/* binding */ cursorLineDown),\n/* harmony export */   cursorLineEnd: () => (/* binding */ cursorLineEnd),\n/* harmony export */   cursorLineStart: () => (/* binding */ cursorLineStart),\n/* harmony export */   cursorLineUp: () => (/* binding */ cursorLineUp),\n/* harmony export */   cursorMatchingBracket: () => (/* binding */ cursorMatchingBracket),\n/* harmony export */   cursorPageDown: () => (/* binding */ cursorPageDown),\n/* harmony export */   cursorPageUp: () => (/* binding */ cursorPageUp),\n/* harmony export */   cursorSubwordBackward: () => (/* binding */ cursorSubwordBackward),\n/* harmony export */   cursorSubwordForward: () => (/* binding */ cursorSubwordForward),\n/* harmony export */   cursorSyntaxLeft: () => (/* binding */ cursorSyntaxLeft),\n/* harmony export */   cursorSyntaxRight: () => (/* binding */ cursorSyntaxRight),\n/* harmony export */   defaultKeymap: () => (/* binding */ defaultKeymap),\n/* harmony export */   deleteCharBackward: () => (/* binding */ deleteCharBackward),\n/* harmony export */   deleteCharForward: () => (/* binding */ deleteCharForward),\n/* harmony export */   deleteGroupBackward: () => (/* binding */ deleteGroupBackward),\n/* harmony export */   deleteGroupForward: () => (/* binding */ deleteGroupForward),\n/* harmony export */   deleteLine: () => (/* binding */ deleteLine),\n/* harmony export */   deleteLineBoundaryBackward: () => (/* binding */ deleteLineBoundaryBackward),\n/* harmony export */   deleteLineBoundaryForward: () => (/* binding */ deleteLineBoundaryForward),\n/* harmony export */   deleteToLineEnd: () => (/* binding */ deleteToLineEnd),\n/* harmony export */   deleteToLineStart: () => (/* binding */ deleteToLineStart),\n/* harmony export */   deleteTrailingWhitespace: () => (/* binding */ deleteTrailingWhitespace),\n/* harmony export */   emacsStyleKeymap: () => (/* binding */ emacsStyleKeymap),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   historyField: () => (/* binding */ historyField),\n/* harmony export */   historyKeymap: () => (/* binding */ historyKeymap),\n/* harmony export */   indentLess: () => (/* binding */ indentLess),\n/* harmony export */   indentMore: () => (/* binding */ indentMore),\n/* harmony export */   indentSelection: () => (/* binding */ indentSelection),\n/* harmony export */   indentWithTab: () => (/* binding */ indentWithTab),\n/* harmony export */   insertBlankLine: () => (/* binding */ insertBlankLine),\n/* harmony export */   insertNewline: () => (/* binding */ insertNewline),\n/* harmony export */   insertNewlineAndIndent: () => (/* binding */ insertNewlineAndIndent),\n/* harmony export */   insertTab: () => (/* binding */ insertTab),\n/* harmony export */   invertedEffects: () => (/* binding */ invertedEffects),\n/* harmony export */   isolateHistory: () => (/* binding */ isolateHistory),\n/* harmony export */   lineComment: () => (/* binding */ lineComment),\n/* harmony export */   lineUncomment: () => (/* binding */ lineUncomment),\n/* harmony export */   moveLineDown: () => (/* binding */ moveLineDown),\n/* harmony export */   moveLineUp: () => (/* binding */ moveLineUp),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   redoSelection: () => (/* binding */ redoSelection),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectCharBackward: () => (/* binding */ selectCharBackward),\n/* harmony export */   selectCharForward: () => (/* binding */ selectCharForward),\n/* harmony export */   selectCharLeft: () => (/* binding */ selectCharLeft),\n/* harmony export */   selectCharRight: () => (/* binding */ selectCharRight),\n/* harmony export */   selectDocEnd: () => (/* binding */ selectDocEnd),\n/* harmony export */   selectDocStart: () => (/* binding */ selectDocStart),\n/* harmony export */   selectGroupBackward: () => (/* binding */ selectGroupBackward),\n/* harmony export */   selectGroupForward: () => (/* binding */ selectGroupForward),\n/* harmony export */   selectGroupLeft: () => (/* binding */ selectGroupLeft),\n/* harmony export */   selectGroupRight: () => (/* binding */ selectGroupRight),\n/* harmony export */   selectLine: () => (/* binding */ selectLine),\n/* harmony export */   selectLineBoundaryBackward: () => (/* binding */ selectLineBoundaryBackward),\n/* harmony export */   selectLineBoundaryForward: () => (/* binding */ selectLineBoundaryForward),\n/* harmony export */   selectLineBoundaryLeft: () => (/* binding */ selectLineBoundaryLeft),\n/* harmony export */   selectLineBoundaryRight: () => (/* binding */ selectLineBoundaryRight),\n/* harmony export */   selectLineDown: () => (/* binding */ selectLineDown),\n/* harmony export */   selectLineEnd: () => (/* binding */ selectLineEnd),\n/* harmony export */   selectLineStart: () => (/* binding */ selectLineStart),\n/* harmony export */   selectLineUp: () => (/* binding */ selectLineUp),\n/* harmony export */   selectMatchingBracket: () => (/* binding */ selectMatchingBracket),\n/* harmony export */   selectPageDown: () => (/* binding */ selectPageDown),\n/* harmony export */   selectPageUp: () => (/* binding */ selectPageUp),\n/* harmony export */   selectParentSyntax: () => (/* binding */ selectParentSyntax),\n/* harmony export */   selectSubwordBackward: () => (/* binding */ selectSubwordBackward),\n/* harmony export */   selectSubwordForward: () => (/* binding */ selectSubwordForward),\n/* harmony export */   selectSyntaxLeft: () => (/* binding */ selectSyntaxLeft),\n/* harmony export */   selectSyntaxRight: () => (/* binding */ selectSyntaxRight),\n/* harmony export */   simplifySelection: () => (/* binding */ simplifySelection),\n/* harmony export */   splitLine: () => (/* binding */ splitLine),\n/* harmony export */   standardKeymap: () => (/* binding */ standardKeymap),\n/* harmony export */   toggleBlockComment: () => (/* binding */ toggleBlockComment),\n/* harmony export */   toggleBlockCommentByLine: () => (/* binding */ toggleBlockCommentByLine),\n/* harmony export */   toggleComment: () => (/* binding */ toggleComment),\n/* harmony export */   toggleLineComment: () => (/* binding */ toggleLineComment),\n/* harmony export */   transposeChars: () => (/* binding */ transposeChars),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth),\n/* harmony export */   undoSelection: () => (/* binding */ undoSelection)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/ const toggleComment = (target)=>{\n    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let tr = f(option, state);\n        if (!tr) return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleLineComment = /*@__PURE__*/ command(changeLineComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using line comments.\n*/ const lineComment = /*@__PURE__*/ command(changeLineComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using line comments.\n*/ const lineUncomment = /*@__PURE__*/ command(changeLineComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleBlockComment = /*@__PURE__*/ command(changeBlockComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using block comments.\n*/ const blockComment = /*@__PURE__*/ command(changeBlockComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using block comments.\n*/ const blockUncomment = /*@__PURE__*/ command(changeBlockComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/ const toggleBlockCommentByLine = /*@__PURE__*/ command((o, s)=>changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */ );\nfunction getConfig(state, pos) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/ function findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return {\n            open: {\n                pos: from - spaceBefore,\n                margin: spaceBefore && 1\n            },\n            close: {\n                pos: to + spaceAfter,\n                margin: spaceAfter && 1\n            }\n        };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    } else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n        return {\n            open: {\n                pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n            },\n            close: {\n                pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n            }\n        };\n    }\n    return null;\n}\nfunction selectedLineRanges(state) {\n    let ranges = [];\n    for (let r of state.selection.ranges){\n        let fromLine = state.doc.lineAt(r.from);\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n        let last = ranges.length - 1;\n        if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;\n        else ranges.push({\n            from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length,\n            to: toLine.to\n        });\n    }\n    return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n    let tokens = ranges.map((r)=>getConfig(state, r.from).block);\n    if (!tokens.every((c)=>c)) return null;\n    let comments = ranges.map((r, i)=>findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* CommentOption.Uncomment */  && !comments.every((c)=>c)) {\n        return {\n            changes: state.changes(ranges.map((range, i)=>{\n                if (comments[i]) return [];\n                return [\n                    {\n                        from: range.from,\n                        insert: tokens[i].open + \" \"\n                    },\n                    {\n                        from: range.to,\n                        insert: \" \" + tokens[i].close\n                    }\n                ];\n            }))\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && comments.some((c)=>c)) {\n        let changes = [];\n        for(let i = 0, comment; i < comments.length; i++)if (comment = comments[i]) {\n            let token = tokens[i], { open, close } = comment;\n            changes.push({\n                from: open.pos - token.open.length,\n                to: open.pos + open.margin\n            }, {\n                from: close.pos - close.margin,\n                to: close.pos + token.close.length\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges){\n        let startI = lines.length, minIndent = 1e9;\n        let token = getConfig(state, from).line;\n        if (!token) continue;\n        for(let pos = from; pos <= to;){\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent) minIndent = indent;\n                lines.push({\n                    line,\n                    comment,\n                    token,\n                    indent,\n                    empty,\n                    single: false\n                });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9) {\n            for(let i = startI; i < lines.length; i++)if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n        }\n        if (lines.length == startI + 1) lines[startI].single = true;\n    }\n    if (option != 2 /* CommentOption.Uncomment */  && lines.some((l)=>l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)if (single || !empty) changes.push({\n            from: line.from + indent,\n            insert: token + \" \"\n        });\n        let changeSet = state.changes(changes);\n        return {\n            changes: changeSet,\n            selection: state.selection.map(changeSet, 1)\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && lines.some((l)=>l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)if (comment >= 0) {\n            let from = line.from + comment, to = from + token.length;\n            if (line.text[to - line.from] == \" \") to++;\n            changes.push({\n                from,\n                to\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\nconst fromHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/ const isolateHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/ const invertedEffects = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst historyConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            minDepth: 100,\n            newGroupDelay: 500,\n            joinToEvent: (_t, isAdjacent)=>isAdjacent\n        }, {\n            minDepth: Math.max,\n            newGroupDelay: Math.min,\n            joinToEvent: (a, b)=>(tr, adj)=>a(tr, adj) || b(tr, adj)\n        });\n    }\n});\nconst historyField_ = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return HistoryState.empty;\n    },\n    update (state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;\n            let other = from == 0 /* BranchName.Done */  ? state.undone : state.done;\n            if (item) other = updateBranch(other, other.length, config.minDepth, item);\n            else other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* BranchName.Done */  ? fromHist.rest : other, from == 0 /* BranchName.Done */  ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n        if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time), userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);\n        if (event) state = state.addChanges(event, time, userEvent, config, tr);\n        else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n        return state;\n    },\n    toJSON (value) {\n        return {\n            done: value.done.map((e)=>e.toJSON()),\n            undone: value.undone.map((e)=>e.toJSON())\n        };\n    },\n    fromJSON (json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/ function history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n            beforeinput (e, view) {\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n                if (!command) return false;\n                e.preventDefault();\n                return command(view);\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/ const historyField = historyField_;\nfunction cmd(side, selection) {\n    return function({ state, dispatch }) {\n        if (!selection && state.readOnly) return false;\n        let historyState = state.field(historyField_, false);\n        if (!historyState) return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr) return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/ const undo = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/ const redo = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , false);\n/**\nUndo a change or selection change.\n*/ const undoSelection = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , true);\n/**\nRedo a change or selection change.\n*/ const redoSelection = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , true);\nfunction depth(side) {\n    return function(state) {\n        let histState = state.field(historyField_, false);\n        if (!histState) return 0;\n        let branch = side == 0 /* BranchName.Done */  ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/ const undoDepth = /*@__PURE__*/ depth(0 /* BranchName.Done */ );\n/**\nThe amount of redoable change events available in a given state.\n*/ const redoDepth = /*@__PURE__*/ depth(1 /* BranchName.Undone */ );\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(// The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, // The effects associated with this event\n    effects, // Accumulated mapping (from addToHistory==false) that should be\n    // applied to events below this one.\n    mapped, // The selection before this event\n    startSelection, // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter){\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map((s)=>s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr, selection) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)){\n            let result = invert(tr);\n            if (result.length) effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty) return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t)=>ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t)=>{\n        for(let i = 0; i < ranges.length;){\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to) isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i)=>r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [\n            HistEvent.selection([\n                selection\n            ])\n        ];\n    } else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length) return branch;\n    let length = branch.length, selections = none;\n    while(length){\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) {\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        } else {\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [\n        HistEvent.selection(selections)\n    ] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s)=>s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes) return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined){\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, config, tr) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event\n        userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        } else {\n            done = updateBranch(done, done.length, config.minDepth, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, onlySelection) {\n        let branch = side == 0 /* BranchName.Done */  ? this.done : this.undone;\n        if (branch.length == 0) return null;\n        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;\n        if (onlySelection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({\n                    side,\n                    rest: popSelection(branch),\n                    selection\n                }),\n                userEvent: side == 0 /* BranchName.Done */  ? \"select.undo\" : \"select.redo\",\n                scrollIntoView: true\n            });\n        } else if (!event.changes) {\n            return null;\n        } else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({\n                    side,\n                    rest,\n                    selection\n                }),\n                filter: false,\n                userEvent: side == 0 /* BranchName.Done */  ? \"undo\" : \"redo\",\n                scrollIntoView: true\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/ new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/ const historyKeymap = [\n    {\n        key: \"Mod-z\",\n        run: undo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-y\",\n        mac: \"Mod-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        linux: \"Ctrl-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-u\",\n        run: undoSelection,\n        preventDefault: true\n    },\n    {\n        key: \"Alt-u\",\n        mac: \"Mod-Shift-u\",\n        run: redoSelection,\n        preventDefault: true\n    }\n];\nfunction updateSel(sel, by) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({\n        selection,\n        scrollIntoView: true,\n        userEvent: \"select\"\n    });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection, true)) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n    return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/ const cursorCharLeft = (view)=>cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/ const cursorCharRight = (view)=>cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/ const cursorCharForward = (view)=>cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/ const cursorCharBackward = (view)=>cursorByChar(view, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/ const cursorGroupLeft = (view)=>cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/ const cursorGroupRight = (view)=>cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/ const cursorGroupForward = (view)=>cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/ const cursorGroupBackward = (view)=>cursorByGroup(view, false);\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ? /*@__PURE__*/ new Intl.Segmenter(undefined, {\n    granularity: \"word\"\n}) : null;\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space, pos = range.from, steps = 0;\n    let done = false, sawUpper = false, sawLower = false;\n    let step = (next)=>{\n        if (done) return false;\n        pos += forward ? next.length : -next.length;\n        let nextCat = categorize(next), ahead;\n        if (nextCat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next)) nextCat = -1; // Treat word punctuation specially\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) cat = nextCat;\n        if (cat != nextCat) return false;\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (next.toLowerCase() == next) {\n                if (!forward && sawUpper) return false;\n                sawLower = true;\n            } else if (sawLower) {\n                if (forward) return false;\n                done = true;\n            } else {\n                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n                sawUpper = true;\n            }\n        }\n        steps++;\n        return true;\n    };\n    let end = view.moveByChar(range, forward, (start)=>{\n        step(start);\n        return step;\n    });\n    if (segmenter && cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);\n        let skipped = view.state.sliceDoc(from, to);\n        if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n            let segments = Array.from(segmenter.segment(skipped));\n            if (segments.length > 1) {\n                if (forward) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + segments[1].index, -1);\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n            }\n        }\n    }\n    return end;\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, (range)=>range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/ const cursorSubwordForward = (view)=>cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/ const cursorSubwordBackward = (view)=>cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp)) return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n    let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for(let at = start.head;;){\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next) break;\n        if (interestingNode(state, next, bracketProp)) pos = next;\n        else at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;\n    else newPos = forward ? pos.to : pos.from;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/ const cursorSyntaxLeft = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/ const cursorSyntaxRight = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, (range)=>{\n        if (!range.empty) return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/ const cursorLineUp = (view)=>cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/ const cursorLineDown = (view)=>cursorByLine(view, true);\nfunction pageInfo(view) {\n    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n    let marginTop = 0, marginBottom = 0, height;\n    if (selfScroll) {\n        for (let source of view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollMargins)){\n            let margins = source(view);\n            if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n            if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n        }\n        height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n    } else {\n        height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n    }\n    return {\n        marginTop,\n        marginBottom,\n        selfScroll,\n        height: Math.max(view.defaultLineHeight, height - 5)\n    };\n}\nfunction cursorByPage(view, forward) {\n    let page = pageInfo(view);\n    let { state } = view, selection = updateSel(state.selection, (range)=>{\n        return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);\n    });\n    if (selection.eq(state.selection)) return false;\n    let effect;\n    if (page.selfScroll) {\n        let startPos = view.coordsAtPos(state.selection.main.head);\n        let scrollRect = view.scrollDOM.getBoundingClientRect();\n        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;\n        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, {\n            y: \"start\",\n            yMargin: startPos.top - scrollTop\n        });\n    }\n    view.dispatch(setSel(state, selection), {\n        effects: effect\n    });\n    return true;\n}\n/**\nMove the selection one page up.\n*/ const cursorPageUp = (view)=>cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/ const cursorPageDown = (view)=>cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space) moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/ const cursorLineBoundaryForward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/ const cursorLineBoundaryBackward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/ const cursorLineBoundaryLeft = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/ const cursorLineBoundaryRight = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/ const cursorLineStart = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/ const cursorLineEnd = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, (range)=>{\n        let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1) || range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1) || range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1);\n        if (!matching || !matching.end) return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n    });\n    if (!found) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/ const cursorMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/ const selectMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, true);\nfunction extendSel(view, how) {\n    let selection = updateSel(view.state.selection, (range)=>{\n        let head = how(range);\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n    });\n    if (selection.eq(view.state.selection)) return false;\n    view.dispatch(setSel(view.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, (range)=>view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/ const selectCharLeft = (view)=>selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/ const selectCharRight = (view)=>selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/ const selectCharForward = (view)=>selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/ const selectCharBackward = (view)=>selectByChar(view, false);\nfunction selectByGroup(view, forward) {\n    return extendSel(view, (range)=>view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/ const selectGroupLeft = (view)=>selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/ const selectGroupRight = (view)=>selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/ const selectGroupForward = (view)=>selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/ const selectGroupBackward = (view)=>selectByGroup(view, false);\nfunction selectBySubword(view, forward) {\n    return extendSel(view, (range)=>moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/ const selectSubwordForward = (view)=>selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/ const selectSubwordBackward = (view)=>selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/ const selectSyntaxLeft = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/ const selectSyntaxRight = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/ const selectLineUp = (view)=>selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/ const selectLineDown = (view)=>selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/ const selectPageUp = (view)=>selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/ const selectPageDown = (view)=>selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/ const selectLineBoundaryForward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/ const selectLineBoundaryBackward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/ const selectLineBoundaryLeft = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/ const selectLineBoundaryRight = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/ const selectLineStart = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/ const selectLineEnd = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/ const cursorDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: 0\n    }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/ const cursorDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.doc.length\n    }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/ const selectDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: 0\n    }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/ const selectDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: state.doc.length\n    }));\n    return true;\n};\n/**\nSelect the entire document.\n*/ const selectAll = ({ state, dispatch })=>{\n    dispatch(state.update({\n        selection: {\n            anchor: 0,\n            head: state.doc.length\n        },\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/ const selectLine = ({ state, dispatch })=>{\n    let ranges = selectedLineBlocks(state).map(({ from, to })=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges),\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/ const selectParentSyntax = ({ state, dispatch })=>{\n    let selection = updateSel(state.selection, (range)=>{\n        var _a;\n        let stack = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveStack(range.from, 1);\n        for(let cur = stack; cur; cur = cur.next){\n            let { node } = cur;\n            if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(node.to, node.from);\n        }\n        return range;\n    });\n    dispatch(setSel(state, selection));\n    return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/ const simplifySelection = ({ state, dispatch })=>{\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        cur.main\n    ]);\n    else if (!cur.main.empty) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)\n    ]);\n    if (!selection) return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(target, by) {\n    if (target.state.readOnly) return false;\n    let event = \"delete.selection\", { state } = target;\n    let changes = state.changeByRange((range)=>{\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(range);\n            if (towards < from) {\n                event = \"delete.backward\";\n                towards = skipAtomic(target, towards, false);\n            } else if (towards > from) {\n                event = \"delete.forward\";\n                towards = skipAtomic(target, towards, true);\n            }\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        } else {\n            from = skipAtomic(target, from, false);\n            to = skipAtomic(target, to, true);\n        }\n        return from == to ? {\n            range\n        } : {\n            changes: {\n                from,\n                to\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from, from < range.head ? -1 : 1)\n        };\n    });\n    if (changes.changes.empty) return false;\n    target.dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: event,\n        effects: event == \"delete.selection\" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n    }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView) for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map((f)=>f(target)))ranges.between(pos, pos, (from, to)=>{\n        if (from < pos && to > pos) pos = forward ? to : from;\n    });\n    return pos;\n}\nconst deleteByChar = (target, forward)=>deleteBy(target, (range)=>{\n        let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n        if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n            if (before[before.length - 1] == \"\t\") return pos - 1;\n            let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize), drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n            for(let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)pos--;\n            targetPos = pos;\n        } else {\n            targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\n            if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;\n            else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, targetPos - line.from, false, false) + line.from;\n        }\n        return targetPos;\n    });\n/**\nDelete the selection, or, for cursor selections, the character\nbefore the cursor.\n*/ const deleteCharBackward = (view)=>deleteByChar(view, false);\n/**\nDelete the selection or the character after the cursor.\n*/ const deleteCharForward = (view)=>deleteByChar(view, true);\nconst deleteByGroup = (target, forward)=>deleteBy(target, (range)=>{\n        let pos = range.head, { state } = target, line = state.doc.lineAt(pos);\n        let categorize = state.charCategorizer(pos);\n        for(let cat = null;;){\n            if (pos == (forward ? line.to : line.from)) {\n                if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n                break;\n            }\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n            let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n            let nextCat = categorize(nextChar);\n            if (cat != null && nextCat != cat) break;\n            if (nextChar != \" \" || pos != range.head) cat = nextCat;\n            pos = next;\n        }\n        return pos;\n    });\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/ const deleteGroupBackward = (target)=>deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/ const deleteGroupForward = (target)=>deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/ const deleteToLineEnd = (view)=>deleteBy(view, (range)=>{\n        let lineEnd = view.lineBlockAt(range.head).to;\n        return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/ const deleteToLineStart = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.lineBlockAt(range.head).from;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/ const deleteLineBoundaryBackward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, false).head;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/ const deleteLineBoundaryForward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, true).head;\n        return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/ const deleteTrailingWhitespace = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = [];\n    for(let pos = 0, prev = \"\", iter = state.doc.iter();;){\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1) changes.push({\n                from: pos - (prev.length - trailing),\n                to: pos\n            });\n            if (iter.done) break;\n            prev = \"\";\n        } else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        userEvent: \"delete\"\n    }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/ const splitLine = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        return {\n            changes: {\n                from: range.from,\n                to: range.to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of([\n                    \"\",\n                    \"\"\n                ])\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from)\n        };\n    });\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/ const transposeChars = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n            range\n        };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n        return {\n            changes: {\n                from,\n                to,\n                insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to)\n        };\n    });\n    if (changes.changes.empty) return false;\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"move.character\"\n    }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges){\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        } else {\n            blocks.push({\n                from: startLine.from,\n                to: endLine.to,\n                ranges: [\n                    range\n                ]\n            });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward ? block.to == state.doc.length : block.from == 0) continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({\n                from: block.to,\n                to: nextLine.to\n            }, {\n                from: block.from,\n                insert: nextLine.text + state.lineBreak\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        } else {\n            changes.push({\n                from: nextLine.from,\n                to: block.from\n            }, {\n                from: block.to,\n                insert: state.lineBreak + nextLine.text\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/ const moveLineUp = ({ state, dispatch })=>moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/ const moveLineDown = ({ state, dispatch })=>moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward) changes.push({\n            from: block.from,\n            insert: state.doc.slice(block.from, block.to) + state.lineBreak\n        });\n        else changes.push({\n            from: block.to,\n            insert: state.lineBreak + state.doc.slice(block.from, block.to)\n        });\n    }\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        userEvent: \"input.copyline\"\n    }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/ const copyLineUp = ({ state, dispatch })=>copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/ const copyLineDown = ({ state, dispatch })=>copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/ const deleteLine = (view)=>{\n    if (view.state.readOnly) return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to })=>{\n        if (from > 0) from--;\n        else if (to < state.doc.length) to++;\n        return {\n            from,\n            to\n        };\n    }));\n    let selection = updateSel(state.selection, (range)=>view.moveVertically(range, true)).map(changes);\n    view.dispatch({\n        changes,\n        selection,\n        scrollIntoView: true,\n        userEvent: \"delete.line\"\n    });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/ const insertNewline = ({ state, dispatch })=>{\n    dispatch(state.update(state.replaceSelection(state.lineBreak), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n        from: pos,\n        to: pos\n    };\n    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\\S/.test(state.sliceDoc(before.to, after.from))) return {\n        from: before.to,\n        to: after.from\n    };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/ const insertNewlineAndIndent = /*@__PURE__*/ newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/ const insertBlankLine = /*@__PURE__*/ newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let changes = state.changeByRange((range)=>{\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n                simulateBreak: from,\n                simulateDoubleBreak: !!explode\n            });\n            let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n            if (indent == null) indent = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n            while(to < line.to && /\\s/.test(line.text[to - line.from]))to++;\n            if (explode) ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n            let insert = [\n                \"\",\n                (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)\n            ];\n            if (explode) insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n            return {\n                changes: {\n                    from,\n                    to,\n                    insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert)\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length)\n            };\n        });\n        dispatch(state.update(changes, {\n            scrollIntoView: true,\n            userEvent: \"input\"\n        }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange((range)=>{\n        let changes = [];\n        for(let pos = range.from; pos <= range.to;){\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return {\n            changes,\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n        };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/ const indentSelection = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let updated = Object.create(null);\n    let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n        overrideIndentation: (start)=>{\n            let found = updated[start];\n            return found == null ? -1 : found;\n        }\n    });\n    let changes = changeBySelectedLine(state, (line, changes, range)=>{\n        let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n        if (indent == null) return;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    });\n    if (!changes.changes.empty) dispatch(state.update(changes, {\n        userEvent: \"indent\"\n    }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/ const indentMore = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        changes.push({\n            from: line.from,\n            insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit)\n        });\n    }), {\n        userEvent: \"input.indent\"\n    }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/ const indentLess = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space) return;\n        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize), keep = 0;\n        let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n        while(keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))keep++;\n        changes.push({\n            from: line.from + keep,\n            to: line.from + space.length,\n            insert: insert.slice(keep)\n        });\n    }), {\n        userEvent: \"delete.dedent\"\n    }));\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/ const insertTab = ({ state, dispatch })=>{\n    if (state.selection.ranges.some((r)=>!r.empty)) return indentMore({\n        state,\n        dispatch\n    });\n    dispatch(state.update(state.replaceSelection(\"\t\"), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/ const emacsStyleKeymap = [\n    {\n        key: \"Ctrl-b\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Ctrl-f\",\n        run: cursorCharRight,\n        shift: selectCharRight\n    },\n    {\n        key: \"Ctrl-p\",\n        run: cursorLineUp,\n        shift: selectLineUp\n    },\n    {\n        key: \"Ctrl-n\",\n        run: cursorLineDown,\n        shift: selectLineDown\n    },\n    {\n        key: \"Ctrl-a\",\n        run: cursorLineStart,\n        shift: selectLineStart\n    },\n    {\n        key: \"Ctrl-e\",\n        run: cursorLineEnd,\n        shift: selectLineEnd\n    },\n    {\n        key: \"Ctrl-d\",\n        run: deleteCharForward\n    },\n    {\n        key: \"Ctrl-h\",\n        run: deleteCharBackward\n    },\n    {\n        key: \"Ctrl-k\",\n        run: deleteToLineEnd\n    },\n    {\n        key: \"Ctrl-Alt-h\",\n        run: deleteGroupBackward\n    },\n    {\n        key: \"Ctrl-o\",\n        run: splitLine\n    },\n    {\n        key: \"Ctrl-t\",\n        run: transposeChars\n    },\n    {\n        key: \"Ctrl-v\",\n        run: cursorPageDown\n    }\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/ const standardKeymap = /*@__PURE__*/ [\n    {\n        key: \"ArrowLeft\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowLeft\",\n        mac: \"Alt-ArrowLeft\",\n        run: cursorGroupLeft,\n        shift: selectGroupLeft,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowLeft\",\n        run: cursorLineBoundaryLeft,\n        shift: selectLineBoundaryLeft,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowRight\",\n        run: cursorCharRight,\n        shift: selectCharRight,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowRight\",\n        mac: \"Alt-ArrowRight\",\n        run: cursorGroupRight,\n        shift: selectGroupRight,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowRight\",\n        run: cursorLineBoundaryRight,\n        shift: selectLineBoundaryRight,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowUp\",\n        run: cursorLineUp,\n        shift: selectLineUp,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowUp\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        mac: \"Ctrl-ArrowUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"ArrowDown\",\n        run: cursorLineDown,\n        shift: selectLineDown,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowDown\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        mac: \"Ctrl-ArrowDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"PageUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"PageDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"Home\",\n        run: cursorLineBoundaryBackward,\n        shift: selectLineBoundaryBackward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-Home\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        key: \"End\",\n        run: cursorLineBoundaryForward,\n        shift: selectLineBoundaryForward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-End\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        key: \"Enter\",\n        run: insertNewlineAndIndent\n    },\n    {\n        key: \"Mod-a\",\n        run: selectAll\n    },\n    {\n        key: \"Backspace\",\n        run: deleteCharBackward,\n        shift: deleteCharBackward\n    },\n    {\n        key: \"Delete\",\n        run: deleteCharForward\n    },\n    {\n        key: \"Mod-Backspace\",\n        mac: \"Alt-Backspace\",\n        run: deleteGroupBackward\n    },\n    {\n        key: \"Mod-Delete\",\n        mac: \"Alt-Delete\",\n        run: deleteGroupForward\n    },\n    {\n        mac: \"Mod-Backspace\",\n        run: deleteLineBoundaryBackward\n    },\n    {\n        mac: \"Mod-Delete\",\n        run: deleteLineBoundaryForward\n    }\n].concat(/*@__PURE__*/ emacsStyleKeymap.map((b)=>({\n        mac: b.key,\n        run: b.run,\n        shift: b.shift\n    })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n*/ const defaultKeymap = /*@__PURE__*/ [\n    {\n        key: \"Alt-ArrowLeft\",\n        mac: \"Ctrl-ArrowLeft\",\n        run: cursorSyntaxLeft,\n        shift: selectSyntaxLeft\n    },\n    {\n        key: \"Alt-ArrowRight\",\n        mac: \"Ctrl-ArrowRight\",\n        run: cursorSyntaxRight,\n        shift: selectSyntaxRight\n    },\n    {\n        key: \"Alt-ArrowUp\",\n        run: moveLineUp\n    },\n    {\n        key: \"Shift-Alt-ArrowUp\",\n        run: copyLineUp\n    },\n    {\n        key: \"Alt-ArrowDown\",\n        run: moveLineDown\n    },\n    {\n        key: \"Shift-Alt-ArrowDown\",\n        run: copyLineDown\n    },\n    {\n        key: \"Escape\",\n        run: simplifySelection\n    },\n    {\n        key: \"Mod-Enter\",\n        run: insertBlankLine\n    },\n    {\n        key: \"Alt-l\",\n        mac: \"Ctrl-l\",\n        run: selectLine\n    },\n    {\n        key: \"Mod-i\",\n        run: selectParentSyntax,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-[\",\n        run: indentLess\n    },\n    {\n        key: \"Mod-]\",\n        run: indentMore\n    },\n    {\n        key: \"Mod-Alt-\\\\\",\n        run: indentSelection\n    },\n    {\n        key: \"Shift-Mod-k\",\n        run: deleteLine\n    },\n    {\n        key: \"Shift-Mod-\\\\\",\n        run: cursorMatchingBracket\n    },\n    {\n        key: \"Mod-/\",\n        run: toggleComment\n    },\n    {\n        key: \"Alt-A\",\n        run: toggleBlockComment\n    }\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/ const indentWithTab = {\n    key: \"Tab\",\n    run: indentMore,\n    shift: indentLess\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzTTtBQUM3STtBQUNnRjtBQUNoRztBQUV6Qzs7O0FBR0EsR0FDQSxNQUFNdUIsZ0JBQWdCQyxDQUFBQTtJQUNsQixJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHRCxRQUFRRSxPQUFPRCxNQUFNRSxHQUFHLENBQUNDLE1BQU0sQ0FBQ0gsTUFBTUksU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksR0FBR0MsU0FBU0MsVUFBVVQsT0FBT0MsS0FBSyxFQUFFQyxLQUFLSyxJQUFJO0lBQ3RILE9BQU9DLE9BQU9OLElBQUksR0FBR1Esa0JBQWtCVixVQUFVUSxPQUFPRyxLQUFLLEdBQUdDLHlCQUF5QlosVUFBVTtBQUN2RztBQUNBLFNBQVNhLFFBQVFDLENBQUMsRUFBRUMsTUFBTTtJQUN0QixPQUFPLENBQUMsRUFBRWQsS0FBSyxFQUFFZSxRQUFRLEVBQUU7UUFDdkIsSUFBSWYsTUFBTWdCLFFBQVEsRUFDZCxPQUFPO1FBQ1gsSUFBSUMsS0FBS0osRUFBRUMsUUFBUWQ7UUFDbkIsSUFBSSxDQUFDaUIsSUFDRCxPQUFPO1FBQ1hGLFNBQVNmLE1BQU1rQixNQUFNLENBQUNEO1FBQ3RCLE9BQU87SUFDWDtBQUNKO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNUixvQkFBb0IsV0FBVyxHQUFFRyxRQUFRTyxtQkFBbUIsRUFBRSx3QkFBd0I7QUFDNUY7O0FBRUEsR0FDQSxNQUFNQyxjQUFjLFdBQVcsR0FBRVIsUUFBUU8sbUJBQW1CLEVBQUUseUJBQXlCO0FBQ3ZGOztBQUVBLEdBQ0EsTUFBTUUsZ0JBQWdCLFdBQVcsR0FBRVQsUUFBUU8sbUJBQW1CLEVBQUUs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QUNnUztBQUNUOzs7OztBQUtBLEdBQ0EsTUFBTUUsZ0JBQWdCO0lBQUU5UCxLQUFLO0lBQU9DLEtBQUtxUDtJQUFZSyxPQUFPSjtBQUFXO0FBRTRwRCIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2NvbW1hbmRzL2Rpc3QvaW5kZXguanM/YmYyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbm5vdGF0aW9uLCBGYWNldCwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgVHJhbnNhY3Rpb24sIENoYW5nZVNldCwgQ2hhbmdlRGVzYywgRWRpdG9yU2VsZWN0aW9uLCBTdGF0ZUVmZmVjdCwgVGV4dCwgZmluZENsdXN0ZXJCcmVhaywgY291bnRDb2x1bW4sIENoYXJDYXRlZ29yeSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcsIERpcmVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgSW5kZW50Q29udGV4dCwgZ2V0SW5kZW50YXRpb24sIGluZGVudFN0cmluZywgbWF0Y2hCcmFja2V0cywgc3ludGF4VHJlZSwgZ2V0SW5kZW50VW5pdCwgaW5kZW50VW5pdCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaWxsIHVzZSBsaW5lIGNvbW1lbnRzXG5pZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsaW5nIGJhY2sgdG8gYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQ29tbWVudCA9IHRhcmdldCA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSksIGNvbmZpZyA9IGdldENvbmZpZyh0YXJnZXQuc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIGNvbmZpZy5saW5lID8gdG9nZ2xlTGluZUNvbW1lbnQodGFyZ2V0KSA6IGNvbmZpZy5ibG9jayA/IHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSh0YXJnZXQpIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gY29tbWFuZChmLCBvcHRpb24pIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHIgPSBmKG9wdGlvbiwgc3RhdGUpO1xuICAgICAgICBpZiAoIXRyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUodHIpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG5UaGUgbGluZSBjb21tZW50IHN5bnRheCBpcyB0YWtlbiBmcm9tIHRoZVxuW2Bjb21tZW50VG9rZW5zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLlxuKi9cbmNvbnN0IHRvZ2dsZUxpbmVDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuLyoqXG5Db21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGxpbmVDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovKTtcbi8qKlxuVW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGxpbmVVbmNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyk7XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cblRoZSBibG9jayBjb21tZW50IHN5bnRheCBpcyB0YWtlbiBmcm9tIHRoZVxuW2Bjb21tZW50VG9rZW5zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLlxuKi9cbmNvbnN0IHRvZ2dsZUJsb2NrQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG4vKipcbkNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGJsb2NrQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8pO1xuLyoqXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGJsb2NrVW5jb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGxpbmVzIGFyb3VuZCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmdcbmJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKChvLCBzKSA9PiBjaGFuZ2VCbG9ja0NvbW1lbnQobywgcywgc2VsZWN0ZWRMaW5lUmFuZ2VzKHMpKSwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG5mdW5jdGlvbiBnZXRDb25maWcoc3RhdGUsIHBvcykge1xuICAgIGxldCBkYXRhID0gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjb21tZW50VG9rZW5zXCIsIHBvcyk7XG4gICAgcmV0dXJuIGRhdGEubGVuZ3RoID8gZGF0YVswXSA6IHt9O1xufVxuY29uc3QgU2VhcmNoTWFyZ2luID0gNTA7XG4vKipcbkRldGVybWluZXMgaWYgdGhlIGdpdmVuIHJhbmdlIGlzIGJsb2NrLWNvbW1lbnRlZCBpbiB0aGUgZ2l2ZW5cbnN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHsgb3BlbiwgY2xvc2UgfSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHN0YXRlLnNsaWNlRG9jKGZyb20gLSBTZWFyY2hNYXJnaW4sIGZyb20pO1xuICAgIGxldCB0ZXh0QWZ0ZXIgPSBzdGF0ZS5zbGljZURvYyh0bywgdG8gKyBTZWFyY2hNYXJnaW4pO1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IC9cXHMqJC8uZXhlYyh0ZXh0QmVmb3JlKVswXS5sZW5ndGgsIHNwYWNlQWZ0ZXIgPSAvXlxccyovLmV4ZWModGV4dEFmdGVyKVswXS5sZW5ndGg7XG4gICAgbGV0IGJlZm9yZU9mZiA9IHRleHRCZWZvcmUubGVuZ3RoIC0gc3BhY2VCZWZvcmU7XG4gICAgaWYgKHRleHRCZWZvcmUuc2xpY2UoYmVmb3JlT2ZmIC0gb3Blbi5sZW5ndGgsIGJlZm9yZU9mZikgPT0gb3BlbiAmJlxuICAgICAgICB0ZXh0QWZ0ZXIuc2xpY2Uoc3BhY2VBZnRlciwgc3BhY2VBZnRlciArIGNsb3NlLmxlbmd0aCkgPT0gY2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gLSBzcGFjZUJlZm9yZSwgbWFyZ2luOiBzcGFjZUJlZm9yZSAmJiAxIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvICsgc3BhY2VBZnRlciwgbWFyZ2luOiBzcGFjZUFmdGVyICYmIDEgfSB9O1xuICAgIH1cbiAgICBsZXQgc3RhcnRUZXh0LCBlbmRUZXh0O1xuICAgIGlmICh0byAtIGZyb20gPD0gMiAqIFNlYXJjaE1hcmdpbikge1xuICAgICAgICBzdGFydFRleHQgPSBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgZnJvbSArIFNlYXJjaE1hcmdpbik7XG4gICAgICAgIGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyh0byAtIFNlYXJjaE1hcmdpbiwgdG8pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRTcGFjZSA9IC9eXFxzKi8uZXhlYyhzdGFydFRleHQpWzBdLmxlbmd0aCwgZW5kU3BhY2UgPSAvXFxzKiQvLmV4ZWMoZW5kVGV4dClbMF0ubGVuZ3RoO1xuICAgIGxldCBlbmRPZmYgPSBlbmRUZXh0Lmxlbmd0aCAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoO1xuICAgIGlmIChzdGFydFRleHQuc2xpY2Uoc3RhcnRTcGFjZSwgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSA9PSBvcGVuICYmXG4gICAgICAgIGVuZFRleHQuc2xpY2UoZW5kT2ZmLCBlbmRPZmYgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tICsgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogL1xccy8udGVzdChzdGFydFRleHQuY2hhckF0KHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkpID8gMSA6IDAgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3QoZW5kVGV4dC5jaGFyQXQoZW5kT2ZmIC0gMSkpID8gMSA6IDAgfSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGVkTGluZVJhbmdlcyhzdGF0ZSkge1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb21MaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyLmZyb20pO1xuICAgICAgICBsZXQgdG9MaW5lID0gci50byA8PSBmcm9tTGluZS50byA/IGZyb21MaW5lIDogc3RhdGUuZG9jLmxpbmVBdChyLnRvKTtcbiAgICAgICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPj0gMCAmJiByYW5nZXNbbGFzdF0udG8gPiBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgcmFuZ2VzW2xhc3RdLnRvID0gdG9MaW5lLnRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IGZyb21MaW5lLmZyb20gKyAvXlxccyovLmV4ZWMoZnJvbUxpbmUudGV4dClbMF0ubGVuZ3RoLCB0bzogdG9MaW5lLnRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgYmxvY2sgY29tbWVudHMgaW5cbi8vIGxhbmd1YWdlcyB0aGF0IHN1cHBvcnQgdGhlbS5cbmZ1bmN0aW9uIGNoYW5nZUJsb2NrQ29tbWVudChvcHRpb24sIHN0YXRlLCByYW5nZXMgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgbGV0IHRva2VucyA9IHJhbmdlcy5tYXAociA9PiBnZXRDb25maWcoc3RhdGUsIHIuZnJvbSkuYmxvY2spO1xuICAgIGlmICghdG9rZW5zLmV2ZXJ5KGMgPT4gYykpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBjb21tZW50cyA9IHJhbmdlcy5tYXAoKHIsIGkpID0+IGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHRva2Vuc1tpXSwgci5mcm9tLCByLnRvKSk7XG4gICAgaWYgKG9wdGlvbiAhPSAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovICYmICFjb21tZW50cy5ldmVyeShjID0+IGMpKSB7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHN0YXRlLmNoYW5nZXMocmFuZ2VzLm1hcCgocmFuZ2UsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3sgZnJvbTogcmFuZ2UuZnJvbSwgaW5zZXJ0OiB0b2tlbnNbaV0ub3BlbiArIFwiIFwiIH0sIHsgZnJvbTogcmFuZ2UudG8sIGluc2VydDogXCIgXCIgKyB0b2tlbnNbaV0uY2xvc2UgfV07XG4gICAgICAgICAgICB9KSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9uICE9IDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovICYmIGNvbW1lbnRzLnNvbWUoYyA9PiBjKSkge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgY29tbWVudDsgaSA8IGNvbW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPSBjb21tZW50c1tpXSkge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHRva2Vuc1tpXSwgeyBvcGVuLCBjbG9zZSB9ID0gY29tbWVudDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBvcGVuLnBvcyAtIHRva2VuLm9wZW4ubGVuZ3RoLCB0bzogb3Blbi5wb3MgKyBvcGVuLm1hcmdpbiB9LCB7IGZyb206IGNsb3NlLnBvcyAtIGNsb3NlLm1hcmdpbiwgdG86IGNsb3NlLnBvcyArIHRva2VuLmNsb3NlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIFBlcmZvcm1zIHRvZ2dsZSwgY29tbWVudCBhbmQgdW5jb21tZW50IG9mIGxpbmUgY29tbWVudHMuXG5mdW5jdGlvbiBjaGFuZ2VMaW5lQ29tbWVudChvcHRpb24sIHN0YXRlLCByYW5nZXMgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGV0IHByZXZMaW5lID0gLTE7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHJhbmdlcykge1xuICAgICAgICBsZXQgc3RhcnRJID0gbGluZXMubGVuZ3RoLCBtaW5JbmRlbnQgPSAxZTk7XG4gICAgICAgIGxldCB0b2tlbiA9IGdldENvbmZpZyhzdGF0ZSwgZnJvbSkubGluZTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBmcm9tOyBwb3MgPD0gdG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBwcmV2TGluZSAmJiAoZnJvbSA9PSB0byB8fCB0byA+IGxpbmUuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICBwcmV2TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBlbXB0eSA9IGluZGVudCA9PSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWVudCA9IGxpbmUudGV4dC5zbGljZShpbmRlbnQsIGluZGVudCArIHRva2VuLmxlbmd0aCkgPT0gdG9rZW4gPyBpbmRlbnQgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZW50IDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBpbmRlbnQgPCBtaW5JbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGVudCA9IGluZGVudDtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgbGluZSwgY29tbWVudCwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluSW5kZW50IDwgMWU5KVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0STsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChsaW5lc1tpXS5pbmRlbnQgPCBsaW5lc1tpXS5saW5lLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBsaW5lc1tpXS5pbmRlbnQgPSBtaW5JbmRlbnQ7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT0gc3RhcnRJICsgMSlcbiAgICAgICAgICAgIGxpbmVzW3N0YXJ0SV0uc2luZ2xlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbiAhPSAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovICYmIGxpbmVzLnNvbWUobCA9PiBsLmNvbW1lbnQgPCAwICYmICghbC5lbXB0eSB8fCBsLnNpbmdsZSkpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgdG9rZW4sIGluZGVudCwgZW1wdHksIHNpbmdsZSB9IG9mIGxpbmVzKVxuICAgICAgICAgICAgaWYgKHNpbmdsZSB8fCAhZW1wdHkpXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsgaW5kZW50LCBpbnNlcnQ6IHRva2VuICsgXCIgXCIgfSk7XG4gICAgICAgIGxldCBjaGFuZ2VTZXQgPSBzdGF0ZS5jaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBjaGFuZ2VTZXQsIHNlbGVjdGlvbjogc3RhdGUuc2VsZWN0aW9uLm1hcChjaGFuZ2VTZXQsIDEpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbiAhPSAxIC8qIENvbW1lbnRPcHRpb24uQ29tbWVudCAqLyAmJiBsaW5lcy5zb21lKGwgPT4gbC5jb21tZW50ID49IDApKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgbGluZSwgY29tbWVudCwgdG9rZW4gfSBvZiBsaW5lcylcbiAgICAgICAgICAgIGlmIChjb21tZW50ID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGxpbmUuZnJvbSArIGNvbW1lbnQsIHRvID0gZnJvbSArIHRva2VuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGluZS50ZXh0W3RvIC0gbGluZS5mcm9tXSA9PSBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgZnJvbUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuVHJhbnNhY3Rpb24gYW5ub3RhdGlvbiB0aGF0IHdpbGwgcHJldmVudCB0aGF0IHRyYW5zYWN0aW9uIGZyb21cbmJlaW5nIGNvbWJpbmVkIHdpdGggb3RoZXIgdHJhbnNhY3Rpb25zIGluIHRoZSB1bmRvIGhpc3RvcnkuIEdpdmVuXG5gXCJiZWZvcmVcImAsIGl0J2xsIHByZXZlbnQgbWVyZ2luZyB3aXRoIHByZXZpb3VzIHRyYW5zYWN0aW9ucy4gV2l0aFxuYFwiYWZ0ZXJcImAsIHN1YnNlcXVlbnQgdHJhbnNhY3Rpb25zIHdvbid0IGJlIGNvbWJpbmVkIHdpdGggdGhpc1xub25lLiBXaXRoIGBcImZ1bGxcImAsIHRoZSB0cmFuc2FjdGlvbiBpcyBpc29sYXRlZCBvbiBib3RoIHNpZGVzLlxuKi9cbmNvbnN0IGlzb2xhdGVIaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcblRoaXMgZmFjZXQgcHJvdmlkZXMgYSB3YXkgdG8gcmVnaXN0ZXIgZnVuY3Rpb25zIHRoYXQsIGdpdmVuIGFcbnRyYW5zYWN0aW9uLCBwcm92aWRlIGEgc2V0IG9mIGVmZmVjdHMgdGhhdCB0aGUgaGlzdG9yeSBzaG91bGRcbnN0b3JlIHdoZW4gaW52ZXJ0aW5nIHRoZSB0cmFuc2FjdGlvbi4gVGhpcyBjYW4gYmUgdXNlZCB0b1xuaW50ZWdyYXRlIHNvbWUga2luZHMgb2YgZWZmZWN0cyBpbiB0aGUgaGlzdG9yeSwgc28gdGhhdCB0aGV5IGNhblxuYmUgdW5kb25lIChhbmQgcmVkb25lIGFnYWluKS5cbiovXG5jb25zdCBpbnZlcnRlZEVmZmVjdHMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBoaXN0b3J5Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIG1pbkRlcHRoOiAxMDAsXG4gICAgICAgICAgICBuZXdHcm91cERlbGF5OiA1MDAsXG4gICAgICAgICAgICBqb2luVG9FdmVudDogKF90LCBpc0FkamFjZW50KSA9PiBpc0FkamFjZW50LFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtaW5EZXB0aDogTWF0aC5tYXgsXG4gICAgICAgICAgICBuZXdHcm91cERlbGF5OiBNYXRoLm1pbixcbiAgICAgICAgICAgIGpvaW5Ub0V2ZW50OiAoYSwgYikgPT4gKHRyLCBhZGopID0+IGEodHIsIGFkaikgfHwgYih0ciwgYWRqKVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNvbnN0IGhpc3RvcnlGaWVsZF8gPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIEhpc3RvcnlTdGF0ZS5lbXB0eTtcbiAgICB9LFxuICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGhpc3RvcnlDb25maWcpO1xuICAgICAgICBsZXQgZnJvbUhpc3QgPSB0ci5hbm5vdGF0aW9uKGZyb21IaXN0b3J5KTtcbiAgICAgICAgaWYgKGZyb21IaXN0KSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IEhpc3RFdmVudC5mcm9tVHJhbnNhY3Rpb24odHIsIGZyb21IaXN0LnNlbGVjdGlvbiksIGZyb20gPSBmcm9tSGlzdC5zaWRlO1xuICAgICAgICAgICAgbGV0IG90aGVyID0gZnJvbSA9PSAwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLyA/IHN0YXRlLnVuZG9uZSA6IHN0YXRlLmRvbmU7XG4gICAgICAgICAgICBpZiAoaXRlbSlcbiAgICAgICAgICAgICAgICBvdGhlciA9IHVwZGF0ZUJyYW5jaChvdGhlciwgb3RoZXIubGVuZ3RoLCBjb25maWcubWluRGVwdGgsIGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG90aGVyID0gYWRkU2VsZWN0aW9uKG90aGVyLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gZnJvbUhpc3QucmVzdCA6IG90aGVyLCBmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gb3RoZXIgOiBmcm9tSGlzdC5yZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNvbGF0ZSA9IHRyLmFubm90YXRpb24oaXNvbGF0ZUhpc3RvcnkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYmVmb3JlXCIpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmlzb2xhdGUoKTtcbiAgICAgICAgaWYgKHRyLmFubm90YXRpb24oVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5KSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gIXRyLmNoYW5nZXMuZW1wdHkgPyBzdGF0ZS5hZGRNYXBwaW5nKHRyLmNoYW5nZXMuZGVzYykgOiBzdGF0ZTtcbiAgICAgICAgbGV0IGV2ZW50ID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0cik7XG4gICAgICAgIGxldCB0aW1lID0gdHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi50aW1lKSwgdXNlckV2ZW50ID0gdHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi51c2VyRXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLCB0cik7XG4gICAgICAgIGVsc2UgaWYgKHRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYWRkU2VsZWN0aW9uKHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLCB0aW1lLCB1c2VyRXZlbnQsIGNvbmZpZy5uZXdHcm91cERlbGF5KTtcbiAgICAgICAgaWYgKGlzb2xhdGUgPT0gXCJmdWxsXCIgfHwgaXNvbGF0ZSA9PSBcImFmdGVyXCIpXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmlzb2xhdGUoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG4gICAgdG9KU09OKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGRvbmU6IHZhbHVlLmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSksIHVuZG9uZTogdmFsdWUudW5kb25lLm1hcChlID0+IGUudG9KU09OKCkpIH07XG4gICAgfSxcbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGpzb24uZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSwganNvbi51bmRvbmUubWFwKEhpc3RFdmVudC5mcm9tSlNPTikpO1xuICAgIH1cbn0pO1xuLyoqXG5DcmVhdGUgYSBoaXN0b3J5IGV4dGVuc2lvbiB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuKi9cbmZ1bmN0aW9uIGhpc3RvcnkoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBoaXN0b3J5RmllbGRfLFxuICAgICAgICBoaXN0b3J5Q29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIEVkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAgICAgICAgICBiZWZvcmVpbnB1dChlLCB2aWV3KSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIgPyB1bmRvIDogZS5pbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIF07XG59XG4vKipcblRoZSBzdGF0ZSBmaWVsZCB1c2VkIHRvIHN0b3JlIHRoZSBoaXN0b3J5IGRhdGEuIFNob3VsZCBwcm9iYWJseVxub25seSBiZSB1c2VkIHdoZW4geW91IHdhbnQgdG9cbltzZXJpYWxpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSBvclxuW2Rlc2VyaWFsaXplXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmZyb21KU09OKSBzdGF0ZSBvYmplY3RzIGluIGEgd2F5XG50aGF0IHByZXNlcnZlcyBoaXN0b3J5LlxuKi9cbmNvbnN0IGhpc3RvcnlGaWVsZCA9IGhpc3RvcnlGaWVsZF87XG5mdW5jdGlvbiBjbWQoc2lkZSwgc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh7IHN0YXRlLCBkaXNwYXRjaCB9KSB7XG4gICAgICAgIGlmICghc2VsZWN0aW9uICYmIHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaGlzdG9yeVN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RvcnlTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHRyID0gaGlzdG9yeVN0YXRlLnBvcChzaWRlLCBzdGF0ZSwgc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKCF0cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5VbmRvIGEgc2luZ2xlIGdyb3VwIG9mIGhpc3RvcnkgZXZlbnRzLiBSZXR1cm5zIGZhbHNlIGlmIG5vIGdyb3VwXG53YXMgYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHVuZG8gPSAvKkBfX1BVUkVfXyovY21kKDAgLyogQnJhbmNoTmFtZS5Eb25lICovLCBmYWxzZSk7XG4vKipcblJlZG8gYSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cCB3YXNcbmF2YWlsYWJsZS5cbiovXG5jb25zdCByZWRvID0gLypAX19QVVJFX18qL2NtZCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovLCBmYWxzZSk7XG4vKipcblVuZG8gYSBjaGFuZ2Ugb3Igc2VsZWN0aW9uIGNoYW5nZS5cbiovXG5jb25zdCB1bmRvU2VsZWN0aW9uID0gLypAX19QVVJFX18qL2NtZCgwIC8qIEJyYW5jaE5hbWUuRG9uZSAqLywgdHJ1ZSk7XG4vKipcblJlZG8gYSBjaGFuZ2Ugb3Igc2VsZWN0aW9uIGNoYW5nZS5cbiovXG5jb25zdCByZWRvU2VsZWN0aW9uID0gLypAX19QVVJFX18qL2NtZCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovLCB0cnVlKTtcbmZ1bmN0aW9uIGRlcHRoKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGxldCBoaXN0U3RhdGUgPSBzdGF0ZS5maWVsZChoaXN0b3J5RmllbGRfLCBmYWxzZSk7XG4gICAgICAgIGlmICghaGlzdFN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gaGlzdFN0YXRlLmRvbmUgOiBoaXN0U3RhdGUudW5kb25lO1xuICAgICAgICByZXR1cm4gYnJhbmNoLmxlbmd0aCAtIChicmFuY2gubGVuZ3RoICYmICFicmFuY2hbMF0uY2hhbmdlcyA/IDEgOiAwKTtcbiAgICB9O1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHVuZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgdW5kb0RlcHRoID0gLypAX19QVVJFX18qL2RlcHRoKDAgLyogQnJhbmNoTmFtZS5Eb25lICovKTtcbi8qKlxuVGhlIGFtb3VudCBvZiByZWRvYWJsZSBjaGFuZ2UgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmNvbnN0IHJlZG9EZXB0aCA9IC8qQF9fUFVSRV9fKi9kZXB0aCgxIC8qIEJyYW5jaE5hbWUuVW5kb25lICovKTtcbi8vIEhpc3RvcnkgZXZlbnRzIHN0b3JlIGdyb3VwcyBvZiBjaGFuZ2VzIG9yIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlXG4vLyB1bmRvbmUvcmVkb25lIHRvZ2V0aGVyLlxuY2xhc3MgSGlzdEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgY2hhbmdlcyBpbiB0aGlzIGV2ZW50LiBOb3JtYWwgZXZlbnRzIGhvbGQgYXQgbGVhc3Qgb25lXG4gICAgLy8gY2hhbmdlIG9yIGVmZmVjdC4gQnV0IGl0IG1heSBiZSBuZWNlc3NhcnkgdG8gc3RvcmUgc2VsZWN0aW9uXG4gICAgLy8gZXZlbnRzIGJlZm9yZSB0aGUgZmlyc3QgY2hhbmdlLCBpbiB3aGljaCBjYXNlIGEgc3BlY2lhbCB0eXBlIG9mXG4gICAgLy8gaW5zdGFuY2UgaXMgY3JlYXRlZCB3aGljaCBkb2Vzbid0IGhvbGQgYW55IGNoYW5nZXMsIHdpdGhcbiAgICAvLyBjaGFuZ2VzID09IHN0YXJ0U2VsZWN0aW9uID09IHVuZGVmaW5lZFxuICAgIGNoYW5nZXMsIFxuICAgIC8vIFRoZSBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50XG4gICAgZWZmZWN0cywgXG4gICAgLy8gQWNjdW11bGF0ZWQgbWFwcGluZyAoZnJvbSBhZGRUb0hpc3Rvcnk9PWZhbHNlKSB0aGF0IHNob3VsZCBiZVxuICAgIC8vIGFwcGxpZWQgdG8gZXZlbnRzIGJlbG93IHRoaXMgb25lLlxuICAgIG1hcHBlZCwgXG4gICAgLy8gVGhlIHNlbGVjdGlvbiBiZWZvcmUgdGhpcyBldmVudFxuICAgIHN0YXJ0U2VsZWN0aW9uLCBcbiAgICAvLyBTdG9yZXMgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIgdGhpcyBldmVudCwgdG8gYmUgdXNlZCBmb3JcbiAgICAvLyBzZWxlY3Rpb24gdW5kby9yZWRvLlxuICAgIHNlbGVjdGlvbnNBZnRlcikge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLm1hcHBlZCA9IG1hcHBlZDtcbiAgICAgICAgdGhpcy5zdGFydFNlbGVjdGlvbiA9IHN0YXJ0U2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnNBZnRlciA9IHNlbGVjdGlvbnNBZnRlcjtcbiAgICB9XG4gICAgc2V0U2VsQWZ0ZXIoYWZ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodGhpcy5jaGFuZ2VzLCB0aGlzLmVmZmVjdHMsIHRoaXMubWFwcGVkLCB0aGlzLnN0YXJ0U2VsZWN0aW9uLCBhZnRlcik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzOiAoX2EgPSB0aGlzLmNoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKSxcbiAgICAgICAgICAgIG1hcHBlZDogKF9iID0gdGhpcy5tYXBwZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0pTT04oKSxcbiAgICAgICAgICAgIHN0YXJ0U2VsZWN0aW9uOiAoX2MgPSB0aGlzLnN0YXJ0U2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9KU09OKCksXG4gICAgICAgICAgICBzZWxlY3Rpb25zQWZ0ZXI6IHRoaXMuc2VsZWN0aW9uc0FmdGVyLm1hcChzID0+IHMudG9KU09OKCkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KGpzb24uY2hhbmdlcyAmJiBDaGFuZ2VTZXQuZnJvbUpTT04oanNvbi5jaGFuZ2VzKSwgW10sIGpzb24ubWFwcGVkICYmIENoYW5nZURlc2MuZnJvbUpTT04oanNvbi5tYXBwZWQpLCBqc29uLnN0YXJ0U2VsZWN0aW9uICYmIEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnN0YXJ0U2VsZWN0aW9uKSwganNvbi5zZWxlY3Rpb25zQWZ0ZXIubWFwKEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTikpO1xuICAgIH1cbiAgICAvLyBUaGlzIGRvZXMgbm90IGNoZWNrIGBhZGRUb0hpc3RvcnlgIGFuZCBzdWNoLCBpdCBhc3N1bWVzIHRoZVxuICAgIC8vIHRyYW5zYWN0aW9uIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhbiBpdGVtLiBSZXR1cm5zIG51bGwgd2hlblxuICAgIC8vIHRoZXJlIGFyZSBubyBjaGFuZ2VzIG9yIGVmZmVjdHMgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgIHN0YXRpYyBmcm9tVHJhbnNhY3Rpb24odHIsIHNlbGVjdGlvbikge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IG5vbmU7XG4gICAgICAgIGZvciAobGV0IGludmVydCBvZiB0ci5zdGFydFN0YXRlLmZhY2V0KGludmVydGVkRWZmZWN0cykpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBpbnZlcnQodHIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZWZmZWN0cyA9IGVmZmVjdHMuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlZmZlY3RzLmxlbmd0aCAmJiB0ci5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRyLmNoYW5nZXMuaW52ZXJ0KHRyLnN0YXJ0U3RhdGUuZG9jKSwgZWZmZWN0cywgdW5kZWZpbmVkLCBzZWxlY3Rpb24gfHwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIG5vbmUpO1xuICAgIH1cbiAgICBzdGF0aWMgc2VsZWN0aW9uKHNlbGVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodW5kZWZpbmVkLCBub25lLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgc2VsZWN0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQnJhbmNoKGJyYW5jaCwgdG8sIG1heExlbiwgbmV3RXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSB0byArIDEgPiBtYXhMZW4gKyAyMCA/IHRvIC0gbWF4TGVuIC0gMSA6IDA7XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZShzdGFydCwgdG8pO1xuICAgIG5ld0JyYW5jaC5wdXNoKG5ld0V2ZW50KTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuZnVuY3Rpb24gaXNBZGphY2VudChhLCBiKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBpc0FkamFjZW50ID0gZmFsc2U7XG4gICAgYS5pdGVyQ2hhbmdlZFJhbmdlcygoZiwgdCkgPT4gcmFuZ2VzLnB1c2goZiwgdCkpO1xuICAgIGIuaXRlckNoYW5nZWRSYW5nZXMoKF9mLCBfdCwgZiwgdCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tpKytdLCB0byA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgaWYgKHQgPj0gZnJvbSAmJiBmIDw9IHRvKVxuICAgICAgICAgICAgICAgIGlzQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQWRqYWNlbnQ7XG59XG5mdW5jdGlvbiBlcVNlbGVjdGlvblNoYXBlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5yYW5nZXMubGVuZ3RoID09IGIucmFuZ2VzLmxlbmd0aCAmJlxuICAgICAgICBhLnJhbmdlcy5maWx0ZXIoKHIsIGkpID0+IHIuZW1wdHkgIT0gYi5yYW5nZXNbaV0uZW1wdHkpLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIGNvbmMoYSwgYikge1xuICAgIHJldHVybiAhYS5sZW5ndGggPyBiIDogIWIubGVuZ3RoID8gYSA6IGEuY29uY2F0KGIpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuY29uc3QgTWF4U2VsZWN0aW9uc1BlckV2ZW50ID0gMjAwO1xuZnVuY3Rpb24gYWRkU2VsZWN0aW9uKGJyYW5jaCwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbSGlzdEV2ZW50LnNlbGVjdGlvbihbc2VsZWN0aW9uXSldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGxhc3RFdmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBzZWxzID0gbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5zbGljZShNYXRoLm1heCgwLCBsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIE1heFNlbGVjdGlvbnNQZXJFdmVudCkpO1xuICAgICAgICBpZiAoc2Vscy5sZW5ndGggJiYgc2Vsc1tzZWxzLmxlbmd0aCAtIDFdLmVxKHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICBzZWxzLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUJyYW5jaChicmFuY2gsIGJyYW5jaC5sZW5ndGggLSAxLCAxZTksIGxhc3RFdmVudC5zZXRTZWxBZnRlcihzZWxzKSk7XG4gICAgfVxufVxuLy8gQXNzdW1lcyB0aGUgdG9wIGl0ZW0gaGFzIG9uZSBvciBtb3JlIHNlbGVjdGlvbkFmdGVyIHZhbHVlc1xuZnVuY3Rpb24gcG9wU2VsZWN0aW9uKGJyYW5jaCkge1xuICAgIGxldCBsYXN0ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICBsZXQgbmV3QnJhbmNoID0gYnJhbmNoLnNsaWNlKCk7XG4gICAgbmV3QnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXSA9IGxhc3Quc2V0U2VsQWZ0ZXIobGFzdC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoMCwgbGFzdC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBuZXdCcmFuY2g7XG59XG4vLyBBZGQgYSBtYXBwaW5nIHRvIHRoZSB0b3AgZXZlbnQgaW4gdGhlIGdpdmVuIGJyYW5jaC4gSWYgdGhpcyBtYXBzXG4vLyBhd2F5IGFsbCB0aGUgY2hhbmdlcyBhbmQgZWZmZWN0cyBpbiB0aGF0IGl0ZW0sIGRyb3AgaXQgYW5kXG4vLyBwcm9wYWdhdGUgdGhlIG1hcHBpbmcgdG8gdGhlIG5leHQgaXRlbS5cbmZ1bmN0aW9uIGFkZE1hcHBpbmdUb0JyYW5jaChicmFuY2gsIG1hcHBpbmcpIHtcbiAgICBpZiAoIWJyYW5jaC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgbGV0IGxlbmd0aCA9IGJyYW5jaC5sZW5ndGgsIHNlbGVjdGlvbnMgPSBub25lO1xuICAgIHdoaWxlIChsZW5ndGgpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gbWFwRXZlbnQoYnJhbmNoW2xlbmd0aCAtIDFdLCBtYXBwaW5nLCBzZWxlY3Rpb25zKTtcbiAgICAgICAgaWYgKGV2ZW50LmNoYW5nZXMgJiYgIWV2ZW50LmNoYW5nZXMuZW1wdHkgfHwgZXZlbnQuZWZmZWN0cy5sZW5ndGgpIHsgLy8gRXZlbnQgc3Vydml2ZWQgbWFwcGluZ1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGJyYW5jaC5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0W2xlbmd0aCAtIDFdID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBEcm9wIHRoaXMgZXZlbnQsIHNpbmNlIHRoZXJlJ3Mgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGxlZnRcbiAgICAgICAgICAgIG1hcHBpbmcgPSBldmVudC5tYXBwZWQ7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIHNlbGVjdGlvbnMgPSBldmVudC5zZWxlY3Rpb25zQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGlvbnMubGVuZ3RoID8gW0hpc3RFdmVudC5zZWxlY3Rpb24oc2VsZWN0aW9ucyldIDogbm9uZTtcbn1cbmZ1bmN0aW9uIG1hcEV2ZW50KGV2ZW50LCBtYXBwaW5nLCBleHRyYVNlbGVjdGlvbnMpIHtcbiAgICBsZXQgc2VsZWN0aW9ucyA9IGNvbmMoZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCA/IGV2ZW50LnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLm1hcChtYXBwaW5nKSkgOiBub25lLCBleHRyYVNlbGVjdGlvbnMpO1xuICAgIC8vIENoYW5nZS1sZXNzIGV2ZW50cyBkb24ndCBzdG9yZSBtYXBwaW5ncyAodGhleSBhcmUgYWx3YXlzIHRoZSBsYXN0IGV2ZW50IGluIGEgYnJhbmNoKVxuICAgIGlmICghZXZlbnQuY2hhbmdlcylcbiAgICAgICAgcmV0dXJuIEhpc3RFdmVudC5zZWxlY3Rpb24oc2VsZWN0aW9ucyk7XG4gICAgbGV0IG1hcHBlZENoYW5nZXMgPSBldmVudC5jaGFuZ2VzLm1hcChtYXBwaW5nKSwgYmVmb3JlID0gbWFwcGluZy5tYXBEZXNjKGV2ZW50LmNoYW5nZXMsIHRydWUpO1xuICAgIGxldCBmdWxsTWFwcGluZyA9IGV2ZW50Lm1hcHBlZCA/IGV2ZW50Lm1hcHBlZC5jb21wb3NlRGVzYyhiZWZvcmUpIDogYmVmb3JlO1xuICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KG1hcHBlZENoYW5nZXMsIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZXZlbnQuZWZmZWN0cywgbWFwcGluZyksIGZ1bGxNYXBwaW5nLCBldmVudC5zdGFydFNlbGVjdGlvbi5tYXAoYmVmb3JlKSwgc2VsZWN0aW9ucyk7XG59XG5jb25zdCBqb2luYWJsZVVzZXJFdmVudCA9IC9eKGlucHV0XFwudHlwZXxkZWxldGUpKCR8XFwuKS87XG5jbGFzcyBIaXN0b3J5U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbmUsIHVuZG9uZSwgcHJldlRpbWUgPSAwLCBwcmV2VXNlckV2ZW50ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldlVzZXJFdmVudCA9IHByZXZVc2VyRXZlbnQ7XG4gICAgfVxuICAgIGlzb2xhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZUaW1lID8gbmV3IEhpc3RvcnlTdGF0ZSh0aGlzLmRvbmUsIHRoaXMudW5kb25lKSA6IHRoaXM7XG4gICAgfVxuICAgIGFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLCB0cikge1xuICAgICAgICBsZXQgZG9uZSA9IHRoaXMuZG9uZSwgbGFzdEV2ZW50ID0gZG9uZVtkb25lLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdEV2ZW50ICYmIGxhc3RFdmVudC5jaGFuZ2VzICYmICFsYXN0RXZlbnQuY2hhbmdlcy5lbXB0eSAmJiBldmVudC5jaGFuZ2VzICYmXG4gICAgICAgICAgICAoIXVzZXJFdmVudCB8fCBqb2luYWJsZVVzZXJFdmVudC50ZXN0KHVzZXJFdmVudCkpICYmXG4gICAgICAgICAgICAoKCFsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgY29uZmlnLm5ld0dyb3VwRGVsYXkgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuam9pblRvRXZlbnQodHIsIGlzQWRqYWNlbnQobGFzdEV2ZW50LmNoYW5nZXMsIGV2ZW50LmNoYW5nZXMpKSkgfHxcbiAgICAgICAgICAgICAgICAvLyBGb3IgY29tcG9zZSAoYnV0IG5vdCBjb21wb3NlLnN0YXJ0KSBldmVudHMsIGFsd2F5cyBqb2luIHdpdGggcHJldmlvdXMgZXZlbnRcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQgPT0gXCJpbnB1dC50eXBlLmNvbXBvc2VcIikpIHtcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGggLSAxLCBjb25maWcubWluRGVwdGgsIG5ldyBIaXN0RXZlbnQoZXZlbnQuY2hhbmdlcy5jb21wb3NlKGxhc3RFdmVudC5jaGFuZ2VzKSwgY29uYyhldmVudC5lZmZlY3RzLCBsYXN0RXZlbnQuZWZmZWN0cyksIGxhc3RFdmVudC5tYXBwZWQsIGxhc3RFdmVudC5zdGFydFNlbGVjdGlvbiwgbm9uZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9uZSA9IHVwZGF0ZUJyYW5jaChkb25lLCBkb25lLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZG9uZSwgbm9uZSwgdGltZSwgdXNlckV2ZW50KTtcbiAgICB9XG4gICAgYWRkU2VsZWN0aW9uKHNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBuZXdHcm91cERlbGF5KSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb25lLmxlbmd0aCA/IHRoaXMuZG9uZVt0aGlzLmRvbmUubGVuZ3RoIC0gMV0uc2VsZWN0aW9uc0FmdGVyIDogbm9uZTtcbiAgICAgICAgaWYgKGxhc3QubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBuZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICB1c2VyRXZlbnQgPT0gdGhpcy5wcmV2VXNlckV2ZW50ICYmIHVzZXJFdmVudCAmJiAvXnNlbGVjdCgkfFxcLikvLnRlc3QodXNlckV2ZW50KSAmJlxuICAgICAgICAgICAgZXFTZWxlY3Rpb25TaGFwZShsYXN0W2xhc3QubGVuZ3RoIC0gMV0sIHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoYWRkU2VsZWN0aW9uKHRoaXMuZG9uZSwgc2VsZWN0aW9uKSwgdGhpcy51bmRvbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZE1hcHBpbmcobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRNYXBwaW5nVG9CcmFuY2godGhpcy5kb25lLCBtYXBwaW5nKSwgYWRkTWFwcGluZ1RvQnJhbmNoKHRoaXMudW5kb25lLCBtYXBwaW5nKSwgdGhpcy5wcmV2VGltZSwgdGhpcy5wcmV2VXNlckV2ZW50KTtcbiAgICB9XG4gICAgcG9wKHNpZGUsIHN0YXRlLCBvbmx5U2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gdGhpcy5kb25lIDogdGhpcy51bmRvbmU7XG4gICAgICAgIGlmIChicmFuY2gubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGV2ZW50ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXSwgc2VsZWN0aW9uID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyWzBdIHx8IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG9ubHlTZWxlY3Rpb24gJiYgZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zZWxlY3Rpb25zQWZ0ZXJbZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3Q6IHBvcFNlbGVjdGlvbihicmFuY2gpLCBzZWxlY3Rpb24gfSksXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJzZWxlY3QudW5kb1wiIDogXCJzZWxlY3QucmVkb1wiLFxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZXZlbnQuY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzdCA9IGJyYW5jaC5sZW5ndGggPT0gMSA/IG5vbmUgOiBicmFuY2guc2xpY2UoMCwgYnJhbmNoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKGV2ZW50Lm1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN0ID0gYWRkTWFwcGluZ1RvQnJhbmNoKHJlc3QsIGV2ZW50Lm1hcHBlZCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBldmVudC5jaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQuc3RhcnRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogZXZlbnQuZWZmZWN0cyxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZnJvbUhpc3Rvcnkub2YoeyBzaWRlLCByZXN0LCBzZWxlY3Rpb24gfSksXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBcInVuZG9cIiA6IFwicmVkb1wiLFxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkhpc3RvcnlTdGF0ZS5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgSGlzdG9yeVN0YXRlKG5vbmUsIG5vbmUpO1xuLyoqXG5EZWZhdWx0IGtleSBiaW5kaW5ncyBmb3IgdGhlIHVuZG8gaGlzdG9yeS5cblxuLSBNb2QtejogW2B1bmRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy51bmRvKS5cbi0gTW9kLXkgKE1vZC1TaGlmdC16IG9uIG1hY09TKSArIEN0cmwtU2hpZnQteiBvbiBMaW51eDogW2ByZWRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5yZWRvKS5cbi0gTW9kLXU6IFtgdW5kb1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudW5kb1NlbGVjdGlvbikuXG4tIEFsdC11IChNb2QtU2hpZnQtdSBvbiBtYWNPUyk6IFtgcmVkb1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkb1NlbGVjdGlvbikuXG4qL1xuY29uc3QgaGlzdG9yeUtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtelwiLCBydW46IHVuZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLXlcIiwgbWFjOiBcIk1vZC1TaGlmdC16XCIsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGxpbnV4OiBcIkN0cmwtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLXVcIiwgcnVuOiB1bmRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFsdC11XCIsIG1hYzogXCJNb2QtU2hpZnQtdVwiLCBydW46IHJlZG9TZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH1cbl07XG5cbmZ1bmN0aW9uIHVwZGF0ZVNlbChzZWwsIGJ5KSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsLnJhbmdlcy5tYXAoYnkpLCBzZWwubWFpbkluZGV4KTtcbn1cbmZ1bmN0aW9uIHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KTtcbn1cbmZ1bmN0aW9uIG1vdmVTZWwoeyBzdGF0ZSwgZGlzcGF0Y2ggfSwgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIGhvdyk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24sIHRydWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IHJhbmdlLnRvIDogcmFuZ2UuZnJvbSk7XG59XG5mdW5jdGlvbiBjdXJzb3JCeUNoYXIodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG5mdW5jdGlvbiBsdHJBdEN1cnNvcih2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbkF0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkgPT0gRGlyZWN0aW9uLkxUUjtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQgKHdoaWNoIGlzIGJhY2t3YXJkIGluXG5sZWZ0LXRvLXJpZ2h0IHRleHQsIGZvcndhcmQgaW4gcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiovXG5jb25zdCBjdXJzb3JDaGFyTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JDaGFyUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gY3Vyc29yQnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbGVmdCBhY3Jvc3Mgb25lIGdyb3VwIG9mIHdvcmQgb3Jcbm5vbi13b3JkIChidXQgYWxzbyBub24tc3BhY2UpIGNoYXJhY3RlcnMuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBMZWZ0ID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgZmFsc2UpO1xuY29uc3Qgc2VnbWVudGVyID0gdHlwZW9mIEludGwgIT0gXCJ1bmRlZmluZWRcIiAmJiBJbnRsLlNlZ21lbnRlciA/XG4gICAgLypAX19QVVJFX18qL25ldyAoSW50bC5TZWdtZW50ZXIpKHVuZGVmaW5lZCwgeyBncmFudWxhcml0eTogXCJ3b3JkXCIgfSkgOiBudWxsO1xuZnVuY3Rpb24gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkge1xuICAgIGxldCBjYXRlZ29yaXplID0gdmlldy5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuZnJvbSk7XG4gICAgbGV0IGNhdCA9IENoYXJDYXRlZ29yeS5TcGFjZSwgcG9zID0gcmFuZ2UuZnJvbSwgc3RlcHMgPSAwO1xuICAgIGxldCBkb25lID0gZmFsc2UsIHNhd1VwcGVyID0gZmFsc2UsIHNhd0xvd2VyID0gZmFsc2U7XG4gICAgbGV0IHN0ZXAgPSAobmV4dCkgPT4ge1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcG9zICs9IGZvcndhcmQgPyBuZXh0Lmxlbmd0aCA6IC1uZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpLCBhaGVhZDtcbiAgICAgICAgaWYgKG5leHRDYXQgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiYgbmV4dC5jaGFyQ29kZUF0KDApIDwgMTI4ICYmIC9bXFxXX10vLnRlc3QobmV4dCkpXG4gICAgICAgICAgICBuZXh0Q2F0ID0gLTE7IC8vIFRyZWF0IHdvcmQgcHVuY3R1YXRpb24gc3BlY2lhbGx5XG4gICAgICAgIGlmIChjYXQgPT0gQ2hhckNhdGVnb3J5LlNwYWNlKVxuICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcbiAgICAgICAgaWYgKGNhdCAhPSBuZXh0Q2F0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkKSB7XG4gICAgICAgICAgICBpZiAobmV4dC50b0xvd2VyQ2FzZSgpID09IG5leHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcndhcmQgJiYgc2F3VXBwZXIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBzYXdMb3dlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYXdMb3dlcikge1xuICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc2F3VXBwZXIgJiYgZm9yd2FyZCAmJiBjYXRlZ29yaXplKGFoZWFkID0gdmlldy5zdGF0ZS5zbGljZURvYyhwb3MsIHBvcyArIDEpKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZCAmJlxuICAgICAgICAgICAgICAgICAgICBhaGVhZC50b0xvd2VyQ2FzZSgpID09IGFoZWFkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2F3VXBwZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ZXBzKys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgbGV0IGVuZCA9IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgZm9yd2FyZCwgc3RhcnQgPT4ge1xuICAgICAgICBzdGVwKHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfSk7XG4gICAgaWYgKHNlZ21lbnRlciAmJiBjYXQgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiYgZW5kLmZyb20gPT0gcmFuZ2UuZnJvbSArIHN0ZXBzICogKGZvcndhcmQgPyAxIDogLTEpKSB7XG4gICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4ocmFuZ2UuaGVhZCwgZW5kLmhlYWQpLCB0byA9IE1hdGgubWF4KHJhbmdlLmhlYWQsIGVuZC5oZWFkKTtcbiAgICAgICAgbGV0IHNraXBwZWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMSAmJiAvW1xcdTRFMDAtXFx1ZmZmZl0vLnRlc3Qoc2tpcHBlZCkpIHtcbiAgICAgICAgICAgIGxldCBzZWdtZW50cyA9IEFycmF5LmZyb20oc2VnbWVudGVyLnNlZ21lbnQoc2tpcHBlZCkpO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCArIHNlZ21lbnRzWzFdLmluZGV4LCAtMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZW5kLmhlYWQgKyBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5pbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5U3Vid29yZCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyBtb3ZlQnlTdWJ3b3JkKHZpZXcsIHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yU3Vid29yZEZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5U3Vid29yZCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yU3Vid29yZEJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeVN1YndvcmQodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gaW50ZXJlc3RpbmdOb2RlKHN0YXRlLCBub2RlLCBicmFja2V0UHJvcCkge1xuICAgIGlmIChub2RlLnR5cGUucHJvcChicmFja2V0UHJvcCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBsZW4gPSBub2RlLnRvIC0gbm9kZS5mcm9tO1xuICAgIHJldHVybiBsZW4gJiYgKGxlbiA+IDIgfHwgL1teXFxzLC47Ol0vLnRlc3Qoc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBub2RlLnRvKSkpIHx8IG5vZGUuZmlyc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIG1vdmVCeVN5bnRheChzdGF0ZSwgc3RhcnQsIGZvcndhcmQpIHtcbiAgICBsZXQgcG9zID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHN0YXJ0LmhlYWQpO1xuICAgIGxldCBicmFja2V0UHJvcCA9IGZvcndhcmQgPyBOb2RlUHJvcC5jbG9zZWRCeSA6IE5vZGVQcm9wLm9wZW5lZEJ5O1xuICAgIC8vIFNjYW4gZm9yd2FyZCB0aHJvdWdoIGNoaWxkIG5vZGVzIHRvIHNlZSBpZiB0aGVyZSdzIGFuIGludGVyZXN0aW5nXG4gICAgLy8gbm9kZSBhaGVhZC5cbiAgICBmb3IgKGxldCBhdCA9IHN0YXJ0LmhlYWQ7Oykge1xuICAgICAgICBsZXQgbmV4dCA9IGZvcndhcmQgPyBwb3MuY2hpbGRBZnRlcihhdCkgOiBwb3MuY2hpbGRCZWZvcmUoYXQpO1xuICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbmV4dCwgYnJhY2tldFByb3ApKVxuICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYXQgPSBmb3J3YXJkID8gbmV4dC50byA6IG5leHQuZnJvbTtcbiAgICB9XG4gICAgbGV0IGJyYWNrZXQgPSBwb3MudHlwZS5wcm9wKGJyYWNrZXRQcm9wKSwgbWF0Y2gsIG5ld1BvcztcbiAgICBpZiAoYnJhY2tldCAmJiAobWF0Y2ggPSBmb3J3YXJkID8gbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcG9zLmZyb20sIDEpIDogbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcG9zLnRvLCAtMSkpICYmIG1hdGNoLm1hdGNoZWQpXG4gICAgICAgIG5ld1BvcyA9IGZvcndhcmQgPyBtYXRjaC5lbmQudG8gOiBtYXRjaC5lbmQuZnJvbTtcbiAgICBlbHNlXG4gICAgICAgIG5ld1BvcyA9IGZvcndhcmQgPyBwb3MudG8gOiBwb3MuZnJvbTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXdQb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBjdXJzb3JTeW50YXhMZWZ0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIGN1cnNvciBvdmVyIHRoZSBuZXh0IHN5bnRhY3RpYyBlbGVtZW50IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JTeW50YXhSaWdodCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG5mdW5jdGlvbiBjdXJzb3JCeUxpbmUodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCk7XG4gICAgICAgIGxldCBtb3ZlZCA9IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICByZXR1cm4gbW92ZWQuaGVhZCAhPSByYW5nZS5oZWFkID8gbW92ZWQgOiB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZm9yd2FyZCk7XG4gICAgfSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB1cC5cbiovXG5jb25zdCBjdXJzb3JMaW5lVXAgPSB2aWV3ID0+IGN1cnNvckJ5TGluZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSBkb3duLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVEb3duID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgdHJ1ZSk7XG5mdW5jdGlvbiBwYWdlSW5mbyh2aWV3KSB7XG4gICAgbGV0IHNlbGZTY3JvbGwgPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQgPCB2aWV3LnNjcm9sbERPTS5zY3JvbGxIZWlnaHQgLSAyO1xuICAgIGxldCBtYXJnaW5Ub3AgPSAwLCBtYXJnaW5Cb3R0b20gPSAwLCBoZWlnaHQ7XG4gICAgaWYgKHNlbGZTY3JvbGwpIHtcbiAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHZpZXcuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zKSkge1xuICAgICAgICAgICAgbGV0IG1hcmdpbnMgPSBzb3VyY2Uodmlldyk7XG4gICAgICAgICAgICBpZiAobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLnRvcClcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBNYXRoLm1heChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMudG9wLCBtYXJnaW5Ub3ApO1xuICAgICAgICAgICAgaWYgKG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy5ib3R0b20pXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gTWF0aC5tYXgobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLmJvdHRvbSwgbWFyZ2luQm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgICBoZWlnaHQgPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQgLSBtYXJnaW5Ub3AgLSBtYXJnaW5Cb3R0b207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBoZWlnaHQgPSAodmlldy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmlubmVySGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4geyBtYXJnaW5Ub3AsIG1hcmdpbkJvdHRvbSwgc2VsZlNjcm9sbCxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCh2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0LCBoZWlnaHQgLSA1KSB9O1xufVxuZnVuY3Rpb24gY3Vyc29yQnlQYWdlKHZpZXcsIGZvcndhcmQpIHtcbiAgICBsZXQgcGFnZSA9IHBhZ2VJbmZvKHZpZXcpO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIHJldHVybiByYW5nZS5lbXB0eSA/IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQsIHBhZ2UuaGVpZ2h0KVxuICAgICAgICAgICAgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdDtcbiAgICBpZiAocGFnZS5zZWxmU2Nyb2xsKSB7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHZpZXcuY29vcmRzQXRQb3Moc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGxldCBzY3JvbGxSZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSBzY3JvbGxSZWN0LnRvcCArIHBhZ2UubWFyZ2luVG9wLCBzY3JvbGxCb3R0b20gPSBzY3JvbGxSZWN0LmJvdHRvbSAtIHBhZ2UubWFyZ2luQm90dG9tO1xuICAgICAgICBpZiAoc3RhcnRQb3MgJiYgc3RhcnRQb3MudG9wID4gc2Nyb2xsVG9wICYmIHN0YXJ0UG9zLmJvdHRvbSA8IHNjcm9sbEJvdHRvbSlcbiAgICAgICAgICAgIGVmZmVjdCA9IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcoc2VsZWN0aW9uLm1haW4uaGVhZCwgeyB5OiBcInN0YXJ0XCIsIHlNYXJnaW46IHN0YXJ0UG9zLnRvcCAtIHNjcm9sbFRvcCB9KTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbiksIHsgZWZmZWN0czogZWZmZWN0IH0pO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIHBhZ2UgdXAuXG4qL1xuY29uc3QgY3Vyc29yUGFnZVVwID0gdmlldyA9PiBjdXJzb3JCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIHBhZ2UgZG93bi5cbiovXG5jb25zdCBjdXJzb3JQYWdlRG93biA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHN0YXJ0LmhlYWQpLCBtb3ZlZCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHN0YXJ0LCBmb3J3YXJkKTtcbiAgICBpZiAobW92ZWQuaGVhZCA9PSBzdGFydC5oZWFkICYmIG1vdmVkLmhlYWQgIT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSlcbiAgICAgICAgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgZmFsc2UpO1xuICAgIGlmICghZm9yd2FyZCAmJiBtb3ZlZC5oZWFkID09IGxpbmUuZnJvbSAmJiBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgc3BhY2UgPSAvXlxccyovLmV4ZWModmlldy5zdGF0ZS5zbGljZURvYyhsaW5lLmZyb20sIE1hdGgubWluKGxpbmUuZnJvbSArIDEwMCwgbGluZS50bykpKVswXS5sZW5ndGg7XG4gICAgICAgIGlmIChzcGFjZSAmJiBzdGFydC5oZWFkICE9IGxpbmUuZnJvbSArIHNwYWNlKVxuICAgICAgICAgICAgbW92ZWQgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGxpbmUuZnJvbSArIHNwYWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdmVkO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgbGluZSB3cmFwIHBvaW50LCBvciB0byB0aGUgZW5kIG9mXG50aGUgbGluZSBpZiB0aGVyZSBpc24ndCBvbmUgbGVmdCBvbiB0aGlzIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIHRydWUpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHByZXZpb3VzIGxpbmUgd3JhcCBwb2ludCwgb3IgZmFpbGluZyB0aGF0IHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBsaW5lIGlzIGluZGVudGVkLCBhbmQgdGhlIGN1cnNvclxuaXNuJ3QgYWxyZWFkeSBhdCB0aGUgZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiwgdGhpcyB3aWxsIG1vdmUgdG8gdGhlXG5lbmQgb2YgdGhlIGluZGVudGF0aW9uIGluc3RlYWQgb2YgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgd3JhcCBwb2ludCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVTdGFydCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbSwgMSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lRW5kID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bywgLTEpKTtcbmZ1bmN0aW9uIHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZXh0ZW5kKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2UsIHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IG1hdGNoaW5nID0gbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgLTEpXG4gICAgICAgICAgICB8fCBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkLCAxKVxuICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPiAwICYmIG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQgLSAxLCAxKSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkIDwgc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEpKTtcbiAgICAgICAgaWYgKCFtYXRjaGluZyB8fCAhbWF0Y2hpbmcuZW5kKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGxldCBoZWFkID0gbWF0Y2hpbmcuc3RhcnQuZnJvbSA9PSByYW5nZS5oZWFkID8gbWF0Y2hpbmcuZW5kLnRvIDogbWF0Y2hpbmcuZW5kLmZyb207XG4gICAgICAgIHJldHVybiBleHRlbmQgPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuYW5jaG9yLCBoZWFkKSA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoaGVhZCk7XG4gICAgfSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIGl0IGlzIGN1cnJlbnRseVxub24sIGlmIGFueS5cbiovXG5jb25zdCBjdXJzb3JNYXRjaGluZ0JyYWNrZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbkV4dGVuZCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBicmFja2V0IG1hdGNoaW5nIHRoZSBvbmUgdGhlIHNlbGVjdGlvblxuaGVhZCBpcyBjdXJyZW50bHkgb24sIGlmIGFueS5cbiovXG5jb25zdCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gdG9NYXRjaGluZ0JyYWNrZXQoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbmZ1bmN0aW9uIGV4dGVuZFNlbCh2aWV3LCBob3cpIHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHZpZXcuc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBoZWFkID0gaG93KHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IsIGhlYWQuaGVhZCwgaGVhZC5nb2FsQ29sdW1uLCBoZWFkLmJpZGlMZXZlbCB8fCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaChzZXRTZWwodmlldy5zdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZWxlY3RCeUNoYXIodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQsIHdoaWxlIGxlYXZpbmdcbnRoZSBhbmNob3IgaW4gcGxhY2UuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckxlZnQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RDaGFyUmlnaHQgPSB2aWV3ID0+IHNlbGVjdEJ5Q2hhcih2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgZm9yd2FyZC5cbiovXG5jb25zdCBzZWxlY3RDaGFyRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5R3JvdXAodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlHcm91cChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwTGVmdCkgdG9cbnRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwTGVmdCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCAhbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwUmlnaHQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgZm9yd2FyZC5cbiovXG5jb25zdCBzZWxlY3RHcm91cEZvcndhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RHcm91cEJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5U3Vid29yZCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTdWJ3b3JkKHZpZXcsIHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBvciBjYW1lbC1jYXNlIHN1YndvcmQgZm9yd2FyZC5cbiovXG5jb25zdCBzZWxlY3RTdWJ3b3JkRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgb3Igc3Vid29yZCBiYWNrd2FyZC5cbiovXG5jb25zdCBzZWxlY3RTdWJ3b3JkQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5U3Vid29yZCh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0U3ludGF4TGVmdCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN5bnRheCh2aWV3LnN0YXRlLCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdFN5bnRheFJpZ2h0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuZnVuY3Rpb24gc2VsZWN0QnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgdXAuXG4qL1xuY29uc3Qgc2VsZWN0TGluZVVwID0gdmlldyA9PiBzZWxlY3RCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVEb3duID0gdmlldyA9PiBzZWxlY3RCeUxpbmUodmlldywgdHJ1ZSk7XG5mdW5jdGlvbiBzZWxlY3RCeVBhZ2UodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCwgcGFnZUluZm8odmlldykuaGVpZ2h0KSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VVcCA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgZG93bi5cbiovXG5jb25zdCBzZWxlY3RQYWdlRG93biA9IHZpZXcgPT4gc2VsZWN0QnlQYWdlKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIHRydWUpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHByZXZpb3VzIGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGJvdW5kYXJ5IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IHNlbGVjdExpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSBib3VuZGFyeSB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBzZWxlY3RMaW5lU3RhcnQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVFbmQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8pKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IDAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IGN1cnNvckRvY0VuZCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdERvY1N0YXJ0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IsIGhlYWQ6IDAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSBlbnRpcmUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0QWxsID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IHsgYW5jaG9yOiAwLCBoZWFkOiBzdGF0ZS5kb2MubGVuZ3RoIH0sIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5FeHBhbmQgdGhlIHNlbGVjdGlvbiB0byBjb3ZlciBlbnRpcmUgbGluZXMuXG4qL1xuY29uc3Qgc2VsZWN0TGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkubWFwKCh7IGZyb20sIHRvIH0pID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCBNYXRoLm1pbih0byArIDEsIHN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcyksIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIG5leHQgc3ludGFjdGljIGNvbnN0cnVjdCB0aGF0IGlzIGxhcmdlciB0aGFuIHRoZVxuc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG9ubHkgd29yayBpbnNvZmFyIGFzIHRoZSBsYW5ndWFnZVxuW3Byb3ZpZGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmxhbmd1YWdlKSB5b3UgdXNlIGJ1aWxkcyB1cCBhIGZ1bGxcbnN5bnRheCB0cmVlLlxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudFN5bnRheCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgc3RhY2sgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlU3RhY2socmFuZ2UuZnJvbSwgMSk7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHN0YWNrOyBjdXI7IGN1ciA9IGN1ci5uZXh0KSB7XG4gICAgICAgICAgICBsZXQgeyBub2RlIH0gPSBjdXI7XG4gICAgICAgICAgICBpZiAoKChub2RlLmZyb20gPCByYW5nZS5mcm9tICYmIG5vZGUudG8gPj0gcmFuZ2UudG8pIHx8XG4gICAgICAgICAgICAgICAgKG5vZGUudG8gPiByYW5nZS50byAmJiBub2RlLmZyb20gPD0gcmFuZ2UuZnJvbSkpICYmXG4gICAgICAgICAgICAgICAgKChfYSA9IG5vZGUucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKG5vZGUudG8sIG5vZGUuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH0pO1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TaW1wbGlmeSB0aGUgY3VycmVudCBzZWxlY3Rpb24uIFdoZW4gbXVsdGlwbGUgcmFuZ2VzIGFyZSBzZWxlY3RlZCxcbnJlZHVjZSBpdCB0byBpdHMgbWFpbiByYW5nZS4gT3RoZXJ3aXNlLCBpZiB0aGUgc2VsZWN0aW9uIGlzXG5ub24tZW1wdHksIGNvbnZlcnQgaXQgdG8gYSBjdXJzb3Igc2VsZWN0aW9uLlxuKi9cbmNvbnN0IHNpbXBsaWZ5U2VsZWN0aW9uID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgY3VyID0gc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3Rpb24gPSBudWxsO1xuICAgIGlmIChjdXIucmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW2N1ci5tYWluXSk7XG4gICAgZWxzZSBpZiAoIWN1ci5tYWluLmVtcHR5KVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGN1ci5tYWluLmhlYWQpXSk7XG4gICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlbGV0ZUJ5KHRhcmdldCwgYnkpIHtcbiAgICBpZiAodGFyZ2V0LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGV2ZW50ID0gXCJkZWxldGUuc2VsZWN0aW9uXCIsIHsgc3RhdGUgfSA9IHRhcmdldDtcbiAgICBsZXQgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChmcm9tID09IHRvKSB7XG4gICAgICAgICAgICBsZXQgdG93YXJkcyA9IGJ5KHJhbmdlKTtcbiAgICAgICAgICAgIGlmICh0b3dhcmRzIDwgZnJvbSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJkZWxldGUuYmFja3dhcmRcIjtcbiAgICAgICAgICAgICAgICB0b3dhcmRzID0gc2tpcEF0b21pYyh0YXJnZXQsIHRvd2FyZHMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvd2FyZHMgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBcImRlbGV0ZS5mb3J3YXJkXCI7XG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb20gPSBNYXRoLm1pbihmcm9tLCB0b3dhcmRzKTtcbiAgICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIHRvd2FyZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHNraXBBdG9taWModGFyZ2V0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgICAgICB0byA9IHNraXBBdG9taWModGFyZ2V0LCB0bywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdG8gPyB7IHJhbmdlIH0gOiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8gfSwgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSwgZnJvbSA8IHJhbmdlLmhlYWQgPyAtMSA6IDEpIH07XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBldmVudCxcbiAgICAgICAgZWZmZWN0czogZXZlbnQgPT0gXCJkZWxldGUuc2VsZWN0aW9uXCIgPyBFZGl0b3JWaWV3LmFubm91bmNlLm9mKHN0YXRlLnBocmFzZShcIlNlbGVjdGlvbiBkZWxldGVkXCIpKSA6IHVuZGVmaW5lZFxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNraXBBdG9taWModGFyZ2V0LCBwb3MsIGZvcndhcmQpIHtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRWRpdG9yVmlldylcbiAgICAgICAgZm9yIChsZXQgcmFuZ2VzIG9mIHRhcmdldC5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LmF0b21pY1JhbmdlcykubWFwKGYgPT4gZih0YXJnZXQpKSlcbiAgICAgICAgICAgIHJhbmdlcy5iZXR3ZWVuKHBvcywgcG9zLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHBvcyAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZm9yd2FyZCA/IHRvIDogZnJvbTtcbiAgICAgICAgICAgIH0pO1xuICAgIHJldHVybiBwb3M7XG59XG5jb25zdCBkZWxldGVCeUNoYXIgPSAodGFyZ2V0LCBmb3J3YXJkKSA9PiBkZWxldGVCeSh0YXJnZXQsIHJhbmdlID0+IHtcbiAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBiZWZvcmUsIHRhcmdldFBvcztcbiAgICBpZiAoIWZvcndhcmQgJiYgcG9zID4gbGluZS5mcm9tICYmIHBvcyA8IGxpbmUuZnJvbSArIDIwMCAmJlxuICAgICAgICAhL1teIFxcdF0vLnRlc3QoYmVmb3JlID0gbGluZS50ZXh0LnNsaWNlKDAsIHBvcyAtIGxpbmUuZnJvbSkpKSB7XG4gICAgICAgIGlmIChiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDFdID09IFwiXFx0XCIpXG4gICAgICAgICAgICByZXR1cm4gcG9zIC0gMTtcbiAgICAgICAgbGV0IGNvbCA9IGNvdW50Q29sdW1uKGJlZm9yZSwgc3RhdGUudGFiU2l6ZSksIGRyb3AgPSBjb2wgJSBnZXRJbmRlbnRVbml0KHN0YXRlKSB8fCBnZXRJbmRlbnRVbml0KHN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcm9wICYmIGJlZm9yZVtiZWZvcmUubGVuZ3RoIC0gMSAtIGldID09IFwiIFwiOyBpKyspXG4gICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgdGFyZ2V0UG9zID0gcG9zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFyZ2V0UG9zID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCwgZm9yd2FyZCkgKyBsaW5lLmZyb207XG4gICAgICAgIGlmICh0YXJnZXRQb3MgPT0gcG9zICYmIGxpbmUubnVtYmVyICE9IChmb3J3YXJkID8gc3RhdGUuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgICAgICB0YXJnZXRQb3MgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgZWxzZSBpZiAoIWZvcndhcmQgJiYgL1tcXHVmZTAwLVxcdWZlMGZdLy50ZXN0KGxpbmUudGV4dC5zbGljZSh0YXJnZXRQb3MgLSBsaW5lLmZyb20sIHBvcyAtIGxpbmUuZnJvbSkpKVxuICAgICAgICAgICAgdGFyZ2V0UG9zID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHRhcmdldFBvcyAtIGxpbmUuZnJvbSwgZmFsc2UsIGZhbHNlKSArIGxpbmUuZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldFBvcztcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGZvciBjdXJzb3Igc2VsZWN0aW9ucywgdGhlIGNoYXJhY3RlclxuYmVmb3JlIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlQ2hhckJhY2t3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgZmFsc2UpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciB0aGUgY2hhcmFjdGVyIGFmdGVyIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlQ2hhckZvcndhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5Q2hhcih2aWV3LCB0cnVlKTtcbmNvbnN0IGRlbGV0ZUJ5R3JvdXAgPSAodGFyZ2V0LCBmb3J3YXJkKSA9PiBkZWxldGVCeSh0YXJnZXQsIHJhbmdlID0+IHtcbiAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgIGxldCBjYXRlZ29yaXplID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgZm9yIChsZXQgY2F0ID0gbnVsbDs7KSB7XG4gICAgICAgIGlmIChwb3MgPT0gKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgaWYgKHBvcyA9PSByYW5nZS5oZWFkICYmIGxpbmUubnVtYmVyICE9IChmb3J3YXJkID8gc3RhdGUuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgICAgICAgICAgcG9zICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQpICsgbGluZS5mcm9tO1xuICAgICAgICBsZXQgbmV4dENoYXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4ocG9zLCBuZXh0KSAtIGxpbmUuZnJvbSwgTWF0aC5tYXgocG9zLCBuZXh0KSAtIGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0Q2hhcik7XG4gICAgICAgIGlmIChjYXQgIT0gbnVsbCAmJiBuZXh0Q2F0ICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dENoYXIgIT0gXCIgXCIgfHwgcG9zICE9IHJhbmdlLmhlYWQpXG4gICAgICAgICAgICBjYXQgPSBuZXh0Q2F0O1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIGJhY2t3YXJkIHVudGlsIHRoZSBlbmQgb2YgdGhlIG5leHRcbltncm91cF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5R3JvdXApLCBvbmx5IHNraXBwaW5nIGdyb3VwcyBvZlxud2hpdGVzcGFjZSB3aGVuIHRoZXkgY29uc2lzdCBvZiBhIHNpbmdsZSBzcGFjZS5cbiovXG5jb25zdCBkZWxldGVHcm91cEJhY2t3YXJkID0gdGFyZ2V0ID0+IGRlbGV0ZUJ5R3JvdXAodGFyZ2V0LCBmYWxzZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uIG9yIGZvcndhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dCBncm91cC5cbiovXG5jb25zdCBkZWxldGVHcm91cEZvcndhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIHRydWUpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgZW5kIG9mIHRoZSBsaW5lLiBJZiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IGF0IHRoZSBlbmQgb2YgdGhlXG5saW5lLCBkZWxldGUgdGhlIGxpbmUgYnJlYWsgYWZ0ZXIgaXQuXG4qL1xuY29uc3QgZGVsZXRlVG9MaW5lRW5kID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVFbmQgPSB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLnRvO1xuICAgIHJldHVybiByYW5nZS5oZWFkIDwgbGluZUVuZCA/IGxpbmVFbmQgOiBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIHJhbmdlLmhlYWQgKyAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIHN0YXJ0IG9mIHRoZVxubGluZSwgZGVsZXRlIHRoZSBsaW5lIGJyZWFrIGJlZm9yZSBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVTdGFydCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb207XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPiBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1heCgwLCByYW5nZS5oZWFkIC0gMSk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lIG9yIHRoZSBuZXh0IGxpbmUgd3JhcCBiZWZvcmUgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gZGVsZXRlQnkodmlldywgcmFuZ2UgPT4ge1xuICAgIGxldCBsaW5lU3RhcnQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZmFsc2UpLmhlYWQ7XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPiBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1heCgwLCByYW5nZS5oZWFkIC0gMSk7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBpZiBpdCBpcyBhIGN1cnNvciBzZWxlY3Rpb24sIGRlbGV0ZSB0b1xudGhlIGVuZCBvZiB0aGUgbGluZSBvciB0aGUgbmV4dCBsaW5lIHdyYXAgYWZ0ZXIgdGhlIGN1cnNvci5cbiovXG5jb25zdCBkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCB0cnVlKS5oZWFkO1xuICAgIHJldHVybiByYW5nZS5oZWFkIDwgbGluZVN0YXJ0ID8gbGluZVN0YXJ0IDogTWF0aC5taW4odmlldy5zdGF0ZS5kb2MubGVuZ3RoLCByYW5nZS5oZWFkICsgMSk7XG59KTtcbi8qKlxuRGVsZXRlIGFsbCB3aGl0ZXNwYWNlIGRpcmVjdGx5IGJlZm9yZSBhIGxpbmUgZW5kIGZyb20gdGhlXG5kb2N1bWVudC5cbiovXG5jb25zdCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gMCwgcHJldiA9IFwiXCIsIGl0ZXIgPSBzdGF0ZS5kb2MuaXRlcigpOzspIHtcbiAgICAgICAgaXRlci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVyLmxpbmVCcmVhayB8fCBpdGVyLmRvbmUpIHtcbiAgICAgICAgICAgIGxldCB0cmFpbGluZyA9IHByZXYuc2VhcmNoKC9cXHMrJC8pO1xuICAgICAgICAgICAgaWYgKHRyYWlsaW5nID4gLTEpXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogcG9zIC0gKHByZXYubGVuZ3RoIC0gdHJhaWxpbmcpLCB0bzogcG9zIH0pO1xuICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHByZXYgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJldiA9IGl0ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGl0ZXIudmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgY2hhbmdlcywgdXNlckV2ZW50OiBcImRlbGV0ZVwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgZWFjaCBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCBhIGxpbmUgYnJlYWssIGxlYXZpbmcgdGhlIGN1cnNvclxub24gdGhlIGxpbmUgYmVmb3JlIHRoZSBicmVhay5cbiovXG5jb25zdCBzcGxpdExpbmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiXCIsIFwiXCJdKSB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSkgfTtcbiAgICB9KTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRmxpcCB0aGUgY2hhcmFjdGVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjdXJzb3IocykuXG4qL1xuY29uc3QgdHJhbnNwb3NlQ2hhcnMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgfHwgcmFuZ2UuZnJvbSA9PSAwIHx8IHJhbmdlLmZyb20gPT0gc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgIGxldCBwb3MgPSByYW5nZS5mcm9tLCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgZnJvbSA9IHBvcyA9PSBsaW5lLmZyb20gPyBwb3MgLSAxIDogZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZmFsc2UpICsgbGluZS5mcm9tO1xuICAgICAgICBsZXQgdG8gPSBwb3MgPT0gbGluZS50byA/IHBvcyArIDEgOiBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCB0cnVlKSArIGxpbmUuZnJvbTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBzdGF0ZS5kb2Muc2xpY2UocG9zLCB0bykuYXBwZW5kKHN0YXRlLmRvYy5zbGljZShmcm9tLCBwb3MpKSB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IodG8pIH07XG4gICAgfSk7XG4gICAgaWYgKGNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwibW92ZS5jaGFyYWN0ZXJcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSB7XG4gICAgbGV0IGJsb2NrcyA9IFtdLCB1cHRvID0gLTE7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBsZXQgc3RhcnRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKSwgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5ICYmIHJhbmdlLnRvID09IGVuZExpbmUuZnJvbSlcbiAgICAgICAgICAgIGVuZExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvIC0gMSk7XG4gICAgICAgIGlmICh1cHRvID49IHN0YXJ0TGluZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gYmxvY2tzW2Jsb2Nrcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHByZXYudG8gPSBlbmRMaW5lLnRvO1xuICAgICAgICAgICAgcHJldi5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9ja3MucHVzaCh7IGZyb206IHN0YXJ0TGluZS5mcm9tLCB0bzogZW5kTGluZS50bywgcmFuZ2VzOiBbcmFuZ2VdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwdG8gPSBlbmRMaW5lLm51bWJlciArIDE7XG4gICAgfVxuICAgIHJldHVybiBibG9ja3M7XG59XG5mdW5jdGlvbiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZvcndhcmQpIHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdLCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBibG9jayBvZiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpKSB7XG4gICAgICAgIGlmIChmb3J3YXJkID8gYmxvY2sudG8gPT0gc3RhdGUuZG9jLmxlbmd0aCA6IGJsb2NrLmZyb20gPT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbmV4dExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZvcndhcmQgPyBibG9jay50byArIDEgOiBibG9jay5mcm9tIC0gMSk7XG4gICAgICAgIGxldCBzaXplID0gbmV4dExpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCB0bzogbmV4dExpbmUudG8gfSwgeyBmcm9tOiBibG9jay5mcm9tLCBpbnNlcnQ6IG5leHRMaW5lLnRleHQgKyBzdGF0ZS5saW5lQnJlYWsgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCByIG9mIGJsb2NrLnJhbmdlcylcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgci5hbmNob3IgKyBzaXplKSwgTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgci5oZWFkICsgc2l6ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG5leHRMaW5lLmZyb20sIHRvOiBibG9jay5mcm9tIH0sIHsgZnJvbTogYmxvY2sudG8sIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgbmV4dExpbmUudGV4dCB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmFuY2hvciAtIHNpemUsIHIuaGVhZCAtIHNpemUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHN0YXRlLnNlbGVjdGlvbi5tYWluSW5kZXgpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwibW92ZS5saW5lXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIHVwIG9uZSBsaW5lLlxuKi9cbmNvbnN0IG1vdmVMaW5lVXAgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGVkIGxpbmVzIGRvd24gb25lIGxpbmUuXG4qL1xuY29uc3QgbW92ZUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZvcndhcmQpIHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBibG9jay5mcm9tLCBpbnNlcnQ6IHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgKyBzdGF0ZS5saW5lQnJlYWsgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIHN0YXRlLmRvYy5zbGljZShibG9jay5mcm9tLCBibG9jay50bykgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IGNoYW5nZXMsIHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXQuY29weWxpbmVcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkNyZWF0ZSBhIGNvcHkgb2YgdGhlIHNlbGVjdGVkIGxpbmVzLiBLZWVwIHRoZSBzZWxlY3Rpb24gaW4gdGhlIHRvcCBjb3B5LlxuKi9cbmNvbnN0IGNvcHlMaW5lVXAgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gY29weUxpbmUoc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4vKipcbkNyZWF0ZSBhIGNvcHkgb2YgdGhlIHNlbGVjdGVkIGxpbmVzLiBLZWVwIHRoZSBzZWxlY3Rpb24gaW4gdGhlIGJvdHRvbSBjb3B5LlxuKi9cbmNvbnN0IGNvcHlMaW5lRG93biA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIHRydWUpO1xuLyoqXG5EZWxldGUgc2VsZWN0ZWQgbGluZXMuXG4qL1xuY29uc3QgZGVsZXRlTGluZSA9IHZpZXcgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VzKHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkubWFwKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBlbHNlIGlmICh0byA8IHN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICByZXR1cm4geyBmcm9tLCB0byB9O1xuICAgIH0pKTtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgdHJ1ZSkpLm1hcChjaGFuZ2VzKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlcywgc2VsZWN0aW9uLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZS5saW5lXCIgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24oc3RhdGUubGluZUJyZWFrKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGlzQmV0d2VlbkJyYWNrZXRzKHN0YXRlLCBwb3MpIHtcbiAgICBpZiAoL1xcKFxcKXxcXFtcXF18XFx7XFx9Ly50ZXN0KHN0YXRlLnNsaWNlRG9jKHBvcyAtIDEsIHBvcyArIDEpKSlcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogcG9zLCB0bzogcG9zIH07XG4gICAgbGV0IGNvbnRleHQgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIocG9zKTtcbiAgICBsZXQgYmVmb3JlID0gY29udGV4dC5jaGlsZEJlZm9yZShwb3MpLCBhZnRlciA9IGNvbnRleHQuY2hpbGRBZnRlcihwb3MpLCBjbG9zZWRCeTtcbiAgICBpZiAoYmVmb3JlICYmIGFmdGVyICYmIGJlZm9yZS50byA8PSBwb3MgJiYgYWZ0ZXIuZnJvbSA+PSBwb3MgJiZcbiAgICAgICAgKGNsb3NlZEJ5ID0gYmVmb3JlLnR5cGUucHJvcChOb2RlUHJvcC5jbG9zZWRCeSkpICYmIGNsb3NlZEJ5LmluZGV4T2YoYWZ0ZXIubmFtZSkgPiAtMSAmJlxuICAgICAgICBzdGF0ZS5kb2MubGluZUF0KGJlZm9yZS50bykuZnJvbSA9PSBzdGF0ZS5kb2MubGluZUF0KGFmdGVyLmZyb20pLmZyb20gJiZcbiAgICAgICAgIS9cXFMvLnRlc3Qoc3RhdGUuc2xpY2VEb2MoYmVmb3JlLnRvLCBhZnRlci5mcm9tKSkpXG4gICAgICAgIHJldHVybiB7IGZyb206IGJlZm9yZS50bywgdG86IGFmdGVyLmZyb20gfTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGFuZCBpbmRlbnQgdGhlIG5ld2x5IGNyZWF0ZWRcbmxpbmUocykuIElmIHRoZSBjdXJyZW50IGxpbmUgY29uc2lzdHMgb25seSBvZiB3aGl0ZXNwYWNlLCB0aGlzXG53aWxsIGFsc28gZGVsZXRlIHRoYXQgd2hpdGVzcGFjZS4gV2hlbiB0aGUgY3Vyc29yIGlzIGJldHdlZW5cbm1hdGNoaW5nIGJyYWNrZXRzLCBhbiBhZGRpdGlvbmFsIG5ld2xpbmUgd2lsbCBiZSBpbnNlcnRlZCBhZnRlclxudGhlIGN1cnNvci5cbiovXG5jb25zdCBpbnNlcnROZXdsaW5lQW5kSW5kZW50ID0gLypAX19QVVJFX18qL25ld2xpbmVBbmRJbmRlbnQoZmFsc2UpO1xuLyoqXG5DcmVhdGUgYSBibGFuaywgaW5kZW50ZWQgbGluZSBiZWxvdyB0aGUgY3VycmVudCBsaW5lLlxuKi9cbmNvbnN0IGluc2VydEJsYW5rTGluZSA9IC8qQF9fUFVSRV9fKi9uZXdsaW5lQW5kSW5kZW50KHRydWUpO1xuZnVuY3Rpb24gbmV3bGluZUFuZEluZGVudChhdEVvZikge1xuICAgIHJldHVybiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2UsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pO1xuICAgICAgICAgICAgbGV0IGV4cGxvZGUgPSAhYXRFb2YgJiYgZnJvbSA9PSB0byAmJiBpc0JldHdlZW5CcmFja2V0cyhzdGF0ZSwgZnJvbSk7XG4gICAgICAgICAgICBpZiAoYXRFb2YpXG4gICAgICAgICAgICAgICAgZnJvbSA9IHRvID0gKHRvIDw9IGxpbmUudG8gPyBsaW5lIDogc3RhdGUuZG9jLmxpbmVBdCh0bykpLnRvO1xuICAgICAgICAgICAgbGV0IGN4ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgc2ltdWxhdGVCcmVhazogZnJvbSwgc2ltdWxhdGVEb3VibGVCcmVhazogISFleHBsb2RlIH0pO1xuICAgICAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKGN4LCBmcm9tKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSBjb3VudENvbHVtbigvXlxccyovLmV4ZWMoc3RhdGUuZG9jLmxpbmVBdChmcm9tKS50ZXh0KVswXSwgc3RhdGUudGFiU2l6ZSk7XG4gICAgICAgICAgICB3aGlsZSAodG8gPCBsaW5lLnRvICYmIC9cXHMvLnRlc3QobGluZS50ZXh0W3RvIC0gbGluZS5mcm9tXSkpXG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgIGlmIChleHBsb2RlKVxuICAgICAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSBleHBsb2RlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb20gPiBsaW5lLmZyb20gJiYgZnJvbSA8IGxpbmUuZnJvbSArIDEwMCAmJiAhL1xcUy8udGVzdChsaW5lLnRleHQuc2xpY2UoMCwgZnJvbSkpKVxuICAgICAgICAgICAgICAgIGZyb20gPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gW1wiXCIsIGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KV07XG4gICAgICAgICAgICBpZiAoZXhwbG9kZSlcbiAgICAgICAgICAgICAgICBpbnNlcnQucHVzaChpbmRlbnRTdHJpbmcoc3RhdGUsIGN4LmxpbmVJbmRlbnQobGluZS5mcm9tLCAtMSkpKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbSwgdG8sIGluc2VydDogVGV4dC5vZihpbnNlcnQpIH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZnJvbSArIDEgKyBpbnNlcnRbMV0ubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCBmKSB7XG4gICAgbGV0IGF0TGluZSA9IC0xO1xuICAgIHJldHVybiBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZnJvbTsgcG9zIDw9IHJhbmdlLnRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPiBhdExpbmUgJiYgKHJhbmdlLmVtcHR5IHx8IHJhbmdlLnRvID4gbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgICAgIGYobGluZSwgY2hhbmdlcywgcmFuZ2UpO1xuICAgICAgICAgICAgICAgIGF0TGluZSA9IGxpbmUubnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoYW5nZVNldCA9IHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXMsXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGNoYW5nZVNldC5tYXBQb3MocmFuZ2UuYW5jaG9yLCAxKSwgY2hhbmdlU2V0Lm1hcFBvcyhyYW5nZS5oZWFkLCAxKSkgfTtcbiAgICB9KTtcbn1cbi8qKlxuQXV0by1pbmRlbnQgdGhlIHNlbGVjdGVkIGxpbmVzLiBUaGlzIHVzZXMgdGhlIFtpbmRlbnRhdGlvbiBzZXJ2aWNlXG5mYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTZXJ2aWNlKSBhcyBzb3VyY2UgZm9yIGF1dG8taW5kZW50XG5pbmZvcm1hdGlvbi5cbiovXG5jb25zdCBpbmRlbnRTZWxlY3Rpb24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB1cGRhdGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IG92ZXJyaWRlSW5kZW50YXRpb246IHN0YXJ0ID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IHVwZGF0ZWRbc3RhcnRdO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID09IG51bGwgPyAtMSA6IGZvdW5kO1xuICAgICAgICB9IH0pO1xuICAgIGxldCBjaGFuZ2VzID0gY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzLCByYW5nZSkgPT4ge1xuICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QobGluZS50ZXh0KSlcbiAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgIGxldCBjdXIgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgIGlmIChjdXIgIT0gbm9ybSB8fCByYW5nZS5mcm9tIDwgbGluZS5mcm9tICsgY3VyLmxlbmd0aCkge1xuICAgICAgICAgICAgdXBkYXRlZFtsaW5lLmZyb21dID0gaW5kZW50O1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHVzZXJFdmVudDogXCJpbmRlbnRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BZGQgYSBbdW5pdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBvZiBpbmRlbnRhdGlvbiB0byBhbGwgc2VsZWN0ZWRcbmxpbmVzLlxuKi9cbmNvbnN0IGluZGVudE1vcmUgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMpID0+IHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCBpbnNlcnQ6IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpIH0pO1xuICAgIH0pLCB7IHVzZXJFdmVudDogXCJpbnB1dC5pbmRlbnRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZW1vdmUgYSBbdW5pdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRVbml0KSBvZiBpbmRlbnRhdGlvbiBmcm9tIGFsbFxuc2VsZWN0ZWQgbGluZXMuXG4qL1xuY29uc3QgaW5kZW50TGVzcyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcykgPT4ge1xuICAgICAgICBsZXQgc3BhY2UgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgaWYgKCFzcGFjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNvbCA9IGNvdW50Q29sdW1uKHNwYWNlLCBzdGF0ZS50YWJTaXplKSwga2VlcCA9IDA7XG4gICAgICAgIGxldCBpbnNlcnQgPSBpbmRlbnRTdHJpbmcoc3RhdGUsIE1hdGgubWF4KDAsIGNvbCAtIGdldEluZGVudFVuaXQoc3RhdGUpKSk7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgc3BhY2UubGVuZ3RoICYmIGtlZXAgPCBpbnNlcnQubGVuZ3RoICYmIHNwYWNlLmNoYXJDb2RlQXQoa2VlcCkgPT0gaW5zZXJ0LmNoYXJDb2RlQXQoa2VlcCkpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSArIGtlZXAsIHRvOiBsaW5lLmZyb20gKyBzcGFjZS5sZW5ndGgsIGluc2VydDogaW5zZXJ0LnNsaWNlKGtlZXApIH0pO1xuICAgIH0pLCB7IHVzZXJFdmVudDogXCJkZWxldGUuZGVkZW50XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSW5zZXJ0IGEgdGFiIGNoYXJhY3RlciBhdCB0aGUgY3Vyc29yIG9yLCBpZiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQsXG51c2UgW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKSB0byBpbmRlbnQgdGhlIGVudGlyZVxuc2VsZWN0aW9uLlxuKi9cbmNvbnN0IGluc2VydFRhYiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+ICFyLmVtcHR5KSlcbiAgICAgICAgcmV0dXJuIGluZGVudE1vcmUoeyBzdGF0ZSwgZGlzcGF0Y2ggfSk7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIiksIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkFycmF5IG9mIGtleSBiaW5kaW5ncyBjb250YWluaW5nIHRoZSBFbWFjcy1zdHlsZSBiaW5kaW5ncyB0aGF0IGFyZVxuYXZhaWxhYmxlIG9uIG1hY09TIGJ5IGRlZmF1bHQuXG5cbiAtIEN0cmwtYjogW2BjdXJzb3JDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhckxlZnQpIChbYHNlbGVjdENoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyTGVmdCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZjogW2BjdXJzb3JDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJSaWdodCkgKFtgc2VsZWN0Q2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLXA6IFtgY3Vyc29yTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lVXApIChbYHNlbGVjdExpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVVwKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1uOiBbYGN1cnNvckxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRG93bikgKFtgc2VsZWN0TGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVEb3duKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1hOiBbYGN1cnNvckxpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVN0YXJ0KSAoW2BzZWxlY3RMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVTdGFydCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtZTogW2BjdXJzb3JMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRW5kKSAoW2BzZWxlY3RMaW5lRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1kOiBbYGRlbGV0ZUNoYXJGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyRm9yd2FyZClcbiAtIEN0cmwtaDogW2BkZWxldGVDaGFyQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJCYWNrd2FyZClcbiAtIEN0cmwtazogW2BkZWxldGVUb0xpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZVRvTGluZUVuZClcbiAtIEN0cmwtQWx0LWg6IFtgZGVsZXRlR3JvdXBCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlR3JvdXBCYWNrd2FyZClcbiAtIEN0cmwtbzogW2BzcGxpdExpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0TGluZSlcbiAtIEN0cmwtdDogW2B0cmFuc3Bvc2VDaGFyc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudHJhbnNwb3NlQ2hhcnMpXG4gLSBDdHJsLXY6IFtgY3Vyc29yUGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VEb3duKVxuIC0gQWx0LXY6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApXG4qL1xuY29uc3QgZW1hY3NTdHlsZUtleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLWJcIiwgcnVuOiBjdXJzb3JDaGFyTGVmdCwgc2hpZnQ6IHNlbGVjdENoYXJMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtZlwiLCBydW46IGN1cnNvckNoYXJSaWdodCwgc2hpZnQ6IHNlbGVjdENoYXJSaWdodCB9LFxuICAgIHsga2V5OiBcIkN0cmwtcFwiLCBydW46IGN1cnNvckxpbmVVcCwgc2hpZnQ6IHNlbGVjdExpbmVVcCB9LFxuICAgIHsga2V5OiBcIkN0cmwtblwiLCBydW46IGN1cnNvckxpbmVEb3duLCBzaGlmdDogc2VsZWN0TGluZURvd24gfSxcbiAgICB7IGtleTogXCJDdHJsLWFcIiwgcnVuOiBjdXJzb3JMaW5lU3RhcnQsIHNoaWZ0OiBzZWxlY3RMaW5lU3RhcnQgfSxcbiAgICB7IGtleTogXCJDdHJsLWVcIiwgcnVuOiBjdXJzb3JMaW5lRW5kLCBzaGlmdDogc2VsZWN0TGluZUVuZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtZFwiLCBydW46IGRlbGV0ZUNoYXJGb3J3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1oXCIsIHJ1bjogZGVsZXRlQ2hhckJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1rXCIsIHJ1bjogZGVsZXRlVG9MaW5lRW5kIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtaFwiLCBydW46IGRlbGV0ZUdyb3VwQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLW9cIiwgcnVuOiBzcGxpdExpbmUgfSxcbiAgICB7IGtleTogXCJDdHJsLXRcIiwgcnVuOiB0cmFuc3Bvc2VDaGFycyB9LFxuICAgIHsga2V5OiBcIkN0cmwtdlwiLCBydW46IGN1cnNvclBhZ2VEb3duIH0sXG5dO1xuLyoqXG5BbiBhcnJheSBvZiBrZXkgYmluZGluZ3MgY2xvc2VseSBzdGlja2luZyB0byBwbGF0Zm9ybS1zdGFuZGFyZCBvclxud2lkZWx5IHVzZWQgYmluZGluZ3MuIChUaGlzIGluY2x1ZGVzIHRoZSBiaW5kaW5ncyBmcm9tXG5bYGVtYWNzU3R5bGVLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmVtYWNzU3R5bGVLZXltYXApLCB3aXRoIHRoZWlyIGBrZXlgXG5wcm9wZXJ0eSBjaGFuZ2VkIHRvIGBtYWNgLilcblxuIC0gQXJyb3dMZWZ0OiBbYGN1cnNvckNoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyTGVmdCkgKFtgc2VsZWN0Q2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dSaWdodDogW2BjdXJzb3JDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJSaWdodCkgKFtgc2VsZWN0Q2hhclJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RDaGFyUmlnaHQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93TGVmdCAoQWx0LUFycm93TGVmdCBvbiBtYWNPUyk6IFtgY3Vyc29yR3JvdXBMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cExlZnQpIChbYHNlbGVjdEdyb3VwTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0R3JvdXBMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd1JpZ2h0IChBbHQtQXJyb3dSaWdodCBvbiBtYWNPUyk6IFtgY3Vyc29yR3JvdXBSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBSaWdodCkgKFtgc2VsZWN0R3JvdXBSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0R3JvdXBSaWdodCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd0xlZnQgKG9uIG1hY09TKTogW2BjdXJzb3JMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVTdGFydCkgKFtgc2VsZWN0TGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dSaWdodCAob24gbWFjT1MpOiBbYGN1cnNvckxpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVFbmQpIChbYHNlbGVjdExpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVFbmQpIHdpdGggU2hpZnQpXG4gLSBBcnJvd1VwOiBbYGN1cnNvckxpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVVwKSAoW2BzZWxlY3RMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVVcCkgd2l0aCBTaGlmdClcbiAtIEFycm93RG93bjogW2BjdXJzb3JMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZURvd24pIChbYHNlbGVjdExpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lRG93bikgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd1VwIChvbiBtYWNPUyk6IFtgY3Vyc29yRG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY1N0YXJ0KSAoW2BzZWxlY3REb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDbWQtQXJyb3dEb3duIChvbiBtYWNPUyk6IFtgY3Vyc29yRG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NFbmQpIChbYHNlbGVjdERvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jRW5kKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd1VwIChvbiBtYWNPUyk6IFtgY3Vyc29yUGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlVXApIChbYHNlbGVjdFBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFnZVVwKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1BcnJvd0Rvd24gKG9uIG1hY09TKTogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pIChbYHNlbGVjdFBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlRG93bikgd2l0aCBTaGlmdClcbiAtIFBhZ2VVcDogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcCkgKFtgc2VsZWN0UGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlVXApIHdpdGggU2hpZnQpXG4gLSBQYWdlRG93bjogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pIChbYHNlbGVjdFBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlRG93bikgd2l0aCBTaGlmdClcbiAtIEhvbWU6IFtgY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVCb3VuZGFyeUJhY2t3YXJkKSAoW2BzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQpIHdpdGggU2hpZnQpXG4gLSBFbmQ6IFtgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCkgKFtgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtSG9tZSAoQ21kLUhvbWUgb24gbWFjT1MpOiBbYGN1cnNvckRvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JEb2NTdGFydCkgKFtgc2VsZWN0RG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY1N0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1FbmQgKENtZC1Ib21lIG9uIG1hY09TKTogW2BjdXJzb3JEb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY0VuZCkgKFtgc2VsZWN0RG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NFbmQpIHdpdGggU2hpZnQpXG4gLSBFbnRlcjogW2BpbnNlcnROZXdsaW5lQW5kSW5kZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnROZXdsaW5lQW5kSW5kZW50KVxuIC0gQ3RybC1hIChDbWQtYSBvbiBtYWNPUyk6IFtgc2VsZWN0QWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RBbGwpXG4gLSBCYWNrc3BhY2U6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBEZWxldGU6IFtgZGVsZXRlQ2hhckZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJGb3J3YXJkKVxuIC0gQ3RybC1CYWNrc3BhY2UgKEFsdC1CYWNrc3BhY2Ugb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLURlbGV0ZSAoQWx0LURlbGV0ZSBvbiBtYWNPUyk6IFtgZGVsZXRlR3JvdXBGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEZvcndhcmQpXG4gLSBDbWQtQmFja3NwYWNlIChtYWNPUyk6IFtgZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkKS5cbiAtIENtZC1EZWxldGUgKG1hY09TKTogW2BkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkKS5cbiovXG5jb25zdCBzdGFuZGFyZEtleW1hcCA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBrZXk6IFwiQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dMZWZ0XCIsIG1hYzogXCJBbHQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yR3JvdXBMZWZ0LCBzaGlmdDogc2VsZWN0R3JvdXBMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0LCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJBbHQtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckdyb3VwUmlnaHQsIHNoaWZ0OiBzZWxlY3RHcm91cFJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBcnJvd1VwXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yRG9jU3RhcnQsIHNoaWZ0OiBzZWxlY3REb2NTdGFydCB9LFxuICAgIHsgbWFjOiBcIkN0cmwtQXJyb3dVcFwiLCBydW46IGN1cnNvclBhZ2VVcCwgc2hpZnQ6IHNlbGVjdFBhZ2VVcCB9LFxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IGN1cnNvckxpbmVEb3duLCBzaGlmdDogc2VsZWN0TGluZURvd24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93RG93blwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsgbWFjOiBcIkN0cmwtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yUGFnZURvd24sIHNoaWZ0OiBzZWxlY3RQYWdlRG93biB9LFxuICAgIHsga2V5OiBcIlBhZ2VVcFwiLCBydW46IGN1cnNvclBhZ2VVcCwgc2hpZnQ6IHNlbGVjdFBhZ2VVcCB9LFxuICAgIHsga2V5OiBcIlBhZ2VEb3duXCIsIHJ1bjogY3Vyc29yUGFnZURvd24sIHNoaWZ0OiBzZWxlY3RQYWdlRG93biB9LFxuICAgIHsga2V5OiBcIkhvbWVcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1Ib21lXCIsIHJ1bjogY3Vyc29yRG9jU3RhcnQsIHNoaWZ0OiBzZWxlY3REb2NTdGFydCB9LFxuICAgIHsga2V5OiBcIkVuZFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1FbmRcIiwgcnVuOiBjdXJzb3JEb2NFbmQsIHNoaWZ0OiBzZWxlY3REb2NFbmQgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgfSxcbiAgICB7IGtleTogXCJNb2QtYVwiLCBydW46IHNlbGVjdEFsbCB9LFxuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUNoYXJCYWNrd2FyZCwgc2hpZnQ6IGRlbGV0ZUNoYXJCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBydW46IGRlbGV0ZUNoYXJGb3J3YXJkIH0sXG4gICAgeyBrZXk6IFwiTW9kLUJhY2tzcGFjZVwiLCBtYWM6IFwiQWx0LUJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUdyb3VwQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJNb2QtRGVsZXRlXCIsIG1hYzogXCJBbHQtRGVsZXRlXCIsIHJ1bjogZGVsZXRlR3JvdXBGb3J3YXJkIH0sXG4gICAgeyBtYWM6IFwiTW9kLUJhY2tzcGFjZVwiLCBydW46IGRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkIH0sXG4gICAgeyBtYWM6IFwiTW9kLURlbGV0ZVwiLCBydW46IGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQgfVxuXS5jb25jYXQoLypAX19QVVJFX18qL2VtYWNzU3R5bGVLZXltYXAubWFwKGIgPT4gKHsgbWFjOiBiLmtleSwgcnVuOiBiLnJ1biwgc2hpZnQ6IGIuc2hpZnQgfSkpKTtcbi8qKlxuVGhlIGRlZmF1bHQga2V5bWFwLiBJbmNsdWRlcyBhbGwgYmluZGluZ3MgZnJvbVxuW2BzdGFuZGFyZEtleW1hcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc3RhbmRhcmRLZXltYXApIHBsdXMgdGhlIGZvbGxvd2luZzpcblxuLSBBbHQtQXJyb3dMZWZ0IChDdHJsLUFycm93TGVmdCBvbiBtYWNPUyk6IFtgY3Vyc29yU3ludGF4TGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yU3ludGF4TGVmdCkgKFtgc2VsZWN0U3ludGF4TGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0U3ludGF4TGVmdCkgd2l0aCBTaGlmdClcbi0gQWx0LUFycm93UmlnaHQgKEN0cmwtQXJyb3dSaWdodCBvbiBtYWNPUyk6IFtgY3Vyc29yU3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheFJpZ2h0KSAoW2BzZWxlY3RTeW50YXhSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0U3ludGF4UmlnaHQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1VwOiBbYG1vdmVMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLm1vdmVMaW5lVXApXG4tIEFsdC1BcnJvd0Rvd246IFtgbW92ZUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZURvd24pXG4tIFNoaWZ0LUFsdC1BcnJvd1VwOiBbYGNvcHlMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmNvcHlMaW5lVXApXG4tIFNoaWZ0LUFsdC1BcnJvd0Rvd246IFtgY29weUxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZURvd24pXG4tIEVzY2FwZTogW2BzaW1wbGlmeVNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2ltcGxpZnlTZWxlY3Rpb24pXG4tIEN0cmwtRW50ZXIgKENtZC1FbnRlciBvbiBtYWNPUyk6IFtgaW5zZXJ0QmxhbmtMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnRCbGFua0xpbmUpXG4tIEFsdC1sIChDdHJsLWwgb24gbWFjT1MpOiBbYHNlbGVjdExpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmUpXG4tIEN0cmwtaSAoQ21kLWkgb24gbWFjT1MpOiBbYHNlbGVjdFBhcmVudFN5bnRheGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0UGFyZW50U3ludGF4KVxuLSBDdHJsLVsgKENtZC1bIG9uIG1hY09TKTogW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKVxuLSBDdHJsLV0gKENtZC1dIG9uIG1hY09TKTogW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKVxuLSBDdHJsLUFsdC1cXFxcIChDbWQtQWx0LVxcXFwgb24gbWFjT1MpOiBbYGluZGVudFNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50U2VsZWN0aW9uKVxuLSBTaGlmdC1DdHJsLWsgKFNoaWZ0LUNtZC1rIG9uIG1hY09TKTogW2BkZWxldGVMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lKVxuLSBTaGlmdC1DdHJsLVxcXFwgKFNoaWZ0LUNtZC1cXFxcIG9uIG1hY09TKTogW2BjdXJzb3JNYXRjaGluZ0JyYWNrZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvck1hdGNoaW5nQnJhY2tldClcbi0gQ3RybC0vIChDbWQtLyBvbiBtYWNPUyk6IFtgdG9nZ2xlQ29tbWVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlQ29tbWVudCkuXG4tIFNoaWZ0LUFsdC1hOiBbYHRvZ2dsZUJsb2NrQ29tbWVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlQmxvY2tDb21tZW50KS5cbiovXG5jb25zdCBkZWZhdWx0S2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBbHQtQXJyb3dMZWZ0XCIsIG1hYzogXCJDdHJsLUFycm93TGVmdFwiLCBydW46IGN1cnNvclN5bnRheExlZnQsIHNoaWZ0OiBzZWxlY3RTeW50YXhMZWZ0IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93UmlnaHRcIiwgbWFjOiBcIkN0cmwtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvclN5bnRheFJpZ2h0LCBzaGlmdDogc2VsZWN0U3ludGF4UmlnaHQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dVcFwiLCBydW46IG1vdmVMaW5lVXAgfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dVcFwiLCBydW46IGNvcHlMaW5lVXAgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dEb3duXCIsIHJ1bjogbW92ZUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtQWx0LUFycm93RG93blwiLCBydW46IGNvcHlMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IHNpbXBsaWZ5U2VsZWN0aW9uIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVudGVyXCIsIHJ1bjogaW5zZXJ0QmxhbmtMaW5lIH0sXG4gICAgeyBrZXk6IFwiQWx0LWxcIiwgbWFjOiBcIkN0cmwtbFwiLCBydW46IHNlbGVjdExpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtaVwiLCBydW46IHNlbGVjdFBhcmVudFN5bnRheCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtW1wiLCBydW46IGluZGVudExlc3MgfSxcbiAgICB7IGtleTogXCJNb2QtXVwiLCBydW46IGluZGVudE1vcmUgfSxcbiAgICB7IGtleTogXCJNb2QtQWx0LVxcXFxcIiwgcnVuOiBpbmRlbnRTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1Nb2Qta1wiLCBydW46IGRlbGV0ZUxpbmUgfSxcbiAgICB7IGtleTogXCJTaGlmdC1Nb2QtXFxcXFwiLCBydW46IGN1cnNvck1hdGNoaW5nQnJhY2tldCB9LFxuICAgIHsga2V5OiBcIk1vZC0vXCIsIHJ1bjogdG9nZ2xlQ29tbWVudCB9LFxuICAgIHsga2V5OiBcIkFsdC1BXCIsIHJ1bjogdG9nZ2xlQmxvY2tDb21tZW50IH1cbl0uY29uY2F0KHN0YW5kYXJkS2V5bWFwKTtcbi8qKlxuQSBiaW5kaW5nIHRoYXQgYmluZHMgVGFiIHRvIFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSkgYW5kXG5TaGlmdC1UYWIgdG8gW2BpbmRlbnRMZXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRMZXNzKS5cblBsZWFzZSBzZWUgdGhlIFtUYWIgZXhhbXBsZV0oLi4vLi4vZXhhbXBsZXMvdGFiLykgYmVmb3JlIHVzaW5nXG50aGlzLlxuKi9cbmNvbnN0IGluZGVudFdpdGhUYWIgPSB7IGtleTogXCJUYWJcIiwgcnVuOiBpbmRlbnRNb3JlLCBzaGlmdDogaW5kZW50TGVzcyB9O1xuXG5leHBvcnQgeyBibG9ja0NvbW1lbnQsIGJsb2NrVW5jb21tZW50LCBjb3B5TGluZURvd24sIGNvcHlMaW5lVXAsIGN1cnNvckNoYXJCYWNrd2FyZCwgY3Vyc29yQ2hhckZvcndhcmQsIGN1cnNvckNoYXJMZWZ0LCBjdXJzb3JDaGFyUmlnaHQsIGN1cnNvckRvY0VuZCwgY3Vyc29yRG9jU3RhcnQsIGN1cnNvckdyb3VwQmFja3dhcmQsIGN1cnNvckdyb3VwRm9yd2FyZCwgY3Vyc29yR3JvdXBMZWZ0LCBjdXJzb3JHcm91cFJpZ2h0LCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIGN1cnNvckxpbmVEb3duLCBjdXJzb3JMaW5lRW5kLCBjdXJzb3JMaW5lU3RhcnQsIGN1cnNvckxpbmVVcCwgY3Vyc29yTWF0Y2hpbmdCcmFja2V0LCBjdXJzb3JQYWdlRG93biwgY3Vyc29yUGFnZVVwLCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQsIGN1cnNvclN1YndvcmRGb3J3YXJkLCBjdXJzb3JTeW50YXhMZWZ0LCBjdXJzb3JTeW50YXhSaWdodCwgZGVmYXVsdEtleW1hcCwgZGVsZXRlQ2hhckJhY2t3YXJkLCBkZWxldGVDaGFyRm9yd2FyZCwgZGVsZXRlR3JvdXBCYWNrd2FyZCwgZGVsZXRlR3JvdXBGb3J3YXJkLCBkZWxldGVMaW5lLCBkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCwgZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCwgZGVsZXRlVG9MaW5lRW5kLCBkZWxldGVUb0xpbmVTdGFydCwgZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlLCBlbWFjc1N0eWxlS2V5bWFwLCBoaXN0b3J5LCBoaXN0b3J5RmllbGQsIGhpc3RvcnlLZXltYXAsIGluZGVudExlc3MsIGluZGVudE1vcmUsIGluZGVudFNlbGVjdGlvbiwgaW5kZW50V2l0aFRhYiwgaW5zZXJ0QmxhbmtMaW5lLCBpbnNlcnROZXdsaW5lLCBpbnNlcnROZXdsaW5lQW5kSW5kZW50LCBpbnNlcnRUYWIsIGludmVydGVkRWZmZWN0cywgaXNvbGF0ZUhpc3RvcnksIGxpbmVDb21tZW50LCBsaW5lVW5jb21tZW50LCBtb3ZlTGluZURvd24sIG1vdmVMaW5lVXAsIHJlZG8sIHJlZG9EZXB0aCwgcmVkb1NlbGVjdGlvbiwgc2VsZWN0QWxsLCBzZWxlY3RDaGFyQmFja3dhcmQsIHNlbGVjdENoYXJGb3J3YXJkLCBzZWxlY3RDaGFyTGVmdCwgc2VsZWN0Q2hhclJpZ2h0LCBzZWxlY3REb2NFbmQsIHNlbGVjdERvY1N0YXJ0LCBzZWxlY3RHcm91cEJhY2t3YXJkLCBzZWxlY3RHcm91cEZvcndhcmQsIHNlbGVjdEdyb3VwTGVmdCwgc2VsZWN0R3JvdXBSaWdodCwgc2VsZWN0TGluZSwgc2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQsIHNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQsIHNlbGVjdExpbmVCb3VuZGFyeUxlZnQsIHNlbGVjdExpbmVCb3VuZGFyeVJpZ2h0LCBzZWxlY3RMaW5lRG93biwgc2VsZWN0TGluZUVuZCwgc2VsZWN0TGluZVN0YXJ0LCBzZWxlY3RMaW5lVXAsIHNlbGVjdE1hdGNoaW5nQnJhY2tldCwgc2VsZWN0UGFnZURvd24sIHNlbGVjdFBhZ2VVcCwgc2VsZWN0UGFyZW50U3ludGF4LCBzZWxlY3RTdWJ3b3JkQmFja3dhcmQsIHNlbGVjdFN1YndvcmRGb3J3YXJkLCBzZWxlY3RTeW50YXhMZWZ0LCBzZWxlY3RTeW50YXhSaWdodCwgc2ltcGxpZnlTZWxlY3Rpb24sIHNwbGl0TGluZSwgc3RhbmRhcmRLZXltYXAsIHRvZ2dsZUJsb2NrQ29tbWVudCwgdG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lLCB0b2dnbGVDb21tZW50LCB0b2dnbGVMaW5lQ29tbWVudCwgdHJhbnNwb3NlQ2hhcnMsIHVuZG8sIHVuZG9EZXB0aCwgdW5kb1NlbGVjdGlvbiB9O1xuIl0sIm5hbWVzIjpbIkFubm90YXRpb24iLCJGYWNldCIsImNvbWJpbmVDb25maWciLCJTdGF0ZUZpZWxkIiwiVHJhbnNhY3Rpb24iLCJDaGFuZ2VTZXQiLCJDaGFuZ2VEZXNjIiwiRWRpdG9yU2VsZWN0aW9uIiwiU3RhdGVFZmZlY3QiLCJUZXh0IiwiZmluZENsdXN0ZXJCcmVhayIsImNvdW50Q29sdW1uIiwiQ2hhckNhdGVnb3J5IiwiRWRpdG9yVmlldyIsIkRpcmVjdGlvbiIsIkluZGVudENvbnRleHQiLCJnZXRJbmRlbnRhdGlvbiIsImluZGVudFN0cmluZyIsIm1hdGNoQnJhY2tldHMiLCJzeW50YXhUcmVlIiwiZ2V0SW5kZW50VW5pdCIsImluZGVudFVuaXQiLCJOb2RlUHJvcCIsInRvZ2dsZUNvbW1lbnQiLCJ0YXJnZXQiLCJzdGF0ZSIsImxpbmUiLCJkb2MiLCJsaW5lQXQiLCJzZWxlY3Rpb24iLCJtYWluIiwiZnJvbSIsImNvbmZpZyIsImdldENvbmZpZyIsInRvZ2dsZUxpbmVDb21tZW50IiwiYmxvY2siLCJ0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUiLCJjb21tYW5kIiwiZiIsIm9wdGlvbiIsImRpc3BhdGNoIiwicmVhZE9ubHkiLCJ0ciIsInVwZGF0ZSIsImNoYW5nZUxpbmVDb21tZW50IiwibGluZUNvbW1lbnQiLCJsaW5lVW5jb21tZW50IiwidG9nZ2xlQmxvY2tDb21tZW50IiwiY2hhbmdlQmxvY2tDb21tZW50IiwiYmxvY2tDb21tZW50IiwiYmxvY2tVbmNvbW1lbnQiLCJvIiwicyIsInNlbGVjdGVkTGluZVJhbmdlcyIsInBvcyIsImRhdGEiLCJsYW5ndWFnZURhdGFBdCIsImxlbmd0aCIsIlNlYXJjaE1hcmdpbiIsImZpbmRCbG9ja0NvbW1lbnQiLCJvcGVuIiwiY2xvc2UiLCJ0byIsInRleHRCZWZvcmUiLCJzbGljZURvYyIsInRleHRBZnRlciIsInNwYWNlQmVmb3JlIiwiZXhlYyIsInNwYWNlQWZ0ZXIiLCJiZWZvcmVPZmYiLCJzbGljZSIsIm1hcmdpbiIsInN0YXJ0VGV4dCIsImVuZFRleHQiLCJzdGFydFNwYWNlIiwiZW5kU3BhY2UiLCJlbmRPZmYiLCJ0ZXN0IiwiY2hhckF0IiwicmFuZ2VzIiwiciIsImZyb21MaW5lIiwidG9MaW5lIiwibGFzdCIsInB1c2giLCJ0ZXh0IiwidG9rZW5zIiwibWFwIiwiZXZlcnkiLCJjIiwiY29tbWVudHMiLCJpIiwiY2hhbmdlcyIsInJhbmdlIiwiaW5zZXJ0Iiwic29tZSIsImNvbW1lbnQiLCJ0b2tlbiIsImxpbmVzIiwicHJldkxpbmUiLCJzdGFydEkiLCJtaW5JbmRlbnQiLCJpbmRlbnQiLCJlbXB0eSIsInNpbmdsZSIsImwiLCJjaGFuZ2VTZXQiLCJmcm9tSGlzdG9yeSIsImRlZmluZSIsImlzb2xhdGVIaXN0b3J5IiwiaW52ZXJ0ZWRFZmZlY3RzIiwiaGlzdG9yeUNvbmZpZyIsImNvbWJpbmUiLCJjb25maWdzIiwibWluRGVwdGgiLCJuZXdHcm91cERlbGF5Iiwiam9pblRvRXZlbnQiLCJfdCIsImlzQWRqYWNlbnQiLCJNYXRoIiwibWF4IiwibWluIiwiYSIsImIiLCJhZGoiLCJoaXN0b3J5RmllbGRfIiwiY3JlYXRlIiwiSGlzdG9yeVN0YXRlIiwiZmFjZXQiLCJmcm9tSGlzdCIsImFubm90YXRpb24iLCJpdGVtIiwiSGlzdEV2ZW50IiwiZnJvbVRyYW5zYWN0aW9uIiwic2lkZSIsIm90aGVyIiwidW5kb25lIiwiZG9uZSIsInVwZGF0ZUJyYW5jaCIsImFkZFNlbGVjdGlvbiIsInN0YXJ0U3RhdGUiLCJyZXN0IiwiaXNvbGF0ZSIsImFkZFRvSGlzdG9yeSIsImFkZE1hcHBpbmciLCJkZXNjIiwiZXZlbnQiLCJ0aW1lIiwidXNlckV2ZW50IiwiYWRkQ2hhbmdlcyIsInRvSlNPTiIsInZhbHVlIiwiZSIsImZyb21KU09OIiwianNvbiIsImhpc3RvcnkiLCJvZiIsImRvbUV2ZW50SGFuZGxlcnMiLCJiZWZvcmVpbnB1dCIsInZpZXciLCJpbnB1dFR5cGUiLCJ1bmRvIiwicmVkbyIsInByZXZlbnREZWZhdWx0IiwiaGlzdG9yeUZpZWxkIiwiY21kIiwiaGlzdG9yeVN0YXRlIiwiZmllbGQiLCJwb3AiLCJ1bmRvU2VsZWN0aW9uIiwicmVkb1NlbGVjdGlvbiIsImRlcHRoIiwiaGlzdFN0YXRlIiwiYnJhbmNoIiwidW5kb0RlcHRoIiwicmVkb0RlcHRoIiwiY29uc3RydWN0b3IiLCJlZmZlY3RzIiwibWFwcGVkIiwic3RhcnRTZWxlY3Rpb24iLCJzZWxlY3Rpb25zQWZ0ZXIiLCJzZXRTZWxBZnRlciIsImFmdGVyIiwiX2EiLCJfYiIsIl9jIiwibm9uZSIsImludmVydCIsInJlc3VsdCIsImNvbmNhdCIsInVuZGVmaW5lZCIsInNlbGVjdGlvbnMiLCJtYXhMZW4iLCJuZXdFdmVudCIsInN0YXJ0IiwibmV3QnJhbmNoIiwiaXRlckNoYW5nZWRSYW5nZXMiLCJ0IiwiX2YiLCJlcVNlbGVjdGlvblNoYXBlIiwiZmlsdGVyIiwiY29uYyIsIk1heFNlbGVjdGlvbnNQZXJFdmVudCIsImxhc3RFdmVudCIsInNlbHMiLCJlcSIsInBvcFNlbGVjdGlvbiIsImFkZE1hcHBpbmdUb0JyYW5jaCIsIm1hcHBpbmciLCJtYXBFdmVudCIsImV4dHJhU2VsZWN0aW9ucyIsIm1hcHBlZENoYW5nZXMiLCJiZWZvcmUiLCJtYXBEZXNjIiwiZnVsbE1hcHBpbmciLCJjb21wb3NlRGVzYyIsIm1hcEVmZmVjdHMiLCJqb2luYWJsZVVzZXJFdmVudCIsInByZXZUaW1lIiwicHJldlVzZXJFdmVudCIsImNvbXBvc2UiLCJvbmx5U2VsZWN0aW9uIiwiYW5ub3RhdGlvbnMiLCJzY3JvbGxJbnRvVmlldyIsImhpc3RvcnlLZXltYXAiLCJrZXkiLCJydW4iLCJtYWMiLCJsaW51eCIsInVwZGF0ZVNlbCIsInNlbCIsImJ5IiwibWFpbkluZGV4Iiwic2V0U2VsIiwibW92ZVNlbCIsImhvdyIsInJhbmdlRW5kIiwiZm9yd2FyZCIsImN1cnNvciIsImN1cnNvckJ5Q2hhciIsIm1vdmVCeUNoYXIiLCJsdHJBdEN1cnNvciIsInRleHREaXJlY3Rpb25BdCIsImhlYWQiLCJMVFIiLCJjdXJzb3JDaGFyTGVmdCIsImN1cnNvckNoYXJSaWdodCIsImN1cnNvckNoYXJGb3J3YXJkIiwiY3Vyc29yQ2hhckJhY2t3YXJkIiwiY3Vyc29yQnlHcm91cCIsIm1vdmVCeUdyb3VwIiwiY3Vyc29yR3JvdXBMZWZ0IiwiY3Vyc29yR3JvdXBSaWdodCIsImN1cnNvckdyb3VwRm9yd2FyZCIsImN1cnNvckdyb3VwQmFja3dhcmQiLCJzZWdtZW50ZXIiLCJJbnRsIiwiU2VnbWVudGVyIiwiZ3JhbnVsYXJpdHkiLCJtb3ZlQnlTdWJ3b3JkIiwiY2F0ZWdvcml6ZSIsImNoYXJDYXRlZ29yaXplciIsImNhdCIsIlNwYWNlIiwic3RlcHMiLCJzYXdVcHBlciIsInNhd0xvd2VyIiwic3RlcCIsIm5leHQiLCJuZXh0Q2F0IiwiYWhlYWQiLCJXb3JkIiwiY2hhckNvZGVBdCIsInRvTG93ZXJDYXNlIiwiZW5kIiwic2tpcHBlZCIsInNlZ21lbnRzIiwiQXJyYXkiLCJzZWdtZW50IiwiaW5kZXgiLCJjdXJzb3JCeVN1YndvcmQiLCJjdXJzb3JTdWJ3b3JkRm9yd2FyZCIsImN1cnNvclN1YndvcmRCYWNrd2FyZCIsImludGVyZXN0aW5nTm9kZSIsIm5vZGUiLCJicmFja2V0UHJvcCIsInR5cGUiLCJwcm9wIiwibGVuIiwiZmlyc3RDaGlsZCIsIm1vdmVCeVN5bnRheCIsInJlc29sdmVJbm5lciIsImNsb3NlZEJ5Iiwib3BlbmVkQnkiLCJhdCIsImNoaWxkQWZ0ZXIiLCJjaGlsZEJlZm9yZSIsImJyYWNrZXQiLCJtYXRjaCIsIm5ld1BvcyIsIm1hdGNoZWQiLCJjdXJzb3JTeW50YXhMZWZ0IiwiY3Vyc29yU3ludGF4UmlnaHQiLCJjdXJzb3JCeUxpbmUiLCJtb3ZlZCIsIm1vdmVWZXJ0aWNhbGx5IiwibW92ZVRvTGluZUJvdW5kYXJ5IiwiY3Vyc29yTGluZVVwIiwiY3Vyc29yTGluZURvd24iLCJwYWdlSW5mbyIsInNlbGZTY3JvbGwiLCJzY3JvbGxET00iLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5Cb3R0b20iLCJoZWlnaHQiLCJzb3VyY2UiLCJzY3JvbGxNYXJnaW5zIiwibWFyZ2lucyIsInRvcCIsImJvdHRvbSIsImRvbSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImlubmVySGVpZ2h0IiwiZGVmYXVsdExpbmVIZWlnaHQiLCJjdXJzb3JCeVBhZ2UiLCJwYWdlIiwiZWZmZWN0Iiwic3RhcnRQb3MiLCJjb29yZHNBdFBvcyIsInNjcm9sbFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY3JvbGxUb3AiLCJzY3JvbGxCb3R0b20iLCJ5IiwieU1hcmdpbiIsImN1cnNvclBhZ2VVcCIsImN1cnNvclBhZ2VEb3duIiwibW92ZUJ5TGluZUJvdW5kYXJ5IiwibGluZUJsb2NrQXQiLCJzcGFjZSIsImN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQiLCJjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCIsImN1cnNvckxpbmVCb3VuZGFyeUxlZnQiLCJjdXJzb3JMaW5lQm91bmRhcnlSaWdodCIsImN1cnNvckxpbmVTdGFydCIsImN1cnNvckxpbmVFbmQiLCJ0b01hdGNoaW5nQnJhY2tldCIsImV4dGVuZCIsImZvdW5kIiwibWF0Y2hpbmciLCJhbmNob3IiLCJjdXJzb3JNYXRjaGluZ0JyYWNrZXQiLCJzZWxlY3RNYXRjaGluZ0JyYWNrZXQiLCJleHRlbmRTZWwiLCJnb2FsQ29sdW1uIiwiYmlkaUxldmVsIiwic2VsZWN0QnlDaGFyIiwic2VsZWN0Q2hhckxlZnQiLCJzZWxlY3RDaGFyUmlnaHQiLCJzZWxlY3RDaGFyRm9yd2FyZCIsInNlbGVjdENoYXJCYWNrd2FyZCIsInNlbGVjdEJ5R3JvdXAiLCJzZWxlY3RHcm91cExlZnQiLCJzZWxlY3RHcm91cFJpZ2h0Iiwic2VsZWN0R3JvdXBGb3J3YXJkIiwic2VsZWN0R3JvdXBCYWNrd2FyZCIsInNlbGVjdEJ5U3Vid29yZCIsInNlbGVjdFN1YndvcmRGb3J3YXJkIiwic2VsZWN0U3Vid29yZEJhY2t3YXJkIiwic2VsZWN0U3ludGF4TGVmdCIsInNlbGVjdFN5bnRheFJpZ2h0Iiwic2VsZWN0QnlMaW5lIiwic2VsZWN0TGluZVVwIiwic2VsZWN0TGluZURvd24iLCJzZWxlY3RCeVBhZ2UiLCJzZWxlY3RQYWdlVXAiLCJzZWxlY3RQYWdlRG93biIsInNlbGVjdExpbmVCb3VuZGFyeUZvcndhcmQiLCJzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCIsInNlbGVjdExpbmVCb3VuZGFyeUxlZnQiLCJzZWxlY3RMaW5lQm91bmRhcnlSaWdodCIsInNlbGVjdExpbmVTdGFydCIsInNlbGVjdExpbmVFbmQiLCJjdXJzb3JEb2NTdGFydCIsImN1cnNvckRvY0VuZCIsInNlbGVjdERvY1N0YXJ0Iiwic2VsZWN0RG9jRW5kIiwic2VsZWN0QWxsIiwic2VsZWN0TGluZSIsInNlbGVjdGVkTGluZUJsb2NrcyIsInNlbGVjdFBhcmVudFN5bnRheCIsInN0YWNrIiwicmVzb2x2ZVN0YWNrIiwiY3VyIiwicGFyZW50Iiwic2ltcGxpZnlTZWxlY3Rpb24iLCJkZWxldGVCeSIsImNoYW5nZUJ5UmFuZ2UiLCJ0b3dhcmRzIiwic2tpcEF0b21pYyIsImFubm91bmNlIiwicGhyYXNlIiwiYXRvbWljUmFuZ2VzIiwiYmV0d2VlbiIsImRlbGV0ZUJ5Q2hhciIsInRhcmdldFBvcyIsImNvbCIsInRhYlNpemUiLCJkcm9wIiwibnVtYmVyIiwiZGVsZXRlQ2hhckJhY2t3YXJkIiwiZGVsZXRlQ2hhckZvcndhcmQiLCJkZWxldGVCeUdyb3VwIiwibmV4dENoYXIiLCJkZWxldGVHcm91cEJhY2t3YXJkIiwiZGVsZXRlR3JvdXBGb3J3YXJkIiwiZGVsZXRlVG9MaW5lRW5kIiwibGluZUVuZCIsImRlbGV0ZVRvTGluZVN0YXJ0IiwibGluZVN0YXJ0IiwiZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmQiLCJkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkIiwiZGVsZXRlVHJhaWxpbmdXaGl0ZXNwYWNlIiwicHJldiIsIml0ZXIiLCJsaW5lQnJlYWsiLCJ0cmFpbGluZyIsInNlYXJjaCIsInNwbGl0TGluZSIsInRyYW5zcG9zZUNoYXJzIiwiYXBwZW5kIiwiYmxvY2tzIiwidXB0byIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJtb3ZlTGluZSIsIm5leHRMaW5lIiwic2l6ZSIsIm1vdmVMaW5lVXAiLCJtb3ZlTGluZURvd24iLCJjb3B5TGluZSIsImNvcHlMaW5lVXAiLCJjb3B5TGluZURvd24iLCJkZWxldGVMaW5lIiwiaW5zZXJ0TmV3bGluZSIsInJlcGxhY2VTZWxlY3Rpb24iLCJpc0JldHdlZW5CcmFja2V0cyIsImNvbnRleHQiLCJpbmRleE9mIiwibmFtZSIsImluc2VydE5ld2xpbmVBbmRJbmRlbnQiLCJuZXdsaW5lQW5kSW5kZW50IiwiaW5zZXJ0QmxhbmtMaW5lIiwiYXRFb2YiLCJleHBsb2RlIiwiY3giLCJzaW11bGF0ZUJyZWFrIiwic2ltdWxhdGVEb3VibGVCcmVhayIsImxpbmVJbmRlbnQiLCJjaGFuZ2VCeVNlbGVjdGVkTGluZSIsImF0TGluZSIsIm1hcFBvcyIsImluZGVudFNlbGVjdGlvbiIsInVwZGF0ZWQiLCJPYmplY3QiLCJvdmVycmlkZUluZGVudGF0aW9uIiwibm9ybSIsImluZGVudE1vcmUiLCJpbmRlbnRMZXNzIiwia2VlcCIsImluc2VydFRhYiIsImVtYWNzU3R5bGVLZXltYXAiLCJzaGlmdCIsInN0YW5kYXJkS2V5bWFwIiwiZGVmYXVsdEtleW1hcCIsImluZGVudFdpdGhUYWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/commands/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lang-javascript/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@codemirror/lang-javascript/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoCloseTags: () => (/* binding */ autoCloseTags),\n/* harmony export */   completionPath: () => (/* binding */ completionPath),\n/* harmony export */   esLint: () => (/* binding */ esLint),\n/* harmony export */   javascript: () => (/* binding */ javascript),\n/* harmony export */   javascriptLanguage: () => (/* binding */ javascriptLanguage),\n/* harmony export */   jsxLanguage: () => (/* binding */ jsxLanguage),\n/* harmony export */   localCompletionSource: () => (/* binding */ localCompletionSource),\n/* harmony export */   scopeCompletionSource: () => (/* binding */ scopeCompletionSource),\n/* harmony export */   snippets: () => (/* binding */ snippets),\n/* harmony export */   tsxLanguage: () => (/* binding */ tsxLanguage),\n/* harmony export */   typescriptLanguage: () => (/* binding */ typescriptLanguage),\n/* harmony export */   typescriptSnippets: () => (/* binding */ typescriptSnippets)\n/* harmony export */ });\n/* harmony import */ var _lezer_javascript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/javascript */ \"(ssr)/./node_modules/@lezer/javascript/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/ const snippets = [\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"function ${name}(${params}) {\\n\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"for (let ${name} of ${collection}) {\\n\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"do {\\n\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"while (${}) {\\n\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"try {\\n\t${}\\n} catch (${error}) {\\n\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"if (${}) {\\n\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"if (${}) {\\n\t${}\\n} else {\\n\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"class ${name} {\\n\tconstructor(${params}) {\\n\t\t${}\\n\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)('import {${names}} from \"${module}\"\\n${}', {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)('import ${name} from \"${module}\"\\n${}', {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/ const typescriptSnippets = /*@__PURE__*/ snippets.concat([\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"interface ${name} {\\n\t${}\\n}\", {\n        label: \"interface\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"type ${name} = ${type}\", {\n        label: \"type\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/ (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.snippetCompletion)(\"enum ${name} {\\n\t${}\\n}\", {\n        label: \"enum\",\n        detail: \"definition\",\n        type: \"keyword\"\n    })\n]);\nconst cache = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_1__.NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/ new Set([\n    \"Script\",\n    \"Block\",\n    \"FunctionExpression\",\n    \"FunctionDeclaration\",\n    \"ArrowFunction\",\n    \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def)=>{\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id) def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\n    \"FunctionDeclaration\"\n];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/ defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/ defID(\"class\"),\n    ClassExpression: ()=>true,\n    EnumDeclaration: /*@__PURE__*/ defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/ defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/ defID(\"namespace\"),\n    VariableDefinition (node, def) {\n        if (!node.matchContext(functionContext)) def(node, \"variable\");\n    },\n    TypeDefinition (node, def) {\n        def(node, \"type\");\n    },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached) return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({\n            label: name,\n            type\n        });\n    }\n    node.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_1__.IterMode.IncludeAnonymous).iterate((node)=>{\n        if (top) {\n            top = false;\n        } else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name)) return false;\n        } else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\",\n    \"String\",\n    \"RegExp\",\n    \"LineComment\",\n    \"BlockComment\",\n    \"VariableDefinition\",\n    \"TypeDefinition\",\n    \"Label\",\n    \"PropertyDefinition\",\n    \"PropertyName\",\n    \"PrivatePropertyDefinition\",\n    \"PrivatePropertyName\",\n    \".\",\n    \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/ function localCompletionSource(context) {\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1) return null;\n    let isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit) return null;\n    let options = [];\n    for(let pos = inner; pos; pos = pos.parent){\n        if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for(;;){\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return {\n                path: path.reverse(),\n                name\n            };\n        } else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = prop = obj.lastChild) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        } else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/ function completionPath(context) {\n    let read = (node)=>context.state.doc.sliceString(node.from, node.to);\n    let inner = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    } else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    } else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    } else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return {\n            path: [],\n            name: read(inner)\n        };\n    } else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    } else {\n        return context.explicit ? {\n            path: [],\n            name: \"\"\n        } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for(let depth = 0;; depth++){\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)){\n            if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name)) continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            } catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? /^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\" : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next) return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/ function scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context)=>{\n        let path = completionPath(context);\n        if (!path) return null;\n        let target = scope;\n        for (let step of path.path){\n            target = target[step];\n            if (!target) return null;\n        }\n        let options = cache.get(target);\n        if (!options) cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/ const javascriptLanguage = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/ _lezer_javascript__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n        props: [\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentNodeProp.add({\n                IfStatement: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({\n                    except: /^\\s*({|else\\b)/\n                }),\n                TryStatement: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({\n                    except: /^\\s*({|catch\\b|finally\\b)/\n                }),\n                LabeledStatement: _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.flatIndent,\n                SwitchBody: (context)=>{\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.delimitedIndent)({\n                    closing: \"}\"\n                }),\n                ArrowFunction: (cx)=>cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": ()=>null,\n                \"Statement Property\": /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.continuedIndent)({\n                    except: /^{/\n                }),\n                JSXElement (context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape (context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\" (context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.foldInside,\n                BlockComment (tree) {\n                    return {\n                        from: tree.from + 2,\n                        to: tree.to - 2\n                    };\n                }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: {\n            brackets: [\n                \"(\",\n                \"[\",\n                \"{\",\n                \"'\",\n                '\"',\n                \"`\"\n            ]\n        },\n        commentTokens: {\n            line: \"//\",\n            block: {\n                open: \"/*\",\n                close: \"*/\"\n            }\n        },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: (node)=>/^JSX/.test(node.name),\n    facet: /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.defineLanguageFacet)({\n        commentTokens: {\n            block: {\n                open: \"{/*\",\n                close: \"*/}\"\n            }\n        }\n    })\n};\n/**\nA language provider for TypeScript.\n*/ const typescriptLanguage = /*@__PURE__*/ javascriptLanguage.configure({\n    dialect: \"ts\"\n}, \"typescript\");\n/**\nLanguage provider for JSX.\n*/ const jsxLanguage = /*@__PURE__*/ javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [\n        /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.sublanguageProp.add((n)=>n.isTop ? [\n                jsxSublanguage\n            ] : undefined)\n    ]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/ const tsxLanguage = /*@__PURE__*/ javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [\n        /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.sublanguageProp.add((n)=>n.isTop ? [\n                jsxSublanguage\n            ] : undefined)\n    ]\n}, \"typescript\");\nlet kwCompletion = (name)=>({\n        label: name,\n        type: \"keyword\"\n    });\nconst keywords = /*@__PURE__*/ \"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/ keywords.concat(/*@__PURE__*/ [\n    \"declare\",\n    \"implements\",\n    \"private\",\n    \"protected\",\n    \"public\"\n].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\ncompletion.\n*/ function javascript(config = {}) {\n    let lang = config.jsx ? config.typescript ? tsxLanguage : jsxLanguage : config.typescript ? typescriptLanguage : javascriptLanguage;\n    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.ifNotIn)(dontComplete, (0,_codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_2__.completeFromList)(completions))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : []\n    ]);\n}\nfunction findOpenTag(node) {\n    for(;;){\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\") return node;\n        if (node.name == \"JSXEscape\" || !node.parent) return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for(let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling){\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" || ch.name == \"JSXMemberExpression\") return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/ const autoCloseTags = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.inputHandler.of((view, from, to, text, defaultInsert)=>{\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly || from != to || text != \">\" && text != \"/\" || !javascriptLanguage.isActiveAt(view.state, from, -1)) return false;\n    let base = defaultInsert(), { state } = base;\n    let closeTags = state.changeByRange((range)=>{\n        var _a;\n        let { head } = range, around = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(head - 1, -1), name;\n        if (around.name == \"JSXStartTag\") around = around.parent;\n        if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return {\n                range,\n                changes: {\n                    from: head,\n                    insert: `</>`\n                }\n            };\n        } else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n            let empty = around.parent, base = empty.parent;\n            if (base && empty.from == head - 2 && ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n                let insert = `${name}>`;\n                return {\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_5__.EditorSelection.cursor(head + insert.length, -1),\n                    changes: {\n                        from: head,\n                        insert\n                    }\n                };\n            }\n        } else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) && (name = elementName(state.doc, openTag, head))) return {\n                range,\n                changes: {\n                    from: head,\n                    insert: `</${name}>`\n                }\n            };\n        }\n        return {\n            range\n        };\n    });\n    if (closeTags.changes.empty) return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, {\n            userEvent: \"input.complete\",\n            scrollIntoView: true\n        })\n    ]);\n    return true;\n});\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/ function esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: {\n                ecmaVersion: 2019,\n                sourceType: \"module\"\n            },\n            env: {\n                browser: true,\n                node: true,\n                es6: true,\n                es2015: true,\n                es2017: true,\n                es2020: true\n            },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name)=>{\n            if (desc.meta.docs.recommended) config.rules[name] = 2;\n        });\n    }\n    return (view)=>{\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)){\n            let fromLine = state.doc.lineAt(from), offset = {\n                line: fromLine.number - 1,\n                col: from - fromLine.from,\n                pos: from\n            };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\"\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [\n            {\n                name: \"fix\",\n                apply (view, start) {\n                    view.dispatch({\n                        changes: {\n                            from: start + from,\n                            to: start + to,\n                            insert: text\n                        },\n                        scrollIntoView: true\n                    });\n                }\n            }\n        ];\n    }\n    return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZy1qYXZhc2NyaXB0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJDO0FBQ2tLO0FBQ3pKO0FBQ047QUFDMEM7QUFDbEM7QUFFdEQ7OztBQUdBLEdBQ0EsTUFBTW1CLFdBQVc7SUFDYixXQUFXLEdBQUVMLDJFQUFpQkEsQ0FBQywwQ0FBMkM7UUFDdEVNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyxzRUFBdUU7UUFDbEdNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyxpREFBa0Q7UUFDN0VNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyw2QkFBOEI7UUFDekRNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQywwQkFBMkI7UUFDdERNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyw4Q0FBZ0Q7UUFDM0VNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyx1QkFBd0I7UUFDbkRNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyx1Q0FBeUM7UUFDcEVNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQyw0REFBZ0U7UUFDM0ZNLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxNQUFNO0lBQ1Y7SUFDQSxXQUFXLEdBQUVSLDJFQUFpQkEsQ0FBQywyQ0FBNkM7UUFDeEVN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TU8sTUFBTSxHQUFHLFlBQVlQLE1BQU1PLE1BQU0sR0FBRztRQUNsREMsVUFBVVIsTUFBTVEsUUFBUSxJQUFJLElBQUksWUFBWTtJQUNoRDtJQUNBLElBQUlSLE1BQU1TLEdBQUcsRUFBRTtRQUNYLElBQUksRUFBRWpELEtBQUssRUFBRVQsSUFBSSxFQUFFLEdBQUdpRCxNQUFNUyxHQUFHLEVBQUV2TCxPQUFPc0ksS0FBSyxDQUFDLEVBQUUsR0FBR2lDLE9BQU90SixHQUFHLEdBQUc4SixPQUFPOUssS0FBS3FJLEtBQUssQ0FBQyxFQUFFLEdBQUdpQyxPQUFPdEosR0FBRyxHQUFHOEo7UUFDcEdDLE9BQU9RLE9BQU8sR0FBRztZQUFDO2dCQUNWMUwsTUFBTTtnQkFDTjJMLE9BQU03RCxJQUFJLEVBQUVtRCxLQUFLO29CQUNibkQsS0FBS2lCLFFBQVEsQ0FBQzt3QkFBRUosU0FBUzs0QkFBRXpJLE1BQU0rSyxRQUFRL0s7NEJBQU1DLElBQUk4SyxRQUFROUs7NEJBQUl5SSxRQUFRYjt3QkFBSzt3QkFBR21CLGdCQUFnQjtvQkFBSztnQkFDeEc7WUFDSjtTQUFFO0lBQ1Y7SUFDQSxPQUFPZ0M7QUFDWDtBQUUyTSIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmctamF2YXNjcmlwdC9kaXN0L2luZGV4LmpzP2Y5OGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VyIH0gZnJvbSAnQGxlemVyL2phdmFzY3JpcHQnO1xuaW1wb3J0IHsgc3ludGF4VHJlZSwgTFJMYW5ndWFnZSwgaW5kZW50Tm9kZVByb3AsIGNvbnRpbnVlZEluZGVudCwgZmxhdEluZGVudCwgZGVsaW1pdGVkSW5kZW50LCBmb2xkTm9kZVByb3AsIGZvbGRJbnNpZGUsIGRlZmluZUxhbmd1YWdlRmFjZXQsIHN1Ymxhbmd1YWdlUHJvcCwgTGFuZ3VhZ2VTdXBwb3J0IH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgRWRpdG9yU2VsZWN0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgc25pcHBldENvbXBsZXRpb24sIGlmTm90SW4sIGNvbXBsZXRlRnJvbUxpc3QgfSBmcm9tICdAY29kZW1pcnJvci9hdXRvY29tcGxldGUnO1xuaW1wb3J0IHsgTm9kZVdlYWtNYXAsIEl0ZXJNb2RlIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8qKlxuQSBjb2xsZWN0aW9uIG9mIEphdmFTY3JpcHQtcmVsYXRlZFxuW3NuaXBwZXRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5zbmlwcGV0KS5cbiovXG5jb25zdCBzbmlwcGV0cyA9IFtcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmdW5jdGlvbiAke25hbWV9KCR7cGFyYW1zfSkge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJmdW5jdGlvblwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImZvciAobGV0ICR7aW5kZXh9ID0gMDsgJHtpbmRleH0gPCAke2JvdW5kfTsgJHtpbmRleH0rKykge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJmb3JcIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJmb3IgKGxldCAke25hbWV9IG9mICR7Y29sbGVjdGlvbn0pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiZm9yXCIsXG4gICAgICAgIGRldGFpbDogXCJvZiBsb29wXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiZG8ge1xcblxcdCR7fVxcbn0gd2hpbGUgKCR7fSlcIiwge1xuICAgICAgICBsYWJlbDogXCJkb1wiLFxuICAgICAgICBkZXRhaWw6IFwibG9vcFwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcIndoaWxlICgke30pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwid2hpbGVcIixcbiAgICAgICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ0cnkge1xcblxcdCR7fVxcbn0gY2F0Y2ggKCR7ZXJyb3J9KSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcInRyeVwiLFxuICAgICAgICBkZXRhaWw6IFwiLyBjYXRjaCBibG9ja1wiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImlmICgke30pIHtcXG5cXHQke31cXG59XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaWZcIixcbiAgICAgICAgZGV0YWlsOiBcImJsb2NrXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaWYgKCR7fSkge1xcblxcdCR7fVxcbn0gZWxzZSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImlmXCIsXG4gICAgICAgIGRldGFpbDogXCIvIGVsc2UgYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJjbGFzcyAke25hbWV9IHtcXG5cXHRjb25zdHJ1Y3Rvcigke3BhcmFtc30pIHtcXG5cXHRcXHQke31cXG5cXHR9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImNsYXNzXCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaW1wb3J0IHske25hbWVzfX0gZnJvbSBcXFwiJHttb2R1bGV9XFxcIlxcbiR7fVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImltcG9ydFwiLFxuICAgICAgICBkZXRhaWw6IFwibmFtZWRcIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJpbXBvcnQgJHtuYW1lfSBmcm9tIFxcXCIke21vZHVsZX1cXFwiXFxuJHt9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiaW1wb3J0XCIsXG4gICAgICAgIGRldGFpbDogXCJkZWZhdWx0XCIsXG4gICAgICAgIHR5cGU6IFwia2V5d29yZFwiXG4gICAgfSlcbl07XG4vKipcbkEgY29sbGVjdGlvbiBvZiBzbmlwcGV0IGNvbXBsZXRpb25zIGZvciBUeXBlU2NyaXB0LiBJbmNsdWRlcyB0aGVcbkphdmFTY3JpcHQgW3NuaXBwZXRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmctamF2YXNjcmlwdC5zbmlwcGV0cykuXG4qL1xuY29uc3QgdHlwZXNjcmlwdFNuaXBwZXRzID0gLypAX19QVVJFX18qL3NuaXBwZXRzLmNvbmNhdChbXG4gICAgLypAX19QVVJFX18qL3NuaXBwZXRDb21wbGV0aW9uKFwiaW50ZXJmYWNlICR7bmFtZX0ge1xcblxcdCR7fVxcbn1cIiwge1xuICAgICAgICBsYWJlbDogXCJpbnRlcmZhY2VcIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KSxcbiAgICAvKkBfX1BVUkVfXyovc25pcHBldENvbXBsZXRpb24oXCJ0eXBlICR7bmFtZX0gPSAke3R5cGV9XCIsIHtcbiAgICAgICAgbGFiZWw6IFwidHlwZVwiLFxuICAgICAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgICB0eXBlOiBcImtleXdvcmRcIlxuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9zbmlwcGV0Q29tcGxldGlvbihcImVudW0gJHtuYW1lfSB7XFxuXFx0JHt9XFxufVwiLCB7XG4gICAgICAgIGxhYmVsOiBcImVudW1cIixcbiAgICAgICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICAgICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgICB9KVxuXSk7XG5cbmNvbnN0IGNhY2hlID0gLypAX19QVVJFX18qL25ldyBOb2RlV2Vha01hcCgpO1xuY29uc3QgU2NvcGVOb2RlcyA9IC8qQF9fUFVSRV9fKi9uZXcgU2V0KFtcbiAgICBcIlNjcmlwdFwiLCBcIkJsb2NrXCIsXG4gICAgXCJGdW5jdGlvbkV4cHJlc3Npb25cIiwgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIFwiQXJyb3dGdW5jdGlvblwiLCBcIk1ldGhvZERlY2xhcmF0aW9uXCIsXG4gICAgXCJGb3JTdGF0ZW1lbnRcIlxuXSk7XG5mdW5jdGlvbiBkZWZJRCh0eXBlKSB7XG4gICAgcmV0dXJuIChub2RlLCBkZWYpID0+IHtcbiAgICAgICAgbGV0IGlkID0gbm9kZS5ub2RlLmdldENoaWxkKFwiVmFyaWFibGVEZWZpbml0aW9uXCIpO1xuICAgICAgICBpZiAoaWQpXG4gICAgICAgICAgICBkZWYoaWQsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuY29uc3QgZnVuY3Rpb25Db250ZXh0ID0gW1wiRnVuY3Rpb25EZWNsYXJhdGlvblwiXTtcbmNvbnN0IGdhdGhlckNvbXBsZXRpb25zID0ge1xuICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IC8qQF9fUFVSRV9fKi9kZWZJRChcImZ1bmN0aW9uXCIpLFxuICAgIENsYXNzRGVjbGFyYXRpb246IC8qQF9fUFVSRV9fKi9kZWZJRChcImNsYXNzXCIpLFxuICAgIENsYXNzRXhwcmVzc2lvbjogKCkgPT4gdHJ1ZSxcbiAgICBFbnVtRGVjbGFyYXRpb246IC8qQF9fUFVSRV9fKi9kZWZJRChcImNvbnN0YW50XCIpLFxuICAgIFR5cGVBbGlhc0RlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJ0eXBlXCIpLFxuICAgIE5hbWVzcGFjZURlY2xhcmF0aW9uOiAvKkBfX1BVUkVfXyovZGVmSUQoXCJuYW1lc3BhY2VcIiksXG4gICAgVmFyaWFibGVEZWZpbml0aW9uKG5vZGUsIGRlZikgeyBpZiAoIW5vZGUubWF0Y2hDb250ZXh0KGZ1bmN0aW9uQ29udGV4dCkpXG4gICAgICAgIGRlZihub2RlLCBcInZhcmlhYmxlXCIpOyB9LFxuICAgIFR5cGVEZWZpbml0aW9uKG5vZGUsIGRlZikgeyBkZWYobm9kZSwgXCJ0eXBlXCIpOyB9LFxuICAgIF9fcHJvdG9fXzogbnVsbFxufTtcbmZ1bmN0aW9uIGdldFNjb3BlKGRvYywgbm9kZSkge1xuICAgIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBbXSwgdG9wID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBkZWYobm9kZSwgdHlwZSkge1xuICAgICAgICBsZXQgbmFtZSA9IGRvYy5zbGljZVN0cmluZyhub2RlLmZyb20sIG5vZGUudG8pO1xuICAgICAgICBjb21wbGV0aW9ucy5wdXNoKHsgbGFiZWw6IG5hbWUsIHR5cGUgfSk7XG4gICAgfVxuICAgIG5vZGUuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpLml0ZXJhdGUobm9kZSA9PiB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgIHRvcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubmFtZSkge1xuICAgICAgICAgICAgbGV0IGdhdGhlciA9IGdhdGhlckNvbXBsZXRpb25zW25vZGUubmFtZV07XG4gICAgICAgICAgICBpZiAoZ2F0aGVyICYmIGdhdGhlcihub2RlLCBkZWYpIHx8IFNjb3BlTm9kZXMuaGFzKG5vZGUubmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudG8gLSBub2RlLmZyb20gPiA4MTkyKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBjYWNoaW5nIGZvciBiaWdnZXIgaW50ZXJuYWwgbm9kZXNcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgZ2V0U2NvcGUoZG9jLCBub2RlLm5vZGUpKVxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goYyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjYWNoZS5zZXQobm9kZSwgY29tcGxldGlvbnMpO1xuICAgIHJldHVybiBjb21wbGV0aW9ucztcbn1cbmNvbnN0IElkZW50aWZpZXIgPSAvXltcXHckXFx4YTEtXFx1ZmZmZl1bXFx3JFxcZFxceGExLVxcdWZmZmZdKiQvO1xuY29uc3QgZG9udENvbXBsZXRlID0gW1xuICAgIFwiVGVtcGxhdGVTdHJpbmdcIiwgXCJTdHJpbmdcIiwgXCJSZWdFeHBcIixcbiAgICBcIkxpbmVDb21tZW50XCIsIFwiQmxvY2tDb21tZW50XCIsXG4gICAgXCJWYXJpYWJsZURlZmluaXRpb25cIiwgXCJUeXBlRGVmaW5pdGlvblwiLCBcIkxhYmVsXCIsXG4gICAgXCJQcm9wZXJ0eURlZmluaXRpb25cIiwgXCJQcm9wZXJ0eU5hbWVcIixcbiAgICBcIlByaXZhdGVQcm9wZXJ0eURlZmluaXRpb25cIiwgXCJQcml2YXRlUHJvcGVydHlOYW1lXCIsXG4gICAgXCIuXCIsIFwiPy5cIlxuXTtcbi8qKlxuQ29tcGxldGlvbiBzb3VyY2UgdGhhdCBsb29rcyB1cCBsb2NhbGx5IGRlZmluZWQgbmFtZXMgaW5cbkphdmFTY3JpcHQgY29kZS5cbiovXG5mdW5jdGlvbiBsb2NhbENvbXBsZXRpb25Tb3VyY2UoY29udGV4dCkge1xuICAgIGxldCBpbm5lciA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7XG4gICAgaWYgKGRvbnRDb21wbGV0ZS5pbmRleE9mKGlubmVyLm5hbWUpID4gLTEpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBpc1dvcmQgPSBpbm5lci5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIgfHxcbiAgICAgICAgaW5uZXIudG8gLSBpbm5lci5mcm9tIDwgMjAgJiYgSWRlbnRpZmllci50ZXN0KGNvbnRleHQuc3RhdGUuc2xpY2VEb2MoaW5uZXIuZnJvbSwgaW5uZXIudG8pKTtcbiAgICBpZiAoIWlzV29yZCAmJiAhY29udGV4dC5leHBsaWNpdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG9wdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSBpbm5lcjsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgIGlmIChTY29wZU5vZGVzLmhhcyhwb3MubmFtZSkpXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jb25jYXQoZ2V0U2NvcGUoY29udGV4dC5zdGF0ZS5kb2MsIHBvcykpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmcm9tOiBpc1dvcmQgPyBpbm5lci5mcm9tIDogY29udGV4dC5wb3MsXG4gICAgICAgIHZhbGlkRm9yOiBJZGVudGlmaWVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhdGhGb3IocmVhZCwgbWVtYmVyLCBuYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBwYXRoID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgb2JqID0gbWVtYmVyLmZpcnN0Q2hpbGQsIHByb3A7XG4gICAgICAgIGlmICgob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm5hbWUpID09IFwiVmFyaWFibGVOYW1lXCIpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChyZWFkKG9iaikpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogcGF0aC5yZXZlcnNlKCksIG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLm5hbWUpID09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmICgoX2EgPSAocHJvcCA9IG9iai5sYXN0Q2hpbGQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT0gXCJQcm9wZXJ0eU5hbWVcIikge1xuICAgICAgICAgICAgcGF0aC5wdXNoKHJlYWQocHJvcCkpO1xuICAgICAgICAgICAgbWVtYmVyID0gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbkhlbHBlciBmdW5jdGlvbiBmb3IgZGVmaW5pbmcgSmF2YVNjcmlwdCBjb21wbGV0aW9uIHNvdXJjZXMuIEl0XG5yZXR1cm5zIHRoZSBjb21wbGV0YWJsZSBuYW1lIGFuZCBvYmplY3QgcGF0aCBmb3IgYSBjb21wbGV0aW9uXG5jb250ZXh0LCBvciBudWxsIGlmIG5vIG5hbWUvcHJvcGVydHkgY29tcGxldGlvbiBzaG91bGQgaGFwcGVuIGF0XG50aGF0IHBvc2l0aW9uLiBGb3IgZXhhbXBsZSwgd2hlbiBjb21wbGV0aW5nIGFmdGVyIGBhLmIuY2AgaXQgd2lsbFxucmV0dXJuIGB7cGF0aDogW1wiYVwiLCBcImJcIl0sIG5hbWU6IFwiY1wifWAuIFdoZW4gY29tcGxldGluZyBhZnRlciBgeGBcbml0IHdpbGwgcmV0dXJuIGB7cGF0aDogW10sIG5hbWU6IFwieFwifWAuIFdoZW4gbm90IGluIGEgcHJvcGVydHkgb3Jcbm5hbWUsIGl0IHdpbGwgcmV0dXJuIG51bGwgaWYgYGNvbnRleHQuZXhwbGljaXRgIGlzIGZhbHNlLCBhbmRcbmB7cGF0aDogW10sIG5hbWU6IFwiXCJ9YCBvdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gY29tcGxldGlvblBhdGgoY29udGV4dCkge1xuICAgIGxldCByZWFkID0gKG5vZGUpID0+IGNvbnRleHQuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKG5vZGUuZnJvbSwgbm9kZS50byk7XG4gICAgbGV0IGlubmVyID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTtcbiAgICBpZiAoaW5uZXIubmFtZSA9PSBcIlByb3BlcnR5TmFtZVwiKSB7XG4gICAgICAgIHJldHVybiBwYXRoRm9yKHJlYWQsIGlubmVyLnBhcmVudCwgcmVhZChpbm5lcikpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoaW5uZXIubmFtZSA9PSBcIi5cIiB8fCBpbm5lci5uYW1lID09IFwiPy5cIikgJiYgaW5uZXIucGFyZW50Lm5hbWUgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhGb3IocmVhZCwgaW5uZXIucGFyZW50LCBcIlwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9udENvbXBsZXRlLmluZGV4T2YoaW5uZXIubmFtZSkgPiAtMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5uZXIubmFtZSA9PSBcIlZhcmlhYmxlTmFtZVwiIHx8IGlubmVyLnRvIC0gaW5uZXIuZnJvbSA8IDIwICYmIElkZW50aWZpZXIudGVzdChyZWFkKGlubmVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogW10sIG5hbWU6IHJlYWQoaW5uZXIpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlubmVyLm5hbWUgPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhGb3IocmVhZCwgaW5uZXIsIFwiXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXhwbGljaXQgPyB7IHBhdGg6IFtdLCBuYW1lOiBcIlwiIH0gOiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVudW1lcmF0ZVByb3BlcnR5Q29tcGxldGlvbnMob2JqLCB0b3ApIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdLCBzZWVuID0gbmV3IFNldDtcbiAgICBmb3IgKGxldCBkZXB0aCA9IDA7OyBkZXB0aCsrKSB7XG4gICAgICAgIGZvciAobGV0IG5hbWUgb2YgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IE9iamVjdC5rZXlzKShvYmopKSB7XG4gICAgICAgICAgICBpZiAoIS9eW2EtekEtWl8kXFx4YWEtXFx1ZmZkY11bXFx3JFxceGFhLVxcdWZmZGNdKiQvLnRlc3QobmFtZSkgfHwgc2Vlbi5oYXMobmFtZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBzZWVuLmFkZChuYW1lKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsYWJlbDogbmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiID8gKC9eW0EtWl0vLnRlc3QobmFtZSkgPyBcImNsYXNzXCIgOiB0b3AgPyBcImZ1bmN0aW9uXCIgOiBcIm1ldGhvZFwiKVxuICAgICAgICAgICAgICAgICAgICA6IHRvcCA/IFwidmFyaWFibGVcIiA6IFwicHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICBib29zdDogLWRlcHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgb2JqID0gbmV4dDtcbiAgICB9XG59XG4vKipcbkRlZmluZXMgYSBbY29tcGxldGlvbiBzb3VyY2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Tb3VyY2UpIHRoYXRcbmNvbXBsZXRlcyBmcm9tIHRoZSBnaXZlbiBzY29wZSBvYmplY3QgKGZvciBleGFtcGxlIGBnbG9iYWxUaGlzYCkuXG5XaWxsIGVudGVyIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCB3aGVuIGNvbXBsZXRpbmcgcHJvcGVydGllcyBvblxuYSBkaXJlY3RseS1uYW1lZCBwYXRoLlxuKi9cbmZ1bmN0aW9uIHNjb3BlQ29tcGxldGlvblNvdXJjZShzY29wZSkge1xuICAgIGxldCBjYWNoZSA9IG5ldyBNYXA7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCBwYXRoID0gY29tcGxldGlvblBhdGgoY29udGV4dCk7XG4gICAgICAgIGlmICghcGF0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gc2NvcGU7XG4gICAgICAgIGZvciAobGV0IHN0ZXAgb2YgcGF0aC5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRbc3RlcF07XG4gICAgICAgICAgICBpZiAoIXRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3B0aW9ucyA9IGNhY2hlLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBjYWNoZS5zZXQodGFyZ2V0LCBvcHRpb25zID0gZW51bWVyYXRlUHJvcGVydHlDb21wbGV0aW9ucyh0YXJnZXQsICFwYXRoLnBhdGgubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiBjb250ZXh0LnBvcyAtIHBhdGgubmFtZS5sZW5ndGgsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgdmFsaWRGb3I6IElkZW50aWZpZXJcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgYmFzZWQgb24gdGhlIFtMZXplciBKYXZhU2NyaXB0XG5wYXJzZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZXplci1wYXJzZXIvamF2YXNjcmlwdCksIGV4dGVuZGVkIHdpdGhcbmhpZ2hsaWdodGluZyBhbmQgaW5kZW50YXRpb24gaW5mb3JtYXRpb24uXG4qL1xuY29uc3QgamF2YXNjcmlwdExhbmd1YWdlID0gLypAX19QVVJFX18qL0xSTGFuZ3VhZ2UuZGVmaW5lKHtcbiAgICBuYW1lOiBcImphdmFzY3JpcHRcIixcbiAgICBwYXJzZXI6IC8qQF9fUFVSRV9fKi9wYXJzZXIuY29uZmlndXJlKHtcbiAgICAgICAgcHJvcHM6IFtcbiAgICAgICAgICAgIC8qQF9fUFVSRV9fKi9pbmRlbnROb2RlUHJvcC5hZGQoe1xuICAgICAgICAgICAgICAgIElmU3RhdGVtZW50OiAvKkBfX1BVUkVfXyovY29udGludWVkSW5kZW50KHsgZXhjZXB0OiAvXlxccyooe3xlbHNlXFxiKS8gfSksXG4gICAgICAgICAgICAgICAgVHJ5U3RhdGVtZW50OiAvKkBfX1BVUkVfXyovY29udGludWVkSW5kZW50KHsgZXhjZXB0OiAvXlxccyooe3xjYXRjaFxcYnxmaW5hbGx5XFxiKS8gfSksXG4gICAgICAgICAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogZmxhdEluZGVudCxcbiAgICAgICAgICAgICAgICBTd2l0Y2hCb2R5OiBjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFmdGVyID0gY29udGV4dC50ZXh0QWZ0ZXIsIGNsb3NlZCA9IC9eXFxzKlxcfS8udGVzdChhZnRlciksIGlzQ2FzZSA9IC9eXFxzKihjYXNlfGRlZmF1bHQpXFxiLy50ZXN0KGFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChjbG9zZWQgPyAwIDogaXNDYXNlID8gMSA6IDIpICogY29udGV4dC51bml0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQmxvY2s6IC8qQF9fUFVSRV9fKi9kZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nOiBcIn1cIiB9KSxcbiAgICAgICAgICAgICAgICBBcnJvd0Z1bmN0aW9uOiBjeCA9PiBjeC5iYXNlSW5kZW50ICsgY3gudW5pdCxcbiAgICAgICAgICAgICAgICBcIlRlbXBsYXRlU3RyaW5nIEJsb2NrQ29tbWVudFwiOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgICAgIFwiU3RhdGVtZW50IFByb3BlcnR5XCI6IC8qQF9fUFVSRV9fKi9jb250aW51ZWRJbmRlbnQoeyBleGNlcHQ6IC9eey8gfSksXG4gICAgICAgICAgICAgICAgSlNYRWxlbWVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbG9zZWQgPSAvXlxccyo8XFwvLy50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQubGluZUluZGVudChjb250ZXh0Lm5vZGUuZnJvbSkgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBKU1hFc2NhcGUoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2xvc2VkID0gL1xccypcXH0vLnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5saW5lSW5kZW50KGNvbnRleHQubm9kZS5mcm9tKSArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiSlNYT3BlblRhZyBKU1hTZWxmQ2xvc2luZ1RhZ1wiKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29sdW1uKGNvbnRleHQubm9kZS5mcm9tKSArIGNvbnRleHQudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8qQF9fUFVSRV9fKi9mb2xkTm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgICAgICBcIkJsb2NrIENsYXNzQm9keSBTd2l0Y2hCb2R5IEVudW1Cb2R5IE9iamVjdEV4cHJlc3Npb24gQXJyYXlFeHByZXNzaW9uIE9iamVjdFR5cGVcIjogZm9sZEluc2lkZSxcbiAgICAgICAgICAgICAgICBCbG9ja0NvbW1lbnQodHJlZSkgeyByZXR1cm4geyBmcm9tOiB0cmVlLmZyb20gKyAyLCB0bzogdHJlZS50byAtIDIgfTsgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgIH0pLFxuICAgIGxhbmd1YWdlRGF0YToge1xuICAgICAgICBjbG9zZUJyYWNrZXRzOiB7IGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIicsIFwiYFwiXSB9LFxuICAgICAgICBjb21tZW50VG9rZW5zOiB7IGxpbmU6IFwiLy9cIiwgYmxvY2s6IHsgb3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wiIH0gfSxcbiAgICAgICAgaW5kZW50T25JbnB1dDogL15cXHMqKD86Y2FzZSB8ZGVmYXVsdDp8XFx7fFxcfXw8XFwvKSQvLFxuICAgICAgICB3b3JkQ2hhcnM6IFwiJFwiXG4gICAgfVxufSk7XG5jb25zdCBqc3hTdWJsYW5ndWFnZSA9IHtcbiAgICB0ZXN0OiBub2RlID0+IC9eSlNYLy50ZXN0KG5vZGUubmFtZSksXG4gICAgZmFjZXQ6IC8qQF9fUFVSRV9fKi9kZWZpbmVMYW5ndWFnZUZhY2V0KHsgY29tbWVudFRva2VuczogeyBibG9jazogeyBvcGVuOiBcInsvKlwiLCBjbG9zZTogXCIqL31cIiB9IH0gfSlcbn07XG4vKipcbkEgbGFuZ3VhZ2UgcHJvdmlkZXIgZm9yIFR5cGVTY3JpcHQuXG4qL1xuY29uc3QgdHlwZXNjcmlwdExhbmd1YWdlID0gLypAX19QVVJFX18qL2phdmFzY3JpcHRMYW5ndWFnZS5jb25maWd1cmUoeyBkaWFsZWN0OiBcInRzXCIgfSwgXCJ0eXBlc2NyaXB0XCIpO1xuLyoqXG5MYW5ndWFnZSBwcm92aWRlciBmb3IgSlNYLlxuKi9cbmNvbnN0IGpzeExhbmd1YWdlID0gLypAX19QVVJFX18qL2phdmFzY3JpcHRMYW5ndWFnZS5jb25maWd1cmUoe1xuICAgIGRpYWxlY3Q6IFwianN4XCIsXG4gICAgcHJvcHM6IFsvKkBfX1BVUkVfXyovc3VibGFuZ3VhZ2VQcm9wLmFkZChuID0+IG4uaXNUb3AgPyBbanN4U3VibGFuZ3VhZ2VdIDogdW5kZWZpbmVkKV1cbn0pO1xuLyoqXG5MYW5ndWFnZSBwcm92aWRlciBmb3IgSlNYICsgVHlwZVNjcmlwdC5cbiovXG5jb25zdCB0c3hMYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9qYXZhc2NyaXB0TGFuZ3VhZ2UuY29uZmlndXJlKHtcbiAgICBkaWFsZWN0OiBcImpzeCB0c1wiLFxuICAgIHByb3BzOiBbLypAX19QVVJFX18qL3N1Ymxhbmd1YWdlUHJvcC5hZGQobiA9PiBuLmlzVG9wID8gW2pzeFN1Ymxhbmd1YWdlXSA6IHVuZGVmaW5lZCldXG59LCBcInR5cGVzY3JpcHRcIik7XG5sZXQga3dDb21wbGV0aW9uID0gKG5hbWUpID0+ICh7IGxhYmVsOiBuYW1lLCB0eXBlOiBcImtleXdvcmRcIiB9KTtcbmNvbnN0IGtleXdvcmRzID0gLypAX19QVVJFX18qL1wiYnJlYWsgY2FzZSBjb25zdCBjb250aW51ZSBkZWZhdWx0IGRlbGV0ZSBleHBvcnQgZXh0ZW5kcyBmYWxzZSBmaW5hbGx5IGluIGluc3RhbmNlb2YgbGV0IG5ldyByZXR1cm4gc3RhdGljIHN1cGVyIHN3aXRjaCB0aGlzIHRocm93IHRydWUgdHlwZW9mIHZhciB5aWVsZFwiLnNwbGl0KFwiIFwiKS5tYXAoa3dDb21wbGV0aW9uKTtcbmNvbnN0IHR5cGVzY3JpcHRLZXl3b3JkcyA9IC8qQF9fUFVSRV9fKi9rZXl3b3Jkcy5jb25jYXQoLypAX19QVVJFX18qL1tcImRlY2xhcmVcIiwgXCJpbXBsZW1lbnRzXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiXS5tYXAoa3dDb21wbGV0aW9uKSk7XG4vKipcbkphdmFTY3JpcHQgc3VwcG9ydC4gSW5jbHVkZXMgW3NuaXBwZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZy1qYXZhc2NyaXB0LnNuaXBwZXRzKVxuY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBqYXZhc2NyaXB0KGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IGxhbmcgPSBjb25maWcuanN4ID8gKGNvbmZpZy50eXBlc2NyaXB0ID8gdHN4TGFuZ3VhZ2UgOiBqc3hMYW5ndWFnZSlcbiAgICAgICAgOiBjb25maWcudHlwZXNjcmlwdCA/IHR5cGVzY3JpcHRMYW5ndWFnZSA6IGphdmFzY3JpcHRMYW5ndWFnZTtcbiAgICBsZXQgY29tcGxldGlvbnMgPSBjb25maWcudHlwZXNjcmlwdCA/IHR5cGVzY3JpcHRTbmlwcGV0cy5jb25jYXQodHlwZXNjcmlwdEtleXdvcmRzKSA6IHNuaXBwZXRzLmNvbmNhdChrZXl3b3Jkcyk7XG4gICAgcmV0dXJuIG5ldyBMYW5ndWFnZVN1cHBvcnQobGFuZywgW1xuICAgICAgICBqYXZhc2NyaXB0TGFuZ3VhZ2UuZGF0YS5vZih7XG4gICAgICAgICAgICBhdXRvY29tcGxldGU6IGlmTm90SW4oZG9udENvbXBsZXRlLCBjb21wbGV0ZUZyb21MaXN0KGNvbXBsZXRpb25zKSlcbiAgICAgICAgfSksXG4gICAgICAgIGphdmFzY3JpcHRMYW5ndWFnZS5kYXRhLm9mKHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogbG9jYWxDb21wbGV0aW9uU291cmNlXG4gICAgICAgIH0pLFxuICAgICAgICBjb25maWcuanN4ID8gYXV0b0Nsb3NlVGFncyA6IFtdLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gZmluZE9wZW5UYWcobm9kZSkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PSBcIkpTWE9wZW5UYWdcIiB8fCBub2RlLm5hbWUgPT0gXCJKU1hTZWxmQ2xvc2luZ1RhZ1wiIHx8IG5vZGUubmFtZSA9PSBcIkpTWEZyYWdtZW50VGFnXCIpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PSBcIkpTWEVzY2FwZVwiIHx8ICFub2RlLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZWxlbWVudE5hbWUoZG9jLCB0cmVlLCBtYXggPSBkb2MubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgY2ggPSB0cmVlID09PSBudWxsIHx8IHRyZWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyZWUuZmlyc3RDaGlsZDsgY2g7IGNoID0gY2gubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgaWYgKGNoLm5hbWUgPT0gXCJKU1hJZGVudGlmaWVyXCIgfHwgY2gubmFtZSA9PSBcIkpTWEJ1aWx0aW5cIiB8fCBjaC5uYW1lID09IFwiSlNYTmFtZXNwYWNlZE5hbWVcIiB8fFxuICAgICAgICAgICAgY2gubmFtZSA9PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIilcbiAgICAgICAgICAgIHJldHVybiBkb2Muc2xpY2VTdHJpbmcoY2guZnJvbSwgTWF0aC5taW4oY2gudG8sIG1heCkpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmNvbnN0IGFuZHJvaWQgPSB0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgJiYgLypAX19QVVJFX18qLy9BbmRyb2lkXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLyoqXG5FeHRlbnNpb24gdGhhdCB3aWxsIGF1dG9tYXRpY2FsbHkgaW5zZXJ0IEpTWCBjbG9zZSB0YWdzIHdoZW4gYSBgPmAgb3JcbmAvYCBpcyB0eXBlZC5cbiovXG5jb25zdCBhdXRvQ2xvc2VUYWdzID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuaW5wdXRIYW5kbGVyLm9mKCh2aWV3LCBmcm9tLCB0bywgdGV4dCwgZGVmYXVsdEluc2VydCkgPT4ge1xuICAgIGlmICgoYW5kcm9pZCA/IHZpZXcuY29tcG9zaW5nIDogdmlldy5jb21wb3NpdGlvblN0YXJ0ZWQpIHx8IHZpZXcuc3RhdGUucmVhZE9ubHkgfHxcbiAgICAgICAgZnJvbSAhPSB0byB8fCAodGV4dCAhPSBcIj5cIiAmJiB0ZXh0ICE9IFwiL1wiKSB8fFxuICAgICAgICAhamF2YXNjcmlwdExhbmd1YWdlLmlzQWN0aXZlQXQodmlldy5zdGF0ZSwgZnJvbSwgLTEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGJhc2UgPSBkZWZhdWx0SW5zZXJ0KCksIHsgc3RhdGUgfSA9IGJhc2U7XG4gICAgbGV0IGNsb3NlVGFncyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB7IGhlYWQgfSA9IHJhbmdlLCBhcm91bmQgPSBzeW50YXhUcmVlKHN0YXRlKS5yZXNvbHZlSW5uZXIoaGVhZCAtIDEsIC0xKSwgbmFtZTtcbiAgICAgICAgaWYgKGFyb3VuZC5uYW1lID09IFwiSlNYU3RhcnRUYWdcIilcbiAgICAgICAgICAgIGFyb3VuZCA9IGFyb3VuZC5wYXJlbnQ7XG4gICAgICAgIGlmIChzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoaGVhZCAtIDEsIGhlYWQpICE9IHRleHQgfHwgYXJvdW5kLm5hbWUgPT0gXCJKU1hBdHRyaWJ1dGVWYWx1ZVwiICYmIGFyb3VuZC50byA+IGhlYWQpIDtcbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PSBcIj5cIiAmJiBhcm91bmQubmFtZSA9PSBcIkpTWEZyYWdtZW50VGFnXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlLCBjaGFuZ2VzOiB7IGZyb206IGhlYWQsIGluc2VydDogYDwvPmAgfSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHQgPT0gXCIvXCIgJiYgYXJvdW5kLm5hbWUgPT0gXCJKU1hTdGFydENsb3NlVGFnXCIpIHtcbiAgICAgICAgICAgIGxldCBlbXB0eSA9IGFyb3VuZC5wYXJlbnQsIGJhc2UgPSBlbXB0eS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoYmFzZSAmJiBlbXB0eS5mcm9tID09IGhlYWQgLSAyICYmXG4gICAgICAgICAgICAgICAgKChuYW1lID0gZWxlbWVudE5hbWUoc3RhdGUuZG9jLCBiYXNlLmZpcnN0Q2hpbGQsIGhlYWQpKSB8fCAoKF9hID0gYmFzZS5maXJzdENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT0gXCJKU1hGcmFnbWVudFRhZ1wiKSkge1xuICAgICAgICAgICAgICAgIGxldCBpbnNlcnQgPSBgJHtuYW1lfT5gO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQgKyBpbnNlcnQubGVuZ3RoLCAtMSksIGNoYW5nZXM6IHsgZnJvbTogaGVhZCwgaW5zZXJ0IH0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0ID09IFwiPlwiKSB7XG4gICAgICAgICAgICBsZXQgb3BlblRhZyA9IGZpbmRPcGVuVGFnKGFyb3VuZCk7XG4gICAgICAgICAgICBpZiAob3BlblRhZyAmJlxuICAgICAgICAgICAgICAgICEvXlxcLz8+fF48XFwvLy50ZXN0KHN0YXRlLmRvYy5zbGljZVN0cmluZyhoZWFkLCBoZWFkICsgMikpICYmXG4gICAgICAgICAgICAgICAgKG5hbWUgPSBlbGVtZW50TmFtZShzdGF0ZS5kb2MsIG9wZW5UYWcsIGhlYWQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSwgY2hhbmdlczogeyBmcm9tOiBoZWFkLCBpbnNlcnQ6IGA8LyR7bmFtZX0+YCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICB9KTtcbiAgICBpZiAoY2xvc2VUYWdzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKFtcbiAgICAgICAgYmFzZSxcbiAgICAgICAgc3RhdGUudXBkYXRlKGNsb3NlVGFncywgeyB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSlcbiAgICBdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG4vKipcbkNvbm5lY3RzIGFuIFtFU0xpbnRdKGh0dHBzOi8vZXNsaW50Lm9yZy8pIGxpbnRlciB0byBDb2RlTWlycm9yJ3NcbltsaW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQpIGludGVncmF0aW9uLiBgZXNsaW50YCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgdGhlXG5bYExpbnRlcmBdKGh0dHBzOi8vZXNsaW50Lm9yZy9kb2NzL2RldmVsb3Blci1ndWlkZS9ub2RlanMtYXBpI2xpbnRlcilcbmNsYXNzLCBhbmQgYGNvbmZpZ2AgYW4gb3B0aW9uYWwgRVNMaW50IGNvbmZpZ3VyYXRpb24uIFRoZSByZXR1cm5cbnZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gY2FuIGJlIHBhc3NlZCB0byBbYGxpbnRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5saW50ZXIpXG50byBjcmVhdGUgYSBKYXZhU2NyaXB0IGxpbnRpbmcgZXh0ZW5zaW9uLlxuXG5Ob3RlIHRoYXQgRVNMaW50IHRhcmdldHMgbm9kZSwgYW5kIGlzIHRyaWNreSB0byBydW4gaW4gdGhlXG5icm93c2VyLiBUaGVcbltlc2xpbnQtbGludGVyLWJyb3dzZXJpZnldKGh0dHBzOi8vZ2l0aHViLmNvbS9VemlUZWNoL2VzbGludC1saW50ZXItYnJvd3NlcmlmeSlcbnBhY2thZ2UgbWF5IGhlbHAgd2l0aCB0aGF0IChzZWVcbltleGFtcGxlXShodHRwczovL2dpdGh1Yi5jb20vVXppVGVjaC9lc2xpbnQtbGludGVyLWJyb3dzZXJpZnkvYmxvYi9tYXN0ZXIvZXhhbXBsZS9zY3JpcHQuanMpKS5cbiovXG5mdW5jdGlvbiBlc0xpbnQoZXNsaW50LCBjb25maWcpIHtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICBwYXJzZXJPcHRpb25zOiB7IGVjbWFWZXJzaW9uOiAyMDE5LCBzb3VyY2VUeXBlOiBcIm1vZHVsZVwiIH0sXG4gICAgICAgICAgICBlbnY6IHsgYnJvd3NlcjogdHJ1ZSwgbm9kZTogdHJ1ZSwgZXM2OiB0cnVlLCBlczIwMTU6IHRydWUsIGVzMjAxNzogdHJ1ZSwgZXMyMDIwOiB0cnVlIH0sXG4gICAgICAgICAgICBydWxlczoge31cbiAgICAgICAgfTtcbiAgICAgICAgZXNsaW50LmdldFJ1bGVzKCkuZm9yRWFjaCgoZGVzYywgbmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGRlc2MubWV0YS5kb2NzLnJlY29tbWVuZGVkKVxuICAgICAgICAgICAgICAgIGNvbmZpZy5ydWxlc1tuYW1lXSA9IDI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKHZpZXcpID0+IHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGZvdW5kID0gW107XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBqYXZhc2NyaXB0TGFuZ3VhZ2UuZmluZFJlZ2lvbnMoc3RhdGUpKSB7XG4gICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pLCBvZmZzZXQgPSB7IGxpbmU6IGZyb21MaW5lLm51bWJlciAtIDEsIGNvbDogZnJvbSAtIGZyb21MaW5lLmZyb20sIHBvczogZnJvbSB9O1xuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBlc2xpbnQudmVyaWZ5KHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSwgY29uZmlnKSlcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHRyYW5zbGF0ZURpYWdub3N0aWMoZCwgc3RhdGUuZG9jLCBvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcFBvcyhsaW5lLCBjb2wsIGRvYywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRvYy5saW5lKGxpbmUgKyBvZmZzZXQubGluZSkuZnJvbSArIGNvbCArIChsaW5lID09IDEgPyBvZmZzZXQuY29sIC0gMSA6IC0xKTtcbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZURpYWdub3N0aWMoaW5wdXQsIGRvYywgb2Zmc2V0KSB7XG4gICAgbGV0IHN0YXJ0ID0gbWFwUG9zKGlucHV0LmxpbmUsIGlucHV0LmNvbHVtbiwgZG9jLCBvZmZzZXQpO1xuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGZyb206IHN0YXJ0LFxuICAgICAgICB0bzogaW5wdXQuZW5kTGluZSAhPSBudWxsICYmIGlucHV0LmVuZENvbHVtbiAhPSAxID8gbWFwUG9zKGlucHV0LmVuZExpbmUsIGlucHV0LmVuZENvbHVtbiwgZG9jLCBvZmZzZXQpIDogc3RhcnQsXG4gICAgICAgIG1lc3NhZ2U6IGlucHV0Lm1lc3NhZ2UsXG4gICAgICAgIHNvdXJjZTogaW5wdXQucnVsZUlkID8gXCJlc2xpbnQ6XCIgKyBpbnB1dC5ydWxlSWQgOiBcImVzbGludFwiLFxuICAgICAgICBzZXZlcml0eTogaW5wdXQuc2V2ZXJpdHkgPT0gMSA/IFwid2FybmluZ1wiIDogXCJlcnJvclwiLFxuICAgIH07XG4gICAgaWYgKGlucHV0LmZpeCkge1xuICAgICAgICBsZXQgeyByYW5nZSwgdGV4dCB9ID0gaW5wdXQuZml4LCBmcm9tID0gcmFuZ2VbMF0gKyBvZmZzZXQucG9zIC0gc3RhcnQsIHRvID0gcmFuZ2VbMV0gKyBvZmZzZXQucG9zIC0gc3RhcnQ7XG4gICAgICAgIHJlc3VsdC5hY3Rpb25zID0gW3tcbiAgICAgICAgICAgICAgICBuYW1lOiBcImZpeFwiLFxuICAgICAgICAgICAgICAgIGFwcGx5KHZpZXcsIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBjaGFuZ2VzOiB7IGZyb206IHN0YXJ0ICsgZnJvbSwgdG86IHN0YXJ0ICsgdG8sIGluc2VydDogdGV4dCB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHsgYXV0b0Nsb3NlVGFncywgY29tcGxldGlvblBhdGgsIGVzTGludCwgamF2YXNjcmlwdCwgamF2YXNjcmlwdExhbmd1YWdlLCBqc3hMYW5ndWFnZSwgbG9jYWxDb21wbGV0aW9uU291cmNlLCBzY29wZUNvbXBsZXRpb25Tb3VyY2UsIHNuaXBwZXRzLCB0c3hMYW5ndWFnZSwgdHlwZXNjcmlwdExhbmd1YWdlLCB0eXBlc2NyaXB0U25pcHBldHMgfTtcbiJdLCJuYW1lcyI6WyJwYXJzZXIiLCJzeW50YXhUcmVlIiwiTFJMYW5ndWFnZSIsImluZGVudE5vZGVQcm9wIiwiY29udGludWVkSW5kZW50IiwiZmxhdEluZGVudCIsImRlbGltaXRlZEluZGVudCIsImZvbGROb2RlUHJvcCIsImZvbGRJbnNpZGUiLCJkZWZpbmVMYW5ndWFnZUZhY2V0Iiwic3VibGFuZ3VhZ2VQcm9wIiwiTGFuZ3VhZ2VTdXBwb3J0IiwiRWRpdG9yU2VsZWN0aW9uIiwiRWRpdG9yVmlldyIsInNuaXBwZXRDb21wbGV0aW9uIiwiaWZOb3RJbiIsImNvbXBsZXRlRnJvbUxpc3QiLCJOb2RlV2Vha01hcCIsIkl0ZXJNb2RlIiwic25pcHBldHMiLCJsYWJlbCIsImRldGFpbCIsInR5cGUiLCJ0eXBlc2NyaXB0U25pcHBldHMiLCJjb25jYXQiLCJjYWNoZSIsIlNjb3BlTm9kZXMiLCJTZXQiLCJkZWZJRCIsIm5vZGUiLCJkZWYiLCJpZCIsImdldENoaWxkIiwiZnVuY3Rpb25Db250ZXh0IiwiZ2F0aGVyQ29tcGxldGlvbnMiLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwiQ2xhc3NEZWNsYXJhdGlvbiIsIkNsYXNzRXhwcmVzc2lvbiIsIkVudW1EZWNsYXJhdGlvbiIsIlR5cGVBbGlhc0RlY2xhcmF0aW9uIiwiTmFtZXNwYWNlRGVjbGFyYXRpb24iLCJWYXJpYWJsZURlZmluaXRpb24iLCJtYXRjaENvbnRleHQiLCJUeXBlRGVmaW5pdGlvbiIsIl9fcHJvdG9fXyIsImdldFNjb3BlIiwiZG9jIiwiY2FjaGVkIiwiZ2V0IiwiY29tcGxldGlvbnMiLCJ0b3AiLCJuYW1lIiwic2xpY2VTdHJpbmciLCJmcm9tIiwidG8iLCJwdXNoIiwiY3Vyc29yIiwiSW5jbHVkZUFub255bW91cyIsIml0ZXJhdGUiLCJnYXRoZXIiLCJoYXMiLCJjIiwic2V0IiwiSWRlbnRpZmllciIsImRvbnRDb21wbGV0ZSIsImxvY2FsQ29tcGxldGlvblNvdXJjZSIsImNvbnRleHQiLCJpbm5lciIsInN0YXRlIiwicmVzb2x2ZUlubmVyIiwicG9zIiwiaW5kZXhPZiIsImlzV29yZCIsInRlc3QiLCJzbGljZURvYyIsImV4cGxpY2l0Iiwib3B0aW9ucyIsInBhcmVudCIsInZhbGlkRm9yIiwicGF0aEZvciIsInJlYWQiLCJtZW1iZXIiLCJfYSIsInBhdGgiLCJvYmoiLCJmaXJzdENoaWxkIiwicHJvcCIsInJldmVyc2UiLCJsYXN0Q2hpbGQiLCJjb21wbGV0aW9uUGF0aCIsImVudW1lcmF0ZVByb3BlcnR5Q29tcGxldGlvbnMiLCJzZWVuIiwiZGVwdGgiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwia2V5cyIsImFkZCIsInZhbHVlIiwiXyIsImJvb3N0IiwibmV4dCIsImdldFByb3RvdHlwZU9mIiwic2NvcGVDb21wbGV0aW9uU291cmNlIiwic2NvcGUiLCJNYXAiLCJ0YXJnZXQiLCJzdGVwIiwibGVuZ3RoIiwiamF2YXNjcmlwdExhbmd1YWdlIiwiZGVmaW5lIiwiY29uZmlndXJlIiwicHJvcHMiLCJJZlN0YXRlbWVudCIsImV4Y2VwdCIsIlRyeVN0YXRlbWVudCIsIkxhYmVsZWRTdGF0ZW1lbnQiLCJTd2l0Y2hCb2R5IiwiYWZ0ZXIiLCJ0ZXh0QWZ0ZXIiLCJjbG9zZWQiLCJpc0Nhc2UiLCJiYXNlSW5kZW50IiwidW5pdCIsIkJsb2NrIiwiY2xvc2luZyIsIkFycm93RnVuY3Rpb24iLCJjeCIsIkpTWEVsZW1lbnQiLCJsaW5lSW5kZW50IiwiSlNYRXNjYXBlIiwiY29sdW1uIiwiQmxvY2tDb21tZW50IiwidHJlZSIsImxhbmd1YWdlRGF0YSIsImNsb3NlQnJhY2tldHMiLCJicmFja2V0cyIsImNvbW1lbnRUb2tlbnMiLCJsaW5lIiwiYmxvY2siLCJvcGVuIiwiY2xvc2UiLCJpbmRlbnRPbklucHV0Iiwid29yZENoYXJzIiwianN4U3VibGFuZ3VhZ2UiLCJmYWNldCIsInR5cGVzY3JpcHRMYW5ndWFnZSIsImRpYWxlY3QiLCJqc3hMYW5ndWFnZSIsIm4iLCJpc1RvcCIsInVuZGVmaW5lZCIsInRzeExhbmd1YWdlIiwia3dDb21wbGV0aW9uIiwia2V5d29yZHMiLCJzcGxpdCIsIm1hcCIsInR5cGVzY3JpcHRLZXl3b3JkcyIsImphdmFzY3JpcHQiLCJjb25maWciLCJsYW5nIiwianN4IiwidHlwZXNjcmlwdCIsImRhdGEiLCJvZiIsImF1dG9jb21wbGV0ZSIsImF1dG9DbG9zZVRhZ3MiLCJmaW5kT3BlblRhZyIsImVsZW1lbnROYW1lIiwibWF4IiwiY2giLCJuZXh0U2libGluZyIsIk1hdGgiLCJtaW4iLCJhbmRyb2lkIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5wdXRIYW5kbGVyIiwidmlldyIsInRleHQiLCJkZWZhdWx0SW5zZXJ0IiwiY29tcG9zaW5nIiwiY29tcG9zaXRpb25TdGFydGVkIiwicmVhZE9ubHkiLCJpc0FjdGl2ZUF0IiwiYmFzZSIsImNsb3NlVGFncyIsImNoYW5nZUJ5UmFuZ2UiLCJyYW5nZSIsImhlYWQiLCJhcm91bmQiLCJjaGFuZ2VzIiwiaW5zZXJ0IiwiZW1wdHkiLCJvcGVuVGFnIiwiZGlzcGF0Y2giLCJ1cGRhdGUiLCJ1c2VyRXZlbnQiLCJzY3JvbGxJbnRvVmlldyIsImVzTGludCIsImVzbGludCIsInBhcnNlck9wdGlvbnMiLCJlY21hVmVyc2lvbiIsInNvdXJjZVR5cGUiLCJlbnYiLCJicm93c2VyIiwiZXM2IiwiZXMyMDE1IiwiZXMyMDE3IiwiZXMyMDIwIiwicnVsZXMiLCJnZXRSdWxlcyIsImZvckVhY2giLCJkZXNjIiwibWV0YSIsImRvY3MiLCJyZWNvbW1lbmRlZCIsImZvdW5kIiwiZmluZFJlZ2lvbnMiLCJmcm9tTGluZSIsImxpbmVBdCIsIm9mZnNldCIsIm51bWJlciIsImNvbCIsImQiLCJ2ZXJpZnkiLCJ0cmFuc2xhdGVEaWFnbm9zdGljIiwibWFwUG9zIiwiaW5wdXQiLCJzdGFydCIsInJlc3VsdCIsImVuZExpbmUiLCJlbmRDb2x1bW4iLCJtZXNzYWdlIiwic291cmNlIiwicnVsZUlkIiwic2V2ZXJpdHkiLCJmaXgiLCJhY3Rpb25zIiwiYXBwbHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lang-javascript/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocInput: () => (/* binding */ DocInput),\n/* harmony export */   HighlightStyle: () => (/* binding */ HighlightStyle),\n/* harmony export */   IndentContext: () => (/* binding */ IndentContext),\n/* harmony export */   LRLanguage: () => (/* binding */ LRLanguage),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   LanguageDescription: () => (/* binding */ LanguageDescription),\n/* harmony export */   LanguageSupport: () => (/* binding */ LanguageSupport),\n/* harmony export */   ParseContext: () => (/* binding */ ParseContext),\n/* harmony export */   StreamLanguage: () => (/* binding */ StreamLanguage),\n/* harmony export */   StringStream: () => (/* binding */ StringStream),\n/* harmony export */   TreeIndentContext: () => (/* binding */ TreeIndentContext),\n/* harmony export */   bidiIsolates: () => (/* binding */ bidiIsolates),\n/* harmony export */   bracketMatching: () => (/* binding */ bracketMatching),\n/* harmony export */   bracketMatchingHandle: () => (/* binding */ bracketMatchingHandle),\n/* harmony export */   codeFolding: () => (/* binding */ codeFolding),\n/* harmony export */   continuedIndent: () => (/* binding */ continuedIndent),\n/* harmony export */   defaultHighlightStyle: () => (/* binding */ defaultHighlightStyle),\n/* harmony export */   defineLanguageFacet: () => (/* binding */ defineLanguageFacet),\n/* harmony export */   delimitedIndent: () => (/* binding */ delimitedIndent),\n/* harmony export */   ensureSyntaxTree: () => (/* binding */ ensureSyntaxTree),\n/* harmony export */   flatIndent: () => (/* binding */ flatIndent),\n/* harmony export */   foldAll: () => (/* binding */ foldAll),\n/* harmony export */   foldCode: () => (/* binding */ foldCode),\n/* harmony export */   foldEffect: () => (/* binding */ foldEffect),\n/* harmony export */   foldGutter: () => (/* binding */ foldGutter),\n/* harmony export */   foldInside: () => (/* binding */ foldInside),\n/* harmony export */   foldKeymap: () => (/* binding */ foldKeymap),\n/* harmony export */   foldNodeProp: () => (/* binding */ foldNodeProp),\n/* harmony export */   foldService: () => (/* binding */ foldService),\n/* harmony export */   foldState: () => (/* binding */ foldState),\n/* harmony export */   foldable: () => (/* binding */ foldable),\n/* harmony export */   foldedRanges: () => (/* binding */ foldedRanges),\n/* harmony export */   forceParsing: () => (/* binding */ forceParsing),\n/* harmony export */   getIndentUnit: () => (/* binding */ getIndentUnit),\n/* harmony export */   getIndentation: () => (/* binding */ getIndentation),\n/* harmony export */   highlightingFor: () => (/* binding */ highlightingFor),\n/* harmony export */   indentNodeProp: () => (/* binding */ indentNodeProp),\n/* harmony export */   indentOnInput: () => (/* binding */ indentOnInput),\n/* harmony export */   indentRange: () => (/* binding */ indentRange),\n/* harmony export */   indentService: () => (/* binding */ indentService),\n/* harmony export */   indentString: () => (/* binding */ indentString),\n/* harmony export */   indentUnit: () => (/* binding */ indentUnit),\n/* harmony export */   language: () => (/* binding */ language),\n/* harmony export */   languageDataProp: () => (/* binding */ languageDataProp),\n/* harmony export */   matchBrackets: () => (/* binding */ matchBrackets),\n/* harmony export */   sublanguageProp: () => (/* binding */ sublanguageProp),\n/* harmony export */   syntaxHighlighting: () => (/* binding */ syntaxHighlighting),\n/* harmony export */   syntaxParserRunning: () => (/* binding */ syntaxParserRunning),\n/* harmony export */   syntaxTree: () => (/* binding */ syntaxTree),\n/* harmony export */   syntaxTreeAvailable: () => (/* binding */ syntaxTreeAvailable),\n/* harmony export */   toggleFold: () => (/* binding */ toggleFold),\n/* harmony export */   unfoldAll: () => (/* binding */ unfoldAll),\n/* harmony export */   unfoldCode: () => (/* binding */ unfoldCode),\n/* harmony export */   unfoldEffect: () => (/* binding */ unfoldEffect)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\nvar _a;\n/**\nNode prop stored in a parser's top syntax node to provide the\nfacet that stores language-specific data for that language.\n*/ const languageDataProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/ function defineLanguageFacet(baseData) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n        combine: baseData ? (values)=>values.concat(baseData) : undefined\n    });\n}\n/**\nSyntax node prop used to register sublanguages. Should be added to\nthe top level node type for the language.\n*/ const sublanguageProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\nfor stream parsers.\n*/ class Language {\n    /**\n    Construct a language object. If you need to invoke this\n    directly, first define a data facet with\n    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n    to the language's outer syntax node.\n    */ constructor(/**\n    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\n    used for this language.\n    */ data, parser, extraExtensions = [], /**\n    A language name.\n    */ name = \"\"){\n        this.data = data;\n        this.name = name;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", {\n            get () {\n                return syntaxTree(this);\n            }\n        });\n        this.parser = parser;\n        this.extension = [\n            language.of(this),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side)=>{\n                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);\n                if (!data) return [];\n                let base = state.facet(data), sub = top.type.prop(sublanguageProp);\n                if (sub) {\n                    let innerNode = top.resolve(pos - top.from, side);\n                    for (let sublang of sub)if (sublang.test(innerNode, state)) {\n                        let data = state.facet(sublang.facet);\n                        return sublang.type == \"replace\" ? data : data.concat(base);\n                    }\n                }\n                return base;\n            })\n        ].concat(extraExtensions);\n    }\n    /**\n    Query whether this language is active at the given position.\n    */ isActiveAt(state, pos, side = -1) {\n        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;\n    }\n    /**\n    Find the document regions that were parsed using this language.\n    The returned regions will _include_ any nested languages rooted\n    in this language, when those exist.\n    */ findRegions(state) {\n        let lang = state.facet(language);\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [\n            {\n                from: 0,\n                to: state.doc.length\n            }\n        ];\n        if (!lang || !lang.allowsNesting) return [];\n        let result = [];\n        let explore = (tree, from)=>{\n            if (tree.prop(languageDataProp) == this.data) {\n                result.push({\n                    from,\n                    to: from + tree.length\n                });\n                return;\n            }\n            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n            if (mount) {\n                if (mount.tree.prop(languageDataProp) == this.data) {\n                    if (mount.overlay) for (let r of mount.overlay)result.push({\n                        from: r.from + from,\n                        to: r.to + from\n                    });\n                    else result.push({\n                        from: from,\n                        to: from + tree.length\n                    });\n                    return;\n                } else if (mount.overlay) {\n                    let size = result.length;\n                    explore(mount.tree, mount.overlay[0].from + from);\n                    if (result.length > size) return;\n                }\n            }\n            for(let i = 0; i < tree.children.length; i++){\n                let ch = tree.children[i];\n                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) explore(ch, tree.positions[i] + from);\n            }\n        };\n        explore(syntaxTree(state), 0);\n        return result;\n    }\n    /**\n    Indicates whether this language allows nested languages. The\n    default implementation returns true.\n    */ get allowsNesting() {\n        return true;\n    }\n}\n/**\n@internal\n*/ Language.setState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction topNodeAt(state, pos, side) {\n    let topLang = state.facet(language), tree = syntaxTree(state).topNode;\n    if (!topLang || topLang.allowsNesting) {\n        for(let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers))if (node.type.isTop) tree = node;\n    }\n    return tree;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/ class LRLanguage extends Language {\n    constructor(data, parser, name){\n        super(data, parser, [], name);\n        this.parser = parser;\n    }\n    /**\n    Define a language from a parser.\n    */ static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LRLanguage(data, spec.parser.configure({\n            props: [\n                languageDataProp.add((type)=>type.isTop ? data : undefined)\n            ]\n        }), spec.name);\n    }\n    /**\n    Create a new instance of this language with a reconfigured\n    version of its parser and optionally a new name.\n    */ configure(options, name) {\n        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\n    }\n    get allowsNesting() {\n        return this.parser.hasWrappers();\n    }\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of the active\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\nlanguage available.\n*/ function syntaxTree(state) {\n    let field = state.field(Language.state, false);\n    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/ function ensureSyntaxTree(state, upto, timeout = 50) {\n    var _a;\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n    if (!parse) return null;\n    let oldVieport = parse.viewport;\n    parse.updateViewport({\n        from: 0,\n        to: upto\n    });\n    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\n    parse.updateViewport(oldVieport);\n    return result;\n}\n/**\nQueries whether there is a full syntax tree available up to the\ngiven document position. If there isn't, the background parse\nprocess _might_ still be working and update the tree further, but\nthere is no guarantee of that—the parser will [stop\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\ncertain amount of time or has moved beyond the visible viewport.\nAlways returns false if no language has been enabled.\n*/ function syntaxTreeAvailable(state, upto = state.doc.length) {\n    var _a;\n    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\n}\n/**\nMove parsing forward, and update the editor state afterwards to\nreflect the new tree. Will work for at most `timeout`\nmilliseconds. Returns true if the parser managed get to the given\nposition in that time.\n*/ function forceParsing(view, upto = view.viewport.to, timeout = 100) {\n    let success = ensureSyntaxTree(view.state, upto, timeout);\n    if (success != syntaxTree(view.state)) view.dispatch({});\n    return !!success;\n}\n/**\nTells you whether the language parser is planning to do more\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\nstopped running, either because it parsed the entire document,\nbecause it spent too much time and was cut off, or because there\nis no language parser enabled.\n*/ function syntaxParserRunning(view) {\n    var _a;\n    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\n}\n/**\nLezer-style\n[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)\nobject for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.\n*/ class DocInput {\n    /**\n    Create an input object for the given document.\n    */ constructor(doc){\n        this.doc = doc;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get length() {\n        return this.doc.length;\n    }\n    syncTo(pos) {\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    chunk(pos) {\n        this.syncTo(pos);\n        return this.string;\n    }\n    get lineChunks() {\n        return true;\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);\n        else return this.string.slice(from - stringStart, to - stringStart);\n    }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/ class ParseContext {\n    constructor(parser, /**\n    The current editor state.\n    */ state, /**\n    Tree fragments that can be reused by incremental re-parses.\n    */ fragments = [], /**\n    @internal\n    */ tree, /**\n    @internal\n    */ treeLen, /**\n    The current editor viewport (or some overapproximation\n    thereof). Intended to be used for opportunistically avoiding\n    work (in which case\n    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n    should be called to make sure the parser is restarted when the\n    skipped region becomes visible).\n    */ viewport, /**\n    @internal\n    */ skipped, /**\n    This is where skipping parsers can register a promise that,\n    when resolved, will schedule a new parse. It is cleared when\n    the parse worker picks up the promise. @internal\n    */ scheduleOn){\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.treeLen = treeLen;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.scheduleOn = scheduleOn;\n        this.parse = null;\n        /**\n        @internal\n        */ this.tempSkipped = [];\n    }\n    /**\n    @internal\n    */ static create(parser, state, viewport) {\n        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\n    }\n    startParse() {\n        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n    }\n    /**\n    @internal\n    */ work(until, upto) {\n        if (upto != null && upto >= this.state.doc.length) upto = undefined;\n        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n            this.takeTree();\n            return true;\n        }\n        return this.withContext(()=>{\n            var _a;\n            if (typeof until == \"number\") {\n                let endTime = Date.now() + until;\n                until = ()=>Date.now() > endTime;\n            }\n            if (!this.parse) this.parse = this.startParse();\n            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);\n            for(;;){\n                let done = this.parse.advance();\n                if (done) {\n                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n                    this.tree = done;\n                    this.parse = null;\n                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();\n                    else return true;\n                }\n                if (until()) return false;\n            }\n        });\n    }\n    /**\n    @internal\n    */ takeTree() {\n        let pos, tree;\n        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\n            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);\n            this.withContext(()=>{\n                while(!(tree = this.parse.advance())){}\n            });\n            this.treeLen = pos;\n            this.tree = tree;\n            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n            this.parse = null;\n        }\n    }\n    withContext(f) {\n        let prev = currentContext;\n        currentContext = this;\n        try {\n            return f();\n        } finally{\n            currentContext = prev;\n        }\n    }\n    withoutTempSkipped(fragments) {\n        for(let r; r = this.tempSkipped.pop();)fragments = cutFragments(fragments, r.from, r.to);\n        return fragments;\n    }\n    /**\n    @internal\n    */ changes(changes, newState) {\n        let { fragments, tree, treeLen, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB)=>ranges.push({\n                    fromA,\n                    toA,\n                    fromB,\n                    toB\n                }));\n            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n            treeLen = 0;\n            viewport = {\n                from: changes.mapPos(viewport.from, -1),\n                to: changes.mapPos(viewport.to, 1)\n            };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped){\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to) skipped.push({\n                        from,\n                        to\n                    });\n                }\n            }\n        }\n        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n    }\n    /**\n    @internal\n    */ updateViewport(viewport) {\n        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for(let i = 0; i < this.skipped.length; i++){\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.fragments = cutFragments(this.fragments, from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        if (this.skipped.length >= startLen) return false;\n        this.reset();\n        return true;\n    }\n    /**\n    @internal\n    */ reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    /**\n    Notify the parse scheduler that the given region was skipped\n    because it wasn't in view, and the parse should be restarted\n    when it comes into view.\n    */ skipUntilInView(from, to) {\n        this.skipped.push({\n            from,\n            to\n        });\n    }\n    /**\n    Returns a parser intended to be used as placeholder when\n    asynchronously loading a nested parser. It'll skip its input and\n    mark it as not-really-parsed, so that the next update will parse\n    it again.\n    \n    When `until` is given, a reparse will be scheduled when that\n    promise resolves.\n    */ static getSkippingParser(until) {\n        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                let from = ranges[0].from, to = ranges[ranges.length - 1].to;\n                let parser = {\n                    parsedPos: from,\n                    advance () {\n                        let cx = currentContext;\n                        if (cx) {\n                            for (let r of ranges)cx.tempSkipped.push(r);\n                            if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([\n                                cx.scheduleOn,\n                                until\n                            ]) : until;\n                        }\n                        this.parsedPos = to;\n                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n                    },\n                    stoppedAt: null,\n                    stopAt () {}\n                };\n                return parser;\n            }\n        };\n    }\n    /**\n    @internal\n    */ isDone(upto) {\n        upto = Math.min(upto, this.state.doc.length);\n        let frags = this.fragments;\n        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n    }\n    /**\n    Get the context for the current parse, or `null` if no editor\n    parse is in progress.\n    */ static get() {\n        return currentContext;\n    }\n}\nfunction cutFragments(fragments, from, to) {\n    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [\n        {\n            fromA: from,\n            toA: to,\n            fromB: from,\n            toB: to\n        }\n    ]);\n}\nclass LanguageState {\n    constructor(// A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context){\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged && this.tree == this.context.tree) return this;\n        let newCx = this.context.changes(tr.changes, tr.state);\n        // If the previous parse wasn't done, go forward only up to its\n        // end position or the end of the viewport, to avoid slowing down\n        // state updates with parse work beyond the viewport.\n        let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n        if (!newCx.work(20 /* Work.Apply */ , upto)) newCx.takeTree();\n        return new LanguageState(newCx);\n    }\n    static init(state) {\n        let vpTo = Math.min(3000 /* Work.InitViewport */ , state.doc.length);\n        let parseState = ParseContext.create(state.facet(language).parser, state, {\n            from: 0,\n            to: vpTo\n        });\n        if (!parseState.work(20 /* Work.Apply */ , vpTo)) parseState.takeTree();\n        return new LanguageState(parseState);\n    }\n}\nLanguage.state = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create: LanguageState.init,\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(Language.setState)) return e.value;\n        if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n        return value.apply(tr);\n    }\n});\nlet requestIdle = (callback)=>{\n    let timeout = setTimeout(()=>callback(), 500 /* Work.MaxPause */ );\n    return ()=>clearTimeout(timeout);\n};\nif (typeof requestIdleCallback != \"undefined\") requestIdle = (callback)=>{\n    let idle = -1, timeout = setTimeout(()=>{\n        idle = requestIdleCallback(callback, {\n            timeout: 500 /* Work.MaxPause */  - 100 /* Work.MinPause */ \n        });\n    }, 100 /* Work.MinPause */ );\n    return ()=>idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\n};\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? ()=>navigator.scheduling.isInputPending() : null;\nconst parseWorker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\n    constructor(view){\n        this.view = view;\n        this.working = null;\n        this.workScheduled = 0;\n        // End of the current time chunk\n        this.chunkEnd = -1;\n        // Milliseconds of budget left for this chunk\n        this.chunkBudget = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        let cx = this.view.state.field(Language.state).context;\n        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();\n        if (update.docChanged || update.selectionSet) {\n            if (this.view.hasFocus) this.chunkBudget += 50 /* Work.ChangeBonus */ ;\n            this.scheduleWork();\n        }\n        this.checkAsyncSchedule(cx);\n    }\n    scheduleWork() {\n        if (this.working) return;\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);\n    }\n    work(deadline) {\n        this.working = null;\n        let now = Date.now();\n        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n            this.chunkEnd = now + 30000 /* Work.ChunkTime */ ;\n            this.chunkBudget = 3000 /* Work.ChunkBudget */ ;\n        }\n        if (this.chunkBudget <= 0) return; // No more budget\n        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);\n        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */ )) return;\n        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */ , deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */ , deadline.timeRemaining() - 5) : 1e9);\n        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\n        let done = field.context.work(()=>{\n            return isInputPending && isInputPending() || Date.now() > endTime;\n        }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */ ));\n        this.chunkBudget -= Date.now() - now;\n        if (done || this.chunkBudget <= 0) {\n            field.context.takeTree();\n            this.view.dispatch({\n                effects: Language.setState.of(new LanguageState(field.context))\n            });\n        }\n        if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();\n        this.checkAsyncSchedule(field.context);\n    }\n    checkAsyncSchedule(cx) {\n        if (cx.scheduleOn) {\n            this.workScheduled++;\n            cx.scheduleOn.then(()=>this.scheduleWork()).catch((err)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err)).then(()=>this.workScheduled--);\n            cx.scheduleOn = null;\n        }\n    }\n    destroy() {\n        if (this.working) this.working();\n    }\n    isWorking() {\n        return !!(this.working || this.workScheduled > 0);\n    }\n}, {\n    eventHandlers: {\n        focus () {\n            this.scheduleWork();\n        }\n    }\n});\n/**\nThe facet used to associate a language with an editor state. Used\nby `Language` object's `extension` property (so you don't need to\nmanually wrap your languages in this). Can be used to access the\ncurrent language on a state.\n*/ const language = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (languages) {\n        return languages.length ? languages[0] : null;\n    },\n    enables: (language)=>[\n            Language.state,\n            parseWorker,\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([\n                language\n            ], (state)=>{\n                let lang = state.facet(language);\n                return lang && lang.name ? {\n                    \"data-language\": lang.name\n                } : {};\n            })\n        ]\n});\n/**\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/ class LanguageSupport {\n    /**\n    Create a language support object.\n    */ constructor(/**\n    The language object.\n    */ language, /**\n    An optional set of supporting extensions. When nesting a\n    language in another language, the outer language is encouraged\n    to include the supporting extensions for its inner languages\n    in its own set of support extensions.\n    */ support = []){\n        this.language = language;\n        this.support = support;\n        this.extension = [\n            language,\n            support\n        ];\n    }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/ class LanguageDescription {\n    constructor(/**\n    The name of this language.\n    */ name, /**\n    Alternative names for the mode (lowercased, includes `this.name`).\n    */ alias, /**\n    File extensions associated with this language.\n    */ extensions, /**\n    Optional filename pattern that should be associated with this\n    language.\n    */ filename, loadFunc, /**\n    If the language has been loaded, this will hold its value.\n    */ support = undefined){\n        this.name = name;\n        this.alias = alias;\n        this.extensions = extensions;\n        this.filename = filename;\n        this.loadFunc = loadFunc;\n        this.support = support;\n        this.loading = null;\n    }\n    /**\n    Start loading the the language. Will return a promise that\n    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n    object when the language successfully loads.\n    */ load() {\n        return this.loading || (this.loading = this.loadFunc().then((support)=>this.support = support, (err)=>{\n            this.loading = null;\n            throw err;\n        }));\n    }\n    /**\n    Create a language description.\n    */ static of(spec) {\n        let { load, support } = spec;\n        if (!load) {\n            if (!support) throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\n            load = ()=>Promise.resolve(support);\n        }\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s)=>s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\n    }\n    /**\n    Look for a language in the given array of descriptions that\n    matches the filename. Will first match\n    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n    and return the first language that matches.\n    */ static matchFilename(descs, filename) {\n        for (let d of descs)if (d.filename && d.filename.test(filename)) return d;\n        let ext = /\\.([^.]+)$/.exec(filename);\n        if (ext) {\n            for (let d of descs)if (d.extensions.indexOf(ext[1]) > -1) return d;\n        }\n        return null;\n    }\n    /**\n    Look for a language whose name or alias matches the the given\n    name (case-insensitively). If `fuzzy` is true, and no direct\n    matchs is found, this'll also search for a language whose name\n    or alias occurs in the string (for names shorter than three\n    characters, only when surrounded by non-word characters).\n    */ static matchLanguageName(descs, name, fuzzy = true) {\n        name = name.toLowerCase();\n        for (let d of descs)if (d.alias.some((a)=>a == name)) return d;\n        if (fuzzy) for (let d of descs)for (let a of d.alias){\n            let found = name.indexOf(a);\n            if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length]))) return d;\n        }\n        return null;\n    }\n}\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth, as a column number (see\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\nline. A return value of `null` indicates no indentation can be\ndetermined, and the line should inherit the indentation of the one\nabove it. A return value of `undefined` defers to the next indent\nservice.\n*/ const indentService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens. Should\nbe a string consisting either entirely of the same whitespace\ncharacter. When not set, this defaults to 2 spaces.\n*/ const indentUnit = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>{\n        if (!values.length) return \"  \";\n        let unit = values[0];\n        if (!unit || /\\S/.test(unit) || Array.from(unit).some((e)=>e != unit[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return unit;\n    }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/ function getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/ function indentString(state, cols) {\n    let result = \"\", ts = state.tabSize, ch = state.facet(indentUnit)[0];\n    if (ch == \"\t\") {\n        while(cols >= ts){\n            result += \"\t\";\n            cols -= ts;\n        }\n        ch = \" \";\n    }\n    for(let i = 0; i < cols; i++)result += ch;\n    return result;\n}\n/**\nGet the indentation, as a column number, at the given position.\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\nthat are registered, and if none of those return an indentation,\nthis will check the syntax tree for the [indent node\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\nnumber when an indentation could be determined, and null\notherwise.\n*/ function getIndentation(context, pos) {\n    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState) context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)){\n        let result = service(context, pos);\n        if (result !== undefined) return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nCreate a change set that auto-indents all lines touched by the\ngiven document range.\n*/ function indentRange(state, from, to) {\n    let updated = Object.create(null);\n    let context = new IndentContext(state, {\n        overrideIndentation: (start)=>{\n            var _a;\n            return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;\n        }\n    });\n    let changes = [];\n    for(let pos = from; pos <= to;){\n        let line = state.doc.lineAt(pos);\n        pos = line.to + 1;\n        let indent = getIndentation(context, line.from);\n        if (indent == null) continue;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    }\n    return state.changes(changes);\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/ class IndentContext {\n    /**\n    Create an indent context.\n    */ constructor(/**\n    The editor state.\n    */ state, /**\n    @internal\n    */ options = {}){\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /**\n    Get a description of the line at the given position, taking\n    [simulated line\n    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    into account. If there is such a break at `pos`, the `bias`\n    argument determines whether the part of the line line before or\n    after the break is used.\n    */ lineAt(pos, bias = 1) {\n        let line = this.state.doc.lineAt(pos);\n        let { simulateBreak, simulateDoubleBreak } = this.options;\n        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n            if (simulateDoubleBreak && simulateBreak == pos) return {\n                text: \"\",\n                from: pos\n            };\n            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {\n                text: line.text.slice(simulateBreak - line.from),\n                from: simulateBreak\n            };\n            else return {\n                text: line.text.slice(0, simulateBreak - line.from),\n                from: line.from\n            };\n        }\n        return line;\n    }\n    /**\n    Get the text directly after `pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ textAfterPos(pos, bias = 1) {\n        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return \"\";\n        let { text, from } = this.lineAt(pos, bias);\n        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n    }\n    /**\n    Find the column for the given position.\n    */ column(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let result = this.countColumn(text, pos - from);\n        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n        if (override > -1) result += override - this.countColumn(text, text.search(/\\S|$/));\n        return result;\n    }\n    /**\n    Find the column position (taking tabs into account) of the given\n    position in the given string.\n    */ countColumn(line, pos = line.length) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n    }\n    /**\n    Find the indentation column of the line at the given point.\n    */ lineIndent(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let override = this.options.overrideIndentation;\n        if (override) {\n            let overriden = override(from);\n            if (overriden > -1) return overriden;\n        }\n        return this.countColumn(text, text.search(/\\S|$/));\n    }\n    /**\n    Returns the [simulated line\n    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    for this context, if any.\n    */ get simulatedBreak() {\n        return this.options.simulateBreak || null;\n    }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number (see also\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\nindicates that no definitive indentation can be determined.\n*/ const indentNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    let stack = ast.resolveStack(pos);\n    let inner = stack.node.enterUnfinishedNodesBefore(pos);\n    if (inner != stack.node) {\n        let add = [];\n        for(let cur = inner; cur != stack.node; cur = cur.parent)add.push(cur);\n        for(let i = add.length - 1; i >= 0; i--)stack = {\n            node: add[i],\n            next: stack\n        };\n    }\n    return indentFor(stack, cx, pos);\n}\nfunction indentFor(stack, cx, pos) {\n    for(let cur = stack; cur; cur = cur.next){\n        let strategy = indentStrategy(cur.node);\n        if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur));\n    }\n    return 0;\n}\nfunction ignoreClosed(cx) {\n    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy) return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return (cx)=>delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() {\n    return 0;\n}\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions registered on syntax nodes.\n*/ class TreeIndentContext extends IndentContext {\n    constructor(base, /**\n    The position at which indentation is being computed.\n    */ pos, /**\n    @internal\n    */ context){\n        super(base.state, base.options);\n        this.base = base;\n        this.pos = pos;\n        this.context = context;\n    }\n    /**\n    The syntax tree node to which the indentation strategy\n    applies.\n    */ get node() {\n        return this.context.node;\n    }\n    /**\n    @internal\n    */ static create(base, pos, context) {\n        return new TreeIndentContext(base, pos, context);\n    }\n    /**\n    Get the text directly after `this.pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /**\n    Get the indentation at the reference line for `this.node`, which\n    is the line on which it starts, unless there is a node that is\n    _not_ a parent of this node covering the start of that line. If\n    so, the line at the start of that node is tried, again skipping\n    on if it is covered by another such node.\n    */ get baseIndent() {\n        return this.baseIndentFor(this.node);\n    }\n    /**\n    Get the indentation for the reference line of the given node\n    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).\n    */ baseIndentFor(node) {\n        let line = this.state.doc.lineAt(node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for(;;){\n            let atBreak = node.resolve(line.from);\n            while(atBreak.parent && atBreak.parent.from == atBreak.from)atBreak = atBreak.parent;\n            if (isParent(atBreak, node)) break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line.from);\n    }\n    /**\n    Continue looking for indentations in the node's parent nodes,\n    and return the result of that.\n    */ continue() {\n        return indentFor(this.context.next, this.base, this.pos);\n    }\n}\nfunction isParent(parent, of) {\n    for(let cur = of; cur; cur = cur.parent)if (parent == cur) return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken) return null;\n    let sim = context.options.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for(let pos = openToken.to;;){\n        let next = tree.childAfter(pos);\n        if (!next || next == last) return null;\n        if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;\n        pos = next.to;\n    }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/ function delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context)=>delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/ const flatIndent = (context)=>context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/ function continuedIndent({ except, units = 1 } = {}) {\n    return (context)=>{\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/ function indentOnInput() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of((tr)=>{\n        if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\")) return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n        if (!rules.length) return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond) return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some((r)=>r.test(lineStart))) return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges){\n            let line = state.doc.lineAt(head);\n            if (line.from == last) continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null) continue;\n            let cur = /^\\s*/.exec(line.text)[0];\n            let norm = indentString(state, indent);\n            if (cur != norm) changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n        return changes.length ? [\n            tr,\n            {\n                changes,\n                sequential: true\n            }\n        ] : tr;\n    });\n}\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/ const foldService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/ const foldNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/ function foldInside(node) {\n    let first = node.firstChild, last = node.lastChild;\n    return first && first.to < last.from ? {\n        from: first.to,\n        to: last.type.isError ? node.to : last.from\n    } : null;\n}\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length < end) return null;\n    let stack = tree.resolveStack(end, 1);\n    let found = null;\n    for(let iter = stack; iter; iter = iter.next){\n        let cur = iter.node;\n        if (cur.to <= end || cur.from > end) continue;\n        if (found && cur.from < start) break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n        }\n    }\n    return found;\n}\nfunction isUnfinished(node) {\n    let ch = node.lastChild;\n    return ch && ch.to == node.to && ch.type.isError;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/ function foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)){\n        let result = service(state, lineStart, lineEnd);\n        if (result) return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : {\n        from,\n        to\n    };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\n*/ const foldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/ const unfoldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges){\n        if (lines.some((l)=>l.from <= head && l.to >= head)) continue;\n        lines.push(view.lineBlockAt(head));\n    }\n    return lines;\n}\n/**\nThe state field that stores the folded ranges (as a [decoration\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\nstate.\n*/ const foldState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (folded, tr) {\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects){\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {\n                let { preparePlaceholder } = tr.state.facet(foldConfig);\n                let widget = !preparePlaceholder ? foldWidget : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n                    widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value))\n                });\n                folded = folded.update({\n                    add: [\n                        widget.range(e.value.from, e.value.to)\n                    ]\n                });\n            } else if (e.is(unfoldEffect)) {\n                folded = folded.update({\n                    filter: (from, to)=>e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from,\n                    filterTo: e.value.to\n                });\n            }\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) {\n            let onSelection = false, { head } = tr.selection.main;\n            folded.between(head, head, (a, b)=>{\n                if (a < head && b > head) onSelection = true;\n            });\n            if (onSelection) folded = folded.update({\n                filterFrom: head,\n                filterTo: head,\n                filter: (a, b)=>b <= head || a >= head\n            });\n        }\n        return folded;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\n    toJSON (folded, state) {\n        let ranges = [];\n        folded.between(0, state.doc.length, (from, to)=>{\n            ranges.push(from, to);\n        });\n        return ranges;\n    },\n    fromJSON (value) {\n        if (!Array.isArray(value) || value.length % 2) throw new RangeError(\"Invalid JSON for fold state\");\n        let ranges = [];\n        for(let i = 0; i < value.length;){\n            let from = value[i++], to = value[i++];\n            if (typeof from != \"number\" || typeof to != \"number\") throw new RangeError(\"Invalid JSON for fold state\");\n            ranges.push(foldWidget.range(from, to));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\n    }\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\nin the given state.\n*/ function foldedRanges(state) {\n    return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n}\nfunction findFold(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to)=>{\n        if (!found || found.from > from) found = {\n            from,\n            to\n        };\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b)=>{\n        if (a == from && b == to) found = true;\n    });\n    return found;\n}\nfunction maybeEnable(state, other) {\n    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/ const foldCode = (view)=>{\n    for (let line of selectedLines(view)){\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({\n                effects: maybeEnable(view.state, [\n                    foldEffect.of(range),\n                    announceFold(view, range)\n                ])\n            });\n            return true;\n        }\n    }\n    return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/ const unfoldCode = (view)=>{\n    if (!view.state.field(foldState, false)) return false;\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    }\n    if (effects.length) view.dispatch({\n        effects\n    });\n    return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges. Note that, in most cases,\nfolding information will depend on the [syntax\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\nreliably when the document hasn't been fully parsed (either\nbecause the editor state was only just initialized, or because the\ndocument is so big that the parser decided not to parse it\nentirely).\n*/ const foldAll = (view)=>{\n    let { state } = view, effects = [];\n    for(let pos = 0; pos < state.doc.length;){\n        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);\n        if (range) effects.push(foldEffect.of(range));\n        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n    }\n    if (effects.length) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/ const unfoldAll = (view)=>{\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size) return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to)=>{\n        effects.push(unfoldEffect.of({\n            from,\n            to\n        }));\n    });\n    view.dispatch({\n        effects\n    });\n    return true;\n};\n// Find the foldable region containing the given line, if one exists\nfunction foldableContainer(view, lineBlock) {\n    // Look backwards through line blocks until we find a foldable region that\n    // intersects with the line\n    for(let line = lineBlock;;){\n        let foldableRegion = foldable(view.state, line.from, line.to);\n        if (foldableRegion && foldableRegion.to > lineBlock.from) return foldableRegion;\n        if (!line.from) return null;\n        line = view.lineBlockAt(line.from - 1);\n    }\n}\n/**\nToggle folding at cursors. Unfolds if there is an existing fold\nstarting in that line, tries to find a foldable range around it\notherwise.\n*/ const toggleFold = (view)=>{\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) {\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n        } else {\n            let foldRange = foldableContainer(view, line);\n            if (foldRange) effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));\n        }\n    }\n    if (effects.length > 0) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\n*/ const foldKeymap = [\n    {\n        key: \"Ctrl-Shift-[\",\n        mac: \"Cmd-Alt-[\",\n        run: foldCode\n    },\n    {\n        key: \"Ctrl-Shift-]\",\n        mac: \"Cmd-Alt-]\",\n        run: unfoldCode\n    },\n    {\n        key: \"Ctrl-Alt-[\",\n        run: foldAll\n    },\n    {\n        key: \"Ctrl-Alt-]\",\n        run: unfoldAll\n    }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    preparePlaceholder: null,\n    placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig);\n    }\n});\n/**\nCreate an extension that configures code folding.\n*/ function codeFolding(config) {\n    let result = [\n        foldState,\n        baseTheme$1\n    ];\n    if (config) result.push(foldConfig.of(config));\n    return result;\n}\nfunction widgetToDOM(view, prepared) {\n    let { state } = view, conf = state.facet(foldConfig);\n    let onclick = (event)=>{\n        let line = view.lineBlockAt(view.posAtDOM(event.target));\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) view.dispatch({\n            effects: unfoldEffect.of(folded)\n        });\n        event.preventDefault();\n    };\n    if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);\n    let element = document.createElement(\"span\");\n    element.textContent = conf.placeholderText;\n    element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n    element.title = state.phrase(\"unfold\");\n    element.className = \"cm-foldPlaceholder\";\n    element.onclick = onclick;\n    return element;\n}\nconst foldWidget = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n        toDOM(view) {\n            return widgetToDOM(view, null);\n        }\n    }\n});\nclass PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    eq(other) {\n        return this.value == other.value;\n    }\n    toDOM(view) {\n        return widgetToDOM(view, this.value);\n    }\n}\nconst foldGutterDefaults = {\n    openText: \"⌄\",\n    closedText: \"›\",\n    markerDOM: null,\n    domEventHandlers: {},\n    foldingChanged: ()=>false\n};\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n    constructor(config, open){\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) {\n        return this.config == other.config && this.open == other.open;\n    }\n    toDOM(view) {\n        if (this.config.markerDOM) return this.config.markerDOM(this.open);\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/ function foldGutter(config = {}) {\n    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n        constructor(view){\n            this.from = view.viewport.from;\n            this.markers = this.buildMarkers(view);\n        }\n        update(update) {\n            if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);\n        }\n        buildMarkers(view) {\n            let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n            for (let line of view.viewportLineBlocks){\n                let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n                if (mark) builder.add(line.from, line.from, mark);\n            }\n            return builder.finish();\n        }\n    });\n    let { domEventHandlers } = fullConfig;\n    return [\n        markers,\n        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n            class: \"cm-foldGutter\",\n            markers (view) {\n                var _a;\n                return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n            },\n            initialSpacer () {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {\n                click: (view, line, event)=>{\n                    if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;\n                    let folded = findFold(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({\n                            effects: unfoldEffect.of(folded)\n                        });\n                        return true;\n                    }\n                    let range = foldable(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({\n                            effects: foldEffect.of(range)\n                        });\n                        return true;\n                    }\n                    return false;\n                }\n            })\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \".cm-foldGutter span\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\n*/ class HighlightStyle {\n    constructor(/**\n    The tag styles used to create this highlight style.\n    */ specs, options){\n        this.specs = specs;\n        let modSpec;\n        function def(spec) {\n            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\n            (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n            return cls;\n        }\n        const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\n        const scopeOpt = options.scope;\n        this.scope = scopeOpt instanceof Language ? (type)=>type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type)=>type == scopeOpt : undefined;\n        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map((style)=>({\n                tag: style.tag,\n                class: style.class || def(Object.assign({}, style, {\n                    tag: null\n                }))\n            })), {\n            all\n        }).style;\n        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\n        this.themeType = options.themeType;\n    }\n    /**\n    Create a highlighter style that associates the given styles to\n    the given tags. The specs must be objects that hold a style tag\n    or array of tags in their `tag` property, and either a single\n    `class` property providing a static CSS class (for highlighter\n    that rely on external styling), or a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    set of CSS properties (which define the styling for those tags).\n    \n    The CSS rules created for a highlighter will be emitted in the\n    order of the spec's properties. That means that for elements that\n    have multiple tags associated with them, styles defined further\n    down in the list will have a higher CSS precedence than styles\n    defined earlier.\n    */ static define(specs, options) {\n        return new HighlightStyle(specs, options || {});\n    }\n}\nconst highlighterFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst fallbackHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return values.length ? [\n            values[0]\n        ] : null;\n    }\n});\nfunction getHighlighters(state) {\n    let main = state.facet(highlighterFacet);\n    return main.length ? main : state.facet(fallbackHighlighter);\n}\n/**\nWrap a highlighter in an editor extension that uses it to apply\nsyntax highlighting to the editor content.\n\nWhen multiple (non-fallback) styles are provided, the styling\napplied is the union of the classes they emit.\n*/ function syntaxHighlighting(highlighter, options) {\n    let ext = [\n        treeHighlighter\n    ], themeType;\n    if (highlighter instanceof HighlightStyle) {\n        if (highlighter.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\n        themeType = highlighter.themeType;\n    }\n    if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));\n    else if (themeType) ext.push(highlighterFacet.computeN([\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme\n    ], (state)=>{\n        return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [\n            highlighter\n        ] : [];\n    }));\n    else ext.push(highlighterFacet.of(highlighter));\n    return ext;\n}\n/**\nReturns the CSS classes (if any) that the highlighters active in\nthe state would assign to the given style\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\n(optional) language\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\n*/ function highlightingFor(state, tags, scope) {\n    let highlighters = getHighlighters(state);\n    let result = null;\n    if (highlighters) for (let highlighter of highlighters){\n        if (!highlighter.scope || scope && highlighter.scope(scope)) {\n            let cls = highlighter.style(tags);\n            if (cls) result = result ? result + \" \" + cls : cls;\n        }\n    }\n    return result;\n}\nclass TreeHighlighter {\n    constructor(view){\n        this.markCache = Object.create(null);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.buildDeco(view, getHighlighters(view.state));\n        this.decoratedTo = view.viewport.to;\n    }\n    update(update) {\n        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);\n        let styleChange = highlighters != getHighlighters(update.startState);\n        let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);\n        if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {\n            this.decorations = this.decorations.map(update.changes);\n            this.decoratedTo = decoratedToMapped;\n        } else if (tree != this.tree || update.viewportChanged || styleChange) {\n            this.tree = tree;\n            this.decorations = this.buildDeco(update.view, highlighters);\n            this.decoratedTo = viewport.to;\n        }\n    }\n    buildDeco(view, highlighters) {\n        if (!highlighters || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges){\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style)=>{\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n                    class: style\n                })));\n            }, from, to);\n        }\n        return builder.finish();\n    }\n}\nconst treeHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\n    decorations: (v)=>v.decorations\n}));\n/**\nA default highlight style (works well with light themes).\n*/ const defaultHighlightStyle = /*@__PURE__*/ HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n        color: \"#404740\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\n        textDecoration: \"underline\",\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n        color: \"#708\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName\n        ],\n        color: \"#219\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted\n        ],\n        color: \"#164\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted\n        ],\n        color: \"#a11\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)\n        ],\n        color: \"#e40\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#00f\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#30a\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace\n        ],\n        color: \"#085\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n        color: \"#167\"\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName\n        ],\n        color: \"#256\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n        color: \"#00c\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n        color: \"#940\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\n        color: \"#f00\"\n    }\n]);\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \"&.cm-focused .cm-matchingBracket\": {\n        backgroundColor: \"#328c8252\"\n    },\n    \"&.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bb555544\"\n    }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist,\n            renderMatch: defaultRenderMatch\n        });\n    }\n});\nconst matchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-matchingBracket\"\n}), nonmatchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-nonmatchingBracket\"\n});\nfunction defaultRenderMatch(match) {\n    let decorations = [];\n    let mark = match.matched ? matchingMark : nonmatchingMark;\n    decorations.push(mark.range(match.start.from, match.start.to));\n    if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n    return decorations;\n}\nconst bracketMatchingState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (deco, tr) {\n        if (!tr.docChanged && !tr.selection) return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges){\n            if (!range.empty) continue;\n            let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n            if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/ function bracketMatching(config = {}) {\n    return [\n        bracketMatchingConfig.of(config),\n        bracketMatchingUnique\n    ];\n}\n/**\nWhen larger syntax nodes, such as HTML tags, are marked as\nopening/closing, it can be a bit messy to treat the whole node as\na matchable bracket. This node prop allows you to define, for such\na node, a ‘handle’—the part of the node that is highlighted, and\nthat the cursor must be on to activate highlighting in the first\nplace.\n*/ const bracketMatchingHandle = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n    if (byProp) return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [\n            brackets[index + dir]\n        ];\n    }\n    return null;\n}\nfunction findHandle(node) {\n    let hasHandle = node.type.prop(bracketMatchingHandle);\n    return hasHandle ? hasHandle(node.node) : node;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/ function matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);\n    for(let cur = node; cur; cur = cur.parent){\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to) {\n            let handle = findHandle(cur);\n            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);\n        }\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {\n    let parent = token.parent, firstToken = {\n        from: handle.from,\n        to: handle.to\n    };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n            if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                let endHandle = findHandle(cursor);\n                return {\n                    start: firstToken,\n                    end: endHandle ? {\n                        from: endHandle.from,\n                        to: endHandle.to\n                    } : undefined,\n                    matched: true\n                };\n            } else if (matchingNodes(cursor.type, dir, brackets)) {\n                depth++;\n            } else if (matchingNodes(cursor.type, -dir, brackets)) {\n                if (depth == 0) {\n                    let endHandle = findHandle(cursor);\n                    return {\n                        start: firstToken,\n                        end: endHandle && endHandle.from < endHandle.to ? {\n                            from: endHandle.from,\n                            to: endHandle.to\n                        } : undefined,\n                        matched: false\n                    };\n                }\n                depth--;\n            }\n        }\n    }while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return {\n        start: firstToken,\n        matched: false\n    };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n    let startToken = {\n        from: dir < 0 ? pos - 1 : pos,\n        to: dir > 0 ? pos + 1 : pos\n    };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for(let distance = 0; !iter.next().done && distance <= maxScanDistance;){\n        let text = iter.value;\n        if (dir < 0) distance += text.length;\n        let basePos = pos + distance * dir;\n        for(let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir){\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType) continue;\n            if (found % 2 == 0 == dir > 0) {\n                depth++;\n            } else if (depth == 1) {\n                return {\n                    start: startToken,\n                    end: {\n                        from: basePos + pos,\n                        to: basePos + pos + 1\n                    },\n                    matched: found >> 1 == bracket >> 1\n                };\n            } else {\n                depth--;\n            }\n        }\n        if (dir > 0) distance += text.length;\n    }\n    return iter.done ? {\n        start: startToken,\n        matched: false\n    } : null;\n}\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1) end = string.length;\n    }\n    let n = startValue;\n    for(let i = startIndex; i < end; i++){\n        if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;\n        else n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/ class StringStream {\n    /**\n    Create a stream.\n    */ constructor(/**\n    The line.\n    */ string, tabSize, /**\n    The current indent unit size.\n    */ indentUnit, overrideIndent){\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        this.overrideIndent = overrideIndent;\n        /**\n        The current position on the line.\n        */ this.pos = 0;\n        /**\n        The start position of the current token.\n        */ this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */ eol() {\n        return this.pos >= this.string.length;\n    }\n    /**\n    True if we are at the start of the line.\n    */ sol() {\n        return this.pos == 0;\n    }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */ peek() {\n        return this.string.charAt(this.pos) || undefined;\n    }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */ next() {\n        if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */ eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\") ok = ch == match;\n        else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */ eatWhile(match) {\n        let start = this.pos;\n        while(this.eat(match)){}\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */ eatSpace() {\n        let start = this.pos;\n        while(/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */ skipToEnd() {\n        this.pos = this.string.length;\n    }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */ skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */ backUp(n) {\n        this.pos -= n;\n    }\n    /**\n    Get the column position at `this.pos`.\n    */ column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */ indentation() {\n        var _a;\n        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */ match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str)=>caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false) this.pos += pattern.length;\n                return true;\n            } else return null;\n        } else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0) return null;\n            if (match && consume !== false) this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */ current() {\n        return this.string.slice(this.start, this.pos);\n    }\n}\nfunction fullParser(spec) {\n    return {\n        name: spec.name || \"\",\n        token: spec.token,\n        blankLine: spec.blankLine || (()=>{}),\n        startState: spec.startState || (()=>true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (()=>null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\") return state;\n    let newState = {};\n    for(let prop in state){\n        let val = state[prop];\n        newState[prop] = val instanceof Array ? val.slice() : val;\n    }\n    return newState;\n}\nconst IndentedFrom = /*@__PURE__*/ new WeakMap();\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\n*/ class StreamLanguage extends Language {\n    constructor(parser){\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, [\n            indentService.of((cx, pos)=>this.getIndent(cx, pos))\n        ], parser.name);\n        this.topNode = docID(data);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n            perNode: true\n        });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    /**\n    Define a stream language.\n    */ static define(spec) {\n        return new StreamLanguage(spec);\n    }\n    getIndent(cx, pos) {\n        let tree = syntaxTree(cx.state), at = tree.resolve(pos);\n        while(at && at.type != this.topNode)at = at.parent;\n        if (!at) return null;\n        let from = undefined;\n        let { overrideIndentation } = cx.options;\n        if (overrideIndentation) {\n            from = IndentedFrom.get(cx.state);\n            if (from != null && from < pos - 1e4) from = undefined;\n        }\n        let start = findState(this, tree, 0, at.from, from !== null && from !== void 0 ? from : pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        } else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = 0;\n        }\n        if (pos - statePos > 10000 /* C.MaxIndentScanDist */ ) return null;\n        while(statePos < pos){\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);\n            if (line.length) {\n                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);\n                while(stream.pos < end - line.from)readToken(this.streamParser.token, stream, state);\n            } else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == pos) break;\n            statePos = line.to + 1;\n        }\n        let line = cx.lineAt(pos);\n        if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(line.text)[1], cx);\n    }\n    get allowsNesting() {\n        return false;\n    }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state) return {\n        state: lang.streamParser.copyState(state),\n        pos: off + tree.length\n    };\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found) return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length) return tree;\n    if (!inside && tree.type == lang.topNode) inside = true;\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n            return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n    for (let f of fragments){\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n            state: found.state,\n            tree\n        };\n    }\n    return {\n        state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),\n        tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty\n    };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges){\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for(let i = 0; i < tree.children.length; i++){\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */ ) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n        this.moveRangeIndex();\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */ );\n        if (context) end = Math.min(end, context.viewport.to);\n        while(this.parsedPos < end)this.parseLine(context);\n        if (this.chunkStart < this.parsedPos) this.finishChunk();\n        if (this.parsedPos >= parseEnd) return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1) chunk = chunk.slice(0, eol);\n        } else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for(let index = this.rangeIndex;;){\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end) break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length) break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return {\n            line,\n            end\n        };\n    }\n    skipGapsTo(pos, offset, side) {\n        for(;;){\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos) break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    moveRangeIndex() {\n        while(this.ranges[this.rangeIndex].to < this.parsedPos)this.rangeIndex++;\n    }\n    emitToken(id, from, to, size, offset) {\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        } else {\n            while(!stream.eol()){\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n                if (stream.start > 10000 /* C.MaxLineLength */ ) break;\n            }\n        }\n        this.parsedPos = end;\n        this.moveRangeIndex();\n        if (this.parsedPos < this.to) this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* C.ChunkSize */ ,\n            reused: this.chunkReused\n        });\n        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [\n            [\n                this.lang.stateAfter,\n                this.lang.streamParser.copyState(this.state)\n            ]\n        ]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for(let i = 0; i < 10; i++){\n        let result = token(stream, state);\n        if (stream.pos > stream.start) return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/ Object.create(null);\nconst typeArray = [\n    _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none\n];\nconst nodeSet = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nconst warned = [];\n// Cache of node types by name and tags\nconst byTag = /*@__PURE__*/ Object.create(null);\nconst defaultTable = /*@__PURE__*/ Object.create(null);\nfor (let [legacyName, name] of [\n    [\n        \"variable\",\n        \"variableName\"\n    ],\n    [\n        \"variable-2\",\n        \"variableName.special\"\n    ],\n    [\n        \"string-2\",\n        \"string.special\"\n    ],\n    [\n        \"def\",\n        \"variableName.definition\"\n    ],\n    [\n        \"tag\",\n        \"tagName\"\n    ],\n    [\n        \"attribute\",\n        \"attributeName\"\n    ],\n    [\n        \"type\",\n        \"typeName\"\n    ],\n    [\n        \"builtin\",\n        \"variableName.standard\"\n    ],\n    [\n        \"qualifier\",\n        \"modifier\"\n    ],\n    [\n        \"error\",\n        \"invalid\"\n    ],\n    [\n        \"header\",\n        \"heading\"\n    ],\n    [\n        \"property\",\n        \"propertyName\"\n    ]\n])defaultTable[legacyName] = /*@__PURE__*/ createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra){\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = /*@__PURE__*/ new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1) return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tags$1 = [];\n    for (let name of tagStr.split(\" \")){\n        let found = [];\n        for (let part of name.split(\".\")){\n            let value = extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part];\n            if (!value) {\n                warnForPart(part, `Unknown highlighting tag ${part}`);\n            } else if (typeof value == \"function\") {\n                if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);\n                else found = found.map(value);\n            } else {\n                if (found.length) warnForPart(part, `Tag ${part} used as modifier`);\n                else found = Array.isArray(value) ? value : [\n                    value\n                ];\n            }\n        }\n        for (let tag of found)tags$1.push(tag);\n    }\n    if (!tags$1.length) return 0;\n    let name = tagStr.replace(/ /g, \"_\"), key = name + \" \" + tags$1.map((t)=>t.id);\n    let known = byTag[key];\n    if (known) return known.id;\n    let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n                [name]: tags$1\n            })\n        ]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data) {\n    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name: \"Document\",\n        props: [\n            languageDataProp.add(()=>data)\n        ],\n        top: true\n    });\n    typeArray.push(type);\n    return type;\n}\nfunction buildForLine(line) {\n    return line.length <= 4096 && /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/.test(line);\n}\nfunction textHasRTL(text) {\n    for(let i = text.iter(); !i.next().done;)if (buildForLine(i.value)) return true;\n    return false;\n}\nfunction changeAddsRTL(change) {\n    let added = false;\n    change.iterChanges((fA, tA, fB, tB, ins)=>{\n        if (!added && textHasRTL(ins)) added = true;\n    });\n    return added;\n}\nconst alwaysIsolate = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nMake sure nodes\n[marked](https://lezer.codemirror.net/docs/ref/#common.NodeProp^isolate)\nas isolating for bidirectional text are rendered in a way that\nisolates them from the surrounding text.\n*/ function bidiIsolates(options = {}) {\n    let extensions = [\n        isolateMarks\n    ];\n    if (options.alwaysIsolate) extensions.push(alwaysIsolate.of(true));\n    return extensions;\n}\nconst isolateMarks = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.always = view.state.facet(alwaysIsolate) || view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n        this.hasRTL = !this.always && textHasRTL(view.state.doc);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    }\n    update(update) {\n        let always = update.state.facet(alwaysIsolate) || update.view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || update.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n        if (!always && !this.hasRTL && changeAddsRTL(update.changes)) this.hasRTL = true;\n        if (!always && !this.hasRTL) return;\n        let tree = syntaxTree(update.state);\n        if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {\n            this.tree = tree;\n            this.always = always;\n            this.decorations = buildDeco(update.view, tree, always);\n        }\n    }\n}, {\n    provide: (plugin)=>{\n        function access(view) {\n            var _a, _b;\n            return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        }\n        return [\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.outerDecorations.of(access),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.bidiIsolatedRanges.of(access))\n        ];\n    }\n});\nfunction buildDeco(view, tree, always) {\n    let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n    let ranges = view.visibleRanges;\n    if (!always) ranges = clipRTLLines(ranges, view.state.doc);\n    for (let { from, to } of ranges){\n        tree.iterate({\n            enter: (node)=>{\n                let iso = node.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.isolate);\n                if (iso) deco.add(node.from, node.to, marks[iso]);\n            },\n            from,\n            to\n        });\n    }\n    return deco.finish();\n}\nfunction clipRTLLines(ranges, doc) {\n    let cur = doc.iter(), pos = 0, result = [], last = null;\n    for (let { from, to } of ranges){\n        if (from != pos) {\n            if (pos < from) cur.next(from - pos);\n            pos = from;\n        }\n        for(;;){\n            let start = pos, end = pos + cur.value.length;\n            if (!cur.lineBreak && buildForLine(cur.value)) {\n                if (last && last.to > start - 10) last.to = Math.min(to, end);\n                else result.push(last = {\n                    from: start,\n                    to: Math.min(to, end)\n                });\n            }\n            if (pos >= to) break;\n            pos = end;\n            cur.next();\n        }\n    }\n    return result;\n}\nconst marks = {\n    rtl: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"rtl\"\n        },\n        bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.RTL\n    }),\n    ltr: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"ltr\"\n        },\n        bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR\n    }),\n    auto: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"auto\"\n        },\n        bidiIsolate: null\n    })\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRztBQUMyQztBQUNaO0FBQy9DO0FBQzFDO0FBRXhDLElBQUk2QjtBQUNKOzs7QUFHQSxHQUNBLE1BQU1DLG1CQUFtQixXQUFXLEdBQUUsSUFBSTlCLG1EQUFRQTtBQUNsRDs7Ozs7OztBQU9BLEdBQ0EsU0FBUytCLG9CQUFvQkMsUUFBUTtJQUNqQyxPQUFPdkIsb0RBQUtBLENBQUN3QixNQUFNLENBQUM7UUFDaEJDLFNBQVNGLFdBQVdHLENBQUFBLFNBQVVBLE9BQU9DLE1BQU0sQ0FBQ0osWUFBWUs7SUFDNUQ7QUFDSjtBQUNBOzs7QUFHQSxHQUNBLE1BQU1DLGtCQUFrQixXQUFXLEdBQUUsSUFBSXRDLG1EQUFRQTtBQUNqRDs7Ozs7Ozs7QUFRQSxHQUNBLE1BQU11QztJQUNGOzs7Ozs7SUFNQSxHQUNBQyxZQUNBOzs7SUFHQSxHQUNBQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUUsRUFDbEM7O0lBRUEsR0FDQUMsT0FBTyxFQUFFLENBQUU7UUFDUCxJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNHLElBQUksR0FBR0E7UUFDWiwyREFBMkQ7UUFDM0QseURBQXlEO1FBQ3pELDZCQUE2QjtRQUM3QixJQUFJLENBQUNsQywwREFBV0EsQ0FBQ21DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDLFNBQ3RDQyxPQUFPQyxjQUFjLENBQUN0QywwREFBV0EsQ0FBQ21DLFNBQVMsRUFBRSxRQUFRO1lBQUVJO2dCQUFRLE9BQU9DLFdBQVcsSUFBSTtZQUFHO1FBQUU7UUFDOUYsSUFBSSxDQUFDUixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUyxTQUFTLEdBQUc7WUFDYkMsU0FBU0MsRUFBRSxDQUFDLElBQUk7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UUFBTTtRQUFHMkssYUFBYW5zQix1REFBU0EsQ0FBQ29zQixHQUFHO0lBQUM7SUFDN0hDLEtBQUssV0FBVyxHQUFFenNCLHdEQUFVQSxDQUFDNmIsSUFBSSxDQUFDO1FBQUVFLE9BQU87UUFBVXNRLFdBQVc7UUFBTUMsWUFBWTtZQUFFMUssS0FBSztRQUFNO1FBQUcySyxhQUFhbnNCLHVEQUFTQSxDQUFDa3JCLEdBQUc7SUFBQztJQUM3SG9CLE1BQU0sV0FBVyxHQUFFMXNCLHdEQUFVQSxDQUFDNmIsSUFBSSxDQUFDO1FBQUVFLE9BQU87UUFBVXNRLFdBQVc7UUFBTUMsWUFBWTtZQUFFMUssS0FBSztRQUFPO1FBQUcySyxhQUFhO0lBQUs7QUFDMUg7QUFFd3lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcz9kNzNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wLCBJdGVyTW9kZSwgVHJlZSwgVHJlZUZyYWdtZW50LCBQYXJzZXIsIE5vZGVUeXBlLCBOb2RlU2V0IH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgRmFjZXQsIEVkaXRvclN0YXRlLCBjb3VudENvbHVtbiwgY29tYmluZUNvbmZpZywgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUHJlYyB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IFZpZXdQbHVnaW4sIGxvZ0V4Y2VwdGlvbiwgRWRpdG9yVmlldywgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwgZ3V0dGVyLCBHdXR0ZXJNYXJrZXIsIERpcmVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgdGFncywgdGFnSGlnaGxpZ2h0ZXIsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuXG52YXIgX2E7XG4vKipcbk5vZGUgcHJvcCBzdG9yZWQgaW4gYSBwYXJzZXIncyB0b3Agc3ludGF4IG5vZGUgdG8gcHJvdmlkZSB0aGVcbmZhY2V0IHRoYXQgc3RvcmVzIGxhbmd1YWdlLXNwZWNpZmljIGRhdGEgZm9yIHRoYXQgbGFuZ3VhZ2UuXG4qL1xuY29uc3QgbGFuZ3VhZ2VEYXRhUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRvIGRlZmluZSBhIGZhY2V0ICh0byBiZSBhZGRlZCB0byB0aGUgdG9wIHN5bnRheFxubm9kZShzKSBmb3IgYSBsYW5ndWFnZSB2aWFcbltgbGFuZ3VhZ2VEYXRhUHJvcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkpLCB0aGF0IHdpbGwgYmVcbnVzZWQgdG8gYXNzb2NpYXRlIGxhbmd1YWdlIGRhdGEgd2l0aCB0aGUgbGFuZ3VhZ2UuIFlvdVxucHJvYmFibHkgb25seSBuZWVkIHRoaXMgd2hlbiBzdWJjbGFzc2luZ1xuW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLlxuKi9cbmZ1bmN0aW9uIGRlZmluZUxhbmd1YWdlRmFjZXQoYmFzZURhdGEpIHtcbiAgICByZXR1cm4gRmFjZXQuZGVmaW5lKHtcbiAgICAgICAgY29tYmluZTogYmFzZURhdGEgPyB2YWx1ZXMgPT4gdmFsdWVzLmNvbmNhdChiYXNlRGF0YSkgOiB1bmRlZmluZWRcbiAgICB9KTtcbn1cbi8qKlxuU3ludGF4IG5vZGUgcHJvcCB1c2VkIHRvIHJlZ2lzdGVyIHN1Ymxhbmd1YWdlcy4gU2hvdWxkIGJlIGFkZGVkIHRvXG50aGUgdG9wIGxldmVsIG5vZGUgdHlwZSBmb3IgdGhlIGxhbmd1YWdlLlxuKi9cbmNvbnN0IHN1Ymxhbmd1YWdlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuQSBsYW5ndWFnZSBvYmplY3QgbWFuYWdlcyBwYXJzaW5nIGFuZCBwZXItbGFuZ3VhZ2VcblttZXRhZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuIFBhcnNlIGRhdGEgaXNcbm1hbmFnZWQgYXMgYSBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQpIHRyZWUuIFRoZSBjbGFzc1xuY2FuIGJlIHVzZWQgZGlyZWN0bHksIHZpYSB0aGUgW2BMUkxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MUkxhbmd1YWdlKVxuc3ViY2xhc3MgZm9yIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC8pIExSIHBhcnNlcnMsIG9yXG52aWEgdGhlIFtgU3RyZWFtTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbUxhbmd1YWdlKSBzdWJjbGFzc1xuZm9yIHN0cmVhbSBwYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBsYW5ndWFnZSBvYmplY3QuIElmIHlvdSBuZWVkIHRvIGludm9rZSB0aGlzXG4gICAgZGlyZWN0bHksIGZpcnN0IGRlZmluZSBhIGRhdGEgZmFjZXQgd2l0aFxuICAgIFtgZGVmaW5lTGFuZ3VhZ2VGYWNldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmaW5lTGFuZ3VhZ2VGYWNldCksIGFuZCB0aGVuXG4gICAgY29uZmlndXJlIHlvdXIgcGFyc2VyIHRvIFthdHRhY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkgaXRcbiAgICB0byB0aGUgbGFuZ3VhZ2UncyBvdXRlciBzeW50YXggbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBbbGFuZ3VhZ2UgZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgZmFjZXRcbiAgICB1c2VkIGZvciB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZGF0YSwgcGFyc2VyLCBleHRyYUV4dGVuc2lvbnMgPSBbXSwgXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBuYW1lLlxuICAgICovXG4gICAgbmFtZSA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIGRlZmluZSBFZGl0b3JTdGF0ZS50cmVlIGFzIGEgZGVidWdnaW5nIGhlbHBlcixcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgRWRpdG9yU3RhdGUgcGFja2FnZSBhY3R1YWxseSBrbm93aW5nIGFib3V0XG4gICAgICAgIC8vIGxhbmd1YWdlcyBhbmQgbGV6ZXIgdHJlZXMuXG4gICAgICAgIGlmICghRWRpdG9yU3RhdGUucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwidHJlZVwiKSlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZGl0b3JTdGF0ZS5wcm90b3R5cGUsIFwidHJlZVwiLCB7IGdldCgpIHsgcmV0dXJuIHN5bnRheFRyZWUodGhpcyk7IH0gfSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtcbiAgICAgICAgICAgIGxhbmd1YWdlLm9mKHRoaXMpLFxuICAgICAgICAgICAgRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhLm9mKChzdGF0ZSwgcG9zLCBzaWRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKSwgZGF0YSA9IHRvcC50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBzdGF0ZS5mYWNldChkYXRhKSwgc3ViID0gdG9wLnR5cGUucHJvcChzdWJsYW5ndWFnZVByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyTm9kZSA9IHRvcC5yZXNvbHZlKHBvcyAtIHRvcC5mcm9tLCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3VibGFuZyBvZiBzdWIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VibGFuZy50ZXN0KGlubmVyTm9kZSwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBzdGF0ZS5mYWNldChzdWJsYW5nLmZhY2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VibGFuZy50eXBlID09IFwicmVwbGFjZVwiID8gZGF0YSA6IGRhdGEuY29uY2F0KGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0uY29uY2F0KGV4dHJhRXh0ZW5zaW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBpcyBhY3RpdmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaXNBY3RpdmVBdChzdGF0ZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKS50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCByZWdpb25zIHRoYXQgd2VyZSBwYXJzZWQgdXNpbmcgdGhpcyBsYW5ndWFnZS5cbiAgICBUaGUgcmV0dXJuZWQgcmVnaW9ucyB3aWxsIF9pbmNsdWRlXyBhbnkgbmVzdGVkIGxhbmd1YWdlcyByb290ZWRcbiAgICBpbiB0aGlzIGxhbmd1YWdlLCB3aGVuIHRob3NlIGV4aXN0LlxuICAgICovXG4gICAgZmluZFJlZ2lvbnMoc3RhdGUpIHtcbiAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgIGlmICgobGFuZyA9PT0gbnVsbCB8fCBsYW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYW5nLmRhdGEpID09IHRoaXMuZGF0YSlcbiAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiAwLCB0bzogc3RhdGUuZG9jLmxlbmd0aCB9XTtcbiAgICAgICAgaWYgKCFsYW5nIHx8ICFsYW5nLmFsbG93c05lc3RpbmcpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAodHJlZSwgZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vdW50ID0gdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgaWYgKG1vdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50LnRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tOiByLmZyb20gKyBmcm9tLCB0bzogci50byArIGZyb20gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogZnJvbSwgdG86IGZyb20gKyB0cmVlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiBzaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShjaCwgdHJlZS5wb3NpdGlvbnNbaV0gKyBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXhwbG9yZShzeW50YXhUcmVlKHN0YXRlKSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgYWxsb3dzIG5lc3RlZCBsYW5ndWFnZXMuIFRoZVxuICAgIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0cnVlLlxuICAgICovXG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0cnVlOyB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkxhbmd1YWdlLnNldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuZnVuY3Rpb24gdG9wTm9kZUF0KHN0YXRlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgdG9wTGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKSwgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnRvcE5vZGU7XG4gICAgaWYgKCF0b3BMYW5nIHx8IHRvcExhbmcuYWxsb3dzTmVzdGluZykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdHJlZTsgbm9kZTsgbm9kZSA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIHRyZWUgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZTtcbn1cbi8qKlxuQSBzdWJjbGFzcyBvZiBbYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgZm9yIHVzZSB3aXRoIExlemVyXG5bTFIgcGFyc2Vyc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNsci5MUlBhcnNlcilcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTFJMYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoZGF0YSwgcGFyc2VyLCBbXSwgbmFtZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBsYW5ndWFnZSBmcm9tIGEgcGFyc2VyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChzcGVjLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZShkYXRhLCBzcGVjLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgICAgICAgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCh0eXBlID0+IHR5cGUuaXNUb3AgPyBkYXRhIDogdW5kZWZpbmVkKV1cbiAgICAgICAgfSksIHNwZWMubmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGxhbmd1YWdlIHdpdGggYSByZWNvbmZpZ3VyZWRcbiAgICB2ZXJzaW9uIG9mIGl0cyBwYXJzZXIgYW5kIG9wdGlvbmFsbHkgYSBuZXcgbmFtZS5cbiAgICAqL1xuICAgIGNvbmZpZ3VyZShvcHRpb25zLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZSh0aGlzLmRhdGEsIHRoaXMucGFyc2VyLmNvbmZpZ3VyZShvcHRpb25zKSwgbmFtZSB8fCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIHRoaXMucGFyc2VyLmhhc1dyYXBwZXJzKCk7IH1cbn1cbi8qKlxuR2V0IHRoZSBzeW50YXggdHJlZSBmb3IgYSBzdGF0ZSwgd2hpY2ggaXMgdGhlIGN1cnJlbnQgKHBvc3NpYmx5XG5pbmNvbXBsZXRlKSBwYXJzZSB0cmVlIG9mIHRoZSBhY3RpdmVcbltsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSksIG9yIHRoZSBlbXB0eSB0cmVlIGlmIHRoZXJlIGlzIG5vXG5sYW5ndWFnZSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZShzdGF0ZSkge1xuICAgIGxldCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZpZWxkID8gZmllbGQudHJlZSA6IFRyZWUuZW1wdHk7XG59XG4vKipcblRyeSB0byBnZXQgYSBwYXJzZSB0cmVlIHRoYXQgc3BhbnMgYXQgbGVhc3QgdXAgdG8gYHVwdG9gLiBUaGVcbm1ldGhvZCB3aWxsIGRvIGF0IG1vc3QgYHRpbWVvdXRgIG1pbGxpc2Vjb25kcyBvZiB3b3JrIHRvIHBhcnNlXG51cCB0byB0aGF0IHBvaW50IGlmIHRoZSB0cmVlIGlzbid0IGFscmVhZHkgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIGVuc3VyZVN5bnRheFRyZWUoc3RhdGUsIHVwdG8sIHRpbWVvdXQgPSA1MCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcGFyc2UgPSAoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dDtcbiAgICBpZiAoIXBhcnNlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb2xkVmllcG9ydCA9IHBhcnNlLnZpZXdwb3J0O1xuICAgIHBhcnNlLnVwZGF0ZVZpZXdwb3J0KHsgZnJvbTogMCwgdG86IHVwdG8gfSk7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnNlLmlzRG9uZSh1cHRvKSB8fCBwYXJzZS53b3JrKHRpbWVvdXQsIHVwdG8pID8gcGFyc2UudHJlZSA6IG51bGw7XG4gICAgcGFyc2UudXBkYXRlVmlld3BvcnQob2xkVmllcG9ydCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuUXVlcmllcyB3aGV0aGVyIHRoZXJlIGlzIGEgZnVsbCBzeW50YXggdHJlZSBhdmFpbGFibGUgdXAgdG8gdGhlXG5naXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gSWYgdGhlcmUgaXNuJ3QsIHRoZSBiYWNrZ3JvdW5kIHBhcnNlXG5wcm9jZXNzIF9taWdodF8gc3RpbGwgYmUgd29ya2luZyBhbmQgdXBkYXRlIHRoZSB0cmVlIGZ1cnRoZXIsIGJ1dFxudGhlcmUgaXMgbm8gZ3VhcmFudGVlIG9mIHRoYXTigJR0aGUgcGFyc2VyIHdpbGwgW3N0b3BcbndvcmtpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4UGFyc2VyUnVubmluZykgd2hlbiBpdCBoYXMgc3BlbnQgYVxuY2VydGFpbiBhbW91bnQgb2YgdGltZSBvciBoYXMgbW92ZWQgYmV5b25kIHRoZSB2aXNpYmxlIHZpZXdwb3J0LlxuQWx3YXlzIHJldHVybnMgZmFsc2UgaWYgbm8gbGFuZ3VhZ2UgaGFzIGJlZW4gZW5hYmxlZC5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlQXZhaWxhYmxlKHN0YXRlLCB1cHRvID0gc3RhdGUuZG9jLmxlbmd0aCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0LmlzRG9uZSh1cHRvKSkgfHwgZmFsc2U7XG59XG4vKipcbk1vdmUgcGFyc2luZyBmb3J3YXJkLCBhbmQgdXBkYXRlIHRoZSBlZGl0b3Igc3RhdGUgYWZ0ZXJ3YXJkcyB0b1xucmVmbGVjdCB0aGUgbmV3IHRyZWUuIFdpbGwgd29yayBmb3IgYXQgbW9zdCBgdGltZW91dGBcbm1pbGxpc2Vjb25kcy4gUmV0dXJucyB0cnVlIGlmIHRoZSBwYXJzZXIgbWFuYWdlZCBnZXQgdG8gdGhlIGdpdmVuXG5wb3NpdGlvbiBpbiB0aGF0IHRpbWUuXG4qL1xuZnVuY3Rpb24gZm9yY2VQYXJzaW5nKHZpZXcsIHVwdG8gPSB2aWV3LnZpZXdwb3J0LnRvLCB0aW1lb3V0ID0gMTAwKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSBlbnN1cmVTeW50YXhUcmVlKHZpZXcuc3RhdGUsIHVwdG8sIHRpbWVvdXQpO1xuICAgIGlmIChzdWNjZXNzICE9IHN5bnRheFRyZWUodmlldy5zdGF0ZSkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe30pO1xuICAgIHJldHVybiAhIXN1Y2Nlc3M7XG59XG4vKipcblRlbGxzIHlvdSB3aGV0aGVyIHRoZSBsYW5ndWFnZSBwYXJzZXIgaXMgcGxhbm5pbmcgdG8gZG8gbW9yZVxucGFyc2luZyB3b3JrIChpbiBhIGByZXF1ZXN0SWRsZUNhbGxiYWNrYCBwc2V1ZG8tdGhyZWFkKSBvciBoYXNcbnN0b3BwZWQgcnVubmluZywgZWl0aGVyIGJlY2F1c2UgaXQgcGFyc2VkIHRoZSBlbnRpcmUgZG9jdW1lbnQsXG5iZWNhdXNlIGl0IHNwZW50IHRvbyBtdWNoIHRpbWUgYW5kIHdhcyBjdXQgb2ZmLCBvciBiZWNhdXNlIHRoZXJlXG5pcyBubyBsYW5ndWFnZSBwYXJzZXIgZW5hYmxlZC5cbiovXG5mdW5jdGlvbiBzeW50YXhQYXJzZXJSdW5uaW5nKHZpZXcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwYXJzZVdvcmtlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1dvcmtpbmcoKSkgfHwgZmFsc2U7XG59XG4vKipcbkxlemVyLXN0eWxlXG5bYElucHV0YF0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNjb21tb24uSW5wdXQpXG5vYmplY3QgZm9yIGEgW2BUZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0KSBvYmplY3QuXG4qL1xuY2xhc3MgRG9jSW5wdXQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnB1dCBvYmplY3QgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSAwO1xuICAgICAgICB0aGlzLnN0cmluZyA9IFwiXCI7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jLml0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuZG9jLmxlbmd0aDsgfVxuICAgIHN5bmNUbyhwb3MpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSB0aGlzLmN1cnNvci5uZXh0KHBvcyAtIHRoaXMuY3Vyc29yUG9zKS52YWx1ZTtcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBwb3MgKyB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgY2h1bmsocG9zKSB7XG4gICAgICAgIHRoaXMuc3luY1RvKHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBsZXQgc3RyaW5nU3RhcnQgPSB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKGZyb20gPCBzdHJpbmdTdGFydCB8fCB0byA+PSB0aGlzLmN1cnNvclBvcylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0byk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tIC0gc3RyaW5nU3RhcnQsIHRvIC0gc3RyaW5nU3RhcnQpO1xuICAgIH1cbn1cbmxldCBjdXJyZW50Q29udGV4dCA9IG51bGw7XG4vKipcbkEgcGFyc2UgY29udGV4dCBwcm92aWRlZCB0byBwYXJzZXJzIHdvcmtpbmcgb24gdGhlIGVkaXRvciBjb250ZW50LlxuKi9cbmNsYXNzIFBhcnNlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVHJlZSBmcmFnbWVudHMgdGhhdCBjYW4gYmUgcmV1c2VkIGJ5IGluY3JlbWVudGFsIHJlLXBhcnNlcy5cbiAgICAqL1xuICAgIGZyYWdtZW50cyA9IFtdLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHJlZUxlbiwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHZpZXdwb3J0IChvciBzb21lIG92ZXJhcHByb3hpbWF0aW9uXG4gICAgdGhlcmVvZikuIEludGVuZGVkIHRvIGJlIHVzZWQgZm9yIG9wcG9ydHVuaXN0aWNhbGx5IGF2b2lkaW5nXG4gICAgd29yayAoaW4gd2hpY2ggY2FzZVxuICAgIFtgc2tpcFVudGlsSW5WaWV3YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5QYXJzZUNvbnRleHQuc2tpcFVudGlsSW5WaWV3KVxuICAgIHNob3VsZCBiZSBjYWxsZWQgdG8gbWFrZSBzdXJlIHRoZSBwYXJzZXIgaXMgcmVzdGFydGVkIHdoZW4gdGhlXG4gICAgc2tpcHBlZCByZWdpb24gYmVjb21lcyB2aXNpYmxlKS5cbiAgICAqL1xuICAgIHZpZXdwb3J0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNraXBwZWQsIFxuICAgIC8qKlxuICAgIFRoaXMgaXMgd2hlcmUgc2tpcHBpbmcgcGFyc2VycyBjYW4gcmVnaXN0ZXIgYSBwcm9taXNlIHRoYXQsXG4gICAgd2hlbiByZXNvbHZlZCwgd2lsbCBzY2hlZHVsZSBhIG5ldyBwYXJzZS4gSXQgaXMgY2xlYXJlZCB3aGVuXG4gICAgdGhlIHBhcnNlIHdvcmtlciBwaWNrcyB1cCB0aGUgcHJvbWlzZS4gQGludGVybmFsXG4gICAgKi9cbiAgICBzY2hlZHVsZU9uKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLnRyZWVMZW4gPSB0cmVlTGVuO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMuc2tpcHBlZCA9IHNraXBwZWQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVPbiA9IHNjaGVkdWxlT247XG4gICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGVtcFNraXBwZWQgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHBhcnNlciwgc3RhdGUsIHZpZXdwb3J0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0KHBhcnNlciwgc3RhdGUsIFtdLCBUcmVlLmVtcHR5LCAwLCB2aWV3cG9ydCwgW10sIG51bGwpO1xuICAgIH1cbiAgICBzdGFydFBhcnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZXIuc3RhcnRQYXJzZShuZXcgRG9jSW5wdXQodGhpcy5zdGF0ZS5kb2MpLCB0aGlzLmZyYWdtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd29yayh1bnRpbCwgdXB0bykge1xuICAgICAgICBpZiAodXB0byAhPSBudWxsICYmIHVwdG8gPj0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdXB0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMudHJlZSAhPSBUcmVlLmVtcHR5ICYmIHRoaXMuaXNEb25lKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdW50aWwgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIHVudGlsO1xuICAgICAgICAgICAgICAgIHVudGlsID0gKCkgPT4gRGF0ZS5ub3coKSA+IGVuZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMuc3RhcnRQYXJzZSgpO1xuICAgICAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHVwdG8pICYmXG4gICAgICAgICAgICAgICAgdXB0byA8IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnN0b3BBdCh1cHRvKTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUoZG9uZSwgdGhpcy5mcmFnbWVudHMsIHRoaXMucGFyc2Uuc3RvcHBlZEF0ICE9IG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gKF9hID0gdGhpcy5wYXJzZS5zdG9wcGVkQXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlID0gZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyZWVMZW4gPCAodXB0byAhPT0gbnVsbCAmJiB1cHRvICE9PSB2b2lkIDAgPyB1cHRvIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bnRpbCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRha2VUcmVlKCkge1xuICAgICAgICBsZXQgcG9zLCB0cmVlO1xuICAgICAgICBpZiAodGhpcy5wYXJzZSAmJiAocG9zID0gdGhpcy5wYXJzZS5wYXJzZWRQb3MpID49IHRoaXMudHJlZUxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2Uuc3RvcHBlZEF0ID09IG51bGwgfHwgdGhpcy5wYXJzZS5zdG9wcGVkQXQgPiBwb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICAgICAgICAgIHRoaXMud2l0aENvbnRleHQoKCkgPT4geyB3aGlsZSAoISh0cmVlID0gdGhpcy5wYXJzZS5hZHZhbmNlKCkpKSB7IH0gfSk7XG4gICAgICAgICAgICB0aGlzLnRyZWVMZW4gPSBwb3M7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSB0aGlzLndpdGhvdXRUZW1wU2tpcHBlZChUcmVlRnJhZ21lbnQuYWRkVHJlZSh0aGlzLnRyZWUsIHRoaXMuZnJhZ21lbnRzLCB0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aXRoQ29udGV4dChmKSB7XG4gICAgICAgIGxldCBwcmV2ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgIGN1cnJlbnRDb250ZXh0ID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IHByZXY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aG91dFRlbXBTa2lwcGVkKGZyYWdtZW50cykge1xuICAgICAgICBmb3IgKGxldCByOyByID0gdGhpcy50ZW1wU2tpcHBlZC5wb3AoKTspXG4gICAgICAgICAgICBmcmFnbWVudHMgPSBjdXRGcmFnbWVudHMoZnJhZ21lbnRzLCByLmZyb20sIHIudG8pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoYW5nZXMoY2hhbmdlcywgbmV3U3RhdGUpIHtcbiAgICAgICAgbGV0IHsgZnJhZ21lbnRzLCB0cmVlLCB0cmVlTGVuLCB2aWV3cG9ydCwgc2tpcHBlZCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICBpZiAoIWNoYW5nZXMuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IHJhbmdlcy5wdXNoKHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9KSk7XG4gICAgICAgICAgICBmcmFnbWVudHMgPSBUcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgICAgIHRyZWUgPSBUcmVlLmVtcHR5O1xuICAgICAgICAgICAgdHJlZUxlbiA9IDA7XG4gICAgICAgICAgICB2aWV3cG9ydCA9IHsgZnJvbTogY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0bzogY2hhbmdlcy5tYXBQb3Modmlld3BvcnQudG8sIDEpIH07XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwcGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMuc2tpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHIuZnJvbSwgMSksIHRvID0gY2hhbmdlcy5tYXBQb3Moci50bywgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0KHRoaXMucGFyc2VyLCBuZXdTdGF0ZSwgZnJhZ21lbnRzLCB0cmVlLCB0cmVlTGVuLCB2aWV3cG9ydCwgc2tpcHBlZCwgdGhpcy5zY2hlZHVsZU9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1cGRhdGVWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydC5mcm9tID09IHZpZXdwb3J0LmZyb20gJiYgdGhpcy52aWV3cG9ydC50byA9PSB2aWV3cG9ydC50bylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICBsZXQgc3RhcnRMZW4gPSB0aGlzLnNraXBwZWQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2tpcHBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMuc2tpcHBlZFtpXTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgdmlld3BvcnQudG8gJiYgdG8gPiB2aWV3cG9ydC5mcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBjdXRGcmFnbWVudHModGhpcy5mcmFnbWVudHMsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBwZWQuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGggPj0gc3RhcnRMZW4pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBOb3RpZnkgdGhlIHBhcnNlIHNjaGVkdWxlciB0aGF0IHRoZSBnaXZlbiByZWdpb24gd2FzIHNraXBwZWRcbiAgICBiZWNhdXNlIGl0IHdhc24ndCBpbiB2aWV3LCBhbmQgdGhlIHBhcnNlIHNob3VsZCBiZSByZXN0YXJ0ZWRcbiAgICB3aGVuIGl0IGNvbWVzIGludG8gdmlldy5cbiAgICAqL1xuICAgIHNraXBVbnRpbEluVmlldyhmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcGFyc2VyIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgcGxhY2Vob2xkZXIgd2hlblxuICAgIGFzeW5jaHJvbm91c2x5IGxvYWRpbmcgYSBuZXN0ZWQgcGFyc2VyLiBJdCdsbCBza2lwIGl0cyBpbnB1dCBhbmRcbiAgICBtYXJrIGl0IGFzIG5vdC1yZWFsbHktcGFyc2VkLCBzbyB0aGF0IHRoZSBuZXh0IHVwZGF0ZSB3aWxsIHBhcnNlXG4gICAgaXQgYWdhaW4uXG4gICAgXG4gICAgV2hlbiBgdW50aWxgIGlzIGdpdmVuLCBhIHJlcGFyc2Ugd2lsbCBiZSBzY2hlZHVsZWQgd2hlbiB0aGF0XG4gICAgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXRTa2lwcGluZ1BhcnNlcih1bnRpbCkge1xuICAgICAgICByZXR1cm4gbmV3IGNsYXNzIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAgICAgICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzWzBdLmZyb20sIHRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VyID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRQb3M6IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3ggPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC50ZW1wU2tpcHBlZC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnRpbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IGN4LnNjaGVkdWxlT24gPyBQcm9taXNlLmFsbChbY3guc2NoZWR1bGVPbiwgdW50aWxdKSA6IHVudGlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIHRvIC0gZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRBdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0KCkgeyB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlzRG9uZSh1cHRvKSB7XG4gICAgICAgIHVwdG8gPSBNYXRoLm1pbih1cHRvLCB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBsZXQgZnJhZ3MgPSB0aGlzLmZyYWdtZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZUxlbiA+PSB1cHRvICYmIGZyYWdzLmxlbmd0aCAmJiBmcmFnc1swXS5mcm9tID09IDAgJiYgZnJhZ3NbMF0udG8gPj0gdXB0bztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZXh0IGZvciB0aGUgY3VycmVudCBwYXJzZSwgb3IgYG51bGxgIGlmIG5vIGVkaXRvclxuICAgIHBhcnNlIGlzIGluIHByb2dyZXNzLlxuICAgICovXG4gICAgc3RhdGljIGdldCgpIHsgcmV0dXJuIGN1cnJlbnRDb250ZXh0OyB9XG59XG5mdW5jdGlvbiBjdXRGcmFnbWVudHMoZnJhZ21lbnRzLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBUcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgW3sgZnJvbUE6IGZyb20sIHRvQTogdG8sIGZyb21COiBmcm9tLCB0b0I6IHRvIH1dKTtcbn1cbmNsYXNzIExhbmd1YWdlU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIEEgbXV0YWJsZSBwYXJzZSBzdGF0ZSB0aGF0IGlzIHVzZWQgdG8gcHJlc2VydmUgd29yayBkb25lIGR1cmluZ1xuICAgIC8vIHRoZSBsaWZldGltZSBvZiBhIHN0YXRlIHdoZW4gbW92aW5nIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy50cmVlID0gY29udGV4dC50cmVlO1xuICAgIH1cbiAgICBhcHBseSh0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgJiYgdGhpcy50cmVlID09IHRoaXMuY29udGV4dC50cmVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBuZXdDeCA9IHRoaXMuY29udGV4dC5jaGFuZ2VzKHRyLmNoYW5nZXMsIHRyLnN0YXRlKTtcbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHBhcnNlIHdhc24ndCBkb25lLCBnbyBmb3J3YXJkIG9ubHkgdXAgdG8gaXRzXG4gICAgICAgIC8vIGVuZCBwb3NpdGlvbiBvciB0aGUgZW5kIG9mIHRoZSB2aWV3cG9ydCwgdG8gYXZvaWQgc2xvd2luZyBkb3duXG4gICAgICAgIC8vIHN0YXRlIHVwZGF0ZXMgd2l0aCBwYXJzZSB3b3JrIGJleW9uZCB0aGUgdmlld3BvcnQuXG4gICAgICAgIGxldCB1cHRvID0gdGhpcy5jb250ZXh0LnRyZWVMZW4gPT0gdHIuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IE1hdGgubWF4KHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuY29udGV4dC50cmVlTGVuKSwgbmV3Q3gudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAoIW5ld0N4LndvcmsoMjAgLyogV29yay5BcHBseSAqLywgdXB0bykpXG4gICAgICAgICAgICBuZXdDeC50YWtlVHJlZSgpO1xuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlU3RhdGUobmV3Q3gpO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdChzdGF0ZSkge1xuICAgICAgICBsZXQgdnBUbyA9IE1hdGgubWluKDMwMDAgLyogV29yay5Jbml0Vmlld3BvcnQgKi8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBsZXQgcGFyc2VTdGF0ZSA9IFBhcnNlQ29udGV4dC5jcmVhdGUoc3RhdGUuZmFjZXQobGFuZ3VhZ2UpLnBhcnNlciwgc3RhdGUsIHsgZnJvbTogMCwgdG86IHZwVG8gfSk7XG4gICAgICAgIGlmICghcGFyc2VTdGF0ZS53b3JrKDIwIC8qIFdvcmsuQXBwbHkgKi8sIHZwVG8pKVxuICAgICAgICAgICAgcGFyc2VTdGF0ZS50YWtlVHJlZSgpO1xuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlU3RhdGUocGFyc2VTdGF0ZSk7XG4gICAgfVxufVxuTGFuZ3VhZ2Uuc3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZTogTGFuZ3VhZ2VTdGF0ZS5pbml0LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGUuaXMoTGFuZ3VhZ2Uuc2V0U3RhdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgICBpZiAodHIuc3RhcnRTdGF0ZS5mYWNldChsYW5ndWFnZSkgIT0gdHIuc3RhdGUuZmFjZXQobGFuZ3VhZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIExhbmd1YWdlU3RhdGUuaW5pdCh0ci5zdGF0ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0cik7XG4gICAgfVxufSk7XG5sZXQgcmVxdWVzdElkbGUgPSAoY2FsbGJhY2spID0+IHtcbiAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soKSwgNTAwIC8qIFdvcmsuTWF4UGF1c2UgKi8pO1xuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG59O1xuaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9IFwidW5kZWZpbmVkXCIpXG4gICAgcmVxdWVzdElkbGUgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgbGV0IGlkbGUgPSAtMSwgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWRsZSA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soY2FsbGJhY2ssIHsgdGltZW91dDogNTAwIC8qIFdvcmsuTWF4UGF1c2UgKi8gLSAxMDAgLyogV29yay5NaW5QYXVzZSAqLyB9KTtcbiAgICAgICAgfSwgMTAwIC8qIFdvcmsuTWluUGF1c2UgKi8pO1xuICAgICAgICByZXR1cm4gKCkgPT4gaWRsZSA8IDAgPyBjbGVhclRpbWVvdXQodGltZW91dCkgOiBjYW5jZWxJZGxlQ2FsbGJhY2soaWRsZSk7XG4gICAgfTtcbmNvbnN0IGlzSW5wdXRQZW5kaW5nID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmICgoX2EgPSBuYXZpZ2F0b3Iuc2NoZWR1bGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzSW5wdXRQZW5kaW5nKVxuICAgID8gKCkgPT4gbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcoKSA6IG51bGw7XG5jb25zdCBwYXJzZVdvcmtlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyBQYXJzZVdvcmtlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLndvcmtpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLndvcmtTY2hlZHVsZWQgPSAwO1xuICAgICAgICAvLyBFbmQgb2YgdGhlIGN1cnJlbnQgdGltZSBjaHVua1xuICAgICAgICB0aGlzLmNodW5rRW5kID0gLTE7XG4gICAgICAgIC8vIE1pbGxpc2Vjb25kcyBvZiBidWRnZXQgbGVmdCBmb3IgdGhpcyBjaHVua1xuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gLTE7XG4gICAgICAgIHRoaXMud29yayA9IHRoaXMud29yay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjeCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSkuY29udGV4dDtcbiAgICAgICAgaWYgKGN4LnVwZGF0ZVZpZXdwb3J0KHVwZGF0ZS52aWV3LnZpZXdwb3J0KSB8fCB0aGlzLnZpZXcudmlld3BvcnQudG8gPiBjeC50cmVlTGVuKVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaGFzRm9jdXMpXG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua0J1ZGdldCArPSA1MCAvKiBXb3JrLkNoYW5nZUJvbnVzICovO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShjeCk7XG4gICAgfVxuICAgIHNjaGVkdWxlV29yaygpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSk7XG4gICAgICAgIGlmIChmaWVsZC50cmVlICE9IGZpZWxkLmNvbnRleHQudHJlZSB8fCAhZmllbGQuY29udGV4dC5pc0RvbmUoc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLndvcmtpbmcgPSByZXF1ZXN0SWRsZSh0aGlzLndvcmspO1xuICAgIH1cbiAgICB3b3JrKGRlYWRsaW5lKSB7XG4gICAgICAgIHRoaXMud29ya2luZyA9IG51bGw7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5jaHVua0VuZCA8IG5vdyAmJiAodGhpcy5jaHVua0VuZCA8IDAgfHwgdGhpcy52aWV3Lmhhc0ZvY3VzKSkgeyAvLyBTdGFydCBhIG5ldyBjaHVua1xuICAgICAgICAgICAgdGhpcy5jaHVua0VuZCA9IG5vdyArIDMwMDAwIC8qIFdvcmsuQ2h1bmtUaW1lICovO1xuICAgICAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IDMwMDAgLyogV29yay5DaHVua0J1ZGdldCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0J1ZGdldCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBObyBtb3JlIGJ1ZGdldFxuICAgICAgICBsZXQgeyBzdGF0ZSwgdmlld3BvcnQ6IHsgdG86IHZwVG8gfSB9ID0gdGhpcy52aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKTtcbiAgICAgICAgaWYgKGZpZWxkLnRyZWUgPT0gZmllbGQuY29udGV4dC50cmVlICYmIGZpZWxkLmNvbnRleHQuaXNEb25lKHZwVG8gKyAxMDAwMDAgLyogV29yay5NYXhQYXJzZUFoZWFkICovKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgTWF0aC5taW4odGhpcy5jaHVua0J1ZGdldCwgMTAwIC8qIFdvcmsuU2xpY2UgKi8sIGRlYWRsaW5lICYmICFpc0lucHV0UGVuZGluZyA/IE1hdGgubWF4KDI1IC8qIFdvcmsuTWluU2xpY2UgKi8sIGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSAtIDUpIDogMWU5KTtcbiAgICAgICAgbGV0IHZpZXdwb3J0Rmlyc3QgPSBmaWVsZC5jb250ZXh0LnRyZWVMZW4gPCB2cFRvICYmIHN0YXRlLmRvYy5sZW5ndGggPiB2cFRvICsgMTAwMDtcbiAgICAgICAgbGV0IGRvbmUgPSBmaWVsZC5jb250ZXh0LndvcmsoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzSW5wdXRQZW5kaW5nICYmIGlzSW5wdXRQZW5kaW5nKCkgfHwgRGF0ZS5ub3coKSA+IGVuZFRpbWU7XG4gICAgICAgIH0sIHZwVG8gKyAodmlld3BvcnRGaXJzdCA/IDAgOiAxMDAwMDAgLyogV29yay5NYXhQYXJzZUFoZWFkICovKSk7XG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgLT0gRGF0ZS5ub3coKSAtIG5vdztcbiAgICAgICAgaWYgKGRvbmUgfHwgdGhpcy5jaHVua0J1ZGdldCA8PSAwKSB7XG4gICAgICAgICAgICBmaWVsZC5jb250ZXh0LnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBMYW5ndWFnZS5zZXRTdGF0ZS5vZihuZXcgTGFuZ3VhZ2VTdGF0ZShmaWVsZC5jb250ZXh0KSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtCdWRnZXQgPiAwICYmICEoZG9uZSAmJiAhdmlld3BvcnRGaXJzdCkpXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShmaWVsZC5jb250ZXh0KTtcbiAgICB9XG4gICAgY2hlY2tBc3luY1NjaGVkdWxlKGN4KSB7XG4gICAgICAgIGlmIChjeC5zY2hlZHVsZU9uKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtTY2hlZHVsZWQrKztcbiAgICAgICAgICAgIGN4LnNjaGVkdWxlT25cbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNjaGVkdWxlV29yaygpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLndvcmtTY2hlZHVsZWQtLSk7XG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKVxuICAgICAgICAgICAgdGhpcy53b3JraW5nKCk7XG4gICAgfVxuICAgIGlzV29ya2luZygpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMud29ya2luZyB8fCB0aGlzLndvcmtTY2hlZHVsZWQgPiAwKTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczogeyBmb2N1cygpIHsgdGhpcy5zY2hlZHVsZVdvcmsoKTsgfSB9XG59KTtcbi8qKlxuVGhlIGZhY2V0IHVzZWQgdG8gYXNzb2NpYXRlIGEgbGFuZ3VhZ2Ugd2l0aCBhbiBlZGl0b3Igc3RhdGUuIFVzZWRcbmJ5IGBMYW5ndWFnZWAgb2JqZWN0J3MgYGV4dGVuc2lvbmAgcHJvcGVydHkgKHNvIHlvdSBkb24ndCBuZWVkIHRvXG5tYW51YWxseSB3cmFwIHlvdXIgbGFuZ3VhZ2VzIGluIHRoaXMpLiBDYW4gYmUgdXNlZCB0byBhY2Nlc3MgdGhlXG5jdXJyZW50IGxhbmd1YWdlIG9uIGEgc3RhdGUuXG4qL1xuY29uc3QgbGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGxhbmd1YWdlcykgeyByZXR1cm4gbGFuZ3VhZ2VzLmxlbmd0aCA/IGxhbmd1YWdlc1swXSA6IG51bGw7IH0sXG4gICAgZW5hYmxlczogbGFuZ3VhZ2UgPT4gW1xuICAgICAgICBMYW5ndWFnZS5zdGF0ZSxcbiAgICAgICAgcGFyc2VXb3JrZXIsXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMuY29tcHV0ZShbbGFuZ3VhZ2VdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHJldHVybiBsYW5nICYmIGxhbmcubmFtZSA/IHsgXCJkYXRhLWxhbmd1YWdlXCI6IGxhbmcubmFtZSB9IDoge307XG4gICAgICAgIH0pXG4gICAgXVxufSk7XG4vKipcblRoaXMgY2xhc3MgYnVuZGxlcyBhIFtsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgd2l0aCBhblxub3B0aW9uYWwgc2V0IG9mIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucy4gTGFuZ3VhZ2UgcGFja2FnZXMgYXJlXG5lbmNvdXJhZ2VkIHRvIGV4cG9ydCBhIGZ1bmN0aW9uIHRoYXQgb3B0aW9uYWxseSB0YWtlcyBhXG5jb25maWd1cmF0aW9uIG9iamVjdCBhbmQgcmV0dXJucyBhIGBMYW5ndWFnZVN1cHBvcnRgIGluc3RhbmNlLCBhc1xudGhlIG1haW4gd2F5IGZvciBjbGllbnQgY29kZSB0byB1c2UgdGhlIHBhY2thZ2UuXG4qL1xuY2xhc3MgTGFuZ3VhZ2VTdXBwb3J0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBzdXBwb3J0IG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsYW5ndWFnZSBvYmplY3QuXG4gICAgKi9cbiAgICBsYW5ndWFnZSwgXG4gICAgLyoqXG4gICAgQW4gb3B0aW9uYWwgc2V0IG9mIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucy4gV2hlbiBuZXN0aW5nIGFcbiAgICBsYW5ndWFnZSBpbiBhbm90aGVyIGxhbmd1YWdlLCB0aGUgb3V0ZXIgbGFuZ3VhZ2UgaXMgZW5jb3VyYWdlZFxuICAgIHRvIGluY2x1ZGUgdGhlIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucyBmb3IgaXRzIGlubmVyIGxhbmd1YWdlc1xuICAgIGluIGl0cyBvd24gc2V0IG9mIHN1cHBvcnQgZXh0ZW5zaW9ucy5cbiAgICAqL1xuICAgIHN1cHBvcnQgPSBbXSkge1xuICAgICAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gW2xhbmd1YWdlLCBzdXBwb3J0XTtcbiAgICB9XG59XG4vKipcbkxhbmd1YWdlIGRlc2NyaXB0aW9ucyBhcmUgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBhYm91dCBsYW5ndWFnZXNcbmFuZCB0byBkeW5hbWljYWxseSBsb2FkIHRoZW0uIFRoZWlyIG1haW4gcm9sZSBpcyBmaW5kaW5nIHRoZVxuYXBwcm9wcmlhdGUgbGFuZ3VhZ2UgZm9yIGEgZmlsZW5hbWUgb3IgZHluYW1pY2FsbHkgbG9hZGluZyBuZXN0ZWRcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTGFuZ3VhZ2VEZXNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgb2YgdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEFsdGVybmF0aXZlIG5hbWVzIGZvciB0aGUgbW9kZSAobG93ZXJjYXNlZCwgaW5jbHVkZXMgYHRoaXMubmFtZWApLlxuICAgICovXG4gICAgYWxpYXMsIFxuICAgIC8qKlxuICAgIEZpbGUgZXh0ZW5zaW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGV4dGVuc2lvbnMsIFxuICAgIC8qKlxuICAgIE9wdGlvbmFsIGZpbGVuYW1lIHBhdHRlcm4gdGhhdCBzaG91bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHRoaXNcbiAgICBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGZpbGVuYW1lLCBsb2FkRnVuYywgXG4gICAgLyoqXG4gICAgSWYgdGhlIGxhbmd1YWdlIGhhcyBiZWVuIGxvYWRlZCwgdGhpcyB3aWxsIGhvbGQgaXRzIHZhbHVlLlxuICAgICovXG4gICAgc3VwcG9ydCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFsaWFzID0gYWxpYXM7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5sb2FkRnVuYyA9IGxvYWRGdW5jO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCBsb2FkaW5nIHRoZSB0aGUgbGFuZ3VhZ2UuIFdpbGwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0XG4gICAgcmVzb2x2ZXMgdG8gYSBbYExhbmd1YWdlU3VwcG9ydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VTdXBwb3J0KVxuICAgIG9iamVjdCB3aGVuIHRoZSBsYW5ndWFnZSBzdWNjZXNzZnVsbHkgbG9hZHMuXG4gICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nIHx8ICh0aGlzLmxvYWRpbmcgPSB0aGlzLmxvYWRGdW5jKCkudGhlbihzdXBwb3J0ID0+IHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQsIGVyciA9PiB7IHRoaXMubG9hZGluZyA9IG51bGw7IHRocm93IGVycjsgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBkZXNjcmlwdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihzcGVjKSB7XG4gICAgICAgIGxldCB7IGxvYWQsIHN1cHBvcnQgfSA9IHNwZWM7XG4gICAgICAgIGlmICghbG9hZCkge1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVzdCBwYXNzIGVpdGhlciAnbG9hZCcgb3IgJ3N1cHBvcnQnIHRvIExhbmd1YWdlRGVzY3JpcHRpb24ub2ZcIik7XG4gICAgICAgICAgICBsb2FkID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN1cHBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VEZXNjcmlwdGlvbihzcGVjLm5hbWUsIChzcGVjLmFsaWFzIHx8IFtdKS5jb25jYXQoc3BlYy5uYW1lKS5tYXAocyA9PiBzLnRvTG93ZXJDYXNlKCkpLCBzcGVjLmV4dGVuc2lvbnMgfHwgW10sIHNwZWMuZmlsZW5hbWUsIGxvYWQsIHN1cHBvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciBhIGxhbmd1YWdlIGluIHRoZSBnaXZlbiBhcnJheSBvZiBkZXNjcmlwdGlvbnMgdGhhdFxuICAgIG1hdGNoZXMgdGhlIGZpbGVuYW1lLiBXaWxsIGZpcnN0IG1hdGNoXG4gICAgW2BmaWxlbmFtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VEZXNjcmlwdGlvbi5maWxlbmFtZSkgcGF0dGVybnMsXG4gICAgYW5kIHRoZW4gW2V4dGVuc2lvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VEZXNjcmlwdGlvbi5leHRlbnNpb25zKSxcbiAgICBhbmQgcmV0dXJuIHRoZSBmaXJzdCBsYW5ndWFnZSB0aGF0IG1hdGNoZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF0Y2hGaWxlbmFtZShkZXNjcywgZmlsZW5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgIGlmIChkLmZpbGVuYW1lICYmIGQuZmlsZW5hbWUudGVzdChmaWxlbmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIGxldCBleHQgPSAvXFwuKFteLl0rKSQvLmV4ZWMoZmlsZW5hbWUpO1xuICAgICAgICBpZiAoZXh0KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBpZiAoZC5leHRlbnNpb25zLmluZGV4T2YoZXh0WzFdKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2Ugd2hvc2UgbmFtZSBvciBhbGlhcyBtYXRjaGVzIHRoZSB0aGUgZ2l2ZW5cbiAgICBuYW1lIChjYXNlLWluc2Vuc2l0aXZlbHkpLiBJZiBgZnV6enlgIGlzIHRydWUsIGFuZCBubyBkaXJlY3RcbiAgICBtYXRjaHMgaXMgZm91bmQsIHRoaXMnbGwgYWxzbyBzZWFyY2ggZm9yIGEgbGFuZ3VhZ2Ugd2hvc2UgbmFtZVxuICAgIG9yIGFsaWFzIG9jY3VycyBpbiB0aGUgc3RyaW5nIChmb3IgbmFtZXMgc2hvcnRlciB0aGFuIHRocmVlXG4gICAgY2hhcmFjdGVycywgb25seSB3aGVuIHN1cnJvdW5kZWQgYnkgbm9uLXdvcmQgY2hhcmFjdGVycykuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF0Y2hMYW5ndWFnZU5hbWUoZGVzY3MsIG5hbWUsIGZ1enp5ID0gdHJ1ZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuYWxpYXMuc29tZShhID0+IGEgPT0gbmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIGlmIChmdXp6eSlcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYSBvZiBkLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IG5hbWUuaW5kZXhPZihhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEgJiYgKGEubGVuZ3RoID4gMiB8fCAhL1xcdy8udGVzdChuYW1lW2ZvdW5kIC0gMV0pICYmICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgKyBhLmxlbmd0aF0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbkZhY2V0IHRoYXQgZGVmaW5lcyBhIHdheSB0byBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyB0aGVcbmFwcHJvcHJpYXRlIGluZGVudGF0aW9uIGRlcHRoLCBhcyBhIGNvbHVtbiBudW1iZXIgKHNlZVxuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpLCBhdCB0aGUgc3RhcnQgb2YgYSBnaXZlblxubGluZS4gQSByZXR1cm4gdmFsdWUgb2YgYG51bGxgIGluZGljYXRlcyBubyBpbmRlbnRhdGlvbiBjYW4gYmVcbmRldGVybWluZWQsIGFuZCB0aGUgbGluZSBzaG91bGQgaW5oZXJpdCB0aGUgaW5kZW50YXRpb24gb2YgdGhlIG9uZVxuYWJvdmUgaXQuIEEgcmV0dXJuIHZhbHVlIG9mIGB1bmRlZmluZWRgIGRlZmVycyB0byB0aGUgbmV4dCBpbmRlbnRcbnNlcnZpY2UuXG4qL1xuY29uc3QgaW5kZW50U2VydmljZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRmFjZXQgZm9yIG92ZXJyaWRpbmcgdGhlIHVuaXQgYnkgd2hpY2ggaW5kZW50YXRpb24gaGFwcGVucy4gU2hvdWxkXG5iZSBhIHN0cmluZyBjb25zaXN0aW5nIGVpdGhlciBlbnRpcmVseSBvZiB0aGUgc2FtZSB3aGl0ZXNwYWNlXG5jaGFyYWN0ZXIuIFdoZW4gbm90IHNldCwgdGhpcyBkZWZhdWx0cyB0byAyIHNwYWNlcy5cbiovXG5jb25zdCBpbmRlbnRVbml0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFwiICBcIjtcbiAgICAgICAgbGV0IHVuaXQgPSB2YWx1ZXNbMF07XG4gICAgICAgIGlmICghdW5pdCB8fCAvXFxTLy50ZXN0KHVuaXQpIHx8IEFycmF5LmZyb20odW5pdCkuc29tZShlID0+IGUgIT0gdW5pdFswXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGVudCB1bml0OiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlc1swXSkpO1xuICAgICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJuIHRoZSBfY29sdW1uIHdpZHRoXyBvZiBhbiBpbmRlbnQgdW5pdCBpbiB0aGUgc3RhdGUuXG5EZXRlcm1pbmVkIGJ5IHRoZSBbYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpXG5mYWNldCwgYW5kIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgd2hlbiB0aGF0XG5jb250YWlucyB0YWJzLlxuKi9cbmZ1bmN0aW9uIGdldEluZGVudFVuaXQoc3RhdGUpIHtcbiAgICBsZXQgdW5pdCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgIHJldHVybiB1bml0LmNoYXJDb2RlQXQoMCkgPT0gOSA/IHN0YXRlLnRhYlNpemUgKiB1bml0Lmxlbmd0aCA6IHVuaXQubGVuZ3RoO1xufVxuLyoqXG5DcmVhdGUgYW4gaW5kZW50YXRpb24gc3RyaW5nIHRoYXQgY292ZXJzIGNvbHVtbnMgMCB0byBgY29sc2AuXG5XaWxsIHVzZSB0YWJzIGZvciBhcyBtdWNoIG9mIHRoZSBjb2x1bW5zIGFzIHBvc3NpYmxlIHdoZW4gdGhlXG5bYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIGZhY2V0IGNvbnRhaW5zXG50YWJzLlxuKi9cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdGF0ZSwgY29scykge1xuICAgIGxldCByZXN1bHQgPSBcIlwiLCB0cyA9IHN0YXRlLnRhYlNpemUsIGNoID0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdClbMF07XG4gICAgaWYgKGNoID09IFwiXFx0XCIpIHtcbiAgICAgICAgd2hpbGUgKGNvbHMgPj0gdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgY29scyAtPSB0cztcbiAgICAgICAgfVxuICAgICAgICBjaCA9IFwiIFwiO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHM7IGkrKylcbiAgICAgICAgcmVzdWx0ICs9IGNoO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkdldCB0aGUgaW5kZW50YXRpb24sIGFzIGEgY29sdW1uIG51bWJlciwgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuV2lsbCBmaXJzdCBjb25zdWx0IGFueSBbaW5kZW50IHNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpXG50aGF0IGFyZSByZWdpc3RlcmVkLCBhbmQgaWYgbm9uZSBvZiB0aG9zZSByZXR1cm4gYW4gaW5kZW50YXRpb24sXG50aGlzIHdpbGwgY2hlY2sgdGhlIHN5bnRheCB0cmVlIGZvciB0aGUgW2luZGVudCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudE5vZGVQcm9wKSBhbmQgdXNlIHRoYXQgaWYgZm91bmQuIFJldHVybnMgYVxubnVtYmVyIHdoZW4gYW4gaW5kZW50YXRpb24gY291bGQgYmUgZGV0ZXJtaW5lZCwgYW5kIG51bGxcbm90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBwb3MpIHtcbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIEVkaXRvclN0YXRlKVxuICAgICAgICBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoY29udGV4dCk7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBjb250ZXh0LnN0YXRlLmZhY2V0KGluZGVudFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKGNvbnRleHQsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKTtcbiAgICByZXR1cm4gdHJlZS5sZW5ndGggPj0gcG9zID8gc3ludGF4SW5kZW50YXRpb24oY29udGV4dCwgdHJlZSwgcG9zKSA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhIGNoYW5nZSBzZXQgdGhhdCBhdXRvLWluZGVudHMgYWxsIGxpbmVzIHRvdWNoZWQgYnkgdGhlXG5naXZlbiBkb2N1bWVudCByYW5nZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRSYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHVwZGF0ZWRbc3RhcnRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTsgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG59XG4vKipcbkluZGVudGF0aW9uIGNvbnRleHRzIGFyZSB1c2VkIHdoZW4gY2FsbGluZyBbaW5kZW50YXRpb25cbnNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpLiBUaGV5IHByb3ZpZGUgaGVscGVyIHV0aWxpdGllc1xudXNlZnVsIGluIGluZGVudGF0aW9uIGxvZ2ljLCBhbmQgY2FuIHNlbGVjdGl2ZWx5IG92ZXJyaWRlIHRoZVxuaW5kZW50YXRpb24gcmVwb3J0ZWQgZm9yIHNvbWUgbGluZXMuXG4qL1xuY2xhc3MgSW5kZW50Q29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluZGVudCBjb250ZXh0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudW5pdCA9IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHRha2luZ1xuICAgIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBpbnRvIGFjY291bnQuIElmIHRoZXJlIGlzIHN1Y2ggYSBicmVhayBhdCBgcG9zYCwgdGhlIGBiaWFzYFxuICAgIGFyZ3VtZW50IGRldGVybWluZXMgd2hldGhlciB0aGUgcGFydCBvZiB0aGUgbGluZSBsaW5lIGJlZm9yZSBvclxuICAgIGFmdGVyIHRoZSBicmVhayBpcyB1c2VkLlxuICAgICovXG4gICAgbGluZUF0KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IHsgc2ltdWxhdGVCcmVhaywgc2ltdWxhdGVEb3VibGVCcmVhayB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc2ltdWxhdGVCcmVhayAhPSBudWxsICYmIHNpbXVsYXRlQnJlYWsgPj0gbGluZS5mcm9tICYmIHNpbXVsYXRlQnJlYWsgPD0gbGluZS50bykge1xuICAgICAgICAgICAgaWYgKHNpbXVsYXRlRG91YmxlQnJlYWsgJiYgc2ltdWxhdGVCcmVhayA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogXCJcIiwgZnJvbTogcG9zIH07XG4gICAgICAgICAgICBlbHNlIGlmIChiaWFzIDwgMCA/IHNpbXVsYXRlQnJlYWsgPCBwb3MgOiBzaW11bGF0ZUJyZWFrIDw9IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2Uoc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IHNpbXVsYXRlQnJlYWsgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2UoMCwgc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IGxpbmUuZnJvbSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHRleHQgZGlyZWN0bHkgYWZ0ZXIgYHBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICB0ZXh0QWZ0ZXJQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWsgJiYgcG9zID09IHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKHBvcyAtIGZyb20sIE1hdGgubWluKHRleHQubGVuZ3RoLCBwb3MgKyAxMDAgLSBmcm9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgY29sdW1uKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY291bnRDb2x1bW4odGV4dCwgcG9zIC0gZnJvbSk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uID8gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24oZnJvbSkgOiAtMTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID4gLTEpXG4gICAgICAgICAgICByZXN1bHQgKz0gb3ZlcnJpZGUgLSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIHBvc2l0aW9uICh0YWtpbmcgdGFicyBpbnRvIGFjY291bnQpIG9mIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBjb3VudENvbHVtbihsaW5lLCBwb3MgPSBsaW5lLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY291bnRDb2x1bW4obGluZSwgdGhpcy5zdGF0ZS50YWJTaXplLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgICovXG4gICAgbGluZUluZGVudChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZW4gPSBvdmVycmlkZShmcm9tKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZW4gPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgW3NpbXVsYXRlZCBsaW5lXG4gICAgYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgZm9yIHRoaXMgY29udGV4dCwgaWYgYW55LlxuICAgICovXG4gICAgZ2V0IHNpbXVsYXRlZEJyZWFrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWsgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkEgc3ludGF4IHRyZWUgbm9kZSBwcm9wIHVzZWQgdG8gYXNzb2NpYXRlIGluZGVudGF0aW9uIHN0cmF0ZWdpZXNcbndpdGggbm9kZSB0eXBlcy4gU3VjaCBhIHN0cmF0ZWd5IGlzIGEgZnVuY3Rpb24gZnJvbSBhbiBpbmRlbnRhdGlvblxuY29udGV4dCB0byBhIGNvbHVtbiBudW1iZXIgKHNlZSBhbHNvXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSkgb3IgbnVsbCwgd2hlcmUgbnVsbFxuaW5kaWNhdGVzIHRoYXQgbm8gZGVmaW5pdGl2ZSBpbmRlbnRhdGlvbiBjYW4gYmUgZGV0ZXJtaW5lZC5cbiovXG5jb25zdCBpbmRlbnROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8vIENvbXB1dGUgdGhlIGluZGVudGF0aW9uIGZvciBhIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhlIHN5bnRheCB0cmVlLlxuZnVuY3Rpb24gc3ludGF4SW5kZW50YXRpb24oY3gsIGFzdCwgcG9zKSB7XG4gICAgbGV0IHN0YWNrID0gYXN0LnJlc29sdmVTdGFjayhwb3MpO1xuICAgIGxldCBpbm5lciA9IHN0YWNrLm5vZGUuZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKTtcbiAgICBpZiAoaW5uZXIgIT0gc3RhY2subm9kZSkge1xuICAgICAgICBsZXQgYWRkID0gW107XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGlubmVyOyBjdXIgIT0gc3RhY2subm9kZTsgY3VyID0gY3VyLnBhcmVudClcbiAgICAgICAgICAgIGFkZC5wdXNoKGN1cik7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZGQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBzdGFjayA9IHsgbm9kZTogYWRkW2ldLCBuZXh0OiBzdGFjayB9O1xuICAgIH1cbiAgICByZXR1cm4gaW5kZW50Rm9yKHN0YWNrLCBjeCwgcG9zKTtcbn1cbmZ1bmN0aW9uIGluZGVudEZvcihzdGFjaywgY3gsIHBvcykge1xuICAgIGZvciAobGV0IGN1ciA9IHN0YWNrOyBjdXI7IGN1ciA9IGN1ci5uZXh0KSB7XG4gICAgICAgIGxldCBzdHJhdGVneSA9IGluZGVudFN0cmF0ZWd5KGN1ci5ub2RlKTtcbiAgICAgICAgaWYgKHN0cmF0ZWd5KVxuICAgICAgICAgICAgcmV0dXJuIHN0cmF0ZWd5KFRyZWVJbmRlbnRDb250ZXh0LmNyZWF0ZShjeCwgcG9zLCBjdXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpZ25vcmVDbG9zZWQoY3gpIHtcbiAgICByZXR1cm4gY3gucG9zID09IGN4Lm9wdGlvbnMuc2ltdWxhdGVCcmVhayAmJiBjeC5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWs7XG59XG5mdW5jdGlvbiBpbmRlbnRTdHJhdGVneSh0cmVlKSB7XG4gICAgbGV0IHN0cmF0ZWd5ID0gdHJlZS50eXBlLnByb3AoaW5kZW50Tm9kZVByb3ApO1xuICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5O1xuICAgIGxldCBmaXJzdCA9IHRyZWUuZmlyc3RDaGlsZCwgY2xvc2U7XG4gICAgaWYgKGZpcnN0ICYmIChjbG9zZSA9IGZpcnN0LnR5cGUucHJvcChOb2RlUHJvcC5jbG9zZWRCeSkpKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdHJlZS5sYXN0Q2hpbGQsIGNsb3NlZCA9IGxhc3QgJiYgY2xvc2UuaW5kZXhPZihsYXN0Lm5hbWUpID4gLTE7XG4gICAgICAgIHJldHVybiBjeCA9PiBkZWxpbWl0ZWRTdHJhdGVneShjeCwgdHJ1ZSwgMSwgdW5kZWZpbmVkLCBjbG9zZWQgJiYgIWlnbm9yZUNsb3NlZChjeCkgPyBsYXN0LmZyb20gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZS5wYXJlbnQgPT0gbnVsbCA/IHRvcEluZGVudCA6IG51bGw7XG59XG5mdW5jdGlvbiB0b3BJbmRlbnQoKSB7IHJldHVybiAwOyB9XG4vKipcbk9iamVjdHMgb2YgdGhpcyB0eXBlIHByb3ZpZGUgY29udGV4dCBpbmZvcm1hdGlvbiBhbmQgaGVscGVyXG5tZXRob2RzIHRvIGluZGVudGF0aW9uIGZ1bmN0aW9ucyByZWdpc3RlcmVkIG9uIHN5bnRheCBub2Rlcy5cbiovXG5jbGFzcyBUcmVlSW5kZW50Q29udGV4dCBleHRlbmRzIEluZGVudENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB3aGljaCBpbmRlbnRhdGlvbiBpcyBiZWluZyBjb21wdXRlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGJhc2Uuc3RhdGUsIGJhc2Uub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3ludGF4IHRyZWUgbm9kZSB0byB3aGljaCB0aGUgaW5kZW50YXRpb24gc3RyYXRlZ3lcbiAgICBhcHBsaWVzLlxuICAgICovXG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzLmNvbnRleHQubm9kZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShiYXNlLCBwb3MsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlSW5kZW50Q29udGV4dChiYXNlLCBwb3MsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHRleHQgZGlyZWN0bHkgYWZ0ZXIgYHRoaXMucG9zYCwgZWl0aGVyIHRoZSBlbnRpcmUgbGluZVxuICAgIG9yIHRoZSBuZXh0IDEwMCBjaGFyYWN0ZXJzLCB3aGljaGV2ZXIgaXMgc2hvcnRlci5cbiAgICAqL1xuICAgIGdldCB0ZXh0QWZ0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHRBZnRlclBvcyh0aGlzLnBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgaW5kZW50YXRpb24gYXQgdGhlIHJlZmVyZW5jZSBsaW5lIGZvciBgdGhpcy5ub2RlYCwgd2hpY2hcbiAgICBpcyB0aGUgbGluZSBvbiB3aGljaCBpdCBzdGFydHMsIHVubGVzcyB0aGVyZSBpcyBhIG5vZGUgdGhhdCBpc1xuICAgIF9ub3RfIGEgcGFyZW50IG9mIHRoaXMgbm9kZSBjb3ZlcmluZyB0aGUgc3RhcnQgb2YgdGhhdCBsaW5lLiBJZlxuICAgIHNvLCB0aGUgbGluZSBhdCB0aGUgc3RhcnQgb2YgdGhhdCBub2RlIGlzIHRyaWVkLCBhZ2FpbiBza2lwcGluZ1xuICAgIG9uIGlmIGl0IGlzIGNvdmVyZWQgYnkgYW5vdGhlciBzdWNoIG5vZGUuXG4gICAgKi9cbiAgICBnZXQgYmFzZUluZGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUluZGVudEZvcih0aGlzLm5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGZvciB0aGUgcmVmZXJlbmNlIGxpbmUgb2YgdGhlIGdpdmVuIG5vZGVcbiAgICAoc2VlIFtgYmFzZUluZGVudGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuVHJlZUluZGVudENvbnRleHQuYmFzZUluZGVudCkpLlxuICAgICovXG4gICAgYmFzZUluZGVudEZvcihub2RlKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KG5vZGUuZnJvbSk7XG4gICAgICAgIC8vIFNraXAgbGluZSBzdGFydHMgdGhhdCBhcmUgY292ZXJlZCBieSBhIHNpYmxpbmcgKG9yIGNvdXNpbiwgZXRjKVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYXRCcmVhayA9IG5vZGUucmVzb2x2ZShsaW5lLmZyb20pO1xuICAgICAgICAgICAgd2hpbGUgKGF0QnJlYWsucGFyZW50ICYmIGF0QnJlYWsucGFyZW50LmZyb20gPT0gYXRCcmVhay5mcm9tKVxuICAgICAgICAgICAgICAgIGF0QnJlYWsgPSBhdEJyZWFrLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChpc1BhcmVudChhdEJyZWFrLCBub2RlKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQoYXRCcmVhay5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5kZW50KGxpbmUuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnRpbnVlIGxvb2tpbmcgZm9yIGluZGVudGF0aW9ucyBpbiB0aGUgbm9kZSdzIHBhcmVudCBub2RlcyxcbiAgICBhbmQgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhhdC5cbiAgICAqL1xuICAgIGNvbnRpbnVlKCkge1xuICAgICAgICByZXR1cm4gaW5kZW50Rm9yKHRoaXMuY29udGV4dC5uZXh0LCB0aGlzLmJhc2UsIHRoaXMucG9zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1BhcmVudChwYXJlbnQsIG9mKSB7XG4gICAgZm9yIChsZXQgY3VyID0gb2Y7IGN1cjsgY3VyID0gY3VyLnBhcmVudClcbiAgICAgICAgaWYgKHBhcmVudCA9PSBjdXIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBDaGVjayB3aGV0aGVyIGEgZGVsaW1pdGVkIG5vZGUgaXMgYWxpZ25lZCAobWVhbmluZyB0aGVyZSBhcmVcbi8vIG5vbi1za2lwcGVkIG5vZGVzIG9uIHRoZSBzYW1lIGxpbmUgYXMgdGhlIG9wZW5pbmcgZGVsaW1pdGVyKS4gQW5kXG4vLyBpZiBzbywgcmV0dXJuIHRoZSBvcGVuaW5nIHRva2VuLlxuZnVuY3Rpb24gYnJhY2tldGVkQWxpZ25lZChjb250ZXh0KSB7XG4gICAgbGV0IHRyZWUgPSBjb250ZXh0Lm5vZGU7XG4gICAgbGV0IG9wZW5Ub2tlbiA9IHRyZWUuY2hpbGRBZnRlcih0cmVlLmZyb20pLCBsYXN0ID0gdHJlZS5sYXN0Q2hpbGQ7XG4gICAgaWYgKCFvcGVuVG9rZW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzaW0gPSBjb250ZXh0Lm9wdGlvbnMuc2ltdWxhdGVCcmVhaztcbiAgICBsZXQgb3BlbkxpbmUgPSBjb250ZXh0LnN0YXRlLmRvYy5saW5lQXQob3BlblRva2VuLmZyb20pO1xuICAgIGxldCBsaW5lRW5kID0gc2ltID09IG51bGwgfHwgc2ltIDw9IG9wZW5MaW5lLmZyb20gPyBvcGVuTGluZS50byA6IE1hdGgubWluKG9wZW5MaW5lLnRvLCBzaW0pO1xuICAgIGZvciAobGV0IHBvcyA9IG9wZW5Ub2tlbi50bzs7KSB7XG4gICAgICAgIGxldCBuZXh0ID0gdHJlZS5jaGlsZEFmdGVyKHBvcyk7XG4gICAgICAgIGlmICghbmV4dCB8fCBuZXh0ID09IGxhc3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFuZXh0LnR5cGUuaXNTa2lwcGVkKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQuZnJvbSA8IGxpbmVFbmQgPyBvcGVuVG9rZW4gOiBudWxsO1xuICAgICAgICBwb3MgPSBuZXh0LnRvO1xuICAgIH1cbn1cbi8qKlxuQW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgZm9yIGRlbGltaXRlZCAodXN1YWxseSBicmFja2V0ZWQpIG5vZGVzLlxuV2lsbCwgYnkgZGVmYXVsdCwgaW5kZW50IG9uZSB1bml0IG1vcmUgdGhhbiB0aGUgcGFyZW50J3MgYmFzZVxuaW5kZW50IHVubGVzcyB0aGUgbGluZSBzdGFydHMgd2l0aCBhIGNsb3NpbmcgdG9rZW4uIFdoZW4gYGFsaWduYFxuaXMgdHJ1ZSBhbmQgdGhlcmUgYXJlIG5vbi1za2lwcGVkIG5vZGVzIG9uIHRoZSBub2RlJ3Mgb3BlbmluZ1xubGluZSwgdGhlIGNvbnRlbnQgb2YgdGhlIG5vZGUgd2lsbCBiZSBhbGlnbmVkIHdpdGggdGhlIGVuZCBvZiB0aGVcbm9wZW5pbmcgbm9kZSwgbGlrZSB0aGlzOlxuXG4gICAgZm9vKGJhcixcbiAgICAgICAgYmF6KVxuKi9cbmZ1bmN0aW9uIGRlbGltaXRlZEluZGVudCh7IGNsb3NpbmcsIGFsaWduID0gdHJ1ZSwgdW5pdHMgPSAxIH0pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IGRlbGltaXRlZFN0cmF0ZWd5KGNvbnRleHQsIGFsaWduLCB1bml0cywgY2xvc2luZyk7XG59XG5mdW5jdGlvbiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcsIGNsb3NlZEF0KSB7XG4gICAgbGV0IGFmdGVyID0gY29udGV4dC50ZXh0QWZ0ZXIsIHNwYWNlID0gYWZ0ZXIubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuICAgIGxldCBjbG9zZWQgPSBjbG9zaW5nICYmIGFmdGVyLnNsaWNlKHNwYWNlLCBzcGFjZSArIGNsb3NpbmcubGVuZ3RoKSA9PSBjbG9zaW5nIHx8IGNsb3NlZEF0ID09IGNvbnRleHQucG9zICsgc3BhY2U7XG4gICAgbGV0IGFsaWduZWQgPSBhbGlnbiA/IGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkgOiBudWxsO1xuICAgIGlmIChhbGlnbmVkKVxuICAgICAgICByZXR1cm4gY2xvc2VkID8gY29udGV4dC5jb2x1bW4oYWxpZ25lZC5mcm9tKSA6IGNvbnRleHQuY29sdW1uKGFsaWduZWQudG8pO1xuICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAoY2xvc2VkID8gMCA6IGNvbnRleHQudW5pdCAqIHVuaXRzKTtcbn1cbi8qKlxuQW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgdGhhdCBhbGlnbnMgYSBub2RlJ3MgY29udGVudCB0byBpdHMgYmFzZVxuaW5kZW50YXRpb24uXG4qL1xuY29uc3QgZmxhdEluZGVudCA9IChjb250ZXh0KSA9PiBjb250ZXh0LmJhc2VJbmRlbnQ7XG4vKipcbkNyZWF0ZXMgYW4gaW5kZW50YXRpb24gc3RyYXRlZ3kgdGhhdCwgYnkgZGVmYXVsdCwgaW5kZW50c1xuY29udGludWVkIGxpbmVzIG9uZSB1bml0IG1vcmUgdGhhbiB0aGUgbm9kZSdzIGJhc2UgaW5kZW50YXRpb24uXG5Zb3UgY2FuIHByb3ZpZGUgYGV4Y2VwdGAgdG8gcHJldmVudCBpbmRlbnRhdGlvbiBvZiBsaW5lcyB0aGF0XG5tYXRjaCBhIHBhdHRlcm4gKGZvciBleGFtcGxlIGAvXmVsc2VcXGIvYCBpbiBgaWZgL2BlbHNlYFxuY29uc3RydWN0cyksIGFuZCB5b3UgY2FuIGNoYW5nZSB0aGUgYW1vdW50IG9mIHVuaXRzIHVzZWQgd2l0aCB0aGVcbmB1bml0c2Agb3B0aW9uLlxuKi9cbmZ1bmN0aW9uIGNvbnRpbnVlZEluZGVudCh7IGV4Y2VwdCwgdW5pdHMgPSAxIH0gPSB7fSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hFeGNlcHQgPSBleGNlcHQgJiYgZXhjZXB0LnRlc3QoY29udGV4dC50ZXh0QWZ0ZXIpO1xuICAgICAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKG1hdGNoRXhjZXB0ID8gMCA6IHVuaXRzICogY29udGV4dC51bml0KTtcbiAgICB9O1xufVxuY29uc3QgRG9udEluZGVudEJleW9uZCA9IDIwMDtcbi8qKlxuRW5hYmxlcyByZWluZGVudGF0aW9uIG9uIGlucHV0LiBXaGVuIGEgbGFuZ3VhZ2UgZGVmaW5lcyBhblxuYGluZGVudE9uSW5wdXRgIGZpZWxkIGluIGl0cyBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLCB3aGljaCBtdXN0IGhvbGQgYSByZWd1bGFyXG5leHByZXNzaW9uLCB0aGUgbGluZSBhdCB0aGUgY3Vyc29yIHdpbGwgYmUgcmVpbmRlbnRlZCB3aGVuZXZlciBuZXdcbnRleHQgaXMgdHlwZWQgYW5kIHRoZSBpbnB1dCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgbGluZSB1cCB0byB0aGVcbmN1cnNvciBtYXRjaGVzIHRoYXQgcmVnZXhwLlxuXG5UbyBhdm9pZCB1bm5lY2Nlc2FyeSByZWluZGVudHMsIGl0IGlzIHJlY29tbWVuZGVkIHRvIHN0YXJ0IHRoZVxucmVnZXhwIHdpdGggYF5gICh1c3VhbGx5IGZvbGxvd2VkIGJ5IGBcXHMqYCksIGFuZCBlbmQgaXQgd2l0aCBgJGAuXG5Gb3IgZXhhbXBsZSwgYC9eXFxzKlxcfSQvYCB3aWxsIHJlaW5kZW50IHdoZW4gYSBjbG9zaW5nIGJyYWNlIGlzXG5hZGRlZCBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lLlxuKi9cbmZ1bmN0aW9uIGluZGVudE9uSW5wdXQoKSB7XG4gICAgcmV0dXJuIEVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRmlsdGVyLm9mKHRyID0+IHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkIHx8ICF0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikgJiYgIXRyLmlzVXNlckV2ZW50KFwiaW5wdXQuY29tcGxldGVcIikpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBydWxlcyA9IHRyLnN0YXJ0U3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJpbmRlbnRPbklucHV0XCIsIHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGlmICghcnVsZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgZG9jID0gdHIubmV3RG9jLCB7IGhlYWQgfSA9IHRyLm5ld1NlbGVjdGlvbi5tYWluLCBsaW5lID0gZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgaWYgKGhlYWQgPiBsaW5lLmZyb20gKyBEb250SW5kZW50QmV5b25kKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgbGluZVN0YXJ0ID0gZG9jLnNsaWNlU3RyaW5nKGxpbmUuZnJvbSwgaGVhZCk7XG4gICAgICAgIGlmICghcnVsZXMuc29tZShyID0+IHIudGVzdChsaW5lU3RhcnQpKSlcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRyLCBsYXN0ID0gLTEsIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBoZWFkIH0gb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGhlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA9PSBsYXN0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGFzdCA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihzdGF0ZSwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBjdXIgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXTtcbiAgICAgICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICAgICAgaWYgKGN1ciAhPSBub3JtKVxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlcy5sZW5ndGggPyBbdHIsIHsgY2hhbmdlcywgc2VxdWVudGlhbDogdHJ1ZSB9XSA6IHRyO1xuICAgIH0pO1xufVxuXG4vKipcbkEgZmFjZXQgdGhhdCByZWdpc3RlcnMgYSBjb2RlIGZvbGRpbmcgc2VydmljZS4gV2hlbiBjYWxsZWQgd2l0aFxudGhlIGV4dGVudCBvZiBhIGxpbmUsIHN1Y2ggYSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgZm9sZGFibGVcbnJhbmdlIHRoYXQgc3RhcnRzIG9uIHRoYXQgbGluZSAoYnV0IGNvbnRpbnVlcyBiZXlvbmQgaXQpLCBpZiBvbmVcbmNhbiBiZSBmb3VuZC5cbiovXG5jb25zdCBmb2xkU2VydmljZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuVGhpcyBub2RlIHByb3AgaXMgdXNlZCB0byBhc3NvY2lhdGUgZm9sZGluZyBpbmZvcm1hdGlvbiB3aXRoXG5zeW50YXggbm9kZSB0eXBlcy4gR2l2ZW4gYSBzeW50YXggbm9kZSwgaXQgc2hvdWxkIGNoZWNrIHdoZXRoZXJcbnRoYXQgdHJlZSBpcyBmb2xkYWJsZSBhbmQgcmV0dXJuIHRoZSByYW5nZSB0aGF0IGNhbiBiZSBjb2xsYXBzZWRcbndoZW4gaXQgaXMuXG4qL1xuY29uc3QgZm9sZE5vZGVQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLyoqXG5bRm9sZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkTm9kZVByb3ApIGZ1bmN0aW9uIHRoYXQgZm9sZHMgZXZlcnl0aGluZyBidXRcbnRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgY2hpbGQgb2YgYSBzeW50YXggbm9kZS4gVXNlZnVsIGZvciBub2Rlc1xudGhhdCBzdGFydCBhbmQgZW5kIHdpdGggZGVsaW1pdGVycy5cbiovXG5mdW5jdGlvbiBmb2xkSW5zaWRlKG5vZGUpIHtcbiAgICBsZXQgZmlyc3QgPSBub2RlLmZpcnN0Q2hpbGQsIGxhc3QgPSBub2RlLmxhc3RDaGlsZDtcbiAgICByZXR1cm4gZmlyc3QgJiYgZmlyc3QudG8gPCBsYXN0LmZyb20gPyB7IGZyb206IGZpcnN0LnRvLCB0bzogbGFzdC50eXBlLmlzRXJyb3IgPyBub2RlLnRvIDogbGFzdC5mcm9tIH0gOiBudWxsO1xufVxuZnVuY3Rpb24gc3ludGF4Rm9sZGluZyhzdGF0ZSwgc3RhcnQsIGVuZCkge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSk7XG4gICAgaWYgKHRyZWUubGVuZ3RoIDwgZW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc3RhY2sgPSB0cmVlLnJlc29sdmVTdGFjayhlbmQsIDEpO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgZm9yIChsZXQgaXRlciA9IHN0YWNrOyBpdGVyOyBpdGVyID0gaXRlci5uZXh0KSB7XG4gICAgICAgIGxldCBjdXIgPSBpdGVyLm5vZGU7XG4gICAgICAgIGlmIChjdXIudG8gPD0gZW5kIHx8IGN1ci5mcm9tID4gZW5kKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChmb3VuZCAmJiBjdXIuZnJvbSA8IHN0YXJ0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBwcm9wID0gY3VyLnR5cGUucHJvcChmb2xkTm9kZVByb3ApO1xuICAgICAgICBpZiAocHJvcCAmJiAoY3VyLnRvIDwgdHJlZS5sZW5ndGggLSA1MCB8fCB0cmVlLmxlbmd0aCA9PSBzdGF0ZS5kb2MubGVuZ3RoIHx8ICFpc1VuZmluaXNoZWQoY3VyKSkpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHByb3AoY3VyLCBzdGF0ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuZnJvbSA8PSBlbmQgJiYgdmFsdWUuZnJvbSA+PSBzdGFydCAmJiB2YWx1ZS50byA+IGVuZClcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGlzVW5maW5pc2hlZChub2RlKSB7XG4gICAgbGV0IGNoID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGNoICYmIGNoLnRvID09IG5vZGUudG8gJiYgY2gudHlwZS5pc0Vycm9yO1xufVxuLyoqXG5DaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBsaW5lIGlzIGZvbGRhYmxlLiBGaXJzdCBhc2tzIGFueSBmb2xkXG5zZXJ2aWNlcyByZWdpc3RlcmVkIHRocm91Z2hcbltgZm9sZFNlcnZpY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRTZXJ2aWNlKSwgYW5kIGlmIG5vbmUgb2YgdGhlbSByZXR1cm5cbmEgcmVzdWx0LCB0cmllcyB0byBxdWVyeSB0aGUgW2ZvbGQgbm9kZVxucHJvcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkTm9kZVByb3ApIG9mIHN5bnRheCBub2RlcyB0aGF0IGNvdmVyIHRoZSBlbmRcbm9mIHRoZSBsaW5lLlxuKi9cbmZ1bmN0aW9uIGZvbGRhYmxlKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpIHtcbiAgICBmb3IgKGxldCBzZXJ2aWNlIG9mIHN0YXRlLmZhY2V0KGZvbGRTZXJ2aWNlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2VydmljZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBzeW50YXhGb2xkaW5nKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpO1xufVxuZnVuY3Rpb24gbWFwUmFuZ2UocmFuZ2UsIG1hcHBpbmcpIHtcbiAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUG9zKHJhbmdlLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUG9zKHJhbmdlLnRvLCAtMSk7XG4gICAgcmV0dXJuIGZyb20gPj0gdG8gPyB1bmRlZmluZWQgOiB7IGZyb20sIHRvIH07XG59XG4vKipcblN0YXRlIGVmZmVjdCB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRvIGZvbGQgdGhlXG5naXZlbiByYW5nZS4gKFlvdSBwcm9iYWJseSBvbmx5IG5lZWQgdGhpcyBpbiBleGNlcHRpb25hbFxuY2lyY3Vtc3RhbmNlc+KAlHVzdWFsbHkgeW91J2xsIGp1c3Qgd2FudCB0byBsZXRcbltgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKSBhbmQgdGhlIFtmb2xkXG5ndXR0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEd1dHRlcikgY3JlYXRlIHRoZSB0cmFuc2FjdGlvbnMuKVxuKi9cbmNvbnN0IGZvbGRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHRoYXQgdW5mb2xkcyB0aGUgZ2l2ZW4gcmFuZ2UgKGlmIGl0IHdhcyBmb2xkZWQpLlxuKi9cbmNvbnN0IHVuZm9sZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6IG1hcFJhbmdlIH0pO1xuZnVuY3Rpb24gc2VsZWN0ZWRMaW5lcyh2aWV3KSB7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgZm9yIChsZXQgeyBoZWFkIH0gb2Ygdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGlmIChsaW5lcy5zb21lKGwgPT4gbC5mcm9tIDw9IGhlYWQgJiYgbC50byA+PSBoZWFkKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsaW5lcy5wdXNoKHZpZXcubGluZUJsb2NrQXQoaGVhZCkpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG59XG4vKipcblRoZSBzdGF0ZSBmaWVsZCB0aGF0IHN0b3JlcyB0aGUgZm9sZGVkIHJhbmdlcyAoYXMgYSBbZGVjb3JhdGlvblxuc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkpLiBDYW4gYmUgcGFzc2VkIHRvXG5bYEVkaXRvclN0YXRlLnRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudG9KU09OKSBhbmRcbltgZnJvbUpTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmZyb21KU09OKSB0byBzZXJpYWxpemUgdGhlIGZvbGRcbnN0YXRlLlxuKi9cbmNvbnN0IGZvbGRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIH0sXG4gICAgdXBkYXRlKGZvbGRlZCwgdHIpIHtcbiAgICAgICAgZm9sZGVkID0gZm9sZGVkLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZS5pcyhmb2xkRWZmZWN0KSAmJiAhZm9sZEV4aXN0cyhmb2xkZWQsIGUudmFsdWUuZnJvbSwgZS52YWx1ZS50bykpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBwcmVwYXJlUGxhY2Vob2xkZXIgfSA9IHRyLnN0YXRlLmZhY2V0KGZvbGRDb25maWcpO1xuICAgICAgICAgICAgICAgIGxldCB3aWRnZXQgPSAhcHJlcGFyZVBsYWNlaG9sZGVyID8gZm9sZFdpZGdldCA6XG4gICAgICAgICAgICAgICAgICAgIERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFByZXBhcmVkRm9sZFdpZGdldChwcmVwYXJlUGxhY2Vob2xkZXIodHIuc3RhdGUsIGUudmFsdWUpKSB9KTtcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgYWRkOiBbd2lkZ2V0LnJhbmdlKGUudmFsdWUuZnJvbSwgZS52YWx1ZS50byldIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5pcyh1bmZvbGRFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGZpbHRlcjogKGZyb20sIHRvKSA9PiBlLnZhbHVlLmZyb20gIT0gZnJvbSB8fCBlLnZhbHVlLnRvICE9IHRvLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcm9tOiBlLnZhbHVlLmZyb20sIGZpbHRlclRvOiBlLnZhbHVlLnRvIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGZvbGRlZCByYW5nZXMgdGhhdCBjb3ZlciB0aGUgc2VsZWN0aW9uIGhlYWRcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IG9uU2VsZWN0aW9uID0gZmFsc2UsIHsgaGVhZCB9ID0gdHIuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICBmb2xkZWQuYmV0d2VlbihoZWFkLCBoZWFkLCAoYSwgYikgPT4geyBpZiAoYSA8IGhlYWQgJiYgYiA+IGhlYWQpXG4gICAgICAgICAgICAgICAgb25TZWxlY3Rpb24gPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIGlmIChvblNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogaGVhZCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVG86IGhlYWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogKGEsIGIpID0+IGIgPD0gaGVhZCB8fCBhID49IGhlYWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9sZGVkO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiksXG4gICAgdG9KU09OKGZvbGRlZCwgc3RhdGUpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb2xkZWQuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHsgcmFuZ2VzLnB1c2goZnJvbSwgdG8pOyB9KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9LFxuICAgIGZyb21KU09OKHZhbHVlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoICUgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIGZvciBmb2xkIHN0YXRlXCIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSB2YWx1ZVtpKytdLCB0byA9IHZhbHVlW2krK107XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGZvbGRXaWRnZXQucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQocmFuZ2VzLCB0cnVlKTtcbiAgICB9XG59KTtcbi8qKlxuR2V0IGEgW3JhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldCkgY29udGFpbmluZyB0aGUgZm9sZGVkIHJhbmdlc1xuaW4gdGhlIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZvbGRlZFJhbmdlcyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fCBSYW5nZVNldC5lbXB0eTtcbn1cbmZ1bmN0aW9uIGZpbmRGb2xkKHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIChfYSA9IHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmV0d2Vlbihmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIGlmICghZm91bmQgfHwgZm91bmQuZnJvbSA+IGZyb20pXG4gICAgICAgICAgICBmb3VuZCA9IHsgZnJvbSwgdG8gfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBmb2xkRXhpc3RzKGZvbGRlZCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBmb2xkZWQuYmV0d2Vlbihmcm9tLCBmcm9tLCAoYSwgYikgPT4geyBpZiAoYSA9PSBmcm9tICYmIGIgPT0gdG8pXG4gICAgICAgIGZvdW5kID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gbWF5YmVFbmFibGUoc3RhdGUsIG90aGVyKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpID8gb3RoZXIgOiBvdGhlci5jb25jYXQoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGNvZGVGb2xkaW5nKCkpKTtcbn1cbi8qKlxuRm9sZCB0aGUgbGluZXMgdGhhdCBhcmUgc2VsZWN0ZWQsIGlmIHBvc3NpYmxlLlxuKi9cbmNvbnN0IGZvbGRDb2RlID0gdmlldyA9PiB7XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCByYW5nZSA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIFtmb2xkRWZmZWN0Lm9mKHJhbmdlKSwgYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlKV0pIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuVW5mb2xkIGZvbGRlZCByYW5nZXMgb24gc2VsZWN0ZWQgbGluZXMuXG4qL1xuY29uc3QgdW5mb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGlmICghdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgIHJldHVybiBlZmZlY3RzLmxlbmd0aCA+IDA7XG59O1xuZnVuY3Rpb24gYW5ub3VuY2VGb2xkKHZpZXcsIHJhbmdlLCBmb2xkID0gdHJ1ZSkge1xuICAgIGxldCBsaW5lRnJvbSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKS5udW1iZXIsIGxpbmVUbyA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50bykubnVtYmVyO1xuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKGZvbGQgPyBcIkZvbGRlZCBsaW5lc1wiIDogXCJVbmZvbGRlZCBsaW5lc1wiKX0gJHtsaW5lRnJvbX0gJHt2aWV3LnN0YXRlLnBocmFzZShcInRvXCIpfSAke2xpbmVUb30uYCk7XG59XG4vKipcbkZvbGQgYWxsIHRvcC1sZXZlbCBmb2xkYWJsZSByYW5nZXMuIE5vdGUgdGhhdCwgaW4gbW9zdCBjYXNlcyxcbmZvbGRpbmcgaW5mb3JtYXRpb24gd2lsbCBkZXBlbmQgb24gdGhlIFtzeW50YXhcbnRyZWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4VHJlZSksIGFuZCBmb2xkaW5nIGV2ZXJ5dGhpbmcgbWF5IG5vdCB3b3JrXG5yZWxpYWJseSB3aGVuIHRoZSBkb2N1bWVudCBoYXNuJ3QgYmVlbiBmdWxseSBwYXJzZWQgKGVpdGhlclxuYmVjYXVzZSB0aGUgZWRpdG9yIHN0YXRlIHdhcyBvbmx5IGp1c3QgaW5pdGlhbGl6ZWQsIG9yIGJlY2F1c2UgdGhlXG5kb2N1bWVudCBpcyBzbyBiaWcgdGhhdCB0aGUgcGFyc2VyIGRlY2lkZWQgbm90IHRvIHBhcnNlIGl0XG5lbnRpcmVseSkuXG4qL1xuY29uc3QgZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgc3RhdGUuZG9jLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyksIHJhbmdlID0gZm9sZGFibGUoc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKHJhbmdlKSk7XG4gICAgICAgIHBvcyA9IChyYW5nZSA/IHZpZXcubGluZUJsb2NrQXQocmFuZ2UudG8pIDogbGluZSkudG8gKyAxO1xuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBlZmZlY3RzKSB9KTtcbiAgICByZXR1cm4gISFlZmZlY3RzLmxlbmd0aDtcbn07XG4vKipcblVuZm9sZCBhbGwgZm9sZGVkIGNvZGUuXG4qL1xuY29uc3QgdW5mb2xkQWxsID0gdmlldyA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5zaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmaWVsZC5iZXR3ZWVuKDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoeyBmcm9tLCB0byB9KSk7IH0pO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8vIEZpbmQgdGhlIGZvbGRhYmxlIHJlZ2lvbiBjb250YWluaW5nIHRoZSBnaXZlbiBsaW5lLCBpZiBvbmUgZXhpc3RzXG5mdW5jdGlvbiBmb2xkYWJsZUNvbnRhaW5lcih2aWV3LCBsaW5lQmxvY2spIHtcbiAgICAvLyBMb29rIGJhY2t3YXJkcyB0aHJvdWdoIGxpbmUgYmxvY2tzIHVudGlsIHdlIGZpbmQgYSBmb2xkYWJsZSByZWdpb24gdGhhdFxuICAgIC8vIGludGVyc2VjdHMgd2l0aCB0aGUgbGluZVxuICAgIGZvciAobGV0IGxpbmUgPSBsaW5lQmxvY2s7Oykge1xuICAgICAgICBsZXQgZm9sZGFibGVSZWdpb24gPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGFibGVSZWdpb24gJiYgZm9sZGFibGVSZWdpb24udG8gPiBsaW5lQmxvY2suZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBmb2xkYWJsZVJlZ2lvbjtcbiAgICAgICAgaWYgKCFsaW5lLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGluZSA9IHZpZXcubGluZUJsb2NrQXQobGluZS5mcm9tIC0gMSk7XG4gICAgfVxufVxuLyoqXG5Ub2dnbGUgZm9sZGluZyBhdCBjdXJzb3JzLiBVbmZvbGRzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGZvbGRcbnN0YXJ0aW5nIGluIHRoYXQgbGluZSwgdHJpZXMgdG8gZmluZCBhIGZvbGRhYmxlIHJhbmdlIGFyb3VuZCBpdFxub3RoZXJ3aXNlLlxuKi9cbmNvbnN0IHRvZ2dsZUZvbGQgPSAodmlldykgPT4ge1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgbGluZSBvZiBzZWxlY3RlZExpbmVzKHZpZXcpKSB7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkZWQsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm9sZFJhbmdlID0gZm9sZGFibGVDb250YWluZXIodmlldywgbGluZSk7XG4gICAgICAgICAgICBpZiAoZm9sZFJhbmdlKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaChmb2xkRWZmZWN0Lm9mKGZvbGRSYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkUmFuZ2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWZmZWN0cy5sZW5ndGggPiAwKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLyoqXG5EZWZhdWx0IGZvbGQtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIEN0cmwtU2hpZnQtWyAoQ21kLUFsdC1bIG9uIG1hY09TKTogW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpLlxuIC0gQ3RybC1TaGlmdC1dIChDbWQtQWx0LV0gb24gbWFjT1MpOiBbYHVuZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnVuZm9sZENvZGUpLlxuIC0gQ3RybC1BbHQtWzogW2Bmb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQWxsKS5cbiAtIEN0cmwtQWx0LV06IFtgdW5mb2xkQWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRBbGwpLlxuKi9cbmNvbnN0IGZvbGRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1bXCIsIG1hYzogXCJDbWQtQWx0LVtcIiwgcnVuOiBmb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtXVwiLCBtYWM6IFwiQ21kLUFsdC1dXCIsIHJ1bjogdW5mb2xkQ29kZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LVtcIiwgcnVuOiBmb2xkQWxsIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtXVwiLCBydW46IHVuZm9sZEFsbCB9XG5dO1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBwbGFjZWhvbGRlckRPTTogbnVsbCxcbiAgICBwcmVwYXJlUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgcGxhY2Vob2xkZXJUZXh0OiBcIuKAplwiXG59O1xuY29uc3QgZm9sZENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiBjb21iaW5lQ29uZmlnKHZhbHVlcywgZGVmYXVsdENvbmZpZyk7IH1cbn0pO1xuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyBjb2RlIGZvbGRpbmcuXG4qL1xuZnVuY3Rpb24gY29kZUZvbGRpbmcoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtmb2xkU3RhdGUsIGJhc2VUaGVtZSQxXTtcbiAgICBpZiAoY29uZmlnKVxuICAgICAgICByZXN1bHQucHVzaChmb2xkQ29uZmlnLm9mKGNvbmZpZykpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3aWRnZXRUb0RPTSh2aWV3LCBwcmVwYXJlZCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoZm9sZENvbmZpZyk7XG4gICAgbGV0IG9uY2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHZpZXcucG9zQXRET00oZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAoZm9sZGVkKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG4gICAgaWYgKGNvbmYucGxhY2Vob2xkZXJET00pXG4gICAgICAgIHJldHVybiBjb25mLnBsYWNlaG9sZGVyRE9NKHZpZXcsIG9uY2xpY2ssIHByZXBhcmVkKTtcbiAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBjb25mLnBsYWNlaG9sZGVyVGV4dDtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc3RhdGUucGhyYXNlKFwiZm9sZGVkIGNvZGVcIikpO1xuICAgIGVsZW1lbnQudGl0bGUgPSBzdGF0ZS5waHJhc2UoXCJ1bmZvbGRcIik7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBcImNtLWZvbGRQbGFjZWhvbGRlclwiO1xuICAgIGVsZW1lbnQub25jbGljayA9IG9uY2xpY2s7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5jb25zdCBmb2xkV2lkZ2V0ID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgICAgICB0b0RPTSh2aWV3KSB7IHJldHVybiB3aWRnZXRUb0RPTSh2aWV3LCBudWxsKTsgfVxuICAgIH0gfSk7XG5jbGFzcyBQcmVwYXJlZEZvbGRXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLnZhbHVlID09IG90aGVyLnZhbHVlOyB9XG4gICAgdG9ET00odmlldykgeyByZXR1cm4gd2lkZ2V0VG9ET00odmlldywgdGhpcy52YWx1ZSk7IH1cbn1cbmNvbnN0IGZvbGRHdXR0ZXJEZWZhdWx0cyA9IHtcbiAgICBvcGVuVGV4dDogXCLijIRcIixcbiAgICBjbG9zZWRUZXh0OiBcIuKAulwiLFxuICAgIG1hcmtlckRPTTogbnVsbCxcbiAgICBkb21FdmVudEhhbmRsZXJzOiB7fSxcbiAgICBmb2xkaW5nQ2hhbmdlZDogKCkgPT4gZmFsc2Vcbn07XG5jbGFzcyBGb2xkTWFya2VyIGV4dGVuZHMgR3V0dGVyTWFya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIG9wZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMub3BlbiA9IG9wZW47XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzLmNvbmZpZyA9PSBvdGhlci5jb25maWcgJiYgdGhpcy5vcGVuID09IG90aGVyLm9wZW47IH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXJrZXJET00pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubWFya2VyRE9NKHRoaXMub3Blbik7XG4gICAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSB0aGlzLm9wZW4gPyB0aGlzLmNvbmZpZy5vcGVuVGV4dCA6IHRoaXMuY29uZmlnLmNsb3NlZFRleHQ7XG4gICAgICAgIHNwYW4udGl0bGUgPSB2aWV3LnN0YXRlLnBocmFzZSh0aGlzLm9wZW4gPyBcIkZvbGQgbGluZVwiIDogXCJVbmZvbGQgbGluZVwiKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIGEgZm9sZCBndXR0ZXIsIHdoaWNoIHNob3dzIGFcbmZvbGQgc3RhdHVzIGluZGljYXRvciBiZWZvcmUgZm9sZGFibGUgbGluZXMgKHdoaWNoIGNhbiBiZSBjbGlja2VkXG50byBmb2xkIG9yIHVuZm9sZCB0aGUgbGluZSkuXG4qL1xuZnVuY3Rpb24gZm9sZEd1dHRlcihjb25maWcgPSB7fSkge1xuICAgIGxldCBmdWxsQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmb2xkR3V0dGVyRGVmYXVsdHMpLCBjb25maWcpO1xuICAgIGxldCBjYW5Gb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgdHJ1ZSksIGNhblVuZm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcbiAgICBsZXQgbWFya2VycyA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdmlldy52aWV3cG9ydC5mcm9tO1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsYW5ndWFnZSkgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxhbmd1YWdlKSB8fFxuICAgICAgICAgICAgICAgIHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpICE9IHVwZGF0ZS5zdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgIHN5bnRheFRyZWUodXBkYXRlLnN0YXJ0U3RhdGUpICE9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSB8fFxuICAgICAgICAgICAgICAgIGZ1bGxDb25maWcuZm9sZGluZ0NoYW5nZWQodXBkYXRlKSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh1cGRhdGUudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRNYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgbGluZSBvZiB2aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKSA/IGNhblVuZm9sZFxuICAgICAgICAgICAgICAgICAgICA6IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5Gb2xkIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAobWFyaylcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRlci5hZGQobGluZS5mcm9tLCBsaW5lLmZyb20sIG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgeyBkb21FdmVudEhhbmRsZXJzIH0gPSBmdWxsQ29uZmlnO1xuICAgIHJldHVybiBbXG4gICAgICAgIG1hcmtlcnMsXG4gICAgICAgIGd1dHRlcih7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1mb2xkR3V0dGVyXCIsXG4gICAgICAgICAgICBtYXJrZXJzKHZpZXcpIHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKG1hcmtlcnMpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya2VycykgfHwgUmFuZ2VTZXQuZW1wdHk7IH0sXG4gICAgICAgICAgICBpbml0aWFsU3BhY2VyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tRXZlbnRIYW5kbGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkb21FdmVudEhhbmRsZXJzKSwgeyBjbGljazogKHZpZXcsIGxpbmUsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21FdmVudEhhbmRsZXJzLmNsaWNrICYmIGRvbUV2ZW50SGFuZGxlcnMuY2xpY2sodmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb2xkZWQgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBmb2xkRWZmZWN0Lm9mKHJhbmdlKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IH0pXG4gICAgICAgIH0pLFxuICAgICAgICBjb2RlRm9sZGluZygpXG4gICAgXTtcbn1cbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1mb2xkUGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2VlZVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNkZGRcIixcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiLjJlbVwiLFxuICAgICAgICBtYXJnaW46IFwiMCAxcHhcIixcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfSxcbiAgICBcIi5jbS1mb2xkR3V0dGVyIHNwYW5cIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjAgMXB4XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9XG59KTtcblxuLyoqXG5BIGhpZ2hsaWdodCBzdHlsZSBhc3NvY2lhdGVzIENTUyBzdHlsZXMgd2l0aCBoaWdsaWdodGluZ1xuW3RhZ3NdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjaGlnaGxpZ2h0LlRhZykuXG4qL1xuY2xhc3MgSGlnaGxpZ2h0U3R5bGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0YWcgc3R5bGVzIHVzZWQgdG8gY3JlYXRlIHRoaXMgaGlnaGxpZ2h0IHN0eWxlLlxuICAgICovXG4gICAgc3BlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zcGVjcyA9IHNwZWNzO1xuICAgICAgICBsZXQgbW9kU3BlYztcbiAgICAgICAgZnVuY3Rpb24gZGVmKHNwZWMpIHtcbiAgICAgICAgICAgIGxldCBjbHMgPSBTdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgICAgICAobW9kU3BlYyB8fCAobW9kU3BlYyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVtcIi5cIiArIGNsc10gPSBzcGVjO1xuICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGwgPSB0eXBlb2Ygb3B0aW9ucy5hbGwgPT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuYWxsIDogb3B0aW9ucy5hbGwgPyBkZWYob3B0aW9ucy5hbGwpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzY29wZU9wdCA9IG9wdGlvbnMuc2NvcGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZU9wdCBpbnN0YW5jZW9mIExhbmd1YWdlID8gKHR5cGUpID0+IHR5cGUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSBzY29wZU9wdC5kYXRhXG4gICAgICAgICAgICA6IHNjb3BlT3B0ID8gKHR5cGUpID0+IHR5cGUgPT0gc2NvcGVPcHQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSB0YWdIaWdobGlnaHRlcihzcGVjcy5tYXAoc3R5bGUgPT4gKHtcbiAgICAgICAgICAgIHRhZzogc3R5bGUudGFnLFxuICAgICAgICAgICAgY2xhc3M6IHN0eWxlLmNsYXNzIHx8IGRlZihPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgeyB0YWc6IG51bGwgfSkpXG4gICAgICAgIH0pKSwge1xuICAgICAgICAgICAgYWxsLFxuICAgICAgICB9KS5zdHlsZTtcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2RTcGVjID8gbmV3IFN0eWxlTW9kdWxlKG1vZFNwZWMpIDogbnVsbDtcbiAgICAgICAgdGhpcy50aGVtZVR5cGUgPSBvcHRpb25zLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgaGlnaGxpZ2h0ZXIgc3R5bGUgdGhhdCBhc3NvY2lhdGVzIHRoZSBnaXZlbiBzdHlsZXMgdG9cbiAgICB0aGUgZ2l2ZW4gdGFncy4gVGhlIHNwZWNzIG11c3QgYmUgb2JqZWN0cyB0aGF0IGhvbGQgYSBzdHlsZSB0YWdcbiAgICBvciBhcnJheSBvZiB0YWdzIGluIHRoZWlyIGB0YWdgIHByb3BlcnR5LCBhbmQgZWl0aGVyIGEgc2luZ2xlXG4gICAgYGNsYXNzYCBwcm9wZXJ0eSBwcm92aWRpbmcgYSBzdGF0aWMgQ1NTIGNsYXNzIChmb3IgaGlnaGxpZ2h0ZXJcbiAgICB0aGF0IHJlbHkgb24gZXh0ZXJuYWwgc3R5bGluZyksIG9yIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKS1zdHlsZVxuICAgIHNldCBvZiBDU1MgcHJvcGVydGllcyAod2hpY2ggZGVmaW5lIHRoZSBzdHlsaW5nIGZvciB0aG9zZSB0YWdzKS5cbiAgICBcbiAgICBUaGUgQ1NTIHJ1bGVzIGNyZWF0ZWQgZm9yIGEgaGlnaGxpZ2h0ZXIgd2lsbCBiZSBlbWl0dGVkIGluIHRoZVxuICAgIG9yZGVyIG9mIHRoZSBzcGVjJ3MgcHJvcGVydGllcy4gVGhhdCBtZWFucyB0aGF0IGZvciBlbGVtZW50cyB0aGF0XG4gICAgaGF2ZSBtdWx0aXBsZSB0YWdzIGFzc29jaWF0ZWQgd2l0aCB0aGVtLCBzdHlsZXMgZGVmaW5lZCBmdXJ0aGVyXG4gICAgZG93biBpbiB0aGUgbGlzdCB3aWxsIGhhdmUgYSBoaWdoZXIgQ1NTIHByZWNlZGVuY2UgdGhhbiBzdHlsZXNcbiAgICBkZWZpbmVkIGVhcmxpZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0U3R5bGUoc3BlY3MsIG9wdGlvbnMgfHwge30pO1xuICAgIH1cbn1cbmNvbnN0IGhpZ2hsaWdodGVyRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBmYWxsYmFja0hpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHsgcmV0dXJuIHZhbHVlcy5sZW5ndGggPyBbdmFsdWVzWzBdXSA6IG51bGw7IH1cbn0pO1xuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0ZXJzKHN0YXRlKSB7XG4gICAgbGV0IG1haW4gPSBzdGF0ZS5mYWNldChoaWdobGlnaHRlckZhY2V0KTtcbiAgICByZXR1cm4gbWFpbi5sZW5ndGggPyBtYWluIDogc3RhdGUuZmFjZXQoZmFsbGJhY2tIaWdobGlnaHRlcik7XG59XG4vKipcbldyYXAgYSBoaWdobGlnaHRlciBpbiBhbiBlZGl0b3IgZXh0ZW5zaW9uIHRoYXQgdXNlcyBpdCB0byBhcHBseVxuc3ludGF4IGhpZ2hsaWdodGluZyB0byB0aGUgZWRpdG9yIGNvbnRlbnQuXG5cbldoZW4gbXVsdGlwbGUgKG5vbi1mYWxsYmFjaykgc3R5bGVzIGFyZSBwcm92aWRlZCwgdGhlIHN0eWxpbmdcbmFwcGxpZWQgaXMgdGhlIHVuaW9uIG9mIHRoZSBjbGFzc2VzIHRoZXkgZW1pdC5cbiovXG5mdW5jdGlvbiBzeW50YXhIaWdobGlnaHRpbmcoaGlnaGxpZ2h0ZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgZXh0ID0gW3RyZWVIaWdobGlnaHRlcl0sIHRoZW1lVHlwZTtcbiAgICBpZiAoaGlnaGxpZ2h0ZXIgaW5zdGFuY2VvZiBIaWdobGlnaHRTdHlsZSkge1xuICAgICAgICBpZiAoaGlnaGxpZ2h0ZXIubW9kdWxlKVxuICAgICAgICAgICAgZXh0LnB1c2goRWRpdG9yVmlldy5zdHlsZU1vZHVsZS5vZihoaWdobGlnaHRlci5tb2R1bGUpKTtcbiAgICAgICAgdGhlbWVUeXBlID0gaGlnaGxpZ2h0ZXIudGhlbWVUeXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrKVxuICAgICAgICBleHQucHVzaChmYWxsYmFja0hpZ2hsaWdodGVyLm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgZWxzZSBpZiAodGhlbWVUeXBlKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0LmNvbXB1dGVOKFtFZGl0b3JWaWV3LmRhcmtUaGVtZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5mYWNldChFZGl0b3JWaWV3LmRhcmtUaGVtZSkgPT0gKHRoZW1lVHlwZSA9PSBcImRhcmtcIikgPyBbaGlnaGxpZ2h0ZXJdIDogW107XG4gICAgICAgIH0pKTtcbiAgICBlbHNlXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodGVyRmFjZXQub2YoaGlnaGxpZ2h0ZXIpKTtcbiAgICByZXR1cm4gZXh0O1xufVxuLyoqXG5SZXR1cm5zIHRoZSBDU1MgY2xhc3NlcyAoaWYgYW55KSB0aGF0IHRoZSBoaWdobGlnaHRlcnMgYWN0aXZlIGluXG50aGUgc3RhdGUgd291bGQgYXNzaWduIHRvIHRoZSBnaXZlbiBzdHlsZVxuW3RhZ3NdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYjaGlnaGxpZ2h0LlRhZykgYW5kXG4ob3B0aW9uYWwpIGxhbmd1YWdlXG5bc2NvcGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSGlnaGxpZ2h0U3R5bGVeZGVmaW5lXm9wdGlvbnMuc2NvcGUpLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodGluZ0ZvcihzdGF0ZSwgdGFncywgc2NvcGUpIHtcbiAgICBsZXQgaGlnaGxpZ2h0ZXJzID0gZ2V0SGlnaGxpZ2h0ZXJzKHN0YXRlKTtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoaGlnaGxpZ2h0ZXJzKVxuICAgICAgICBmb3IgKGxldCBoaWdobGlnaHRlciBvZiBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgICAgIGlmICghaGlnaGxpZ2h0ZXIuc2NvcGUgfHwgc2NvcGUgJiYgaGlnaGxpZ2h0ZXIuc2NvcGUoc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNscyA9IGhpZ2hsaWdodGVyLnN0eWxlKHRhZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IHJlc3VsdCArIFwiIFwiICsgY2xzIDogY2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIFRyZWVIaWdobGlnaHRlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLm1hcmtDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudHJlZSA9IHN5bnRheFRyZWUodmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh2aWV3LCBnZXRIaWdobGlnaHRlcnModmlldy5zdGF0ZSkpO1xuICAgICAgICB0aGlzLmRlY29yYXRlZFRvID0gdmlldy52aWV3cG9ydC50bztcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKSwgaGlnaGxpZ2h0ZXJzID0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGxldCBzdHlsZUNoYW5nZSA9IGhpZ2hsaWdodGVycyAhPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXJ0U3RhdGUpO1xuICAgICAgICBsZXQgeyB2aWV3cG9ydCB9ID0gdXBkYXRlLnZpZXcsIGRlY29yYXRlZFRvTWFwcGVkID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMuZGVjb3JhdGVkVG8sIDEpO1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPCB2aWV3cG9ydC50byAmJiAhc3R5bGVDaGFuZ2UgJiYgdHJlZS50eXBlID09IHRoaXMudHJlZS50eXBlICYmIGRlY29yYXRlZFRvTWFwcGVkID49IHZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0aW9ucy5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZWRUbyA9IGRlY29yYXRlZFRvTWFwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRyZWUgIT0gdGhpcy50cmVlIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgc3R5bGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odXBkYXRlLnZpZXcsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlZFRvID0gdmlld3BvcnQudG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGREZWNvKHZpZXcsIGhpZ2hsaWdodGVycykge1xuICAgICAgICBpZiAoIWhpZ2hsaWdodGVycyB8fCAhdGhpcy50cmVlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRUcmVlKHRoaXMudHJlZSwgaGlnaGxpZ2h0ZXJzLCAoZnJvbSwgdG8sIHN0eWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIHRoaXMubWFya0NhY2hlW3N0eWxlXSB8fCAodGhpcy5tYXJrQ2FjaGVbc3R5bGVdID0gRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IHN0eWxlIH0pKSk7XG4gICAgICAgICAgICB9LCBmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgfVxufVxuY29uc3QgdHJlZUhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ByZWMuaGlnaCgvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoVHJlZUhpZ2hsaWdodGVyLCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSkpO1xuLyoqXG5BIGRlZmF1bHQgaGlnaGxpZ2h0IHN0eWxlICh3b3JrcyB3ZWxsIHdpdGggbGlnaHQgdGhlbWVzKS5cbiovXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5tZXRhLFxuICAgICAgICBjb2xvcjogXCIjNDA0NzQwXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmhlYWRpbmcsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJvbmcsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLFxuICAgICAgICBjb2xvcjogXCIjNzA4XCIgfSxcbiAgICB7IHRhZzogW3RhZ3MuYXRvbSwgdGFncy5ib29sLCB0YWdzLnVybCwgdGFncy5jb250ZW50U2VwYXJhdG9yLCB0YWdzLmxhYmVsTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyMTlcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5saXRlcmFsLCB0YWdzLmluc2VydGVkXSxcbiAgICAgICAgY29sb3I6IFwiIzE2NFwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnN0cmluZywgdGFncy5kZWxldGVkXSxcbiAgICAgICAgY29sb3I6IFwiI2ExMVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSxcbiAgICAgICAgY29sb3I6IFwiI2U0MFwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBmXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMzBhXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MubmFtZXNwYWNlXSxcbiAgICAgICAgY29sb3I6IFwiIzA4NVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLFxuICAgICAgICBjb2xvcjogXCIjMTY3XCIgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgICAgIGNvbG9yOiBcIiMyNTZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCxcbiAgICAgICAgY29sb3I6IFwiIzk0MFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IFwiI2YwMFwiIH1cbl0pO1xuXG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMyOGM4MjUyXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNiYjU1NTU0NFwiIH1cbn0pO1xuY29uc3QgRGVmYXVsdFNjYW5EaXN0ID0gMTAwMDAsIERlZmF1bHRCcmFja2V0cyA9IFwiKClbXXt9XCI7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgYWZ0ZXJDdXJzb3I6IHRydWUsXG4gICAgICAgICAgICBicmFja2V0czogRGVmYXVsdEJyYWNrZXRzLFxuICAgICAgICAgICAgbWF4U2NhbkRpc3RhbmNlOiBEZWZhdWx0U2NhbkRpc3QsXG4gICAgICAgICAgICByZW5kZXJNYXRjaDogZGVmYXVsdFJlbmRlck1hdGNoXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgbWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW1hdGNoaW5nQnJhY2tldFwiIH0pLCBub25tYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbm9ubWF0Y2hpbmdCcmFja2V0XCIgfSk7XG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWF0Y2gobWF0Y2gpIHtcbiAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICBsZXQgbWFyayA9IG1hdGNoLm1hdGNoZWQgPyBtYXRjaGluZ01hcmsgOiBub25tYXRjaGluZ01hcms7XG4gICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLnN0YXJ0LmZyb20sIG1hdGNoLnN0YXJ0LnRvKSk7XG4gICAgaWYgKG1hdGNoLmVuZClcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaChtYXJrLnJhbmdlKG1hdGNoLmVuZC5mcm9tLCBtYXRjaC5lbmQudG8pKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5jb25zdCBicmFja2V0TWF0Y2hpbmdTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gRGVjb3JhdGlvbi5ub25lOyB9LFxuICAgIHVwZGF0ZShkZWNvLCB0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgJiYgIXRyLnNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBkZWNvO1xuICAgICAgICBsZXQgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGJyYWNrZXRNYXRjaGluZ0NvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHRyLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAtMSwgY29uZmlnKVxuICAgICAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSwgY29uZmlnKSlcbiAgICAgICAgICAgICAgICB8fCAoY29uZmlnLmFmdGVyQ3Vyc29yICYmXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkLCAxLCBjb25maWcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocmFuZ2UuaGVhZCA8IHRyLnN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xLCBjb25maWcpKSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgIGRlY29yYXRpb25zID0gZGVjb3JhdGlvbnMuY29uY2F0KGNvbmZpZy5yZW5kZXJNYXRjaChtYXRjaCwgdHIuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjb3JhdGlvbnMsIHRydWUpO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZilcbn0pO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nVW5pcXVlID0gW1xuICAgIGJyYWNrZXRNYXRjaGluZ1N0YXRlLFxuICAgIGJhc2VUaGVtZVxuXTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgYnJhY2tldCBtYXRjaGluZy4gV2hlbmV2ZXIgdGhlXG5jdXJzb3IgaXMgbmV4dCB0byBhIGJyYWNrZXQsIHRoYXQgYnJhY2tldCBhbmQgdGhlIG9uZSBpdCBtYXRjaGVzXG5hcmUgaGlnaGxpZ2h0ZWQuIE9yLCB3aGVuIG5vIG1hdGNoaW5nIGJyYWNrZXQgaXMgZm91bmQsIGFub3RoZXJcbmhpZ2hsaWdodGluZyBzdHlsZSBpcyB1c2VkIHRvIGluZGljYXRlIHRoaXMuXG4qL1xuZnVuY3Rpb24gYnJhY2tldE1hdGNoaW5nKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFticmFja2V0TWF0Y2hpbmdDb25maWcub2YoY29uZmlnKSwgYnJhY2tldE1hdGNoaW5nVW5pcXVlXTtcbn1cbi8qKlxuV2hlbiBsYXJnZXIgc3ludGF4IG5vZGVzLCBzdWNoIGFzIEhUTUwgdGFncywgYXJlIG1hcmtlZCBhc1xub3BlbmluZy9jbG9zaW5nLCBpdCBjYW4gYmUgYSBiaXQgbWVzc3kgdG8gdHJlYXQgdGhlIHdob2xlIG5vZGUgYXNcbmEgbWF0Y2hhYmxlIGJyYWNrZXQuIFRoaXMgbm9kZSBwcm9wIGFsbG93cyB5b3UgdG8gZGVmaW5lLCBmb3Igc3VjaFxuYSBub2RlLCBhIOKAmGhhbmRsZeKAmeKAlHRoZSBwYXJ0IG9mIHRoZSBub2RlIHRoYXQgaXMgaGlnaGxpZ2h0ZWQsIGFuZFxudGhhdCB0aGUgY3Vyc29yIG11c3QgYmUgb24gdG8gYWN0aXZhdGUgaGlnaGxpZ2h0aW5nIGluIHRoZSBmaXJzdFxucGxhY2UuXG4qL1xuY29uc3QgYnJhY2tldE1hdGNoaW5nSGFuZGxlID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuZnVuY3Rpb24gbWF0Y2hpbmdOb2Rlcyhub2RlLCBkaXIsIGJyYWNrZXRzKSB7XG4gICAgbGV0IGJ5UHJvcCA9IG5vZGUucHJvcChkaXIgPCAwID8gTm9kZVByb3Aub3BlbmVkQnkgOiBOb2RlUHJvcC5jbG9zZWRCeSk7XG4gICAgaWYgKGJ5UHJvcClcbiAgICAgICAgcmV0dXJuIGJ5UHJvcDtcbiAgICBpZiAobm9kZS5uYW1lLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGxldCBpbmRleCA9IGJyYWNrZXRzLmluZGV4T2Yobm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEgJiYgaW5kZXggJSAyID09IChkaXIgPCAwID8gMSA6IDApKVxuICAgICAgICAgICAgcmV0dXJuIFticmFja2V0c1tpbmRleCArIGRpcl1dO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRIYW5kbGUobm9kZSkge1xuICAgIGxldCBoYXNIYW5kbGUgPSBub2RlLnR5cGUucHJvcChicmFja2V0TWF0Y2hpbmdIYW5kbGUpO1xuICAgIHJldHVybiBoYXNIYW5kbGUgPyBoYXNIYW5kbGUobm9kZS5ub2RlKSA6IG5vZGU7XG59XG4vKipcbkZpbmQgdGhlIG1hdGNoaW5nIGJyYWNrZXQgZm9yIHRoZSB0b2tlbiBhdCBgcG9zYCwgc2Nhbm5pbmdcbmRpcmVjdGlvbiBgZGlyYC4gT25seSB0aGUgYGJyYWNrZXRzYCBhbmQgYG1heFNjYW5EaXN0YW5jZWBcbnByb3BlcnRpZXMgYXJlIHVzZWQgZnJvbSBgY29uZmlnYCwgaWYgZ2l2ZW4uIFJldHVybnMgbnVsbCBpZiBub1xuYnJhY2tldCB3YXMgZm91bmQgYXQgYHBvc2AsIG9yIGEgbWF0Y2ggcmVzdWx0IG90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBtYXRjaEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY29uZmlnID0ge30pIHtcbiAgICBsZXQgbWF4U2NhbkRpc3RhbmNlID0gY29uZmlnLm1heFNjYW5EaXN0YW5jZSB8fCBEZWZhdWx0U2NhbkRpc3QsIGJyYWNrZXRzID0gY29uZmlnLmJyYWNrZXRzIHx8IERlZmF1bHRCcmFja2V0cztcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCBub2RlID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBkaXIpO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoaW5nTm9kZXMoY3VyLnR5cGUsIGRpciwgYnJhY2tldHMpO1xuICAgICAgICBpZiAobWF0Y2hlcyAmJiBjdXIuZnJvbSA8IGN1ci50bykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZSA9IGZpbmRIYW5kbGUoY3VyKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgJiYgKGRpciA+IDAgPyBwb3MgPj0gaGFuZGxlLmZyb20gJiYgcG9zIDwgaGFuZGxlLnRvIDogcG9zID4gaGFuZGxlLmZyb20gJiYgcG9zIDw9IGhhbmRsZS50bykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoTWFya2VkQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjdXIsIGhhbmRsZSwgbWF0Y2hlcywgYnJhY2tldHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCBub2RlLnR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpO1xufVxuZnVuY3Rpb24gbWF0Y2hNYXJrZWRCcmFja2V0cyhfc3RhdGUsIF9wb3MsIGRpciwgdG9rZW4sIGhhbmRsZSwgbWF0Y2hpbmcsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHBhcmVudCA9IHRva2VuLnBhcmVudCwgZmlyc3RUb2tlbiA9IHsgZnJvbTogaGFuZGxlLmZyb20sIHRvOiBoYW5kbGUudG8gfTtcbiAgICBsZXQgZGVwdGggPSAwLCBjdXJzb3IgPSBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuY3Vyc29yKCk7XG4gICAgaWYgKGN1cnNvciAmJiAoZGlyIDwgMCA/IGN1cnNvci5jaGlsZEJlZm9yZSh0b2tlbi5mcm9tKSA6IGN1cnNvci5jaGlsZEFmdGVyKHRva2VuLnRvKSkpXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChkaXIgPCAwID8gY3Vyc29yLnRvIDw9IHRva2VuLmZyb20gOiBjdXJzb3IuZnJvbSA+PSB0b2tlbi50bykge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwICYmIG1hdGNoaW5nLmluZGV4T2YoY3Vyc29yLnR5cGUubmFtZSkgPiAtMSAmJiBjdXJzb3IuZnJvbSA8IGN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSGFuZGxlID0gZmluZEhhbmRsZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgZW5kOiBlbmRIYW5kbGUgPyB7IGZyb206IGVuZEhhbmRsZS5mcm9tLCB0bzogZW5kSGFuZGxlLnRvIH0gOiB1bmRlZmluZWQsIG1hdGNoZWQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmdOb2RlcyhjdXJzb3IudHlwZSwgLWRpciwgYnJhY2tldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW5kSGFuZGxlID0gZmluZEhhbmRsZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZmlyc3RUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZEhhbmRsZSAmJiBlbmRIYW5kbGUuZnJvbSA8IGVuZEhhbmRsZS50byA/IHsgZnJvbTogZW5kSGFuZGxlLmZyb20sIHRvOiBlbmRIYW5kbGUudG8gfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlyIDwgMCA/IGN1cnNvci5wcmV2U2libGluZygpIDogY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgdG9rZW5UeXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKSB7XG4gICAgbGV0IHN0YXJ0Q2ggPSBkaXIgPCAwID8gc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zKSA6IHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgMSk7XG4gICAgbGV0IGJyYWNrZXQgPSBicmFja2V0cy5pbmRleE9mKHN0YXJ0Q2gpO1xuICAgIGlmIChicmFja2V0IDwgMCB8fCAoYnJhY2tldCAlIDIgPT0gMCkgIT0gKGRpciA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc3RhcnRUb2tlbiA9IHsgZnJvbTogZGlyIDwgMCA/IHBvcyAtIDEgOiBwb3MsIHRvOiBkaXIgPiAwID8gcG9zICsgMSA6IHBvcyB9O1xuICAgIGxldCBpdGVyID0gc3RhdGUuZG9jLml0ZXJSYW5nZShwb3MsIGRpciA+IDAgPyBzdGF0ZS5kb2MubGVuZ3RoIDogMCksIGRlcHRoID0gMDtcbiAgICBmb3IgKGxldCBkaXN0YW5jZSA9IDA7ICEoaXRlci5uZXh0KCkpLmRvbmUgJiYgZGlzdGFuY2UgPD0gbWF4U2NhbkRpc3RhbmNlOykge1xuICAgICAgICBsZXQgdGV4dCA9IGl0ZXIudmFsdWU7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBiYXNlUG9zID0gcG9zICsgZGlzdGFuY2UgKiBkaXI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGRpciA+IDAgPyAwIDogdGV4dC5sZW5ndGggLSAxLCBlbmQgPSBkaXIgPiAwID8gdGV4dC5sZW5ndGggOiAtMTsgcG9zICE9IGVuZDsgcG9zICs9IGRpcikge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gYnJhY2tldHMuaW5kZXhPZih0ZXh0W3Bvc10pO1xuICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCB8fCB0cmVlLnJlc29sdmVJbm5lcihiYXNlUG9zICsgcG9zLCAxKS50eXBlICE9IHRva2VuVHlwZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICgoZm91bmQgJSAyID09IDApID09IChkaXIgPiAwKSkge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA9PSAxKSB7IC8vIENsb3NpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnRUb2tlbiwgZW5kOiB7IGZyb206IGJhc2VQb3MgKyBwb3MsIHRvOiBiYXNlUG9zICsgcG9zICsgMSB9LCBtYXRjaGVkOiAoZm91bmQgPj4gMSkgPT0gKGJyYWNrZXQgPj4gMSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpciA+IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXIuZG9uZSA/IHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH0gOiBudWxsO1xufVxuXG4vLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbi8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXG5mdW5jdGlvbiBjb3VudENvbChzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCA9IDAsIHN0YXJ0VmFsdWUgPSAwKSB7XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcbiAgICAgICAgaWYgKGVuZCA9PSAtMSlcbiAgICAgICAgICAgIGVuZCA9IHN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBuID0gc3RhcnRWYWx1ZTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PSA5KVxuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbisrO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cbi8qKlxuRW5jYXBzdWxhdGVzIGEgc2luZ2xlIGxpbmUgb2YgaW5wdXQuIEdpdmVuIHRvIHN0cmVhbSBzeW50YXggY29kZSxcbndoaWNoIHVzZXMgaXQgdG8gdG9rZW5pemUgdGhlIGNvbnRlbnQuXG4qL1xuY2xhc3MgU3RyaW5nU3RyZWFtIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzdHJlYW0uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbGluZS5cbiAgICAqL1xuICAgIHN0cmluZywgdGFiU2l6ZSwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgaW5kZW50IHVuaXQgc2l6ZS5cbiAgICAqL1xuICAgIGluZGVudFVuaXQsIG92ZXJyaWRlSW5kZW50KSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplO1xuICAgICAgICB0aGlzLmluZGVudFVuaXQgPSBpbmRlbnRVbml0O1xuICAgICAgICB0aGlzLm92ZXJyaWRlSW5kZW50ID0gb3ZlcnJpZGVJbmRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgbGluZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IHRva2VuLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgZW9sKCkgeyByZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgc29sKCkgeyByZXR1cm4gdGhpcy5wb3MgPT0gMDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbmV4dCBjb2RlIHVuaXQgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIG9yIHVuZGVmaW5lZFxuICAgIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBwZWVrKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWQ7IH1cbiAgICAvKipcbiAgICBSZWFkIHRoZSBuZXh0IGNvZGUgdW5pdCBhbmQgYWR2YW5jZSBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIG5leHQgY2hhcmFjdGVyIGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZywgcmVndWxhclxuICAgIGV4cHJlc3Npb24sIG9yIHByZWRpY2F0ZS4gQ29uc3VtZSBhbmQgcmV0dXJuIGl0IGlmIGl0IG1hdGNoZXMuXG4gICAgKi9cbiAgICBlYXQobWF0Y2gpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKTtcbiAgICAgICAgbGV0IG9rO1xuICAgICAgICBpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBvayA9IGNoID09IG1hdGNoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvayA9IGNoICYmIChtYXRjaCBpbnN0YW5jZW9mIFJlZ0V4cCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnRpbnVlIG1hdGNoaW5nIGNoYXJhY3RlcnMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gc3RyaW5nLFxuICAgIHJlZ3VsYXIgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlIGZ1bmN0aW9uLiBSZXR1cm4gdHJ1ZSBpZiBhbnlcbiAgICBjaGFyYWN0ZXJzIHdlcmUgY29uc3VtZWQuXG4gICAgKi9cbiAgICBlYXRXaGlsZShtYXRjaCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25zdW1lIHdoaXRlc3BhY2UgYWhlYWQgb2YgYHRoaXMucG9zYC4gUmV0dXJuIHRydWUgaWYgYW55IHdhc1xuICAgIGZvdW5kLlxuICAgICovXG4gICAgZWF0U3BhY2UoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAoL1tcXHNcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSlcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG9FbmQoKSB7IHRoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byBkaXJlY3RseSBiZWZvcmUgdGhlIGdpdmVuIGNoYXJhY3RlciwgaWYgZm91bmQgb24gdGhlXG4gICAgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgc2tpcFRvKGNoKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gZm91bmQ7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGJhY2sgYG5gIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBiYWNrVXAobikgeyB0aGlzLnBvcyAtPSBuOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIGNvbHVtbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdENvbHVtblBvcyA8IHRoaXMuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2wodGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDb2x1bW5WYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAqL1xuICAgIGluZGVudGF0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm92ZXJyaWRlSW5kZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb3VudENvbCh0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggdGhlIGlucHV0IGFnYWluc3QgdGhlIGdpdmVuIHN0cmluZyBvciByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAod2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggYSBgXmApLiBSZXR1cm4gdHJ1ZSBvciB0aGUgcmVnZXhwIG1hdGNoXG4gICAgaWYgaXQgbWF0Y2hlcy5cbiAgICBcbiAgICBVbmxlc3MgYGNvbnN1bWVgIGlzIHNldCB0byBgZmFsc2VgLCB0aGlzIHdpbGwgbW92ZSBgdGhpcy5wb3NgXG4gICAgcGFzdCB0aGUgbWF0Y2hlZCB0ZXh0LlxuICAgIFxuICAgIFdoZW4gbWF0Y2hpbmcgYSBzdHJpbmcgYGNhc2VJbnNlbnNpdGl2ZWAgY2FuIGJlIHNldCB0byB0cnVlIHRvXG4gICAgbWFrZSB0aGUgbWF0Y2ggY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAqL1xuICAgIG1hdGNoKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IGNhc2VkID0gKHN0cikgPT4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7XG4gICAgICAgICAgICBsZXQgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgKi9cbiAgICBjdXJyZW50KCkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpOyB9XG59XG5cbmZ1bmN0aW9uIGZ1bGxQYXJzZXIoc3BlYykge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHNwZWMubmFtZSB8fCBcIlwiLFxuICAgICAgICB0b2tlbjogc3BlYy50b2tlbixcbiAgICAgICAgYmxhbmtMaW5lOiBzcGVjLmJsYW5rTGluZSB8fCAoKCkgPT4geyB9KSxcbiAgICAgICAgc3RhcnRTdGF0ZTogc3BlYy5zdGFydFN0YXRlIHx8ICgoKSA9PiB0cnVlKSxcbiAgICAgICAgY29weVN0YXRlOiBzcGVjLmNvcHlTdGF0ZSB8fCBkZWZhdWx0Q29weVN0YXRlLFxuICAgICAgICBpbmRlbnQ6IHNwZWMuaW5kZW50IHx8ICgoKSA9PiBudWxsKSxcbiAgICAgICAgbGFuZ3VhZ2VEYXRhOiBzcGVjLmxhbmd1YWdlRGF0YSB8fCB7fSxcbiAgICAgICAgdG9rZW5UYWJsZTogc3BlYy50b2tlblRhYmxlIHx8IG5vVG9rZW5zXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDb3B5U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mIHN0YXRlICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBsZXQgbmV3U3RhdGUgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWwgPSBzdGF0ZVtwcm9wXTtcbiAgICAgICAgbmV3U3RhdGVbcHJvcF0gPSAodmFsIGluc3RhbmNlb2YgQXJyYXkgPyB2YWwuc2xpY2UoKSA6IHZhbCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdTdGF0ZTtcbn1cbmNvbnN0IEluZGVudGVkRnJvbSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLyoqXG5BIFtsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgY2xhc3MgYmFzZWQgb24gYSBDb2RlTWlycm9yXG41LXN0eWxlIFtzdHJlYW1pbmcgcGFyc2VyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbVBhcnNlcikuXG4qL1xuY2xhc3MgU3RyZWFtTGFuZ3VhZ2UgZXh0ZW5kcyBMYW5ndWFnZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChwYXJzZXIubGFuZ3VhZ2VEYXRhKTtcbiAgICAgICAgbGV0IHAgPSBmdWxsUGFyc2VyKHBhcnNlciksIHNlbGY7XG4gICAgICAgIGxldCBpbXBsID0gbmV3IGNsYXNzIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAgICAgICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2Uoc2VsZiwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoZGF0YSwgaW1wbCwgW2luZGVudFNlcnZpY2Uub2YoKGN4LCBwb3MpID0+IHRoaXMuZ2V0SW5kZW50KGN4LCBwb3MpKV0sIHBhcnNlci5uYW1lKTtcbiAgICAgICAgdGhpcy50b3BOb2RlID0gZG9jSUQoZGF0YSk7XG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0cmVhbVBhcnNlciA9IHA7XG4gICAgICAgIHRoaXMuc3RhdGVBZnRlciA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMudG9rZW5UYWJsZSA9IHBhcnNlci50b2tlblRhYmxlID8gbmV3IFRva2VuVGFibGUocC50b2tlblRhYmxlKSA6IGRlZmF1bHRUb2tlblRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBzdHJlYW0gbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHsgcmV0dXJuIG5ldyBTdHJlYW1MYW5ndWFnZShzcGVjKTsgfVxuICAgIGdldEluZGVudChjeCwgcG9zKSB7XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjeC5zdGF0ZSksIGF0ID0gdHJlZS5yZXNvbHZlKHBvcyk7XG4gICAgICAgIHdoaWxlIChhdCAmJiBhdC50eXBlICE9IHRoaXMudG9wTm9kZSlcbiAgICAgICAgICAgIGF0ID0gYXQucGFyZW50O1xuICAgICAgICBpZiAoIWF0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgeyBvdmVycmlkZUluZGVudGF0aW9uIH0gPSBjeC5vcHRpb25zO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbikge1xuICAgICAgICAgICAgZnJvbSA9IEluZGVudGVkRnJvbS5nZXQoY3guc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZyb20gIT0gbnVsbCAmJiBmcm9tIDwgcG9zIC0gMWU0KVxuICAgICAgICAgICAgICAgIGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZmluZFN0YXRlKHRoaXMsIHRyZWUsIDAsIGF0LmZyb20sIGZyb20gIT09IG51bGwgJiYgZnJvbSAhPT0gdm9pZCAwID8gZnJvbSA6IHBvcyksIHN0YXRlUG9zLCBzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXJ0LnN0YXRlO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBzdGFydC5wb3MgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0cmVhbVBhcnNlci5zdGFydFN0YXRlKGN4LnVuaXQpO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgLSBzdGF0ZVBvcyA+IDEwMDAwIC8qIEMuTWF4SW5kZW50U2NhbkRpc3QgKi8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHN0YXRlUG9zIDwgcG9zKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGN4LnN0YXRlLmRvYy5saW5lQXQoc3RhdGVQb3MpLCBlbmQgPSBNYXRoLm1pbihwb3MsIGxpbmUudG8pO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudGF0aW9uID0gb3ZlcnJpZGVJbmRlbnRhdGlvbiA/IG92ZXJyaWRlSW5kZW50YXRpb24obGluZS5mcm9tKSA6IC0xO1xuICAgICAgICAgICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUudGV4dCwgY3guc3RhdGUudGFiU2l6ZSwgY3gudW5pdCwgaW5kZW50YXRpb24gPCAwID8gdW5kZWZpbmVkIDogaW5kZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJlYW0ucG9zIDwgZW5kIC0gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICByZWFkVG9rZW4odGhpcy5zdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHN0YXRlLCBjeC51bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZSA9IGN4LmxpbmVBdChwb3MpO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbiAmJiBmcm9tID09IG51bGwpXG4gICAgICAgICAgICBJbmRlbnRlZEZyb20uc2V0KGN4LnN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1QYXJzZXIuaW5kZW50KHN0YXRlLCAvXlxccyooLiopLy5leGVjKGxpbmUudGV4dClbMV0sIGN4KTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuZnVuY3Rpb24gZmluZFN0YXRlKGxhbmcsIHRyZWUsIG9mZiwgc3RhcnRQb3MsIGJlZm9yZSkge1xuICAgIGxldCBzdGF0ZSA9IG9mZiA+PSBzdGFydFBvcyAmJiBvZmYgKyB0cmVlLmxlbmd0aCA8PSBiZWZvcmUgJiYgdHJlZS5wcm9wKGxhbmcuc3RhdGVBZnRlcik7XG4gICAgaWYgKHN0YXRlKVxuICAgICAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHN0YXRlKSwgcG9zOiBvZmYgKyB0cmVlLmxlbmd0aCB9O1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIHBvcyA9IG9mZiArIHRyZWUucG9zaXRpb25zW2ldO1xuICAgICAgICBsZXQgZm91bmQgPSBjaGlsZCBpbnN0YW5jZW9mIFRyZWUgJiYgcG9zIDwgYmVmb3JlICYmIGZpbmRTdGF0ZShsYW5nLCBjaGlsZCwgcG9zLCBzdGFydFBvcywgYmVmb3JlKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGN1dFRyZWUobGFuZywgdHJlZSwgZnJvbSwgdG8sIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgJiYgZnJvbSA8PSAwICYmIHRvID49IHRyZWUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICBpZiAoIWluc2lkZSAmJiB0cmVlLnR5cGUgPT0gbGFuZy50b3BOb2RlKVxuICAgICAgICBpbnNpZGUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBwb3MgPSB0cmVlLnBvc2l0aW9uc1tpXSwgY2hpbGQgPSB0cmVlLmNoaWxkcmVuW2ldLCBpbm5lcjtcbiAgICAgICAgaWYgKHBvcyA8IHRvICYmIGNoaWxkIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgaWYgKCEoaW5uZXIgPSBjdXRUcmVlKGxhbmcsIGNoaWxkLCBmcm9tIC0gcG9zLCB0byAtIHBvcywgaW5zaWRlKSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICByZXR1cm4gIWluc2lkZSA/IGlubmVyXG4gICAgICAgICAgICAgICAgOiBuZXcgVHJlZSh0cmVlLnR5cGUsIHRyZWUuY2hpbGRyZW4uc2xpY2UoMCwgaSkuY29uY2F0KGlubmVyKSwgdHJlZS5wb3NpdGlvbnMuc2xpY2UoMCwgaSArIDEpLCBwb3MgKyBpbm5lci5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBzdGFydFBvcywgZWRpdG9yU3RhdGUpIHtcbiAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cykge1xuICAgICAgICBsZXQgZnJvbSA9IGYuZnJvbSArIChmLm9wZW5TdGFydCA/IDI1IDogMCksIHRvID0gZi50byAtIChmLm9wZW5FbmQgPyAyNSA6IDApO1xuICAgICAgICBsZXQgZm91bmQgPSBmcm9tIDw9IHN0YXJ0UG9zICYmIHRvID4gc3RhcnRQb3MgJiYgZmluZFN0YXRlKGxhbmcsIGYudHJlZSwgMCAtIGYub2Zmc2V0LCBzdGFydFBvcywgdG8pLCB0cmVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgKHRyZWUgPSBjdXRUcmVlKGxhbmcsIGYudHJlZSwgc3RhcnRQb3MgKyBmLm9mZnNldCwgZm91bmQucG9zICsgZi5vZmZzZXQsIGZhbHNlKSkpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogZm91bmQuc3RhdGUsIHRyZWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdGU6IGxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZWRpdG9yU3RhdGUgPyBnZXRJbmRlbnRVbml0KGVkaXRvclN0YXRlKSA6IDQpLCB0cmVlOiBUcmVlLmVtcHR5IH07XG59XG5jbGFzcyBQYXJzZSB7XG4gICAgY29uc3RydWN0b3IobGFuZywgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubGFuZyA9IGxhbmc7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVuayA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUmV1c2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCksIGZyb20gPSByYW5nZXNbMF0uZnJvbTtcbiAgICAgICAgbGV0IHsgc3RhdGUsIHRyZWUgfSA9IGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgZnJvbSwgY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnN0YXRlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRoaXMuY2h1bmtTdGFydCA9IGZyb20gKyB0cmVlLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRyZWUucG9zaXRpb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA8IGNvbnRleHQudmlld3BvcnQuZnJvbSAtIDEwMDAwMCAvKiBDLk1heERpc3RhbmNlQmVmb3JlVmlld3BvcnQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSk7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgY29udGV4dC52aWV3cG9ydC5mcm9tKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkUG9zID0gY29udGV4dC52aWV3cG9ydC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSW5kZXgoKTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBQYXJzZUNvbnRleHQuZ2V0KCk7XG4gICAgICAgIGxldCBwYXJzZUVuZCA9IHRoaXMuc3RvcHBlZEF0ID09IG51bGwgPyB0aGlzLnRvIDogTWF0aC5taW4odGhpcy50bywgdGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4ocGFyc2VFbmQsIHRoaXMuY2h1bmtTdGFydCArIDIwNDggLyogQy5DaHVua1NpemUgKi8pO1xuICAgICAgICBpZiAoY29udGV4dClcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgY29udGV4dC52aWV3cG9ydC50byk7XG4gICAgICAgIHdoaWxlICh0aGlzLnBhcnNlZFBvcyA8IGVuZClcbiAgICAgICAgICAgIHRoaXMucGFyc2VMaW5lKGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA+PSBwYXJzZUVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiB0aGlzLnBhcnNlZFBvcyA+PSBjb250ZXh0LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICBjb250ZXh0LnNraXBVbnRpbEluVmlldyh0aGlzLnBhcnNlZFBvcywgcGFyc2VFbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgfVxuICAgIGxpbmVBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IGNodW5rID0gdGhpcy5pbnB1dC5jaHVuayhwb3MpO1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQubGluZUNodW5rcykge1xuICAgICAgICAgICAgbGV0IGVvbCA9IGNodW5rLmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICBpZiAoZW9sID4gLTEpXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zbGljZSgwLCBlb2wpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNodW5rID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGNodW5rID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zICsgY2h1bmsubGVuZ3RoIDw9IHRoaXMudG8gPyBjaHVuayA6IGNodW5rLnNsaWNlKDAsIHRoaXMudG8gLSBwb3MpO1xuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnBhcnNlZFBvcywgbGluZSA9IHRoaXMubGluZUFmdGVyKGZyb20pLCBlbmQgPSBmcm9tICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5yYW5nZUluZGV4OzspIHtcbiAgICAgICAgICAgIGxldCByYW5nZUVuZCA9IHRoaXMucmFuZ2VzW2luZGV4XS50bztcbiAgICAgICAgICAgIGlmIChyYW5nZUVuZCA+PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgwLCByYW5nZUVuZCAtIChlbmQgLSBsaW5lLmxlbmd0aCkpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgcmFuZ2VTdGFydCA9IHRoaXMucmFuZ2VzW2luZGV4XS5mcm9tO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5saW5lQWZ0ZXIocmFuZ2VTdGFydCk7XG4gICAgICAgICAgICBsaW5lICs9IGFmdGVyO1xuICAgICAgICAgICAgZW5kID0gcmFuZ2VTdGFydCArIGFmdGVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsaW5lLCBlbmQgfTtcbiAgICB9XG4gICAgc2tpcEdhcHNUbyhwb3MsIG9mZnNldCwgc2lkZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50bywgb2ZmUG9zID0gcG9zICsgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHNpZGUgPiAwID8gZW5kID4gb2ZmUG9zIDogZW5kID49IG9mZlBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XS5mcm9tO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0YXJ0IC0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIG1vdmVSYW5nZUluZGV4KCkge1xuICAgICAgICB3aGlsZSAodGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4XS50byA8IHRoaXMucGFyc2VkUG9zKVxuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4Kys7XG4gICAgfVxuICAgIGVtaXRUb2tlbihpZCwgZnJvbSwgdG8sIHNpemUsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKGZyb20sIG9mZnNldCwgMSk7XG4gICAgICAgICAgICBmcm9tICs9IG9mZnNldDtcbiAgICAgICAgICAgIGxldCBsZW4wID0gdGhpcy5jaHVuay5sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8odG8sIG9mZnNldCwgLTEpO1xuICAgICAgICAgICAgdG8gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc2l6ZSArPSB0aGlzLmNodW5rLmxlbmd0aCAtIGxlbjA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHVuay5wdXNoKGlkLCBmcm9tLCB0bywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIHBhcnNlTGluZShjb250ZXh0KSB7XG4gICAgICAgIGxldCB7IGxpbmUsIGVuZCB9ID0gdGhpcy5uZXh0TGluZSgpLCBvZmZzZXQgPSAwLCB7IHN0cmVhbVBhcnNlciB9ID0gdGhpcy5sYW5nO1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLCBjb250ZXh0ID8gY29udGV4dC5zdGF0ZS50YWJTaXplIDogNCwgY29udGV4dCA/IGdldEluZGVudFVuaXQoY29udGV4dC5zdGF0ZSkgOiAyKTtcbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgc3RyZWFtUGFyc2VyLmJsYW5rTGluZSh0aGlzLnN0YXRlLCBzdHJlYW0uaW5kZW50VW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHJlYWRUb2tlbihzdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmVtaXRUb2tlbih0aGlzLmxhbmcudG9rZW5UYWJsZS5yZXNvbHZlKHRva2VuKSwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0uc3RhcnQsIHRoaXMucGFyc2VkUG9zICsgc3RyZWFtLnBvcywgNCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnN0YXJ0ID4gMTAwMDAgLyogQy5NYXhMaW5lTGVuZ3RoICovKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IGVuZDtcbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRQb3MgPCB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MrKztcbiAgICB9XG4gICAgZmluaXNoQ2h1bmsoKSB7XG4gICAgICAgIGxldCB0cmVlID0gVHJlZS5idWlsZCh7XG4gICAgICAgICAgICBidWZmZXI6IHRoaXMuY2h1bmssXG4gICAgICAgICAgICBzdGFydDogdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLnBhcnNlZFBvcyAtIHRoaXMuY2h1bmtTdGFydCxcbiAgICAgICAgICAgIG5vZGVTZXQsXG4gICAgICAgICAgICB0b3BJRDogMCxcbiAgICAgICAgICAgIG1heEJ1ZmZlckxlbmd0aDogMjA0OCAvKiBDLkNodW5rU2l6ZSAqLyxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5jaHVua1JldXNlZFxuICAgICAgICB9KTtcbiAgICAgICAgdHJlZSA9IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbiwgdHJlZS5wb3NpdGlvbnMsIHRyZWUubGVuZ3RoLCBbW3RoaXMubGFuZy5zdGF0ZUFmdGVyLCB0aGlzLmxhbmcuc3RyZWFtUGFyc2VyLmNvcHlTdGF0ZSh0aGlzLnN0YXRlKV1dKTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaCh0cmVlKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCAtIHRoaXMucmFuZ2VzWzBdLmZyb20pO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IHRoaXMucGFyc2VkUG9zO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0aGlzLmxhbmcudG9wTm9kZSwgdGhpcy5jaHVua3MsIHRoaXMuY2h1bmtQb3MsIHRoaXMucGFyc2VkUG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSkuYmFsYW5jZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlYWRUb2tlbih0b2tlbiwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gcGFyc2VyIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIik7XG59XG5jb25zdCBub1Rva2VucyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgdHlwZUFycmF5ID0gW05vZGVUeXBlLm5vbmVdO1xuY29uc3Qgbm9kZVNldCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVNldCh0eXBlQXJyYXkpO1xuY29uc3Qgd2FybmVkID0gW107XG4vLyBDYWNoZSBvZiBub2RlIHR5cGVzIGJ5IG5hbWUgYW5kIHRhZ3NcbmNvbnN0IGJ5VGFnID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZWZhdWx0VGFibGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZvciAobGV0IFtsZWdhY3lOYW1lLCBuYW1lXSBvZiBbXG4gICAgW1widmFyaWFibGVcIiwgXCJ2YXJpYWJsZU5hbWVcIl0sXG4gICAgW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlTmFtZS5zcGVjaWFsXCJdLFxuICAgIFtcInN0cmluZy0yXCIsIFwic3RyaW5nLnNwZWNpYWxcIl0sXG4gICAgW1wiZGVmXCIsIFwidmFyaWFibGVOYW1lLmRlZmluaXRpb25cIl0sXG4gICAgW1widGFnXCIsIFwidGFnTmFtZVwiXSxcbiAgICBbXCJhdHRyaWJ1dGVcIiwgXCJhdHRyaWJ1dGVOYW1lXCJdLFxuICAgIFtcInR5cGVcIiwgXCJ0eXBlTmFtZVwiXSxcbiAgICBbXCJidWlsdGluXCIsIFwidmFyaWFibGVOYW1lLnN0YW5kYXJkXCJdLFxuICAgIFtcInF1YWxpZmllclwiLCBcIm1vZGlmaWVyXCJdLFxuICAgIFtcImVycm9yXCIsIFwiaW52YWxpZFwiXSxcbiAgICBbXCJoZWFkZXJcIiwgXCJoZWFkaW5nXCJdLFxuICAgIFtcInByb3BlcnR5XCIsIFwicHJvcGVydHlOYW1lXCJdXG5dKVxuICAgIGRlZmF1bHRUYWJsZVtsZWdhY3lOYW1lXSA9IC8qQF9fUFVSRV9fKi9jcmVhdGVUb2tlblR5cGUobm9Ub2tlbnMsIG5hbWUpO1xuY2xhc3MgVG9rZW5UYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZXh0cmEpIHtcbiAgICAgICAgdGhpcy5leHRyYSA9IGV4dHJhO1xuICAgICAgICB0aGlzLnRhYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBkZWZhdWx0VGFibGUpO1xuICAgIH1cbiAgICByZXNvbHZlKHRhZykge1xuICAgICAgICByZXR1cm4gIXRhZyA/IDAgOiB0aGlzLnRhYmxlW3RhZ10gfHwgKHRoaXMudGFibGVbdGFnXSA9IGNyZWF0ZVRva2VuVHlwZSh0aGlzLmV4dHJhLCB0YWcpKTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0VG9rZW5UYWJsZSA9IC8qQF9fUFVSRV9fKi9uZXcgVG9rZW5UYWJsZShub1Rva2Vucyk7XG5mdW5jdGlvbiB3YXJuRm9yUGFydChwYXJ0LCBtc2cpIHtcbiAgICBpZiAod2FybmVkLmluZGV4T2YocGFydCkgPiAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHdhcm5lZC5wdXNoKHBhcnQpO1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5UeXBlKGV4dHJhLCB0YWdTdHIpIHtcbiAgICBsZXQgdGFncyQxID0gW107XG4gICAgZm9yIChsZXQgbmFtZSBvZiB0YWdTdHIuc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIG5hbWUuc3BsaXQoXCIuXCIpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAoZXh0cmFbcGFydF0gfHwgdGFnc1twYXJ0XSk7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYFVua25vd24gaGlnaGxpZ2h0aW5nIHRhZyAke3BhcnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBNb2RpZmllciAke3BhcnR9IHVzZWQgYXQgc3RhcnQgb2YgdGFnYCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLm1hcCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVGFnICR7cGFydH0gdXNlZCBhcyBtb2RpZmllcmApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0YWcgb2YgZm91bmQpXG4gICAgICAgICAgICB0YWdzJDEucHVzaCh0YWcpO1xuICAgIH1cbiAgICBpZiAoIXRhZ3MkMS5sZW5ndGgpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGxldCBuYW1lID0gdGFnU3RyLnJlcGxhY2UoLyAvZywgXCJfXCIpLCBrZXkgPSBuYW1lICsgXCIgXCIgKyB0YWdzJDEubWFwKHQgPT4gdC5pZCk7XG4gICAgbGV0IGtub3duID0gYnlUYWdba2V5XTtcbiAgICBpZiAoa25vd24pXG4gICAgICAgIHJldHVybiBrbm93bi5pZDtcbiAgICBsZXQgdHlwZSA9IGJ5VGFnW2tleV0gPSBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogdHlwZUFycmF5Lmxlbmd0aCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IFtzdHlsZVRhZ3MoeyBbbmFtZV06IHRhZ3MkMSB9KV1cbiAgICB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZS5pZDtcbn1cbmZ1bmN0aW9uIGRvY0lEKGRhdGEpIHtcbiAgICBsZXQgdHlwZSA9IE5vZGVUeXBlLmRlZmluZSh7IGlkOiB0eXBlQXJyYXkubGVuZ3RoLCBuYW1lOiBcIkRvY3VtZW50XCIsIHByb3BzOiBbbGFuZ3VhZ2VEYXRhUHJvcC5hZGQoKCkgPT4gZGF0YSldLCB0b3A6IHRydWUgfSk7XG4gICAgdHlwZUFycmF5LnB1c2godHlwZSk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRm9yTGluZShsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUubGVuZ3RoIDw9IDQwOTYgJiYgL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNcXHVmYjUwLVxcdWZkZmZdLy50ZXN0KGxpbmUpO1xufVxuZnVuY3Rpb24gdGV4dEhhc1JUTCh0ZXh0KSB7XG4gICAgZm9yIChsZXQgaSA9IHRleHQuaXRlcigpOyAhaS5uZXh0KCkuZG9uZTspXG4gICAgICAgIGlmIChidWlsZEZvckxpbmUoaS52YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGFuZ2VBZGRzUlRMKGNoYW5nZSkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGNoYW5nZS5pdGVyQ2hhbmdlcygoZkEsIHRBLCBmQiwgdEIsIGlucykgPT4ge1xuICAgICAgICBpZiAoIWFkZGVkICYmIHRleHRIYXNSVEwoaW5zKSlcbiAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWRkZWQ7XG59XG5jb25zdCBhbHdheXNJc29sYXRlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh4ID0+IHgpIH0pO1xuLyoqXG5NYWtlIHN1cmUgbm9kZXNcblttYXJrZWRdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1vbi5Ob2RlUHJvcF5pc29sYXRlKVxuYXMgaXNvbGF0aW5nIGZvciBiaWRpcmVjdGlvbmFsIHRleHQgYXJlIHJlbmRlcmVkIGluIGEgd2F5IHRoYXRcbmlzb2xhdGVzIHRoZW0gZnJvbSB0aGUgc3Vycm91bmRpbmcgdGV4dC5cbiovXG5mdW5jdGlvbiBiaWRpSXNvbGF0ZXMob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGV4dGVuc2lvbnMgPSBbaXNvbGF0ZU1hcmtzXTtcbiAgICBpZiAob3B0aW9ucy5hbHdheXNJc29sYXRlKVxuICAgICAgICBleHRlbnNpb25zLnB1c2goYWx3YXlzSXNvbGF0ZS5vZih0cnVlKSk7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG59XG5jb25zdCBpc29sYXRlTWFya3MgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5hbHdheXMgPSB2aWV3LnN0YXRlLmZhY2V0KGFsd2F5c0lzb2xhdGUpIHx8XG4gICAgICAgICAgICB2aWV3LnRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiB8fFxuICAgICAgICAgICAgdmlldy5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNSVEwgPSAhdGhpcy5hbHdheXMgJiYgdGV4dEhhc1JUTCh2aWV3LnN0YXRlLmRvYyk7XG4gICAgICAgIHRoaXMudHJlZSA9IHN5bnRheFRyZWUodmlldy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmFsd2F5cyB8fCB0aGlzLmhhc1JUTCA/IGJ1aWxkRGVjbyh2aWV3LCB0aGlzLnRyZWUsIHRoaXMuYWx3YXlzKSA6IERlY29yYXRpb24ubm9uZTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgYWx3YXlzID0gdXBkYXRlLnN0YXRlLmZhY2V0KGFsd2F5c0lzb2xhdGUpIHx8XG4gICAgICAgICAgICB1cGRhdGUudmlldy50ZXh0RGlyZWN0aW9uICE9IERpcmVjdGlvbi5MVFIgfHxcbiAgICAgICAgICAgIHVwZGF0ZS5zdGF0ZS5mYWNldChFZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKCFhbHdheXMgJiYgIXRoaXMuaGFzUlRMICYmIGNoYW5nZUFkZHNSVEwodXBkYXRlLmNoYW5nZXMpKVxuICAgICAgICAgICAgdGhpcy5oYXNSVEwgPSB0cnVlO1xuICAgICAgICBpZiAoIWFsd2F5cyAmJiAhdGhpcy5oYXNSVEwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpO1xuICAgICAgICBpZiAoYWx3YXlzICE9IHRoaXMuYWx3YXlzIHx8IHRyZWUgIT0gdGhpcy50cmVlIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmFsd2F5cyA9IGFsd2F5cztcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBidWlsZERlY28odXBkYXRlLnZpZXcsIHRyZWUsIGFsd2F5cyk7XG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IHtcbiAgICAgICAgZnVuY3Rpb24gYWNjZXNzKHZpZXcpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdmlldy5wbHVnaW4ocGx1Z2luKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlY29yYXRpb25zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtFZGl0b3JWaWV3Lm91dGVyRGVjb3JhdGlvbnMub2YoYWNjZXNzKSxcbiAgICAgICAgICAgIFByZWMubG93ZXN0KEVkaXRvclZpZXcuYmlkaUlzb2xhdGVkUmFuZ2VzLm9mKGFjY2VzcykpXTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGJ1aWxkRGVjbyh2aWV3LCB0cmVlLCBhbHdheXMpIHtcbiAgICBsZXQgZGVjbyA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICBsZXQgcmFuZ2VzID0gdmlldy52aXNpYmxlUmFuZ2VzO1xuICAgIGlmICghYWx3YXlzKVxuICAgICAgICByYW5nZXMgPSBjbGlwUlRMTGluZXMocmFuZ2VzLCB2aWV3LnN0YXRlLmRvYyk7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHJhbmdlcykge1xuICAgICAgICB0cmVlLml0ZXJhdGUoe1xuICAgICAgICAgICAgZW50ZXI6IG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpc28gPSBub2RlLnR5cGUucHJvcChOb2RlUHJvcC5pc29sYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNvKVxuICAgICAgICAgICAgICAgICAgICBkZWNvLmFkZChub2RlLmZyb20sIG5vZGUudG8sIG1hcmtzW2lzb10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb20sIHRvXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVjby5maW5pc2goKTtcbn1cbmZ1bmN0aW9uIGNsaXBSVExMaW5lcyhyYW5nZXMsIGRvYykge1xuICAgIGxldCBjdXIgPSBkb2MuaXRlcigpLCBwb3MgPSAwLCByZXN1bHQgPSBbXSwgbGFzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHJhbmdlcykge1xuICAgICAgICBpZiAoZnJvbSAhPSBwb3MpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGN1ci5uZXh0KGZyb20gLSBwb3MpO1xuICAgICAgICAgICAgcG9zID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBwb3MsIGVuZCA9IHBvcyArIGN1ci52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIWN1ci5saW5lQnJlYWsgJiYgYnVpbGRGb3JMaW5lKGN1ci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnRvID4gc3RhcnQgLSAxMClcbiAgICAgICAgICAgICAgICAgICAgbGFzdC50byA9IE1hdGgubWluKHRvLCBlbmQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGFzdCA9IHsgZnJvbTogc3RhcnQsIHRvOiBNYXRoLm1pbih0bywgZW5kKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgICBjdXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBtYXJrcyA9IHtcbiAgICBydGw6IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1pc29cIiwgaW5jbHVzaXZlOiB0cnVlLCBhdHRyaWJ1dGVzOiB7IGRpcjogXCJydGxcIiB9LCBiaWRpSXNvbGF0ZTogRGlyZWN0aW9uLlJUTCB9KSxcbiAgICBsdHI6IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1pc29cIiwgaW5jbHVzaXZlOiB0cnVlLCBhdHRyaWJ1dGVzOiB7IGRpcjogXCJsdHJcIiB9LCBiaWRpSXNvbGF0ZTogRGlyZWN0aW9uLkxUUiB9KSxcbiAgICBhdXRvOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taXNvXCIsIGluY2x1c2l2ZTogdHJ1ZSwgYXR0cmlidXRlczogeyBkaXI6IFwiYXV0b1wiIH0sIGJpZGlJc29sYXRlOiBudWxsIH0pXG59O1xuXG5leHBvcnQgeyBEb2NJbnB1dCwgSGlnaGxpZ2h0U3R5bGUsIEluZGVudENvbnRleHQsIExSTGFuZ3VhZ2UsIExhbmd1YWdlLCBMYW5ndWFnZURlc2NyaXB0aW9uLCBMYW5ndWFnZVN1cHBvcnQsIFBhcnNlQ29udGV4dCwgU3RyZWFtTGFuZ3VhZ2UsIFN0cmluZ1N0cmVhbSwgVHJlZUluZGVudENvbnRleHQsIGJpZGlJc29sYXRlcywgYnJhY2tldE1hdGNoaW5nLCBicmFja2V0TWF0Y2hpbmdIYW5kbGUsIGNvZGVGb2xkaW5nLCBjb250aW51ZWRJbmRlbnQsIGRlZmF1bHRIaWdobGlnaHRTdHlsZSwgZGVmaW5lTGFuZ3VhZ2VGYWNldCwgZGVsaW1pdGVkSW5kZW50LCBlbnN1cmVTeW50YXhUcmVlLCBmbGF0SW5kZW50LCBmb2xkQWxsLCBmb2xkQ29kZSwgZm9sZEVmZmVjdCwgZm9sZEd1dHRlciwgZm9sZEluc2lkZSwgZm9sZEtleW1hcCwgZm9sZE5vZGVQcm9wLCBmb2xkU2VydmljZSwgZm9sZFN0YXRlLCBmb2xkYWJsZSwgZm9sZGVkUmFuZ2VzLCBmb3JjZVBhcnNpbmcsIGdldEluZGVudFVuaXQsIGdldEluZGVudGF0aW9uLCBoaWdobGlnaHRpbmdGb3IsIGluZGVudE5vZGVQcm9wLCBpbmRlbnRPbklucHV0LCBpbmRlbnRSYW5nZSwgaW5kZW50U2VydmljZSwgaW5kZW50U3RyaW5nLCBpbmRlbnRVbml0LCBsYW5ndWFnZSwgbGFuZ3VhZ2VEYXRhUHJvcCwgbWF0Y2hCcmFja2V0cywgc3VibGFuZ3VhZ2VQcm9wLCBzeW50YXhIaWdobGlnaHRpbmcsIHN5bnRheFBhcnNlclJ1bm5pbmcsIHN5bnRheFRyZWUsIHN5bnRheFRyZWVBdmFpbGFibGUsIHRvZ2dsZUZvbGQsIHVuZm9sZEFsbCwgdW5mb2xkQ29kZSwgdW5mb2xkRWZmZWN0IH07XG4iXSwibmFtZXMiOlsiTm9kZVByb3AiLCJJdGVyTW9kZSIsIlRyZWUiLCJUcmVlRnJhZ21lbnQiLCJQYXJzZXIiLCJOb2RlVHlwZSIsIk5vZGVTZXQiLCJTdGF0ZUVmZmVjdCIsIlN0YXRlRmllbGQiLCJGYWNldCIsIkVkaXRvclN0YXRlIiwiY291bnRDb2x1bW4iLCJjb21iaW5lQ29uZmlnIiwiUmFuZ2VTZXQiLCJSYW5nZVNldEJ1aWxkZXIiLCJQcmVjIiwiVmlld1BsdWdpbiIsImxvZ0V4Y2VwdGlvbiIsIkVkaXRvclZpZXciLCJEZWNvcmF0aW9uIiwiV2lkZ2V0VHlwZSIsImd1dHRlciIsIkd1dHRlck1hcmtlciIsIkRpcmVjdGlvbiIsInRhZ3MiLCJ0YWdIaWdobGlnaHRlciIsImhpZ2hsaWdodFRyZWUiLCJzdHlsZVRhZ3MiLCJTdHlsZU1vZHVsZSIsIl9hIiwibGFuZ3VhZ2VEYXRhUHJvcCIsImRlZmluZUxhbmd1YWdlRmFjZXQiLCJiYXNlRGF0YSIsImRlZmluZSIsImNvbWJpbmUiLCJ2YWx1ZXMiLCJjb25jYXQiLCJ1bmRlZmluZWQiLCJzdWJsYW5ndWFnZVByb3AiLCJMYW5ndWFnZSIsImNvbnN0cnVjdG9yIiwiZGF0YSIsInBhcnNlciIsImV4dHJhRXh0ZW5zaW9ucyIsIm5hbWUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic3ludGF4VHJlZSIsImV4dGVuc2lvbiIsImxhbmd1YWdlIiwib2YiLCJsYW5ndWFnZURhdGEiLCJzdGF0ZSIsInBvcyIsInNpZGUiLCJ0b3AiLCJ0b3BOb2RlQXQiLCJ0eXBlIiwicHJvcCIsImJhc2UiLCJmYWNldCIsInN1YiIsImlubmVyTm9kZSIsInJlc29sdmUiLCJmcm9tIiwic3VibGFuZyIsInRlc3QiLCJpc0FjdGl2ZUF0IiwiZmluZFJlZ2lvbnMiLCJsYW5nIiwidG8iLCJkb2MiLCJsZW5ndGgiLCJhbGxvd3NOZXN0aW5nIiwicmVzdWx0IiwiZXhwbG9yZSIsInRyZWUiLCJwdXNoIiwibW91bnQiLCJtb3VudGVkIiwib3ZlcmxheSIsInIiLCJzaXplIiwiaSIsImNoaWxkcmVuIiwiY2giLCJwb3NpdGlvbnMiLCJzZXRTdGF0ZSIsInRvcExhbmciLCJ0b3BOb2RlIiwibm9kZSIsImVudGVyIiwiRXhjbHVkZUJ1ZmZlcnMiLCJpc1RvcCIsIkxSTGFuZ3VhZ2UiLCJzcGVjIiwiY29uZmlndXJlIiwicHJvcHMiLCJhZGQiLCJvcHRpb25zIiwiaGFzV3JhcHBlcnMiLCJmaWVsZCIsImVtcHR5IiwiZW5zdXJlU3ludGF4VHJlZSIsInVwdG8iLCJ0aW1lb3V0IiwicGFyc2UiLCJjb250ZXh0Iiwib2xkVmllcG9ydCIsInZpZXdwb3J0IiwidXBkYXRlVmlld3BvcnQiLCJpc0RvbmUiLCJ3b3JrIiwic3ludGF4VHJlZUF2YWlsYWJsZSIsImZvcmNlUGFyc2luZyIsInZpZXciLCJzdWNjZXNzIiwiZGlzcGF0Y2giLCJzeW50YXhQYXJzZXJSdW5uaW5nIiwicGx1Z2luIiwicGFyc2VXb3JrZXIiLCJpc1dvcmtpbmciLCJEb2NJbnB1dCIsImN1cnNvclBvcyIsInN0cmluZyIsImN1cnNvciIsIml0ZXIiLCJzeW5jVG8iLCJuZXh0IiwidmFsdWUiLCJjaHVuayIsImxpbmVDaHVua3MiLCJyZWFkIiwic3RyaW5nU3RhcnQiLCJzbGljZVN0cmluZyIsInNsaWNlIiwiY3VycmVudENvbnRleHQiLCJQYXJzZUNvbnRleHQiLCJmcmFnbWVudHMiLCJ0cmVlTGVuIiwic2tpcHBlZCIsInNjaGVkdWxlT24iLCJ0ZW1wU2tpcHBlZCIsImNyZWF0ZSIsInN0YXJ0UGFyc2UiLCJ1bnRpbCIsInRha2VUcmVlIiwid2l0aENvbnRleHQiLCJlbmRUaW1lIiwiRGF0ZSIsIm5vdyIsInN0b3BwZWRBdCIsInN0b3BBdCIsImRvbmUiLCJhZHZhbmNlIiwid2l0aG91dFRlbXBTa2lwcGVkIiwiYWRkVHJlZSIsInBhcnNlZFBvcyIsImYiLCJwcmV2IiwicG9wIiwiY3V0RnJhZ21lbnRzIiwiY2hhbmdlcyIsIm5ld1N0YXRlIiwicmFuZ2VzIiwiaXRlckNoYW5nZWRSYW5nZXMiLCJmcm9tQSIsInRvQSIsImZyb21CIiwidG9CIiwiYXBwbHlDaGFuZ2VzIiwibWFwUG9zIiwic3RhcnRMZW4iLCJzcGxpY2UiLCJyZXNldCIsInNraXBVbnRpbEluVmlldyIsImdldFNraXBwaW5nUGFyc2VyIiwiY3JlYXRlUGFyc2UiLCJpbnB1dCIsImN4IiwiUHJvbWlzZSIsImFsbCIsIm5vbmUiLCJNYXRoIiwibWluIiwiZnJhZ3MiLCJMYW5ndWFnZVN0YXRlIiwiYXBwbHkiLCJ0ciIsImRvY0NoYW5nZWQiLCJuZXdDeCIsInN0YXJ0U3RhdGUiLCJtYXgiLCJpbml0IiwidnBUbyIsInBhcnNlU3RhdGUiLCJ1cGRhdGUiLCJlIiwiZWZmZWN0cyIsImlzIiwicmVxdWVzdElkbGUiLCJjYWxsYmFjayIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiaWRsZSIsImNhbmNlbElkbGVDYWxsYmFjayIsImlzSW5wdXRQZW5kaW5nIiwibmF2aWdhdG9yIiwic2NoZWR1bGluZyIsImZyb21DbGFzcyIsIlBhcnNlV29ya2VyIiwid29ya2luZyIsIndvcmtTY2hlZHVsZWQiLCJjaHVua0VuZCIsImNodW5rQnVkZ2V0IiwiYmluZCIsInNjaGVkdWxlV29yayIsInNlbGVjdGlvblNldCIsImhhc0ZvY3VzIiwiY2hlY2tBc3luY1NjaGVkdWxlIiwiZGVhZGxpbmUiLCJ0aW1lUmVtYWluaW5nIiwidmlld3BvcnRGaXJzdCIsInRoZW4iLCJjYXRjaCIsImVyciIsImRlc3Ryb3kiLCJldmVudEhhbmRsZXJzIiwiZm9jdXMiLCJsYW5ndWFnZXMiLCJlbmFibGVzIiwiY29udGVudEF0dHJpYnV0ZXMiLCJjb21wdXRlIiwiTGFuZ3VhZ2VTdXBwb3J0Iiwic3VwcG9ydCIsIkxhbmd1YWdlRGVzY3JpcHRpb24iLCJhbGlhcyIsImV4dGVuc2lvbnMiLCJmaWxlbmFtZSIsImxvYWRGdW5jIiwibG9hZGluZyIsImxvYWQiLCJSYW5nZUVycm9yIiwibWFwIiwicyIsInRvTG93ZXJDYXNlIiwibWF0Y2hGaWxlbmFtZSIsImRlc2NzIiwiZCIsImV4dCIsImV4ZWMiLCJpbmRleE9mIiwibWF0Y2hMYW5ndWFnZU5hbWUiLCJmdXp6eSIsInNvbWUiLCJhIiwiZm91bmQiLCJpbmRlbnRTZXJ2aWNlIiwiaW5kZW50VW5pdCIsInVuaXQiLCJBcnJheSIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldEluZGVudFVuaXQiLCJjaGFyQ29kZUF0IiwidGFiU2l6ZSIsImluZGVudFN0cmluZyIsImNvbHMiLCJ0cyIsImdldEluZGVudGF0aW9uIiwiSW5kZW50Q29udGV4dCIsInNlcnZpY2UiLCJzeW50YXhJbmRlbnRhdGlvbiIsImluZGVudFJhbmdlIiwidXBkYXRlZCIsIm92ZXJyaWRlSW5kZW50YXRpb24iLCJzdGFydCIsImxpbmUiLCJsaW5lQXQiLCJpbmRlbnQiLCJ0ZXh0IiwiY3VyIiwibm9ybSIsImluc2VydCIsImJpYXMiLCJzaW11bGF0ZUJyZWFrIiwic2ltdWxhdGVEb3VibGVCcmVhayIsInRleHRBZnRlclBvcyIsImNvbHVtbiIsIm92ZXJyaWRlIiwic2VhcmNoIiwibGluZUluZGVudCIsIm92ZXJyaWRlbiIsInNpbXVsYXRlZEJyZWFrIiwiaW5kZW50Tm9kZVByb3AiLCJhc3QiLCJzdGFjayIsInJlc29sdmVTdGFjayIsImlubmVyIiwiZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUiLCJwYXJlbnQiLCJpbmRlbnRGb3IiLCJzdHJhdGVneSIsImluZGVudFN0cmF0ZWd5IiwiVHJlZUluZGVudENvbnRleHQiLCJpZ25vcmVDbG9zZWQiLCJmaXJzdCIsImZpcnN0Q2hpbGQiLCJjbG9zZSIsImNsb3NlZEJ5IiwibGFzdCIsImxhc3RDaGlsZCIsImNsb3NlZCIsImRlbGltaXRlZFN0cmF0ZWd5IiwidG9wSW5kZW50IiwidGV4dEFmdGVyIiwiYmFzZUluZGVudCIsImJhc2VJbmRlbnRGb3IiLCJhdEJyZWFrIiwiaXNQYXJlbnQiLCJjb250aW51ZSIsImJyYWNrZXRlZEFsaWduZWQiLCJvcGVuVG9rZW4iLCJjaGlsZEFmdGVyIiwic2ltIiwib3BlbkxpbmUiLCJsaW5lRW5kIiwiaXNTa2lwcGVkIiwiZGVsaW1pdGVkSW5kZW50IiwiY2xvc2luZyIsImFsaWduIiwidW5pdHMiLCJjbG9zZWRBdCIsImFmdGVyIiwic3BhY2UiLCJtYXRjaCIsImFsaWduZWQiLCJmbGF0SW5kZW50IiwiY29udGludWVkSW5kZW50IiwiZXhjZXB0IiwibWF0Y2hFeGNlcHQiLCJEb250SW5kZW50QmV5b25kIiwiaW5kZW50T25JbnB1dCIsInRyYW5zYWN0aW9uRmlsdGVyIiwiaXNVc2VyRXZlbnQiLCJydWxlcyIsImxhbmd1YWdlRGF0YUF0Iiwic2VsZWN0aW9uIiwibWFpbiIsImhlYWQiLCJuZXdEb2MiLCJuZXdTZWxlY3Rpb24iLCJsaW5lU3RhcnQiLCJzZXF1ZW50aWFsIiwiZm9sZFNlcnZpY2UiLCJmb2xkTm9kZVByb3AiLCJmb2xkSW5zaWRlIiwiaXNFcnJvciIsInN5bnRheEZvbGRpbmciLCJlbmQiLCJpc1VuZmluaXNoZWQiLCJmb2xkYWJsZSIsIm1hcFJhbmdlIiwicmFuZ2UiLCJtYXBwaW5nIiwiZm9sZEVmZmVjdCIsInVuZm9sZEVmZmVjdCIsInNlbGVjdGVkTGluZXMiLCJsaW5lcyIsImwiLCJsaW5lQmxvY2tBdCIsImZvbGRTdGF0ZSIsImZvbGRlZCIsImZvbGRFeGlzdHMiLCJwcmVwYXJlUGxhY2Vob2xkZXIiLCJmb2xkQ29uZmlnIiwid2lkZ2V0IiwiZm9sZFdpZGdldCIsInJlcGxhY2UiLCJQcmVwYXJlZEZvbGRXaWRnZXQiLCJmaWx0ZXIiLCJmaWx0ZXJGcm9tIiwiZmlsdGVyVG8iLCJvblNlbGVjdGlvbiIsImJldHdlZW4iLCJiIiwicHJvdmlkZSIsImRlY29yYXRpb25zIiwidG9KU09OIiwiZnJvbUpTT04iLCJpc0FycmF5Iiwic2V0IiwiZm9sZGVkUmFuZ2VzIiwiZmluZEZvbGQiLCJtYXliZUVuYWJsZSIsIm90aGVyIiwiYXBwZW5kQ29uZmlnIiwiY29kZUZvbGRpbmciLCJmb2xkQ29kZSIsImFubm91bmNlRm9sZCIsInVuZm9sZENvZGUiLCJmb2xkIiwibGluZUZyb20iLCJudW1iZXIiLCJsaW5lVG8iLCJhbm5vdW5jZSIsInBocmFzZSIsImZvbGRBbGwiLCJ1bmZvbGRBbGwiLCJmb2xkYWJsZUNvbnRhaW5lciIsImxpbmVCbG9jayIsImZvbGRhYmxlUmVnaW9uIiwidG9nZ2xlRm9sZCIsImZvbGRSYW5nZSIsImZvbGRLZXltYXAiLCJrZXkiLCJtYWMiLCJydW4iLCJkZWZhdWx0Q29uZmlnIiwicGxhY2Vob2xkZXJET00iLCJwbGFjZWhvbGRlclRleHQiLCJjb25maWciLCJiYXNlVGhlbWUkMSIsIndpZGdldFRvRE9NIiwicHJlcGFyZWQiLCJjb25mIiwib25jbGljayIsImV2ZW50IiwicG9zQXRET00iLCJ0YXJnZXQiLCJwcmV2ZW50RGVmYXVsdCIsImVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ0ZXh0Q29udGVudCIsInNldEF0dHJpYnV0ZSIsInRpdGxlIiwiY2xhc3NOYW1lIiwidG9ET00iLCJlcSIsImZvbGRHdXR0ZXJEZWZhdWx0cyIsIm9wZW5UZXh0IiwiY2xvc2VkVGV4dCIsIm1hcmtlckRPTSIsImRvbUV2ZW50SGFuZGxlcnMiLCJmb2xkaW5nQ2hhbmdlZCIsIkZvbGRNYXJrZXIiLCJvcGVuIiwic3BhbiIsImZvbGRHdXR0ZXIiLCJmdWxsQ29uZmlnIiwiYXNzaWduIiwiY2FuRm9sZCIsImNhblVuZm9sZCIsIm1hcmtlcnMiLCJidWlsZE1hcmtlcnMiLCJ2aWV3cG9ydENoYW5nZWQiLCJidWlsZGVyIiwidmlld3BvcnRMaW5lQmxvY2tzIiwibWFyayIsImZpbmlzaCIsImNsYXNzIiwiaW5pdGlhbFNwYWNlciIsImNsaWNrIiwiYmFzZVRoZW1lIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwiY29sb3IiLCJib3JkZXJSYWRpdXMiLCJtYXJnaW4iLCJwYWRkaW5nIiwiSGlnaGxpZ2h0U3R5bGUiLCJzcGVjcyIsIm1vZFNwZWMiLCJkZWYiLCJjbHMiLCJuZXdOYW1lIiwic2NvcGVPcHQiLCJzY29wZSIsInN0eWxlIiwidGFnIiwibW9kdWxlIiwidGhlbWVUeXBlIiwiaGlnaGxpZ2h0ZXJGYWNldCIsImZhbGxiYWNrSGlnaGxpZ2h0ZXIiLCJnZXRIaWdobGlnaHRlcnMiLCJzeW50YXhIaWdobGlnaHRpbmciLCJoaWdobGlnaHRlciIsInRyZWVIaWdobGlnaHRlciIsInN0eWxlTW9kdWxlIiwiZmFsbGJhY2siLCJjb21wdXRlTiIsImRhcmtUaGVtZSIsImhpZ2hsaWdodGluZ0ZvciIsImhpZ2hsaWdodGVycyIsIlRyZWVIaWdobGlnaHRlciIsIm1hcmtDYWNoZSIsImJ1aWxkRGVjbyIsImRlY29yYXRlZFRvIiwic3R5bGVDaGFuZ2UiLCJkZWNvcmF0ZWRUb01hcHBlZCIsInZpc2libGVSYW5nZXMiLCJoaWdoIiwidiIsImRlZmF1bHRIaWdobGlnaHRTdHlsZSIsIm1ldGEiLCJsaW5rIiwidGV4dERlY29yYXRpb24iLCJoZWFkaW5nIiwiZm9udFdlaWdodCIsImVtcGhhc2lzIiwiZm9udFN0eWxlIiwic3Ryb25nIiwic3RyaWtldGhyb3VnaCIsImtleXdvcmQiLCJhdG9tIiwiYm9vbCIsInVybCIsImNvbnRlbnRTZXBhcmF0b3IiLCJsYWJlbE5hbWUiLCJsaXRlcmFsIiwiaW5zZXJ0ZWQiLCJkZWxldGVkIiwicmVnZXhwIiwiZXNjYXBlIiwic3BlY2lhbCIsImRlZmluaXRpb24iLCJ2YXJpYWJsZU5hbWUiLCJsb2NhbCIsInR5cGVOYW1lIiwibmFtZXNwYWNlIiwibWFjcm9OYW1lIiwicHJvcGVydHlOYW1lIiwiY29tbWVudCIsImludmFsaWQiLCJEZWZhdWx0U2NhbkRpc3QiLCJEZWZhdWx0QnJhY2tldHMiLCJicmFja2V0TWF0Y2hpbmdDb25maWciLCJjb25maWdzIiwiYWZ0ZXJDdXJzb3IiLCJicmFja2V0cyIsIm1heFNjYW5EaXN0YW5jZSIsInJlbmRlck1hdGNoIiwiZGVmYXVsdFJlbmRlck1hdGNoIiwibWF0Y2hpbmdNYXJrIiwibm9ubWF0Y2hpbmdNYXJrIiwibWF0Y2hlZCIsImJyYWNrZXRNYXRjaGluZ1N0YXRlIiwiZGVjbyIsIm1hdGNoQnJhY2tldHMiLCJicmFja2V0TWF0Y2hpbmdVbmlxdWUiLCJicmFja2V0TWF0Y2hpbmciLCJicmFja2V0TWF0Y2hpbmdIYW5kbGUiLCJtYXRjaGluZ05vZGVzIiwiZGlyIiwiYnlQcm9wIiwib3BlbmVkQnkiLCJpbmRleCIsImZpbmRIYW5kbGUiLCJoYXNIYW5kbGUiLCJyZXNvbHZlSW5uZXIiLCJtYXRjaGVzIiwiaGFuZGxlIiwibWF0Y2hNYXJrZWRCcmFja2V0cyIsIm1hdGNoUGxhaW5CcmFja2V0cyIsIl9zdGF0ZSIsIl9wb3MiLCJ0b2tlbiIsIm1hdGNoaW5nIiwiZmlyc3RUb2tlbiIsImRlcHRoIiwiY2hpbGRCZWZvcmUiLCJlbmRIYW5kbGUiLCJwcmV2U2libGluZyIsIm5leHRTaWJsaW5nIiwidG9rZW5UeXBlIiwic3RhcnRDaCIsInNsaWNlRG9jIiwiYnJhY2tldCIsInN0YXJ0VG9rZW4iLCJpdGVyUmFuZ2UiLCJkaXN0YW5jZSIsImJhc2VQb3MiLCJjb3VudENvbCIsInN0YXJ0SW5kZXgiLCJzdGFydFZhbHVlIiwibiIsIlN0cmluZ1N0cmVhbSIsIm92ZXJyaWRlSW5kZW50IiwibGFzdENvbHVtblBvcyIsImxhc3RDb2x1bW5WYWx1ZSIsImVvbCIsInNvbCIsInBlZWsiLCJjaGFyQXQiLCJlYXQiLCJvayIsIlJlZ0V4cCIsImVhdFdoaWxlIiwiZWF0U3BhY2UiLCJza2lwVG9FbmQiLCJza2lwVG8iLCJiYWNrVXAiLCJpbmRlbnRhdGlvbiIsInBhdHRlcm4iLCJjb25zdW1lIiwiY2FzZUluc2Vuc2l0aXZlIiwiY2FzZWQiLCJzdHIiLCJzdWJzdHIiLCJjdXJyZW50IiwiZnVsbFBhcnNlciIsImJsYW5rTGluZSIsImNvcHlTdGF0ZSIsImRlZmF1bHRDb3B5U3RhdGUiLCJ0b2tlblRhYmxlIiwibm9Ub2tlbnMiLCJ2YWwiLCJJbmRlbnRlZEZyb20iLCJXZWFrTWFwIiwiU3RyZWFtTGFuZ3VhZ2UiLCJwIiwic2VsZiIsImltcGwiLCJQYXJzZSIsImdldEluZGVudCIsImRvY0lEIiwic3RyZWFtUGFyc2VyIiwic3RhdGVBZnRlciIsInBlck5vZGUiLCJUb2tlblRhYmxlIiwiZGVmYXVsdFRva2VuVGFibGUiLCJhdCIsImZpbmRTdGF0ZSIsInN0YXRlUG9zIiwic3RyZWFtIiwicmVhZFRva2VuIiwib2ZmIiwic3RhcnRQb3MiLCJiZWZvcmUiLCJjaGlsZCIsImN1dFRyZWUiLCJpbnNpZGUiLCJmaW5kU3RhcnRJbkZyYWdtZW50cyIsImVkaXRvclN0YXRlIiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsIm9mZnNldCIsImNodW5rcyIsImNodW5rUG9zIiwiY2h1bmtSZXVzZWQiLCJyYW5nZUluZGV4IiwiY2h1bmtTdGFydCIsIm1vdmVSYW5nZUluZGV4IiwicGFyc2VFbmQiLCJwYXJzZUxpbmUiLCJmaW5pc2hDaHVuayIsImxpbmVBZnRlciIsIm5leHRMaW5lIiwicmFuZ2VFbmQiLCJyYW5nZVN0YXJ0Iiwic2tpcEdhcHNUbyIsIm9mZlBvcyIsImVtaXRUb2tlbiIsImlkIiwibGVuMCIsImJ1aWxkIiwiYnVmZmVyIiwibm9kZVNldCIsInRvcElEIiwibWF4QnVmZmVyTGVuZ3RoIiwicmV1c2VkIiwiYmFsYW5jZSIsInR5cGVBcnJheSIsIndhcm5lZCIsImJ5VGFnIiwiZGVmYXVsdFRhYmxlIiwibGVnYWN5TmFtZSIsImNyZWF0ZVRva2VuVHlwZSIsImV4dHJhIiwidGFibGUiLCJ3YXJuRm9yUGFydCIsInBhcnQiLCJtc2ciLCJjb25zb2xlIiwid2FybiIsInRhZ1N0ciIsInRhZ3MkMSIsInNwbGl0IiwidCIsImtub3duIiwiYnVpbGRGb3JMaW5lIiwidGV4dEhhc1JUTCIsImNoYW5nZUFkZHNSVEwiLCJjaGFuZ2UiLCJhZGRlZCIsIml0ZXJDaGFuZ2VzIiwiZkEiLCJ0QSIsImZCIiwidEIiLCJpbnMiLCJhbHdheXNJc29sYXRlIiwieCIsImJpZGlJc29sYXRlcyIsImlzb2xhdGVNYXJrcyIsImFsd2F5cyIsInRleHREaXJlY3Rpb24iLCJMVFIiLCJwZXJMaW5lVGV4dERpcmVjdGlvbiIsImhhc1JUTCIsImFjY2VzcyIsIl9iIiwib3V0ZXJEZWNvcmF0aW9ucyIsImxvd2VzdCIsImJpZGlJc29sYXRlZFJhbmdlcyIsImNsaXBSVExMaW5lcyIsIml0ZXJhdGUiLCJpc28iLCJpc29sYXRlIiwibWFya3MiLCJsaW5lQnJlYWsiLCJydGwiLCJpbmNsdXNpdmUiLCJhdHRyaWJ1dGVzIiwiYmlkaUlzb2xhdGUiLCJSVEwiLCJsdHIiLCJhdXRvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/language/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lint/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/lint/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeLintPanel: () => (/* binding */ closeLintPanel),\n/* harmony export */   diagnosticCount: () => (/* binding */ diagnosticCount),\n/* harmony export */   forEachDiagnostic: () => (/* binding */ forEachDiagnostic),\n/* harmony export */   forceLinting: () => (/* binding */ forceLinting),\n/* harmony export */   lintGutter: () => (/* binding */ lintGutter),\n/* harmony export */   lintKeymap: () => (/* binding */ lintKeymap),\n/* harmony export */   linter: () => (/* binding */ linter),\n/* harmony export */   nextDiagnostic: () => (/* binding */ nextDiagnostic),\n/* harmony export */   openLintPanel: () => (/* binding */ openLintPanel),\n/* harmony export */   previousDiagnostic: () => (/* binding */ previousDiagnostic),\n/* harmony export */   setDiagnostics: () => (/* binding */ setDiagnostics),\n/* harmony export */   setDiagnosticsEffect: () => (/* binding */ setDiagnosticsEffect)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic){\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected){\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n    static init(diagnostics, panel, state) {\n        // Filter the list of diagnostics for which to create markers\n        let markedDiagnostics = diagnostics;\n        let diagnosticFilter = state.facet(lintConfig).markerFilter;\n        if (diagnosticFilter) markedDiagnostics = diagnosticFilter(markedDiagnostics, state);\n        let ranges = _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set(markedDiagnostics.map((d)=>{\n            // For zero-length ranges or ranges covering only a line break, create a widget\n            return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.widget({\n                widget: new DiagnosticWidget(d),\n                diagnostic: d\n            }).range(d.from) : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\n                attributes: {\n                    class: \"cm-lintRange cm-lintRange-\" + d.severity + (d.markClass ? \" \" + d.markClass : \"\")\n                },\n                diagnostic: d,\n                inclusive: true\n            }).range(d.from, d.to);\n        }), true);\n        return new LintState(ranges, panel, findDiagnostic(ranges));\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, 1e9, (from, to, { spec })=>{\n        if (diagnostic && spec.diagnostic != diagnostic) return;\n        found = new SelectedDiagnostic(from, to, spec.diagnostic);\n        return false;\n    });\n    return found;\n}\nfunction hideTooltip(tr, tooltip) {\n    let line = tr.startState.doc.lineAt(tooltip.pos);\n    return !!(tr.effects.some((e)=>e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, line.to));\n}\nfunction maybeEnableLint(state, effects) {\n    return state.field(lintState, false) ? effects : effects.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.appendConfig.of(lintExtensions));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics, and enables the lint extension if if wasn't already\nactive.\n*/ function setDiagnostics(state, diagnostics) {\n    return {\n        effects: maybeEnableLint(state, [\n            setDiagnosticsEffect.of(diagnostics)\n        ])\n    };\n}\n/**\nThe state effect that updates the set of active diagnostics. Can\nbe useful when writing an extension that needs to track these.\n*/ const setDiagnosticsEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst movePanelSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst lintState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return new LintState(_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none, null, null);\n    },\n    update (value, tr) {\n        if (tr.docChanged) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            value = new LintState(mapped, value.panel, selected);\n        }\n        for (let effect of tr.effects){\n            if (effect.is(setDiagnosticsEffect)) {\n                value = LintState.init(effect.value, value.panel, tr.state);\n            } else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            } else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showPanel.from(f, (val)=>val.panel),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.from(f, (s)=>s.diagnostics)\n        ]\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/ function diagnosticCount(state) {\n    let lint = state.field(lintState, false);\n    return lint ? lint.diagnostics.size : 0;\n}\nconst activeMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.mark({\n    class: \"cm-lintRange cm-lintRange-active\",\n    inclusive: true\n});\nfunction lintTooltip(view, pos, side) {\n    let { diagnostics } = view.state.field(lintState);\n    let found = [], stackStart = 2e8, stackEnd = 0;\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec })=>{\n        if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {\n            found.push(spec.diagnostic);\n            stackStart = Math.min(from, stackStart);\n            stackEnd = Math.max(to, stackEnd);\n        }\n    });\n    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;\n    if (diagnosticFilter) found = diagnosticFilter(found, view.state);\n    if (!found.length) return null;\n    return {\n        pos: stackStart,\n        end: stackEnd,\n        above: view.state.doc.lineAt(stackStart).to < stackEnd,\n        create () {\n            return {\n                dom: diagnosticsTooltip(view, found)\n            };\n        }\n    };\n}\nfunction diagnosticsTooltip(view, diagnostics) {\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n        class: \"cm-tooltip-lint\"\n    }, diagnostics.map((d)=>renderDiagnostic(view, d, false)));\n}\n/**\nCommand to open and focus the lint panel.\n*/ const openLintPanel = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel) view.dispatch({\n        effects: maybeEnableLint(view.state, [\n            togglePanel.of(true)\n        ])\n    });\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.getPanel)(view, LintPanel.open);\n    if (panel) panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/ const closeLintPanel = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel) return false;\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/ const nextDiagnostic = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field) return false;\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to) return false;\n    }\n    view.dispatch({\n        selection: {\n            anchor: next.from,\n            head: next.to\n        },\n        scrollIntoView: true\n    });\n    return true;\n};\n/**\nMove the selection to the previous diagnostic.\n*/ const previousDiagnostic = (view)=>{\n    let { state } = view, field = state.field(lintState, false);\n    if (!field) return false;\n    let sel = state.selection.main;\n    let prevFrom, prevTo, lastFrom, lastTo;\n    field.diagnostics.between(0, state.doc.length, (from, to)=>{\n        if (to < sel.to && (prevFrom == null || prevFrom < from)) {\n            prevFrom = from;\n            prevTo = to;\n        }\n        if (lastFrom == null || from > lastFrom) {\n            lastFrom = from;\n            lastTo = to;\n        }\n    });\n    if (lastFrom == null || prevFrom == null && lastFrom == sel.from) return false;\n    view.dispatch({\n        selection: {\n            anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom,\n            head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo\n        },\n        scrollIntoView: true\n    });\n    return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/ const lintKeymap = [\n    {\n        key: \"Mod-Shift-m\",\n        run: openLintPanel,\n        preventDefault: true\n    },\n    {\n        key: \"F8\",\n        run: nextDiagnostic\n    }\n];\nconst lintPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.timeout = -1;\n        this.set = true;\n        let { delay } = view.state.facet(lintConfig);\n        this.lintTime = Date.now() + delay;\n        this.run = this.run.bind(this);\n        this.timeout = setTimeout(this.run, delay);\n    }\n    run() {\n        let now = Date.now();\n        if (now < this.lintTime - 10) {\n            this.timeout = setTimeout(this.run, this.lintTime - now);\n        } else {\n            this.set = false;\n            let { state } = this.view, { sources } = state.facet(lintConfig);\n            if (sources.length) Promise.all(sources.map((source)=>Promise.resolve(source(this.view)))).then((annotations)=>{\n                let all = annotations.reduce((a, b)=>a.concat(b));\n                if (this.view.state.doc == state.doc) this.view.dispatch(setDiagnostics(this.view.state, all));\n            }, (error)=>{\n                (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.logException)(this.view.state, error);\n            });\n        }\n    }\n    update(update) {\n        let config = update.state.facet(lintConfig);\n        if (update.docChanged || config != update.startState.facet(lintConfig) || config.needsRefresh && config.needsRefresh(update)) {\n            this.lintTime = Date.now() + config.delay;\n            if (!this.set) {\n                this.set = true;\n                this.timeout = setTimeout(this.run, config.delay);\n            }\n        }\n    }\n    force() {\n        if (this.set) {\n            this.lintTime = Date.now();\n            this.run();\n        }\n    }\n    destroy() {\n        clearTimeout(this.timeout);\n    }\n});\nconst lintConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (input) {\n        return Object.assign({\n            sources: input.map((i)=>i.source).filter((x)=>x != null)\n        }, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(input.map((i)=>i.config), {\n            delay: 750,\n            markerFilter: null,\n            tooltipFilter: null,\n            needsRefresh: null\n        }, {\n            needsRefresh: (a, b)=>!a ? b : !b ? a : (u)=>a(u) || b(u)\n        }));\n    }\n});\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed). If `null` is given as\nsource, this only configures the lint extension.\n*/ function linter(source, config = {}) {\n    return [\n        lintConfig.of({\n            source,\n            config\n        }),\n        lintPlugin,\n        lintExtensions\n    ];\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/ function forceLinting(view) {\n    let plugin = view.plugin(lintPlugin);\n    if (plugin) plugin.force();\n}\nfunction assignKeys(actions) {\n    let assigned = [];\n    if (actions) actions: for (let { name } of actions){\n        for(let i = 0; i < name.length; i++){\n            let ch = name[i];\n            if (/[a-zA-Z]/.test(ch) && !assigned.some((c)=>c.toLowerCase() == ch.toLowerCase())) {\n                assigned.push(ch);\n                continue actions;\n            }\n        }\n        assigned.push(\"\");\n    }\n    return assigned;\n}\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n    var _a;\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"li\", {\n        class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", {\n        class: \"cm-diagnosticText\"\n    }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i)=>{\n        let fired = false, click = (e)=>{\n            e.preventDefault();\n            if (fired) return;\n            fired = true;\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n            if (found) action.apply(view, found.from, found.to);\n        };\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n        let nameElt = keyIndex < 0 ? name : [\n            name.slice(0, keyIndex),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"u\", name.slice(keyIndex, keyIndex + 1)),\n            name.slice(keyIndex + 1)\n        ];\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            class: \"cm-diagnosticAction\",\n            onclick: click,\n            onmousedown: click,\n            \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\n        }, nameElt);\n    }), diagnostic.source && (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n        class: \"cm-diagnosticSource\"\n    }, diagnostic.source));\n}\nclass DiagnosticWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.WidgetType {\n    constructor(diagnostic){\n        super();\n        this.diagnostic = diagnostic;\n    }\n    eq(other) {\n        return other.diagnostic == this.diagnostic;\n    }\n    toDOM() {\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", {\n            class: \"cm-lintPoint cm-lintPoint-\" + this.diagnostic.severity\n        });\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic){\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic, true);\n        this.dom.id = this.id;\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view){\n        this.view = view;\n        this.items = [];\n        let onkeydown = (event)=>{\n            if (event.keyCode == 27) {\n                closeLintPanel(this.view);\n                this.view.focus();\n            } else if (event.keyCode == 38 || event.keyCode == 33) {\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            } else if (event.keyCode == 40 || event.keyCode == 34) {\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            } else if (event.keyCode == 36) {\n                this.moveSelection(0);\n            } else if (event.keyCode == 35) {\n                this.moveSelection(this.items.length - 1);\n            } else if (event.keyCode == 13) {\n                this.view.focus();\n            } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\n                for(let i = 0; i < keys.length; i++)if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n                    let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n                    if (found) diagnostic.actions[i].apply(view, found.from, found.to);\n                }\n            } else {\n                return;\n            }\n            event.preventDefault();\n        };\n        let onclick = (event)=>{\n            for(let i = 0; i < this.items.length; i++){\n                if (this.items[i].dom.contains(event.target)) this.moveSelection(i);\n            }\n        };\n        this.list = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n            tabIndex: 0,\n            role: \"listbox\",\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n            onkeydown,\n            onclick\n        });\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            class: \"cm-panel-lint\"\n        }, this.list, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            name: \"close\",\n            \"aria-label\": this.view.state.phrase(\"close\"),\n            onclick: ()=>closeLintPanel(this.view)\n        }, \"\\xd7\"));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected) return -1;\n        for(let i = 0; i < this.items.length; i++)if (this.items[i].diagnostic == selected.diagnostic) return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec })=>{\n            let found = -1, item;\n            for(let j = i; j < this.items.length; j++)if (this.items[j].diagnostic == spec.diagnostic) {\n                found = j;\n                break;\n            }\n            if (found < 0) {\n                item = new PanelItem(this.view, spec.diagnostic);\n                this.items.splice(i, 0, item);\n                needsSync = true;\n            } else {\n                item = this.items[found];\n                if (found > i) {\n                    this.items.splice(i, found - i);\n                    needsSync = true;\n                }\n            }\n            if (selected && item.diagnostic == selected.diagnostic) {\n                if (!item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.setAttribute(\"aria-selected\", \"true\");\n                    newSelectedItem = item;\n                }\n            } else if (item.dom.hasAttribute(\"aria-selected\")) {\n                item.dom.removeAttribute(\"aria-selected\");\n            }\n            i++;\n        });\n        while(i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)){\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1,\n                to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: ()=>({\n                        sel: newSelectedItem.dom.getBoundingClientRect(),\n                        panel: this.list.getBoundingClientRect()\n                    }),\n                write: ({ sel, panel })=>{\n                    let scaleY = panel.height / this.list.offsetHeight;\n                    if (sel.top < panel.top) this.list.scrollTop -= (panel.top - sel.top) / scaleY;\n                    else if (sel.bottom > panel.bottom) this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;\n                }\n            });\n        } else if (this.selectedIndex < 0) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync) this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items){\n            if (item.dom.parentNode == this.list) {\n                while(domPos != item.dom)rm();\n                domPos = item.dom.nextSibling;\n            } else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while(domPos)rm();\n    }\n    moveSelection(selectedIndex) {\n        if (this.selectedIndex < 0) return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection) return;\n        this.view.dispatch({\n            selection: {\n                anchor: selection.from,\n                head: selection.to\n            },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    static open(view) {\n        return new LintPanel(view);\n    }\n}\nfunction svg(content, attrs = `viewBox=\"0 0 40 40\"`) {\n    return `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ${attrs}>${encodeURIComponent(content)}</svg>')`;\n}\nfunction underline(color) {\n    return svg(`<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>`, `width=\"6\" height=\"3\"`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-diagnostic\": {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\",\n        whiteSpace: \"pre-wrap\"\n    },\n    \".cm-diagnostic-error\": {\n        borderLeft: \"5px solid #d11\"\n    },\n    \".cm-diagnostic-warning\": {\n        borderLeft: \"5px solid orange\"\n    },\n    \".cm-diagnostic-info\": {\n        borderLeft: \"5px solid #999\"\n    },\n    \".cm-diagnostic-hint\": {\n        borderLeft: \"5px solid #66d\"\n    },\n    \".cm-diagnosticAction\": {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\",\n        cursor: \"pointer\"\n    },\n    \".cm-diagnosticSource\": {\n        fontSize: \"70%\",\n        opacity: .7\n    },\n    \".cm-lintRange\": {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\",\n        paddingBottom: \"0.7px\"\n    },\n    \".cm-lintRange-error\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#d11\")\n    },\n    \".cm-lintRange-warning\": {\n        backgroundImage: /*@__PURE__*/ underline(\"orange\")\n    },\n    \".cm-lintRange-info\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#999\")\n    },\n    \".cm-lintRange-hint\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#66d\")\n    },\n    \".cm-lintRange-active\": {\n        backgroundColor: \"#ffdd9980\"\n    },\n    \".cm-tooltip-lint\": {\n        padding: 0,\n        margin: 0\n    },\n    \".cm-lintPoint\": {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \".cm-lintPoint-warning\": {\n        \"&:after\": {\n            borderBottomColor: \"orange\"\n        }\n    },\n    \".cm-lintPoint-info\": {\n        \"&:after\": {\n            borderBottomColor: \"#999\"\n        }\n    },\n    \".cm-lintPoint-hint\": {\n        \"&:after\": {\n            borderBottomColor: \"#66d\"\n        }\n    },\n    \".cm-panel.cm-panel-lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\",\n                \"& u\": {\n                    textDecoration: \"underline\"\n                }\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            \"& u\": {\n                textDecoration: \"none\"\n            },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    }\n});\nfunction severityWeight(sev) {\n    return sev == \"error\" ? 4 : sev == \"warning\" ? 3 : sev == \"info\" ? 2 : 1;\n}\nclass LintGutterMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.GutterMarker {\n    constructor(diagnostics){\n        super();\n        this.diagnostics = diagnostics;\n        this.severity = diagnostics.reduce((max, d)=>severityWeight(max) < severityWeight(d.severity) ? d.severity : max, \"hint\");\n    }\n    toDOM(view) {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\n        let diagnostics = this.diagnostics;\n        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;\n        if (diagnosticsFilter) diagnostics = diagnosticsFilter(diagnostics, view.state);\n        if (diagnostics.length) elt.onmouseover = ()=>gutterMarkerMouseOver(view, elt, diagnostics);\n        return elt;\n    }\n}\nfunction trackHoverOn(view, marker) {\n    let mousemove = (event)=>{\n        let rect = marker.getBoundingClientRect();\n        if (event.clientX > rect.left - 10 /* Hover.Margin */  && event.clientX < rect.right + 10 /* Hover.Margin */  && event.clientY > rect.top - 10 /* Hover.Margin */  && event.clientY < rect.bottom + 10 /* Hover.Margin */ ) return;\n        for(let target = event.target; target; target = target.parentNode){\n            if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\")) return;\n        }\n        window.removeEventListener(\"mousemove\", mousemove);\n        if (view.state.field(lintGutterTooltip)) view.dispatch({\n            effects: setLintGutterTooltip.of(null)\n        });\n    };\n    window.addEventListener(\"mousemove\", mousemove);\n}\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\n    function hovered() {\n        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);\n        const linePos = view.coordsAtPos(line.from);\n        if (linePos) {\n            view.dispatch({\n                effects: setLintGutterTooltip.of({\n                    pos: line.from,\n                    above: false,\n                    create () {\n                        return {\n                            dom: diagnosticsTooltip(view, diagnostics),\n                            getCoords: ()=>marker.getBoundingClientRect()\n                        };\n                    }\n                })\n            });\n        }\n        marker.onmouseout = marker.onmousemove = null;\n        trackHoverOn(view, marker);\n    }\n    let { hoverTime } = view.state.facet(lintGutterConfig);\n    let hoverTimeout = setTimeout(hovered, hoverTime);\n    marker.onmouseout = ()=>{\n        clearTimeout(hoverTimeout);\n        marker.onmouseout = marker.onmousemove = null;\n    };\n    marker.onmousemove = ()=>{\n        clearTimeout(hoverTimeout);\n        hoverTimeout = setTimeout(hovered, hoverTime);\n    };\n}\nfunction markersForDiagnostics(doc, diagnostics) {\n    let byLine = Object.create(null);\n    for (let diagnostic of diagnostics){\n        let line = doc.lineAt(diagnostic.from);\n        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);\n    }\n    let markers = [];\n    for(let line in byLine){\n        markers.push(new LintGutterMarker(byLine[line]).range(+line));\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(markers, true);\n}\nconst lintGutterExtension = /*@__PURE__*/ (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.gutter)({\n    class: \"cm-gutter-lint\",\n    markers: (view)=>view.state.field(lintGutterMarkers)\n});\nconst lintGutterMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\n    },\n    update (markers, tr) {\n        markers = markers.map(tr.changes);\n        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;\n        for (let effect of tr.effects){\n            if (effect.is(setDiagnosticsEffect)) {\n                let diagnostics = effect.value;\n                if (diagnosticFilter) diagnostics = diagnosticFilter(diagnostics || [], tr.state);\n                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));\n            }\n        }\n        return markers;\n    }\n});\nconst setLintGutterTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\nconst lintGutterTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return null;\n    },\n    update (tooltip, tr) {\n        if (tooltip && tr.docChanged) tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), {\n            pos: tr.changes.mapPos(tooltip.pos)\n        });\n        return tr.effects.reduce((t, e)=>e.is(setLintGutterTooltip) ? e.value : t, tooltip);\n    },\n    provide: (field)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.showTooltip.from(field)\n});\nconst lintGutterTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.baseTheme({\n    \".cm-gutter-lint\": {\n        width: \"1.4em\",\n        \"& .cm-gutterElement\": {\n            padding: \".2em\"\n        }\n    },\n    \".cm-lint-marker\": {\n        width: \"1em\",\n        height: \"1em\"\n    },\n    \".cm-lint-marker-info\": {\n        content: /*@__PURE__*/ svg(`<path fill=\"#aaf\" stroke=\"#77e\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M5 5L35 5L35 35L5 35Z\"/>`)\n    },\n    \".cm-lint-marker-warning\": {\n        content: /*@__PURE__*/ svg(`<path fill=\"#fe8\" stroke=\"#fd7\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M20 6L37 35L3 35Z\"/>`)\n    },\n    \".cm-lint-marker-error\": {\n        content: /*@__PURE__*/ svg(`<circle cx=\"20\" cy=\"20\" r=\"15\" fill=\"#f87\" stroke=\"#f43\" stroke-width=\"6\"/>`)\n    }\n});\nconst lintExtensions = [\n    lintState,\n    /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.decorations.compute([\n        lintState\n    ], (state)=>{\n        let { selected, panel } = state.field(lintState);\n        return !selected || !panel || selected.from == selected.to ? _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.none : _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.set([\n            activeMark.range(selected.from, selected.to)\n        ]);\n    }),\n    /*@__PURE__*/ (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_1__.hoverTooltip)(lintTooltip, {\n        hideOn: hideTooltip\n    }),\n    baseTheme\n];\nconst lintGutterConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            hoverTime: 300 /* Hover.Time */ ,\n            markerFilter: null,\n            tooltipFilter: null\n        });\n    }\n});\n/**\nReturns an extension that installs a gutter showing markers for\neach line that has diagnostics, which can be hovered over to see\nthe diagnostics.\n*/ function lintGutter(config = {}) {\n    return [\n        lintGutterConfig.of(config),\n        lintGutterMarkers,\n        lintGutterExtension,\n        lintGutterTheme,\n        lintGutterTooltip\n    ];\n}\n/**\nIterate over the marked diagnostics for the given editor state,\ncalling `f` for each of them. Note that, if the document changed\nsince the diagnostics were created, the `Diagnostic` object will\nhold the original outdated position, whereas the `to` and `from`\narguments hold the diagnostic's current position.\n*/ function forEachDiagnostic(state, f) {\n    let lState = state.field(lintState, false);\n    if (lState && lState.diagnostics.size) for(let iter = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter([\n        lState.diagnostics\n    ]); iter.value; iter.next())f(iter.value.spec.diagnostic, iter.from, iter.to);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzSztBQUMxRTtBQUNwRTtBQUV4QixNQUFNaUI7SUFDRkMsWUFBWUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLFVBQVUsQ0FBRTtRQUM5QixJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDdEI7QUFDSjtBQUNBLE1BQU1DO0lBQ0ZKLFlBQVlLLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDdEMsSUFBSSxDQUFDRixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtJQUNwQjtJQUNBLE9BQU9DLEtBQUtILFdBQVcsRUFBRUMsS0FBSyxFQUFFRyxLQUFLLEVBQUU7UUFDbkMsNkRBQTZEO1FBQzdELElBQUlDLG9CQUFvQkw7UUFDeEIsSUFBSU0sbUJBQW1CRixNQUFNRyxLQUFLLENBQUNDLFlBQVlDLFlBQVk7UUFDM0QsSUFBSUgsa0JBQ0FELG9CQUFvQkMsaUJBQWlCRCxtQkFBbUJEO1FBQzVELElBQUlNLFNBQVNqQyx3REFBVUEsQ0FBQ2tDLEdBQUcsQ0FBQ04sa0JBQWtCTyxHQUFHLENBQUMsQ0FBQ0M7WUFDL0MsK0VBQStFO1lBQy9FLE9BQU9BLEVBQUVqQixJQUFJLElBQUlpQixFQUFFaEIsRUFBRSxJQUFLZ0IsRUFBRWpCLElBQUksSUFBSWlCLEVBQUVoQixFQUFFLEdBQUcsS0FBS08sTUFBTVUsR0FBRyxDQUFDQyxNQUFNLENBQUNGLEVBQUVqQixJQUFJLEVBQUVDLEVBQUUsSUFBSWdCLEVBQUVqQixJQUFJLEdBQy9FbkIsd0RBQVVBLENBQUN1QyxNQUFNLENBQUM7Z0JBQ2hCQSxRQUFRLElBQUlDLGlCQUFpQko7Z0JBQzdCZixZ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QUFFc08sUUFBUWxSO0lBQVk7SUFDN0R5TTtDQUNIO0FBQ0QsTUFBTXFDLG1CQUFtQixXQUFXLEdBQUV0UixvREFBS0EsQ0FBQzZELE1BQU0sQ0FBQztJQUMvQ3VGLFNBQVF1SyxPQUFPO1FBQ1gsT0FBTzFULGdFQUFhQSxDQUFDMFQsU0FBUztZQUMxQmIsV0FBVyxJQUFJLGNBQWM7WUFDN0IzUixjQUFjO1lBQ2QwRSxlQUFlO1FBQ25CO0lBQ0o7QUFDSjtBQUNBOzs7O0FBSUEsR0FDQSxTQUFTK04sV0FBVzdLLFNBQVMsQ0FBQyxDQUFDO0lBQzNCLE9BQU87UUFBQ3VJLGlCQUFpQjVOLEVBQUUsQ0FBQ3FGO1FBQVNxSztRQUFtQkQ7UUFBcUJJO1FBQWlCcEI7S0FBa0I7QUFDcEg7QUFDQTs7Ozs7O0FBTUEsR0FDQSxTQUFTMEIsa0JBQWtCL1MsS0FBSyxFQUFFOEQsQ0FBQztJQUMvQixJQUFJa1AsU0FBU2hULE1BQU13QyxLQUFLLENBQUNDLFdBQVc7SUFDcEMsSUFBSXVRLFVBQVVBLE9BQU9wVCxXQUFXLENBQUN3RSxJQUFJLEVBQ2pDLElBQUssSUFBSTRCLE9BQU81Ryx1REFBUUEsQ0FBQzRHLElBQUksQ0FBQztRQUFDZ04sT0FBT3BULFdBQVc7S0FBQyxHQUFHb0csS0FBSzNDLEtBQUssRUFBRTJDLEtBQUtELElBQUksR0FDdEVqQyxFQUFFa0MsS0FBSzNDLEtBQUssQ0FBQzVCLElBQUksQ0FBQy9CLFVBQVUsRUFBRXNHLEtBQUt4RyxJQUFJLEVBQUV3RyxLQUFLdkcsRUFBRTtBQUM1RDtBQUVxTSIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xpbnQvZGlzdC9pbmRleC5qcz9mOWRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlY29yYXRpb24sIHNob3dQYW5lbCwgRWRpdG9yVmlldywgVmlld1BsdWdpbiwgbG9nRXhjZXB0aW9uLCBndXR0ZXIsIHNob3dUb29sdGlwLCBob3ZlclRvb2x0aXAsIGdldFBhbmVsLCBXaWRnZXRUeXBlLCBHdXR0ZXJNYXJrZXIgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBGYWNldCwgY29tYmluZUNvbmZpZywgUmFuZ2VTZXQgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcblxuY2xhc3MgU2VsZWN0ZWREaWFnbm9zdGljIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgZGlhZ25vc3RpYykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IGRpYWdub3N0aWM7XG4gICAgfVxufVxuY2xhc3MgTGludFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihkaWFnbm9zdGljcywgcGFuZWwsIHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgdGhpcy5wYW5lbCA9IHBhbmVsO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KGRpYWdub3N0aWNzLCBwYW5lbCwgc3RhdGUpIHtcbiAgICAgICAgLy8gRmlsdGVyIHRoZSBsaXN0IG9mIGRpYWdub3N0aWNzIGZvciB3aGljaCB0byBjcmVhdGUgbWFya2Vyc1xuICAgICAgICBsZXQgbWFya2VkRGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgbGV0IGRpYWdub3N0aWNGaWx0ZXIgPSBzdGF0ZS5mYWNldChsaW50Q29uZmlnKS5tYXJrZXJGaWx0ZXI7XG4gICAgICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxuICAgICAgICAgICAgbWFya2VkRGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljRmlsdGVyKG1hcmtlZERpYWdub3N0aWNzLCBzdGF0ZSk7XG4gICAgICAgIGxldCByYW5nZXMgPSBEZWNvcmF0aW9uLnNldChtYXJrZWREaWFnbm9zdGljcy5tYXAoKGQpID0+IHtcbiAgICAgICAgICAgIC8vIEZvciB6ZXJvLWxlbmd0aCByYW5nZXMgb3IgcmFuZ2VzIGNvdmVyaW5nIG9ubHkgYSBsaW5lIGJyZWFrLCBjcmVhdGUgYSB3aWRnZXRcbiAgICAgICAgICAgIHJldHVybiBkLmZyb20gPT0gZC50byB8fCAoZC5mcm9tID09IGQudG8gLSAxICYmIHN0YXRlLmRvYy5saW5lQXQoZC5mcm9tKS50byA9PSBkLmZyb20pXG4gICAgICAgICAgICAgICAgPyBEZWNvcmF0aW9uLndpZGdldCh7XG4gICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IERpYWdub3N0aWNXaWRnZXQoZCksXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWM6IGRcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShkLmZyb20pXG4gICAgICAgICAgICAgICAgOiBEZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IGNsYXNzOiBcImNtLWxpbnRSYW5nZSBjbS1saW50UmFuZ2UtXCIgKyBkLnNldmVyaXR5ICsgKGQubWFya0NsYXNzID8gXCIgXCIgKyBkLm1hcmtDbGFzcyA6IFwiXCIpIH0sXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWM6IGQsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLnJhbmdlKGQuZnJvbSwgZC50byk7XG4gICAgICAgIH0pLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW50U3RhdGUocmFuZ2VzLCBwYW5lbCwgZmluZERpYWdub3N0aWMocmFuZ2VzKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpYWdub3N0aWMoZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMgPSBudWxsLCBhZnRlciA9IDApIHtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGRpYWdub3N0aWNzLmJldHdlZW4oYWZ0ZXIsIDFlOSwgKGZyb20sIHRvLCB7IHNwZWMgfSkgPT4ge1xuICAgICAgICBpZiAoZGlhZ25vc3RpYyAmJiBzcGVjLmRpYWdub3N0aWMgIT0gZGlhZ25vc3RpYylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm91bmQgPSBuZXcgU2VsZWN0ZWREaWFnbm9zdGljKGZyb20sIHRvLCBzcGVjLmRpYWdub3N0aWMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gaGlkZVRvb2x0aXAodHIsIHRvb2x0aXApIHtcbiAgICBsZXQgbGluZSA9IHRyLnN0YXJ0U3RhdGUuZG9jLmxpbmVBdCh0b29sdGlwLnBvcyk7XG4gICAgcmV0dXJuICEhKHRyLmVmZmVjdHMuc29tZShlID0+IGUuaXMoc2V0RGlhZ25vc3RpY3NFZmZlY3QpKSB8fCB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZShsaW5lLmZyb20sIGxpbmUudG8pKTtcbn1cbmZ1bmN0aW9uIG1heWJlRW5hYmxlTGludChzdGF0ZSwgZWZmZWN0cykge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKSA/IGVmZmVjdHMgOiBlZmZlY3RzLmNvbmNhdChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YobGludEV4dGVuc2lvbnMpKTtcbn1cbi8qKlxuUmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggdXBkYXRlcyB0aGUgY3VycmVudCBzZXQgb2ZcbmRpYWdub3N0aWNzLCBhbmQgZW5hYmxlcyB0aGUgbGludCBleHRlbnNpb24gaWYgaWYgd2Fzbid0IGFscmVhZHlcbmFjdGl2ZS5cbiovXG5mdW5jdGlvbiBzZXREaWFnbm9zdGljcyhzdGF0ZSwgZGlhZ25vc3RpY3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlZmZlY3RzOiBtYXliZUVuYWJsZUxpbnQoc3RhdGUsIFtzZXREaWFnbm9zdGljc0VmZmVjdC5vZihkaWFnbm9zdGljcyldKVxuICAgIH07XG59XG4vKipcblRoZSBzdGF0ZSBlZmZlY3QgdGhhdCB1cGRhdGVzIHRoZSBzZXQgb2YgYWN0aXZlIGRpYWdub3N0aWNzLiBDYW5cbmJlIHVzZWZ1bCB3aGVuIHdyaXRpbmcgYW4gZXh0ZW5zaW9uIHRoYXQgbmVlZHMgdG8gdHJhY2sgdGhlc2UuXG4qL1xuY29uc3Qgc2V0RGlhZ25vc3RpY3NFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IG1vdmVQYW5lbFNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGxpbnRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbnRTdGF0ZShEZWNvcmF0aW9uLm5vbmUsIG51bGwsIG51bGwpO1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBpZiAodHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHZhbHVlLmRpYWdub3N0aWNzLm1hcCh0ci5jaGFuZ2VzKSwgc2VsZWN0ZWQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbFBvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLnNlbGVjdGVkLmZyb20sIDEpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gZmluZERpYWdub3N0aWMobWFwcGVkLCB2YWx1ZS5zZWxlY3RlZC5kaWFnbm9zdGljLCBzZWxQb3MpIHx8IGZpbmREaWFnbm9zdGljKG1hcHBlZCwgbnVsbCwgc2VsUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZShtYXBwZWQsIHZhbHVlLnBhbmVsLCBzZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0RGlhZ25vc3RpY3NFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMaW50U3RhdGUuaW5pdChlZmZlY3QudmFsdWUsIHZhbHVlLnBhbmVsLCB0ci5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXModG9nZ2xlUGFuZWwpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKHZhbHVlLmRpYWdub3N0aWNzLCBlZmZlY3QudmFsdWUgPyBMaW50UGFuZWwub3BlbiA6IG51bGwsIHZhbHVlLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhtb3ZlUGFuZWxTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTGludFN0YXRlKHZhbHVlLmRpYWdub3N0aWNzLCB2YWx1ZS5wYW5lbCwgZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IFtzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsLnBhbmVsKSxcbiAgICAgICAgRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYsIHMgPT4gcy5kaWFnbm9zdGljcyldXG59KTtcbi8qKlxuUmV0dXJucyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBsaW50IGRpYWdub3N0aWNzIGluIHRoZSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiBkaWFnbm9zdGljQ291bnQoc3RhdGUpIHtcbiAgICBsZXQgbGludCA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBsaW50ID8gbGludC5kaWFnbm9zdGljcy5zaXplIDogMDtcbn1cbmNvbnN0IGFjdGl2ZU1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbGludFJhbmdlIGNtLWxpbnRSYW5nZS1hY3RpdmVcIiwgaW5jbHVzaXZlOiB0cnVlIH0pO1xuZnVuY3Rpb24gbGludFRvb2x0aXAodmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHsgZGlhZ25vc3RpY3MgfSA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICBsZXQgZm91bmQgPSBbXSwgc3RhY2tTdGFydCA9IDJlOCwgc3RhY2tFbmQgPSAwO1xuICAgIGRpYWdub3N0aWNzLmJldHdlZW4ocG9zIC0gKHNpZGUgPCAwID8gMSA6IDApLCBwb3MgKyAoc2lkZSA+IDAgPyAxIDogMCksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0byAmJlxuICAgICAgICAgICAgKGZyb20gPT0gdG8gfHwgKChwb3MgPiBmcm9tIHx8IHNpZGUgPiAwKSAmJiAocG9zIDwgdG8gfHwgc2lkZSA8IDApKSkpIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2goc3BlYy5kaWFnbm9zdGljKTtcbiAgICAgICAgICAgIHN0YWNrU3RhcnQgPSBNYXRoLm1pbihmcm9tLCBzdGFja1N0YXJ0KTtcbiAgICAgICAgICAgIHN0YWNrRW5kID0gTWF0aC5tYXgodG8sIHN0YWNrRW5kKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gdmlldy5zdGF0ZS5mYWNldChsaW50Q29uZmlnKS50b29sdGlwRmlsdGVyO1xuICAgIGlmIChkaWFnbm9zdGljRmlsdGVyKVxuICAgICAgICBmb3VuZCA9IGRpYWdub3N0aWNGaWx0ZXIoZm91bmQsIHZpZXcuc3RhdGUpO1xuICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IHN0YWNrU3RhcnQsXG4gICAgICAgIGVuZDogc3RhY2tFbmQsXG4gICAgICAgIGFib3ZlOiB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhY2tTdGFydCkudG8gPCBzdGFja0VuZCxcbiAgICAgICAgY3JlYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9tOiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZm91bmQpIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZGlhZ25vc3RpY3NUb29sdGlwKHZpZXcsIGRpYWdub3N0aWNzKSB7XG4gICAgcmV0dXJuIGVsdChcInVsXCIsIHsgY2xhc3M6IFwiY20tdG9vbHRpcC1saW50XCIgfSwgZGlhZ25vc3RpY3MubWFwKGQgPT4gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkLCBmYWxzZSkpKTtcbn1cbi8qKlxuQ29tbWFuZCB0byBvcGVuIGFuZCBmb2N1cyB0aGUgbGludCBwYW5lbC5cbiovXG5jb25zdCBvcGVuTGludFBhbmVsID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnBhbmVsKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGVMaW50KHZpZXcuc3RhdGUsIFt0b2dnbGVQYW5lbC5vZih0cnVlKV0pIH0pO1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIExpbnRQYW5lbC5vcGVuKTtcbiAgICBpZiAocGFuZWwpXG4gICAgICAgIHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLXBhbmVsLWxpbnQgdWxcIikuZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNvbW1hbmQgdG8gY2xvc2UgdGhlIGxpbnQgcGFuZWwsIHdoZW4gb3Blbi5cbiovXG5jb25zdCBjbG9zZUxpbnRQYW5lbCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5wYW5lbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0b2dnbGVQYW5lbC5vZihmYWxzZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBuZXh0RGlhZ25vc3RpYyA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGZpZWxkID0gdmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIWZpZWxkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIG5leHQgPSBmaWVsZC5kaWFnbm9zdGljcy5pdGVyKHNlbC50byArIDEpO1xuICAgIGlmICghbmV4dC52YWx1ZSkge1xuICAgICAgICBuZXh0ID0gZmllbGQuZGlhZ25vc3RpY3MuaXRlcigwKTtcbiAgICAgICAgaWYgKCFuZXh0LnZhbHVlIHx8IG5leHQuZnJvbSA9PSBzZWwuZnJvbSAmJiBuZXh0LnRvID09IHNlbC50bylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IG5leHQuZnJvbSwgaGVhZDogbmV4dC50byB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgZGlhZ25vc3RpYy5cbiovXG5jb25zdCBwcmV2aW91c0RpYWdub3N0aWMgPSAodmlldykgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHByZXZGcm9tLCBwcmV2VG8sIGxhc3RGcm9tLCBsYXN0VG87XG4gICAgZmllbGQuZGlhZ25vc3RpY3MuYmV0d2VlbigwLCBzdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgaWYgKHRvIDwgc2VsLnRvICYmIChwcmV2RnJvbSA9PSBudWxsIHx8IHByZXZGcm9tIDwgZnJvbSkpIHtcbiAgICAgICAgICAgIHByZXZGcm9tID0gZnJvbTtcbiAgICAgICAgICAgIHByZXZUbyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0RnJvbSA9PSBudWxsIHx8IGZyb20gPiBsYXN0RnJvbSkge1xuICAgICAgICAgICAgbGFzdEZyb20gPSBmcm9tO1xuICAgICAgICAgICAgbGFzdFRvID0gdG87XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAobGFzdEZyb20gPT0gbnVsbCB8fCBwcmV2RnJvbSA9PSBudWxsICYmIGxhc3RGcm9tID09IHNlbC5mcm9tKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IHNlbGVjdGlvbjogeyBhbmNob3I6IHByZXZGcm9tICE9PSBudWxsICYmIHByZXZGcm9tICE9PSB2b2lkIDAgPyBwcmV2RnJvbSA6IGxhc3RGcm9tLCBoZWFkOiBwcmV2VG8gIT09IG51bGwgJiYgcHJldlRvICE9PSB2b2lkIDAgPyBwcmV2VG8gOiBsYXN0VG8gfSwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BIHNldCBvZiBkZWZhdWx0IGtleSBiaW5kaW5ncyBmb3IgdGhlIGxpbnQgZnVuY3Rpb25hbGl0eS5cblxuLSBDdHJsLVNoaWZ0LW0gKENtZC1TaGlmdC1tIG9uIG1hY09TKTogW2BvcGVuTGludFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50Lm9wZW5MaW50UGFuZWwpXG4tIEY4OiBbYG5leHREaWFnbm9zdGljYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsaW50Lm5leHREaWFnbm9zdGljKVxuKi9cbmNvbnN0IGxpbnRLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LW1cIiwgcnVuOiBvcGVuTGludFBhbmVsLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkY4XCIsIHJ1bjogbmV4dERpYWdub3N0aWMgfVxuXTtcbmNvbnN0IGxpbnRQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0ID0gdHJ1ZTtcbiAgICAgICAgbGV0IHsgZGVsYXkgfSA9IHZpZXcuc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXk7XG4gICAgICAgIHRoaXMucnVuID0gdGhpcy5ydW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgZGVsYXkpO1xuICAgIH1cbiAgICBydW4oKSB7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IDwgdGhpcy5saW50VGltZSAtIDEwKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucnVuLCB0aGlzLmxpbnRUaW1lIC0gbm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCB7IHNvdXJjZXMgfSA9IHN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHNvdXJjZXMubWFwKHNvdXJjZSA9PiBQcm9taXNlLnJlc29sdmUoc291cmNlKHRoaXMudmlldykpKSkudGhlbihhbm5vdGF0aW9ucyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbGwgPSBhbm5vdGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5kb2MgPT0gc3RhdGUuZG9jKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHNldERpYWdub3N0aWNzKHRoaXMudmlldy5zdGF0ZSwgYWxsKSk7XG4gICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4geyBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnJvcik7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHVwZGF0ZS5zdGF0ZS5mYWNldChsaW50Q29uZmlnKTtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IGNvbmZpZyAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsaW50Q29uZmlnKSB8fFxuICAgICAgICAgICAgY29uZmlnLm5lZWRzUmVmcmVzaCAmJiBjb25maWcubmVlZHNSZWZyZXNoKHVwZGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpICsgY29uZmlnLmRlbGF5O1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucnVuLCBjb25maWcuZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvcmNlKCkge1xuICAgICAgICBpZiAodGhpcy5zZXQpIHtcbiAgICAgICAgICAgIHRoaXMubGludFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICB9XG59KTtcbmNvbnN0IGxpbnRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgc291cmNlczogaW5wdXQubWFwKGkgPT4gaS5zb3VyY2UpLmZpbHRlcih4ID0+IHggIT0gbnVsbCkgfSwgY29tYmluZUNvbmZpZyhpbnB1dC5tYXAoaSA9PiBpLmNvbmZpZyksIHtcbiAgICAgICAgICAgIGRlbGF5OiA3NTAsXG4gICAgICAgICAgICBtYXJrZXJGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwRmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgbmVlZHNSZWZyZXNoOiBudWxsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5lZWRzUmVmcmVzaDogKGEsIGIpID0+ICFhID8gYiA6ICFiID8gYSA6IHUgPT4gYSh1KSB8fCBiKHUpXG4gICAgICAgIH0pKTtcbiAgICB9XG59KTtcbi8qKlxuR2l2ZW4gYSBkaWFnbm9zdGljIHNvdXJjZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0XG5lbmFibGVzIGxpbnRpbmcgd2l0aCB0aGF0IHNvdXJjZS4gSXQgd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlXG5lZGl0b3IgaXMgaWRsZSAoYWZ0ZXIgaXRzIGNvbnRlbnQgY2hhbmdlZCkuIElmIGBudWxsYCBpcyBnaXZlbiBhc1xuc291cmNlLCB0aGlzIG9ubHkgY29uZmlndXJlcyB0aGUgbGludCBleHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gbGludGVyKHNvdXJjZSwgY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBsaW50Q29uZmlnLm9mKHsgc291cmNlLCBjb25maWcgfSksXG4gICAgICAgIGxpbnRQbHVnaW4sXG4gICAgICAgIGxpbnRFeHRlbnNpb25zXG4gICAgXTtcbn1cbi8qKlxuRm9yY2VzIGFueSBsaW50ZXJzIFtjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubGludGVyKSB0byBydW4gd2hlbiB0aGVcbmVkaXRvciBpcyBpZGxlIHRvIHJ1biByaWdodCBhd2F5LlxuKi9cbmZ1bmN0aW9uIGZvcmNlTGludGluZyh2aWV3KSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKGxpbnRQbHVnaW4pO1xuICAgIGlmIChwbHVnaW4pXG4gICAgICAgIHBsdWdpbi5mb3JjZSgpO1xufVxuZnVuY3Rpb24gYXNzaWduS2V5cyhhY3Rpb25zKSB7XG4gICAgbGV0IGFzc2lnbmVkID0gW107XG4gICAgaWYgKGFjdGlvbnMpXG4gICAgICAgIGFjdGlvbnM6IGZvciAobGV0IHsgbmFtZSB9IG9mIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IG5hbWVbaV07XG4gICAgICAgICAgICAgICAgaWYgKC9bYS16QS1aXS8udGVzdChjaCkgJiYgIWFzc2lnbmVkLnNvbWUoYyA9PiBjLnRvTG93ZXJDYXNlKCkgPT0gY2gudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGFjdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduZWQucHVzaChcIlwiKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBhc3NpZ25lZDtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpYWdub3N0aWModmlldywgZGlhZ25vc3RpYywgaW5QYW5lbCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQga2V5cyA9IGluUGFuZWwgPyBhc3NpZ25LZXlzKGRpYWdub3N0aWMuYWN0aW9ucykgOiBbXTtcbiAgICByZXR1cm4gZWx0KFwibGlcIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljIGNtLWRpYWdub3N0aWMtXCIgKyBkaWFnbm9zdGljLnNldmVyaXR5IH0sIGVsdChcInNwYW5cIiwgeyBjbGFzczogXCJjbS1kaWFnbm9zdGljVGV4dFwiIH0sIGRpYWdub3N0aWMucmVuZGVyTWVzc2FnZSA/IGRpYWdub3N0aWMucmVuZGVyTWVzc2FnZSgpIDogZGlhZ25vc3RpYy5tZXNzYWdlKSwgKF9hID0gZGlhZ25vc3RpYy5hY3Rpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChhY3Rpb24sIGkpID0+IHtcbiAgICAgICAgbGV0IGZpcmVkID0gZmFsc2UsIGNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChmaXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmaW5kRGlhZ25vc3RpYyh2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIGFjdGlvbi5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IG5hbWUgfSA9IGFjdGlvbiwga2V5SW5kZXggPSBrZXlzW2ldID8gbmFtZS5pbmRleE9mKGtleXNbaV0pIDogLTE7XG4gICAgICAgIGxldCBuYW1lRWx0ID0ga2V5SW5kZXggPCAwID8gbmFtZSA6IFtuYW1lLnNsaWNlKDAsIGtleUluZGV4KSxcbiAgICAgICAgICAgIGVsdChcInVcIiwgbmFtZS5zbGljZShrZXlJbmRleCwga2V5SW5kZXggKyAxKSksXG4gICAgICAgICAgICBuYW1lLnNsaWNlKGtleUluZGV4ICsgMSldO1xuICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1kaWFnbm9zdGljQWN0aW9uXCIsXG4gICAgICAgICAgICBvbmNsaWNrOiBjbGljayxcbiAgICAgICAgICAgIG9ubW91c2Vkb3duOiBjbGljayxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBgIEFjdGlvbjogJHtuYW1lfSR7a2V5SW5kZXggPCAwID8gXCJcIiA6IGAgKGFjY2VzcyBrZXkgXCIke2tleXNbaV19KVwiYH0uYFxuICAgICAgICB9LCBuYW1lRWx0KTtcbiAgICB9KSwgZGlhZ25vc3RpYy5zb3VyY2UgJiYgZWx0KFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpY1NvdXJjZVwiIH0sIGRpYWdub3N0aWMuc291cmNlKSk7XG59XG5jbGFzcyBEaWFnbm9zdGljV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuZGlhZ25vc3RpYyA9PSB0aGlzLmRpYWdub3N0aWM7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgcmV0dXJuIGVsdChcInNwYW5cIiwgeyBjbGFzczogXCJjbS1saW50UG9pbnQgY20tbGludFBvaW50LVwiICsgdGhpcy5kaWFnbm9zdGljLnNldmVyaXR5IH0pO1xuICAgIH1cbn1cbmNsYXNzIFBhbmVsSXRlbSB7XG4gICAgY29uc3RydWN0b3IodmlldywgZGlhZ25vc3RpYykge1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgICAgICB0aGlzLmlkID0gXCJpdGVtX1wiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICB0aGlzLmRvbSA9IHJlbmRlckRpYWdub3N0aWModmlldywgZGlhZ25vc3RpYywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZG9tLmlkID0gdGhpcy5pZDtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcbiAgICB9XG59XG5jbGFzcyBMaW50UGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICBsZXQgb25rZXlkb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBjbG9zZUxpbnRQYW5lbCh0aGlzLnZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzOCB8fCBldmVudC5rZXlDb2RlID09IDMzKSB7IC8vIEFycm93VXAsIFBhZ2VVcFxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigodGhpcy5zZWxlY3RlZEluZGV4IC0gMSArIHRoaXMuaXRlbXMubGVuZ3RoKSAlIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gNDAgfHwgZXZlbnQua2V5Q29kZSA9PSAzNCkgeyAvLyBBcnJvd0Rvd24sIFBhZ2VEb3duXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKCh0aGlzLnNlbGVjdGVkSW5kZXggKyAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzYpIHsgLy8gSG9tZVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzUpIHsgLy8gRW5kXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKHRoaXMuaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7IC8vIEVudGVyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID49IDY1ICYmIGV2ZW50LmtleUNvZGUgPD0gOTAgJiYgdGhpcy5zZWxlY3RlZEluZGV4ID49IDApIHsgLy8gQS1aXG4gICAgICAgICAgICAgICAgbGV0IHsgZGlhZ25vc3RpYyB9ID0gdGhpcy5pdGVtc1t0aGlzLnNlbGVjdGVkSW5kZXhdLCBrZXlzID0gYXNzaWduS2V5cyhkaWFnbm9zdGljLmFjdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbaV0udG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApID09IGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZpbmREaWFnbm9zdGljKHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpLmRpYWdub3N0aWNzLCBkaWFnbm9zdGljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljLmFjdGlvbnNbaV0uYXBwbHkodmlldywgZm91bmQuZnJvbSwgZm91bmQudG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgb25jbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaV0uZG9tLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0ID0gZWx0KFwidWxcIiwge1xuICAgICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgICByb2xlOiBcImxpc3Rib3hcIixcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiRGlhZ25vc3RpY3NcIiksXG4gICAgICAgICAgICBvbmtleWRvd24sXG4gICAgICAgICAgICBvbmNsaWNrXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbSA9IGVsdChcImRpdlwiLCB7IGNsYXNzOiBcImNtLXBhbmVsLWxpbnRcIiB9LCB0aGlzLmxpc3QsIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgbmFtZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJjbG9zZVwiKSxcbiAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IGNsb3NlTGludFBhbmVsKHRoaXMudmlldylcbiAgICAgICAgfSwgXCLDl1wiKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5zZWxlY3RlZDtcbiAgICAgICAgaWYgKCFzZWxlY3RlZClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaV0uZGlhZ25vc3RpYyA9PSBzZWxlY3RlZC5kaWFnbm9zdGljKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgZGlhZ25vc3RpY3MsIHNlbGVjdGVkIH0gPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICAgICAgbGV0IGkgPSAwLCBuZWVkc1N5bmMgPSBmYWxzZSwgbmV3U2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgZGlhZ25vc3RpY3MuYmV0d2VlbigwLCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgKF9zdGFydCwgX2VuZCwgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IC0xLCBpdGVtO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCB0aGlzLml0ZW1zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2pdLmRpYWdub3N0aWMgPT0gc3BlYy5kaWFnbm9zdGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gajtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBuZXcgUGFuZWxJdGVtKHRoaXMudmlldywgc3BlYy5kaWFnbm9zdGljKTtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpLCAwLCBpdGVtKTtcbiAgICAgICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbZm91bmRdO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgZm91bmQgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgJiYgaXRlbS5kaWFnbm9zdGljID09IHNlbGVjdGVkLmRpYWdub3N0aWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uZG9tLmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlbGVjdGVkSXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5kb20uaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZG9tLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuaXRlbXMubGVuZ3RoICYmICEodGhpcy5pdGVtcy5sZW5ndGggPT0gMSAmJiB0aGlzLml0ZW1zWzBdLmRpYWdub3N0aWMuZnJvbSA8IDApKSB7XG4gICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ldyBQYW5lbEl0ZW0odGhpcy52aWV3LCB7XG4gICAgICAgICAgICAgICAgZnJvbTogLTEsIHRvOiAtMSxcbiAgICAgICAgICAgICAgICBzZXZlcml0eTogXCJpbmZvXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIk5vIGRpYWdub3N0aWNzXCIpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgbmV3U2VsZWN0ZWRJdGVtLmlkKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh7XG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLFxuICAgICAgICAgICAgICAgIHJlYWQ6ICgpID0+ICh7IHNlbDogbmV3U2VsZWN0ZWRJdGVtLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgcGFuZWw6IHRoaXMubGlzdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB9KSxcbiAgICAgICAgICAgICAgICB3cml0ZTogKHsgc2VsLCBwYW5lbCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2FsZVkgPSBwYW5lbC5oZWlnaHQgLyB0aGlzLmxpc3Qub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsLnRvcCA8IHBhbmVsLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgLT0gKHBhbmVsLnRvcCAtIHNlbC50b3ApIC8gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWwuYm90dG9tID4gcGFuZWwuYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvcCArPSAoc2VsLmJvdHRvbSAtIHBhbmVsLmJvdHRvbSkgLyBzY2FsZVk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhpcy5saXN0LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZHNTeW5jKVxuICAgICAgICAgICAgdGhpcy5zeW5jKCk7XG4gICAgfVxuICAgIHN5bmMoKSB7XG4gICAgICAgIGxldCBkb21Qb3MgPSB0aGlzLmxpc3QuZmlyc3RDaGlsZDtcbiAgICAgICAgZnVuY3Rpb24gcm0oKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGRvbVBvcztcbiAgICAgICAgICAgIGRvbVBvcyA9IHByZXYubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBwcmV2LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5saXN0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbVBvcyAhPSBpdGVtLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgcm0oKTtcbiAgICAgICAgICAgICAgICBkb21Qb3MgPSBpdGVtLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5pbnNlcnRCZWZvcmUoaXRlbS5kb20sIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRvbVBvcylcbiAgICAgICAgICAgIHJtKCk7XG4gICAgfVxuICAgIG1vdmVTZWxlY3Rpb24oc2VsZWN0ZWRJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGZpZWxkID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBmaW5kRGlhZ25vc3RpYyhmaWVsZC5kaWFnbm9zdGljcywgdGhpcy5pdGVtc1tzZWxlY3RlZEluZGV4XS5kaWFnbm9zdGljKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBzZWxlY3Rpb24uZnJvbSwgaGVhZDogc2VsZWN0aW9uLnRvIH0sXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIGVmZmVjdHM6IG1vdmVQYW5lbFNlbGVjdGlvbi5vZihzZWxlY3Rpb24pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgb3Blbih2aWV3KSB7IHJldHVybiBuZXcgTGludFBhbmVsKHZpZXcpOyB9XG59XG5mdW5jdGlvbiBzdmcoY29udGVudCwgYXR0cnMgPSBgdmlld0JveD1cIjAgMCA0MCA0MFwiYCkge1xuICAgIHJldHVybiBgdXJsKCdkYXRhOmltYWdlL3N2Zyt4bWwsPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJHthdHRyc30+JHtlbmNvZGVVUklDb21wb25lbnQoY29udGVudCl9PC9zdmc+JylgO1xufVxuZnVuY3Rpb24gdW5kZXJsaW5lKGNvbG9yKSB7XG4gICAgcmV0dXJuIHN2ZyhgPHBhdGggZD1cIm0wIDIuNSBsMiAtMS41IGwxIDAgbDIgMS41IGwxIDBcIiBzdHJva2U9XCIke2NvbG9yfVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiLjdcIi8+YCwgYHdpZHRoPVwiNlwiIGhlaWdodD1cIjNcImApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1kaWFnbm9zdGljXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIzcHggNnB4IDNweCA4cHhcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMXB4XCIsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmUtd3JhcFwiXG4gICAgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLWVycm9yXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgI2QxMVwiIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpYy13YXJuaW5nXCI6IHsgYm9yZGVyTGVmdDogXCI1cHggc29saWQgb3JhbmdlXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLWluZm9cIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjOTk5XCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLWhpbnRcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjNjZkXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljQWN0aW9uXCI6IHtcbiAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDRweFwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzQ0NFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiM3B4XCIsXG4gICAgICAgIG1hcmdpbkxlZnQ6IFwiOHB4XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWNTb3VyY2VcIjoge1xuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgb3BhY2l0eTogLjdcbiAgICB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJsZWZ0IGJvdHRvbVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcInJlcGVhdC14XCIsXG4gICAgICAgIHBhZGRpbmdCb3R0b206IFwiMC43cHhcIixcbiAgICB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1lcnJvclwiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIiNkMTFcIikgfSxcbiAgICBcIi5jbS1saW50UmFuZ2Utd2FybmluZ1wiOiB7IGJhY2tncm91bmRJbWFnZTogLypAX19QVVJFX18qL3VuZGVybGluZShcIm9yYW5nZVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1pbmZvXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwiIzk5OVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1oaW50XCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwiIzY2ZFwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS1hY3RpdmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZGQ5OTgwXCIgfSxcbiAgICBcIi5jbS10b29sdGlwLWxpbnRcIjoge1xuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBtYXJnaW46IDBcbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgbGVmdDogXCItMnB4XCIsXG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBcIjNweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IFwiM3B4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b206IFwiNHB4IHNvbGlkICNkMTFcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW50UG9pbnQtd2FybmluZ1wiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGJvcmRlckJvdHRvbUNvbG9yOiBcIm9yYW5nZVwiIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC1pbmZvXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzk5OVwiIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC1oaW50XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwiIzY2ZFwiIH1cbiAgICB9LFxuICAgIFwiLmNtLXBhbmVsLmNtLXBhbmVsLWxpbnRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiYgdWxcIjoge1xuICAgICAgICAgICAgbWF4SGVpZ2h0OiBcIjEwMHB4XCIsXG4gICAgICAgICAgICBvdmVyZmxvd1k6IFwiYXV0b1wiLFxuICAgICAgICAgICAgXCImIFthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNkZGRcIixcbiAgICAgICAgICAgICAgICBcIiYgdVwiOiB7IHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6Zm9jdXMgW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kX2ZhbGxiYWNrOiBcIiNiZGZcIixcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiSGlnaGxpZ2h0XCIsXG4gICAgICAgICAgICAgICAgY29sb3JfZmFsbGJhY2s6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICBjb2xvcjogXCJIaWdobGlnaHRUZXh0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiYgdVwiOiB7IHRleHREZWNvcmF0aW9uOiBcIm5vbmVcIiB9LFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9LFxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiMFwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiMnB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuZnVuY3Rpb24gc2V2ZXJpdHlXZWlnaHQoc2V2KSB7XG4gICAgcmV0dXJuIHNldiA9PSBcImVycm9yXCIgPyA0IDogc2V2ID09IFwid2FybmluZ1wiID8gMyA6IHNldiA9PSBcImluZm9cIiA/IDIgOiAxO1xufVxuY2xhc3MgTGludEd1dHRlck1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpY3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICAgICAgICB0aGlzLnNldmVyaXR5ID0gZGlhZ25vc3RpY3MucmVkdWNlKChtYXgsIGQpID0+IHNldmVyaXR5V2VpZ2h0KG1heCkgPCBzZXZlcml0eVdlaWdodChkLnNldmVyaXR5KSA/IGQuc2V2ZXJpdHkgOiBtYXgsIFwiaGludFwiKTtcbiAgICB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IFwiY20tbGludC1tYXJrZXIgY20tbGludC1tYXJrZXItXCIgKyB0aGlzLnNldmVyaXR5O1xuICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSB0aGlzLmRpYWdub3N0aWNzO1xuICAgICAgICBsZXQgZGlhZ25vc3RpY3NGaWx0ZXIgPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRHdXR0ZXJDb25maWcpLnRvb2x0aXBGaWx0ZXI7XG4gICAgICAgIGlmIChkaWFnbm9zdGljc0ZpbHRlcilcbiAgICAgICAgICAgIGRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3NGaWx0ZXIoZGlhZ25vc3RpY3MsIHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAoZGlhZ25vc3RpY3MubGVuZ3RoKVxuICAgICAgICAgICAgZWx0Lm9ubW91c2VvdmVyID0gKCkgPT4gZ3V0dGVyTWFya2VyTW91c2VPdmVyKHZpZXcsIGVsdCwgZGlhZ25vc3RpY3MpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYWNrSG92ZXJPbih2aWV3LCBtYXJrZXIpIHtcbiAgICBsZXQgbW91c2Vtb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCByZWN0ID0gbWFya2VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WCA+IHJlY3QubGVmdCAtIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJiBldmVudC5jbGllbnRYIDwgcmVjdC5yaWdodCArIDEwIC8qIEhvdmVyLk1hcmdpbiAqLyAmJlxuICAgICAgICAgICAgZXZlbnQuY2xpZW50WSA+IHJlY3QudG9wIC0gMTAgLyogSG92ZXIuTWFyZ2luICovICYmIGV2ZW50LmNsaWVudFkgPCByZWN0LmJvdHRvbSArIDEwIC8qIEhvdmVyLk1hcmdpbiAqLylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0OyB0YXJnZXQ7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlID09IDEgJiYgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImNtLXRvb2x0aXAtbGludFwiKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlKTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmllbGQobGludEd1dHRlclRvb2x0aXApKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldExpbnRHdXR0ZXJUb29sdGlwLm9mKG51bGwpIH0pO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlKTtcbn1cbmZ1bmN0aW9uIGd1dHRlck1hcmtlck1vdXNlT3Zlcih2aWV3LCBtYXJrZXIsIGRpYWdub3N0aWNzKSB7XG4gICAgZnVuY3Rpb24gaG92ZXJlZCgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmVsZW1lbnRBdEhlaWdodChtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgNSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICAgICBjb25zdCBsaW5lUG9zID0gdmlldy5jb29yZHNBdFBvcyhsaW5lLmZyb20pO1xuICAgICAgICBpZiAobGluZVBvcykge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldExpbnRHdXR0ZXJUb29sdGlwLm9mKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBsaW5lLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIGFib3ZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb206IGRpYWdub3N0aWNzVG9vbHRpcCh2aWV3LCBkaWFnbm9zdGljcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29vcmRzOiAoKSA9PiBtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrZXIub25tb3VzZW91dCA9IG1hcmtlci5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIHRyYWNrSG92ZXJPbih2aWV3LCBtYXJrZXIpO1xuICAgIH1cbiAgICBsZXQgeyBob3ZlclRpbWUgfSA9IHZpZXcuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZyk7XG4gICAgbGV0IGhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQoaG92ZXJlZCwgaG92ZXJUaW1lKTtcbiAgICBtYXJrZXIub25tb3VzZW91dCA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhvdmVyVGltZW91dCk7XG4gICAgICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gbWFya2VyLm9ubW91c2Vtb3ZlID0gbnVsbDtcbiAgICB9O1xuICAgIG1hcmtlci5vbm1vdXNlbW92ZSA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhvdmVyVGltZW91dCk7XG4gICAgICAgIGhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQoaG92ZXJlZCwgaG92ZXJUaW1lKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFya2Vyc0ZvckRpYWdub3N0aWNzKGRvYywgZGlhZ25vc3RpY3MpIHtcbiAgICBsZXQgYnlMaW5lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBkaWFnbm9zdGljIG9mIGRpYWdub3N0aWNzKSB7XG4gICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChkaWFnbm9zdGljLmZyb20pO1xuICAgICAgICAoYnlMaW5lW2xpbmUuZnJvbV0gfHwgKGJ5TGluZVtsaW5lLmZyb21dID0gW10pKS5wdXNoKGRpYWdub3N0aWMpO1xuICAgIH1cbiAgICBsZXQgbWFya2VycyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgaW4gYnlMaW5lKSB7XG4gICAgICAgIG1hcmtlcnMucHVzaChuZXcgTGludEd1dHRlck1hcmtlcihieUxpbmVbbGluZV0pLnJhbmdlKCtsaW5lKSk7XG4gICAgfVxuICAgIHJldHVybiBSYW5nZVNldC5vZihtYXJrZXJzLCB0cnVlKTtcbn1cbmNvbnN0IGxpbnRHdXR0ZXJFeHRlbnNpb24gPSAvKkBfX1BVUkVfXyovZ3V0dGVyKHtcbiAgICBjbGFzczogXCJjbS1ndXR0ZXItbGludFwiLFxuICAgIG1hcmtlcnM6IHZpZXcgPT4gdmlldy5zdGF0ZS5maWVsZChsaW50R3V0dGVyTWFya2VycyksXG59KTtcbmNvbnN0IGxpbnRHdXR0ZXJNYXJrZXJzID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBSYW5nZVNldC5lbXB0eTtcbiAgICB9LFxuICAgIHVwZGF0ZShtYXJrZXJzLCB0cikge1xuICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gdHIuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZykubWFya2VyRmlsdGVyO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGRpYWdub3N0aWNGaWx0ZXIpXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzID0gZGlhZ25vc3RpY0ZpbHRlcihkaWFnbm9zdGljcyB8fCBbXSwgdHIuc3RhdGUpO1xuICAgICAgICAgICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzRm9yRGlhZ25vc3RpY3ModHIuc3RhdGUuZG9jLCBkaWFnbm9zdGljcy5zbGljZSgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfVxufSk7XG5jb25zdCBzZXRMaW50R3V0dGVyVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IGxpbnRHdXR0ZXJUb29sdGlwID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgIHVwZGF0ZSh0b29sdGlwLCB0cikge1xuICAgICAgICBpZiAodG9vbHRpcCAmJiB0ci5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgdG9vbHRpcCA9IGhpZGVUb29sdGlwKHRyLCB0b29sdGlwKSA/IG51bGwgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRvb2x0aXApLCB7IHBvczogdHIuY2hhbmdlcy5tYXBQb3ModG9vbHRpcC5wb3MpIH0pO1xuICAgICAgICByZXR1cm4gdHIuZWZmZWN0cy5yZWR1Y2UoKHQsIGUpID0+IGUuaXMoc2V0TGludEd1dHRlclRvb2x0aXApID8gZS52YWx1ZSA6IHQsIHRvb2x0aXApO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZmllbGQgPT4gc2hvd1Rvb2x0aXAuZnJvbShmaWVsZClcbn0pO1xuY29uc3QgbGludEd1dHRlclRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1ndXR0ZXItbGludFwiOiB7XG4gICAgICAgIHdpZHRoOiBcIjEuNGVtXCIsXG4gICAgICAgIFwiJiAuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiBcIi4yZW1cIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlclwiOiB7XG4gICAgICAgIHdpZHRoOiBcIjFlbVwiLFxuICAgICAgICBoZWlnaHQ6IFwiMWVtXCJcbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyLWluZm9cIjoge1xuICAgICAgICBjb250ZW50OiAvKkBfX1BVUkVfXyovc3ZnKGA8cGF0aCBmaWxsPVwiI2FhZlwiIHN0cm9rZT1cIiM3N2VcIiBzdHJva2Utd2lkdGg9XCI2XCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTUgNUwzNSA1TDM1IDM1TDUgMzVaXCIvPmApXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci13YXJuaW5nXCI6IHtcbiAgICAgICAgY29udGVudDogLypAX19QVVJFX18qL3N2ZyhgPHBhdGggZmlsbD1cIiNmZThcIiBzdHJva2U9XCIjZmQ3XCIgc3Ryb2tlLXdpZHRoPVwiNlwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0yMCA2TDM3IDM1TDMgMzVaXCIvPmApLFxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXItZXJyb3JcIjoge1xuICAgICAgICBjb250ZW50OiAvKkBfX1BVUkVfXyovc3ZnKGA8Y2lyY2xlIGN4PVwiMjBcIiBjeT1cIjIwXCIgcj1cIjE1XCIgZmlsbD1cIiNmODdcIiBzdHJva2U9XCIjZjQzXCIgc3Ryb2tlLXdpZHRoPVwiNlwiLz5gKVxuICAgIH0sXG59KTtcbmNvbnN0IGxpbnRFeHRlbnNpb25zID0gW1xuICAgIGxpbnRTdGF0ZSxcbiAgICAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5jb21wdXRlKFtsaW50U3RhdGVdLCBzdGF0ZSA9PiB7XG4gICAgICAgIGxldCB7IHNlbGVjdGVkLCBwYW5lbCB9ID0gc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICAgICAgcmV0dXJuICFzZWxlY3RlZCB8fCAhcGFuZWwgfHwgc2VsZWN0ZWQuZnJvbSA9PSBzZWxlY3RlZC50byA/IERlY29yYXRpb24ubm9uZSA6IERlY29yYXRpb24uc2V0KFtcbiAgICAgICAgICAgIGFjdGl2ZU1hcmsucmFuZ2Uoc2VsZWN0ZWQuZnJvbSwgc2VsZWN0ZWQudG8pXG4gICAgICAgIF0pO1xuICAgIH0pLFxuICAgIC8qQF9fUFVSRV9fKi9ob3ZlclRvb2x0aXAobGludFRvb2x0aXAsIHsgaGlkZU9uOiBoaWRlVG9vbHRpcCB9KSxcbiAgICBiYXNlVGhlbWVcbl07XG5jb25zdCBsaW50R3V0dGVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGhvdmVyVGltZTogMzAwIC8qIEhvdmVyLlRpbWUgKi8sXG4gICAgICAgICAgICBtYXJrZXJGaWx0ZXI6IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwRmlsdGVyOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGluc3RhbGxzIGEgZ3V0dGVyIHNob3dpbmcgbWFya2VycyBmb3JcbmVhY2ggbGluZSB0aGF0IGhhcyBkaWFnbm9zdGljcywgd2hpY2ggY2FuIGJlIGhvdmVyZWQgb3ZlciB0byBzZWVcbnRoZSBkaWFnbm9zdGljcy5cbiovXG5mdW5jdGlvbiBsaW50R3V0dGVyKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIFtsaW50R3V0dGVyQ29uZmlnLm9mKGNvbmZpZyksIGxpbnRHdXR0ZXJNYXJrZXJzLCBsaW50R3V0dGVyRXh0ZW5zaW9uLCBsaW50R3V0dGVyVGhlbWUsIGxpbnRHdXR0ZXJUb29sdGlwXTtcbn1cbi8qKlxuSXRlcmF0ZSBvdmVyIHRoZSBtYXJrZWQgZGlhZ25vc3RpY3MgZm9yIHRoZSBnaXZlbiBlZGl0b3Igc3RhdGUsXG5jYWxsaW5nIGBmYCBmb3IgZWFjaCBvZiB0aGVtLiBOb3RlIHRoYXQsIGlmIHRoZSBkb2N1bWVudCBjaGFuZ2VkXG5zaW5jZSB0aGUgZGlhZ25vc3RpY3Mgd2VyZSBjcmVhdGVkLCB0aGUgYERpYWdub3N0aWNgIG9iamVjdCB3aWxsXG5ob2xkIHRoZSBvcmlnaW5hbCBvdXRkYXRlZCBwb3NpdGlvbiwgd2hlcmVhcyB0aGUgYHRvYCBhbmQgYGZyb21gXG5hcmd1bWVudHMgaG9sZCB0aGUgZGlhZ25vc3RpYydzIGN1cnJlbnQgcG9zaXRpb24uXG4qL1xuZnVuY3Rpb24gZm9yRWFjaERpYWdub3N0aWMoc3RhdGUsIGYpIHtcbiAgICBsZXQgbFN0YXRlID0gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKGxTdGF0ZSAmJiBsU3RhdGUuZGlhZ25vc3RpY3Muc2l6ZSlcbiAgICAgICAgZm9yIChsZXQgaXRlciA9IFJhbmdlU2V0Lml0ZXIoW2xTdGF0ZS5kaWFnbm9zdGljc10pOyBpdGVyLnZhbHVlOyBpdGVyLm5leHQoKSlcbiAgICAgICAgICAgIGYoaXRlci52YWx1ZS5zcGVjLmRpYWdub3N0aWMsIGl0ZXIuZnJvbSwgaXRlci50byk7XG59XG5cbmV4cG9ydCB7IGNsb3NlTGludFBhbmVsLCBkaWFnbm9zdGljQ291bnQsIGZvckVhY2hEaWFnbm9zdGljLCBmb3JjZUxpbnRpbmcsIGxpbnRHdXR0ZXIsIGxpbnRLZXltYXAsIGxpbnRlciwgbmV4dERpYWdub3N0aWMsIG9wZW5MaW50UGFuZWwsIHByZXZpb3VzRGlhZ25vc3RpYywgc2V0RGlhZ25vc3RpY3MsIHNldERpYWdub3N0aWNzRWZmZWN0IH07XG4iXSwibmFtZXMiOlsiRGVjb3JhdGlvbiIsInNob3dQYW5lbCIsIkVkaXRvclZpZXciLCJWaWV3UGx1Z2luIiwibG9nRXhjZXB0aW9uIiwiZ3V0dGVyIiwic2hvd1Rvb2x0aXAiLCJob3ZlclRvb2x0aXAiLCJnZXRQYW5lbCIsIldpZGdldFR5cGUiLCJHdXR0ZXJNYXJrZXIiLCJTdGF0ZUVmZmVjdCIsIlN0YXRlRmllbGQiLCJGYWNldCIsImNvbWJpbmVDb25maWciLCJSYW5nZVNldCIsImVsdCIsIlNlbGVjdGVkRGlhZ25vc3RpYyIsImNvbnN0cnVjdG9yIiwiZnJvbSIsInRvIiwiZGlhZ25vc3RpYyIsIkxpbnRTdGF0ZSIsImRpYWdub3N0aWNzIiwicGFuZWwiLCJzZWxlY3RlZCIsImluaXQiLCJzdGF0ZSIsIm1hcmtlZERpYWdub3N0aWNzIiwiZGlhZ25vc3RpY0ZpbHRlciIsImZhY2V0IiwibGludENvbmZpZyIsIm1hcmtlckZpbHRlciIsInJhbmdlcyIsInNldCIsIm1hcCIsImQiLCJkb2MiLCJsaW5lQXQiLCJ3aWRnZXQiLCJEaWFnbm9zdGljV2lkZ2V0IiwicmFuZ2UiLCJtYXJrIiwiYXR0cmlidXRlcyIsImNsYXNzIiwic2V2ZXJpdHkiLCJtYXJrQ2xhc3MiLCJpbmNsdXNpdmUiLCJmaW5kRGlhZ25vc3RpYyIsImFmdGVyIiwiZm91bmQiLCJiZXR3ZWVuIiwic3BlYyIsImhpZGVUb29sdGlwIiwidHIiLCJ0b29sdGlwIiwibGluZSIsInN0YXJ0U3RhdGUiLCJwb3MiLCJlZmZlY3RzIiwic29tZSIsImUiLCJpcyIsInNldERpYWdub3N0aWNzRWZmZWN0IiwiY2hhbmdlcyIsInRvdWNoZXNSYW5nZSIsIm1heWJlRW5hYmxlTGludCIsImZpZWxkIiwibGludFN0YXRlIiwiY29uY2F0IiwiYXBwZW5kQ29uZmlnIiwib2YiLCJsaW50RXh0ZW5zaW9ucyIsInNldERpYWdub3N0aWNzIiwiZGVmaW5lIiwidG9nZ2xlUGFuZWwiLCJtb3ZlUGFuZWxTZWxlY3Rpb24iLCJjcmVhdGUiLCJub25lIiwidXBkYXRlIiwidmFsdWUiLCJkb2NDaGFuZ2VkIiwibWFwcGVkIiwic2VsUG9zIiwibWFwUG9zIiwiZWZmZWN0IiwiTGludFBhbmVsIiwib3BlbiIsInByb3ZpZGUiLCJmIiwidmFsIiwiZGVjb3JhdGlvbnMiLCJzIiwiZGlhZ25vc3RpY0NvdW50IiwibGludCIsInNpemUiLCJhY3RpdmVNYXJrIiwibGludFRvb2x0aXAiLCJ2aWV3Iiwic2lkZSIsInN0YWNrU3RhcnQiLCJzdGFja0VuZCIsInB1c2giLCJNYXRoIiwibWluIiwibWF4IiwidG9vbHRpcEZpbHRlciIsImxlbmd0aCIsImVuZCIsImFib3ZlIiwiZG9tIiwiZGlhZ25vc3RpY3NUb29sdGlwIiwicmVuZGVyRGlhZ25vc3RpYyIsIm9wZW5MaW50UGFuZWwiLCJkaXNwYXRjaCIsInF1ZXJ5U2VsZWN0b3IiLCJmb2N1cyIsImNsb3NlTGludFBhbmVsIiwibmV4dERpYWdub3N0aWMiLCJzZWwiLCJzZWxlY3Rpb24iLCJtYWluIiwibmV4dCIsIml0ZXIiLCJhbmNob3IiLCJoZWFkIiwic2Nyb2xsSW50b1ZpZXciLCJwcmV2aW91c0RpYWdub3N0aWMiLCJwcmV2RnJvbSIsInByZXZUbyIsImxhc3RGcm9tIiwibGFzdFRvIiwibGludEtleW1hcCIsImtleSIsInJ1biIsInByZXZlbnREZWZhdWx0IiwibGludFBsdWdpbiIsImZyb21DbGFzcyIsInRpbWVvdXQiLCJkZWxheSIsImxpbnRUaW1lIiwiRGF0ZSIsIm5vdyIsImJpbmQiLCJzZXRUaW1lb3V0Iiwic291cmNlcyIsIlByb21pc2UiLCJhbGwiLCJzb3VyY2UiLCJyZXNvbHZlIiwidGhlbiIsImFubm90YXRpb25zIiwicmVkdWNlIiwiYSIsImIiLCJlcnJvciIsImNvbmZpZyIsIm5lZWRzUmVmcmVzaCIsImZvcmNlIiwiZGVzdHJveSIsImNsZWFyVGltZW91dCIsImNvbWJpbmUiLCJpbnB1dCIsIk9iamVjdCIsImFzc2lnbiIsImkiLCJmaWx0ZXIiLCJ4IiwidSIsImxpbnRlciIsImZvcmNlTGludGluZyIsInBsdWdpbiIsImFzc2lnbktleXMiLCJhY3Rpb25zIiwiYXNzaWduZWQiLCJuYW1lIiwiY2giLCJ0ZXN0IiwiYyIsInRvTG93ZXJDYXNlIiwiaW5QYW5lbCIsIl9hIiwia2V5cyIsInJlbmRlck1lc3NhZ2UiLCJtZXNzYWdlIiwiYWN0aW9uIiwiZmlyZWQiLCJjbGljayIsImFwcGx5Iiwia2V5SW5kZXgiLCJpbmRleE9mIiwibmFtZUVsdCIsInNsaWNlIiwidHlwZSIsIm9uY2xpY2siLCJvbm1vdXNlZG93biIsImVxIiwib3RoZXIiLCJ0b0RPTSIsIlBhbmVsSXRlbSIsImlkIiwiZmxvb3IiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNldEF0dHJpYnV0ZSIsIml0ZW1zIiwib25rZXlkb3duIiwiZXZlbnQiLCJrZXlDb2RlIiwibW92ZVNlbGVjdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJ0b1VwcGVyQ2FzZSIsImNoYXJDb2RlQXQiLCJjb250YWlucyIsInRhcmdldCIsImxpc3QiLCJ0YWJJbmRleCIsInJvbGUiLCJwaHJhc2UiLCJuZWVkc1N5bmMiLCJuZXdTZWxlY3RlZEl0ZW0iLCJfc3RhcnQiLCJfZW5kIiwiaXRlbSIsImoiLCJzcGxpY2UiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwb3AiLCJyZXF1ZXN0TWVhc3VyZSIsInJlYWQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3cml0ZSIsInNjYWxlWSIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsInRvcCIsInNjcm9sbFRvcCIsImJvdHRvbSIsInN5bmMiLCJkb21Qb3MiLCJmaXJzdENoaWxkIiwicm0iLCJwcmV2IiwibmV4dFNpYmxpbmciLCJyZW1vdmUiLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwic3ZnIiwiY29udGVudCIsImF0dHJzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidW5kZXJsaW5lIiwiY29sb3IiLCJiYXNlVGhlbWUiLCJwYWRkaW5nIiwibWFyZ2luTGVmdCIsImRpc3BsYXkiLCJ3aGl0ZVNwYWNlIiwiYm9yZGVyTGVmdCIsImZvbnQiLCJib3JkZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJSYWRpdXMiLCJjdXJzb3IiLCJmb250U2l6ZSIsIm9wYWNpdHkiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwicGFkZGluZ0JvdHRvbSIsImJhY2tncm91bmRJbWFnZSIsIm1hcmdpbiIsInBvc2l0aW9uIiwibGVmdCIsImJvcmRlclJpZ2h0IiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJtYXhIZWlnaHQiLCJvdmVyZmxvd1kiLCJ0ZXh0RGVjb3JhdGlvbiIsImJhY2tncm91bmRfZmFsbGJhY2siLCJjb2xvcl9mYWxsYmFjayIsInJpZ2h0IiwiYmFja2dyb3VuZCIsInNldmVyaXR5V2VpZ2h0Iiwic2V2IiwiTGludEd1dHRlck1hcmtlciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImRpYWdub3N0aWNzRmlsdGVyIiwibGludEd1dHRlckNvbmZpZyIsIm9ubW91c2VvdmVyIiwiZ3V0dGVyTWFya2VyTW91c2VPdmVyIiwidHJhY2tIb3Zlck9uIiwibWFya2VyIiwibW91c2Vtb3ZlIiwicmVjdCIsImNsaWVudFgiLCJjbGllbnRZIiwibm9kZVR5cGUiLCJjbGFzc0xpc3QiLCJ3aW5kb3ciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGludEd1dHRlclRvb2x0aXAiLCJzZXRMaW50R3V0dGVyVG9vbHRpcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJob3ZlcmVkIiwiZWxlbWVudEF0SGVpZ2h0IiwiZG9jdW1lbnRUb3AiLCJsaW5lUG9zIiwiY29vcmRzQXRQb3MiLCJnZXRDb29yZHMiLCJvbm1vdXNlb3V0Iiwib25tb3VzZW1vdmUiLCJob3ZlclRpbWUiLCJob3ZlclRpbWVvdXQiLCJtYXJrZXJzRm9yRGlhZ25vc3RpY3MiLCJieUxpbmUiLCJtYXJrZXJzIiwibGludEd1dHRlckV4dGVuc2lvbiIsImxpbnRHdXR0ZXJNYXJrZXJzIiwiZW1wdHkiLCJ0IiwibGludEd1dHRlclRoZW1lIiwid2lkdGgiLCJjb21wdXRlIiwiaGlkZU9uIiwiY29uZmlncyIsImxpbnRHdXR0ZXIiLCJmb3JFYWNoRGlhZ25vc3RpYyIsImxTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lint/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpCursor: () => (/* binding */ RegExpCursor),\n/* harmony export */   SearchCursor: () => (/* binding */ SearchCursor),\n/* harmony export */   SearchQuery: () => (/* binding */ SearchQuery),\n/* harmony export */   closeSearchPanel: () => (/* binding */ closeSearchPanel),\n/* harmony export */   findNext: () => (/* binding */ findNext),\n/* harmony export */   findPrevious: () => (/* binding */ findPrevious),\n/* harmony export */   getSearchQuery: () => (/* binding */ getSearchQuery),\n/* harmony export */   gotoLine: () => (/* binding */ gotoLine),\n/* harmony export */   highlightSelectionMatches: () => (/* binding */ highlightSelectionMatches),\n/* harmony export */   openSearchPanel: () => (/* binding */ openSearchPanel),\n/* harmony export */   replaceAll: () => (/* binding */ replaceAll),\n/* harmony export */   replaceNext: () => (/* binding */ replaceNext),\n/* harmony export */   search: () => (/* binding */ search),\n/* harmony export */   searchKeymap: () => (/* binding */ searchKeymap),\n/* harmony export */   searchPanelOpen: () => (/* binding */ searchPanelOpen),\n/* harmony export */   selectMatches: () => (/* binding */ selectMatches),\n/* harmony export */   selectNextOccurrence: () => (/* binding */ selectNextOccurrence),\n/* harmony export */   selectSelectionMatches: () => (/* binding */ selectSelectionMatches),\n/* harmony export */   setSearchQuery: () => (/* binding */ setSearchQuery)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? (x)=>x.normalize(\"NFKD\") : (x)=>x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/ class SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */ constructor(text, query, from = 0, to = text.length, normalize, test){\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */ this.value = {\n            from: 0,\n            to: 0\n        };\n        /**\n        Whether the end of the iterated region has been reached.\n        */ this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? (x)=>normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done) return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */ next() {\n        while(this.matches.length)this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */ nextOverlapping() {\n        for(;;){\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            let norm = this.normalize(str);\n            for(let i = 0, pos = start;; i++){\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n            }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for(let i = 0; i < this.matches.length; i += 2){\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = {\n                        from: this.matches[i + 1],\n                        to: end\n                    };\n                } else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1) match = {\n                from: pos,\n                to: end\n            };\n            else this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart)) match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\") SearchCursor.prototype[Symbol.iterator] = function() {\n    return this;\n};\nconst empty = {\n    from: -1,\n    to: -1,\n    match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/ class RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */ constructor(text, query, options, from = 0, to = text.length){\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */ this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */ this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        } else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to) this.curLine = \"\";\n        else this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */ next() {\n        for(let off = this.matchPos - this.curLineStart;;){\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length) this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            } else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            } else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/ new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text){\n        this.from = from;\n        this.text = text;\n    }\n    get to() {\n        return this.from + this.text.length;\n    }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to) return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to) text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to){\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */ ));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for(;;){\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length) return pos;\n    let line = text.lineAt(pos), next;\n    while(pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)pos++;\n    return pos;\n}\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n        class: \"cm-textfield\",\n        name: \"line\",\n        value: line\n    });\n    let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event)=>{\n            if (event.keyCode == 27) {\n                event.preventDefault();\n                view.dispatch({\n                    effects: dialogEffect.of(false)\n                });\n                view.focus();\n            } else if (event.keyCode == 13) {\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event)=>{\n            event.preventDefault();\n            go();\n        }\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n        class: \"cm-button\",\n        type: \"submit\"\n    }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match) return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n            line = Math.round(state.doc.lines * pc);\n        } else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [\n                dialogEffect.of(false),\n                _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.from, {\n                    y: \"center\"\n                })\n            ],\n            selection\n        });\n        view.focus();\n    }\n    return {\n        dom\n    };\n}\nconst dialogEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst dialogField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return true;\n    },\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(dialogEffect)) value = e.value;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/ const gotoLine = (view)=>{\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    if (!panel) {\n        let effects = [\n            dialogEffect.of(true)\n        ];\n        if (view.state.field(dialogField, false) == null) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n            dialogField,\n            baseTheme$1\n        ]));\n        view.dispatch({\n            effects\n        });\n        panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    }\n    if (panel) panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": {\n            fontSize: \"80%\"\n        }\n    }\n});\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (options) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b)=>a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/ function highlightSelectionMatches(options) {\n    let ext = [\n        defaultTheme,\n        matchHighlighter\n    ];\n    if (options) ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch\"\n});\nconst mainMatchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        } else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to))) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            } else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges){\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while(!cursor.next().done){\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n                }\n            }\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nconst defaultTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#99ff7780\"\n    },\n    \".cm-searchMatch .cm-selectionMatch\": {\n        backgroundColor: \"transparent\"\n    }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch })=>{\n    let { selection } = state;\n    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map((range)=>state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection)) return false;\n    dispatch(state.update({\n        selection: newSel\n    }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for(let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;){\n        cursor.next();\n        if (cursor.done) {\n            if (cycled) return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        } else {\n            if (cycled && ranges.some((r)=>r.from == cursor.value.from)) continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to) continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/ const selectNextOccurrence = ({ state, dispatch })=>{\n    let { ranges } = state.selection;\n    if (ranges.some((sel)=>sel.from === sel.to)) return selectWord({\n        state,\n        dispatch\n    });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some((r)=>state.sliceDoc(r.from, r.to) != searchedText)) return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range) return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\nconst searchConfigFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: (view)=>new SearchPanel(view),\n            scrollToMatch: (range)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/ function search(config) {\n    return config ? [\n        searchConfigFacet.of(config),\n        searchExtensions\n    ] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/ class SearchQuery {\n    /**\n    Create a query object.\n    */ constructor(config){\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */ unquote(text) {\n        return this.literal ? text : text.replace(/\\\\([nrt\\\\])/g, (_, ch)=>ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */ eq(other) {\n        return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */ create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */ getCursor(state, from = 0, to) {\n        let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({\n            doc: state\n        });\n        if (to == null) to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec){\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : (x)=>x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos)=>{\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec){\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done) cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for(let pos = to;;){\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */  - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while(!cursor.nextOverlapping().done)range = cursor.value;\n            if (range) return range;\n            if (start == from) return null;\n            pos -= 10000 /* FindPrev.ChunkSize */ ;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(_result) {\n        return this.spec.unquote(this.spec.replace);\n    }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match)=>!match[0].length || (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done) cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for(let size = 1;; size++){\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */ );\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while(!cursor.next().done)range = cursor.value;\n            if (range && (start == from || range.from > start + 10)) return range;\n            if (start == from) return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&\\d+])/g, (m, i)=>i == \"$\" ? \"$\" : i == \"&\" ? result.match[0] : i != \"0\" && +i < result.match.length ? result.match[i] : m);\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */ ), Math.min(to + 250 /* RegExp.HighlightMargin */ , state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/ const setSearchQuery = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst searchState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create (state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/ function getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/ function searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel){\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch\"\n}), selectedMatchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nconst searchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged) this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let { view } = this;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\n        for(let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++){\n            let { from, to } = ranges[i];\n            while(i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */ )to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to)=>{\n                let selected = view.state.selection.ranges.some((r)=>r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nfunction searchCommand(f) {\n    return (view)=>{\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/ const findNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, next),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/ const findPrevious = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, prev),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/ const selectMatches = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length) return false;\n    view.dispatch({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/ const selectSelectionMatches = ({ state, dispatch })=>{\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty) return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for(let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;){\n        if (ranges.length > 1000) return false;\n        if (cur.value.from == from) main = ranges.length;\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/ const replaceNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly) return false;\n    let next = query.nextMatch(state, from, from);\n    if (!next) return false;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({\n            from: next.from,\n            to: next.to,\n            insert: replacement\n        });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes,\n        selection,\n        effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/ const replaceAll = /*@__PURE__*/ searchCommand((view, { query })=>{\n    if (view.state.readOnly) return false;\n    let changes = query.matchAll(view.state, 1e9).map((match)=>{\n        let { from, to } = match;\n        return {\n            from,\n            to,\n            insert: query.getReplacement(match)\n        };\n    });\n    if (!changes.length) return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText) return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement) input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/ const openSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid) view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n            searchInput.focus();\n            searchInput.select();\n        }\n    } else {\n        view.dispatch({\n            effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)\n            ]\n        });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/ const closeSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel) return false;\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/ const searchKeymap = [\n    {\n        key: \"Mod-f\",\n        run: openSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"F3\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Mod-g\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Escape\",\n        run: closeSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"Mod-Shift-l\",\n        run: selectSelectionMatches\n    },\n    {\n        key: \"Mod-Alt-g\",\n        run: gotoLine\n    },\n    {\n        key: \"Mod-d\",\n        run: selectNextOccurrence,\n        preventDefault: true\n    }\n];\nclass SearchPanel {\n    constructor(view){\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                class: \"cm-button\",\n                name,\n                onclick,\n                type: \"button\"\n            }, content);\n        }\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            onkeydown: (e)=>this.keydown(e),\n            class: \"cm-search\"\n        }, [\n            this.searchField,\n            button(\"next\", ()=>findNext(view), [\n                phrase(view, \"next\")\n            ]),\n            button(\"prev\", ()=>findPrevious(view), [\n                phrase(view, \"previous\")\n            ]),\n            button(\"select\", ()=>selectMatches(view), [\n                phrase(view, \"all\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.caseField,\n                phrase(view, \"match case\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.reField,\n                phrase(view, \"regexp\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.wordField,\n                phrase(view, \"by word\")\n            ]),\n            ...view.state.readOnly ? [] : [\n                (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"),\n                this.replaceField,\n                button(\"replace\", ()=>replaceNext(view), [\n                    phrase(view, \"replace\")\n                ]),\n                button(\"replaceAll\", ()=>replaceAll(view), [\n                    phrase(view, \"replace all\")\n                ])\n            ],\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                name: \"close\",\n                onclick: ()=>closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\n                \"\\xd7\"\n            ])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n        }\n    }\n    keydown(e) {\n        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.runScopeHandlers)(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        } else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        } else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)for (let effect of tr.effects){\n            if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);\n        }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() {\n        return 80;\n    }\n    get top() {\n        return this.view.state.facet(searchConfigFacet).top;\n    }\n}\nfunction phrase(view, phrase) {\n    return view.state.phrase(phrase);\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for(let i = 0; i < AnnounceMargin; i++)if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n            text = text.slice(i);\n            break;\n        }\n    }\n    if (end != lineEnd) {\n        for(let i = text.length - 1; i > text.length - AnnounceMargin; i--)if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n            text = text.slice(0, i);\n            break;\n        }\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": {\n        backgroundColor: \"#ffff0054\"\n    },\n    \"&dark .cm-searchMatch\": {\n        backgroundColor: \"#00ffff8a\"\n    },\n    \"&light .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff6a0054\"\n    },\n    \"&dark .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff00ff8a\"\n    }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.low(searchHighlighter),\n    baseTheme\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc2VhcmNoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RztBQUNxRztBQUMxTDtBQUV4QixNQUFNb0IsaUJBQWlCLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsU0FBUyxJQUFJLGFBQ3REQyxDQUFBQSxJQUFLQSxFQUFFRCxTQUFTLENBQUMsVUFBVUMsQ0FBQUEsSUFBS0E7QUFDdEM7OztBQUdBLEdBQ0EsTUFBTUM7SUFDRjs7Ozs7Ozs7Ozs7O0lBWUEsR0FDQUMsWUFBWUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sQ0FBQyxFQUFFQyxLQUFLSCxLQUFLSSxNQUFNLEVBQUVSLFNBQVMsRUFBRVMsSUFBSSxDQUFFO1FBQ2xFLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtRQUNaOzs7O1FBSUEsR0FDQSxJQUFJLENBQUNDLEtBQUssR0FBRztZQUFFSixNQUFNO1lBQUdDLElBQUk7UUFBRTtRQUM5Qjs7UUFFQSxHQUNBLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHWCxLQUFLWSxTQUFTLENBQUNWLE1BQU1DO1FBQ2pDLElBQUksQ0FBQ1UsV0FBVyxHQUFHWDtRQUNuQixJQUFJLENBQUNOLFNBQVMsR0FBR0EsWUFBWUMsQ0FBQUEsSUFBS0QsVUFBVUgsZUFBZUksTUFBTUo7UUFDakUsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDTCxTQUFTLENBQUNLO0lBQ2hDO0lBQ0FhLE9BQU87UUFDSCxJQUFJLElBQUksQ0FBQ0osU0FBUyxJQUFJLElBQUksQ0FBQ0QsTUFBTSxDQUFDTCxNQUFNLEVBQUU7WUFDdEMsSUFBSSxDQUFDUyxXQUFXLElBQUksSUFBSSxDQUFDSixNQUFNLENBQUNMLE1BQU07WUFDdEMsSUFBSSxDQUFDTyxJQUFJLENBQUNJLElBQUk7WUFDZCxJQUFJLElBQUksQ0FBQ0osSUFBSSxDQUFDSixJQUFJLEVBQ2QsT0FBTyxDQUFDO1lBQ1osSUFBSSxDQUFDRyxTQUFTLEdBQUc7WUFDakIsSUFBSSxDQUFDRCxNQUFNLEdBQUcsSUFBSSxDQUFDRSxJQUFJLENBQUNMLEtBQUs7UUFDakM7UUFDQSxPQUFPM0IsOERBQVdBLENBQUMsSUFBSSxDQUFDOEIsTUFBTSxFQUFFLElBQUksQ0FBQ0MsU0FBUztJQUNsRDtJQUNBOzs7OztJQUtBLEdBQ0FLLE9BQU87UUFDSCxNQUFPLElBQUksQ0FBQ1AsT0FBTyxDQUFDSixNQUFNLENBQ3RCLElBQUksQ0FBQ0ksT0FBTyxDQUFDUSxHQUFHO1FBQ3BCLE9BQU8sSUFBSSxDQUFDQyxlQUFlO0lBQy9CO0lBQ0E7Ozs7SUFJQSxHQUNBQSxrQkFBa0I7UUFDZCxPQUFTO1lBQ0wsSUFBSUYsT0FBTyxJQUFJLENBQUNELElBQUk7WUFDcEIsSUFBSUMsT0FBTyxHQUFHO2dCQUNWLElBQUksQ0FBQ1IsSUFBSSxHQUFHO2dCQUNaLE9BQU8sSUFBSTtZQUNmO1lBQ0EsSUFBSVcsTUFBTXRDLGdFQUFhQSxDQUFDbUMsT0FBT0ksUUFBUSxJQUFJLENBQUNOLFdBQVcsR0FBRyxJQUFJLENBQUNILFNBQVM7WUFDeEUsSUFBSSxDQUFDQSxTQUFTLElBQUk3QixnRUFBYUEsQ0FBQ2tDO1lBQ2hDLElBQUlLLE9BQU8sSUFBSSxDQUFDeEIsU0FBUyxDQUFDc0I7WUFDMUIsSUFBSyxJQUFJRyxJQUFJLEdBQUdDLE1BQU1ILFFBQVFFLElBQUs7Z0JBQy9CLElBQUlFLE9BQU9ILEtBQUtJLFVBQVUsQ0FBQ0g7Z0JBQzNCLElBQUlJLFFBQVEsSUFBSSxDQUFDQSxLQUFLLENBQUNGLE1BQU1ELEtBQUssSUFBSSxDQUFDWixTQUFTLEdBQUcsSUFBSSxDQUFDRyxXQUFXO2dCQUNuRSxJQUFJUSxLQUFLRCxLQUFLaEIsTUFBTSxHQUFHLEdBQUc7b0JBQ3RCLElBQUlxQixPQUFPO3dCQUNQLElBQUksQ0FBQ25CLEtBQUssR0FBR21CO3dCQUNiLE9BQU8sSUFBSTtvQkFDZjtvQkFDQTtnQkFDSjtnQkFDQSxJQUFJSCxPQUFPSCxTQUFTRSxJQUFJSCxJQUFJZCxNQUFNLElBQUljLElBQUlNLFVBQVUsQ0FBQ0gsTUFBTUUsTUFDdkREO1lBQ1I7UUFDSjtJQUNKO0lBQ0FHLE1BQU1GLElBQUksRUFBRUQsR0FBRyxFQUFFSSxHQUFHLEVBQUU7UUFDbEIsSUFBSUQsUUFBUTtRQUNaLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2IsT0FBTyxDQUFDSixNQUFNLEVBQUVpQixLQUFLLEVBQUc7WUFDN0MsSUFBSU0sUUFBUSxJQUFJLENBQUNuQixPQUFPLENBQUNhLEVBQUUsRUFBRU8sT0FBTztZQUNwQyxJQUFJLElBQUksQ0FBQzNCLEtBQUssQ0FBQ3VCLFVBQVUsQ0FBQ0csVUFBVUosTUFBTTtnQkFDdEMsSUFBSUksU0FBUyxJQUFJLENBQUMxQixLQUFLLENBQUNHLE1BQU0sR0FBRyxHQUFHO29CQUNoQ3FCLFFBQVE7d0JBQUV2QixNQUFNLElBQUksQ0FBQ00sT0FBTyxDQUFDYSxJQUFJLEVBQUU7d0JBQUVsQixJQUFJdUI7b0JBQUk7Z0JBQ2pELE9BQ0s7b0JBQ0QsSUFBSSxDQUFDbEIsT0FBTyxDQUFDYSxFQUFFO29CQUNmTyxPQUFPO2dCQUNYO1lBQ0o7WUFDQSxJQUFJLENBQUNBLE1BQU07Z0JBQ1AsSUFBSSxDQUFDcEIsT0FBTyxDQUFDcUIsTUFBTSxDQUFDUixHQUFHO2dCQUN2QkEsS0FBSztZQUNUO1FBQ0o7UUFDQSxJQUFJLElBQUksQ0FBQ3BCLEtBQUssQ0FBQ3VCLFVBQVUsQ0FBQyxNQUFNRCxNQUFNO1lBQ2xDLElBQUksSUFBSSxDQUFDdEIsS0FBSyxDQUFDRyxNQUFNLElBQUksR0FDckJxQixRQUFRO2dCQUFFdkIsTUFBTW9CO2dCQUFLbkIsSUFBSXVCO1lBQUk7aUJBRTdCLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ3NCLElBQUksQ0FBQyxHQUFHUjtRQUM3QjtRQUNBLElBQUlHLFNBQVMsSUFBSSxDQUFDcEIsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDQSxJQUFJLENBQUNvQixNQUFNdkIsSUFBSSxFQUFFdUIsTUFBTXRCLEVBQUUsRUFBRSxJQUFJLENBQUNNLE1BQU0sRUFBRSxJQUFJLENBQUNJLFdBQVcsR0FDcEZZLFFBQVE7UUFDWixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxJQUFJLE9BQU9NLFVBQVUsYUFDakJqQyxhQUFhSCxTQUFTLENBQUNvQyxPQUFPQyxRQUFRLENBQUMsR0FBRztJQUFjLE9BQU8sSUFBSTtBQUFFO0FBRXpFLE1BQU1DLFFBQVE7SUFBRS9CLE1BQU0sQ0FBQztJQUFHQyxJQUFJLENBQUM7SUFBR3NCLE9BQU8sV0FBVyxHQUFFLEtBQUtTLElBQUksQ0FBQztBQUFJO0FBQ3BFLE1BQU1DLFlBQVksT0FBUSxLQUFJQyxPQUFPLElBQUksT0FBTyxLQUFLLEdBQUU7QUFDdkQ7Ozs7QUFJQSxHQUNBLE1BQU1DO0lBQ0Y7Ozs7SUFJQSxHQUNBdEMsWUFBWUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVxQyxPQUFPLEVBQUVwQyxPQUFPLENBQUMsRUFBRUMsS0FBS0gsS0FBS0ksTUFBTSxDQUFFO1FBQzFELElBQUksQ0FBQ0osSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0csRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ29DLE9BQU8sR0FBRztRQUNmOzs7UUFHQSxHQUNBLElBQUksQ0FBQ2hDLElBQUksR0FBRztRQUNaOzs7O1FBSUEsR0FDQSxJQUFJLENBQUNELEtBQUssR0FBRzJCO1FBQ2IsSUFBSSx1QkFBdUI1QixJQUFJLENBQUNKLFFBQzVCLE9BQU8sSUFBSXVDLHNCQUFzQnhDLE1BQU1DLE9BQU9xQyxTQUFTcEMsTUFBTUM7UUFDakUsSUFBSSxDQUFDc0MsRUFBRSxHQUFHLElBQUlDLE9BQU96QyxPQUFPa0MsWUFBYSxFQUFDRyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUUssVUFBVSxJQUFJLE1BQU0sRUFBQztRQUN6SCxJQUFJLENBQUN0QyxJQUFJLEdBQUdpQyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUWpDLElBQUk7UUFDMUUsSUFBSSxDQUFDTSxJQUFJLEdBQUdYLEtBQUtXLElBQUk7UUFDckIsSUFBSWlDLFlBQVk1QyxLQUFLNkMsTUFBTSxDQUFDM0M7UUFDNUIsSUFBSSxDQUFDNEMsWUFBWSxHQUFHRixVQUFVMUMsSUFBSTtRQUNsQyxJQUFJLENBQUM2QyxRQUFRLEdBQUdDLFVBQVVoRCxNQUFNRTtRQUNoQyxJQUFJLENBQUMrQyxPQUFPLENBQUMsSUFBSSxDQUFDSCxZQUFZO0lBQ2xDO0lBQ0FHLFFBQVFDLElBQUksRUFBRTtRQUNWLElBQUksQ0FBQ3ZDLElBQUksQ0FBQ0ksSUFBSSxDQUFDbUM7UUFDZixJQUFJLElBQUksQ0FBQ3ZDLElBQUksQ0FBQ3dDLFNBQVMsRUFBRTtZQUNyQixJQUFJLENBQUNaLE9BQU8sR0FBRztRQUNuQixPQUNLO1lBQ0QsSUFBSSxDQUFDQSxPQUFPLEdBQUcsSUFBSSxDQUFDNUIsSUFBSSxDQUFDTCxLQUFLO1lBQzlCLElBQUksSUFBSSxDQUFDd0MsWUFBWSxHQUFHLElBQUksQ0FBQ1AsT0FBTyxDQUFDbkMsTUFBTSxHQUFHLElBQUksQ0FBQ0QsRUFBRSxFQUNqRCxJQUFJLENBQUNvQyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUNhLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQ2pELEVBQUUsR0FBRyxJQUFJLENBQUMyQyxZQUFZO1lBQ3BFLElBQUksQ0FBQ25DLElBQUksQ0FBQ0ksSUFBSTtRQUNsQjtJQUNKO0lBQ0FzQyxXQUFXO1FBQ1AsSUFBSSxDQUFDUCxZQUFZLEdBQUcsSUFBSSxDQUFDQSxZQUFZLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUNuQyxNQUFNLEdBQUc7UUFDOUQsSUFBSSxJQUFJLENBQUMwQyxZQUFZLEdBQUcsSUFBSSxDQUFDM0MsRUFBRSxFQUMzQixJQUFJLENBQUNvQyxPQUFPLEdBQUc7YUFFZixJQUFJLENBQUNVLE9BQU8sQ0FBQztJQUNyQjtJQUNBOztJQUVBLEdBQ0FsQyxPQUFPO1FBQ0gsSUFBSyxJQUFJdUMsTUFBTSxJQUFJLENBQUNQLFFBQVEsR0FBRyxJQUFJLENBQUNELFlBQVksR0FBSTtZQUNoRCxJQUFJLENBQUNMLEVBQUUsQ0FBQ2MsU0FBUyxHQUFHRDtZQUNwQixJQUFJN0IsUUFBUSxJQUFJLENBQUNzQixRQUFRLElBQUksSUFBSSxDQUFDNUMsRUFBRSxJQUFJLElBQUksQ0FBQ3NDLEVBQUUsQ0FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQ0ssT0FBTztZQUNqRSxJQUFJZCxPQUFPO2dCQUNQLElBQUl2QixPQUFPLElBQUksQ0FBQzRDLFlBQVksR0FBR3JCLE1BQU1FLEtBQUssRUFBRXhCLEtBQUtELE9BQU91QixLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTTtnQkFDdkUsSUFBSSxDQUFDMkMsUUFBUSxHQUFHQyxVQUFVLElBQUksQ0FBQ2hELElBQUksRUFBRUcsS0FBTUQsQ0FBQUEsUUFBUUMsS0FBSyxJQUFJO2dCQUM1RCxJQUFJRCxRQUFRLElBQUksQ0FBQzRDLFlBQVksR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQ25DLE1BQU0sRUFDL0MsSUFBSSxDQUFDaUQsUUFBUTtnQkFDakIsSUFBSSxDQUFDbkQsT0FBT0MsTUFBTUQsT0FBTyxJQUFJLENBQUNJLEtBQUssQ0FBQ0gsRUFBRSxLQUFNLEVBQUMsSUFBSSxDQUFDRSxJQUFJLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUNILE1BQU1DLElBQUlzQixNQUFLLEdBQUk7b0JBQ25GLElBQUksQ0FBQ25CLEtBQUssR0FBRzt3QkFBRUo7d0JBQU1DO3dCQUFJc0I7b0JBQU07b0JBQy9CLE9BQU8sSUFBSTtnQkFDZjtnQkFDQTZCLE1BQU0sSUFBSSxDQUFDUCxRQUFRLEdBQUcsSUFBSSxDQUFDRCxZQUFZO1lBQzNDLE9BQ0ssSUFBSSxJQUFJLENBQUNBLFlBQVksR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQ25DLE1BQU0sR0FBRyxJQUFJLENBQUNELEVBQUUsRUFBRTtnQkFDeEQsSUFBSSxDQUFDa0QsUUFBUTtnQkFDYkMsTUFBTTtZQUNWLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDL0MsSUFBSSxHQUFHO2dCQUNaLE9BQU8sSUFBSTtZQUNmO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsTUFBTWlELFlBQVksV0FBVyxHQUFFLElBQUlDO0FBQ25DLGtEQUFrRDtBQUNsRCxNQUFNQztJQUNGM0QsWUFBWUcsSUFBSSxFQUFFRixJQUFJLENBQUU7UUFDcEIsSUFBSSxDQUFDRSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRixJQUFJLEdBQUdBO0lBQ2hCO0lBQ0EsSUFBSUcsS0FBSztRQUFFLE9BQU8sSUFBSSxDQUFDRCxJQUFJLEdBQUcsSUFBSSxDQUFDRixJQUFJLENBQUNJLE1BQU07SUFBRTtJQUNoRCxPQUFPdUQsSUFBSUMsR0FBRyxFQUFFMUQsSUFBSSxFQUFFQyxFQUFFLEVBQUU7UUFDdEIsSUFBSTBELFNBQVNMLFVBQVVHLEdBQUcsQ0FBQ0M7UUFDM0IsSUFBSSxDQUFDQyxVQUFVQSxPQUFPM0QsSUFBSSxJQUFJQyxNQUFNMEQsT0FBTzFELEVBQUUsSUFBSUQsTUFBTTtZQUNuRCxJQUFJNEQsT0FBTyxJQUFJSixhQUFheEQsTUFBTTBELElBQUlHLFdBQVcsQ0FBQzdELE1BQU1DO1lBQ3hEcUQsVUFBVVEsR0FBRyxDQUFDSixLQUFLRTtZQUNuQixPQUFPQTtRQUNYO1FBQ0EsSUFBSUQsT0FBTzNELElBQUksSUFBSUEsUUFBUTJELE9BQU8xRCxFQUFFLElBQUlBLElBQ3BDLE9BQU8wRDtRQUNYLElBQUksRUFBRTdELElBQUksRUFBRUUsTUFBTStELFVBQVUsRUFBRSxHQUFHSjtRQUNqQyxJQUFJSSxhQUFhL0QsTUFBTTtZQUNuQkYsT0FBTzRELElBQUlHLFdBQVcsQ0FBQzdELE1BQU0rRCxjQUFjakU7WUFDM0NpRSxhQUFhL0Q7UUFDakI7UUFDQSxJQUFJMkQsT0FBTzFELEVBQUUsR0FBR0EsSUFDWkgsUUFBUTRELElBQUlHLFdBQVcsQ0FBQ0YsT0FBTzFELEVBQUUsRUFBRUE7UUFDdkNxRCxVQUFVUSxHQUFHLENBQUNKLEtBQUssSUFBSUYsYUFBYU8sWUFBWWpFO1FBQ2hELE9BQU8sSUFBSTBELGFBQWF4RCxNQUFNRixLQUFLb0QsS0FBSyxDQUFDbEQsT0FBTytELFlBQVk5RCxLQUFLOEQ7SUFDckU7QUFDSjtBQUNBLE1BQU16QjtJQUNGekMsWUFBWUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVxQyxPQUFPLEVBQUVwQyxJQUFJLEVBQUVDLEVBQUUsQ0FBRTtRQUN4QyxJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNHLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNJLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsS0FBSyxHQUFHMkI7UUFDYixJQUFJLENBQUNjLFFBQVEsR0FBR0MsVUFBVWhELE1BQU1FO1FBQ2hDLElBQUksQ0FBQ3VDLEVBQUUsR0FBRyxJQUFJQyxPQUFPekMsT0FBT2tDLFlBQWEsRUFBQ0csWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFLLFVBQVUsSUFBSSxNQUFNLEVBQUM7UUFDekgsSUFBSSxDQUFDdEMsSUFBSSxHQUFHaUMsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFqQyxJQUFJO1FBQzFFLElBQUksQ0FBQ3lELElBQUksR0FBR0osYUFBYUMsR0FBRyxDQUFDM0QsTUFBTUUsTUFBTSxJQUFJLENBQUNnRSxRQUFRLENBQUNoRSxPQUFPLEtBQUssY0FBYztJQUNyRjtJQUNBZ0UsU0FBUzVDLEdBQUcsRUFBRTtRQUNWLE9BQU9BLE9BQU8sSUFBSSxDQUFDbkIsRUFBRSxHQUFHLElBQUksQ0FBQ0EsRUFBRSxHQUFHLElBQUksQ0FBQ0gsSUFBSSxDQUFDNkMsTUFBTSxDQUFDdkIsS0FBS25CLEVBQUU7SUFDOUQ7SUFDQVksT0FBTztRQUNILE9BQVM7WUFDTCxJQUFJdUMsTUFBTSxJQUFJLENBQUNiLEVBQUUsQ0FBQ2MsU0FBUyxHQUFHLElBQUksQ0FBQ1IsUUFBUSxHQUFHLElBQUksQ0FBQ2UsSUFBSSxDQUFDNUQsSUFBSTtZQUM1RCxJQUFJdUIsUUFBUSxJQUFJLENBQUNnQixFQUFFLENBQUNQLElBQUksQ0FBQyxJQUFJLENBQUM0QixJQUFJLENBQUM5RCxJQUFJO1lBQ3ZDLG1EQUFtRDtZQUNuRCxJQUFJeUIsU0FBUyxDQUFDQSxLQUFLLENBQUMsRUFBRSxJQUFJQSxNQUFNRSxLQUFLLElBQUkyQixLQUFLO2dCQUMxQyxJQUFJLENBQUNiLEVBQUUsQ0FBQ2MsU0FBUyxHQUFHRCxNQUFNO2dCQUMxQjdCLFFBQVEsSUFBSSxDQUFDZ0IsRUFBRSxDQUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDNEIsSUFBSSxDQUFDOUQsSUFBSTtZQUN2QztZQUNBLElBQUl5QixPQUFPO2dCQUNQLElBQUl2QixPQUFPLElBQUksQ0FBQzRELElBQUksQ0FBQzVELElBQUksR0FBR3VCLE1BQU1FLEtBQUssRUFBRXhCLEtBQUtELE9BQU91QixLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTTtnQkFDcEUsZ0VBQWdFO2dCQUNoRSxrREFBa0Q7Z0JBQ2xELElBQUksQ0FBQyxJQUFJLENBQUMwRCxJQUFJLENBQUMzRCxFQUFFLElBQUksSUFBSSxDQUFDQSxFQUFFLElBQUlzQixNQUFNRSxLQUFLLEdBQUdGLEtBQUssQ0FBQyxFQUFFLENBQUNyQixNQUFNLElBQUksSUFBSSxDQUFDMEQsSUFBSSxDQUFDOUQsSUFBSSxDQUFDSSxNQUFNLEdBQUcsRUFBQyxLQUNyRixFQUFDLElBQUksQ0FBQ0MsSUFBSSxJQUFJLElBQUksQ0FBQ0EsSUFBSSxDQUFDSCxNQUFNQyxJQUFJc0IsTUFBSyxHQUFJO29CQUM1QyxJQUFJLENBQUNuQixLQUFLLEdBQUc7d0JBQUVKO3dCQUFNQzt3QkFBSXNCO29CQUFNO29CQUMvQixJQUFJLENBQUNzQixRQUFRLEdBQUdDLFVBQVUsSUFBSSxDQUFDaEQsSUFBSSxFQUFFRyxLQUFNRCxDQUFBQSxRQUFRQyxLQUFLLElBQUk7b0JBQzVELE9BQU8sSUFBSTtnQkFDZjtZQUNKO1lBQ0EsSUFBSSxJQUFJLENBQUMyRCxJQUFJLENBQUMzRCxFQUFFLElBQUksSUFBSSxDQUFDQSxFQUFFLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQ0ksSUFBSSxHQUFHO2dCQUNaLE9BQU8sSUFBSTtZQUNmO1lBQ0EseUJBQXlCO1lBQ3pCLElBQUksQ0FBQ3VELElBQUksR0FBR0osYUFBYUMsR0FBRyxDQUFDLElBQUksQ0FBQzNELElBQUksRUFBRSxJQUFJLENBQUM4RCxJQUFJLENBQUM1RCxJQUFJLEVBQUUsSUFBSSxDQUFDZ0UsUUFBUSxDQUFDLElBQUksQ0FBQ0osSUFBSSxDQUFDNUQsSUFBSSxHQUFHLElBQUksQ0FBQzRELElBQUksQ0FBQzlELElBQUksQ0FBQ0ksTUFBTSxHQUFHO1FBQ25IO0lBQ0o7QUFDSjtBQUNBLElBQUksT0FBTzJCLFVBQVUsYUFBYTtJQUM5Qk0sYUFBYTFDLFNBQVMsQ0FBQ29DLE9BQU9DLFFBQVEsQ0FBQyxHQUFHUSxzQkFBc0I3QyxTQUFTLENBQUNvQyxPQUFPQyxRQUFRLENBQUMsR0FDdEY7UUFBYyxPQUFPLElBQUk7SUFBRTtBQUNuQztBQUNBLFNBQVNtQyxZQUFZQyxNQUFNO0lBQ3ZCLElBQUk7UUFDQSxJQUFJMUIsT0FBTzBCLFFBQVFqQztRQUNuQixPQUFPO0lBQ1gsRUFDQSxPQUFPa0MsSUFBSTtRQUNQLE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU3JCLFVBQVVoRCxJQUFJLEVBQUVzQixHQUFHO0lBQ3hCLElBQUlBLE9BQU90QixLQUFLSSxNQUFNLEVBQ2xCLE9BQU9rQjtJQUNYLElBQUlnRCxPQUFPdEUsS0FBSzZDLE1BQU0sQ0FBQ3ZCLE1BQU1QO0lBQzdCLE1BQU9PLE1BQU1nRCxLQUFLbkUsRUFBRSxJQUFJLENBQUNZLE9BQU91RCxLQUFLdEUsSUFBSSxDQUFDd0IsVUFBVSxDQUFDRixNQUFNZ0QsS0FBS3BFLElBQUksTUFBTSxVQUFVYSxPQUFPLE9BQ3ZGTztJQUNKLE9BQU9BO0FBQ1g7QUFFQSxTQUFTaUQsaUJBQWlCQyxJQUFJO0lBQzFCLElBQUlGLE9BQU81RSxPQUFPOEUsS0FBS0MsS0FBSyxDQUFDYixHQUFHLENBQUNmLE1BQU0sQ0FBQzJCLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksRUFBRUMsTUFBTTtJQUM5RSxJQUFJQyxRQUFRdEYsaURBQUdBLENBQUMsU0FBUztRQUFFdUYsT0FBTztRQUFnQkMsTUFBTTtRQUFRMUUsT0FBT2dFO0lBQUs7SUFDNUUsSUFBSVcsTUFBTXpGLGlEQUFHQSxDQUFDLFFBQVE7UUFDbEJ1RixPQUFPO1FBQ1BHLFdBQVcsQ0FBQ0M7WUFDUixJQUFJQSxNQUFNQyxPQUFPLElBQUksSUFBSTtnQkFDckJELE1BQU1FLGNBQWM7Z0JBQ3BCYixLQUFLYyxRQUFRLENBQUM7b0JBQUVDLFNBQVNDLGFBQWFDLEVBQUUsQ0FBQztnQkFBTztnQkFDaERqQixLQUFLa0IsS0FBSztZQUNkLE9BQ0ssSUFBSVAsTUFBTUMsT0FBTyxJQUFJLElBQUk7Z0JBQzFCRCxNQUFNRSxjQUFjO2dCQUNwQk07WUFDSjtRQUNKO1FBQ0FDLFVBQVUsQ0FBQ1Q7WUFDUEEsTUFBTUUsY0FBYztZQUNwQk07UUFDSjtJQUNKLEdBQUduRyxpREFBR0EsQ0FBQyxTQUFTZ0YsS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLGVBQWUsTUFBTWYsUUFBUSxLQUFLdEYsaURBQUdBLENBQUMsVUFBVTtRQUFFdUYsT0FBTztRQUFhZSxNQUFNO0lBQVMsR0FBR3RCLEtBQUtDLEtBQUssQ0FBQ29CLE1BQU0sQ0FBQztJQUM1SSxTQUFTRjtRQUNMLElBQUlsRSxRQUFRLDZCQUE2QlMsSUFBSSxDQUFDNEMsTUFBTXhFLEtBQUs7UUFDekQsSUFBSSxDQUFDbUIsT0FDRDtRQUNKLElBQUksRUFBRWdELEtBQUssRUFBRSxHQUFHRCxNQUFNNUIsWUFBWTZCLE1BQU1iLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDNEIsTUFBTUMsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUk7UUFDNUUsSUFBSSxHQUFHbUIsTUFBTUMsSUFBSUMsSUFBSUMsUUFBUSxHQUFHekU7UUFDaEMsSUFBSTBFLE1BQU1GLEtBQUssQ0FBQ0EsR0FBRzdDLEtBQUssQ0FBQyxLQUFLO1FBQzlCLElBQUlrQixPQUFPMEIsS0FBSyxDQUFDQSxLQUFLcEQsVUFBVWlDLE1BQU07UUFDdEMsSUFBSW1CLE1BQU1FLFNBQVM7WUFDZixJQUFJRSxLQUFLOUIsT0FBTztZQUNoQixJQUFJeUIsTUFDQUssS0FBS0EsS0FBTUwsQ0FBQUEsUUFBUSxNQUFNLENBQUMsSUFBSSxLQUFNbkQsVUFBVWlDLE1BQU0sR0FBR0osTUFBTWIsR0FBRyxDQUFDeUMsS0FBSztZQUMxRS9CLE9BQU9nQyxLQUFLQyxLQUFLLENBQUM5QixNQUFNYixHQUFHLENBQUN5QyxLQUFLLEdBQUdEO1FBQ3hDLE9BQ0ssSUFBSUosTUFBTUQsTUFBTTtZQUNqQnpCLE9BQU9BLE9BQVF5QixDQUFBQSxRQUFRLE1BQU0sQ0FBQyxJQUFJLEtBQUtuRCxVQUFVaUMsTUFBTTtRQUMzRDtRQUNBLElBQUkyQixVQUFVL0IsTUFBTWIsR0FBRyxDQUFDVSxJQUFJLENBQUNnQyxLQUFLRyxHQUFHLENBQUMsR0FBR0gsS0FBS0ksR0FBRyxDQUFDakMsTUFBTWIsR0FBRyxDQUFDeUMsS0FBSyxFQUFFL0I7UUFDbkUsSUFBSUksWUFBWTFGLDhEQUFlQSxDQUFDMkgsTUFBTSxDQUFDSCxRQUFRdEcsSUFBSSxHQUFHb0csS0FBS0csR0FBRyxDQUFDLEdBQUdILEtBQUtJLEdBQUcsQ0FBQ1AsS0FBS0ssUUFBUXBHLE1BQU07UUFDOUZvRSxLQUFLYyxRQUFRLENBQUM7WUFDVkMsU0FBUztnQkFBQ0MsYUFBYUMsRUFBRSxDQUFDO2dCQUFRbkgsd0RBQVVBLENBQUNzSSxjQUFjLENBQUNsQyxVQUFVeEUsSUFBSSxFQUFFO29CQUFFMkcsR0FBRztnQkFBUzthQUFHO1lBQzdGbkM7UUFDSjtRQUNBRixLQUFLa0IsS0FBSztJQUNkO0lBQ0EsT0FBTztRQUFFVDtJQUFJO0FBQ2pCO0FBQ0EsTUFBTU8sZUFBZSxXQUFXLEdBQUUxRywwREFBV0EsQ0FBQ2dJLE1BQU07QUFDcEQsTUFBTUMsY0FBYyxXQUFXLEdBQUVoSSx5REFBVUEsQ0FBQytILE1BQU0sQ0FBQztJQUMvQ0U7UUFBVyxPQUFPO0lBQU07SUFDeEJDLFFBQU8zRyxLQUFLLEVBQUU0RyxFQUFFO1FBQ1osS0FBSyxJQUFJQyxLQUFLRCxHQUFHM0IsT0FBTyxDQUNwQixJQUFJNEIsRUFBRUMsRUFBRSxDQUFDNUIsZUFDTGxGLFFBQVE2RyxFQUFFN0csS0FBSztRQUN2QixPQUFPQTtJQUNYO0lBQ0ErRyxTQUFTQyxDQUFBQSxJQUFLakosdURBQVNBLENBQUM2QixJQUFJLENBQUNvSCxHQUFHQyxDQUFBQSxNQUFPQSxNQUFNaEQsbUJBQW1CO0FBQ3BFO0FBQ0E7Ozs7Ozs7O0FBUUEsR0FDQSxNQUFNaUQsV0FBV2hELENBQUFBO0lBQ2IsSUFBSWlELFFBQVFsSiwwREFBUUEsQ0FBQ2lHLE1BQU1EO0lBQzNCLElBQUksQ0FBQ2tELE9BQU87UUFDUixJQUFJbEMsVUFBVTtZQUFDQyxhQUFhQyxFQUFFLENBQUM7U0FBTTtRQUNyQyxJQUFJakIsS0FBS0MsS0FBSyxDQUFDaUQsS0FBSyxDQUFDWCxhQUFhLFVBQVUsTUFDeEN4QixRQUFRekQsSUFBSSxDQUFDaEQsMERBQVdBLENBQUM2SSxZQUFZLENBQUNsQyxFQUFFLENBQUM7WUFBQ3NCO1lBQWFhO1NBQVk7UUFDdkVwRCxLQUFLYyxRQUFRLENBQUM7WUFBRUM7UUFBUTtRQUN4QmtDLFFBQVFsSiwwREFBUUEsQ0FBQ2lHLE1BQU1EO0lBQzNCO0lBQ0EsSUFBSWtELE9BQ0FBLE1BQU14QyxHQUFHLENBQUM0QyxhQUFhLENBQUMsU0FBU0MsTUFBTTtJQUMzQyxPQUFPO0FBQ1g7QUFDQSxNQUFNRixjQUFjLFdBQVcsR0FBRXRKLHdEQUFVQSxDQUFDeUosU0FBUyxDQUFDO0lBQ2xELHlCQUF5QjtRQUNyQkMsU0FBUztRQUNULFdBQVc7WUFBRUMsVUFBVTtRQUFNO0lBQ2pDO0FBQ0o7QUFFQSxNQUFNQywwQkFBMEI7SUFDNUJDLDJCQUEyQjtJQUMzQkMsb0JBQW9CO0lBQ3BCQyxZQUFZO0lBQ1pDLFlBQVk7QUFDaEI7QUFDQSxNQUFNQyxrQkFBa0IsV0FBVyxHQUFFdEosb0RBQUtBLENBQUM2SCxNQUFNLENBQUM7SUFDOUMwQixTQUFRbEcsT0FBTztRQUNYLE9BQU9wRCxnRUFBYUEsQ0FBQ29ELFNBQVM0Rix5QkFBeUI7WUFDbkRDLDJCQUEyQixDQUFDTSxHQUFHQyxJQUFNRCxLQUFLQztZQUMxQ04sb0JBQW9COUIsS0FBS0ksR0FBRztZQUM1QjJCLFlBQVkvQixLQUFLSSxHQUFHO1FBQ3hCO0lBQ0o7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsU0FBU2lDLDBCQUEwQnJHLE9BQU87SUFDdEMsSUFBSXNHLE1BQU07UUFBQ0M7UUFBY0M7S0FBaUI7SUFDMUMsSUFBSXhHLFNBQ0FzRyxJQUFJOUcsSUFBSSxDQUFDeUcsZ0JBQWdCOUMsRUFBRSxDQUFDbkQ7SUFDaEMsT0FBT3NHO0FBQ1g7QUFDQSxNQUFNRyxZQUFZLFdBQVcsR0FBRXZLLHdEQUFVQSxDQUFDd0ssSUFBSSxDQUFDO0lBQUVqRSxPQUFPO0FBQW9CO0FBQzVFLE1BQU1rRSxnQkFBZ0IsV0FBVyxHQUFFekssd0RBQVVBLENBQUN3SyxJQUFJLENBQUM7SUFBRWpFLE9BQU87QUFBMkM7QUFDdkcsc0ZBQXNGO0FBQ3RGLFNBQVNtRSxxQkFBcUJDLEtBQUssRUFBRTFFLEtBQUssRUFBRXZFLElBQUksRUFBRUMsRUFBRTtJQUNoRCxPQUFPLENBQUNELFFBQVEsS0FBS2lKLE1BQU0xRSxNQUFNMkUsUUFBUSxDQUFDbEosT0FBTyxHQUFHQSxVQUFVZiwyREFBWUEsQ0FBQ2tLLElBQUksS0FDMUVsSixDQUFBQSxNQUFNc0UsTUFBTWIsR0FBRyxDQUFDeEQsTUFBTSxJQUFJK0ksTUFBTTFFLE1BQU0yRSxRQUFRLENBQUNqSixJQUFJQSxLQUFLLE9BQU9oQiwyREFBWUEsQ0FBQ2tLLElBQUk7QUFDekY7QUFDQSw2RUFBNkU7QUFDN0UsU0FBU0MsV0FBV0gsS0FBSyxFQUFFMUUsS0FBSyxFQUFFdkUsSUFBSSxFQUFFQyxFQUFFO0lBQ3RDLE9BQU9nSixNQUFNMUUsTUFBTTJFLFFBQVEsQ0FBQ2xKLE1BQU1BLE9BQU8sT0FBT2YsMkRBQVlBLENBQUNrSyxJQUFJLElBQzFERixNQUFNMUUsTUFBTTJFLFFBQVEsQ0FBQ2pKLEtBQUssR0FBR0EsUUFBUWhCLDJEQUFZQSxDQUFDa0ssSUFBSTtBQUNqRTtBQUNBLE1BQU1QLG1CQUFtQixXQUFXLEdBQUVySyx3REFBVUEsQ0FBQzhLLFNBQVMsQ0FBQztJQUN2RHhKLFlBQVl5RSxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUNnRixXQUFXLEdBQUcsSUFBSSxDQUFDQyxPQUFPLENBQUNqRjtJQUNwQztJQUNBeUMsT0FBT0EsTUFBTSxFQUFFO1FBQ1gsSUFBSUEsT0FBT3lDLFlBQVksSUFBSXpDLE9BQU8wQyxVQUFVLElBQUkxQyxPQUFPMkMsZUFBZSxFQUNsRSxJQUFJLENBQUNKLFdBQVcsR0FBRyxJQUFJLENBQUNDLE9BQU8sQ0FBQ3hDLE9BQU96QyxJQUFJO0lBQ25EO0lBQ0FpRixRQUFRakYsSUFBSSxFQUFFO1FBQ1YsSUFBSXFGLE9BQU9yRixLQUFLQyxLQUFLLENBQUNxRixLQUFLLENBQUN2QjtRQUM1QixJQUFJLEVBQUU5RCxLQUFLLEVBQUUsR0FBR0QsTUFBTXVGLE1BQU10RixNQUFNQyxTQUFTO1FBQzNDLElBQUlxRixJQUFJQyxNQUFNLENBQUM1SixNQUFNLEdBQUcsR0FDcEIsT0FBTzVCLHdEQUFVQSxDQUFDeUwsSUFBSTtRQUMxQixJQUFJQyxRQUFRSCxJQUFJcEYsSUFBSSxFQUFFMUUsT0FBT2tKLFFBQVE7UUFDckMsSUFBSWUsTUFBTWpJLEtBQUssRUFBRTtZQUNiLElBQUksQ0FBQzRILEtBQUsxQix5QkFBeUIsRUFDL0IsT0FBTzNKLHdEQUFVQSxDQUFDeUwsSUFBSTtZQUMxQixJQUFJRSxPQUFPMUYsTUFBTTJGLE1BQU0sQ0FBQ0YsTUFBTXRGLElBQUk7WUFDbEMsSUFBSSxDQUFDdUYsTUFDRCxPQUFPM0wsd0RBQVVBLENBQUN5TCxJQUFJO1lBQzFCZCxRQUFRMUUsTUFBTTRGLGVBQWUsQ0FBQ0gsTUFBTXRGLElBQUk7WUFDeEMzRSxRQUFRd0UsTUFBTTJFLFFBQVEsQ0FBQ2UsS0FBS2pLLElBQUksRUFBRWlLLEtBQUtoSyxFQUFFO1FBQzdDLE9BQ0s7WUFDRCxJQUFJbUssTUFBTUosTUFBTS9KLEVBQUUsR0FBRytKLE1BQU1oSyxJQUFJO1lBQy9CLElBQUlvSyxNQUFNVCxLQUFLekIsa0JBQWtCLElBQUlrQyxNQUFNLEtBQ3ZDLE9BQU85TCx3REFBVUEsQ0FBQ3lMLElBQUk7WUFDMUIsSUFBSUosS0FBS3ZCLFVBQVUsRUFBRTtnQkFDakJySSxRQUFRd0UsTUFBTTJFLFFBQVEsQ0FBQ2MsTUFBTWhLLElBQUksRUFBRWdLLE1BQU0vSixFQUFFLEdBQUcsa0RBQWtEO2dCQUNoR2dKLFFBQVExRSxNQUFNNEYsZUFBZSxDQUFDSCxNQUFNdEYsSUFBSTtnQkFDeEMsSUFBSSxDQUFFc0UsQ0FBQUEscUJBQXFCQyxPQUFPMUUsT0FBT3lGLE1BQU1oSyxJQUFJLEVBQUVnSyxNQUFNL0osRUFBRSxLQUN6RG1KLFdBQVdILE9BQU8xRSxPQUFPeUYsTUFBTWhLLElBQUksRUFBRWdLLE1BQU0vSixFQUFFLElBQzdDLE9BQU8zQix3REFBVUEsQ0FBQ3lMLElBQUk7WUFDOUIsT0FDSztnQkFDRGhLLFFBQVF3RSxNQUFNMkUsUUFBUSxDQUFDYyxNQUFNaEssSUFBSSxFQUFFZ0ssTUFBTS9KLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ0YsT0FDRCxPQUFPekIsd0RBQVVBLENBQUN5TCxJQUFJO1lBQzlCO1FBQ0o7UUFDQSxJQUFJTSxPQUFPLEVBQUU7UUFDYixLQUFLLElBQUlDLFFBQVFoRyxLQUFLaUcsYUFBYSxDQUFFO1lBQ2pDLElBQUk5RCxTQUFTLElBQUk3RyxhQUFhMkUsTUFBTWIsR0FBRyxFQUFFM0QsT0FBT3VLLEtBQUt0SyxJQUFJLEVBQUVzSyxLQUFLckssRUFBRTtZQUNsRSxNQUFPLENBQUN3RyxPQUFPNUYsSUFBSSxHQUFHUixJQUFJLENBQUU7Z0JBQ3hCLElBQUksRUFBRUwsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBR3dHLE9BQU9yRyxLQUFLO2dCQUMvQixJQUFJLENBQUM2SSxTQUFTRCxxQkFBcUJDLE9BQU8xRSxPQUFPdkUsTUFBTUMsS0FBSztvQkFDeEQsSUFBSStKLE1BQU1qSSxLQUFLLElBQUkvQixRQUFRZ0ssTUFBTWhLLElBQUksSUFBSUMsTUFBTStKLE1BQU0vSixFQUFFLEVBQ25Eb0ssS0FBS3pJLElBQUksQ0FBQ21ILGNBQWNpQixLQUFLLENBQUNoSyxNQUFNQzt5QkFDbkMsSUFBSUQsUUFBUWdLLE1BQU0vSixFQUFFLElBQUlBLE1BQU0rSixNQUFNaEssSUFBSSxFQUN6Q3FLLEtBQUt6SSxJQUFJLENBQUNpSCxVQUFVbUIsS0FBSyxDQUFDaEssTUFBTUM7b0JBQ3BDLElBQUlvSyxLQUFLbkssTUFBTSxHQUFHeUosS0FBS3hCLFVBQVUsRUFDN0IsT0FBTzdKLHdEQUFVQSxDQUFDeUwsSUFBSTtnQkFDOUI7WUFDSjtRQUNKO1FBQ0EsT0FBT3pMLHdEQUFVQSxDQUFDd0YsR0FBRyxDQUFDdUc7SUFDMUI7QUFDSixHQUFHO0lBQ0NmLGFBQWFrQixDQUFBQSxJQUFLQSxFQUFFbEIsV0FBVztBQUNuQztBQUNBLE1BQU1YLGVBQWUsV0FBVyxHQUFFdkssd0RBQVVBLENBQUN5SixTQUFTLENBQUM7SUFDbkQsc0JBQXNCO1FBQUU0QyxpQkFBaUI7SUFBWTtJQUNyRCxzQ0FBc0M7UUFBRUEsaUJBQWlCO0lBQWM7QUFDM0U7QUFDQSx1Q0FBdUM7QUFDdkMsTUFBTUMsYUFBYSxDQUFDLEVBQUVuRyxLQUFLLEVBQUVhLFFBQVEsRUFBRTtJQUNuQyxJQUFJLEVBQUVaLFNBQVMsRUFBRSxHQUFHRDtJQUNwQixJQUFJb0csU0FBUzdMLDhEQUFlQSxDQUFDZ0ksTUFBTSxDQUFDdEMsVUFBVXNGLE1BQU0sQ0FBQ2MsR0FBRyxDQUFDWixDQUFBQSxRQUFTekYsTUFBTTJGLE1BQU0sQ0FBQ0YsTUFBTXRGLElBQUksS0FBSzVGLDhEQUFlQSxDQUFDMkgsTUFBTSxDQUFDdUQsTUFBTXRGLElBQUksSUFBSUYsVUFBVXFHLFNBQVM7SUFDdEosSUFBSUYsT0FBT0csRUFBRSxDQUFDdEcsWUFDVixPQUFPO0lBQ1hZLFNBQVNiLE1BQU13QyxNQUFNLENBQUM7UUFBRXZDLFdBQVdtRztJQUFPO0lBQzFDLE9BQU87QUFDWDtBQUNBLHFFQUFxRTtBQUNyRSw2Q0FBNkM7QUFDN0MsU0FBU0ksbUJBQW1CeEcsS0FBSyxFQUFFeEUsS0FBSztJQUNwQyxJQUFJLEVBQUUwRSxJQUFJLEVBQUVxRixNQUFNLEVBQUUsR0FBR3ZGLE1BQU1DLFNBQVM7SUFDdEMsSUFBSXlGLE9BQU8xRixNQUFNMkYsTUFBTSxDQUFDekYsS0FBS0MsSUFBSSxHQUFHc0csV0FBV2YsUUFBUUEsS0FBS2pLLElBQUksSUFBSXlFLEtBQUt6RSxJQUFJLElBQUlpSyxLQUFLaEssRUFBRSxJQUFJd0UsS0FBS3hFLEVBQUU7SUFDbkcsSUFBSyxJQUFJZ0wsU0FBUyxPQUFPeEUsU0FBUyxJQUFJN0csYUFBYTJFLE1BQU1iLEdBQUcsRUFBRTNELE9BQU8rSixNQUFNLENBQUNBLE9BQU81SixNQUFNLEdBQUcsRUFBRSxDQUFDRCxFQUFFLElBQUs7UUFDbEd3RyxPQUFPNUYsSUFBSTtRQUNYLElBQUk0RixPQUFPcEcsSUFBSSxFQUFFO1lBQ2IsSUFBSTRLLFFBQ0EsT0FBTztZQUNYeEUsU0FBUyxJQUFJN0csYUFBYTJFLE1BQU1iLEdBQUcsRUFBRTNELE9BQU8sR0FBR3FHLEtBQUtHLEdBQUcsQ0FBQyxHQUFHdUQsTUFBTSxDQUFDQSxPQUFPNUosTUFBTSxHQUFHLEVBQUUsQ0FBQ0YsSUFBSSxHQUFHO1lBQzVGaUwsU0FBUztRQUNiLE9BQ0s7WUFDRCxJQUFJQSxVQUFVbkIsT0FBT29CLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRW5MLElBQUksSUFBSXlHLE9BQU9yRyxLQUFLLENBQUNKLElBQUksR0FDdEQ7WUFDSixJQUFJZ0wsVUFBVTtnQkFDVixJQUFJZixPQUFPMUYsTUFBTTJGLE1BQU0sQ0FBQ3pELE9BQU9yRyxLQUFLLENBQUNKLElBQUk7Z0JBQ3pDLElBQUksQ0FBQ2lLLFFBQVFBLEtBQUtqSyxJQUFJLElBQUl5RyxPQUFPckcsS0FBSyxDQUFDSixJQUFJLElBQUlpSyxLQUFLaEssRUFBRSxJQUFJd0csT0FBT3JHLEtBQUssQ0FBQ0gsRUFBRSxFQUNyRTtZQUNSO1lBQ0EsT0FBT3dHLE9BQU9yRyxLQUFLO1FBQ3ZCO0lBQ0o7QUFDSjtBQUNBOzs7QUFHQSxHQUNBLE1BQU1nTCx1QkFBdUIsQ0FBQyxFQUFFN0csS0FBSyxFQUFFYSxRQUFRLEVBQUU7SUFDN0MsSUFBSSxFQUFFMEUsTUFBTSxFQUFFLEdBQUd2RixNQUFNQyxTQUFTO0lBQ2hDLElBQUlzRixPQUFPb0IsSUFBSSxDQUFDckIsQ0FBQUEsTUFBT0EsSUFBSTdKLElBQUksS0FBSzZKLElBQUk1SixFQUFFLEdBQ3RDLE9BQU95SyxXQUFXO1FBQUVuRztRQUFPYTtJQUFTO0lBQ3hDLElBQUlpRyxlQUFlOUcsTUFBTTJFLFFBQVEsQ0FBQ1ksTUFBTSxDQUFDLEVBQUUsQ0FBQzlKLElBQUksRUFBRThKLE1BQU0sQ0FBQyxFQUFFLENBQUM3SixFQUFFO0lBQzlELElBQUlzRSxNQUFNQyxTQUFTLENBQUNzRixNQUFNLENBQUNvQixJQUFJLENBQUNDLENBQUFBLElBQUs1RyxNQUFNMkUsUUFBUSxDQUFDaUMsRUFBRW5MLElBQUksRUFBRW1MLEVBQUVsTCxFQUFFLEtBQUtvTCxlQUNqRSxPQUFPO0lBQ1gsSUFBSXJCLFFBQVFlLG1CQUFtQnhHLE9BQU84RztJQUN0QyxJQUFJLENBQUNyQixPQUNELE9BQU87SUFDWDVFLFNBQVNiLE1BQU13QyxNQUFNLENBQUM7UUFDbEJ2QyxXQUFXRCxNQUFNQyxTQUFTLENBQUM4RyxRQUFRLENBQUN4TSw4REFBZUEsQ0FBQ2tMLEtBQUssQ0FBQ0EsTUFBTWhLLElBQUksRUFBRWdLLE1BQU0vSixFQUFFLEdBQUc7UUFDakZvRixTQUFTakgsd0RBQVVBLENBQUNzSSxjQUFjLENBQUNzRCxNQUFNL0osRUFBRTtJQUMvQztJQUNBLE9BQU87QUFDWDtBQUVBLE1BQU1zTCxvQkFBb0IsV0FBVyxHQUFFeE0sb0RBQUtBLENBQUM2SCxNQUFNLENBQUM7SUFDaEQwQixTQUFRa0QsT0FBTztRQUNYLE9BQU94TSxnRUFBYUEsQ0FBQ3dNLFNBQVM7WUFDMUJDLEtBQUs7WUFDTEMsZUFBZTtZQUNmQyxTQUFTO1lBQ1RDLFFBQVE7WUFDUkMsV0FBVztZQUNYQyxhQUFheEgsQ0FBQUEsT0FBUSxJQUFJeUgsWUFBWXpIO1lBQ3JDMEgsZUFBZWhDLENBQUFBLFFBQVM1TCx3REFBVUEsQ0FBQ3NJLGNBQWMsQ0FBQ3NEO1FBQ3REO0lBQ0o7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsU0FBU2lDLE9BQU9DLE1BQU07SUFDbEIsT0FBT0EsU0FBUztRQUFDWCxrQkFBa0JoRyxFQUFFLENBQUMyRztRQUFTQztLQUFpQixHQUFHQTtBQUN2RTtBQUNBOztBQUVBLEdBQ0EsTUFBTUM7SUFDRjs7SUFFQSxHQUNBdk0sWUFBWXFNLE1BQU0sQ0FBRTtRQUNoQixJQUFJLENBQUNELE1BQU0sR0FBR0MsT0FBT0QsTUFBTTtRQUMzQixJQUFJLENBQUNQLGFBQWEsR0FBRyxDQUFDLENBQUNRLE9BQU9SLGFBQWE7UUFDM0MsSUFBSSxDQUFDQyxPQUFPLEdBQUcsQ0FBQyxDQUFDTyxPQUFPUCxPQUFPO1FBQy9CLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUMsQ0FBQ00sT0FBT04sTUFBTTtRQUM3QixJQUFJLENBQUNTLE9BQU8sR0FBR0gsT0FBT0csT0FBTyxJQUFJO1FBQ2pDLElBQUksQ0FBQ0MsS0FBSyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUNMLE1BQU0sSUFBSyxFQUFDLElBQUksQ0FBQ0wsTUFBTSxJQUFJM0gsWUFBWSxJQUFJLENBQUNnSSxNQUFNO1FBQ3RFLElBQUksQ0FBQ00sUUFBUSxHQUFHLElBQUksQ0FBQ0MsT0FBTyxDQUFDLElBQUksQ0FBQ1AsTUFBTTtRQUN4QyxJQUFJLENBQUNKLFNBQVMsR0FBRyxDQUFDLENBQUNLLE9BQU9MLFNBQVM7SUFDdkM7SUFDQTs7SUFFQSxHQUNBVyxRQUFRMU0sSUFBSSxFQUFFO1FBQ1YsT0FBTyxJQUFJLENBQUM2TCxPQUFPLEdBQUc3TCxPQUNsQkEsS0FBS3VNLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQ0ksR0FBR0MsS0FBT0EsTUFBTSxNQUFNLE9BQU9BLE1BQU0sTUFBTSxPQUFPQSxNQUFNLE1BQU0sTUFBTztJQUN6RztJQUNBOztJQUVBLEdBQ0E1QixHQUFHNkIsS0FBSyxFQUFFO1FBQ04sT0FBTyxJQUFJLENBQUNWLE1BQU0sSUFBSVUsTUFBTVYsTUFBTSxJQUFJLElBQUksQ0FBQ0ksT0FBTyxJQUFJTSxNQUFNTixPQUFPLElBQy9ELElBQUksQ0FBQ1gsYUFBYSxJQUFJaUIsTUFBTWpCLGFBQWEsSUFBSSxJQUFJLENBQUNFLE1BQU0sSUFBSWUsTUFBTWYsTUFBTSxJQUN4RSxJQUFJLENBQUNDLFNBQVMsSUFBSWMsTUFBTWQsU0FBUztJQUN6QztJQUNBOztJQUVBLEdBQ0EvRSxTQUFTO1FBQ0wsT0FBTyxJQUFJLENBQUM4RSxNQUFNLEdBQUcsSUFBSWdCLFlBQVksSUFBSSxJQUFJLElBQUlDLFlBQVksSUFBSTtJQUNyRTtJQUNBOzs7SUFHQSxHQUNBQyxVQUFVdkksS0FBSyxFQUFFdkUsT0FBTyxDQUFDLEVBQUVDLEVBQUUsRUFBRTtRQUMzQixJQUFJOE0sS0FBS3hJLE1BQU1iLEdBQUcsR0FBR2EsUUFBUW5GLDBEQUFXQSxDQUFDMEgsTUFBTSxDQUFDO1lBQUVwRCxLQUFLYTtRQUFNO1FBQzdELElBQUl0RSxNQUFNLE1BQ05BLEtBQUs4TSxHQUFHckosR0FBRyxDQUFDeEQsTUFBTTtRQUN0QixPQUFPLElBQUksQ0FBQzBMLE1BQU0sR0FBR29CLGFBQWEsSUFBSSxFQUFFRCxJQUFJL00sTUFBTUMsTUFBTWdOLGFBQWEsSUFBSSxFQUFFRixJQUFJL00sTUFBTUM7SUFDekY7QUFDSjtBQUNBLE1BQU1pTjtJQUNGck4sWUFBWXNOLElBQUksQ0FBRTtRQUNkLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ0EsU0FBU0YsYUFBYUUsSUFBSSxFQUFFNUksS0FBSyxFQUFFdkUsSUFBSSxFQUFFQyxFQUFFO0lBQ3ZDLE9BQU8sSUFBSUwsYUFBYTJFLE1BQU1iLEdBQUcsRUFBRXlKLEtBQUtaLFFBQVEsRUFBRXZNLE1BQU1DLElBQUlrTixLQUFLekIsYUFBYSxHQUFHMEIsWUFBWXpOLENBQUFBLElBQUtBLEVBQUUwTixXQUFXLElBQUlGLEtBQUt0QixTQUFTLEdBQUd5QixlQUFlL0ksTUFBTWIsR0FBRyxFQUFFYSxNQUFNNEYsZUFBZSxDQUFDNUYsTUFBTUMsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksS0FBSzBJO0FBQ3ROO0FBQ0EsU0FBU0UsZUFBZTVKLEdBQUcsRUFBRTZKLFdBQVc7SUFDcEMsT0FBTyxDQUFDdk4sTUFBTUMsSUFBSXVOLEtBQUtDO1FBQ25CLElBQUlBLFNBQVN6TixRQUFReU4sU0FBU0QsSUFBSXROLE1BQU0sR0FBR0QsSUFBSTtZQUMzQ3dOLFNBQVNySCxLQUFLRyxHQUFHLENBQUMsR0FBR3ZHLE9BQU87WUFDNUJ3TixNQUFNOUosSUFBSUcsV0FBVyxDQUFDNEosUUFBUXJILEtBQUtJLEdBQUcsQ0FBQzlDLElBQUl4RCxNQUFNLEVBQUVELEtBQUs7UUFDNUQ7UUFDQSxPQUFPLENBQUNzTixZQUFZRyxXQUFXRixLQUFLeE4sT0FBT3lOLFlBQVl4TywyREFBWUEsQ0FBQ2tLLElBQUksSUFDcEVvRSxZQUFZSSxVQUFVSCxLQUFLeE4sT0FBT3lOLFlBQVl4TywyREFBWUEsQ0FBQ2tLLElBQUksS0FDOURvRSxDQUFBQSxZQUFZSSxVQUFVSCxLQUFLdk4sS0FBS3dOLFlBQVl4TywyREFBWUEsQ0FBQ2tLLElBQUksSUFDMURvRSxZQUFZRyxXQUFXRixLQUFLdk4sS0FBS3dOLFlBQVl4TywyREFBWUEsQ0FBQ2tLLElBQUk7SUFDMUU7QUFDSjtBQUNBLE1BQU0wRCxvQkFBb0JLO0lBQ3RCck4sWUFBWXNOLElBQUksQ0FBRTtRQUNkLEtBQUssQ0FBQ0E7SUFDVjtJQUNBUyxVQUFVckosS0FBSyxFQUFFc0osT0FBTyxFQUFFQyxLQUFLLEVBQUU7UUFDN0IsSUFBSXJILFNBQVN3RyxhQUFhLElBQUksQ0FBQ0UsSUFBSSxFQUFFNUksT0FBT3VKLE9BQU92SixNQUFNYixHQUFHLENBQUN4RCxNQUFNLEVBQUVhLGVBQWU7UUFDcEYsSUFBSTBGLE9BQU9wRyxJQUFJLEVBQ1hvRyxTQUFTd0csYUFBYSxJQUFJLENBQUNFLElBQUksRUFBRTVJLE9BQU8sR0FBR3NKLFNBQVM5TSxlQUFlO1FBQ3ZFLE9BQU8wRixPQUFPcEcsSUFBSSxHQUFHLE9BQU9vRyxPQUFPckcsS0FBSztJQUM1QztJQUNBLHVFQUF1RTtJQUN2RSxzREFBc0Q7SUFDdEQyTixpQkFBaUJ4SixLQUFLLEVBQUV2RSxJQUFJLEVBQUVDLEVBQUUsRUFBRTtRQUM5QixJQUFLLElBQUltQixNQUFNbkIsS0FBTTtZQUNqQixJQUFJZ0IsUUFBUW1GLEtBQUtHLEdBQUcsQ0FBQ3ZHLE1BQU1vQixNQUFNLE1BQU0sc0JBQXNCLE1BQUssSUFBSSxDQUFDK0wsSUFBSSxDQUFDWixRQUFRLENBQUNyTSxNQUFNO1lBQzNGLElBQUl1RyxTQUFTd0csYUFBYSxJQUFJLENBQUNFLElBQUksRUFBRTVJLE9BQU90RCxPQUFPRyxNQUFNNEksUUFBUTtZQUNqRSxNQUFPLENBQUN2RCxPQUFPMUYsZUFBZSxHQUFHVixJQUFJLENBQ2pDMkosUUFBUXZELE9BQU9yRyxLQUFLO1lBQ3hCLElBQUk0SixPQUNBLE9BQU9BO1lBQ1gsSUFBSS9JLFNBQVNqQixNQUNULE9BQU87WUFDWG9CLE9BQU8sTUFBTSxzQkFBc0I7UUFDdkM7SUFDSjtJQUNBNE0sVUFBVXpKLEtBQUssRUFBRXNKLE9BQU8sRUFBRUMsS0FBSyxFQUFFO1FBQzdCLE9BQU8sSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ3hKLE9BQU8sR0FBR3NKLFlBQ25DLElBQUksQ0FBQ0UsZ0JBQWdCLENBQUN4SixPQUFPdUosT0FBT3ZKLE1BQU1iLEdBQUcsQ0FBQ3hELE1BQU07SUFDNUQ7SUFDQStOLGVBQWVDLE9BQU8sRUFBRTtRQUFFLE9BQU8sSUFBSSxDQUFDZixJQUFJLENBQUNYLE9BQU8sQ0FBQyxJQUFJLENBQUNXLElBQUksQ0FBQ2QsT0FBTztJQUFHO0lBQ3ZFOEIsU0FBUzVKLEtBQUssRUFBRTZKLEtBQUssRUFBRTtRQUNuQixJQUFJM0gsU0FBU3dHLGFBQWEsSUFBSSxDQUFDRSxJQUFJLEVBQUU1SSxPQUFPLEdBQUdBLE1BQU1iLEdBQUcsQ0FBQ3hELE1BQU0sR0FBRzRKLFNBQVMsRUFBRTtRQUM3RSxNQUFPLENBQUNyRCxPQUFPNUYsSUFBSSxHQUFHUixJQUFJLENBQUU7WUFDeEIsSUFBSXlKLE9BQU81SixNQUFNLElBQUlrTyxPQUNqQixPQUFPO1lBQ1h0RSxPQUFPbEksSUFBSSxDQUFDNkUsT0FBT3JHLEtBQUs7UUFDNUI7UUFDQSxPQUFPMEo7SUFDWDtJQUNBdUUsVUFBVTlKLEtBQUssRUFBRXZFLElBQUksRUFBRUMsRUFBRSxFQUFFcU8sR0FBRyxFQUFFO1FBQzVCLElBQUk3SCxTQUFTd0csYUFBYSxJQUFJLENBQUNFLElBQUksRUFBRTVJLE9BQU82QixLQUFLRyxHQUFHLENBQUMsR0FBR3ZHLE9BQU8sSUFBSSxDQUFDbU4sSUFBSSxDQUFDWixRQUFRLENBQUNyTSxNQUFNLEdBQUdrRyxLQUFLSSxHQUFHLENBQUN2RyxLQUFLLElBQUksQ0FBQ2tOLElBQUksQ0FBQ1osUUFBUSxDQUFDck0sTUFBTSxFQUFFcUUsTUFBTWIsR0FBRyxDQUFDeEQsTUFBTTtRQUNwSixNQUFPLENBQUN1RyxPQUFPNUYsSUFBSSxHQUFHUixJQUFJLENBQ3RCaU8sSUFBSTdILE9BQU9yRyxLQUFLLENBQUNKLElBQUksRUFBRXlHLE9BQU9yRyxLQUFLLENBQUNILEVBQUU7SUFDOUM7QUFDSjtBQUNBLFNBQVMrTSxhQUFhRyxJQUFJLEVBQUU1SSxLQUFLLEVBQUV2RSxJQUFJLEVBQUVDLEVBQUU7SUFDdkMsT0FBTyxJQUFJa0MsYUFBYW9DLE1BQU1iLEdBQUcsRUFBRXlKLEtBQUtsQixNQUFNLEVBQUU7UUFDNUN4SixZQUFZLENBQUMwSyxLQUFLekIsYUFBYTtRQUMvQnZMLE1BQU1nTixLQUFLdEIsU0FBUyxHQUFHMEMsZUFBZWhLLE1BQU00RixlQUFlLENBQUM1RixNQUFNQyxTQUFTLENBQUNDLElBQUksQ0FBQ0MsSUFBSSxLQUFLMEk7SUFDOUYsR0FBR3BOLE1BQU1DO0FBQ2I7QUFDQSxTQUFTeU4sV0FBVzFNLEdBQUcsRUFBRVMsS0FBSztJQUMxQixPQUFPVCxJQUFJa0MsS0FBSyxDQUFDN0QsbUVBQWdCQSxDQUFDMkIsS0FBS1MsT0FBTyxRQUFRQTtBQUMxRDtBQUNBLFNBQVNrTSxVQUFVM00sR0FBRyxFQUFFUyxLQUFLO0lBQ3pCLE9BQU9ULElBQUlrQyxLQUFLLENBQUN6QixPQUFPcEMsbUVBQWdCQSxDQUFDMkIsS0FBS1M7QUFDbEQ7QUFDQSxTQUFTOE0sZUFBZWhCLFdBQVc7SUFDL0IsT0FBTyxDQUFDaUIsT0FBT0MsS0FBS2xOLFFBQVUsQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsQ0FBQ3JCLE1BQU0sSUFDMUMsQ0FBQ3FOLFlBQVlHLFdBQVduTSxNQUFNcUQsS0FBSyxFQUFFckQsTUFBTUUsS0FBSyxNQUFNeEMsMkRBQVlBLENBQUNrSyxJQUFJLElBQ25Fb0UsWUFBWUksVUFBVXBNLE1BQU1xRCxLQUFLLEVBQUVyRCxNQUFNRSxLQUFLLE1BQU14QywyREFBWUEsQ0FBQ2tLLElBQUksS0FDcEVvRSxDQUFBQSxZQUFZSSxVQUFVcE0sTUFBTXFELEtBQUssRUFBRXJELE1BQU1FLEtBQUssR0FBR0YsS0FBSyxDQUFDLEVBQUUsQ0FBQ3JCLE1BQU0sTUFBTWpCLDJEQUFZQSxDQUFDa0ssSUFBSSxJQUNwRm9FLFlBQVlHLFdBQVduTSxNQUFNcUQsS0FBSyxFQUFFckQsTUFBTUUsS0FBSyxHQUFHRixLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTSxNQUFNakIsMkRBQVlBLENBQUNrSyxJQUFJO0FBQ3hHO0FBQ0EsTUFBTXlELG9CQUFvQk07SUFDdEJVLFVBQVVySixLQUFLLEVBQUVzSixPQUFPLEVBQUVDLEtBQUssRUFBRTtRQUM3QixJQUFJckgsU0FBU3VHLGFBQWEsSUFBSSxDQUFDRyxJQUFJLEVBQUU1SSxPQUFPdUosT0FBT3ZKLE1BQU1iLEdBQUcsQ0FBQ3hELE1BQU0sRUFBRVcsSUFBSTtRQUN6RSxJQUFJNEYsT0FBT3BHLElBQUksRUFDWG9HLFNBQVN1RyxhQUFhLElBQUksQ0FBQ0csSUFBSSxFQUFFNUksT0FBTyxHQUFHc0osU0FBU2hOLElBQUk7UUFDNUQsT0FBTzRGLE9BQU9wRyxJQUFJLEdBQUcsT0FBT29HLE9BQU9yRyxLQUFLO0lBQzVDO0lBQ0EyTixpQkFBaUJ4SixLQUFLLEVBQUV2RSxJQUFJLEVBQUVDLEVBQUUsRUFBRTtRQUM5QixJQUFLLElBQUl5TyxPQUFPLElBQUlBLE9BQVE7WUFDeEIsSUFBSXpOLFFBQVFtRixLQUFLRyxHQUFHLENBQUN2RyxNQUFNQyxLQUFLeU8sT0FBTyxNQUFNLHNCQUFzQjtZQUNuRSxJQUFJakksU0FBU3VHLGFBQWEsSUFBSSxDQUFDRyxJQUFJLEVBQUU1SSxPQUFPdEQsT0FBT2hCLEtBQUsrSixRQUFRO1lBQ2hFLE1BQU8sQ0FBQ3ZELE9BQU81RixJQUFJLEdBQUdSLElBQUksQ0FDdEIySixRQUFRdkQsT0FBT3JHLEtBQUs7WUFDeEIsSUFBSTRKLFNBQVUvSSxDQUFBQSxTQUFTakIsUUFBUWdLLE1BQU1oSyxJQUFJLEdBQUdpQixRQUFRLEVBQUMsR0FDakQsT0FBTytJO1lBQ1gsSUFBSS9JLFNBQVNqQixNQUNULE9BQU87UUFDZjtJQUNKO0lBQ0FnTyxVQUFVekosS0FBSyxFQUFFc0osT0FBTyxFQUFFQyxLQUFLLEVBQUU7UUFDN0IsT0FBTyxJQUFJLENBQUNDLGdCQUFnQixDQUFDeEosT0FBTyxHQUFHc0osWUFDbkMsSUFBSSxDQUFDRSxnQkFBZ0IsQ0FBQ3hKLE9BQU91SixPQUFPdkosTUFBTWIsR0FBRyxDQUFDeEQsTUFBTTtJQUM1RDtJQUNBK04sZUFBZVUsTUFBTSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDeEIsSUFBSSxDQUFDWCxPQUFPLENBQUMsSUFBSSxDQUFDVyxJQUFJLENBQUNkLE9BQU8sRUFBRUEsT0FBTyxDQUFDLGdCQUFnQixDQUFDdUMsR0FBR3pOLElBQU1BLEtBQUssTUFBTSxNQUNuRkEsS0FBSyxNQUFNd04sT0FBT3BOLEtBQUssQ0FBQyxFQUFFLEdBQ3RCSixLQUFLLE9BQU8sQ0FBQ0EsSUFBSXdOLE9BQU9wTixLQUFLLENBQUNyQixNQUFNLEdBQUd5TyxPQUFPcE4sS0FBSyxDQUFDSixFQUFFLEdBQ2xEeU47SUFDbEI7SUFDQVQsU0FBUzVKLEtBQUssRUFBRTZKLEtBQUssRUFBRTtRQUNuQixJQUFJM0gsU0FBU3VHLGFBQWEsSUFBSSxDQUFDRyxJQUFJLEVBQUU1SSxPQUFPLEdBQUdBLE1BQU1iLEdBQUcsQ0FBQ3hELE1BQU0sR0FBRzRKLFNBQVMsRUFBRTtRQUM3RSxNQUFPLENBQUNyRCxPQUFPNUYsSUFBSSxHQUFHUixJQUFJLENBQUU7WUFDeEIsSUFBSXlKLE9BQU81SixNQUFNLElBQUlrTyxPQUNqQixPQUFPO1lBQ1h0RSxPQUFPbEksSUFBSSxDQUFDNkUsT0FBT3JHLEtBQUs7UUFDNUI7UUFDQSxPQUFPMEo7SUFDWDtJQUNBdUUsVUFBVTlKLEtBQUssRUFBRXZFLElBQUksRUFBRUMsRUFBRSxFQUFFcU8sR0FBRyxFQUFFO1FBQzVCLElBQUk3SCxTQUFTdUcsYUFBYSxJQUFJLENBQUNHLElBQUksRUFBRTVJLE9BQU82QixLQUFLRyxHQUFHLENBQUMsR0FBR3ZHLE9BQU8sSUFBSSwwQkFBMEIsTUFBS29HLEtBQUtJLEdBQUcsQ0FBQ3ZHLEtBQUssSUFBSSwwQkFBMEIsS0FBSXNFLE1BQU1iLEdBQUcsQ0FBQ3hELE1BQU07UUFDbEssTUFBTyxDQUFDdUcsT0FBTzVGLElBQUksR0FBR1IsSUFBSSxDQUN0QmlPLElBQUk3SCxPQUFPckcsS0FBSyxDQUFDSixJQUFJLEVBQUV5RyxPQUFPckcsS0FBSyxDQUFDSCxFQUFFO0lBQzlDO0FBQ0o7QUFDQTs7Ozs7O0FBTUEsR0FDQSxNQUFNNE8saUJBQWlCLFdBQVcsR0FBRWpRLDBEQUFXQSxDQUFDZ0ksTUFBTTtBQUN0RCxNQUFNa0ksY0FBYyxXQUFXLEdBQUVsUSwwREFBV0EsQ0FBQ2dJLE1BQU07QUFDbkQsTUFBTW1JLGNBQWMsV0FBVyxHQUFFbFEseURBQVVBLENBQUMrSCxNQUFNLENBQUM7SUFDL0NFLFFBQU92QyxLQUFLO1FBQ1IsT0FBTyxJQUFJeUssWUFBWUMsYUFBYTFLLE9BQU91QyxNQUFNLElBQUk7SUFDekQ7SUFDQUMsUUFBTzNHLEtBQUssRUFBRTRHLEVBQUU7UUFDWixLQUFLLElBQUlrSSxVQUFVbEksR0FBRzNCLE9BQU8sQ0FBRTtZQUMzQixJQUFJNkosT0FBT2hJLEVBQUUsQ0FBQzJILGlCQUNWek8sUUFBUSxJQUFJNE8sWUFBWUUsT0FBTzlPLEtBQUssQ0FBQzBHLE1BQU0sSUFBSTFHLE1BQU1tSCxLQUFLO2lCQUN6RCxJQUFJMkgsT0FBT2hJLEVBQUUsQ0FBQzRILGNBQ2YxTyxRQUFRLElBQUk0TyxZQUFZNU8sTUFBTUwsS0FBSyxFQUFFbVAsT0FBTzlPLEtBQUssR0FBRytPLG9CQUFvQjtRQUNoRjtRQUNBLE9BQU8vTztJQUNYO0lBQ0ErRyxTQUFTQyxDQUFBQSxJQUFLakosdURBQVNBLENBQUM2QixJQUFJLENBQUNvSCxHQUFHQyxDQUFBQSxNQUFPQSxJQUFJRSxLQUFLO0FBQ3BEO0FBQ0E7O0FBRUEsR0FDQSxTQUFTNkgsZUFBZTdLLEtBQUs7SUFDekIsSUFBSThLLFdBQVc5SyxNQUFNaUQsS0FBSyxDQUFDdUgsYUFBYTtJQUN4QyxPQUFPTSxXQUFXQSxTQUFTdFAsS0FBSyxDQUFDb04sSUFBSSxHQUFHOEIsYUFBYTFLO0FBQ3pEO0FBQ0E7O0FBRUEsR0FDQSxTQUFTK0ssZ0JBQWdCL0ssS0FBSztJQUMxQixJQUFJSjtJQUNKLE9BQU8sQ0FBQyxDQUFDQSxLQUFLSSxNQUFNaUQsS0FBSyxDQUFDdUgsYUFBYSxNQUFLLE1BQU8sUUFBUTVLLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR29ELEtBQUssS0FBSztBQUNyRztBQUNBLE1BQU15SDtJQUNGblAsWUFBWUUsS0FBSyxFQUFFd0gsS0FBSyxDQUFFO1FBQ3RCLElBQUksQ0FBQ3hILEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN3SCxLQUFLLEdBQUdBO0lBQ2pCO0FBQ0o7QUFDQSxNQUFNZ0ksWUFBWSxXQUFXLEdBQUVqUix3REFBVUEsQ0FBQ3dLLElBQUksQ0FBQztJQUFFakUsT0FBTztBQUFpQixJQUFJMkssb0JBQW9CLFdBQVcsR0FBRWxSLHdEQUFVQSxDQUFDd0ssSUFBSSxDQUFDO0lBQUVqRSxPQUFPO0FBQXlDO0FBQ2hMLE1BQU00SyxvQkFBb0IsV0FBVyxHQUFFbFIsd0RBQVVBLENBQUM4SyxTQUFTLENBQUM7SUFDeER4SixZQUFZeUUsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDZ0YsV0FBVyxHQUFHLElBQUksQ0FBQytFLFNBQVMsQ0FBQy9KLEtBQUtDLEtBQUssQ0FBQ2lELEtBQUssQ0FBQ3VIO0lBQ3ZEO0lBQ0FoSSxPQUFPQSxNQUFNLEVBQUU7UUFDWCxJQUFJeEMsUUFBUXdDLE9BQU94QyxLQUFLLENBQUNpRCxLQUFLLENBQUN1SDtRQUMvQixJQUFJeEssU0FBU3dDLE9BQU8ySSxVQUFVLENBQUNsSSxLQUFLLENBQUN1SCxnQkFBZ0JoSSxPQUFPMEMsVUFBVSxJQUFJMUMsT0FBT3lDLFlBQVksSUFBSXpDLE9BQU8yQyxlQUFlLEVBQ25ILElBQUksQ0FBQ0osV0FBVyxHQUFHLElBQUksQ0FBQytFLFNBQVMsQ0FBQzlKO0lBQzFDO0lBQ0E4SixVQUFVLEVBQUV0TyxLQUFLLEVBQUV3SCxLQUFLLEVBQUUsRUFBRTtRQUN4QixJQUFJLENBQUNBLFNBQVMsQ0FBQ3hILE1BQU1vTixJQUFJLENBQUNiLEtBQUssRUFDM0IsT0FBT2hPLHdEQUFVQSxDQUFDeUwsSUFBSTtRQUMxQixJQUFJLEVBQUV6RixJQUFJLEVBQUUsR0FBRyxJQUFJO1FBQ25CLElBQUlxTCxVQUFVLElBQUl6USw4REFBZUE7UUFDakMsSUFBSyxJQUFJaUMsSUFBSSxHQUFHMkksU0FBU3hGLEtBQUtpRyxhQUFhLEVBQUVxRixJQUFJOUYsT0FBTzVKLE1BQU0sRUFBRWlCLElBQUl5TyxHQUFHek8sSUFBSztZQUN4RSxJQUFJLEVBQUVuQixJQUFJLEVBQUVDLEVBQUUsRUFBRSxHQUFHNkosTUFBTSxDQUFDM0ksRUFBRTtZQUM1QixNQUFPQSxJQUFJeU8sSUFBSSxLQUFLM1AsS0FBSzZKLE1BQU0sQ0FBQzNJLElBQUksRUFBRSxDQUFDbkIsSUFBSSxHQUFHLElBQUksSUFBSSwwQkFBMEIsSUFDNUVDLEtBQUs2SixNQUFNLENBQUMsRUFBRTNJLEVBQUUsQ0FBQ2xCLEVBQUU7WUFDdkJGLE1BQU1zTyxTQUFTLENBQUMvSixLQUFLQyxLQUFLLEVBQUV2RSxNQUFNQyxJQUFJLENBQUNELE1BQU1DO2dCQUN6QyxJQUFJNFAsV0FBV3ZMLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxDQUFDc0YsTUFBTSxDQUFDb0IsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFbkwsSUFBSSxJQUFJQSxRQUFRbUwsRUFBRWxMLEVBQUUsSUFBSUE7Z0JBQy9FMFAsUUFBUXJCLEdBQUcsQ0FBQ3RPLE1BQU1DLElBQUk0UCxXQUFXTCxvQkFBb0JEO1lBQ3pEO1FBQ0o7UUFDQSxPQUFPSSxRQUFRRyxNQUFNO0lBQ3pCO0FBQ0osR0FBRztJQUNDeEcsYUFBYWtCLENBQUFBLElBQUtBLEVBQUVsQixXQUFXO0FBQ25DO0FBQ0EsU0FBU3lHLGNBQWMzSSxDQUFDO0lBQ3BCLE9BQU85QyxDQUFBQTtRQUNILElBQUlDLFFBQVFELEtBQUtDLEtBQUssQ0FBQ2lELEtBQUssQ0FBQ3VILGFBQWE7UUFDMUMsT0FBT3hLLFNBQVNBLE1BQU14RSxLQUFLLENBQUNvTixJQUFJLENBQUNiLEtBQUssR0FBR2xGLEVBQUU5QyxNQUFNQyxTQUFTeUwsZ0JBQWdCMUw7SUFDOUU7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsTUFBTTJMLFdBQVcsV0FBVyxHQUFFRixjQUFjLENBQUN6TCxNQUFNLEVBQUV2RSxLQUFLLEVBQUU7SUFDeEQsSUFBSSxFQUFFRSxFQUFFLEVBQUUsR0FBR3FFLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxDQUFDQyxJQUFJO0lBQ3RDLElBQUk1RCxPQUFPZCxNQUFNNk4sU0FBUyxDQUFDdEosS0FBS0MsS0FBSyxFQUFFdEUsSUFBSUE7SUFDM0MsSUFBSSxDQUFDWSxNQUNELE9BQU87SUFDWCxJQUFJMkQsWUFBWTFGLDhEQUFlQSxDQUFDb1IsTUFBTSxDQUFDclAsS0FBS2IsSUFBSSxFQUFFYSxLQUFLWixFQUFFO0lBQ3pELElBQUlpTSxTQUFTNUgsS0FBS0MsS0FBSyxDQUFDcUYsS0FBSyxDQUFDMkI7SUFDOUJqSCxLQUFLYyxRQUFRLENBQUM7UUFDVlo7UUFDQWEsU0FBUztZQUFDOEssY0FBYzdMLE1BQU16RDtZQUFPcUwsT0FBT0YsYUFBYSxDQUFDeEgsVUFBVUMsSUFBSSxFQUFFSDtTQUFNO1FBQ2hGOEwsV0FBVztJQUNmO0lBQ0FDLGtCQUFrQi9MO0lBQ2xCLE9BQU87QUFDWDtBQUNBOzs7O0FBSUEsR0FDQSxNQUFNZ00sZUFBZSxXQUFXLEdBQUVQLGNBQWMsQ0FBQ3pMLE1BQU0sRUFBRXZFLEtBQUssRUFBRTtJQUM1RCxJQUFJLEVBQUV3RSxLQUFLLEVBQUUsR0FBR0QsTUFBTSxFQUFFdEUsSUFBSSxFQUFFLEdBQUd1RSxNQUFNQyxTQUFTLENBQUNDLElBQUk7SUFDckQsSUFBSThMLE9BQU94USxNQUFNaU8sU0FBUyxDQUFDekosT0FBT3ZFLE1BQU1BO0lBQ3hDLElBQUksQ0FBQ3VRLE1BQ0QsT0FBTztJQUNYLElBQUkvTCxZQUFZMUYsOERBQWVBLENBQUNvUixNQUFNLENBQUNLLEtBQUt2USxJQUFJLEVBQUV1USxLQUFLdFEsRUFBRTtJQUN6RCxJQUFJaU0sU0FBUzVILEtBQUtDLEtBQUssQ0FBQ3FGLEtBQUssQ0FBQzJCO0lBQzlCakgsS0FBS2MsUUFBUSxDQUFDO1FBQ1ZaO1FBQ0FhLFNBQVM7WUFBQzhLLGNBQWM3TCxNQUFNaU07WUFBT3JFLE9BQU9GLGFBQWEsQ0FBQ3hILFVBQVVDLElBQUksRUFBRUg7U0FBTTtRQUNoRjhMLFdBQVc7SUFDZjtJQUNBQyxrQkFBa0IvTDtJQUNsQixPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1rTSxnQkFBZ0IsV0FBVyxHQUFFVCxjQUFjLENBQUN6TCxNQUFNLEVBQUV2RSxLQUFLLEVBQUU7SUFDN0QsSUFBSStKLFNBQVMvSixNQUFNb08sUUFBUSxDQUFDN0osS0FBS0MsS0FBSyxFQUFFO0lBQ3hDLElBQUksQ0FBQ3VGLFVBQVUsQ0FBQ0EsT0FBTzVKLE1BQU0sRUFDekIsT0FBTztJQUNYb0UsS0FBS2MsUUFBUSxDQUFDO1FBQ1ZaLFdBQVcxRiw4REFBZUEsQ0FBQ2dJLE1BQU0sQ0FBQ2dELE9BQU9jLEdBQUcsQ0FBQ08sQ0FBQUEsSUFBS3JNLDhEQUFlQSxDQUFDa0wsS0FBSyxDQUFDbUIsRUFBRW5MLElBQUksRUFBRW1MLEVBQUVsTCxFQUFFO1FBQ3BGbVEsV0FBVztJQUNmO0lBQ0EsT0FBTztBQUNYO0FBQ0E7O0FBRUEsR0FDQSxNQUFNSyx5QkFBeUIsQ0FBQyxFQUFFbE0sS0FBSyxFQUFFYSxRQUFRLEVBQUU7SUFDL0MsSUFBSXlFLE1BQU10RixNQUFNQyxTQUFTO0lBQ3pCLElBQUlxRixJQUFJQyxNQUFNLENBQUM1SixNQUFNLEdBQUcsS0FBSzJKLElBQUlwRixJQUFJLENBQUMxQyxLQUFLLEVBQ3ZDLE9BQU87SUFDWCxJQUFJLEVBQUUvQixJQUFJLEVBQUVDLEVBQUUsRUFBRSxHQUFHNEosSUFBSXBGLElBQUk7SUFDM0IsSUFBSXFGLFNBQVMsRUFBRSxFQUFFckYsT0FBTztJQUN4QixJQUFLLElBQUlpTSxNQUFNLElBQUk5USxhQUFhMkUsTUFBTWIsR0FBRyxFQUFFYSxNQUFNMkUsUUFBUSxDQUFDbEosTUFBTUMsTUFBTSxDQUFDeVEsSUFBSTdQLElBQUksR0FBR1IsSUFBSSxFQUFHO1FBQ3JGLElBQUl5SixPQUFPNUosTUFBTSxHQUFHLE1BQ2hCLE9BQU87UUFDWCxJQUFJd1EsSUFBSXRRLEtBQUssQ0FBQ0osSUFBSSxJQUFJQSxNQUNsQnlFLE9BQU9xRixPQUFPNUosTUFBTTtRQUN4QjRKLE9BQU9sSSxJQUFJLENBQUM5Qyw4REFBZUEsQ0FBQ2tMLEtBQUssQ0FBQzBHLElBQUl0USxLQUFLLENBQUNKLElBQUksRUFBRTBRLElBQUl0USxLQUFLLENBQUNILEVBQUU7SUFDbEU7SUFDQW1GLFNBQVNiLE1BQU13QyxNQUFNLENBQUM7UUFDbEJ2QyxXQUFXMUYsOERBQWVBLENBQUNnSSxNQUFNLENBQUNnRCxRQUFRckY7UUFDMUMyTCxXQUFXO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1PLGNBQWMsV0FBVyxHQUFFWixjQUFjLENBQUN6TCxNQUFNLEVBQUV2RSxLQUFLLEVBQUU7SUFDM0QsSUFBSSxFQUFFd0UsS0FBSyxFQUFFLEdBQUdELE1BQU0sRUFBRXRFLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUdzRSxNQUFNQyxTQUFTLENBQUNDLElBQUk7SUFDekQsSUFBSUYsTUFBTXFNLFFBQVEsRUFDZCxPQUFPO0lBQ1gsSUFBSS9QLE9BQU9kLE1BQU02TixTQUFTLENBQUNySixPQUFPdkUsTUFBTUE7SUFDeEMsSUFBSSxDQUFDYSxNQUNELE9BQU87SUFDWCxJQUFJZ1EsVUFBVSxFQUFFLEVBQUVyTSxXQUFXc007SUFDN0IsSUFBSXpMLFVBQVUsRUFBRTtJQUNoQixJQUFJeEUsS0FBS2IsSUFBSSxJQUFJQSxRQUFRYSxLQUFLWixFQUFFLElBQUlBLElBQUk7UUFDcEM2USxjQUFjdk0sTUFBTXdNLE1BQU0sQ0FBQ2hSLE1BQU1rTyxjQUFjLENBQUNwTjtRQUNoRGdRLFFBQVFqUCxJQUFJLENBQUM7WUFBRTVCLE1BQU1hLEtBQUtiLElBQUk7WUFBRUMsSUFBSVksS0FBS1osRUFBRTtZQUFFK1EsUUFBUUY7UUFBWTtRQUNqRWpRLE9BQU9kLE1BQU02TixTQUFTLENBQUNySixPQUFPMUQsS0FBS2IsSUFBSSxFQUFFYSxLQUFLWixFQUFFO1FBQ2hEb0YsUUFBUXpELElBQUksQ0FBQ3hELHdEQUFVQSxDQUFDNlMsUUFBUSxDQUFDMUwsRUFBRSxDQUFDaEIsTUFBTW9CLE1BQU0sQ0FBQyw0QkFBNEJwQixNQUFNYixHQUFHLENBQUNmLE1BQU0sQ0FBQzNDLE1BQU0yRSxNQUFNLElBQUk7SUFDbEg7SUFDQSxJQUFJOUQsTUFBTTtRQUNOLElBQUl1QyxNQUFNeU4sUUFBUTNRLE1BQU0sSUFBSSxLQUFLMlEsT0FBTyxDQUFDLEVBQUUsQ0FBQzdRLElBQUksSUFBSWEsS0FBS1osRUFBRSxHQUFHLElBQUlZLEtBQUtaLEVBQUUsR0FBR1ksS0FBS2IsSUFBSSxHQUFHOFEsWUFBWTVRLE1BQU07UUFDMUdzRSxZQUFZMUYsOERBQWVBLENBQUNvUixNQUFNLENBQUNyUCxLQUFLYixJQUFJLEdBQUdvRCxLQUFLdkMsS0FBS1osRUFBRSxHQUFHbUQ7UUFDOURpQyxRQUFRekQsSUFBSSxDQUFDdU8sY0FBYzdMLE1BQU16RDtRQUNqQ3dFLFFBQVF6RCxJQUFJLENBQUMyQyxNQUFNcUYsS0FBSyxDQUFDMkIsbUJBQW1CUyxhQUFhLENBQUN4SCxVQUFVQyxJQUFJLEVBQUVIO0lBQzlFO0lBQ0FBLEtBQUtjLFFBQVEsQ0FBQztRQUNWeUw7UUFBU3JNO1FBQVdhO1FBQ3BCK0ssV0FBVztJQUNmO0lBQ0EsT0FBTztBQUNYO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTWMsYUFBYSxXQUFXLEdBQUVuQixjQUFjLENBQUN6TCxNQUFNLEVBQUV2RSxLQUFLLEVBQUU7SUFDMUQsSUFBSXVFLEtBQUtDLEtBQUssQ0FBQ3FNLFFBQVEsRUFDbkIsT0FBTztJQUNYLElBQUlDLFVBQVU5USxNQUFNb08sUUFBUSxDQUFDN0osS0FBS0MsS0FBSyxFQUFFLEtBQUtxRyxHQUFHLENBQUNySixDQUFBQTtRQUM5QyxJQUFJLEVBQUV2QixJQUFJLEVBQUVDLEVBQUUsRUFBRSxHQUFHc0I7UUFDbkIsT0FBTztZQUFFdkI7WUFBTUM7WUFBSStRLFFBQVFqUixNQUFNa08sY0FBYyxDQUFDMU07UUFBTztJQUMzRDtJQUNBLElBQUksQ0FBQ3NQLFFBQVEzUSxNQUFNLEVBQ2YsT0FBTztJQUNYLElBQUlpUixlQUFlN00sS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLHNCQUFzQmtMLFFBQVEzUSxNQUFNLElBQUk7SUFDN0VvRSxLQUFLYyxRQUFRLENBQUM7UUFDVnlMO1FBQ0F4TCxTQUFTakgsd0RBQVVBLENBQUM2UyxRQUFRLENBQUMxTCxFQUFFLENBQUM0TDtRQUNoQ2YsV0FBVztJQUNmO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBU2pCLGtCQUFrQjdLLElBQUk7SUFDM0IsT0FBT0EsS0FBS0MsS0FBSyxDQUFDcUYsS0FBSyxDQUFDMkIsbUJBQW1CTyxXQUFXLENBQUN4SDtBQUMzRDtBQUNBLFNBQVMySyxhQUFhMUssS0FBSyxFQUFFNk0sUUFBUTtJQUNqQyxJQUFJak4sSUFBSWtOLElBQUlDLElBQUlDLElBQUlDO0lBQ3BCLElBQUkzSCxNQUFNdEYsTUFBTUMsU0FBUyxDQUFDQyxJQUFJO0lBQzlCLElBQUlnTixVQUFVNUgsSUFBSTlILEtBQUssSUFBSThILElBQUk1SixFQUFFLEdBQUc0SixJQUFJN0osSUFBSSxHQUFHLE1BQU0sS0FBS3VFLE1BQU0yRSxRQUFRLENBQUNXLElBQUk3SixJQUFJLEVBQUU2SixJQUFJNUosRUFBRTtJQUN6RixJQUFJbVIsWUFBWSxDQUFDSyxTQUNiLE9BQU9MO0lBQ1gsSUFBSWxGLFNBQVMzSCxNQUFNcUYsS0FBSyxDQUFDMkI7SUFDekIsT0FBTyxJQUFJYSxZQUFZO1FBQ25CSCxRQUFRLENBQUMsQ0FBQzlILEtBQUtpTixhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3pGLE9BQU8sTUFBTSxRQUFReEgsT0FBTyxLQUFLLElBQUlBLEtBQUsrSCxPQUFPUCxPQUFPLElBQUk4RixVQUFVQSxRQUFRcEYsT0FBTyxDQUFDLE9BQU87UUFDektYLGVBQWUsQ0FBQzJGLEtBQUtELGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTMUYsYUFBYSxNQUFNLFFBQVEyRixPQUFPLEtBQUssSUFBSUEsS0FBS25GLE9BQU9SLGFBQWE7UUFDdEpDLFNBQVMsQ0FBQzJGLEtBQUtGLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTekYsT0FBTyxNQUFNLFFBQVEyRixPQUFPLEtBQUssSUFBSUEsS0FBS3BGLE9BQU9QLE9BQU87UUFDcElDLFFBQVEsQ0FBQzJGLEtBQUtILGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTeEYsTUFBTSxNQUFNLFFBQVEyRixPQUFPLEtBQUssSUFBSUEsS0FBS3JGLE9BQU9OLE1BQU07UUFDaklDLFdBQVcsQ0FBQzJGLEtBQUtKLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTdkYsU0FBUyxNQUFNLFFBQVEyRixPQUFPLEtBQUssSUFBSUEsS0FBS3RGLE9BQU9MLFNBQVM7SUFDOUk7QUFDSjtBQUNBLFNBQVM2RixlQUFlcE4sSUFBSTtJQUN4QixJQUFJaUQsUUFBUWxKLDBEQUFRQSxDQUFDaUcsTUFBTTZLO0lBQzNCLE9BQU81SCxTQUFTQSxNQUFNeEMsR0FBRyxDQUFDNEMsYUFBYSxDQUFDO0FBQzVDO0FBQ0EsU0FBUzBJLGtCQUFrQi9MLElBQUk7SUFDM0IsSUFBSU0sUUFBUThNLGVBQWVwTjtJQUMzQixJQUFJTSxTQUFTQSxTQUFTTixLQUFLcU4sSUFBSSxDQUFDQyxhQUFhLEVBQ3pDaE4sTUFBTWdELE1BQU07QUFDcEI7QUFDQTs7QUFFQSxHQUNBLE1BQU1vSSxrQkFBa0IxTCxDQUFBQTtJQUNwQixJQUFJQyxRQUFRRCxLQUFLQyxLQUFLLENBQUNpRCxLQUFLLENBQUN1SCxhQUFhO0lBQzFDLElBQUl4SyxTQUFTQSxNQUFNZ0QsS0FBSyxFQUFFO1FBQ3RCLElBQUlzSyxjQUFjSCxlQUFlcE47UUFDakMsSUFBSXVOLGVBQWVBLGVBQWV2TixLQUFLcU4sSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDdkQsSUFBSTdSLFFBQVFrUCxhQUFhM0ssS0FBS0MsS0FBSyxFQUFFQSxNQUFNeEUsS0FBSyxDQUFDb04sSUFBSTtZQUNyRCxJQUFJcE4sTUFBTXVNLEtBQUssRUFDWGhJLEtBQUtjLFFBQVEsQ0FBQztnQkFBRUMsU0FBU3dKLGVBQWV0SixFQUFFLENBQUN4RjtZQUFPO1lBQ3REOFIsWUFBWXJNLEtBQUs7WUFDakJxTSxZQUFZakssTUFBTTtRQUN0QjtJQUNKLE9BQ0s7UUFDRHRELEtBQUtjLFFBQVEsQ0FBQztZQUFFQyxTQUFTO2dCQUNqQnlKLFlBQVl2SixFQUFFLENBQUM7Z0JBQ2ZoQixRQUFRc0ssZUFBZXRKLEVBQUUsQ0FBQzBKLGFBQWEzSyxLQUFLQyxLQUFLLEVBQUVBLE1BQU14RSxLQUFLLENBQUNvTixJQUFJLEtBQUt2TywwREFBV0EsQ0FBQzZJLFlBQVksQ0FBQ2xDLEVBQUUsQ0FBQzRHO2FBQ3ZHO1FBQUM7SUFDVjtJQUNBLE9BQU87QUFDWDtBQUNBOztBQUVBLEdBQ0EsTUFBTTJGLG1CQUFtQnhOLENBQUFBO0lBQ3JCLElBQUlDLFFBQVFELEtBQUtDLEtBQUssQ0FBQ2lELEtBQUssQ0FBQ3VILGFBQWE7SUFDMUMsSUFBSSxDQUFDeEssU0FBUyxDQUFDQSxNQUFNZ0QsS0FBSyxFQUN0QixPQUFPO0lBQ1gsSUFBSUEsUUFBUWxKLDBEQUFRQSxDQUFDaUcsTUFBTTZLO0lBQzNCLElBQUk1SCxTQUFTQSxNQUFNeEMsR0FBRyxDQUFDZ04sUUFBUSxDQUFDek4sS0FBS3FOLElBQUksQ0FBQ0MsYUFBYSxHQUNuRHROLEtBQUtrQixLQUFLO0lBQ2RsQixLQUFLYyxRQUFRLENBQUM7UUFBRUMsU0FBU3lKLFlBQVl2SixFQUFFLENBQUM7SUFBTztJQUMvQyxPQUFPO0FBQ1g7QUFDQTs7Ozs7Ozs7QUFRQSxHQUNBLE1BQU15TSxlQUFlO0lBQ2pCO1FBQUVDLEtBQUs7UUFBU0MsS0FBS2xDO1FBQWlCbUMsT0FBTztJQUFzQjtJQUNuRTtRQUFFRixLQUFLO1FBQU1DLEtBQUtqQztRQUFVbUMsT0FBTzlCO1FBQWM2QixPQUFPO1FBQXVCaE4sZ0JBQWdCO0lBQUs7SUFDcEc7UUFBRThNLEtBQUs7UUFBU0MsS0FBS2pDO1FBQVVtQyxPQUFPOUI7UUFBYzZCLE9BQU87UUFBdUJoTixnQkFBZ0I7SUFBSztJQUN2RztRQUFFOE0sS0FBSztRQUFVQyxLQUFLSjtRQUFrQkssT0FBTztJQUFzQjtJQUNyRTtRQUFFRixLQUFLO1FBQWVDLEtBQUt6QjtJQUF1QjtJQUNsRDtRQUFFd0IsS0FBSztRQUFhQyxLQUFLNUs7SUFBUztJQUNsQztRQUFFMkssS0FBSztRQUFTQyxLQUFLOUc7UUFBc0JqRyxnQkFBZ0I7SUFBSztDQUNuRTtBQUNELE1BQU00RztJQUNGbE0sWUFBWXlFLElBQUksQ0FBRTtRQUNkLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtRQUNaLElBQUl2RSxRQUFRLElBQUksQ0FBQ0EsS0FBSyxHQUFHdUUsS0FBS0MsS0FBSyxDQUFDaUQsS0FBSyxDQUFDdUgsYUFBYWhQLEtBQUssQ0FBQ29OLElBQUk7UUFDakUsSUFBSSxDQUFDa0YsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDQyxJQUFJLENBQUMsSUFBSTtRQUNuQyxJQUFJLENBQUNDLFdBQVcsR0FBR2pULGlEQUFHQSxDQUFDLFNBQVM7WUFDNUJjLE9BQU9MLE1BQU1rTSxNQUFNO1lBQ25CdUcsYUFBYTdNLE9BQU9yQixNQUFNO1lBQzFCLGNBQWNxQixPQUFPckIsTUFBTTtZQUMzQk8sT0FBTztZQUNQQyxNQUFNO1lBQ04yTixNQUFNO1lBQ04sY0FBYztZQUNkQyxVQUFVLElBQUksQ0FBQ0wsTUFBTTtZQUNyQk0sU0FBUyxJQUFJLENBQUNOLE1BQU07UUFDeEI7UUFDQSxJQUFJLENBQUNPLFlBQVksR0FBR3RULGlEQUFHQSxDQUFDLFNBQVM7WUFDN0JjLE9BQU9MLE1BQU1zTSxPQUFPO1lBQ3BCbUcsYUFBYTdNLE9BQU9yQixNQUFNO1lBQzFCLGNBQWNxQixPQUFPckIsTUFBTTtZQUMzQk8sT0FBTztZQUNQQyxNQUFNO1lBQ04yTixNQUFNO1lBQ05DLFVBQVUsSUFBSSxDQUFDTCxNQUFNO1lBQ3JCTSxTQUFTLElBQUksQ0FBQ04sTUFBTTtRQUN4QjtRQUNBLElBQUksQ0FBQ1EsU0FBUyxHQUFHdlQsaURBQUdBLENBQUMsU0FBUztZQUMxQnNHLE1BQU07WUFDTmQsTUFBTTtZQUNOMk4sTUFBTTtZQUNOSyxTQUFTL1MsTUFBTTJMLGFBQWE7WUFDNUJnSCxVQUFVLElBQUksQ0FBQ0wsTUFBTTtRQUN6QjtRQUNBLElBQUksQ0FBQ1UsT0FBTyxHQUFHelQsaURBQUdBLENBQUMsU0FBUztZQUN4QnNHLE1BQU07WUFDTmQsTUFBTTtZQUNOMk4sTUFBTTtZQUNOSyxTQUFTL1MsTUFBTTZMLE1BQU07WUFDckI4RyxVQUFVLElBQUksQ0FBQ0wsTUFBTTtRQUN6QjtRQUNBLElBQUksQ0FBQ1csU0FBUyxHQUFHMVQsaURBQUdBLENBQUMsU0FBUztZQUMxQnNHLE1BQU07WUFDTmQsTUFBTTtZQUNOMk4sTUFBTTtZQUNOSyxTQUFTL1MsTUFBTThMLFNBQVM7WUFDeEI2RyxVQUFVLElBQUksQ0FBQ0wsTUFBTTtRQUN6QjtRQUNBLFNBQVNZLE9BQU9uTyxJQUFJLEVBQUVvTyxPQUFPLEVBQUVDLE9BQU87WUFDbEMsT0FBTzdULGlEQUFHQSxDQUFDLFVBQVU7Z0JBQUV1RixPQUFPO2dCQUFhQztnQkFBTW9PO2dCQUFTdE4sTUFBTTtZQUFTLEdBQUd1TjtRQUNoRjtRQUNBLElBQUksQ0FBQ3BPLEdBQUcsR0FBR3pGLGlEQUFHQSxDQUFDLE9BQU87WUFBRTBGLFdBQVcsQ0FBQ2lDLElBQU0sSUFBSSxDQUFDbU0sT0FBTyxDQUFDbk07WUFBSXBDLE9BQU87UUFBWSxHQUFHO1lBQzdFLElBQUksQ0FBQzBOLFdBQVc7WUFDaEJVLE9BQU8sUUFBUSxJQUFNaEQsU0FBUzNMLE9BQU87Z0JBQUNxQixPQUFPckIsTUFBTTthQUFRO1lBQzNEMk8sT0FBTyxRQUFRLElBQU0zQyxhQUFhaE0sT0FBTztnQkFBQ3FCLE9BQU9yQixNQUFNO2FBQVk7WUFDbkUyTyxPQUFPLFVBQVUsSUFBTXpDLGNBQWNsTSxPQUFPO2dCQUFDcUIsT0FBT3JCLE1BQU07YUFBTztZQUNqRWhGLGlEQUFHQSxDQUFDLFNBQVMsTUFBTTtnQkFBQyxJQUFJLENBQUN1VCxTQUFTO2dCQUFFbE4sT0FBT3JCLE1BQU07YUFBYztZQUMvRGhGLGlEQUFHQSxDQUFDLFNBQVMsTUFBTTtnQkFBQyxJQUFJLENBQUN5VCxPQUFPO2dCQUFFcE4sT0FBT3JCLE1BQU07YUFBVTtZQUN6RGhGLGlEQUFHQSxDQUFDLFNBQVMsTUFBTTtnQkFBQyxJQUFJLENBQUMwVCxTQUFTO2dCQUFFck4sT0FBT3JCLE1BQU07YUFBVztlQUN6REEsS0FBS0MsS0FBSyxDQUFDcU0sUUFBUSxHQUFHLEVBQUUsR0FBRztnQkFDMUJ0UixpREFBR0EsQ0FBQztnQkFDSixJQUFJLENBQUNzVCxZQUFZO2dCQUNqQkssT0FBTyxXQUFXLElBQU10QyxZQUFZck0sT0FBTztvQkFBQ3FCLE9BQU9yQixNQUFNO2lCQUFXO2dCQUNwRTJPLE9BQU8sY0FBYyxJQUFNL0IsV0FBVzVNLE9BQU87b0JBQUNxQixPQUFPckIsTUFBTTtpQkFBZTthQUM3RTtZQUNEaEYsaURBQUdBLENBQUMsVUFBVTtnQkFDVndGLE1BQU07Z0JBQ05vTyxTQUFTLElBQU1wQixpQkFBaUJ4TjtnQkFDaEMsY0FBY3FCLE9BQU9yQixNQUFNO2dCQUMzQnNCLE1BQU07WUFDVixHQUFHO2dCQUFDO2FBQUk7U0FDWDtJQUNMO0lBQ0F5TSxTQUFTO1FBQ0wsSUFBSXRTLFFBQVEsSUFBSXFNLFlBQVk7WUFDeEJILFFBQVEsSUFBSSxDQUFDc0csV0FBVyxDQUFDblMsS0FBSztZQUM5QnNMLGVBQWUsSUFBSSxDQUFDbUgsU0FBUyxDQUFDQyxPQUFPO1lBQ3JDbEgsUUFBUSxJQUFJLENBQUNtSCxPQUFPLENBQUNELE9BQU87WUFDNUJqSCxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FBQ0YsT0FBTztZQUNqQ3pHLFNBQVMsSUFBSSxDQUFDdUcsWUFBWSxDQUFDeFMsS0FBSztRQUNwQztRQUNBLElBQUksQ0FBQ0wsTUFBTStLLEVBQUUsQ0FBQyxJQUFJLENBQUMvSyxLQUFLLEdBQUc7WUFDdkIsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1lBQ2IsSUFBSSxDQUFDdUUsSUFBSSxDQUFDYyxRQUFRLENBQUM7Z0JBQUVDLFNBQVN3SixlQUFldEosRUFBRSxDQUFDeEY7WUFBTztRQUMzRDtJQUNKO0lBQ0FxVCxRQUFRbk0sQ0FBQyxFQUFFO1FBQ1AsSUFBSXpJLGtFQUFnQkEsQ0FBQyxJQUFJLENBQUM4RixJQUFJLEVBQUUyQyxHQUFHLGlCQUFpQjtZQUNoREEsRUFBRTlCLGNBQWM7UUFDcEIsT0FDSyxJQUFJOEIsRUFBRS9CLE9BQU8sSUFBSSxNQUFNK0IsRUFBRW9NLE1BQU0sSUFBSSxJQUFJLENBQUNkLFdBQVcsRUFBRTtZQUN0RHRMLEVBQUU5QixjQUFjO1lBQ2Y4QixDQUFBQSxFQUFFcU0sUUFBUSxHQUFHaEQsZUFBZUwsUUFBTyxFQUFHLElBQUksQ0FBQzNMLElBQUk7UUFDcEQsT0FDSyxJQUFJMkMsRUFBRS9CLE9BQU8sSUFBSSxNQUFNK0IsRUFBRW9NLE1BQU0sSUFBSSxJQUFJLENBQUNULFlBQVksRUFBRTtZQUN2RDNMLEVBQUU5QixjQUFjO1lBQ2hCd0wsWUFBWSxJQUFJLENBQUNyTSxJQUFJO1FBQ3pCO0lBQ0o7SUFDQXlDLE9BQU9BLE1BQU0sRUFBRTtRQUNYLEtBQUssSUFBSUMsTUFBTUQsT0FBT3dNLFlBQVksQ0FDOUIsS0FBSyxJQUFJckUsVUFBVWxJLEdBQUczQixPQUFPLENBQUU7WUFDM0IsSUFBSTZKLE9BQU9oSSxFQUFFLENBQUMySCxtQkFBbUIsQ0FBQ0ssT0FBTzlPLEtBQUssQ0FBQzBLLEVBQUUsQ0FBQyxJQUFJLENBQUMvSyxLQUFLLEdBQ3hELElBQUksQ0FBQ3lULFFBQVEsQ0FBQ3RFLE9BQU85TyxLQUFLO1FBQ2xDO0lBQ1I7SUFDQW9ULFNBQVN6VCxLQUFLLEVBQUU7UUFDWixJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN3UyxXQUFXLENBQUNuUyxLQUFLLEdBQUdMLE1BQU1rTSxNQUFNO1FBQ3JDLElBQUksQ0FBQzJHLFlBQVksQ0FBQ3hTLEtBQUssR0FBR0wsTUFBTXNNLE9BQU87UUFDdkMsSUFBSSxDQUFDd0csU0FBUyxDQUFDQyxPQUFPLEdBQUcvUyxNQUFNMkwsYUFBYTtRQUM1QyxJQUFJLENBQUNxSCxPQUFPLENBQUNELE9BQU8sR0FBRy9TLE1BQU02TCxNQUFNO1FBQ25DLElBQUksQ0FBQ29ILFNBQVMsQ0FBQ0YsT0FBTyxHQUFHL1MsTUFBTThMLFNBQVM7SUFDNUM7SUFDQTRILFFBQVE7UUFDSixJQUFJLENBQUNsQixXQUFXLENBQUMzSyxNQUFNO0lBQzNCO0lBQ0EsSUFBSXhHLE1BQU07UUFBRSxPQUFPO0lBQUk7SUFDdkIsSUFBSXFLLE1BQU07UUFBRSxPQUFPLElBQUksQ0FBQ25ILElBQUksQ0FBQ0MsS0FBSyxDQUFDcUYsS0FBSyxDQUFDMkIsbUJBQW1CRSxHQUFHO0lBQUU7QUFDckU7QUFDQSxTQUFTOUYsT0FBT3JCLElBQUksRUFBRXFCLE1BQU07SUFBSSxPQUFPckIsS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDQTtBQUFTO0FBQ2xFLE1BQU0rTixpQkFBaUI7QUFDdkIsTUFBTUMsUUFBUTtBQUNkLFNBQVN4RCxjQUFjN0wsSUFBSSxFQUFFLEVBQUV0RSxJQUFJLEVBQUVDLEVBQUUsRUFBRTtJQUNyQyxJQUFJbUUsT0FBT0UsS0FBS0MsS0FBSyxDQUFDYixHQUFHLENBQUNmLE1BQU0sQ0FBQzNDLE9BQU80VCxVQUFVdFAsS0FBS0MsS0FBSyxDQUFDYixHQUFHLENBQUNmLE1BQU0sQ0FBQzFDLElBQUlBLEVBQUU7SUFDOUUsSUFBSWdCLFFBQVFtRixLQUFLRyxHQUFHLENBQUNuQyxLQUFLcEUsSUFBSSxFQUFFQSxPQUFPMFQsaUJBQWlCbFMsTUFBTTRFLEtBQUtJLEdBQUcsQ0FBQ29OLFNBQVMzVCxLQUFLeVQ7SUFDckYsSUFBSTVULE9BQU93RSxLQUFLQyxLQUFLLENBQUMyRSxRQUFRLENBQUNqSSxPQUFPTztJQUN0QyxJQUFJUCxTQUFTbUQsS0FBS3BFLElBQUksRUFBRTtRQUNwQixJQUFLLElBQUltQixJQUFJLEdBQUdBLElBQUl1UyxnQkFBZ0J2UyxJQUNoQyxJQUFJLENBQUN3UyxNQUFNeFQsSUFBSSxDQUFDTCxJQUFJLENBQUNxQixJQUFJLEVBQUUsS0FBS3dTLE1BQU14VCxJQUFJLENBQUNMLElBQUksQ0FBQ3FCLEVBQUUsR0FBRztZQUNqRHJCLE9BQU9BLEtBQUtvRCxLQUFLLENBQUMvQjtZQUNsQjtRQUNKO0lBQ1I7SUFDQSxJQUFJSyxPQUFPb1MsU0FBUztRQUNoQixJQUFLLElBQUl6UyxJQUFJckIsS0FBS0ksTUFBTSxHQUFHLEdBQUdpQixJQUFJckIsS0FBS0ksTUFBTSxHQUFHd1QsZ0JBQWdCdlMsSUFDNUQsSUFBSSxDQUFDd1MsTUFBTXhULElBQUksQ0FBQ0wsSUFBSSxDQUFDcUIsSUFBSSxFQUFFLEtBQUt3UyxNQUFNeFQsSUFBSSxDQUFDTCxJQUFJLENBQUNxQixFQUFFLEdBQUc7WUFDakRyQixPQUFPQSxLQUFLb0QsS0FBSyxDQUFDLEdBQUcvQjtZQUNyQjtRQUNKO0lBQ1I7SUFDQSxPQUFPL0Msd0RBQVVBLENBQUM2UyxRQUFRLENBQUMxTCxFQUFFLENBQUMsQ0FBQyxFQUFFakIsS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLGlCQUFpQixFQUFFLEVBQUU3RixLQUFLLENBQUMsRUFBRXdFLEtBQUtDLEtBQUssQ0FBQ29CLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRXZCLEtBQUtPLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDbEk7QUFDQSxNQUFNa0QsWUFBWSxXQUFXLEdBQUV6Six3REFBVUEsQ0FBQ3lKLFNBQVMsQ0FBQztJQUNoRCx1QkFBdUI7UUFDbkJDLFNBQVM7UUFDVCtMLFVBQVU7UUFDVixrQkFBa0I7WUFDZEEsVUFBVTtZQUNWcEksS0FBSztZQUNMcUksT0FBTztZQUNQckosaUJBQWlCO1lBQ2pCc0osUUFBUTtZQUNSQyxNQUFNO1lBQ05sTSxTQUFTO1lBQ1RtTSxRQUFRO1FBQ1o7UUFDQSw4QkFBOEI7WUFDMUJBLFFBQVE7UUFDWjtRQUNBLDBCQUEwQjtZQUN0QkMsYUFBYTtRQUNqQjtRQUNBLFdBQVc7WUFDUG5NLFVBQVU7WUFDVm9NLFlBQVk7UUFDaEI7SUFDSjtJQUNBLDBCQUEwQjtRQUFFMUosaUJBQWlCO0lBQVk7SUFDekQseUJBQXlCO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ3hELG1DQUFtQztRQUFFQSxpQkFBaUI7SUFBWTtJQUNsRSxrQ0FBa0M7UUFBRUEsaUJBQWlCO0lBQVk7QUFDckU7QUFDQSxNQUFNMEIsbUJBQW1CO0lBQ3JCNEM7SUFDQSxXQUFXLEdBQUU1UCxtREFBSUEsQ0FBQ2lWLEdBQUcsQ0FBQzNFO0lBQ3RCNUg7Q0FDSDtBQUUrUyIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmpzP2NkMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBnZXRQYW5lbCwgRGVjb3JhdGlvbiwgVmlld1BsdWdpbiwgcnVuU2NvcGVIYW5kbGVycyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgY29kZVBvaW50QXQsIGZyb21Db2RlUG9pbnQsIGNvZGVQb2ludFNpemUsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBFZGl0b3JTZWxlY3Rpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBDaGFyQ2F0ZWdvcnksIFJhbmdlU2V0QnVpbGRlciwgUHJlYywgRWRpdG9yU3RhdGUsIGZpbmRDbHVzdGVyQnJlYWsgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcblxuY29uc3QgYmFzaWNOb3JtYWxpemUgPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUgPT0gXCJmdW5jdGlvblwiXG4gICAgPyB4ID0+IHgubm9ybWFsaXplKFwiTkZLRFwiKSA6IHggPT4geDtcbi8qKlxuQSBzZWFyY2ggY3Vyc29yIHByb3ZpZGVzIGFuIGl0ZXJhdG9yIG92ZXIgdGV4dCBtYXRjaGVzIGluIGFcbmRvY3VtZW50LlxuKi9cbmNsYXNzIFNlYXJjaEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBjdXJzb3IuIFRoZSBxdWVyeSBpcyB0aGUgc2VhcmNoIHN0cmluZywgYGZyb21gIHRvXG4gICAgYHRvYCBwcm92aWRlcyB0aGUgcmVnaW9uIHRvIHNlYXJjaC5cbiAgICBcbiAgICBXaGVuIGBub3JtYWxpemVgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGNhbGxlZCwgb24gYm90aCB0aGUgcXVlcnlcbiAgICBzdHJpbmcgYW5kIHRoZSBjb250ZW50IGl0IGlzIG1hdGNoZWQgYWdhaW5zdCwgYmVmb3JlIGNvbXBhcmluZy5cbiAgICBZb3UgY2FuLCBmb3IgZXhhbXBsZSwgY3JlYXRlIGEgY2FzZS1pbnNlbnNpdGl2ZSBzZWFyY2ggYnlcbiAgICBwYXNzaW5nIGBzID0+IHMudG9Mb3dlckNhc2UoKWAuXG4gICAgXG4gICAgVGV4dCBpcyBhbHdheXMgbm9ybWFsaXplZCB3aXRoXG4gICAgW2Aubm9ybWFsaXplKFwiTkZLRFwiKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9ub3JtYWxpemUpXG4gICAgKHdoZW4gc3VwcG9ydGVkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCwgbm9ybWFsaXplLCB0ZXN0KSB7XG4gICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBtYXRjaCAob25seSBob2xkcyBhIG1lYW5pbmdmdWwgdmFsdWUgYWZ0ZXJcbiAgICAgICAgW2BuZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLm5leHQpIGhhcyBiZWVuIGNhbGxlZCBhbmQgd2hlblxuICAgICAgICBgZG9uZWAgaXMgZmFsc2UpLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBpdGVyYXRlZCByZWdpb24gaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemUgPSBub3JtYWxpemUgPyB4ID0+IG5vcm1hbGl6ZShiYXNpY05vcm1hbGl6ZSh4KSkgOiBiYXNpY05vcm1hbGl6ZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMubm9ybWFsaXplKHF1ZXJ5KTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyUG9zID09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJTdGFydCArPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnRBdCh0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciB0aGUgbmV4dCBtYXRjaC4gVXBkYXRlcyB0aGUgaXRlcmF0b3Inc1xuICAgIFtgdmFsdWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IudmFsdWUpIGFuZFxuICAgIFtgZG9uZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5kb25lKSBwcm9wZXJ0aWVzLiBTaG91bGQgYmUgY2FsbGVkXG4gICAgYXQgbGVhc3Qgb25jZSBiZWZvcmUgdXNpbmcgdGhlIGN1cnNvci5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1hdGNoZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGBuZXh0YCBtZXRob2Qgd2lsbCBpZ25vcmUgbWF0Y2hlcyB0aGF0IHBhcnRpYWxseSBvdmVybGFwIGFcbiAgICBwcmV2aW91cyBtYXRjaC4gVGhpcyBtZXRob2QgYmVoYXZlcyBsaWtlIGBuZXh0YCwgYnV0IGluY2x1ZGVzXG4gICAgc3VjaCBtYXRjaGVzLlxuICAgICovXG4gICAgbmV4dE92ZXJsYXBwaW5nKCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgaWYgKG5leHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdHIgPSBmcm9tQ29kZVBvaW50KG5leHQpLCBzdGFydCA9IHRoaXMuYnVmZmVyU3RhcnQgKyB0aGlzLmJ1ZmZlclBvcztcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBsZXQgbm9ybSA9IHRoaXMubm9ybWFsaXplKHN0cik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZSA9IG5vcm0uY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoKGNvZGUsIHBvcywgdGhpcy5idWZmZXJQb3MgKyB0aGlzLmJ1ZmZlclN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBub3JtLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBzdGFydCAmJiBpIDwgc3RyLmxlbmd0aCAmJiBzdHIuY2hhckNvZGVBdChpKSA9PSBjb2RlKVxuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaChjb2RlLCBwb3MsIGVuZCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF0Y2hlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5tYXRjaGVzW2ldLCBrZWVwID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KGluZGV4KSA9PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucXVlcnkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHsgZnJvbTogdGhpcy5tYXRjaGVzW2kgKyAxXSwgdG86IGVuZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzW2ldKys7XG4gICAgICAgICAgICAgICAgICAgIGtlZXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2VlcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5LmNoYXJDb2RlQXQoMCkgPT0gY29kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHBvcywgdG86IGVuZCB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wdXNoKDEsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoICYmIHRoaXMudGVzdCAmJiAhdGhpcy50ZXN0KG1hdGNoLmZyb20sIG1hdGNoLnRvLCB0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJTdGFydCkpXG4gICAgICAgICAgICBtYXRjaCA9IG51bGw7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKVxuICAgIFNlYXJjaEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbmNvbnN0IGVtcHR5ID0geyBmcm9tOiAtMSwgdG86IC0xLCBtYXRjaDogLypAX19QVVJFX18qLy8uKi8uZXhlYyhcIlwiKSB9O1xuY29uc3QgYmFzZUZsYWdzID0gXCJnbVwiICsgKC94Ly51bmljb2RlID09IG51bGwgPyBcIlwiIDogXCJ1XCIpO1xuLyoqXG5UaGlzIGNsYXNzIGlzIHNpbWlsYXIgdG8gW2BTZWFyY2hDdXJzb3JgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IpXG5idXQgc2VhcmNoZXMgZm9yIGEgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gaW5zdGVhZCBvZiBhIHBsYWluXG5zdHJpbmcuXG4qL1xuY2xhc3MgUmVnRXhwQ3Vyc29yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBjdXJzb3IgdGhhdCB3aWxsIHNlYXJjaCB0aGUgZ2l2ZW4gcmFuZ2UgaW4gdGhlIGdpdmVuXG4gICAgZG9jdW1lbnQuIGBxdWVyeWAgc2hvdWxkIGJlIHRoZSByYXcgcGF0dGVybiAoYXMgeW91J2QgcGFzcyBpdCB0b1xuICAgIGBuZXcgUmVnRXhwYCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgU2V0IHRvIGB0cnVlYCB3aGVuIHRoZSBjdXJzb3IgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoXG4gICAgICAgIHJhbmdlLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdpbGwgY29udGFpbiBhbiBvYmplY3Qgd2l0aCB0aGUgZXh0ZW50IG9mIHRoZSBtYXRjaCBhbmQgdGhlXG4gICAgICAgIG1hdGNoIG9iamVjdCB3aGVuIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlJlZ0V4cEN1cnNvci5uZXh0KVxuICAgICAgICBzdWNlc3NmdWxseSBmaW5kcyBhIG1hdGNoLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIGlmICgvXFxcXFtzV0Rucl18XFxufFxccnxcXFtcXF4vLnRlc3QocXVlcnkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aWxpbmVSZWdFeHBDdXJzb3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XG4gICAgICAgIHRoaXMudGVzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXN0O1xuICAgICAgICB0aGlzLml0ZXIgPSB0ZXh0Lml0ZXIoKTtcbiAgICAgICAgbGV0IHN0YXJ0TGluZSA9IHRleHQubGluZUF0KGZyb20pO1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHN0YXJ0TGluZS5mcm9tO1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLmdldExpbmUodGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgIH1cbiAgICBnZXRMaW5lKHNraXApIHtcbiAgICAgICAgdGhpcy5pdGVyLm5leHQoc2tpcCk7XG4gICAgICAgIGlmICh0aGlzLml0ZXIubGluZUJyZWFrKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA+IHRoaXMudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5jdXJMaW5lLnNsaWNlKDAsIHRoaXMudG8gLSB0aGlzLmN1ckxpbmVTdGFydCk7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICB0aGlzLmN1ckxpbmVTdGFydCA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCA+IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBcIlwiO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbWF0Y2gsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLnJlLmxhc3RJbmRleCA9IG9mZjtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMubWF0Y2hQb3MgPD0gdGhpcy50byAmJiB0aGlzLnJlLmV4ZWModGhpcy5jdXJMaW5lKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5jdXJMaW5lU3RhcnQgKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGZyb20gPCB0byB8fCBmcm9tID4gdGhpcy52YWx1ZS50bykgJiYgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2ZmID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuY3VyTGluZVN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoIDwgdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGZsYXR0ZW5lZCA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLy8gUmV1c2FibGUgKHBhcnRpYWxseSkgZmxhdHRlbmVkIGRvY3VtZW50IHN0cmluZ3NcbmNsYXNzIEZsYXR0ZW5lZERvYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdGV4dCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgc3RhdGljIGdldChkb2MsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBjYWNoZWQgPSBmbGF0dGVuZWQuZ2V0KGRvYyk7XG4gICAgICAgIGlmICghY2FjaGVkIHx8IGNhY2hlZC5mcm9tID49IHRvIHx8IGNhY2hlZC50byA8PSBmcm9tKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKSk7XG4gICAgICAgICAgICBmbGF0dGVuZWQuc2V0KGRvYywgZmxhdCk7XG4gICAgICAgICAgICByZXR1cm4gZmxhdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLmZyb20gPT0gZnJvbSAmJiBjYWNoZWQudG8gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tOiBjYWNoZWRGcm9tIH0gPSBjYWNoZWQ7XG4gICAgICAgIGlmIChjYWNoZWRGcm9tID4gZnJvbSkge1xuICAgICAgICAgICAgdGV4dCA9IGRvYy5zbGljZVN0cmluZyhmcm9tLCBjYWNoZWRGcm9tKSArIHRleHQ7XG4gICAgICAgICAgICBjYWNoZWRGcm9tID0gZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVkLnRvIDwgdG8pXG4gICAgICAgICAgICB0ZXh0ICs9IGRvYy5zbGljZVN0cmluZyhjYWNoZWQudG8sIHRvKTtcbiAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIG5ldyBGbGF0dGVuZWREb2MoY2FjaGVkRnJvbSwgdGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCB0ZXh0LnNsaWNlKGZyb20gLSBjYWNoZWRGcm9tLCB0byAtIGNhY2hlZEZyb20pKTtcbiAgICB9XG59XG5jbGFzcyBNdWx0aWxpbmVSZWdFeHBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZhbHVlID0gZW1wdHk7XG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGV4dCwgZnJvbSk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLnRlc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGVzdDtcbiAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0ZXh0LCBmcm9tLCB0aGlzLmNodW5rRW5kKGZyb20gKyA1MDAwIC8qIENodW5rLkJhc2UgKi8pKTtcbiAgICB9XG4gICAgY2h1bmtFbmQocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPj0gdGhpcy50byA/IHRoaXMudG8gOiB0aGlzLnRleHQubGluZUF0KHBvcykudG87XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBvZmYgPSB0aGlzLnJlLmxhc3RJbmRleCA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmZsYXQuZnJvbTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICAvLyBTa2lwIGVtcHR5IG1hdGNoZXMgZGlyZWN0bHkgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2hcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiAhbWF0Y2hbMF0gJiYgbWF0Y2guaW5kZXggPT0gb2ZmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmYgKyAxO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gdGhpcy5mbGF0LmZyb20gKyBtYXRjaC5pbmRleCwgdG8gPSBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbWF0Y2ggZ29lcyBhbG1vc3QgdG8gdGhlIGVuZCBvZiBhIG5vbmNvbXBsZXRlIGNodW5rLCB0cnlcbiAgICAgICAgICAgICAgICAvLyBhZ2Fpbiwgc2luY2UgaXQnbGwgbGlrZWx5IGJlIGFibGUgdG8gbWF0Y2ggbW9yZVxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5mbGF0LnRvID49IHRoaXMudG8gfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggPD0gdGhpcy5mbGF0LnRleHQubGVuZ3RoIC0gMTApICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy50ZXN0IHx8IHRoaXMudGVzdChmcm9tLCB0bywgbWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0aGlzLnRleHQsIHRvICsgKGZyb20gPT0gdG8gPyAxIDogMCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mbGF0LnRvID09IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR3JvdyB0aGUgZmxhdHRlbmVkIGRvY1xuICAgICAgICAgICAgdGhpcy5mbGF0ID0gRmxhdHRlbmVkRG9jLmdldCh0aGlzLnRleHQsIHRoaXMuZmxhdC5mcm9tLCB0aGlzLmNodW5rRW5kKHRoaXMuZmxhdC5mcm9tICsgdGhpcy5mbGF0LnRleHQubGVuZ3RoICogMikpO1xuICAgICAgICB9XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFJlZ0V4cEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IE11bHRpbGluZVJlZ0V4cEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9XG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG5mdW5jdGlvbiB2YWxpZFJlZ0V4cChzb3VyY2UpIHtcbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHNvdXJjZSwgYmFzZUZsYWdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9DaGFyRW5kKHRleHQsIHBvcykge1xuICAgIGlmIChwb3MgPj0gdGV4dC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgbGV0IGxpbmUgPSB0ZXh0LmxpbmVBdChwb3MpLCBuZXh0O1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRvICYmIChuZXh0ID0gbGluZS50ZXh0LmNoYXJDb2RlQXQocG9zIC0gbGluZS5mcm9tKSkgPj0gMHhEQzAwICYmIG5leHQgPCAweEUwMDApXG4gICAgICAgIHBvcysrO1xuICAgIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmVEaWFsb2codmlldykge1xuICAgIGxldCBsaW5lID0gU3RyaW5nKHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpLm51bWJlcik7XG4gICAgbGV0IGlucHV0ID0gZWx0KFwiaW5wdXRcIiwgeyBjbGFzczogXCJjbS10ZXh0ZmllbGRcIiwgbmFtZTogXCJsaW5lXCIsIHZhbHVlOiBsaW5lIH0pO1xuICAgIGxldCBkb20gPSBlbHQoXCJmb3JtXCIsIHtcbiAgICAgICAgY2xhc3M6IFwiY20tZ290b0xpbmVcIixcbiAgICAgICAgb25rZXlkb3duOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KSB7IC8vIEVzY2FwZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGRpYWxvZ0VmZmVjdC5vZihmYWxzZSkgfSk7XG4gICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAxMykgeyAvLyBFbnRlclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25zdWJtaXQ6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH1cbiAgICB9LCBlbHQoXCJsYWJlbFwiLCB2aWV3LnN0YXRlLnBocmFzZShcIkdvIHRvIGxpbmVcIiksIFwiOiBcIiwgaW5wdXQpLCBcIiBcIiwgZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIHR5cGU6IFwic3VibWl0XCIgfSwgdmlldy5zdGF0ZS5waHJhc2UoXCJnb1wiKSkpO1xuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSAvXihbKy1dKT8oXFxkKyk/KDpcXGQrKT8oJSk/JC8uZXhlYyhpbnB1dC52YWx1ZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBzdGFydExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBsZXQgWywgc2lnbiwgbG4sIGNsLCBwZXJjZW50XSA9IG1hdGNoO1xuICAgICAgICBsZXQgY29sID0gY2wgPyArY2wuc2xpY2UoMSkgOiAwO1xuICAgICAgICBsZXQgbGluZSA9IGxuID8gK2xuIDogc3RhcnRMaW5lLm51bWJlcjtcbiAgICAgICAgaWYgKGxuICYmIHBlcmNlbnQpIHtcbiAgICAgICAgICAgIGxldCBwYyA9IGxpbmUgLyAxMDA7XG4gICAgICAgICAgICBpZiAoc2lnbilcbiAgICAgICAgICAgICAgICBwYyA9IHBjICogKHNpZ24gPT0gXCItXCIgPyAtMSA6IDEpICsgKHN0YXJ0TGluZS5udW1iZXIgLyBzdGF0ZS5kb2MubGluZXMpO1xuICAgICAgICAgICAgbGluZSA9IE1hdGgucm91bmQoc3RhdGUuZG9jLmxpbmVzICogcGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxuICYmIHNpZ24pIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lICogKHNpZ24gPT0gXCItXCIgPyAtMSA6IDEpICsgc3RhcnRMaW5lLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG9jTGluZSA9IHN0YXRlLmRvYy5saW5lKE1hdGgubWF4KDEsIE1hdGgubWluKHN0YXRlLmRvYy5saW5lcywgbGluZSkpKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZG9jTGluZS5mcm9tICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oY29sLCBkb2NMaW5lLmxlbmd0aCkpKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBlZmZlY3RzOiBbZGlhbG9nRWZmZWN0Lm9mKGZhbHNlKSwgRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhzZWxlY3Rpb24uZnJvbSwgeyB5OiAnY2VudGVyJyB9KV0sXG4gICAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIH0pO1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfVxuICAgIHJldHVybiB7IGRvbSB9O1xufVxuY29uc3QgZGlhbG9nRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgZGlhbG9nRmllbGQgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZS5pcyhkaWFsb2dFZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsID8gY3JlYXRlTGluZURpYWxvZyA6IG51bGwpXG59KTtcbi8qKlxuQ29tbWFuZCB0aGF0IHNob3dzIGEgZGlhbG9nIGFza2luZyB0aGUgdXNlciBmb3IgYSBsaW5lIG51bWJlciwgYW5kXG53aGVuIGEgdmFsaWQgcG9zaXRpb24gaXMgcHJvdmlkZWQsIG1vdmVzIHRoZSBjdXJzb3IgdG8gdGhhdCBsaW5lLlxuXG5TdXBwb3J0cyBsaW5lIG51bWJlcnMsIHJlbGF0aXZlIGxpbmUgb2Zmc2V0cyBwcmVmaXhlZCB3aXRoIGArYCBvclxuYC1gLCBkb2N1bWVudCBwZXJjZW50YWdlcyBzdWZmaXhlZCB3aXRoIGAlYCwgYW5kIGFuIG9wdGlvbmFsXG5jb2x1bW4gcG9zaXRpb24gYnkgYWRkaW5nIGA6YCBhbmQgYSBzZWNvbmQgbnVtYmVyIGFmdGVyIHRoZSBsaW5lXG5udW1iZXIuXG4qL1xuY29uc3QgZ290b0xpbmUgPSB2aWV3ID0+IHtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVMaW5lRGlhbG9nKTtcbiAgICBpZiAoIXBhbmVsKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gW2RpYWxvZ0VmZmVjdC5vZih0cnVlKV07XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZpZWxkKGRpYWxvZ0ZpZWxkLCBmYWxzZSkgPT0gbnVsbClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW2RpYWxvZ0ZpZWxkLCBiYXNlVGhlbWUkMV0pKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgICAgIHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlTGluZURpYWxvZyk7XG4gICAgfVxuICAgIGlmIChwYW5lbClcbiAgICAgICAgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKS5zZWxlY3QoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tZ290b0xpbmVcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7IGZvbnRTaXplOiBcIjgwJVwiIH1cbiAgICB9XG59KTtcblxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMgPSB7XG4gICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogZmFsc2UsXG4gICAgbWluU2VsZWN0aW9uTGVuZ3RoOiAxLFxuICAgIG1heE1hdGNoZXM6IDEwMCxcbiAgICB3aG9sZVdvcmRzOiBmYWxzZVxufTtcbmNvbnN0IGhpZ2hsaWdodENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhvcHRpb25zLCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucywge1xuICAgICAgICAgICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogKGEsIGIpID0+IGEgfHwgYixcbiAgICAgICAgICAgIG1pblNlbGVjdGlvbkxlbmd0aDogTWF0aC5taW4sXG4gICAgICAgICAgICBtYXhNYXRjaGVzOiBNYXRoLm1pblxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuVGhpcyBleHRlbnNpb24gaGlnaGxpZ2h0cyB0ZXh0IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0aW9uLiBJdCB1c2VzXG50aGUgYFwiY20tc2VsZWN0aW9uTWF0Y2hcImAgY2xhc3MgZm9yIHRoZSBoaWdobGlnaHRpbmcuIFdoZW5cbmBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yYCBpcyBlbmFibGVkLCB0aGUgd29yZCBhdCB0aGUgY3Vyc29yXG5pdHNlbGYgd2lsbCBiZSBoaWdobGlnaHRlZCB3aXRoIGBcImNtLXNlbGVjdGlvbk1hdGNoLW1haW5cImAuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcyhvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFtkZWZhdWx0VGhlbWUsIG1hdGNoSGlnaGxpZ2h0ZXJdO1xuICAgIGlmIChvcHRpb25zKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRDb25maWcub2Yob3B0aW9ucykpO1xuICAgIHJldHVybiBleHQ7XG59XG5jb25zdCBtYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2hcIiB9KTtcbmNvbnN0IG1haW5NYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2ggY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiIH0pO1xuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBvdXRzaWRlIHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIG5vbi13b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gKGZyb20gPT0gMCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tIC0gMSwgZnJvbSkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAodG8gPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyh0bywgdG8gKyAxKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSB3b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkXG4gICAgICAgICYmIGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvIC0gMSwgdG8pKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZDtcbn1cbmNvbnN0IG1hdGNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoaGlnaGxpZ2h0Q29uZmlnKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbC5tYWluLCBxdWVyeSwgY2hlY2sgPSBudWxsO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGlmICghY29uZi5oaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIGlmICghd29yZClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHdvcmQuZnJvbSwgd29yZC50byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gcmFuZ2UudG8gLSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgaWYgKGxlbiA8IGNvbmYubWluU2VsZWN0aW9uTGVuZ3RoIHx8IGxlbiA+IDIwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgaWYgKGNvbmYud2hvbGVXb3Jkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pOyAvLyBUT0RPOiBhbGxvdyBhbmQgaW5jbHVkZSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlP1xuICAgICAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgICAgIGlmICghKGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pICYmXG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bykpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcGFydC5mcm9tLCBwYXJ0LnRvKTtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrIHx8IGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBmcm9tIDw9IHJhbmdlLmZyb20gJiYgdG8gPj0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWFpbk1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNvLmxlbmd0aCA+IGNvbmYubWF4TWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5jb25zdCBkZWZhdWx0VGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWZmNzc4MFwiIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2ggLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIgfVxufSk7XG4vLyBTZWxlY3QgdGhlIHdvcmRzIGFyb3VuZCB0aGUgY3Vyc29ycy5cbmNvbnN0IHNlbGVjdFdvcmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgbGV0IG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsZWN0aW9uLnJhbmdlcy5tYXAocmFuZ2UgPT4gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpIHx8IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCkpLCBzZWxlY3Rpb24ubWFpbkluZGV4KTtcbiAgICBpZiAobmV3U2VsLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IG5ld1NlbCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gRmluZCBuZXh0IG9jY3VycmVuY2Ugb2YgcXVlcnkgcmVsYXRpdmUgdG8gbGFzdCBjdXJzb3IuIFdyYXAgYXJvdW5kXG4vLyB0aGUgZG9jdW1lbnQgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbWF0Y2hlcy5cbmZ1bmN0aW9uIGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgcXVlcnkpIHtcbiAgICBsZXQgeyBtYWluLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChtYWluLmhlYWQpLCBmdWxsV29yZCA9IHdvcmQgJiYgd29yZC5mcm9tID09IG1haW4uZnJvbSAmJiB3b3JkLnRvID09IG1haW4udG87XG4gICAgZm9yIChsZXQgY3ljbGVkID0gZmFsc2UsIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50byk7Oykge1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIDAsIE1hdGgubWF4KDAsIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0uZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIGN5Y2xlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkICYmIHJhbmdlcy5zb21lKHIgPT4gci5mcm9tID09IGN1cnNvci52YWx1ZS5mcm9tKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmdWxsV29yZCkge1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KGN1cnNvci52YWx1ZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmQgfHwgd29yZC5mcm9tICE9IGN1cnNvci52YWx1ZS5mcm9tIHx8IHdvcmQudG8gIT0gY3Vyc29yLnZhbHVlLnRvKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblNlbGVjdCBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBFeHBhbmQgc2VsZWN0aW9uXG50byB0aGUgc3Vycm91bmRpbmcgd29yZCB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXG4qL1xuY29uc3Qgc2VsZWN0TmV4dE9jY3VycmVuY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChyYW5nZXMuc29tZShzZWwgPT4gc2VsLmZyb20gPT09IHNlbC50bykpXG4gICAgICAgIHJldHVybiBzZWxlY3RXb3JkKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGxldCBzZWFyY2hlZFRleHQgPSBzdGF0ZS5zbGljZURvYyhyYW5nZXNbMF0uZnJvbSwgcmFuZ2VzWzBdLnRvKTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gc3RhdGUuc2xpY2VEb2Moci5mcm9tLCByLnRvKSAhPSBzZWFyY2hlZFRleHQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHJhbmdlID0gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBzZWFyY2hlZFRleHQpO1xuICAgIGlmICghcmFuZ2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5hZGRSYW5nZShFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLCBmYWxzZSksXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UudG8pXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgc2VhcmNoQ29uZmlnRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICAgICAgICByZWdleHA6IGZhbHNlLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiBmYWxzZSxcbiAgICAgICAgICAgIGNyZWF0ZVBhbmVsOiB2aWV3ID0+IG5ldyBTZWFyY2hQYW5lbCh2aWV3KSxcbiAgICAgICAgICAgIHNjcm9sbFRvTWF0Y2g6IHJhbmdlID0+IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5BZGQgc2VhcmNoIHN0YXRlIHRvIHRoZSBlZGl0b3IgY29uZmlndXJhdGlvbiwgYW5kIG9wdGlvbmFsbHlcbmNvbmZpZ3VyZSB0aGUgc2VhcmNoIGV4dGVuc2lvbi5cbihbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgd2lsbCBhdXRvbWF0aWNhbGx5XG5lbmFibGUgdGhpcyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uKS5cbiovXG5mdW5jdGlvbiBzZWFyY2goY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtzZWFyY2hDb25maWdGYWNldC5vZihjb25maWcpLCBzZWFyY2hFeHRlbnNpb25zXSA6IHNlYXJjaEV4dGVuc2lvbnM7XG59XG4vKipcbkEgc2VhcmNoIHF1ZXJ5LiBQYXJ0IG9mIHRoZSBlZGl0b3IncyBzZWFyY2ggc3RhdGUuXG4qL1xuY2xhc3MgU2VhcmNoUXVlcnkge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHF1ZXJ5IG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IGNvbmZpZy5zZWFyY2g7XG4gICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9ICEhY29uZmlnLmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMubGl0ZXJhbCA9ICEhY29uZmlnLmxpdGVyYWw7XG4gICAgICAgIHRoaXMucmVnZXhwID0gISFjb25maWcucmVnZXhwO1xuICAgICAgICB0aGlzLnJlcGxhY2UgPSBjb25maWcucmVwbGFjZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLnZhbGlkID0gISF0aGlzLnNlYXJjaCAmJiAoIXRoaXMucmVnZXhwIHx8IHZhbGlkUmVnRXhwKHRoaXMuc2VhcmNoKSk7XG4gICAgICAgIHRoaXMudW5xdW90ZWQgPSB0aGlzLnVucXVvdGUodGhpcy5zZWFyY2gpO1xuICAgICAgICB0aGlzLndob2xlV29yZCA9ICEhY29uZmlnLndob2xlV29yZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1bnF1b3RlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbCA/IHRleHQgOlxuICAgICAgICAgICAgdGV4dC5yZXBsYWNlKC9cXFxcKFtucnRcXFxcXSkvZywgKF8sIGNoKSA9PiBjaCA9PSBcIm5cIiA/IFwiXFxuXCIgOiBjaCA9PSBcInJcIiA/IFwiXFxyXCIgOiBjaCA9PSBcInRcIiA/IFwiXFx0XCIgOiBcIlxcXFxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBxdWVyeSB0byBhbm90aGVyIHF1ZXJ5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoID09IG90aGVyLnNlYXJjaCAmJiB0aGlzLnJlcGxhY2UgPT0gb3RoZXIucmVwbGFjZSAmJlxuICAgICAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID09IG90aGVyLmNhc2VTZW5zaXRpdmUgJiYgdGhpcy5yZWdleHAgPT0gb3RoZXIucmVnZXhwICYmXG4gICAgICAgICAgICB0aGlzLndob2xlV29yZCA9PSBvdGhlci53aG9sZVdvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyBuZXcgUmVnRXhwUXVlcnkodGhpcykgOiBuZXcgU3RyaW5nUXVlcnkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIHNlYXJjaCBjdXJzb3IgZm9yIHRoaXMgcXVlcnksIHNlYXJjaGluZyB0aHJvdWdoIHRoZSBnaXZlblxuICAgIHJhbmdlIGluIHRoZSBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldEN1cnNvcihzdGF0ZSwgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGxldCBzdCA9IHN0YXRlLmRvYyA/IHN0YXRlIDogRWRpdG9yU3RhdGUuY3JlYXRlKHsgZG9jOiBzdGF0ZSB9KTtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHN0LmRvYy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IHJlZ2V4cEN1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pIDogc3RyaW5nQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5nQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy51bnF1b3RlZCwgZnJvbSwgdG8sIHNwZWMuY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IHggPT4geC50b0xvd2VyQ2FzZSgpLCBzcGVjLndob2xlV29yZCA/IHN0cmluZ1dvcmRUZXN0KHN0YXRlLmRvYywgc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBzdHJpbmdXb3JkVGVzdChkb2MsIGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChmcm9tLCB0bywgYnVmLCBidWZQb3MpID0+IHtcbiAgICAgICAgaWYgKGJ1ZlBvcyA+IGZyb20gfHwgYnVmUG9zICsgYnVmLmxlbmd0aCA8IHRvKSB7XG4gICAgICAgICAgICBidWZQb3MgPSBNYXRoLm1heCgwLCBmcm9tIC0gMik7XG4gICAgICAgICAgICBidWYgPSBkb2Muc2xpY2VTdHJpbmcoYnVmUG9zLCBNYXRoLm1pbihkb2MubGVuZ3RoLCB0byArIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJBZnRlcihidWYsIGZyb20gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCB0byAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIHRvIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xuICAgIH07XG59XG5jbGFzcyBTdHJpbmdRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcihzcGVjKTtcbiAgICB9XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxuICAgICAgICAgICAgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIGN1ckZyb20pLm5leHRPdmVybGFwcGluZygpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICAvLyBTZWFyY2hpbmcgaW4gcmV2ZXJzZSBpcywgcmF0aGVyIHRoYW4gaW1wbGVtZW50aW5nIGFuIGludmVydGVkIHNlYXJjaFxuICAgIC8vIGN1cnNvciwgZG9uZSBieSBzY2FubmluZyBjaHVuayBhZnRlciBjaHVuayBmb3J3YXJkLlxuICAgIHByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRvOzspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGZyb20sIHBvcyAtIDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLyAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBzdGFydCwgcG9zKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dE92ZXJsYXBwaW5nKCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHBvcyAtPSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKSB8fFxuICAgICAgICAgICAgdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KF9yZXN1bHQpIHsgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlKTsgfVxuICAgIG1hdGNoQWxsKHN0YXRlLCBsaW1pdCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIHN0YXRlLmRvYy5sZW5ndGgpLCByYW5nZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBoaWdobGlnaHQoc3RhdGUsIGZyb20sIHRvLCBhZGQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBNYXRoLm1heCgwLCBmcm9tIC0gdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCksIE1hdGgubWluKHRvICsgdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCwgc3RhdGUuZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWdleHBDdXJzb3Ioc3BlYywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHBDdXJzb3Ioc3RhdGUuZG9jLCBzcGVjLnNlYXJjaCwge1xuICAgICAgICBpZ25vcmVDYXNlOiAhc3BlYy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICB0ZXN0OiBzcGVjLndob2xlV29yZCA/IHJlZ2V4cFdvcmRUZXN0KHN0YXRlLmNoYXJDYXRlZ29yaXplcihzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKSkgOiB1bmRlZmluZWRcbiAgICB9LCBmcm9tLCB0byk7XG59XG5mdW5jdGlvbiBjaGFyQmVmb3JlKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBpbmRleCwgZmFsc2UpLCBpbmRleCk7XG59XG5mdW5jdGlvbiBjaGFyQWZ0ZXIoc3RyLCBpbmRleCkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoaW5kZXgsIGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBpbmRleCkpO1xufVxuZnVuY3Rpb24gcmVnZXhwV29yZFRlc3QoY2F0ZWdvcml6ZXIpIHtcbiAgICByZXR1cm4gKF9mcm9tLCBfdG8sIG1hdGNoKSA9PiAhbWF0Y2hbMF0ubGVuZ3RoIHx8XG4gICAgICAgIChjYXRlZ29yaXplcihjaGFyQmVmb3JlKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQWZ0ZXIobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG59XG5jbGFzcyBSZWdFeHBRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0KCk7XG4gICAgICAgIGlmIChjdXJzb3IuZG9uZSlcbiAgICAgICAgICAgIGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBjdXJGcm9tKS5uZXh0KCk7XG4gICAgICAgIHJldHVybiBjdXJzb3IuZG9uZSA/IG51bGwgOiBjdXJzb3IudmFsdWU7XG4gICAgfVxuICAgIHByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAobGV0IHNpemUgPSAxOzsgc2l6ZSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCB0byAtIHNpemUgKiAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8pO1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBzdGFydCwgdG8pLCByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZSAmJiAoc3RhcnQgPT0gZnJvbSB8fCByYW5nZS5mcm9tID4gc3RhcnQgKyAxMCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJldk1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKSB8fFxuICAgICAgICAgICAgdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldFJlcGxhY2VtZW50KHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLnVucXVvdGUodGhpcy5zcGVjLnJlcGxhY2UpLnJlcGxhY2UoL1xcJChbJCZcXGQrXSkvZywgKG0sIGkpID0+IGkgPT0gXCIkXCIgPyBcIiRcIlxuICAgICAgICAgICAgOiBpID09IFwiJlwiID8gcmVzdWx0Lm1hdGNoWzBdXG4gICAgICAgICAgICAgICAgOiBpICE9IFwiMFwiICYmICtpIDwgcmVzdWx0Lm1hdGNoLmxlbmd0aCA/IHJlc3VsdC5tYXRjaFtpXVxuICAgICAgICAgICAgICAgICAgICA6IG0pO1xuICAgIH1cbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgTWF0aC5tYXgoMCwgZnJvbSAtIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovKSwgTWF0aC5taW4odG8gKyAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLywgc3RhdGUuZG9jLmxlbmd0aCkpO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSlcbiAgICAgICAgICAgIGFkZChjdXJzb3IudmFsdWUuZnJvbSwgY3Vyc29yLnZhbHVlLnRvKTtcbiAgICB9XG59XG4vKipcbkEgc3RhdGUgZWZmZWN0IHRoYXQgdXBkYXRlcyB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkuIE5vdGUgdGhhdFxudGhpcyBvbmx5IGhhcyBhbiBlZmZlY3QgaWYgdGhlIHNlYXJjaCBzdGF0ZSBoYXMgYmVlbiBpbml0aWFsaXplZFxuKGJ5IGluY2x1ZGluZyBbYHNlYXJjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlYXJjaCkgaW4geW91ciBjb25maWd1cmF0aW9uIG9yXG5ieSBydW5uaW5nIFtgb3BlblNlYXJjaFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2gub3BlblNlYXJjaFBhbmVsKSBhdCBsZWFzdFxub25jZSkuXG4qL1xuY29uc3Qgc2V0U2VhcmNoUXVlcnkgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCB0b2dnbGVQYW5lbCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNlYXJjaFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWFyY2hTdGF0ZShkZWZhdWx0UXVlcnkoc3RhdGUpLmNyZWF0ZSgpLCBudWxsKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VhcmNoUXVlcnkpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFNlYXJjaFN0YXRlKGVmZmVjdC52YWx1ZS5jcmVhdGUoKSwgdmFsdWUucGFuZWwpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKHRvZ2dsZVBhbmVsKSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZSh2YWx1ZS5xdWVyeSwgZWZmZWN0LnZhbHVlID8gY3JlYXRlU2VhcmNoUGFuZWwgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IHNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwucGFuZWwpXG59KTtcbi8qKlxuR2V0IHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeSBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiBnZXRTZWFyY2hRdWVyeShzdGF0ZSkge1xuICAgIGxldCBjdXJTdGF0ZSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGN1clN0YXRlID8gY3VyU3RhdGUucXVlcnkuc3BlYyA6IGRlZmF1bHRRdWVyeShzdGF0ZSk7XG59XG4vKipcblF1ZXJ5IHdoZXRoZXIgdGhlIHNlYXJjaCBwYW5lbCBpcyBvcGVuIGluIHRoZSBnaXZlbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gc2VhcmNoUGFuZWxPcGVuKHN0YXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhbmVsKSAhPSBudWxsO1xufVxuY2xhc3MgU2VhcmNoU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBwYW5lbCkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICB9XG59XG5jb25zdCBtYXRjaE1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VhcmNoTWF0Y2hcIiB9KSwgc2VsZWN0ZWRNYXRjaE1hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VhcmNoTWF0Y2ggY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIiB9KTtcbmNvbnN0IHNlYXJjaEhpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodCh2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdXBkYXRlLnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlICE9IHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQoc3RhdGUpO1xuICAgIH1cbiAgICBoaWdobGlnaHQoeyBxdWVyeSwgcGFuZWwgfSkge1xuICAgICAgICBpZiAoIXBhbmVsIHx8ICFxdWVyeS5zcGVjLnZhbGlkKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCByYW5nZXMgPSB2aWV3LnZpc2libGVSYW5nZXMsIGwgPSByYW5nZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBsIC0gMSAmJiB0byA+IHJhbmdlc1tpICsgMV0uZnJvbSAtIDIgKiAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICB0byA9IHJhbmdlc1srK2ldLnRvO1xuICAgICAgICAgICAgcXVlcnkuaGlnaGxpZ2h0KHZpZXcuc3RhdGUsIGZyb20sIHRvLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWQgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA9PSBmcm9tICYmIHIudG8gPT0gdG8pO1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCBzZWxlY3RlZCA/IHNlbGVjdGVkTWF0Y2hNYXJrIDogbWF0Y2hNYXJrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcbmZ1bmN0aW9uIHNlYXJjaENvbW1hbmQoZikge1xuICAgIHJldHVybiB2aWV3ID0+IHtcbiAgICAgICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gc3RhdGUgJiYgc3RhdGUucXVlcnkuc3BlYy52YWxpZCA/IGYodmlldywgc3RhdGUpIDogb3BlblNlYXJjaFBhbmVsKHZpZXcpO1xuICAgIH07XG59XG4vKipcbk9wZW4gdGhlIHNlYXJjaCBwYW5lbCBpZiBpdCBpc24ndCBhbHJlYWR5IG9wZW4sIGFuZCBtb3ZlIHRoZVxuc2VsZWN0aW9uIHRvIHRoZSBmaXJzdCBtYXRjaCBhZnRlciB0aGUgY3VycmVudCBtYWluIHNlbGVjdGlvbi5cbldpbGwgd3JhcCBhcm91bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCB3aGVuIGl0IHJlYWNoZXMgdGhlXG5lbmQuXG4qL1xuY29uc3QgZmluZE5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2godmlldy5zdGF0ZSwgdG8sIHRvKTtcbiAgICBpZiAoIW5leHQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXh0LmZyb20sIG5leHQudG8pO1xuICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBlZmZlY3RzOiBbYW5ub3VuY2VNYXRjaCh2aWV3LCBuZXh0KSwgY29uZmlnLnNjcm9sbFRvTWF0Y2goc2VsZWN0aW9uLm1haW4sIHZpZXcpXSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHNlbGVjdFNlYXJjaElucHV0KHZpZXcpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgaW5zdGFuY2Ugb2YgdGhlIHNlYXJjaCBxdWVyeSxcbmJlZm9yZSB0aGUgY3VycmVudCBtYWluIHNlbGVjdGlvbi4gV2lsbCB3cmFwIHBhc3QgdGhlIHN0YXJ0XG5vZiB0aGUgZG9jdW1lbnQgdG8gc3RhcnQgc2VhcmNoaW5nIGF0IHRoZSBlbmQgYWdhaW4uXG4qL1xuY29uc3QgZmluZFByZXZpb3VzID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCB7IGZyb20gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBwcmV2ID0gcXVlcnkucHJldk1hdGNoKHN0YXRlLCBmcm9tLCBmcm9tKTtcbiAgICBpZiAoIXByZXYpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShwcmV2LmZyb20sIHByZXYudG8pO1xuICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBlZmZlY3RzOiBbYW5ub3VuY2VNYXRjaCh2aWV3LCBwcmV2KSwgY29uZmlnLnNjcm9sbFRvTWF0Y2goc2VsZWN0aW9uLm1haW4sIHZpZXcpXSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2hcIlxuICAgIH0pO1xuICAgIHNlbGVjdFNlYXJjaElucHV0KHZpZXcpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hlcyA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZSwgMTAwMCk7XG4gICAgaWYgKCFyYW5nZXMgfHwgIXJhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcy5tYXAociA9PiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoci5mcm9tLCByLnRvKSkpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQuXG4qL1xuY29uc3Qgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxIHx8IHNlbC5tYWluLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbC5tYWluO1xuICAgIGxldCByYW5nZXMgPSBbXSwgbWFpbiA9IDA7XG4gICAgZm9yIChsZXQgY3VyID0gbmV3IFNlYXJjaEN1cnNvcihzdGF0ZS5kb2MsIHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSk7ICFjdXIubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID4gMTAwMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGN1ci52YWx1ZS5mcm9tID09IGZyb20pXG4gICAgICAgICAgICBtYWluID0gcmFuZ2VzLmxlbmd0aDtcbiAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGN1ci52YWx1ZS5mcm9tLCBjdXIudmFsdWUudG8pKTtcbiAgICB9XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHtcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgbWFpbiksXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoLm1hdGNoZXNcIlxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlcGxhY2UgdGhlIGN1cnJlbnQgbWF0Y2ggb2YgdGhlIHNlYXJjaCBxdWVyeS5cbiovXG5jb25zdCByZXBsYWNlTmV4dCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgeyBmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG5leHQgPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUsIGZyb20sIGZyb20pO1xuICAgIGlmICghbmV4dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHNlbGVjdGlvbiwgcmVwbGFjZW1lbnQ7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBpZiAobmV4dC5mcm9tID09IGZyb20gJiYgbmV4dC50byA9PSB0bykge1xuICAgICAgICByZXBsYWNlbWVudCA9IHN0YXRlLnRvVGV4dChxdWVyeS5nZXRSZXBsYWNlbWVudChuZXh0KSk7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG5leHQuZnJvbSwgdG86IG5leHQudG8sIGluc2VydDogcmVwbGFjZW1lbnQgfSk7XG4gICAgICAgIG5leHQgPSBxdWVyeS5uZXh0TWF0Y2goc3RhdGUsIG5leHQuZnJvbSwgbmV4dC50byk7XG4gICAgICAgIGVmZmVjdHMucHVzaChFZGl0b3JWaWV3LmFubm91bmNlLm9mKHN0YXRlLnBocmFzZShcInJlcGxhY2VkIG1hdGNoIG9uIGxpbmUgJFwiLCBzdGF0ZS5kb2MubGluZUF0KGZyb20pLm51bWJlcikgKyBcIi5cIikpO1xuICAgIH1cbiAgICBpZiAobmV4dCkge1xuICAgICAgICBsZXQgb2ZmID0gY2hhbmdlcy5sZW5ndGggPT0gMCB8fCBjaGFuZ2VzWzBdLmZyb20gPj0gbmV4dC50byA/IDAgOiBuZXh0LnRvIC0gbmV4dC5mcm9tIC0gcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5leHQuZnJvbSAtIG9mZiwgbmV4dC50byAtIG9mZik7XG4gICAgICAgIGVmZmVjdHMucHVzaChhbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpKTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKHN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS5zY3JvbGxUb01hdGNoKHNlbGVjdGlvbi5tYWluLCB2aWV3KSk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsXG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5yZXBsYWNlXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5SZXBsYWNlIGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeSB3aXRoIHRoZSBnaXZlblxucmVwbGFjZW1lbnQuXG4qL1xuY29uc3QgcmVwbGFjZUFsbCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gcXVlcnkubWF0Y2hBbGwodmlldy5zdGF0ZSwgMWU5KS5tYXAobWF0Y2ggPT4ge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gbWF0Y2g7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCBpbnNlcnQ6IHF1ZXJ5LmdldFJlcGxhY2VtZW50KG1hdGNoKSB9O1xuICAgIH0pO1xuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYW5ub3VuY2VUZXh0ID0gdmlldy5zdGF0ZS5waHJhc2UoXCJyZXBsYWNlZCAkIG1hdGNoZXNcIiwgY2hhbmdlcy5sZW5ndGgpICsgXCIuXCI7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYW5ub3VuY2VUZXh0KSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2UuYWxsXCJcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuZnVuY3Rpb24gY3JlYXRlU2VhcmNoUGFuZWwodmlldykge1xuICAgIHJldHVybiB2aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS5jcmVhdGVQYW5lbCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRRdWVyeShzdGF0ZSwgZmFsbGJhY2spIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgc2VsVGV4dCA9IHNlbC5lbXB0eSB8fCBzZWwudG8gPiBzZWwuZnJvbSArIDEwMCA/IFwiXCIgOiBzdGF0ZS5zbGljZURvYyhzZWwuZnJvbSwgc2VsLnRvKTtcbiAgICBpZiAoZmFsbGJhY2sgJiYgIXNlbFRleHQpXG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICBsZXQgY29uZmlnID0gc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpO1xuICAgIHJldHVybiBuZXcgU2VhcmNoUXVlcnkoe1xuICAgICAgICBzZWFyY2g6ICgoX2EgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2subGl0ZXJhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uZmlnLmxpdGVyYWwpID8gc2VsVGV4dCA6IHNlbFRleHQucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIiksXG4gICAgICAgIGNhc2VTZW5zaXRpdmU6IChfYiA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5jYXNlU2Vuc2l0aXZlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb25maWcuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgbGl0ZXJhbDogKF9jID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGNvbmZpZy5saXRlcmFsLFxuICAgICAgICByZWdleHA6IChfZCA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5yZWdleHApICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGNvbmZpZy5yZWdleHAsXG4gICAgICAgIHdob2xlV29yZDogKF9lID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLndob2xlV29yZCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogY29uZmlnLndob2xlV29yZFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VhcmNoSW5wdXQodmlldykge1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZVNlYXJjaFBhbmVsKTtcbiAgICByZXR1cm4gcGFuZWwgJiYgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbbWFpbi1maWVsZF1cIik7XG59XG5mdW5jdGlvbiBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KSB7XG4gICAgbGV0IGlucHV0ID0gZ2V0U2VhcmNoSW5wdXQodmlldyk7XG4gICAgaWYgKGlucHV0ICYmIGlucHV0ID09IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KVxuICAgICAgICBpbnB1dC5zZWxlY3QoKTtcbn1cbi8qKlxuTWFrZSBzdXJlIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBhbmQgZm9jdXNlZC5cbiovXG5jb25zdCBvcGVuU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKHN0YXRlICYmIHN0YXRlLnBhbmVsKSB7XG4gICAgICAgIGxldCBzZWFyY2hJbnB1dCA9IGdldFNlYXJjaElucHV0KHZpZXcpO1xuICAgICAgICBpZiAoc2VhcmNoSW5wdXQgJiYgc2VhcmNoSW5wdXQgIT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS52YWxpZClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHRvZ2dsZVBhbmVsLm9mKHRydWUpLFxuICAgICAgICAgICAgICAgIHN0YXRlID8gc2V0U2VhcmNoUXVlcnkub2YoZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpKSA6IFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihzZWFyY2hFeHRlbnNpb25zKVxuICAgICAgICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgc2VhcmNoIHBhbmVsLlxuKi9cbmNvbnN0IGNsb3NlU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jb250YWlucyh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRGVmYXVsdCBzZWFyY2gtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIE1vZC1mOiBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbClcbiAtIEYzLCBNb2QtZzogW2BmaW5kTmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmROZXh0KVxuIC0gU2hpZnQtRjMsIFNoaWZ0LU1vZC1nOiBbYGZpbmRQcmV2aW91c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmRQcmV2aW91cylcbiAtIE1vZC1BbHQtZzogW2Bnb3RvTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmdvdG9MaW5lKVxuIC0gTW9kLWQ6IFtgc2VsZWN0TmV4dE9jY3VycmVuY2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWxlY3ROZXh0T2NjdXJyZW5jZSlcbiovXG5jb25zdCBzZWFyY2hLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiTW9kLWZcIiwgcnVuOiBvcGVuU2VhcmNoUGFuZWwsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiB9LFxuICAgIHsga2V5OiBcIkYzXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtZ1wiLCBydW46IGZpbmROZXh0LCBzaGlmdDogZmluZFByZXZpb3VzLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xvc2VTZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiTW9kLVNoaWZ0LWxcIiwgcnVuOiBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzIH0sXG4gICAgeyBrZXk6IFwiTW9kLUFsdC1nXCIsIHJ1bjogZ290b0xpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtZFwiLCBydW46IHNlbGVjdE5leHRPY2N1cnJlbmNlLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuXTtcbmNsYXNzIFNlYXJjaFBhbmVsIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMucXVlcnkgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlKS5xdWVyeS5zcGVjO1xuICAgICAgICB0aGlzLmNvbW1pdCA9IHRoaXMuY29tbWl0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkuc2VhcmNoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIkZpbmRcIiksXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLFxuICAgICAgICAgICAgbmFtZTogXCJzZWFyY2hcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBcIm1haW4tZmllbGRcIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXQsXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogcXVlcnkucmVwbGFjZSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcbiAgICAgICAgICAgIG9ua2V5dXA6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwiY2FzZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5LmNhc2VTZW5zaXRpdmUsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwicmVcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5yZWdleHAsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud29yZEZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJ3b3JkXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkud2hvbGVXb3JkLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBidXR0b24obmFtZSwgb25jbGljaywgY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCBuYW1lLCBvbmNsaWNrLCB0eXBlOiBcImJ1dHRvblwiIH0sIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tID0gZWx0KFwiZGl2XCIsIHsgb25rZXlkb3duOiAoZSkgPT4gdGhpcy5rZXlkb3duKGUpLCBjbGFzczogXCJjbS1zZWFyY2hcIiB9LCBbXG4gICAgICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLFxuICAgICAgICAgICAgYnV0dG9uKFwibmV4dFwiLCAoKSA9PiBmaW5kTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcIm5leHRcIildKSxcbiAgICAgICAgICAgIGJ1dHRvbihcInByZXZcIiwgKCkgPT4gZmluZFByZXZpb3VzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicHJldmlvdXNcIildKSxcbiAgICAgICAgICAgIGJ1dHRvbihcInNlbGVjdFwiLCAoKSA9PiBzZWxlY3RNYXRjaGVzKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwiYWxsXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy5jYXNlRmllbGQsIHBocmFzZSh2aWV3LCBcIm1hdGNoIGNhc2VcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLnJlRmllbGQsIHBocmFzZSh2aWV3LCBcInJlZ2V4cFwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMud29yZEZpZWxkLCBwaHJhc2UodmlldywgXCJieSB3b3JkXCIpXSksXG4gICAgICAgICAgICAuLi52aWV3LnN0YXRlLnJlYWRPbmx5ID8gW10gOiBbXG4gICAgICAgICAgICAgICAgZWx0KFwiYnJcIiksXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQsXG4gICAgICAgICAgICAgICAgYnV0dG9uKFwicmVwbGFjZVwiLCAoKSA9PiByZXBsYWNlTmV4dCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2VcIildKSxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlQWxsXCIsICgpID0+IHJlcGxhY2VBbGwodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlIGFsbFwiKV0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgICAgICAgICAgb25jbGljazogKCkgPT4gY2xvc2VTZWFyY2hQYW5lbCh2aWV3KSxcbiAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiY2xvc2VcIiksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgICAgICAgICAgfSwgW1wiw5dcIl0pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGxldCBxdWVyeSA9IG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgICAgICBzZWFyY2g6IHRoaXMuc2VhcmNoRmllbGQudmFsdWUsXG4gICAgICAgICAgICBjYXNlU2Vuc2l0aXZlOiB0aGlzLmNhc2VGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVnZXhwOiB0aGlzLnJlRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHdob2xlV29yZDogdGhpcy53b3JkRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFxdWVyeS5lcSh0aGlzLnF1ZXJ5KSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGtleWRvd24oZSkge1xuICAgICAgICBpZiAocnVuU2NvcGVIYW5kbGVycyh0aGlzLnZpZXcsIGUsIFwic2VhcmNoLXBhbmVsXCIpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMuc2VhcmNoRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIChlLnNoaWZ0S2V5ID8gZmluZFByZXZpb3VzIDogZmluZE5leHQpKHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09IDEzICYmIGUudGFyZ2V0ID09IHRoaXMucmVwbGFjZUZpZWxkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXBsYWNlTmV4dCh0aGlzLnZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWFyY2hRdWVyeSkgJiYgIWVmZmVjdC52YWx1ZS5lcSh0aGlzLnF1ZXJ5KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRRdWVyeShlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzZXRRdWVyeShxdWVyeSkge1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQudmFsdWUgPSBxdWVyeS5zZWFyY2g7XG4gICAgICAgIHRoaXMucmVwbGFjZUZpZWxkLnZhbHVlID0gcXVlcnkucmVwbGFjZTtcbiAgICAgICAgdGhpcy5jYXNlRmllbGQuY2hlY2tlZCA9IHF1ZXJ5LmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMucmVGaWVsZC5jaGVja2VkID0gcXVlcnkucmVnZXhwO1xuICAgICAgICB0aGlzLndvcmRGaWVsZC5jaGVja2VkID0gcXVlcnkud2hvbGVXb3JkO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC5zZWxlY3QoKTtcbiAgICB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIDgwOyB9XG4gICAgZ2V0IHRvcCgpIHsgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCkudG9wOyB9XG59XG5mdW5jdGlvbiBwaHJhc2UodmlldywgcGhyYXNlKSB7IHJldHVybiB2aWV3LnN0YXRlLnBocmFzZShwaHJhc2UpOyB9XG5jb25zdCBBbm5vdW5jZU1hcmdpbiA9IDMwO1xuY29uc3QgQnJlYWsgPSAvW1xcc1xcLiw6Oz8hXS87XG5mdW5jdGlvbiBhbm5vdW5jZU1hdGNoKHZpZXcsIHsgZnJvbSwgdG8gfSkge1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCBsaW5lRW5kID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKS50bztcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIGZyb20gLSBBbm5vdW5jZU1hcmdpbiksIGVuZCA9IE1hdGgubWluKGxpbmVFbmQsIHRvICsgQW5ub3VuY2VNYXJnaW4pO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zdGF0ZS5zbGljZURvYyhzdGFydCwgZW5kKTtcbiAgICBpZiAoc3RhcnQgIT0gbGluZS5mcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQW5ub3VuY2VNYXJnaW47IGkrKylcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgKyAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kICE9IGxpbmVFbmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+IHRleHQubGVuZ3RoIC0gQW5ub3VuY2VNYXJnaW47IGktLSlcbiAgICAgICAgICAgIGlmICghQnJlYWsudGVzdCh0ZXh0W2kgLSAxXSkgJiYgQnJlYWsudGVzdCh0ZXh0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShcImN1cnJlbnQgbWF0Y2hcIil9LiAke3RleHR9ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJvbiBsaW5lXCIpfSAke2xpbmUubnVtYmVyfS5gKTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tcGFuZWwuY20tc2VhcmNoXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIycHggNnB4IDRweFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICBcIiYgW25hbWU9Y2xvc2VdXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IFwiMFwiLFxuICAgICAgICAgICAgcmlnaHQ6IFwiNHB4XCIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXQsICYgYnV0dG9uLCAmIGxhYmVsXCI6IHtcbiAgICAgICAgICAgIG1hcmdpbjogXCIuMmVtIC42ZW0gLjJlbSAwXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImIGlucHV0W3R5cGU9Y2hlY2tib3hdXCI6IHtcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBcIi4yZW1cIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgbGFiZWxcIjoge1xuICAgICAgICAgICAgZm9udFNpemU6IFwiODAlXCIsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiBcInByZVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWFyY2hNYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZmZjAwNTRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMwMGZmZmY4YVwiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZjZhMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMDBmZjhhXCIgfVxufSk7XG5jb25zdCBzZWFyY2hFeHRlbnNpb25zID0gW1xuICAgIHNlYXJjaFN0YXRlLFxuICAgIC8qQF9fUFVSRV9fKi9QcmVjLmxvdyhzZWFyY2hIaWdobGlnaHRlciksXG4gICAgYmFzZVRoZW1lXG5dO1xuXG5leHBvcnQgeyBSZWdFeHBDdXJzb3IsIFNlYXJjaEN1cnNvciwgU2VhcmNoUXVlcnksIGNsb3NlU2VhcmNoUGFuZWwsIGZpbmROZXh0LCBmaW5kUHJldmlvdXMsIGdldFNlYXJjaFF1ZXJ5LCBnb3RvTGluZSwgaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcywgb3BlblNlYXJjaFBhbmVsLCByZXBsYWNlQWxsLCByZXBsYWNlTmV4dCwgc2VhcmNoLCBzZWFyY2hLZXltYXAsIHNlYXJjaFBhbmVsT3Blbiwgc2VsZWN0TWF0Y2hlcywgc2VsZWN0TmV4dE9jY3VycmVuY2UsIHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMsIHNldFNlYXJjaFF1ZXJ5IH07XG4iXSwibmFtZXMiOlsic2hvd1BhbmVsIiwiRWRpdG9yVmlldyIsImdldFBhbmVsIiwiRGVjb3JhdGlvbiIsIlZpZXdQbHVnaW4iLCJydW5TY29wZUhhbmRsZXJzIiwiY29kZVBvaW50QXQiLCJmcm9tQ29kZVBvaW50IiwiY29kZVBvaW50U2l6ZSIsIlN0YXRlRWZmZWN0IiwiU3RhdGVGaWVsZCIsIkVkaXRvclNlbGVjdGlvbiIsIkZhY2V0IiwiY29tYmluZUNvbmZpZyIsIkNoYXJDYXRlZ29yeSIsIlJhbmdlU2V0QnVpbGRlciIsIlByZWMiLCJFZGl0b3JTdGF0ZSIsImZpbmRDbHVzdGVyQnJlYWsiLCJlbHQiLCJiYXNpY05vcm1hbGl6ZSIsIlN0cmluZyIsInByb3RvdHlwZSIsIm5vcm1hbGl6ZSIsIngiLCJTZWFyY2hDdXJzb3IiLCJjb25zdHJ1Y3RvciIsInRleHQiLCJxdWVyeSIsImZyb20iLCJ0byIsImxlbmd0aCIsInRlc3QiLCJ2YWx1ZSIsImRvbmUiLCJtYXRjaGVzIiwiYnVmZmVyIiwiYnVmZmVyUG9zIiwiaXRlciIsIml0ZXJSYW5nZSIsImJ1ZmZlclN0YXJ0IiwicGVlayIsIm5leHQiLCJwb3AiLCJuZXh0T3ZlcmxhcHBpbmciLCJzdHIiLCJzdGFydCIsIm5vcm0iLCJpIiwicG9zIiwiY29kZSIsImNoYXJDb2RlQXQiLCJtYXRjaCIsImVuZCIsImluZGV4Iiwia2VlcCIsInNwbGljZSIsInB1c2giLCJTeW1ib2wiLCJpdGVyYXRvciIsImVtcHR5IiwiZXhlYyIsImJhc2VGbGFncyIsInVuaWNvZGUiLCJSZWdFeHBDdXJzb3IiLCJvcHRpb25zIiwiY3VyTGluZSIsIk11bHRpbGluZVJlZ0V4cEN1cnNvciIsInJlIiwiUmVnRXhwIiwiaWdub3JlQ2FzZSIsInN0YXJ0TGluZSIsImxpbmVBdCIsImN1ckxpbmVTdGFydCIsIm1hdGNoUG9zIiwidG9DaGFyRW5kIiwiZ2V0TGluZSIsInNraXAiLCJsaW5lQnJlYWsiLCJzbGljZSIsIm5leHRMaW5lIiwib2ZmIiwibGFzdEluZGV4IiwiZmxhdHRlbmVkIiwiV2Vha01hcCIsIkZsYXR0ZW5lZERvYyIsImdldCIsImRvYyIsImNhY2hlZCIsImZsYXQiLCJzbGljZVN0cmluZyIsInNldCIsImNhY2hlZEZyb20iLCJjaHVua0VuZCIsInZhbGlkUmVnRXhwIiwic291cmNlIiwiX2EiLCJsaW5lIiwiY3JlYXRlTGluZURpYWxvZyIsInZpZXciLCJzdGF0ZSIsInNlbGVjdGlvbiIsIm1haW4iLCJoZWFkIiwibnVtYmVyIiwiaW5wdXQiLCJjbGFzcyIsIm5hbWUiLCJkb20iLCJvbmtleWRvd24iLCJldmVudCIsImtleUNvZGUiLCJwcmV2ZW50RGVmYXVsdCIsImRpc3BhdGNoIiwiZWZmZWN0cyIsImRpYWxvZ0VmZmVjdCIsIm9mIiwiZm9jdXMiLCJnbyIsIm9uc3VibWl0IiwicGhyYXNlIiwidHlwZSIsInNpZ24iLCJsbiIsImNsIiwicGVyY2VudCIsImNvbCIsInBjIiwibGluZXMiLCJNYXRoIiwicm91bmQiLCJkb2NMaW5lIiwibWF4IiwibWluIiwiY3Vyc29yIiwic2Nyb2xsSW50b1ZpZXciLCJ5IiwiZGVmaW5lIiwiZGlhbG9nRmllbGQiLCJjcmVhdGUiLCJ1cGRhdGUiLCJ0ciIsImUiLCJpcyIsInByb3ZpZGUiLCJmIiwidmFsIiwiZ290b0xpbmUiLCJwYW5lbCIsImZpZWxkIiwiYXBwZW5kQ29uZmlnIiwiYmFzZVRoZW1lJDEiLCJxdWVyeVNlbGVjdG9yIiwic2VsZWN0IiwiYmFzZVRoZW1lIiwicGFkZGluZyIsImZvbnRTaXplIiwiZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMiLCJoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yIiwibWluU2VsZWN0aW9uTGVuZ3RoIiwibWF4TWF0Y2hlcyIsIndob2xlV29yZHMiLCJoaWdobGlnaHRDb25maWciLCJjb21iaW5lIiwiYSIsImIiLCJoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzIiwiZXh0IiwiZGVmYXVsdFRoZW1lIiwibWF0Y2hIaWdobGlnaHRlciIsIm1hdGNoRGVjbyIsIm1hcmsiLCJtYWluTWF0Y2hEZWNvIiwiaW5zaWRlV29yZEJvdW5kYXJpZXMiLCJjaGVjayIsInNsaWNlRG9jIiwiV29yZCIsImluc2lkZVdvcmQiLCJmcm9tQ2xhc3MiLCJkZWNvcmF0aW9ucyIsImdldERlY28iLCJzZWxlY3Rpb25TZXQiLCJkb2NDaGFuZ2VkIiwidmlld3BvcnRDaGFuZ2VkIiwiY29uZiIsImZhY2V0Iiwic2VsIiwicmFuZ2VzIiwibm9uZSIsInJhbmdlIiwid29yZCIsIndvcmRBdCIsImNoYXJDYXRlZ29yaXplciIsImxlbiIsImRlY28iLCJwYXJ0IiwidmlzaWJsZVJhbmdlcyIsInYiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzZWxlY3RXb3JkIiwibmV3U2VsIiwibWFwIiwibWFpbkluZGV4IiwiZXEiLCJmaW5kTmV4dE9jY3VycmVuY2UiLCJmdWxsV29yZCIsImN5Y2xlZCIsInNvbWUiLCJyIiwic2VsZWN0TmV4dE9jY3VycmVuY2UiLCJzZWFyY2hlZFRleHQiLCJhZGRSYW5nZSIsInNlYXJjaENvbmZpZ0ZhY2V0IiwiY29uZmlncyIsInRvcCIsImNhc2VTZW5zaXRpdmUiLCJsaXRlcmFsIiwicmVnZXhwIiwid2hvbGVXb3JkIiwiY3JlYXRlUGFuZWwiLCJTZWFyY2hQYW5lbCIsInNjcm9sbFRvTWF0Y2giLCJzZWFyY2giLCJjb25maWciLCJzZWFyY2hFeHRlbnNpb25zIiwiU2VhcmNoUXVlcnkiLCJyZXBsYWNlIiwidmFsaWQiLCJ1bnF1b3RlZCIsInVucXVvdGUiLCJfIiwiY2giLCJvdGhlciIsIlJlZ0V4cFF1ZXJ5IiwiU3RyaW5nUXVlcnkiLCJnZXRDdXJzb3IiLCJzdCIsInJlZ2V4cEN1cnNvciIsInN0cmluZ0N1cnNvciIsIlF1ZXJ5VHlwZSIsInNwZWMiLCJ1bmRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsInN0cmluZ1dvcmRUZXN0IiwiY2F0ZWdvcml6ZXIiLCJidWYiLCJidWZQb3MiLCJjaGFyQmVmb3JlIiwiY2hhckFmdGVyIiwibmV4dE1hdGNoIiwiY3VyRnJvbSIsImN1clRvIiwicHJldk1hdGNoSW5SYW5nZSIsInByZXZNYXRjaCIsImdldFJlcGxhY2VtZW50IiwiX3Jlc3VsdCIsIm1hdGNoQWxsIiwibGltaXQiLCJoaWdobGlnaHQiLCJhZGQiLCJyZWdleHBXb3JkVGVzdCIsIl9mcm9tIiwiX3RvIiwic2l6ZSIsInJlc3VsdCIsIm0iLCJzZXRTZWFyY2hRdWVyeSIsInRvZ2dsZVBhbmVsIiwic2VhcmNoU3RhdGUiLCJTZWFyY2hTdGF0ZSIsImRlZmF1bHRRdWVyeSIsImVmZmVjdCIsImNyZWF0ZVNlYXJjaFBhbmVsIiwiZ2V0U2VhcmNoUXVlcnkiLCJjdXJTdGF0ZSIsInNlYXJjaFBhbmVsT3BlbiIsIm1hdGNoTWFyayIsInNlbGVjdGVkTWF0Y2hNYXJrIiwic2VhcmNoSGlnaGxpZ2h0ZXIiLCJzdGFydFN0YXRlIiwiYnVpbGRlciIsImwiLCJzZWxlY3RlZCIsImZpbmlzaCIsInNlYXJjaENvbW1hbmQiLCJvcGVuU2VhcmNoUGFuZWwiLCJmaW5kTmV4dCIsInNpbmdsZSIsImFubm91bmNlTWF0Y2giLCJ1c2VyRXZlbnQiLCJzZWxlY3RTZWFyY2hJbnB1dCIsImZpbmRQcmV2aW91cyIsInByZXYiLCJzZWxlY3RNYXRjaGVzIiwic2VsZWN0U2VsZWN0aW9uTWF0Y2hlcyIsImN1ciIsInJlcGxhY2VOZXh0IiwicmVhZE9ubHkiLCJjaGFuZ2VzIiwicmVwbGFjZW1lbnQiLCJ0b1RleHQiLCJpbnNlcnQiLCJhbm5vdW5jZSIsInJlcGxhY2VBbGwiLCJhbm5vdW5jZVRleHQiLCJmYWxsYmFjayIsIl9iIiwiX2MiLCJfZCIsIl9lIiwic2VsVGV4dCIsImdldFNlYXJjaElucHV0Iiwicm9vdCIsImFjdGl2ZUVsZW1lbnQiLCJzZWFyY2hJbnB1dCIsImNsb3NlU2VhcmNoUGFuZWwiLCJjb250YWlucyIsInNlYXJjaEtleW1hcCIsImtleSIsInJ1biIsInNjb3BlIiwic2hpZnQiLCJjb21taXQiLCJiaW5kIiwic2VhcmNoRmllbGQiLCJwbGFjZWhvbGRlciIsImZvcm0iLCJvbmNoYW5nZSIsIm9ua2V5dXAiLCJyZXBsYWNlRmllbGQiLCJjYXNlRmllbGQiLCJjaGVja2VkIiwicmVGaWVsZCIsIndvcmRGaWVsZCIsImJ1dHRvbiIsIm9uY2xpY2siLCJjb250ZW50Iiwia2V5ZG93biIsInRhcmdldCIsInNoaWZ0S2V5IiwidHJhbnNhY3Rpb25zIiwic2V0UXVlcnkiLCJtb3VudCIsIkFubm91bmNlTWFyZ2luIiwiQnJlYWsiLCJsaW5lRW5kIiwicG9zaXRpb24iLCJyaWdodCIsImJvcmRlciIsImZvbnQiLCJtYXJnaW4iLCJtYXJnaW5SaWdodCIsIndoaXRlU3BhY2UiLCJsb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/search/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ChangeDesc: () => (/* binding */ ChangeDesc),\n/* harmony export */   ChangeSet: () => (/* binding */ ChangeSet),\n/* harmony export */   CharCategory: () => (/* binding */ CharCategory),\n/* harmony export */   Compartment: () => (/* binding */ Compartment),\n/* harmony export */   EditorSelection: () => (/* binding */ EditorSelection),\n/* harmony export */   EditorState: () => (/* binding */ EditorState),\n/* harmony export */   Facet: () => (/* binding */ Facet),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   MapMode: () => (/* binding */ MapMode),\n/* harmony export */   Prec: () => (/* binding */ Prec),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   RangeSetBuilder: () => (/* binding */ RangeSetBuilder),\n/* harmony export */   RangeValue: () => (/* binding */ RangeValue),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   StateEffect: () => (/* binding */ StateEffect),\n/* harmony export */   StateEffectType: () => (/* binding */ StateEffectType),\n/* harmony export */   StateField: () => (/* binding */ StateField),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   codePointAt: () => (/* binding */ codePointAt),\n/* harmony export */   codePointSize: () => (/* binding */ codePointSize),\n/* harmony export */   combineConfig: () => (/* binding */ combineConfig),\n/* harmony export */   countColumn: () => (/* binding */ countColumn),\n/* harmony export */   findClusterBreak: () => (/* binding */ findClusterBreak),\n/* harmony export */   findColumn: () => (/* binding */ findColumn),\n/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint)\n/* harmony export */ });\n/**\nThe data structure for documents. @nonabstract\n*/ class Text {\n    /**\n    Get the line description around the given position.\n    */ lineAt(pos) {\n        if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /**\n    Get the description for the given (1-based) line number.\n    */ line(n) {\n        if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /**\n    Replace a range of the text with the given content.\n    */ replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* Open.To */ );\n        if (text.length) text.decompose(0, text.length, parts, 1 /* Open.From */  | 2 /* Open.To */ );\n        this.decompose(to, this.length, parts, 1 /* Open.From */ );\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /**\n    Append another document to this one.\n    */ append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /**\n    Retrieve the text between the given points.\n    */ slice(from, to = this.length) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /**\n    Test whether this text is equal to another instance.\n    */ eq(other) {\n        if (other == this) return true;\n        if (other.length != this.length || other.lines != this.lines) return false;\n        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for(let skip = start, pos = start;;){\n            a.next(skip);\n            b.next(skip);\n            skip = 0;\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n            pos += a.value.length;\n            if (a.done || pos >= end) return true;\n        }\n    }\n    /**\n    Iterate over the text. When `dir` is `-1`, iteration happens\n    from end to start. This will return lines and the breaks between\n    them as separate strings.\n    */ iter(dir = 1) {\n        return new RawTextCursor(this, dir);\n    }\n    /**\n    Iterate over a range of the text. When `from` > `to`, the\n    iterator will run in reverse.\n    */ iterRange(from, to = this.length) {\n        return new PartialTextCursor(this, from, to);\n    }\n    /**\n    Return a cursor that iterates over the given range of lines,\n    _without_ returning the line breaks between, and yielding empty\n    strings for empty lines.\n    \n    When `from` and `to` are given, they should be 1-based line numbers.\n    */ iterLines(from, to) {\n        let inner;\n        if (from == null) {\n            inner = this.iter();\n        } else {\n            if (to == null) to = this.lines + 1;\n            let start = this.line(from).from;\n            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n        }\n        return new LineCursor(inner);\n    }\n    /**\n    Return the document as a string, using newline characters to\n    separate lines.\n    */ toString() {\n        return this.sliceString(0);\n    }\n    /**\n    Convert the document to an array of lines (which can be\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n    */ toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /**\n    @internal\n    */ constructor(){}\n    /**\n    Create a `Text` instance for the given array of lines.\n    */ static of(text) {\n        if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0]) return Text.empty;\n        return text.length <= 32 /* Tree.Branch */  ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)){\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() {\n        return this.text.length;\n    }\n    get children() {\n        return null;\n    }\n    lineInner(target, isLine, line, offset) {\n        for(let i = 0;; i++){\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* Open.From */ ) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Tree.Branch */ ) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            } else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        } else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf)) return super.replace(from, to, text);\n        [from, to] = clip(this, from, to);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Tree.Branch */ ) return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for(let pos = 0, i = 0; pos <= to && i < this.text.length; i++){\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i) result += lineSep;\n            if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)target.push(line);\n    }\n    scanIdentical() {\n        return 0;\n    }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text){\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Tree.Branch */ ) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1) target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length){\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for(let i = 0;; i++){\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for(let i = 0, pos = 0; pos <= to && i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* Open.From */  : 0) | (end >= to ? 2 /* Open.To */  : 0));\n                if (pos >= from && end <= to && !childOpen) target.push(child);\n                else child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        if (text.lines < this.lines) for(let i = 0, pos = 0; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            // Fast path: if the change only affects one child and the\n            // child's size remains in the acceptable range, only update\n            // that child\n            if (from >= pos && to <= end) {\n                let updated = child.replace(from - pos, to - pos, text);\n                let totalLines = this.lines - child.lines + updated.lines;\n                if (updated.lines < totalLines >> 5 /* Tree.BranchShift */  - 1 && updated.lines > totalLines >> 5 /* Tree.BranchShift */  + 1) {\n                    let copy = this.children.slice();\n                    copy[i] = updated;\n                    return new TextNode(copy, this.length - (to - from) + text.length);\n                }\n                return super.replace(pos, end, updated);\n            }\n            pos = end + 1;\n        }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for(let i = 0, pos = 0; i < this.children.length && pos <= to; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i) result += lineSep;\n            if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)child.flatten(target);\n    }\n    scanIdentical(other, dir) {\n        if (!(other instanceof TextNode)) return 0;\n        let length = 0;\n        let [iA, iB, eA, eB] = dir > 0 ? [\n            0,\n            0,\n            this.children.length,\n            other.children.length\n        ] : [\n            this.children.length - 1,\n            other.children.length - 1,\n            -1,\n            -1\n        ];\n        for(;; iA += dir, iB += dir){\n            if (iA == eA || iB == eB) return length;\n            let chA = this.children[iA], chB = other.children[iB];\n            if (chA != chB) return length + chA.scanIdentical(chB, dir);\n            length += chA.length + 1;\n        }\n    }\n    static from(children, length = children.reduce((l, ch)=>l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)lines += ch.lines;\n        if (lines < 32 /* Tree.Branch */ ) {\n            let flat = [];\n            for (let ch of children)ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Tree.Branch */ , lines >> 5 /* Tree.BranchShift */ ), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)add(node);\n            } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32 /* Tree.Branch */ ) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            } else {\n                if (currentLines + child.lines > chunk) flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0) return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = /*@__PURE__*/ new TextLeaf([\n    \"\"\n], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for(let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++){\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to) line = line.slice(0, to - pos);\n            if (pos < from) line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            } else target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\n        \"\"\n    ], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1){\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [\n            text\n        ];\n        this.offsets = [\n            dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1\n        ];\n    }\n    nextInner(skip, dir) {\n        this.done = this.lineBreak = false;\n        for(;;){\n            let last = this.nodes.length - 1;\n            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (dir > 0 ? size : 0)) {\n                if (last == 0) {\n                    this.done = true;\n                    this.value = \"\";\n                    return this;\n                }\n                if (dir > 0) this.offsets[last - 1]++;\n                this.nodes.pop();\n                this.offsets.pop();\n            } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n                this.offsets[last] += dir;\n                if (skip == 0) {\n                    this.lineBreak = true;\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            } else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset + (dir < 0 ? -1 : 0)];\n                this.offsets[last] += dir;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            } else {\n                let next = top.children[offset + (dir < 0 ? -1 : 0)];\n                if (skip > next.length) {\n                    skip -= next.length;\n                    this.offsets[last] += dir;\n                } else {\n                    if (dir < 0) this.offsets[last]--;\n                    this.nodes.push(next);\n                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n                }\n            }\n        }\n    }\n    next(skip = 0) {\n        if (skip < 0) {\n            this.nextInner(-skip, -this.dir);\n            skip = this.value.length;\n        }\n        return this.nextInner(skip, this.dir);\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end){\n        this.value = \"\";\n        this.done = false;\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        this.pos = start > end ? text.length : 0;\n        this.from = Math.min(start, end);\n        this.to = Math.max(start, end);\n    }\n    nextInner(skip, dir) {\n        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n            this.value = \"\";\n            this.done = true;\n            return this;\n        }\n        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n        if (skip > limit) skip = limit;\n        limit -= skip;\n        let { value } = this.cursor.next(skip);\n        this.pos += (value.length + skip) * dir;\n        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n        this.done = !this.value;\n        return this;\n    }\n    next(skip = 0) {\n        if (skip < 0) skip = Math.max(skip, this.from - this.pos);\n        else if (skip > 0) skip = Math.min(skip, this.to - this.pos);\n        return this.nextInner(skip, this.cursor.dir);\n    }\n    get lineBreak() {\n        return this.cursor.lineBreak && this.value != \"\";\n    }\n}\nclass LineCursor {\n    constructor(inner){\n        this.inner = inner;\n        this.afterBreak = true;\n        this.value = \"\";\n        this.done = false;\n    }\n    next(skip = 0) {\n        let { done, lineBreak, value } = this.inner.next(skip);\n        if (done && this.afterBreak) {\n            this.value = \"\";\n            this.afterBreak = false;\n        } else if (done) {\n            this.done = true;\n            this.value = \"\";\n        } else if (lineBreak) {\n            if (this.afterBreak) {\n                this.value = \"\";\n            } else {\n                this.afterBreak = true;\n                this.next();\n            }\n        } else {\n            this.value = value;\n            this.afterBreak = false;\n        }\n        return this;\n    }\n    get lineBreak() {\n        return false;\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    Text.prototype[Symbol.iterator] = function() {\n        return this.iter();\n    };\n    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\n*/ class Line {\n    /**\n    @internal\n    */ constructor(/**\n    The position of the start of the line.\n    */ from, /**\n    The position at the end of the line (_before_ the line break,\n    or at the end of document for the last line).\n    */ to, /**\n    This line's line number (1-based).\n    */ number, /**\n    The line's content.\n    */ text){\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /**\n    The length of the line (not including any line break after it).\n    */ get length() {\n        return this.to - this.from;\n    }\n}\nfunction clip(text, from, to) {\n    from = Math.max(0, Math.min(text.length, from));\n    return [\n        from,\n        Math.max(from, Math.min(text.length, to))\n    ];\n}\n// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = /*@__PURE__*/ \"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map((s)=>s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor(let i = 1; i < extend.length; i++)extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n    for(let i = 1; i < extend.length; i += 2)if (extend[i] > code) return extend[i - 1] <= code;\n    return false;\n}\nfunction isRegionalIndicator(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/ function findClusterBreak(str, pos, forward = true, includeExtending = true) {\n    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);\n}\nfunction nextClusterBreak(str, pos, includeExtending) {\n    if (pos == str.length) return pos;\n    // If pos is in the middle of a surrogate pair, move to its start\n    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;\n    let prev = codePointAt(str, pos);\n    pos += codePointSize(prev);\n    while(pos < str.length){\n        let next = codePointAt(str, pos);\n        if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {\n            pos += codePointSize(next);\n            prev = next;\n        } else if (isRegionalIndicator(next)) {\n            let countBefore = 0, i = pos - 2;\n            while(i >= 0 && isRegionalIndicator(codePointAt(str, i))){\n                countBefore++;\n                i -= 2;\n            }\n            if (countBefore % 2 == 0) break;\n            else pos += 2;\n        } else {\n            break;\n        }\n    }\n    return pos;\n}\nfunction prevClusterBreak(str, pos, includeExtending) {\n    while(pos > 0){\n        let found = nextClusterBreak(str, pos - 2, includeExtending);\n        if (found < pos) return found;\n        pos--;\n    }\n    return 0;\n}\nfunction surrogateLow(ch) {\n    return ch >= 0xDC00 && ch < 0xE000;\n}\nfunction surrogateHigh(ch) {\n    return ch >= 0xD800 && ch < 0xDC00;\n}\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/ function codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1)) return code0;\n    return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/ function fromCodePoint(code) {\n    if (code <= 0xffff) return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe amount of positions a character takes up a JavaScript string.\n*/ function codePointSize(code) {\n    return code < 0x10000 ? 1 : 2;\n}\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/ var MapMode = /*@__PURE__*/ function(MapMode) {\n    /**\n    Map a position to a valid new position, even when its context\n    was deleted.\n    */ MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /**\n    Return null if deletion happens across the position.\n    */ MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /**\n    Return null if the character _before_ the position is deleted.\n    */ MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /**\n    Return null if the character _after_ the position is deleted.\n    */ MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n    return MapMode;\n}(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/ class ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ sections){\n        this.sections = sections;\n    }\n    /**\n    The length of the document before the change.\n    */ get length() {\n        let result = 0;\n        for(let i = 0; i < this.sections.length; i += 2)result += this.sections[i];\n        return result;\n    }\n    /**\n    The length of the document after the change.\n    */ get newLength() {\n        let result = 0;\n        for(let i = 0; i < this.sections.length; i += 2){\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /**\n    False when there are actual changes in this set.\n    */ get empty() {\n        return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;\n    }\n    /**\n    Iterate over the unchanged parts left by these changes. `posA`\n    provides the position of the range in the old document, `posB`\n    the new position in the changed document.\n    */ iterGaps(f) {\n        for(let i = 0, posA = 0, posB = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            } else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /**\n    Iterate over the ranges changed by these changes. (See\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n    variant that also provides you with the inserted text.)\n    `fromA`/`toA` provides the extent of the change in the starting\n    document, `fromB`/`toB` the extent of the replacement in the\n    changed document.\n    \n    When `individual` is true, adjacent changes (which are kept\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n    reported separately.\n    */ iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a description of the inverted form of these changes.\n    */ get invertedDesc() {\n        let sections = [];\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) sections.push(len, ins);\n            else sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /**\n    Compute the combined effect of applying another set of changes\n    after this one. The length of the document after this set should\n    match the length before `other`.\n    */ composeDesc(other) {\n        return this.empty ? other : other.empty ? this : composeSets(this, other);\n    }\n    /**\n    Map this description, which should start with the same document\n    as `other`, over another set of changes, so that it can be\n    applied after it. When `before` is true, map as if the changes\n    in `other` happened before the ones in `this`.\n    */ mapDesc(other, before = false) {\n        return other.empty ? this : mapSet(this, other, before);\n    }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos) return posB + (pos - posA);\n                posB += len;\n            } else {\n                if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /**\n    Check whether these changes touch a given range. When one of the\n    changes entirely covers the range, the string `\"cover\"` is\n    returned.\n    */ touchesRange(from, to = from) {\n        for(let i = 0, pos = 0; i < this.sections.length && pos <= to;){\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = \"\";\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n    /**\n    Serialize this change desc to a JSON-representable value.\n    */ toJSON() {\n        return this.sections;\n    }\n    /**\n    Create a change desc from its JSON representation (as produced\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n    */ static fromJSON(json) {\n        if (!Array.isArray(json) || json.length % 2 || json.some((a)=>typeof a != \"number\")) throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n        return new ChangeDesc(json);\n    }\n    /**\n    @internal\n    */ static create(sections) {\n        return new ChangeDesc(sections);\n    }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/ class ChangeSet extends ChangeDesc {\n    constructor(sections, /**\n    @internal\n    */ inserted){\n        super(sections);\n        this.inserted = inserted;\n    }\n    /**\n    Apply the changes to a document, returning the modified\n    document.\n    */ apply(doc) {\n        if (this.length != doc.length) throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text)=>doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    mapDesc(other, before = false) {\n        return mapSet(this, other, before, true);\n    }\n    /**\n    Given the document as it existed _before_ the changes, return a\n    change set that represents the inverse of this set, which could\n    be used to go from the document created by the changes back to\n    the document as it existed before the changes.\n    */ invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for(let i = 0, pos = 0; i < sections.length; i += 2){\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while(inserted.length < index)inserted.push(Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    Combine two subsequent change sets into a single set. `other`\n    must start in the document produced by `this`. If `this` goes\n    `docA` → `docB` and `other` represents `docB` → `docC`, the\n    returned value will represent the change `docA` → `docC`.\n    */ compose(other) {\n        return this.empty ? other : other.empty ? this : composeSets(this, other, true);\n    }\n    /**\n    Given another change set starting in the same document, maps this\n    change set over the other, producing a new change set that can be\n    applied to the document produced by applying `other`. When\n    `before` is `true`, order changes as if `this` comes before\n    `other`, otherwise (the default) treat `other` as coming first.\n    \n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    `B.compose(A.map(B, true))` will produce the same document. This\n    provides a basic form of [operational\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    and can be used for collaborative editing.\n    */ map(other, before = false) {\n        return other.empty ? this : mapSet(this, other, before, true);\n    }\n    /**\n    Iterate over the changed ranges in the document, calling `f` for\n    each, with the range in the original document (`fromA`-`toA`)\n    and the range that replaces it in the new document\n    (`fromB`-`toB`).\n    \n    When `individual` is true, adjacent changes are reported\n    separately.\n    */ iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n    set.\n    */ get desc() {\n        return ChangeDesc.create(this.sections);\n    }\n    /**\n    @internal\n    */ filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for(let i = 0, pos = 0;;){\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while(pos < next || pos == next && iter.len == 0){\n                if (iter.done) break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0) addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while(pos < end){\n                if (iter.done) break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return {\n            changes: new ChangeSet(resultSections, resultInserted),\n            filtered: ChangeDesc.create(filteredSections)\n        };\n    }\n    /**\n    Serialize this change set to a JSON-representable value.\n    */ toJSON() {\n        let parts = [];\n        for(let i = 0; i < this.sections.length; i += 2){\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0) parts.push(len);\n            else if (ins == 0) parts.push([\n                len\n            ]);\n            else parts.push([\n                len\n            ].concat(this.inserted[i >> 1].toJSON()));\n        }\n        return parts;\n    }\n    /**\n    Create a change set for the given changes, for a document of the\n    given length, using `lineSep` as line separator.\n    */ static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length) return;\n            if (pos < length) addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)process(sub);\n            } else if (spec instanceof ChangeSet) {\n                if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            } else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0) return;\n                if (from < pos) flush();\n                if (from > pos) addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /**\n    Create an empty changeset of the given length.\n    */ static empty(length) {\n        return new ChangeSet(length ? [\n            length,\n            -1\n        ] : [], []);\n    }\n    /**\n    Create a changeset from its JSON representation (as produced by\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n    */ static fromJSON(json) {\n        if (!Array.isArray(json)) throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        let sections = [], inserted = [];\n        for(let i = 0; i < json.length; i++){\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            } else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i)=>i && typeof e != \"string\")) {\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n            } else if (part.length == 1) {\n                sections.push(part[0], 0);\n            } else {\n                while(inserted.length < i)inserted.push(Text.empty);\n                inserted[i] = Text.of(part.slice(1));\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    @internal\n    */ static createSet(sections, inserted) {\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0) return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;\n    else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    } else sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0) return;\n    let index = sections.length - 2 >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    } else {\n        while(values.length < index)values.push(Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for(let posA = 0, posB = 0, i = 0; i < desc.sections.length;){\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        } else {\n            let endA = posA, endB = posB, text = Text.empty;\n            for(;;){\n                endA += len;\n                endB += ins;\n                if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    // Produce a copy of setA that applies to the document after setB\n    // has been applied (assuming both start at the same document).\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    // Iterate over both sets in parallel. inserted tracks, for changes\n    // in A that have to be processed piece-by-piece, whether their\n    // content has been inserted already, and refers to the section\n    // index.\n    for(let inserted = -1;;){\n        if (a.ins == -1 && b.ins == -1) {\n            // Move across ranges skipped by both sets.\n            let len = Math.min(a.len, b.len);\n            addSection(sections, len, -1);\n            a.forward(len);\n            b.forward(len);\n        } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\n            // If there's a change in B that comes before the next change in\n            // A (ordered by start pos, then len, then before flag), skip\n            // that (and process any changes in A it covers).\n            let len = b.len;\n            addSection(sections, b.ins, -1);\n            while(len){\n                let piece = Math.min(a.len, len);\n                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\n                    addSection(sections, 0, a.ins);\n                    if (insert) addInsert(insert, sections, a.text);\n                    inserted = a.i;\n                }\n                a.forward(piece);\n                len -= piece;\n            }\n            b.next();\n        } else if (a.ins >= 0) {\n            // Process the part of a change in A up to the start of the next\n            // non-deletion change in B (if overlapping).\n            let len = 0, left = a.len;\n            while(left){\n                if (b.ins == -1) {\n                    let piece = Math.min(left, b.len);\n                    len += piece;\n                    left -= piece;\n                    b.forward(piece);\n                } else if (b.ins == 0 && b.len < left) {\n                    left -= b.len;\n                    b.next();\n                } else {\n                    break;\n                }\n            }\n            addSection(sections, len, inserted < a.i ? a.ins : 0);\n            if (insert && inserted < a.i) addInsert(insert, sections, a.text);\n            inserted = a.i;\n            a.forward(a.len - left);\n        } else if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        } else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for(let open = false;;){\n        if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        } else if (a.ins == 0) {\n            addSection(sections, a.len, 0, open);\n            a.next();\n        } else if (b.len == 0 && !b.done) {\n            addSection(sections, 0, b.ins, open);\n            if (insert) addInsert(insert, sections, b.text);\n            b.next();\n        } else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        } else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB) addInsert(insert, sections, b.text);\n            } else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert) addInsert(insert, sections, a.textBit(len));\n            } else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off) addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set){\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        } else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() {\n        return this.ins == -2;\n    }\n    get len2() {\n        return this.ins < 0 ? this.len : this.ins;\n    }\n    get text() {\n        let { inserted } = this.set, index = this.i - 2 >> 1;\n        return index >= inserted.length ? Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = this.i - 2 >> 1;\n        return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len) this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1) this.forward(len);\n        else if (len == this.ins) this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/ class SelectionRange {\n    constructor(/**\n    The lower boundary of the range.\n    */ from, /**\n    The upper boundary of the range.\n    */ to, flags){\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /**\n    The anchor of the range—the side that doesn't move when you\n    extend it.\n    */ get anchor() {\n        return this.flags & 32 /* RangeFlag.Inverted */  ? this.to : this.from;\n    }\n    /**\n    The head of the range, which is moved when the range is\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n    */ get head() {\n        return this.flags & 32 /* RangeFlag.Inverted */  ? this.from : this.to;\n    }\n    /**\n    True when `anchor` and `head` are at the same position.\n    */ get empty() {\n        return this.from == this.to;\n    }\n    /**\n    If this is a cursor that is explicitly associated with the\n    character on one of its sides, this returns the side. -1 means\n    the character before its position, 1 the character after, and 0\n    means no association.\n    */ get assoc() {\n        return this.flags & 8 /* RangeFlag.AssocBefore */  ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */  ? 1 : 0;\n    }\n    /**\n    The bidirectional text level associated with this cursor, if\n    any.\n    */ get bidiLevel() {\n        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */ ;\n        return level == 7 ? null : level;\n    }\n    /**\n    The goal column (stored vertical offset) associated with a\n    cursor. This is used to preserve the vertical position when\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n    lines of different length.\n    */ get goalColumn() {\n        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */ ;\n        return value == 16777215 /* RangeFlag.NoGoalColumn */  ? undefined : value;\n    }\n    /**\n    Map this range through a change, producing a valid range in the\n    updated document.\n    */ map(change, assoc = -1) {\n        let from, to;\n        if (this.empty) {\n            from = to = change.mapPos(this.from, assoc);\n        } else {\n            from = change.mapPos(this.from, 1);\n            to = change.mapPos(this.to, -1);\n        }\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /**\n    Extend this range to cover at least `from` to `to`.\n    */ extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /**\n    Compare this range to another range.\n    */ eq(other, includeAssoc = false) {\n        return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);\n    }\n    /**\n    Return a JSON-serializable object representing the range.\n    */ toJSON() {\n        return {\n            anchor: this.anchor,\n            head: this.head\n        };\n    }\n    /**\n    Convert a JSON representation of a range to a `SelectionRange`\n    instance.\n    */ static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n    /**\n    @internal\n    */ static create(from, to, flags) {\n        return new SelectionRange(from, to, flags);\n    }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/ class EditorSelection {\n    constructor(/**\n    The ranges in the selection, sorted by position. Ranges cannot\n    overlap (but they may touch, if they aren't empty).\n    */ ranges, /**\n    The index of the _main_ range in the selection (which is\n    usually the range that was added last).\n    */ mainIndex){\n        this.ranges = ranges;\n        this.mainIndex = mainIndex;\n    }\n    /**\n    Map a selection through a change. Used to adjust the selection\n    position for changes.\n    */ map(change, assoc = -1) {\n        if (change.empty) return this;\n        return EditorSelection.create(this.ranges.map((r)=>r.map(change, assoc)), this.mainIndex);\n    }\n    /**\n    Compare this selection to another selection. By default, ranges\n    are compared only by position. When `includeAssoc` is true,\n    cursor ranges must also have the same\n    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.\n    */ eq(other, includeAssoc = false) {\n        if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;\n        for(let i = 0; i < this.ranges.length; i++)if (!this.ranges[i].eq(other.ranges[i], includeAssoc)) return false;\n        return true;\n    }\n    /**\n    Get the primary selection range. Usually, you should make sure\n    your code applies to _all_ ranges, by using methods like\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n    */ get main() {\n        return this.ranges[this.mainIndex];\n    }\n    /**\n    Make sure the selection only has one range. Returns a selection\n    holding only the main range from this selection.\n    */ asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([\n            this.main\n        ], 0);\n    }\n    /**\n    Extend this selection with an extra range.\n    */ addRange(range, main = true) {\n        return EditorSelection.create([\n            range\n        ].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /**\n    Replace a given range with another range, and then normalize the\n    selection to merge and sort ranges if necessary.\n    */ replaceRange(range, which = this.mainIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /**\n    Convert this selection to an object that can be serialized to\n    JSON.\n    */ toJSON() {\n        return {\n            ranges: this.ranges.map((r)=>r.toJSON()),\n            main: this.mainIndex\n        };\n    }\n    /**\n    Create a selection from a JSON representation.\n    */ static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length) throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r)=>SelectionRange.fromJSON(r)), json.main);\n    }\n    /**\n    Create a selection holding a single range.\n    */ static single(anchor, head = anchor) {\n        return new EditorSelection([\n            EditorSelection.range(anchor, head)\n        ], 0);\n    }\n    /**\n    Sort and merge the given set of ranges, creating a valid\n    selection.\n    */ static create(ranges, mainIndex = 0) {\n        if (ranges.length == 0) throw new RangeError(\"A selection needs at least one range\");\n        for(let pos = 0, i = 0; i < ranges.length; i++){\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n    /**\n    Create a cursor selection range at the given position. You can\n    safely ignore the optional arguments in most situations.\n    */ static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */  : 16 /* RangeFlag.AssocAfter */ ) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */ ) << 6 /* RangeFlag.GoalColumnOffset */ );\n    }\n    /**\n    Create a selection range.\n    */ static range(anchor, head, goalColumn, bidiLevel) {\n        let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */ ) << 6 /* RangeFlag.GoalColumnOffset */  | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));\n        return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */  | 16 /* RangeFlag.AssocAfter */  | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */  : 0) | flags);\n    }\n    /**\n    @internal\n    */ static normalized(ranges, mainIndex = 0) {\n        let main = ranges[mainIndex];\n        ranges.sort((a, b)=>a.from - b.from);\n        mainIndex = ranges.indexOf(main);\n        for(let i = 1; i < ranges.length; i++){\n            let range = ranges[i], prev = ranges[i - 1];\n            if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n                let from = prev.from, to = Math.max(range.to, prev.to);\n                if (i <= mainIndex) mainIndex--;\n                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n            }\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)if (range.to > docLength) throw new RangeError(\"Selection points outside of document\");\n}\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of uses of facets are the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\n\nNote that `Facet` instances can be used anywhere where\n[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.\n*/ class Facet {\n    constructor(/**\n    @internal\n    */ combine, /**\n    @internal\n    */ compareInput, /**\n    @internal\n    */ compare, isStatic, enables){\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /**\n        @internal\n        */ this.id = nextID++;\n        this.default = combine([]);\n        this.extensions = typeof enables == \"function\" ? enables(this) : enables;\n    }\n    /**\n    Returns a facet reader for this facet, which can be used to\n    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.\n    */ get reader() {\n        return this;\n    }\n    /**\n    Define a new facet.\n    */ static define(config = {}) {\n        return new Facet(config.combine || ((a)=>a), config.compareInput || ((a, b)=>a === b), config.compare || (!config.combine ? sameArray : (a, b)=>a === b), !!config.static, config.enables);\n    }\n    /**\n    Returns an extension that adds the given value to this facet.\n    */ of(value) {\n        return new FacetProvider([], this, 0 /* Provider.Static */ , value);\n    }\n    /**\n    Create an extension that computes a value for the facet from a\n    state. You must take care to declare the parts of the state that\n    this value depends on, since your function is only called again\n    for a new state when one of those parts changed.\n    \n    In cases where your value depends only on a single field, you'll\n    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n    */ compute(deps, get) {\n        if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Provider.Single */ , get);\n    }\n    /**\n    Create an extension that computes zero or more values for this\n    facet from a state.\n    */ computeN(deps, get) {\n        if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Provider.Multi */ , get);\n    }\n    from(field, get) {\n        if (!get) get = (x)=>x;\n        return this.compute([\n            field\n        ], (state)=>get(state.field(field)));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i)=>e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value){\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */ ;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies){\n            if (dep == \"doc\") depDoc = true;\n            else if (dep == \"selection\") depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);\n        }\n        return {\n            create (state) {\n                state.values[idx] = getter(state);\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            update (state, tr) {\n                if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {\n                    let newVal = getter(state);\n                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\n                        state.values[idx] = newVal;\n                        return 1 /* SlotStatus.Changed */ ;\n                    }\n                }\n                return 0;\n            },\n            reconfigure: (state, oldState)=>{\n                let newVal, oldAddr = oldState.config.address[id];\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (this.dependencies.every((dep)=>{\n                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\n                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\n                        state.values[idx] = oldVal;\n                        return 0;\n                    }\n                } else {\n                    newVal = getter(state);\n                }\n                state.values[idx] = newVal;\n                return 1 /* SlotStatus.Changed */ ;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!compare(a[i], b[i])) return false;\n    return true;\n}\nfunction ensureAll(state, addrs) {\n    let changed = false;\n    for (let addr of addrs)if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */ ) changed = true;\n    return changed;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map((p)=>addresses[p.id]);\n    let providerTypes = providers.map((p)=>p.type);\n    let dynamic = providerAddrs.filter((p)=>!(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    function get(state) {\n        let values = [];\n        for(let i = 0; i < providerAddrs.length; i++){\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Provider.Multi */ ) for (let val of value)values.push(val);\n            else values.push(value);\n        }\n        return facet.combine(values);\n    }\n    return {\n        create (state) {\n            for (let addr of providerAddrs)ensureAddr(state, addr);\n            state.values[idx] = get(state);\n            return 1 /* SlotStatus.Changed */ ;\n        },\n        update (state, tr) {\n            if (!ensureAll(state, dynamic)) return 0;\n            let value = get(state);\n            if (facet.compare(value, state.values[idx])) return 0;\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */ ;\n        },\n        reconfigure (state, oldState) {\n            let depChanged = ensureAll(state, providerAddrs);\n            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);\n            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            let value = get(state);\n            if (facet.compare(value, oldValue)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */ ;\n        }\n    };\n}\nconst initField = /*@__PURE__*/ Facet.define({\n    static: true\n});\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/ class StateField {\n    constructor(/**\n    @internal\n    */ id, createF, updateF, compareF, /**\n    @internal\n    */ spec){\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.spec = spec;\n        /**\n        @internal\n        */ this.provides = undefined;\n    }\n    /**\n    Define a state field.\n    */ static define(config) {\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b)=>a === b), config);\n        if (config.provide) field.provides = config.provide(field);\n        return field;\n    }\n    create(state) {\n        let init = state.facet(initField).find((i)=>i.field == this);\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /**\n    @internal\n    */ slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return {\n            create: (state)=>{\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            update: (state, tr)=>{\n                let oldVal = state.values[idx];\n                let value = this.updateF(oldVal, tr);\n                if (this.compareF(oldVal, value)) return 0;\n                state.values[idx] = value;\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            reconfigure: (state, oldState)=>{\n                if (oldState.config.address[this.id] != null) {\n                    state.values[idx] = oldState.field(this);\n                    return 0;\n                }\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */ ;\n            }\n        };\n    }\n    /**\n    Returns an extension that enables this field and overrides the\n    way it is initialized. Can be useful when you need to provide a\n    non-default starting value for the field.\n    */ init(create) {\n        return [\n            this,\n            initField.of({\n                field: this,\n                create\n            })\n        ];\n    }\n    /**\n    State field instances can be used as\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n    given state.\n    */ get extension() {\n        return this;\n    }\n}\nconst Prec_ = {\n    lowest: 4,\n    low: 3,\n    default: 2,\n    high: 1,\n    highest: 0\n};\nfunction prec(value) {\n    return (ext)=>new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/ const Prec = {\n    /**\n    The highest precedence level, for extensions that should end up\n    near the start of the precedence ordering.\n    */ highest: /*@__PURE__*/ prec(Prec_.highest),\n    /**\n    A higher-than-default precedence, for extensions that should\n    come before those with default precedence.\n    */ high: /*@__PURE__*/ prec(Prec_.high),\n    /**\n    The default precedence, which is also used for extensions\n    without an explicit precedence.\n    */ default: /*@__PURE__*/ prec(Prec_.default),\n    /**\n    A lower-than-default precedence.\n    */ low: /*@__PURE__*/ prec(Prec_.low),\n    /**\n    The lowest precedence level. Meant for things that should end up\n    near the end of the extension order.\n    */ lowest: /*@__PURE__*/ prec(Prec_.lowest)\n};\nclass PrecExtension {\n    constructor(inner, prec){\n        this.inner = inner;\n        this.prec = prec;\n    }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/ class Compartment {\n    /**\n    Create an instance of this compartment to add to your [state\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n    */ of(ext) {\n        return new CompartmentInstance(this, ext);\n    }\n    /**\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n    reconfigures this compartment.\n    */ reconfigure(content) {\n        return Compartment.reconfigure.of({\n            compartment: this,\n            extension: content\n        });\n    }\n    /**\n    Get the current content of the compartment in the state, or\n    `undefined` if it isn't present.\n    */ get(state) {\n        return state.config.compartments.get(this);\n    }\n}\nclass CompartmentInstance {\n    constructor(compartment, inner){\n        this.compartment = compartment;\n        this.inner = inner;\n    }\n}\nclass Configuration {\n    constructor(base, compartments, dynamicSlots, address, staticValues, facets){\n        this.base = base;\n        this.compartments = compartments;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.facets = facets;\n        this.statusTemplate = [];\n        while(this.statusTemplate.length < dynamicSlots.length)this.statusTemplate.push(0 /* SlotStatus.Unresolved */ );\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(base, compartments, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        let newCompartments = new Map();\n        for (let ext of flatten(base, compartments, newCompartments)){\n            if (ext instanceof StateField) fields.push(ext);\n            else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields){\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push((a)=>field.slot(a));\n        }\n        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\n        for(let id in facets){\n            let providers = facets[id], facet = providers[0].facet;\n            let oldProviders = oldFacets && oldFacets[id] || [];\n            if (providers.every((p)=>p.type == 0 /* Provider.Static */ )) {\n                address[facet.id] = staticValues.length << 1 | 1;\n                if (sameArray(oldProviders, providers)) {\n                    staticValues.push(oldState.facet(facet));\n                } else {\n                    let value = facet.combine(providers.map((p)=>p.value));\n                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\n                }\n            } else {\n                for (let p of providers){\n                    if (p.type == 0 /* Provider.Static */ ) {\n                        address[p.id] = staticValues.length << 1 | 1;\n                        staticValues.push(p.value);\n                    } else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push((a)=>p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push((a)=>dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        let dynamic = dynamicSlots.map((f)=>f(address));\n        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\n    }\n}\nfunction flatten(extension, compartments, newCompartments) {\n    let result = [\n        [],\n        [],\n        [],\n        [],\n        []\n    ];\n    let seen = new Map();\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known <= prec) return;\n            let found = result[known].indexOf(ext);\n            if (found > -1) result[known].splice(found, 1);\n            if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)inner(e, prec);\n        } else if (ext instanceof CompartmentInstance) {\n            if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);\n            let content = compartments.get(ext.compartment) || ext.inner;\n            newCompartments.set(ext.compartment, content);\n            inner(content, prec);\n        } else if (ext instanceof PrecExtension) {\n            inner(ext.inner, ext.prec);\n        } else if (ext instanceof StateField) {\n            result[prec].push(ext);\n            if (ext.provides) inner(ext.provides, prec);\n        } else if (ext instanceof FacetProvider) {\n            result[prec].push(ext);\n            if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);\n        } else {\n            let content = ext.extension;\n            if (!content) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n            inner(content, prec);\n        }\n    }\n    inner(extension, Prec_.default);\n    return result.reduce((a, b)=>a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1) return 2 /* SlotStatus.Computed */ ;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* SlotStatus.Computing */ ) throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* SlotStatus.Computed */ ) return status;\n    state.status[idx] = 4 /* SlotStatus.Computing */ ;\n    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\n    return state.status[idx] = 2 /* SlotStatus.Computed */  | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\nconst languageData = /*@__PURE__*/ Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.some((v)=>v),\n    static: true\n});\nconst lineSeparator = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = /*@__PURE__*/ Facet.define();\nconst transactionFilter = /*@__PURE__*/ Facet.define();\nconst transactionExtender = /*@__PURE__*/ Facet.define();\nconst readOnly = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : false\n});\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/ class Annotation {\n    /**\n    @internal\n    */ constructor(/**\n    The annotation type.\n    */ type, /**\n    The value of this annotation.\n    */ value){\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Define a new type of annotation.\n    */ static define() {\n        return new AnnotationType();\n    }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/ class AnnotationType {\n    /**\n    Create an instance of this annotation.\n    */ of(value) {\n        return new Annotation(this, value);\n    }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/ class StateEffectType {\n    /**\n    @internal\n    */ constructor(// The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /**\n    @internal\n    */ map){\n        this.map = map;\n    }\n    /**\n    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n    type.\n    */ of(value) {\n        return new StateEffect(this, value);\n    }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/ class StateEffect {\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ type, /**\n    The value of this effect.\n    */ value){\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Map this effect through a position mapping. Will return\n    `undefined` when that ends up deleting the effect.\n    */ map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /**\n    Tells you whether this effect object is of a given\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n    */ is(type) {\n        return this.type == type;\n    }\n    /**\n    Define a new effect type. The type parameter indicates the type\n    of values that his effect holds. It should be a type that\n    doesn't include `undefined`, since that is used in\n    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is\n    removed.\n    */ static define(spec = {}) {\n        return new StateEffectType(spec.map || ((v)=>v));\n    }\n    /**\n    Map an array of effects through a change set.\n    */ static mapEffects(effects, mapping) {\n        if (!effects.length) return effects;\n        let result = [];\n        for (let effect of effects){\n            let mapped = effect.map(mapping);\n            if (mapped) result.push(mapped);\n        }\n        return result;\n    }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/ StateEffect.reconfigure = /*@__PURE__*/ StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/ StateEffect.appendConfig = /*@__PURE__*/ StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\ndispatch one by calling\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\n*/ class Transaction {\n    constructor(/**\n    The state from which the transaction starts.\n    */ startState, /**\n    The document changes made by this transaction.\n    */ changes, /**\n    The selection set by this transaction, or undefined if it\n    doesn't explicitly set a selection.\n    */ selection, /**\n    The effects added to the transaction.\n    */ effects, /**\n    @internal\n    */ annotations, /**\n    Whether the selection should be scrolled into view after this\n    transaction is dispatched.\n    */ scrollIntoView){\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.scrollIntoView = scrollIntoView;\n        /**\n        @internal\n        */ this._doc = null;\n        /**\n        @internal\n        */ this._state = null;\n        if (selection) checkSelection(selection, changes.newLength);\n        if (!annotations.some((a)=>a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /**\n    @internal\n    */ static create(startState, changes, selection, effects, annotations, scrollIntoView) {\n        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\n    }\n    /**\n    The new document produced by the transaction. Contrary to\n    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n    force the entire new state to be computed right away, so it is\n    recommended that [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n    when they need to look at the new document.\n    */ get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /**\n    The new selection produced by the transaction. If\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n    current selection through the changes made by the transaction.\n    */ get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /**\n    The new state created by the transaction. Computed on demand\n    (but retained for subsequent access), so it is recommended not to\n    access it in [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n    */ get state() {\n        if (!this._state) this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /**\n    Get the value of the given annotation type, if any.\n    */ annotation(type) {\n        for (let ann of this.annotations)if (ann.type == type) return ann.value;\n        return undefined;\n    }\n    /**\n    Indicates whether the transaction changed the document.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Indicates whether this transaction reconfigures the state\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n    with a top-level configuration\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n    */ get reconfigured() {\n        return this.startState.config != this.state.config;\n    }\n    /**\n    Returns true if the transaction has a [user\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n    or more specific than `event`. For example, if the transaction\n    has `\"select.pointer\"` as user event, `\"select\"` and\n    `\"select.pointer\"` will match it.\n    */ isUserEvent(event) {\n        let e = this.annotation(Transaction.userEvent);\n        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n    }\n}\n/**\nAnnotation used to store transaction timestamps. Automatically\nadded to every transaction, holding `Date.now()`.\n*/ Transaction.time = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/ Transaction.userEvent = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/ Transaction.addToHistory = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/ Transaction.remote = /*@__PURE__*/ Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for(let iA = 0, iB = 0;;){\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        } else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        } else return result;\n        if (!result.length || result[result.length - 1] < from) result.push(from, to);\n        else if (result[result.length - 1] < to) result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    } else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let sel = spec.selection, annotations = asArray(spec.annotations);\n    if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations,\n        scrollIntoView: !!spec.scrollIntoView\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false) filter = false;\n    for(let i = 1; i < specs.length; i++){\n        if (specs[i].filter === false) filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)){\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        } else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\n        }\n        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for(let i = filters.length - 1; i >= 0; i--){\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction) tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];\n        else tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for(let i = extenders.length - 1; i >= 0; i--){\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [\n        value\n    ];\n}\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/ var CharCategory = /*@__PURE__*/ function(CharCategory) {\n    /**\n    Word characters.\n    */ CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    /**\n    Whitespace.\n    */ CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    /**\n    Anything else.\n    */ CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n    return CharCategory;\n}(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/ new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch (_) {}\nfunction hasWordChar(str) {\n    if (wordChar) return wordChar.test(str);\n    for(let i = 0; i < str.length; i++){\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char)=>{\n        if (!/\\S/.test(char)) return CharCategory.Space;\n        if (hasWordChar(char)) return CharCategory.Word;\n        for(let i = 0; i < wordChars.length; i++)if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/ class EditorState {\n    constructor(/**\n    @internal\n    */ config, /**\n    The current document.\n    */ doc, /**\n    The current selection.\n    */ selection, /**\n    @internal\n    */ values, computeSlot, tr){\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        this.values = values;\n        this.status = config.statusTemplate.slice();\n        this.computeSlot = computeSlot;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr) tr._state = this;\n        for(let i = 0; i < this.config.dynamicSlots.length; i++)ensureAddr(this, i << 1);\n        this.computeSlot = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require) throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n    can be passed. Unless\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n    are assumed to start in the _current_ document (not the document\n    produced by previous specs), and its\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n    to the document created by its _own_ changes. The resulting\n    transaction contains the combined effect of all the different\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n    specs take precedence over earlier ones.\n    */ update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /**\n    @internal\n    */ applyTransaction(tr) {\n        let conf = this.config, { base, compartments } = conf;\n        for (let effect of tr.effects){\n            if (effect.is(Compartment.reconfigure)) {\n                if (conf) {\n                    compartments = new Map;\n                    conf.compartments.forEach((val, key)=>compartments.set(key, val));\n                    conf = null;\n                }\n                compartments.set(effect.value.compartment, effect.value.extension);\n            } else if (effect.is(StateEffect.reconfigure)) {\n                conf = null;\n                base = effect.value;\n            } else if (effect.is(StateEffect.appendConfig)) {\n                conf = null;\n                base = asArray(base).concat(effect.value);\n            }\n        }\n        let startValues;\n        if (!conf) {\n            conf = Configuration.resolve(base, compartments, this);\n            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(()=>null), (state, slot)=>slot.reconfigure(state, this), null);\n            startValues = intermediateState.values;\n        } else {\n            startValues = tr.startState.values.slice();\n        }\n        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();\n        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot)=>slot.update(state, tr), tr);\n    }\n    /**\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n    replaces every selection range with the given content.\n    */ replaceSelection(text) {\n        if (typeof text == \"string\") text = this.toText(text);\n        return this.changeByRange((range)=>({\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: text\n                },\n                range: EditorSelection.cursor(range.from + text.length)\n            }));\n    }\n    /**\n    Create a set of changes and a new selection by running the given\n    function for each range in the active selection. The function\n    can return an optional set of changes (in the coordinate space\n    of the start document), plus an updated range (in the coordinate\n    space of the document produced by the call's own changes). This\n    method will merge all the changes and ranges into a single\n    changeset and selection, and return it as a [transaction\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n    */ changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [\n            result1.range\n        ];\n        let effects = asArray(result1.effects);\n        for(let i = 1; i < sel.ranges.length; i++){\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for(let j = 0; j < i; j++)ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.mainIndex),\n            effects\n        };\n    }\n    /**\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n    description, taking the state's document length and line\n    separator into account.\n    */ changes(spec = []) {\n        if (spec instanceof ChangeSet) return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /**\n    Using the state's [line\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n    */ toText(string) {\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /**\n    Return the given range of the document as a string.\n    */ sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /**\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n    */ facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null) return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Convert this state to a JSON-serializable object. When custom\n    fields should be serialized, you can pass them in as an object\n    mapping property names (in the resulting object, which should\n    not use `doc` or `selection`) to fields.\n    */ toJSON(fields) {\n        let result = {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n        if (fields) for(let prop in fields){\n            let value = fields[prop];\n            if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n        }\n        return result;\n    }\n    /**\n    Deserialize a state from its JSON representation. When custom\n    fields should be deserialized, pass the same object you passed\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n    third argument.\n    */ static fromJSON(json, config = {}, fields) {\n        if (!json || typeof json.doc != \"string\") throw new RangeError(\"Invalid JSON representation for EditorState\");\n        let fieldInit = [];\n        if (fields) for(let prop in fields){\n            if (Object.prototype.hasOwnProperty.call(json, prop)) {\n                let field = fields[prop], value = json[prop];\n                fieldInit.push(field.init((state)=>field.spec.fromJSON(value, state)));\n            }\n        }\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions ? fieldInit.concat([\n                config.extensions\n            ]) : fieldInit\n        });\n    }\n    /**\n    Create a new state. You'll usually only need this when\n    initializing an editor—updated states are created by applying\n    transactions.\n    */ static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || [], new Map);\n        let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(()=>null), (state, slot)=>slot.create(state), null);\n    }\n    /**\n    The size (in columns) of a tab in the document, determined by\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n    */ get tabSize() {\n        return this.facet(EditorState.tabSize);\n    }\n    /**\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n    string for this state.\n    */ get lineBreak() {\n        return this.facet(EditorState.lineSeparator) || \"\\n\";\n    }\n    /**\n    Returns true when the editor is\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n    */ get readOnly() {\n        return this.facet(readOnly);\n    }\n    /**\n    Look up a translation for the given phrase (via the\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n    original string if no translation is found.\n    \n    If additional arguments are passed, they will be inserted in\n    place of markers like `$1` (for the first value) and `$2`, etc.\n    A single `$` is equivalent to `$1`, and `$$` will produce a\n    literal dollar sign.\n    */ phrase(phrase, ...insert) {\n        for (let map of this.facet(EditorState.phrases))if (Object.prototype.hasOwnProperty.call(map, phrase)) {\n            phrase = map[phrase];\n            break;\n        }\n        if (insert.length) phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i)=>{\n            if (i == \"$\") return \"$\";\n            let n = +(i || 1);\n            return !n || n > insert.length ? m : insert[n - 1];\n        });\n        return phrase;\n    }\n    /**\n    Find the values for a given language data field, provided by the\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n    \n    Examples of language data fields are...\n    \n    - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n      comment syntax.\n    - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n      for providing language-specific completion sources.\n    - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n      characters that should be considered part of words in this\n      language.\n    - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n      bracket closing behavior.\n    */ languageDataAt(name, pos, side = -1) {\n        let values = [];\n        for (let provider of this.facet(languageData)){\n            for (let result of provider(this, pos, side)){\n                if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /**\n    Return a function that can categorize strings (expected to\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n    into one of:\n    \n     - Word (contains an alphanumeric character or a character\n       explicitly listed in the local language's `\"wordChars\"`\n       language data, which should be a string)\n     - Space (contains only whitespace)\n     - Other (anything else)\n    */ charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n    /**\n    Find the word at the given position, meaning the range\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n    around it. If no word characters are adjacent to the position,\n    this returns null.\n    */ wordAt(pos) {\n        let { text, from, length } = this.doc.lineAt(pos);\n        let cat = this.charCategorizer(pos);\n        let start = pos - from, end = pos - from;\n        while(start > 0){\n            let prev = findClusterBreak(text, start, false);\n            if (cat(text.slice(prev, start)) != CharCategory.Word) break;\n            start = prev;\n        }\n        while(end < length){\n            let next = findClusterBreak(text, end);\n            if (cat(text.slice(end, next)) != CharCategory.Word) break;\n            end = next;\n        }\n        return start == end ? null : EditorSelection.range(start + from, end + from);\n    }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/ EditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/ EditorState.tabSize = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/ EditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/ EditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/ EditorState.phrases = /*@__PURE__*/ Facet.define({\n    compare (a, b) {\n        let kA = Object.keys(a), kB = Object.keys(b);\n        return kA.length == kB.length && kA.every((k)=>a[k] == b[k]);\n    }\n});\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/ EditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two numbers indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/ EditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/ EditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even if the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are present.\n*/ EditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/ StateEffect.define();\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. `defaults` should hold\ndefault values for all optional fields in `Config`.\n\nThe function will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/ function combineConfig(configs, defaults, combine = {}) {\n    let result = {};\n    for (let config of configs)for (let key of Object.keys(config)){\n        let value = config[key], current = result[key];\n        if (current === undefined) result[key] = value;\n        else if (current === value || value === undefined) ; // No conflict\n        else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);\n        else throw new Error(\"Config merge conflict for field \" + key);\n    }\n    for(let key in defaults)if (result[key] === undefined) result[key] = defaults[key];\n    return result;\n}\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/ class RangeValue {\n    /**\n    Compare this value with another value. Used when comparing\n    rangesets. The default implementation compares by identity.\n    Unless you are only creating a fixed number of unique instances\n    of your value type, it is a good idea to implement this\n    properly.\n    */ eq(other) {\n        return this == other;\n    }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n    */ range(from, to = from) {\n        return Range.create(from, to, this);\n    }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/ class Range {\n    constructor(/**\n    The range's start position.\n    */ from, /**\n    Its end position.\n    */ to, /**\n    The value associated with this range.\n    */ value){\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n    /**\n    @internal\n    */ static create(from, to, value) {\n        return new Range(from, to, value);\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint){\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() {\n        return this.to[this.to.length - 1];\n    }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for(let lo = startAt, hi = arr.length;;){\n            if (lo == hi) return lo;\n            let mid = lo + hi >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo) return diff >= 0 ? lo : hi;\n            if (diff >= 0) hi = mid;\n            else lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for(let i = this.findIndex(from, -1000000000 /* C.Far */ , true), e = this.findIndex(to, 1000000000 /* C.Far */ , false, i); i < e; i++)if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for(let i = 0; i < this.value.length; i++){\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null) continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom) continue;\n                }\n            } else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n            if (newPos < 0) newPos = newFrom;\n            if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return {\n            mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n            pos: newPos\n        };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\nstructure.\n*/ class RangeSet {\n    constructor(/**\n    @internal\n    */ chunkPos, /**\n    @internal\n    */ chunk, /**\n    @internal\n    */ nextLayer, /**\n    @internal\n    */ maxPoint){\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */ static create(chunkPos, chunk, nextLayer, maxPoint) {\n        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\n    }\n    /**\n    @internal\n    */ get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */ get size() {\n        if (this.isEmpty) return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */ chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (Note: The type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */ update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter) return this;\n        if (sort) add = add.slice().sort(cmpRange);\n        if (this.isEmpty) return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while(cur.value || i < add.length){\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n            } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            } else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(Range.create(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n            add: spill,\n            filter,\n            filterFrom,\n            filterTo\n        }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */ map(changes) {\n        if (changes.empty || this.isEmpty) return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for(let i = 0; i < this.chunk.length; i++){\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            } else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */ between(from, to, f) {\n        if (this.isEmpty) return;\n        for(let i = 0; i < this.chunk.length; i++){\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */ iter(from = 0) {\n        return HeapCursor.from([\n            this\n        ]).goto(from);\n    }\n    /**\n    @internal\n    */ get isEmpty() {\n        return this.nextLayer == this;\n    }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */ static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */ static compare(oldSets, newSets, /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration.\n    */ textDiff, comparator, /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */ minPointSize = -1) {\n        let a = oldSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length)=>compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */ static eq(oldSets, newSets, from = 0, to) {\n        if (to == null) to = 1000000000 /* C.Far */  - 1;\n        let a = oldSets.filter((set)=>!set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter((set)=>!set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length) return false;\n        if (!a.length) return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for(;;){\n            if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;\n            if (sideA.to > to) return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n    of the iteration.\n    */ static spans(sets, from, to, iterator, /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */ minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let openRanges = cursor.openStart;\n        for(;;){\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                let active = cursor.activeForPoint(cursor.to);\n                let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);\n                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\n                openRanges = Math.min(cursor.openEnd(curTo), active.length);\n            } else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, openRanges);\n                openRanges = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to) return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\n            pos = cursor.to;\n            cursor.next();\n        }\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */ static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [\n            ranges\n        ] : sort ? lazySort(ranges) : ranges)build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n    /**\n    Join an array of range sets into a single set.\n    */ static join(sets) {\n        if (!sets.length) return RangeSet.empty;\n        let result = sets[sets.length - 1];\n        for(let i = sets.length - 2; i >= 0; i--){\n            for(let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));\n        }\n        return result;\n    }\n}\n/**\nThe empty set of ranges.\n*/ RangeSet.empty = /*@__PURE__*/ new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1) for(let prev = ranges[0], i = 1; i < ranges.length; i++){\n        let cur = ranges[i];\n        if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);\n        prev = cur;\n    }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\n*/ class RangeSetBuilder {\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Create an empty builder.\n    */ constructor(){\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* C.Far */ ;\n        this.lastTo = -1000000000 /* C.Far */ ;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */ add(from, to, value) {\n        if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */ addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0) return false;\n        if (this.from.length == 250 /* C.ChunkSize */ ) this.finishChunk(true);\n        if (this.chunkStart < 0) this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */ addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n        if (this.from.length) this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */ finish() {\n        return this.finishInner(RangeSet.empty);\n    }\n    /**\n    @internal\n    */ finishInner(next) {\n        if (this.from.length) this.finishChunk(false);\n        if (this.chunks.length == 0) return next;\n        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)for(let i = 0; i < set.chunk.length; i++)if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)for(let i = 0; i < set.chunk.length; i++){\n        let known = inA.get(set.chunk[i]);\n        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length))) shared.add(set.chunk[i]);\n    }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0){\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() {\n        return this.value ? this.value.startSide : 0;\n    }\n    get endSide() {\n        return this.value ? this.value.endSide : 0;\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while(this.chunkIndex < this.layer.chunk.length){\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n    }\n    next() {\n        for(;;){\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* C.Far */ ;\n                this.value = null;\n                break;\n            } else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while(this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        } else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap){\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for(let i = 0; i < sets.length; i++){\n            for(let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer){\n                if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() {\n        return this.value ? this.value.startSide : 0;\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        for (let cur of this.heap)cur.goto(pos, side);\n        for(let i = this.heap.length >> 1; i >= 0; i--)heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)cur.forward(pos, side);\n        for(let i = this.heap.length >> 1; i >= 0; i--)heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* C.Far */ ;\n            this.value = null;\n            this.rank = -1;\n        } else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value) top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for(let cur = heap[index];;){\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length) break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0) break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint){\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* C.Far */ ;\n        this.endSide = 0;\n        // The amount of open active ranges at the start of the iterator.\n        // Not including points.\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while(this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        // Organize active marks by rank first, then by size\n        while(i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen) insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null;\n        for(;;){\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen) remove(trackOpen, a);\n            } else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* C.Far */ ;\n                break;\n            } else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            } else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) {\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                } else {\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    this.cursor.next();\n                    this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            this.openStart = 0;\n            for(let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)this.openStart++;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length) return this.active;\n        let active = [];\n        for(let i = this.active.length - 1; i >= 0; i--){\n            if (this.activeRank[i] < this.pointRank) break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for(let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for(;;){\n        let diff = a.to + dPos - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        } else {\n            if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB) break;\n        pos = end;\n        if (diff <= 0) a.next();\n        if (diff >= 0) b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n    return true;\n}\nfunction remove(array, index) {\n    for(let i = index, e = array.length - 1; i < e; i++)array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for(let i = array.length - 1; i >= index; i--)array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* C.Far */ ;\n    for(let i = 0; i < array.length; i++)if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n        found = i;\n        foundPos = array[i];\n    }\n    return found;\n}\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/ function countColumn(string, tabSize, to = string.length) {\n    let n = 0;\n    for(let i = 0; i < to;){\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - n % tabSize;\n            i++;\n        } else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/ function findColumn(string, col, tabSize, strict) {\n    for(let i = 0, n = 0;;){\n        if (n >= col) return i;\n        if (i == string.length) break;\n        n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;\n        i = findClusterBreak(string, i);\n    }\n    return strict === true ? -1 : string.length;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBLEdBQ0EsTUFBTUE7SUFDRjs7SUFFQSxHQUNBQyxPQUFPQyxHQUFHLEVBQUU7UUFDUixJQUFJQSxNQUFNLEtBQUtBLE1BQU0sSUFBSSxDQUFDQyxNQUFNLEVBQzVCLE1BQU0sSUFBSUMsV0FBVyxDQUFDLGlCQUFpQixFQUFFRixJQUFJLHVCQUF1QixFQUFFLElBQUksQ0FBQ0MsTUFBTSxDQUFDLENBQUM7UUFDdkYsT0FBTyxJQUFJLENBQUNFLFNBQVMsQ0FBQ0gsS0FBSyxPQUFPLEdBQUc7SUFDekM7SUFDQTs7SUFFQSxHQUNBSSxLQUFLQyxDQUFDLEVBQUU7UUFDSixJQUFJQSxJQUFJLEtBQUtBLElBQUksSUFBSSxDQUFDQyxLQUFLLEVBQ3ZCLE1BQU0sSUFBSUosV0FBVyxDQUFDLG9CQUFvQixFQUFFRyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUNDLEtBQUssQ0FBQyxjQUFjLENBQUM7UUFDbEYsT0FBTyxJQUFJLENBQUNILFNBQVMsQ0FBQ0UsR0FBRyxNQUFNLEdBQUc7SUFDdEM7SUFDQTs7SUFFQSxHQUNBRSxRQUFRQyxJQUFJLEVBQUVDLEVBQUUsRUFBRUMsSUFBSSxFQUFFO1FBQ3BCLENBQUNGLE1BQU1DLEdBQUcsR0FBR0UsS0FBSyxJQUFJLEVBQUVILE1BQU1DO1FBQzlCLElBQUlHLFFBQVEsRUFBRTtRQUNkLElBQUksQ0FBQ0MsU0FBUyxDQUFDLEdBQUdMLE1BQU1JLE9BQU8sRUFBRSxXQUFXO1FBQzVDLElBQUlGLEtBQUtULE1BQU0sRUFDWFMsS0FBS0csU0FBUyxDQUFDLEdBQUdILEtBQUtULE1BQU0sRUFBRVcsT0FBTyxFQUFFLGFBQWEsTUFBSyxFQUFFLFdBQVc7UUFDM0UsSUFBSSxDQUFDQyxTQUFTLENBQUNKLElBQUksSUFBSSxDQUFDUixNQUFNLEVB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LE1BQU07QUFDL0M7QUFFa1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zdGF0ZS9kaXN0L2luZGV4LmpzPzhjOGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5UaGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIGRvY3VtZW50cy4gQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgVGV4dCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBsaW5lIGRlc2NyaXB0aW9uIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBsaW5lQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgcG9zaXRpb24gJHtwb3N9IGluIGRvY3VtZW50IG9mIGxlbmd0aCAke3RoaXMubGVuZ3RofWApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIocG9zLCBmYWxzZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiAoMS1iYXNlZCkgbGluZSBudW1iZXIuXG4gICAgKi9cbiAgICBsaW5lKG4pIHtcbiAgICAgICAgaWYgKG4gPCAxIHx8IG4gPiB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbGluZSBudW1iZXIgJHtufSBpbiAke3RoaXMubGluZXN9LWxpbmUgZG9jdW1lbnRgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKG4sIHRydWUsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIHRleHQgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoMCwgZnJvbSwgcGFydHMsIDIgLyogT3Blbi5UbyAqLyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8gfCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSh0bywgdGhpcy5sZW5ndGgsIHBhcnRzLCAxIC8qIE9wZW4uRnJvbSAqLyk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMubGVuZ3RoLCB0aGlzLmxlbmd0aCwgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKGZyb20sIHRvLCBwYXJ0cywgMCk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0byAtIGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyB0ZXh0IGlzIGVxdWFsIHRvIGFub3RoZXIgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob3RoZXIubGVuZ3RoICE9IHRoaXMubGVuZ3RoIHx8IG90aGVyLmxpbmVzICE9IHRoaXMubGluZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgMSksIGVuZCA9IHRoaXMubGVuZ3RoIC0gdGhpcy5zY2FuSWRlbnRpY2FsKG90aGVyLCAtMSk7XG4gICAgICAgIGxldCBhID0gbmV3IFJhd1RleHRDdXJzb3IodGhpcyksIGIgPSBuZXcgUmF3VGV4dEN1cnNvcihvdGhlcik7XG4gICAgICAgIGZvciAobGV0IHNraXAgPSBzdGFydCwgcG9zID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgYS5uZXh0KHNraXApO1xuICAgICAgICAgICAgYi5uZXh0KHNraXApO1xuICAgICAgICAgICAgc2tpcCA9IDA7XG4gICAgICAgICAgICBpZiAoYS5saW5lQnJlYWsgIT0gYi5saW5lQnJlYWsgfHwgYS5kb25lICE9IGIuZG9uZSB8fCBhLnZhbHVlICE9IGIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcG9zICs9IGEudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuZG9uZSB8fCBwb3MgPj0gZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdGV4dC4gV2hlbiBgZGlyYCBpcyBgLTFgLCBpdGVyYXRpb24gaGFwcGVuc1xuICAgIGZyb20gZW5kIHRvIHN0YXJ0LiBUaGlzIHdpbGwgcmV0dXJuIGxpbmVzIGFuZCB0aGUgYnJlYWtzIGJldHdlZW5cbiAgICB0aGVtIGFzIHNlcGFyYXRlIHN0cmluZ3MuXG4gICAgKi9cbiAgICBpdGVyKGRpciA9IDEpIHsgcmV0dXJuIG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMsIGRpcik7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgYSByYW5nZSBvZiB0aGUgdGV4dC4gV2hlbiBgZnJvbWAgPiBgdG9gLCB0aGVcbiAgICBpdGVyYXRvciB3aWxsIHJ1biBpbiByZXZlcnNlLlxuICAgICovXG4gICAgaXRlclJhbmdlKGZyb20sIHRvID0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIG5ldyBQYXJ0aWFsVGV4dEN1cnNvcih0aGlzLCBmcm9tLCB0byk7IH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBjdXJzb3IgdGhhdCBpdGVyYXRlcyBvdmVyIHRoZSBnaXZlbiByYW5nZSBvZiBsaW5lcyxcbiAgICBfd2l0aG91dF8gcmV0dXJuaW5nIHRoZSBsaW5lIGJyZWFrcyBiZXR3ZWVuLCBhbmQgeWllbGRpbmcgZW1wdHlcbiAgICBzdHJpbmdzIGZvciBlbXB0eSBsaW5lcy5cbiAgICBcbiAgICBXaGVuIGBmcm9tYCBhbmQgYHRvYCBhcmUgZ2l2ZW4sIHRoZXkgc2hvdWxkIGJlIDEtYmFzZWQgbGluZSBudW1iZXJzLlxuICAgICovXG4gICAgaXRlckxpbmVzKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBpbm5lcjtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5uZXIgPSB0aGlzLml0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRvID0gdGhpcy5saW5lcyArIDE7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmxpbmUoZnJvbSkuZnJvbTtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyUmFuZ2Uoc3RhcnQsIE1hdGgubWF4KHN0YXJ0LCB0byA9PSB0aGlzLmxpbmVzICsgMSA/IHRoaXMubGVuZ3RoIDogdG8gPD0gMSA/IDAgOiB0aGlzLmxpbmUodG8gLSAxKS50bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZUN1cnNvcihpbm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcsIHVzaW5nIG5ld2xpbmUgY2hhcmFjdGVycyB0b1xuICAgIHNlcGFyYXRlIGxpbmVzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLnNsaWNlU3RyaW5nKDApOyB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGUgZG9jdW1lbnQgdG8gYW4gYXJyYXkgb2YgbGluZXMgKHdoaWNoIGNhbiBiZVxuICAgIGRlc2VyaWFsaXplZCBhZ2FpbiB2aWEgW2BUZXh0Lm9mYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0Xm9mKSkuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmZsYXR0ZW4obGluZXMpO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgVGV4dGAgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBsaW5lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBvZih0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIGRvY3VtZW50IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGluZVwiKTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEgJiYgIXRleHRbMF0pXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovID8gbmV3IFRleHRMZWFmKHRleHQpIDogVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdCh0ZXh0LCBbXSkpO1xuICAgIH1cbn1cbi8vIExlYXZlcyBzdG9yZSBhbiBhcnJheSBvZiBsaW5lIHN0cmluZ3MuIFRoZXJlIGFyZSBhbHdheXMgbGluZSBicmVha3Ncbi8vIGJldHdlZW4gdGhlc2Ugc3RyaW5ncy4gTGVhdmVzIGFyZSBsaW1pdGVkIGluIHNpemUgYW5kIGhhdmUgdG8gYmVcbi8vIGNvbnRhaW5lZCBpbiBUZXh0Tm9kZSBpbnN0YW5jZXMgZm9yIGJpZ2dlciBkb2N1bWVudHMuXG5jbGFzcyBUZXh0TGVhZiBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGxlbmd0aCA9IHRleHRMZW5ndGgodGV4dCkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldCBsaW5lcygpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnRleHRbaV0sIGVuZCA9IG9mZnNldCArIHN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGxpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmUob2Zmc2V0LCBlbmQsIGxpbmUsIHN0cmluZyk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZnJvbSA8PSAwICYmIHRvID49IHRoaXMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgVGV4dExlYWYoc2xpY2VUZXh0KHRoaXMudGV4dCwgZnJvbSwgdG8pLCBNYXRoLm1pbih0bywgdGhpcy5sZW5ndGgpIC0gTWF0aC5tYXgoMCwgZnJvbSkpO1xuICAgICAgICBpZiAob3BlbiAmIDEgLyogT3Blbi5Gcm9tICovKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRhcmdldC5wb3AoKTtcbiAgICAgICAgICAgIGxldCBqb2luZWQgPSBhcHBlbmRUZXh0KHRleHQudGV4dCwgcHJldi50ZXh0LnNsaWNlKCksIDAsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChqb2luZWQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZCwgcHJldi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1pZCA9IGpvaW5lZC5sZW5ndGggPj4gMTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKDAsIG1pZCkpLCBuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKG1pZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmKSlcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgbGluZXMgPSBhcHBlbmRUZXh0KHRoaXMudGV4dCwgYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHNsaWNlVGV4dCh0aGlzLnRleHQsIDAsIGZyb20pKSwgdG8pO1xuICAgICAgICBsZXQgbmV3TGVuID0gdGhpcy5sZW5ndGggKyB0ZXh0Lmxlbmd0aCAtICh0byAtIGZyb20pO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihsaW5lcywgbmV3TGVuKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQobGluZXMsIFtdKSwgbmV3TGVuKTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMudGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnRleHQpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbCgpIHsgcmV0dXJuIDA7IH1cbiAgICBzdGF0aWMgc3BsaXQodGV4dCwgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBwYXJ0ID0gW10sIGxlbiA9IC0xO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHBhcnQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxlbiArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBPcGVuLkZyb20gKi8gOiAwKSB8IChlbmQgPj0gdG8gPyAyIC8qIE9wZW4uVG8gKi8gOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIGVuZCA8PSB0byAmJiAhY2hpbGRPcGVuKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWNvbXBvc2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRhcmdldCwgY2hpbGRPcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGlmICh0ZXh0LmxpbmVzIDwgdGhpcy5saW5lcylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSBjaGFuZ2Ugb25seSBhZmZlY3RzIG9uZSBjaGlsZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQncyBzaXplIHJlbWFpbnMgaW4gdGhlIGFjY2VwdGFibGUgcmFuZ2UsIG9ubHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjaGlsZFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHBvcyAmJiB0byA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSBjaGlsZC5yZXBsYWNlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsTGluZXMgPSB0aGlzLmxpbmVzIC0gY2hpbGQubGluZXMgKyB1cGRhdGVkLmxpbmVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5saW5lcyA8ICh0b3RhbExpbmVzID4+ICg1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8gLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQubGluZXMgPiAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29weSA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlbaV0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZShjb3B5LCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHBvcywgZW5kLCB1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UoZnJvbSwgdG8sIHRleHQpO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLnNsaWNlU3RyaW5nKGZyb20gLSBwb3MsIHRvIC0gcG9zLCBsaW5lU2VwKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgIGNoaWxkLmZsYXR0ZW4odGFyZ2V0KTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbChvdGhlciwgZGlyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVGV4dE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBsZXQgW2lBLCBpQiwgZUEsIGVCXSA9IGRpciA+IDAgPyBbMCwgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIG90aGVyLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgICAgIDogW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIC0xXTtcbiAgICAgICAgZm9yICg7OyBpQSArPSBkaXIsIGlCICs9IGRpcikge1xuICAgICAgICAgICAgaWYgKGlBID09IGVBIHx8IGlCID09IGVCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2hBID0gdGhpcy5jaGlsZHJlbltpQV0sIGNoQiA9IG90aGVyLmNoaWxkcmVuW2lCXTtcbiAgICAgICAgICAgIGlmIChjaEEgIT0gY2hCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggKyBjaEEuc2NhbklkZW50aWNhbChjaEIsIGRpcik7XG4gICAgICAgICAgICBsZW5ndGggKz0gY2hBLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb20oY2hpbGRyZW4sIGxlbmd0aCA9IGNoaWxkcmVuLnJlZHVjZSgobCwgY2gpID0+IGwgKyBjaC5sZW5ndGggKyAxLCAtMSkpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBsaW5lcyArPSBjaC5saW5lcztcbiAgICAgICAgaWYgKGxpbmVzIDwgMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgIGxldCBmbGF0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaC5mbGF0dGVuKGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihmbGF0LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaHVuayA9IE1hdGgubWF4KDMyIC8qIFRyZWUuQnJhbmNoICovLCBsaW5lcyA+PiA1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8pLCBtYXhDaHVuayA9IGNodW5rIDw8IDEsIG1pbkNodW5rID0gY2h1bmsgPj4gMTtcbiAgICAgICAgbGV0IGNodW5rZWQgPSBbXSwgY3VycmVudExpbmVzID0gMCwgY3VycmVudExlbiA9IC0xLCBjdXJyZW50Q2h1bmsgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkKGNoaWxkKSB7XG4gICAgICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgICAgIGlmIChjaGlsZC5saW5lcyA+IG1heENodW5rICYmIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGNoaWxkLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBhZGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5saW5lcyA+IG1pbkNodW5rICYmIChjdXJyZW50TGluZXMgPiBtaW5DaHVuayB8fCAhY3VycmVudExpbmVzKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dExlYWYgJiYgY3VycmVudExpbmVzICYmXG4gICAgICAgICAgICAgICAgKGxhc3QgPSBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIFRleHRMZWFmICYmXG4gICAgICAgICAgICAgICAgY2hpbGQubGluZXMgKyBsYXN0LmxpbmVzIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdID0gbmV3IFRleHRMZWFmKGxhc3QudGV4dC5jb25jYXQoY2hpbGQudGV4dCksIGxhc3QubGVuZ3RoICsgMSArIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudExpbmVzICsgY2hpbGQubGluZXMgPiBjaHVuaylcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuay5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGluZXMgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjaHVua2VkLnB1c2goY3VycmVudENodW5rLmxlbmd0aCA9PSAxID8gY3VycmVudENodW5rWzBdIDogVGV4dE5vZGUuZnJvbShjdXJyZW50Q2h1bmssIGN1cnJlbnRMZW4pKTtcbiAgICAgICAgICAgIGN1cnJlbnRMZW4gPSAtMTtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lcyA9IGN1cnJlbnRDaHVuay5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgYWRkKGNoaWxkKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGNodW5rZWQubGVuZ3RoID09IDEgPyBjaHVua2VkWzBdIDogbmV3IFRleHROb2RlKGNodW5rZWQsIGxlbmd0aCk7XG4gICAgfVxufVxuVGV4dC5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgVGV4dExlYWYoW1wiXCJdLCAwKTtcbmZ1bmN0aW9uIHRleHRMZW5ndGgodGV4dCkge1xuICAgIGxldCBsZW5ndGggPSAtMTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpXG4gICAgICAgIGxlbmd0aCArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmZ1bmN0aW9uIGFwcGVuZFRleHQodGV4dCwgdGFyZ2V0LCBmcm9tID0gMCwgdG8gPSAxZTkpIHtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMCwgZmlyc3QgPSB0cnVlOyBpIDwgdGV4dC5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0ZXh0W2ldLCBlbmQgPSBwb3MgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA+PSBmcm9tKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgdG8gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20pXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoZnJvbSAtIHBvcyk7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbdGFyZ2V0Lmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc2xpY2VUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGFwcGVuZFRleHQodGV4dCwgW1wiXCJdLCBmcm9tLCB0byk7XG59XG5jbGFzcyBSYXdUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBkaXIgPSAxKSB7XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdGV4dF07XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IFtkaXIgPiAwID8gMSA6ICh0ZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyB0ZXh0LnRleHQubGVuZ3RoIDogdGV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDFdO1xuICAgIH1cbiAgICBuZXh0SW5uZXIoc2tpcCwgZGlyKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMubm9kZXNbbGFzdF0sIG9mZnNldFZhbHVlID0gdGhpcy5vZmZzZXRzW2xhc3RdLCBvZmZzZXQgPSBvZmZzZXRWYWx1ZSA+PiAxO1xuICAgICAgICAgICAgbGV0IHNpemUgPSB0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRvcC50ZXh0Lmxlbmd0aCA6IHRvcC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IChkaXIgPiAwID8gc2l6ZSA6IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdCAtIDFdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgob2Zmc2V0VmFsdWUgJiAxKSA9PSAoZGlyID4gMCA/IDAgOiAxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9wIGluc3RhbmNlb2YgVGV4dExlYWYpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLnRleHRbb2Zmc2V0ICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Lmxlbmd0aCA+IE1hdGgubWF4KDAsIHNraXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBza2lwID09IDAgPyBuZXh0IDogZGlyID4gMCA/IG5leHQuc2xpY2Uoc2tpcCkgOiBuZXh0LnNsaWNlKDAsIG5leHQubGVuZ3RoIC0gc2tpcCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5bb2Zmc2V0ICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA+IG5leHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XS0tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKGRpciA+IDAgPyAxIDogKG5leHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IG5leHQudGV4dC5sZW5ndGggOiBuZXh0LmNoaWxkcmVuLmxlbmd0aCkgPDwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgaWYgKHNraXAgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRJbm5lcigtc2tpcCwgKC10aGlzLmRpcikpO1xuICAgICAgICAgICAgc2tpcCA9IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmRpcik7XG4gICAgfVxufVxuY2xhc3MgUGFydGlhbFRleHRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRleHQsIHN0YXJ0ID4gZW5kID8gLTEgOiAxKTtcbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydCA+IGVuZCA/IHRleHQubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy5mcm9tID0gTWF0aC5taW4oc3RhcnQsIGVuZCk7XG4gICAgICAgIHRoaXMudG8gPSBNYXRoLm1heChzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xuICAgICAgICBpZiAoZGlyIDwgMCA/IHRoaXMucG9zIDw9IHRoaXMuZnJvbSA6IHRoaXMucG9zID49IHRoaXMudG8pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHNraXAgKz0gTWF0aC5tYXgoMCwgZGlyIDwgMCA/IHRoaXMucG9zIC0gdGhpcy50byA6IHRoaXMuZnJvbSAtIHRoaXMucG9zKTtcbiAgICAgICAgbGV0IGxpbWl0ID0gZGlyIDwgMCA/IHRoaXMucG9zIC0gdGhpcy5mcm9tIDogdGhpcy50byAtIHRoaXMucG9zO1xuICAgICAgICBpZiAoc2tpcCA+IGxpbWl0KVxuICAgICAgICAgICAgc2tpcCA9IGxpbWl0O1xuICAgICAgICBsaW1pdCAtPSBza2lwO1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gdGhpcy5jdXJzb3IubmV4dChza2lwKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gKHZhbHVlLmxlbmd0aCArIHNraXApICogZGlyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUubGVuZ3RoIDw9IGxpbWl0ID8gdmFsdWUgOiBkaXIgPCAwID8gdmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gbGltaXQpIDogdmFsdWUuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgICB0aGlzLmRvbmUgPSAhdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgaWYgKHNraXAgPCAwKVxuICAgICAgICAgICAgc2tpcCA9IE1hdGgubWF4KHNraXAsIHRoaXMuZnJvbSAtIHRoaXMucG9zKTtcbiAgICAgICAgZWxzZSBpZiAoc2tpcCA+IDApXG4gICAgICAgICAgICBza2lwID0gTWF0aC5taW4oc2tpcCwgdGhpcy50byAtIHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dElubmVyKHNraXAsIHRoaXMuY3Vyc29yLmRpcik7XG4gICAgfVxuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiB0aGlzLmN1cnNvci5saW5lQnJlYWsgJiYgdGhpcy52YWx1ZSAhPSBcIlwiOyB9XG59XG5jbGFzcyBMaW5lQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lcikge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IHRydWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBsZXQgeyBkb25lLCBsaW5lQnJlYWssIHZhbHVlIH0gPSB0aGlzLmlubmVyLm5leHQoc2tpcCk7XG4gICAgICAgIGlmIChkb25lICYmIHRoaXMuYWZ0ZXJCcmVhaykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZUJyZWFrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZnRlckJyZWFrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFRleHQucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLml0ZXIoKTsgfTtcbiAgICBSYXdUZXh0Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gUGFydGlhbFRleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxuICAgICAgICBMaW5lQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbn1cbi8qKlxuVGhpcyB0eXBlIGRlc2NyaWJlcyBhIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBJdCBpcyBjcmVhdGVkXG5vbi1kZW1hbmQgd2hlbiBsaW5lcyBhcmUgW3F1ZXJpZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dC5saW5lQXQpLlxuKi9cbmNsYXNzIExpbmUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIChfYmVmb3JlXyB0aGUgbGluZSBicmVhayxcbiAgICBvciBhdCB0aGUgZW5kIG9mIGRvY3VtZW50IGZvciB0aGUgbGFzdCBsaW5lKS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGlzIGxpbmUncyBsaW5lIG51bWJlciAoMS1iYXNlZCkuXG4gICAgKi9cbiAgICBudW1iZXIsIFxuICAgIC8qKlxuICAgIFRoZSBsaW5lJ3MgY29udGVudC5cbiAgICAqL1xuICAgIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgbGluZSAobm90IGluY2x1ZGluZyBhbnkgbGluZSBicmVhayBhZnRlciBpdCkuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50byAtIHRoaXMuZnJvbTsgfVxufVxuZnVuY3Rpb24gY2xpcCh0ZXh0LCBmcm9tLCB0bykge1xuICAgIGZyb20gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgZnJvbSkpO1xuICAgIHJldHVybiBbZnJvbSwgTWF0aC5tYXgoZnJvbSwgTWF0aC5taW4odGV4dC5sZW5ndGgsIHRvKSldO1xufVxuXG4vLyBDb21wcmVzc2VkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHcmFwaGVtZV9DbHVzdGVyX0JyZWFrPUV4dGVuZFxuLy8gaW5mb3JtYXRpb24gZnJvbVxuLy8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvMTMuMC4wL3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Byb3BlcnR5LnR4dC5cbi8vIEVhY2ggcGFpciBvZiBlbGVtZW50cyByZXByZXNlbnRzIGEgcmFuZ2UsIGFzIGFuIG9mZmV0IGZyb20gdGhlXG4vLyBwcmV2aW91cyByYW5nZSBhbmQgYSBsZW5ndGguIE51bWJlcnMgYXJlIGluIGJhc2UtMzYsIHdpdGggdGhlIGVtcHR5XG4vLyBzdHJpbmcgYmVpbmcgYSBzaG9ydGhhbmQgZm9yIDEuXG5sZXQgZXh0ZW5kID0gLypAX19QVVJFX18qL1wibGMsMzQsN24sNyw3YiwxOSwsLCwyLCwyLCwsMjAsYiwxYyxsLGcsLDJ0LDcsMiw2LDIsMiwsNCx6LCx1LHIsMmosYiwxbSw5LDksLG8sNCwsOSwsMywsNSwxNywzLDNiLGYsLHcsMWosLCwsNCw4LDQsLDMsNyxhLDIsdCwsMW0sLCwsMiw0LDgsLDksLGEsMixxLCwyLDIsMWwsLDQsMiw0LDIsMiwzLDMsLHUsMiwzLCxiLDIsMWwsLDQsNSwsMiw0LCxrLDIsbSw2LCwsMW0sLCwyLCw0LDgsLDcsMyxhLDIsdSwsMW4sLCwsYywsOSwsMTQsLDMsLDFsLDMsNSwzLCw0LDcsMixiLDIsdCwsMW0sLDIsLDIsLDMsLDUsMiw3LDIsYiwyLHMsMiwxbCwyLCwsMiw0LDgsLDksLGEsMix0LCwyMCwsNCwsMiwzLCwsOCwsMjksLDIsNyxjLDgsMnEsLDIsOSxiLDYsMjIsMixyLCwsLCwsMWosZSwsNSwsMiw1LGIsLDEwLDksLDJ1LDQsLDYsLDIsMiwyLHAsMiw0LDMsZyw0LGQsLDIsMiw2LCxmLCxqaiwzLHFhLDMsdCwzLHQsMix1LDIsMXMsMiwsNyw4LCwyLGIsOSwsMTksMywzYiwyLHksLDNhLDMsNCwyLDksLDYsMyw2MywyLDIsLDFtLCwsNywsLCwsMiw4LDYsYSwyLCwxYyxoLDFyLDQsMWMsNywsLDUsLDE0LDksYywyLHcsNCwyLDIsLDMsMWssLCwyLDMsLCwzLDFtLDgsMiwyLDQ4LDMsLGQsLDcsNCwsNiwsMywyLDVpLDFtLCw1LGVrLCw1Zix4LDJkYSwzLDN4LCwybyx3LGZlLDYsMngsMixuOXcsNCwsYSx3LDIsMjgsMiw3aywsMywsNCwscCwyLDUsLDQ3LDIscSxpLGQsLDEyLDgscCxiLDFhLDMsMWMsLDIsNCwyLDIsMTMsLDF2LDYsMiwyLDIsMixjLCw4LCwxYiwsMWYsLCwzLDIsMiw1LDIsLCwxNiwyLDgsLDZtLCwyLCw0LCxmbjQsLGtoLGcsZyxnLGE2LDIsZ3QsLDZhLCw0NSw1LDFhZSwzLCwyLDUsNCwxNCwzLDQsLDRsLDIsZngsNCxhciwyLDQ5LGIsNHcsLDFpLGYsMWssMywxZCw0LDIsMiwxeCwzLDEwLDUsLDgsMXEsLGMsMiwxZyw5LGEsNCwyLCwybiwzLDIsLCwyLDYsLDRnLCwzLDgsbCwyLDFsLDIsLCwsLG0sLGUsNywzLDUsNWYsOCwyLDMsLCxuLCwyOSwsMiw2LCwsMiwsLDIsLDIsNmosLDIsNCw2LDIsLDIsciwyLDJkLDgsMiwsLDIsMnksLCwsMiw2LCwsMnQsMywyLDQsLDUsNzcsOSwsMiw2dCwsYSwyLCwsNCwsNDAsNCwyLDIsNCwsdyxhLDE0LDYsMiw0LDgsLDksNiwyLDMsMWEsZCwsMixiYSw3LCw2LCwsMmEsbSwyLDcsLDIsLDIsM2UsNiwzLCwsMiwsNywsLDIwLDIsMywsLCw5biwyLGYwYiw1LDFuLDcsdDQsLDFyLDQsMjksLGY1aywyLDQzcSwsLDMsNCw1LDgsOCwyLDcsdSw0LDQ0LDMsMWl6LDFqLDQsMWUsOCwsZSwsbSw1LCxmLDExcyw3LCxoLDIsNywsMiwsNSw3OSw3LGM1LDQsMTVzLDcsMzEsNywyNDAsNSxneDdrLDJvLDNrLDZvXCIuc3BsaXQoXCIsXCIpLm1hcChzID0+IHMgPyBwYXJzZUludChzLCAzNikgOiAxKTtcbi8vIENvbnZlcnQgb2Zmc2V0cyBpbnRvIGFic29sdXRlIHZhbHVlc1xuZm9yIChsZXQgaSA9IDE7IGkgPCBleHRlbmQubGVuZ3RoOyBpKyspXG4gICAgZXh0ZW5kW2ldICs9IGV4dGVuZFtpIC0gMV07XG5mdW5jdGlvbiBpc0V4dGVuZGluZ0NoYXIoY29kZSkge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZXh0ZW5kLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBpZiAoZXh0ZW5kW2ldID4gY29kZSlcbiAgICAgICAgICAgIHJldHVybiBleHRlbmRbaSAtIDFdIDw9IGNvZGU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNSZWdpb25hbEluZGljYXRvcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHgxRjFFNiAmJiBjb2RlIDw9IDB4MUYxRkY7XG59XG5jb25zdCBaV0ogPSAweDIwMGQ7XG4vKipcblJldHVybnMgYSBuZXh0IGdyYXBoZW1lIGNsdXN0ZXIgYnJlYWsgX2FmdGVyXyAobm90IGVxdWFsIHRvKVxuYHBvc2AsIGlmIGBmb3J3YXJkYCBpcyB0cnVlLCBvciBiZWZvcmUgb3RoZXJ3aXNlLiBSZXR1cm5zIGBwb3NgXG5pdHNlbGYgaWYgbm8gZnVydGhlciBjbHVzdGVyIGJyZWFrIGlzIGF2YWlsYWJsZSBpbiB0aGUgc3RyaW5nLlxuTW92ZXMgYWNyb3NzIHN1cnJvZ2F0ZSBwYWlycywgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgKHdoZW5cbmBpbmNsdWRlRXh0ZW5kaW5nYCBpcyB0cnVlKSwgY2hhcmFjdGVycyBqb2luZWQgd2l0aCB6ZXJvLXdpZHRoXG5qb2luZXJzLCBhbmQgZmxhZyBlbW9qaS5cbiovXG5mdW5jdGlvbiBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgcG9zLCBmb3J3YXJkID0gdHJ1ZSwgaW5jbHVkZUV4dGVuZGluZyA9IHRydWUpIHtcbiAgICByZXR1cm4gKGZvcndhcmQgPyBuZXh0Q2x1c3RlckJyZWFrIDogcHJldkNsdXN0ZXJCcmVhaykoc3RyLCBwb3MsIGluY2x1ZGVFeHRlbmRpbmcpO1xufVxuZnVuY3Rpb24gbmV4dENsdXN0ZXJCcmVhayhzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZykge1xuICAgIGlmIChwb3MgPT0gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICAvLyBJZiBwb3MgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLCBtb3ZlIHRvIGl0cyBzdGFydFxuICAgIGlmIChwb3MgJiYgc3Vycm9nYXRlTG93KHN0ci5jaGFyQ29kZUF0KHBvcykpICYmIHN1cnJvZ2F0ZUhpZ2goc3RyLmNoYXJDb2RlQXQocG9zIC0gMSkpKVxuICAgICAgICBwb3MtLTtcbiAgICBsZXQgcHJldiA9IGNvZGVQb2ludEF0KHN0ciwgcG9zKTtcbiAgICBwb3MgKz0gY29kZVBvaW50U2l6ZShwcmV2KTtcbiAgICB3aGlsZSAocG9zIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IGNvZGVQb2ludEF0KHN0ciwgcG9zKTtcbiAgICAgICAgaWYgKHByZXYgPT0gWldKIHx8IG5leHQgPT0gWldKIHx8IGluY2x1ZGVFeHRlbmRpbmcgJiYgaXNFeHRlbmRpbmdDaGFyKG5leHQpKSB7XG4gICAgICAgICAgICBwb3MgKz0gY29kZVBvaW50U2l6ZShuZXh0KTtcbiAgICAgICAgICAgIHByZXYgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVnaW9uYWxJbmRpY2F0b3IobmV4dCkpIHtcbiAgICAgICAgICAgIGxldCBjb3VudEJlZm9yZSA9IDAsIGkgPSBwb3MgLSAyO1xuICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBpc1JlZ2lvbmFsSW5kaWNhdG9yKGNvZGVQb2ludEF0KHN0ciwgaSkpKSB7XG4gICAgICAgICAgICAgICAgY291bnRCZWZvcmUrKztcbiAgICAgICAgICAgICAgICBpIC09IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY291bnRCZWZvcmUgJSAyID09IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuZnVuY3Rpb24gcHJldkNsdXN0ZXJCcmVhayhzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZykge1xuICAgIHdoaWxlIChwb3MgPiAwKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IG5leHRDbHVzdGVyQnJlYWsoc3RyLCBwb3MgLSAyLCBpbmNsdWRlRXh0ZW5kaW5nKTtcbiAgICAgICAgaWYgKGZvdW5kIDwgcG9zKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICBwb3MtLTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBzdXJyb2dhdGVMb3coY2gpIHsgcmV0dXJuIGNoID49IDB4REMwMCAmJiBjaCA8IDB4RTAwMDsgfVxuZnVuY3Rpb24gc3Vycm9nYXRlSGlnaChjaCkgeyByZXR1cm4gY2ggPj0gMHhEODAwICYmIGNoIDwgMHhEQzAwOyB9XG4vKipcbkZpbmQgdGhlIGNvZGUgcG9pbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGluIGEgc3RyaW5nIChsaWtlIHRoZVxuW2Bjb2RlUG9pbnRBdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9jb2RlUG9pbnRBdClcbnN0cmluZyBtZXRob2QpLlxuKi9cbmZ1bmN0aW9uIGNvZGVQb2ludEF0KHN0ciwgcG9zKSB7XG4gICAgbGV0IGNvZGUwID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIXN1cnJvZ2F0ZUhpZ2goY29kZTApIHx8IHBvcyArIDEgPT0gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGNvZGUwO1xuICAgIGxldCBjb2RlMSA9IHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmICghc3Vycm9nYXRlTG93KGNvZGUxKSlcbiAgICAgICAgcmV0dXJuIGNvZGUwO1xuICAgIHJldHVybiAoKGNvZGUwIC0gMHhkODAwKSA8PCAxMCkgKyAoY29kZTEgLSAweGRjMDApICsgMHgxMDAwMDtcbn1cbi8qKlxuR2l2ZW4gYSBVbmljb2RlIGNvZGVwb2ludCwgcmV0dXJuIHRoZSBKYXZhU2NyaXB0IHN0cmluZyB0aGF0XG5yZXNwcmVzZW50cyBpdCAobGlrZVxuW2BTdHJpbmcuZnJvbUNvZGVQb2ludGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9mcm9tQ29kZVBvaW50KSkuXG4qL1xuZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhkODAwLCAoY29kZSAmIDEwMjMpICsgMHhkYzAwKTtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiBwb3NpdGlvbnMgYSBjaGFyYWN0ZXIgdGFrZXMgdXAgYSBKYXZhU2NyaXB0IHN0cmluZy5cbiovXG5mdW5jdGlvbiBjb2RlUG9pbnRTaXplKGNvZGUpIHsgcmV0dXJuIGNvZGUgPCAweDEwMDAwID8gMSA6IDI7IH1cblxuY29uc3QgRGVmYXVsdFNwbGl0ID0gL1xcclxcbj98XFxuLztcbi8qKlxuRGlzdGluZ3Vpc2hlcyBkaWZmZXJlbnQgd2F5cyBpbiB3aGljaCBwb3NpdGlvbnMgY2FuIGJlIG1hcHBlZC5cbiovXG52YXIgTWFwTW9kZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE1hcE1vZGUpIHtcbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0byBhIHZhbGlkIG5ldyBwb3NpdGlvbiwgZXZlbiB3aGVuIGl0cyBjb250ZXh0XG4gICAgd2FzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJTaW1wbGVcIl0gPSAwXSA9IFwiU2ltcGxlXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgZGVsZXRpb24gaGFwcGVucyBhY3Jvc3MgdGhlIHBvc2l0aW9uLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tEZWxcIl0gPSAxXSA9IFwiVHJhY2tEZWxcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiB0aGUgY2hhcmFjdGVyIF9iZWZvcmVfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tCZWZvcmVcIl0gPSAyXSA9IFwiVHJhY2tCZWZvcmVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiB0aGUgY2hhcmFjdGVyIF9hZnRlcl8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0FmdGVyXCJdID0gM10gPSBcIlRyYWNrQWZ0ZXJcIjtcbnJldHVybiBNYXBNb2RlfSkoTWFwTW9kZSB8fCAoTWFwTW9kZSA9IHt9KSk7XG4vKipcbkEgY2hhbmdlIGRlc2NyaXB0aW9uIGlzIGEgdmFyaWFudCBvZiBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpXG50aGF0IGRvZXNuJ3Qgc3RvcmUgdGhlIGluc2VydGVkIHRleHQuIEFzIHN1Y2gsIGl0IGNhbid0IGJlXG5hcHBsaWVkLCBidXQgaXMgY2hlYXBlciB0byBzdG9yZSBhbmQgbWFuaXB1bGF0ZS5cbiovXG5jbGFzcyBDaGFuZ2VEZXNjIHtcbiAgICAvLyBTZWN0aW9ucyBhcmUgZW5jb2RlZCBhcyBwYWlycyBvZiBpbnRlZ2Vycy4gVGhlIGZpcnN0IGlzIHRoZVxuICAgIC8vIGxlbmd0aCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCwgYW5kIHRoZSBzZWNvbmQgaXMgLTEgZm9yXG4gICAgLy8gdW5hZmZlY3RlZCBzZWN0aW9ucywgYW5kIHRoZSBsZW5ndGggb2YgdGhlIHJlcGxhY2VtZW50IGNvbnRlbnRcbiAgICAvLyBvdGhlcndpc2UuIFNvIGFuIGluc2VydGlvbiB3b3VsZCBiZSAoMCwgbj4wKSwgYSBkZWxldGlvbiAobj4wLFxuICAgIC8vIDApLCBhbmQgYSByZXBsYWNlbWVudCB0d28gcG9zaXRpdmUgbnVtYmVycy5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zZWN0aW9uc1tpXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBuZXdMZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbnMgPCAwID8gdGhpcy5zZWN0aW9uc1tpXSA6IGlucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBGYWxzZSB3aGVuIHRoZXJlIGFyZSBhY3R1YWwgY2hhbmdlcyBpbiB0aGlzIHNldC5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDAgfHwgdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMiAmJiB0aGlzLnNlY3Rpb25zWzFdIDwgMDsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdW5jaGFuZ2VkIHBhcnRzIGxlZnQgYnkgdGhlc2UgY2hhbmdlcy4gYHBvc0FgXG4gICAgcHJvdmlkZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSByYW5nZSBpbiB0aGUgb2xkIGRvY3VtZW50LCBgcG9zQmBcbiAgICB0aGUgbmV3IHBvc2l0aW9uIGluIHRoZSBjaGFuZ2VkIGRvY3VtZW50LlxuICAgICovXG4gICAgaXRlckdhcHMoZikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgICAgIGYocG9zQSwgcG9zQiwgbGVuKTtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgY2hhbmdlZCBieSB0aGVzZSBjaGFuZ2VzLiAoU2VlXG4gICAgW2BDaGFuZ2VTZXQuaXRlckNoYW5nZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldC5pdGVyQ2hhbmdlcykgZm9yIGFcbiAgICB2YXJpYW50IHRoYXQgYWxzbyBwcm92aWRlcyB5b3Ugd2l0aCB0aGUgaW5zZXJ0ZWQgdGV4dC4pXG4gICAgYGZyb21BYC9gdG9BYCBwcm92aWRlcyB0aGUgZXh0ZW50IG9mIHRoZSBjaGFuZ2UgaW4gdGhlIHN0YXJ0aW5nXG4gICAgZG9jdW1lbnQsIGBmcm9tQmAvYHRvQmAgdGhlIGV4dGVudCBvZiB0aGUgcmVwbGFjZW1lbnQgaW4gdGhlXG4gICAgY2hhbmdlZCBkb2N1bWVudC5cbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzICh3aGljaCBhcmUga2VwdFxuICAgIHNlcGFyYXRlIGZvciBbcG9zaXRpb24gbWFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLm1hcFBvcykpIGFyZVxuICAgIHJlcG9ydGVkIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlZFJhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnZlcnRlZCBmb3JtIG9mIHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBnZXQgaW52ZXJ0ZWREZXNjKCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goaW5zLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhcHBseWluZyBhbm90aGVyIHNldCBvZiBjaGFuZ2VzXG4gICAgYWZ0ZXIgdGhpcyBvbmUuIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoaXMgc2V0IHNob3VsZFxuICAgIG1hdGNoIHRoZSBsZW5ndGggYmVmb3JlIGBvdGhlcmAuXG4gICAgKi9cbiAgICBjb21wb3NlRGVzYyhvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIpOyB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZGVzY3JpcHRpb24sIHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIHRoZSBzYW1lIGRvY3VtZW50XG4gICAgYXMgYG90aGVyYCwgb3ZlciBhbm90aGVyIHNldCBvZiBjaGFuZ2VzLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGFwcGxpZWQgYWZ0ZXIgaXQuIFdoZW4gYGJlZm9yZWAgaXMgdHJ1ZSwgbWFwIGFzIGlmIHRoZSBjaGFuZ2VzXG4gICAgaW4gYG90aGVyYCBoYXBwZW5lZCBiZWZvcmUgdGhlIG9uZXMgaW4gYHRoaXNgLlxuICAgICovXG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlKTsgfVxuICAgIG1hcFBvcyhwb3MsIGFzc29jID0gLTEsIG1vZGUgPSBNYXBNb2RlLlNpbXBsZSkge1xuICAgICAgICBsZXQgcG9zQSA9IDAsIHBvc0IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmRBID0gcG9zQSArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEEgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NCICsgKHBvcyAtIHBvc0EpO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgIT0gTWFwTW9kZS5TaW1wbGUgJiYgZW5kQSA+PSBwb3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1vZGUgPT0gTWFwTW9kZS5UcmFja0RlbCAmJiBwb3NBIDwgcG9zICYmIGVuZEEgPiBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0JlZm9yZSAmJiBwb3NBIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tBZnRlciAmJiBlbmRBID4gcG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEEgPiBwb3MgfHwgZW5kQSA9PSBwb3MgJiYgYXNzb2MgPCAwICYmICFsZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPT0gcG9zQSB8fCBhc3NvYyA8IDAgPyBwb3NCIDogcG9zQiArIGlucztcbiAgICAgICAgICAgICAgICBwb3NCICs9IGlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPiBwb3NBKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBvc2l0aW9uICR7cG9zfSBpcyBvdXQgb2YgcmFuZ2UgZm9yIGNoYW5nZXNldCBvZiBsZW5ndGggJHtwb3NBfWApO1xuICAgICAgICByZXR1cm4gcG9zQjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGVzZSBjaGFuZ2VzIHRvdWNoIGEgZ2l2ZW4gcmFuZ2UuIFdoZW4gb25lIG9mIHRoZVxuICAgIGNoYW5nZXMgZW50aXJlbHkgY292ZXJzIHRoZSByYW5nZSwgdGhlIHN0cmluZyBgXCJjb3ZlclwiYCBpc1xuICAgIHJldHVybmVkLlxuICAgICovXG4gICAgdG91Y2hlc1JhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoICYmIHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgZW5kID0gcG9zICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwICYmIHBvcyA8PSB0byAmJiBlbmQgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zIDwgZnJvbSAmJiBlbmQgPiB0byA/IFwiY292ZXJcIiA6IHRydWU7XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAocmVzdWx0ID8gXCIgXCIgOiBcIlwiKSArIGxlbiArIChpbnMgPj0gMCA/IFwiOlwiICsgaW5zIDogXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIGRlc2MgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIGRlc2MgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWRcbiAgICBieSBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYy50b0pTT04pLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24pIHx8IGpzb24ubGVuZ3RoICUgMiB8fCBqc29uLnNvbWUoYSA9PiB0eXBlb2YgYSAhPSBcIm51bWJlclwiKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZURlc2NcIik7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHNlY3Rpb25zKSB7IHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7IH1cbn1cbi8qKlxuQSBjaGFuZ2Ugc2V0IHJlcHJlc2VudHMgYSBncm91cCBvZiBtb2RpZmljYXRpb25zIHRvIGEgZG9jdW1lbnQuIEl0XG5zdG9yZXMgdGhlIGRvY3VtZW50IGxlbmd0aCwgYW5kIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gZG9jdW1lbnRzXG53aXRoIGV4YWN0bHkgdGhhdCBsZW5ndGguXG4qL1xuY2xhc3MgQ2hhbmdlU2V0IGV4dGVuZHMgQ2hhbmdlRGVzYyB7XG4gICAgY29uc3RydWN0b3Ioc2VjdGlvbnMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0ZWQpIHtcbiAgICAgICAgc3VwZXIoc2VjdGlvbnMpO1xuICAgICAgICB0aGlzLmluc2VydGVkID0gaW5zZXJ0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBjaGFuZ2VzIHRvIGEgZG9jdW1lbnQsIHJldHVybmluZyB0aGUgbW9kaWZpZWRcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT0gZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgY2hhbmdlIHNldCB0byBhIGRvY3VtZW50IHdpdGggdGhlIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgKGZyb21BLCB0b0EsIGZyb21CLCBfdG9CLCB0ZXh0KSA9PiBkb2MgPSBkb2MucmVwbGFjZShmcm9tQiwgZnJvbUIgKyAodG9BIC0gZnJvbUEpLCB0ZXh0KSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgR2l2ZW4gdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgX2JlZm9yZV8gdGhlIGNoYW5nZXMsIHJldHVybiBhXG4gICAgY2hhbmdlIHNldCB0aGF0IHJlcHJlc2VudHMgdGhlIGludmVyc2Ugb2YgdGhpcyBzZXQsIHdoaWNoIGNvdWxkXG4gICAgYmUgdXNlZCB0byBnbyBmcm9tIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IHRoZSBjaGFuZ2VzIGJhY2sgdG9cbiAgICB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBiZWZvcmUgdGhlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IHRoaXMuc2VjdGlvbnMuc2xpY2UoKSwgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHNlY3Rpb25zW2ldLCBpbnMgPSBzZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBpZiAoaW5zID49IDApIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uc1tpXSA9IGlucztcbiAgICAgICAgICAgICAgICBzZWN0aW9uc1tpICsgMV0gPSBsZW47XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gaSA+PiAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnNlcnRlZC5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKGxlbiA/IGRvYy5zbGljZShwb3MsIHBvcyArIGxlbikgOiBUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tYmluZSB0d28gc3Vic2VxdWVudCBjaGFuZ2Ugc2V0cyBpbnRvIGEgc2luZ2xlIHNldC4gYG90aGVyYFxuICAgIG11c3Qgc3RhcnQgaW4gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGB0aGlzYC4gSWYgYHRoaXNgIGdvZXNcbiAgICBgZG9jQWAg4oaSIGBkb2NCYCBhbmQgYG90aGVyYCByZXByZXNlbnRzIGBkb2NCYCDihpIgYGRvY0NgLCB0aGVcbiAgICByZXR1cm5lZCB2YWx1ZSB3aWxsIHJlcHJlc2VudCB0aGUgY2hhbmdlIGBkb2NBYCDihpIgYGRvY0NgLlxuICAgICovXG4gICAgY29tcG9zZShvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYW5vdGhlciBjaGFuZ2Ugc2V0IHN0YXJ0aW5nIGluIHRoZSBzYW1lIGRvY3VtZW50LCBtYXBzIHRoaXNcbiAgICBjaGFuZ2Ugc2V0IG92ZXIgdGhlIG90aGVyLCBwcm9kdWNpbmcgYSBuZXcgY2hhbmdlIHNldCB0aGF0IGNhbiBiZVxuICAgIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGFwcGx5aW5nIGBvdGhlcmAuIFdoZW5cbiAgICBgYmVmb3JlYCBpcyBgdHJ1ZWAsIG9yZGVyIGNoYW5nZXMgYXMgaWYgYHRoaXNgIGNvbWVzIGJlZm9yZVxuICAgIGBvdGhlcmAsIG90aGVyd2lzZSAodGhlIGRlZmF1bHQpIHRyZWF0IGBvdGhlcmAgYXMgY29taW5nIGZpcnN0LlxuICAgIFxuICAgIEdpdmVuIHR3byBjaGFuZ2VzIGBBYCBhbmQgYEJgLCBgQS5jb21wb3NlKEIubWFwKEEpKWAgYW5kXG4gICAgYEIuY29tcG9zZShBLm1hcChCLCB0cnVlKSlgIHdpbGwgcHJvZHVjZSB0aGUgc2FtZSBkb2N1bWVudC4gVGhpc1xuICAgIHByb3ZpZGVzIGEgYmFzaWMgZm9ybSBvZiBbb3BlcmF0aW9uYWxcbiAgICB0cmFuc2Zvcm1hdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0aW9uYWxfdHJhbnNmb3JtYXRpb24pLFxuICAgIGFuZCBjYW4gYmUgdXNlZCBmb3IgY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuICAgICovXG4gICAgbWFwKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbiB0aGUgZG9jdW1lbnQsIGNhbGxpbmcgYGZgIGZvclxuICAgIGVhY2gsIHdpdGggdGhlIHJhbmdlIGluIHRoZSBvcmlnaW5hbCBkb2N1bWVudCAoYGZyb21BYC1gdG9BYClcbiAgICBhbmQgdGhlIHJhbmdlIHRoYXQgcmVwbGFjZXMgaXQgaW4gdGhlIG5ldyBkb2N1bWVudFxuICAgIChgZnJvbUJgLWB0b0JgKS5cbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzIGFyZSByZXBvcnRlZFxuICAgIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtjaGFuZ2UgZGVzY3JpcHRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYykgZm9yIHRoaXMgY2hhbmdlXG4gICAgc2V0LlxuICAgICovXG4gICAgZ2V0IGRlc2MoKSB7IHJldHVybiBDaGFuZ2VEZXNjLmNyZWF0ZSh0aGlzLnNlY3Rpb25zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyKHJhbmdlcykge1xuICAgICAgICBsZXQgcmVzdWx0U2VjdGlvbnMgPSBbXSwgcmVzdWx0SW5zZXJ0ZWQgPSBbXSwgZmlsdGVyZWRTZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgaXRlciA9IG5ldyBTZWN0aW9uSXRlcih0aGlzKTtcbiAgICAgICAgZG9uZTogZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHJhbmdlcy5sZW5ndGggPyAxZTkgOiByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBuZXh0IHx8IHBvcyA9PSBuZXh0ICYmIGl0ZXIubGVuID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgbmV4dCAtIHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihmaWx0ZXJlZFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zID0gaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDA7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCBpbnMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgPiAwKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQocmVzdWx0SW5zZXJ0ZWQsIHJlc3VsdFNlY3Rpb25zLCBpdGVyLnRleHQpO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZW5kID0gcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIGVuZCAtIHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihmaWx0ZXJlZFNlY3Rpb25zLCBsZW4sIGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwKTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IG5ldyBDaGFuZ2VTZXQocmVzdWx0U2VjdGlvbnMsIHJlc3VsdEluc2VydGVkKSxcbiAgICAgICAgICAgIGZpbHRlcmVkOiBDaGFuZ2VEZXNjLmNyZWF0ZShmaWx0ZXJlZFNlY3Rpb25zKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2Ugc2V0IHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBpZiAoaW5zIDwgMClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGxlbik7XG4gICAgICAgICAgICBlbHNlIGlmIChpbnMgPT0gMClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dLmNvbmNhdCh0aGlzLmluc2VydGVkW2kgPj4gMV0udG9KU09OKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBzZXQgZm9yIHRoZSBnaXZlbiBjaGFuZ2VzLCBmb3IgYSBkb2N1bWVudCBvZiB0aGVcbiAgICBnaXZlbiBsZW5ndGgsIHVzaW5nIGBsaW5lU2VwYCBhcyBsaW5lIHNlcGFyYXRvci5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihjaGFuZ2VzLCBsZW5ndGgsIGxpbmVTZXApIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW10sIHBvcyA9IDA7XG4gICAgICAgIGxldCB0b3RhbCA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghZm9yY2UgJiYgIXNlY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocG9zIDwgbGVuZ3RoKVxuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbmd0aCAtIHBvcywgLTEpO1xuICAgICAgICAgICAgbGV0IHNldCA9IG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNldC5tYXAodG90YWwpKSA6IHNldDtcbiAgICAgICAgICAgIHNlY3Rpb25zID0gW107XG4gICAgICAgICAgICBpbnNlcnRlZCA9IFtdO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzKHNwZWMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNwZWMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHNwZWMpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3Moc3ViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5sZW5ndGggIT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aCAoZ290ICR7c3BlYy5sZW5ndGh9LCBleHBlY3RlZCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzcGVjLm1hcCh0b3RhbCkpIDogc3BlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvID0gZnJvbSwgaW5zZXJ0IH0gPSBzcGVjO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gdG8gfHwgZnJvbSA8IDAgfHwgdG8gPiBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNoYW5nZSByYW5nZSAke2Zyb219IHRvICR7dG99IChpbiBkb2Mgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zVGV4dCA9ICFpbnNlcnQgPyBUZXh0LmVtcHR5IDogdHlwZW9mIGluc2VydCA9PSBcInN0cmluZ1wiID8gVGV4dC5vZihpbnNlcnQuc3BsaXQobGluZVNlcCB8fCBEZWZhdWx0U3BsaXQpKSA6IGluc2VydDtcbiAgICAgICAgICAgICAgICBsZXQgaW5zTGVuID0gaW5zVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8gJiYgaW5zTGVuID09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgZnJvbSAtIHBvcywgLTEpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIHRvIC0gZnJvbSwgaW5zTGVuKTtcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0ZWQsIHNlY3Rpb25zLCBpbnNUZXh0KTtcbiAgICAgICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzKGNoYW5nZXMpO1xuICAgICAgICBmbHVzaCghdG90YWwpO1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBjaGFuZ2VzZXQgb2YgdGhlIGdpdmVuIGxlbmd0aC5cbiAgICAqL1xuICAgIHN0YXRpYyBlbXB0eShsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQobGVuZ3RoID8gW2xlbmd0aCwgLTFdIDogW10sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlc2V0IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gKGFzIHByb2R1Y2VkIGJ5XG4gICAgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldC50b0pTT04pLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcGFydCA9IGpzb25baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocGFydCkgfHwgdHlwZW9mIHBhcnRbMF0gIT0gXCJudW1iZXJcIiB8fCBwYXJ0LnNvbWUoKGUsIGkpID0+IGkgJiYgdHlwZW9mIGUgIT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnNlcnRlZC5sZW5ndGggPCBpKVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkW2ldID0gVGV4dC5vZihwYXJ0LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnRbMF0sIGluc2VydGVkW2ldLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zLCBmb3JjZUpvaW4gPSBmYWxzZSkge1xuICAgIGlmIChsZW4gPT0gMCAmJiBpbnMgPD0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBsYXN0ID0gc2VjdGlvbnMubGVuZ3RoIC0gMjtcbiAgICBpZiAobGFzdCA+PSAwICYmIGlucyA8PSAwICYmIGlucyA9PSBzZWN0aW9uc1tsYXN0ICsgMV0pXG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICBlbHNlIGlmIChsZW4gPT0gMCAmJiBzZWN0aW9uc1tsYXN0XSA9PSAwKVxuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIGVsc2UgaWYgKGZvcmNlSm9pbikge1xuICAgICAgICBzZWN0aW9uc1tsYXN0XSArPSBsZW47XG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG59XG5mdW5jdGlvbiBhZGRJbnNlcnQodmFsdWVzLCBzZWN0aW9ucywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgaW5kZXggPSAoc2VjdGlvbnMubGVuZ3RoIC0gMikgPj4gMTtcbiAgICBpZiAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0gPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdLmFwcGVuZCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAodmFsdWVzLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgdmFsdWVzLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyQ2hhbmdlcyhkZXNjLCBmLCBpbmRpdmlkdWFsKSB7XG4gICAgbGV0IGluc2VydGVkID0gZGVzYy5pbnNlcnRlZDtcbiAgICBmb3IgKGxldCBwb3NBID0gMCwgcG9zQiA9IDAsIGkgPSAwOyBpIDwgZGVzYy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK10sIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgIHBvc0EgKz0gbGVuO1xuICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZW5kQSA9IHBvc0EsIGVuZEIgPSBwb3NCLCB0ZXh0ID0gVGV4dC5lbXB0eTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBlbmRBICs9IGxlbjtcbiAgICAgICAgICAgICAgICBlbmRCICs9IGlucztcbiAgICAgICAgICAgICAgICBpZiAoaW5zICYmIGluc2VydGVkKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5hcHBlbmQoaW5zZXJ0ZWRbKGkgLSAyKSA+PiAxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGl2aWR1YWwgfHwgaSA9PSBkZXNjLnNlY3Rpb25zLmxlbmd0aCB8fCBkZXNjLnNlY3Rpb25zW2kgKyAxXSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgICAgICBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmKHBvc0EsIGVuZEEsIHBvc0IsIGVuZEIsIHRleHQpO1xuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgICAgICBwb3NCID0gZW5kQjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFNldChzZXRBLCBzZXRCLCBiZWZvcmUsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICAvLyBQcm9kdWNlIGEgY29weSBvZiBzZXRBIHRoYXQgYXBwbGllcyB0byB0aGUgZG9jdW1lbnQgYWZ0ZXIgc2V0QlxuICAgIC8vIGhhcyBiZWVuIGFwcGxpZWQgKGFzc3VtaW5nIGJvdGggc3RhcnQgYXQgdGhlIHNhbWUgZG9jdW1lbnQpLlxuICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnQgPSBta1NldCA/IFtdIDogbnVsbDtcbiAgICBsZXQgYSA9IG5ldyBTZWN0aW9uSXRlcihzZXRBKSwgYiA9IG5ldyBTZWN0aW9uSXRlcihzZXRCKTtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYm90aCBzZXRzIGluIHBhcmFsbGVsLiBpbnNlcnRlZCB0cmFja3MsIGZvciBjaGFuZ2VzXG4gICAgLy8gaW4gQSB0aGF0IGhhdmUgdG8gYmUgcHJvY2Vzc2VkIHBpZWNlLWJ5LXBpZWNlLCB3aGV0aGVyIHRoZWlyXG4gICAgLy8gY29udGVudCBoYXMgYmVlbiBpbnNlcnRlZCBhbHJlYWR5LCBhbmQgcmVmZXJzIHRvIHRoZSBzZWN0aW9uXG4gICAgLy8gaW5kZXguXG4gICAgZm9yIChsZXQgaW5zZXJ0ZWQgPSAtMTs7KSB7XG4gICAgICAgIGlmIChhLmlucyA9PSAtMSAmJiBiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgLy8gTW92ZSBhY3Jvc3MgcmFuZ2VzIHNraXBwZWQgYnkgYm90aCBzZXRzLlxuICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuLCBiLmxlbik7XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgIGEuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5pbnMgPj0gMCAmJiAoYS5pbnMgPCAwIHx8IGluc2VydGVkID09IGEuaSB8fCBhLm9mZiA9PSAwICYmIChiLmxlbiA8IGEubGVuIHx8IGIubGVuID09IGEubGVuICYmICFiZWZvcmUpKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIGNoYW5nZSBpbiBCIHRoYXQgY29tZXMgYmVmb3JlIHRoZSBuZXh0IGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gQSAob3JkZXJlZCBieSBzdGFydCBwb3MsIHRoZW4gbGVuLCB0aGVuIGJlZm9yZSBmbGFnKSwgc2tpcFxuICAgICAgICAgICAgLy8gdGhhdCAoYW5kIHByb2Nlc3MgYW55IGNoYW5nZXMgaW4gQSBpdCBjb3ZlcnMpLlxuICAgICAgICAgICAgbGV0IGxlbiA9IGIubGVuO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYi5pbnMsIC0xKTtcbiAgICAgICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2UgPSBNYXRoLm1pbihhLmxlbiwgbGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoYS5pbnMgPj0gMCAmJiBpbnNlcnRlZCA8IGEuaSAmJiBhLmxlbiA8PSBwaWVjZSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBhLmlucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhLmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEuZm9yd2FyZChwaWVjZSk7XG4gICAgICAgICAgICAgICAgbGVuIC09IHBpZWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPj0gMCkge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgcGFydCBvZiBhIGNoYW5nZSBpbiBBIHVwIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gbm9uLWRlbGV0aW9uIGNoYW5nZSBpbiBCIChpZiBvdmVybGFwcGluZykuXG4gICAgICAgICAgICBsZXQgbGVuID0gMCwgbGVmdCA9IGEubGVuO1xuICAgICAgICAgICAgd2hpbGUgKGxlZnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4obGVmdCwgYi5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGllY2U7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gcGllY2U7XG4gICAgICAgICAgICAgICAgICAgIGIuZm9yd2FyZChwaWVjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIuaW5zID09IDAgJiYgYi5sZW4gPCBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gYi5sZW47XG4gICAgICAgICAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNlcnRlZCA8IGEuaSA/IGEuaW5zIDogMCk7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc2VydGVkIDwgYS5pKVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHQpO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhLmk7XG4gICAgICAgICAgICBhLmZvcndhcmQoYS5sZW4gLSBsZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ID8gQ2hhbmdlU2V0LmNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0KSA6IENoYW5nZURlc2MuY3JlYXRlKHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNldHMoc2V0QSwgc2V0QiwgbWtTZXQgPSBmYWxzZSkge1xuICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgIGxldCBpbnNlcnQgPSBta1NldCA/IFtdIDogbnVsbDtcbiAgICBsZXQgYSA9IG5ldyBTZWN0aW9uSXRlcihzZXRBKSwgYiA9IG5ldyBTZWN0aW9uSXRlcihzZXRCKTtcbiAgICBmb3IgKGxldCBvcGVuID0gZmFsc2U7Oykge1xuICAgICAgICBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IENoYW5nZVNldC5jcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBDaGFuZ2VEZXNjLmNyZWF0ZShzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPT0gMCkgeyAvLyBEZWxldGlvbiBpbiBBXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLmxlbiwgMCwgb3Blbik7XG4gICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmxlbiA9PSAwICYmICFiLmRvbmUpIHsgLy8gSW5zZXJ0aW9uIGluIEJcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGIuaW5zLCBvcGVuKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRvbmUgfHwgYi5kb25lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbjIsIGIubGVuKSwgc2VjdGlvbkxlbiA9IHNlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBpbnNCID0gYi5pbnMgPT0gLTEgPyAtMSA6IGIub2ZmID8gMCA6IGIuaW5zO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zQiwgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydCAmJiBpbnNCKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGxlbiwgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dEJpdChsZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBiLm9mZiA/IDAgOiBiLmlucywgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydCAmJiAhYi5vZmYpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BlbiA9IChhLmlucyA+IGxlbiB8fCBiLmlucyA+PSAwICYmIGIubGVuID4gbGVuKSAmJiAob3BlbiB8fCBzZWN0aW9ucy5sZW5ndGggPiBzZWN0aW9uTGVuKTtcbiAgICAgICAgICAgIGEuZm9yd2FyZDIobGVuKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2VjdGlvbkl0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNldCkge1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCB7IHNlY3Rpb25zIH0gPSB0aGlzLnNldDtcbiAgICAgICAgaWYgKHRoaXMuaSA8IHNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sZW4gPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgICAgICB0aGlzLmlucyA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW5zID0gLTI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmYgPSAwO1xuICAgIH1cbiAgICBnZXQgZG9uZSgpIHsgcmV0dXJuIHRoaXMuaW5zID09IC0yOyB9XG4gICAgZ2V0IGxlbjIoKSB7IHJldHVybiB0aGlzLmlucyA8IDAgPyB0aGlzLmxlbiA6IHRoaXMuaW5zOyB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIGxldCB7IGluc2VydGVkIH0gPSB0aGlzLnNldCwgaW5kZXggPSAodGhpcy5pIC0gMikgPj4gMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IGluc2VydGVkLmxlbmd0aCA/IFRleHQuZW1wdHkgOiBpbnNlcnRlZFtpbmRleF07XG4gICAgfVxuICAgIHRleHRCaXQobGVuKSB7XG4gICAgICAgIGxldCB7IGluc2VydGVkIH0gPSB0aGlzLnNldCwgaW5kZXggPSAodGhpcy5pIC0gMikgPj4gMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IGluc2VydGVkLmxlbmd0aCAmJiAhbGVuID8gVGV4dC5lbXB0eVxuICAgICAgICAgICAgOiBpbnNlcnRlZFtpbmRleF0uc2xpY2UodGhpcy5vZmYsIGxlbiA9PSBudWxsID8gdW5kZWZpbmVkIDogdGhpcy5vZmYgKyBsZW4pO1xuICAgIH1cbiAgICBmb3J3YXJkKGxlbikge1xuICAgICAgICBpZiAobGVuID09IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gLT0gbGVuO1xuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcndhcmQyKGxlbikge1xuICAgICAgICBpZiAodGhpcy5pbnMgPT0gLTEpXG4gICAgICAgICAgICB0aGlzLmZvcndhcmQobGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuID09IHRoaXMuaW5zKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnMgLT0gbGVuO1xuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbkEgc2luZ2xlIHNlbGVjdGlvbiByYW5nZS4gV2hlblxuW2BhbGxvd011bHRpcGxlU2VsZWN0aW9uc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpXG5pcyBlbmFibGVkLCBhIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uKSBtYXkgaG9sZFxubXVsdGlwbGUgcmFuZ2VzLiBCeSBkZWZhdWx0LCBzZWxlY3Rpb25zIGhvbGQgZXhhY3RseSBvbmUgcmFuZ2UuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG8sIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYW5jaG9yIG9mIHRoZSByYW5nZeKAlHRoZSBzaWRlIHRoYXQgZG9lc24ndCBtb3ZlIHdoZW4geW91XG4gICAgZXh0ZW5kIGl0LlxuICAgICovXG4gICAgZ2V0IGFuY2hvcigpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XG4gICAgLyoqXG4gICAgVGhlIGhlYWQgb2YgdGhlIHJhbmdlLCB3aGljaCBpcyBtb3ZlZCB3aGVuIHRoZSByYW5nZSBpc1xuICAgIFtleHRlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5leHRlbmQpLlxuICAgICovXG4gICAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMzIgLyogUmFuZ2VGbGFnLkludmVydGVkICovID8gdGhpcy5mcm9tIDogdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiBgYW5jaG9yYCBhbmQgYGhlYWRgIGFyZSBhdCB0aGUgc2FtZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZnJvbSA9PSB0aGlzLnRvOyB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIGN1cnNvciB0aGF0IGlzIGV4cGxpY2l0bHkgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgIGNoYXJhY3RlciBvbiBvbmUgb2YgaXRzIHNpZGVzLCB0aGlzIHJldHVybnMgdGhlIHNpZGUuIC0xIG1lYW5zXG4gICAgdGhlIGNoYXJhY3RlciBiZWZvcmUgaXRzIHBvc2l0aW9uLCAxIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIsIGFuZCAwXG4gICAgbWVhbnMgbm8gYXNzb2NpYXRpb24uXG4gICAgKi9cbiAgICBnZXQgYXNzb2MoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgOCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gPyAtMSA6IHRoaXMuZmxhZ3MgJiAxNiAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyA/IDEgOiAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBsZXZlbCBhc3NvY2lhdGVkIHdpdGggdGhpcyBjdXJzb3IsIGlmXG4gICAgYW55LlxuICAgICovXG4gICAgZ2V0IGJpZGlMZXZlbCgpIHtcbiAgICAgICAgbGV0IGxldmVsID0gdGhpcy5mbGFncyAmIDcgLyogUmFuZ2VGbGFnLkJpZGlMZXZlbE1hc2sgKi87XG4gICAgICAgIHJldHVybiBsZXZlbCA9PSA3ID8gbnVsbCA6IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZ29hbCBjb2x1bW4gKHN0b3JlZCB2ZXJ0aWNhbCBvZmZzZXQpIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgY3Vyc29yLiBUaGlzIGlzIHVzZWQgdG8gcHJlc2VydmUgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIHdoZW5cbiAgICBbbW92aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgYWNyb3NzXG4gICAgbGluZXMgb2YgZGlmZmVyZW50IGxlbmd0aC5cbiAgICAqL1xuICAgIGdldCBnb2FsQ29sdW1uKCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmZsYWdzID4+IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi87XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSAxNjc3NzIxNSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHRocm91Z2ggYSBjaGFuZ2UsIHByb2R1Y2luZyBhIHZhbGlkIHJhbmdlIGluIHRoZVxuICAgIHVwZGF0ZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIGZyb20gPSB0byA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCBhc3NvYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gY2hhbmdlLm1hcFBvcyh0aGlzLmZyb20sIDEpO1xuICAgICAgICAgICAgdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMudG8sIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0aGlzLmZyb20gJiYgdG8gPT0gdGhpcy50byA/IHRoaXMgOiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyByYW5nZSB0byBjb3ZlciBhdCBsZWFzdCBgZnJvbWAgdG8gYHRvYC5cbiAgICAqL1xuICAgIGV4dGVuZChmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPD0gdGhpcy5hbmNob3IgJiYgdG8gPj0gdGhpcy5hbmNob3IpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IGhlYWQgPSBNYXRoLmFicyhmcm9tIC0gdGhpcy5hbmNob3IpID4gTWF0aC5hYnModG8gLSB0aGlzLmFuY2hvcikgPyBmcm9tIDogdG87XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodGhpcy5hbmNob3IsIGhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgcmFuZ2UgdG8gYW5vdGhlciByYW5nZS5cbiAgICAqL1xuICAgIGVxKG90aGVyLCBpbmNsdWRlQXNzb2MgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IgPT0gb3RoZXIuYW5jaG9yICYmIHRoaXMuaGVhZCA9PSBvdGhlci5oZWFkICYmXG4gICAgICAgICAgICAoIWluY2x1ZGVBc3NvYyB8fCAhdGhpcy5lbXB0eSB8fCB0aGlzLmFzc29jID09IG90aGVyLmFzc29jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB7IGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZCB9OyB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSByYW5nZSB0byBhIGBTZWxlY3Rpb25SYW5nZWBcbiAgICBpbnN0YW5jZS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgU2VsZWN0aW9uUmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoanNvbi5hbmNob3IsIGpzb24uaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb25SYW5nZShmcm9tLCB0bywgZmxhZ3MpO1xuICAgIH1cbn1cbi8qKlxuQW4gZWRpdG9yIHNlbGVjdGlvbiBob2xkcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb24gcmFuZ2VzLlxuKi9cbmNsYXNzIEVkaXRvclNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlcyBpbiB0aGUgc2VsZWN0aW9uLCBzb3J0ZWQgYnkgcG9zaXRpb24uIFJhbmdlcyBjYW5ub3RcbiAgICBvdmVybGFwIChidXQgdGhleSBtYXkgdG91Y2gsIGlmIHRoZXkgYXJlbid0IGVtcHR5KS5cbiAgICAqL1xuICAgIHJhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIGluZGV4IG9mIHRoZSBfbWFpbl8gcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbiAod2hpY2ggaXNcbiAgICB1c3VhbGx5IHRoZSByYW5nZSB0aGF0IHdhcyBhZGRlZCBsYXN0KS5cbiAgICAqL1xuICAgIG1haW5JbmRleCkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5tYWluSW5kZXggPSBtYWluSW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHNlbGVjdGlvbiB0aHJvdWdoIGEgY2hhbmdlLiBVc2VkIHRvIGFkanVzdCB0aGUgc2VsZWN0aW9uXG4gICAgcG9zaXRpb24gZm9yIGNoYW5nZXMuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGlmIChjaGFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUodGhpcy5yYW5nZXMubWFwKHIgPT4gci5tYXAoY2hhbmdlLCBhc3NvYykpLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBzZWxlY3Rpb24gdG8gYW5vdGhlciBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQsIHJhbmdlc1xuICAgIGFyZSBjb21wYXJlZCBvbmx5IGJ5IHBvc2l0aW9uLiBXaGVuIGBpbmNsdWRlQXNzb2NgIGlzIHRydWUsXG4gICAgY3Vyc29yIHJhbmdlcyBtdXN0IGFsc28gaGF2ZSB0aGUgc2FtZVxuICAgIFtgYXNzb2NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmFzc29jKSB2YWx1ZS5cbiAgICAqL1xuICAgIGVxKG90aGVyLCBpbmNsdWRlQXNzb2MgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoICE9IG90aGVyLnJhbmdlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMubWFpbkluZGV4ICE9IG90aGVyLm1haW5JbmRleClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5yYW5nZXNbaV0uZXEob3RoZXIucmFuZ2VzW2ldLCBpbmNsdWRlQXNzb2MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UuIFVzdWFsbHksIHlvdSBzaG91bGQgbWFrZSBzdXJlXG4gICAgeW91ciBjb2RlIGFwcGxpZXMgdG8gX2FsbF8gcmFuZ2VzLCBieSB1c2luZyBtZXRob2RzIGxpa2VcbiAgICBbYGNoYW5nZUJ5UmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYW5nZUJ5UmFuZ2UpLlxuICAgICovXG4gICAgZ2V0IG1haW4oKSB7IHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLm1haW5JbmRleF07IH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIHNlbGVjdGlvbiBvbmx5IGhhcyBvbmUgcmFuZ2UuIFJldHVybnMgYSBzZWxlY3Rpb25cbiAgICBob2xkaW5nIG9ubHkgdGhlIG1haW4gcmFuZ2UgZnJvbSB0aGlzIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGFzU2luZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMubGVuZ3RoID09IDEgPyB0aGlzIDogbmV3IEVkaXRvclNlbGVjdGlvbihbdGhpcy5tYWluXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHNlbGVjdGlvbiB3aXRoIGFuIGV4dHJhIHJhbmdlLlxuICAgICovXG4gICAgYWRkUmFuZ2UocmFuZ2UsIG1haW4gPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0uY29uY2F0KHRoaXMucmFuZ2VzKSwgbWFpbiA/IDAgOiB0aGlzLm1haW5JbmRleCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhbm90aGVyIHJhbmdlLCBhbmQgdGhlbiBub3JtYWxpemUgdGhlXG4gICAgc2VsZWN0aW9uIHRvIG1lcmdlIGFuZCBzb3J0IHJhbmdlcyBpZiBuZWNlc3NhcnkuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UocmFuZ2UsIHdoaWNoID0gdGhpcy5tYWluSW5kZXgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgIHJhbmdlc1t3aGljaF0gPSByYW5nZTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzZWxlY3Rpb24gdG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG9cbiAgICBKU09OLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyByYW5nZXM6IHRoaXMucmFuZ2VzLm1hcChyID0+IHIudG9KU09OKCkpLCBtYWluOiB0aGlzLm1haW5JbmRleCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIUFycmF5LmlzQXJyYXkoanNvbi5yYW5nZXMpIHx8IHR5cGVvZiBqc29uLm1haW4gIT0gXCJudW1iZXJcIiB8fCBqc29uLm1haW4gPj0ganNvbi5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclNlbGVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oanNvbi5yYW5nZXMubWFwKChyKSA9PiBTZWxlY3Rpb25SYW5nZS5mcm9tSlNPTihyKSksIGpzb24ubWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBob2xkaW5nIGEgc2luZ2xlIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHNpbmdsZShhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oW0VkaXRvclNlbGVjdGlvbi5yYW5nZShhbmNob3IsIGhlYWQpXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNvcnQgYW5kIG1lcmdlIHRoZSBnaXZlbiBzZXQgb2YgcmFuZ2VzLCBjcmVhdGluZyBhIHZhbGlkXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBzZWxlY3Rpb24gbmVlZHMgYXQgbGVhc3Qgb25lIHJhbmdlXCIpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwb3MgOiByYW5nZS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ubm9ybWFsaXplZChyYW5nZXMuc2xpY2UoKSwgbWFpbkluZGV4KTtcbiAgICAgICAgICAgIHBvcyA9IHJhbmdlLnRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHNlbGVjdGlvbiByYW5nZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIFlvdSBjYW5cbiAgICBzYWZlbHkgaWdub3JlIHRoZSBvcHRpb25hbCBhcmd1bWVudHMgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGN1cnNvcihwb3MsIGFzc29jID0gMCwgYmlkaUxldmVsLCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUocG9zLCBwb3MsIChhc3NvYyA9PSAwID8gMCA6IGFzc29jIDwgMCA/IDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMTYgLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8pIHxcbiAgICAgICAgICAgIChiaWRpTGV2ZWwgPT0gbnVsbCA/IDcgOiBNYXRoLm1pbig2LCBiaWRpTGV2ZWwpKSB8XG4gICAgICAgICAgICAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHJhbmdlKGFuY2hvciwgaGVhZCwgZ29hbENvbHVtbiwgYmlkaUxldmVsKSB7XG4gICAgICAgIGxldCBmbGFncyA9ICgoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMTY3NzcyMTUgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLykgPDwgNiAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLykgfFxuICAgICAgICAgICAgKGJpZGlMZXZlbCA9PSBudWxsID8gNyA6IE1hdGgubWluKDYsIGJpZGlMZXZlbCkpO1xuICAgICAgICByZXR1cm4gaGVhZCA8IGFuY2hvciA/IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShoZWFkLCBhbmNob3IsIDMyIC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyB8IDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovIHwgZmxhZ3MpXG4gICAgICAgICAgICA6IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShhbmNob3IsIGhlYWQsIChoZWFkID4gYW5jaG9yID8gOCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gOiAwKSB8IGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplZChyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgbGV0IG1haW4gPSByYW5nZXNbbWFpbkluZGV4XTtcbiAgICAgICAgcmFuZ2VzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIG1haW5JbmRleCA9IHJhbmdlcy5pbmRleE9mKG1haW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldLCBwcmV2ID0gcmFuZ2VzW2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcHJldi50byA6IHJhbmdlLmZyb20gPCBwcmV2LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBwcmV2LmZyb20sIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHByZXYudG8pO1xuICAgICAgICAgICAgICAgIGlmIChpIDw9IG1haW5JbmRleClcbiAgICAgICAgICAgICAgICAgICAgbWFpbkluZGV4LS07XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIHJhbmdlLmFuY2hvciA+IHJhbmdlLmhlYWQgPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24ocmFuZ2VzLCBtYWluSW5kZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZG9jTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcG9pbnRzIG91dHNpZGUgb2YgZG9jdW1lbnRcIik7XG59XG5cbmxldCBuZXh0SUQgPSAwO1xuLyoqXG5BIGZhY2V0IGlzIGEgbGFiZWxlZCB2YWx1ZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbiBlZGl0b3JcbnN0YXRlLiBJdCB0YWtlcyBpbnB1dHMgZnJvbSBhbnkgbnVtYmVyIG9mIGV4dGVuc2lvbnMsIGFuZCBjb21iaW5lc1xudGhvc2UgaW50byBhIHNpbmdsZSBvdXRwdXQgdmFsdWUuXG5cbkV4YW1wbGVzIG9mIHVzZXMgb2YgZmFjZXRzIGFyZSB0aGUgW3RhYlxuc2l6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSwgW2VkaXRvclxuYXR0cmlidXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdG9yQXR0cmlidXRlcyksIGFuZCBbdXBkYXRlXG5saXN0ZW5lcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnVwZGF0ZUxpc3RlbmVyKS5cblxuTm90ZSB0aGF0IGBGYWNldGAgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGFueXdoZXJlIHdoZXJlXG5bYEZhY2V0UmVhZGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldFJlYWRlcikgaXMgZXhwZWN0ZWQuXG4qL1xuY2xhc3MgRmFjZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tYmluZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlSW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZSwgaXNTdGF0aWMsIGVuYWJsZXMpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lID0gY29tYmluZTtcbiAgICAgICAgdGhpcy5jb21wYXJlSW5wdXQgPSBjb21wYXJlSW5wdXQ7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGNvbWJpbmUoW10pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB0eXBlb2YgZW5hYmxlcyA9PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVzKHRoaXMpIDogZW5hYmxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIGZhY2V0IHJlYWRlciBmb3IgdGhpcyBmYWNldCwgd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAgICBbcmVhZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5mYWNldCkgaXQgYnV0IG5vdCB0byBkZWZpbmUgdmFsdWVzIGZvciBpdC5cbiAgICAqL1xuICAgIGdldCByZWFkZXIoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGZhY2V0LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0KGNvbmZpZy5jb21iaW5lIHx8ICgoYSkgPT4gYSksIGNvbmZpZy5jb21wYXJlSW5wdXQgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnLmNvbXBhcmUgfHwgKCFjb25maWcuY29tYmluZSA/IHNhbWVBcnJheSA6IChhLCBiKSA9PiBhID09PSBiKSwgISFjb25maWcuc3RhdGljLCBjb25maWcuZW5hYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhpcyBmYWNldC5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihbXSwgdGhpcywgMCAvKiBQcm92aWRlci5TdGF0aWMgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIGEgdmFsdWUgZm9yIHRoZSBmYWNldCBmcm9tIGFcbiAgICBzdGF0ZS4gWW91IG11c3QgdGFrZSBjYXJlIHRvIGRlY2xhcmUgdGhlIHBhcnRzIG9mIHRoZSBzdGF0ZSB0aGF0XG4gICAgdGhpcyB2YWx1ZSBkZXBlbmRzIG9uLCBzaW5jZSB5b3VyIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGFnYWluXG4gICAgZm9yIGEgbmV3IHN0YXRlIHdoZW4gb25lIG9mIHRob3NlIHBhcnRzIGNoYW5nZWQuXG4gICAgXG4gICAgSW4gY2FzZXMgd2hlcmUgeW91ciB2YWx1ZSBkZXBlbmRzIG9ubHkgb24gYSBzaW5nbGUgZmllbGQsIHlvdSdsbFxuICAgIHdhbnQgdG8gdXNlIHRoZSBbYGZyb21gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0LmZyb20pIG1ldGhvZCBpbnN0ZWFkLlxuICAgICovXG4gICAgY29tcHV0ZShkZXBzLCBnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoZGVwcywgdGhpcywgMSAvKiBQcm92aWRlci5TaW5nbGUgKi8sIGdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyB6ZXJvIG9yIG1vcmUgdmFsdWVzIGZvciB0aGlzXG4gICAgZmFjZXQgZnJvbSBhIHN0YXRlLlxuICAgICovXG4gICAgY29tcHV0ZU4oZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDIgLyogUHJvdmlkZXIuTXVsdGkgKi8sIGdldCk7XG4gICAgfVxuICAgIGZyb20oZmllbGQsIGdldCkge1xuICAgICAgICBpZiAoIWdldClcbiAgICAgICAgICAgIGdldCA9IHggPT4geDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZShbZmllbGRdLCBzdGF0ZSA9PiBnZXQoc3RhdGUuZmllbGQoZmllbGQpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8IGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGUsIGkpID0+IGUgPT09IGJbaV0pO1xufVxuY2xhc3MgRmFjZXRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoZGVwZW5kZW5jaWVzLCBmYWNldCwgdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgfVxuICAgIGR5bmFtaWNTbG90KGFkZHJlc3Nlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBnZXR0ZXIgPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgY29tcGFyZSA9IHRoaXMuZmFjZXQuY29tcGFyZUlucHV0O1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmlkLCBpZHggPSBhZGRyZXNzZXNbaWRdID4+IDEsIG11bHRpID0gdGhpcy50eXBlID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi87XG4gICAgICAgIGxldCBkZXBEb2MgPSBmYWxzZSwgZGVwU2VsID0gZmFsc2UsIGRlcEFkZHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKGRlcCA9PSBcImRvY1wiKVxuICAgICAgICAgICAgICAgIGRlcERvYyA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChkZXAgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICBkZXBTZWwgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoKCgoX2EgPSBhZGRyZXNzZXNbZGVwLmlkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgJiAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIGRlcEFkZHJzLnB1c2goYWRkcmVzc2VzW2RlcC5pZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRlcERvYyAmJiB0ci5kb2NDaGFuZ2VkKSB8fCAoZGVwU2VsICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpIHx8IGVuc3VyZUFsbChzdGF0ZSwgZGVwQWRkcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGkgPyAhY29tcGFyZUFycmF5KG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0sIGNvbXBhcmUpIDogIWNvbXBhcmUobmV3VmFsLCBzdGF0ZS52YWx1ZXNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCwgb2xkQWRkciA9IG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkQWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBnZXRBZGRyKG9sZFN0YXRlLCBvbGRBZGRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwIGluc3RhbmNlb2YgRmFjZXQgPyBvbGRTdGF0ZS5mYWNldChkZXApID09PSBzdGF0ZS5mYWNldChkZXApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXAgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkID8gb2xkU3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgPT0gc3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KSB8fCAobXVsdGkgPyBjb21wYXJlQXJyYXkobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsLCBjb21wYXJlKSA6IGNvbXBhcmUobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlQXJyYXkoYSwgYiwgY29tcGFyZSkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFjb21wYXJlKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5zdXJlQWxsKHN0YXRlLCBhZGRycykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgYWRkciBvZiBhZGRycylcbiAgICAgICAgaWYgKGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpICYgMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi8pXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNGYWNldFNsb3QoYWRkcmVzc2VzLCBmYWNldCwgcHJvdmlkZXJzKSB7XG4gICAgbGV0IHByb3ZpZGVyQWRkcnMgPSBwcm92aWRlcnMubWFwKHAgPT4gYWRkcmVzc2VzW3AuaWRdKTtcbiAgICBsZXQgcHJvdmlkZXJUeXBlcyA9IHByb3ZpZGVycy5tYXAocCA9PiBwLnR5cGUpO1xuICAgIGxldCBkeW5hbWljID0gcHJvdmlkZXJBZGRycy5maWx0ZXIocCA9PiAhKHAgJiAxKSk7XG4gICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1tmYWNldC5pZF0gPj4gMTtcbiAgICBmdW5jdGlvbiBnZXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3ZpZGVyQWRkcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldEFkZHIoc3RhdGUsIHByb3ZpZGVyQWRkcnNbaV0pO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyVHlwZXNbaV0gPT0gMiAvKiBQcm92aWRlci5NdWx0aSAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWwgb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWNldC5jb21iaW5lKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgYWRkciBvZiBwcm92aWRlckFkZHJzKVxuICAgICAgICAgICAgICAgIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpO1xuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICBpZiAoIWVuc3VyZUFsbChzdGF0ZSwgZHluYW1pYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIHN0YXRlLnZhbHVlc1tpZHhdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIHJlY29uZmlndXJlKHN0YXRlLCBvbGRTdGF0ZSkge1xuICAgICAgICAgICAgbGV0IGRlcENoYW5nZWQgPSBlbnN1cmVBbGwoc3RhdGUsIHByb3ZpZGVyQWRkcnMpO1xuICAgICAgICAgICAgbGV0IG9sZFByb3ZpZGVycyA9IG9sZFN0YXRlLmNvbmZpZy5mYWNldHNbZmFjZXQuaWRdLCBvbGRWYWx1ZSA9IG9sZFN0YXRlLmZhY2V0KGZhY2V0KTtcbiAgICAgICAgICAgIGlmIChvbGRQcm92aWRlcnMgJiYgIWRlcENoYW5nZWQgJiYgc2FtZUFycmF5KHByb3ZpZGVycywgb2xkUHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IGluaXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBzdGF0aWM6IHRydWUgfSk7XG4vKipcbkZpZWxkcyBjYW4gc3RvcmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpbiBhbiBlZGl0b3Igc3RhdGUsIGFuZFxua2VlcCBpdCBpbiBzeW5jIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YXRlRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIGNyZWF0ZUYsIHVwZGF0ZUYsIGNvbXBhcmVGLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZUYgPSBjcmVhdGVGO1xuICAgICAgICB0aGlzLnVwZGF0ZUYgPSB1cGRhdGVGO1xuICAgICAgICB0aGlzLmNvbXBhcmVGID0gY29tcGFyZUY7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm92aWRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RhdGUgZmllbGQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNvbmZpZykge1xuICAgICAgICBsZXQgZmllbGQgPSBuZXcgU3RhdGVGaWVsZChuZXh0SUQrKywgY29uZmlnLmNyZWF0ZSwgY29uZmlnLnVwZGF0ZSwgY29uZmlnLmNvbXBhcmUgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm92aWRlKVxuICAgICAgICAgICAgZmllbGQucHJvdmlkZXMgPSBjb25maWcucHJvdmlkZShmaWVsZCk7XG4gICAgICAgIHJldHVybiBmaWVsZDtcbiAgICB9XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0ID0gc3RhdGUuZmFjZXQoaW5pdEZpZWxkKS5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKTtcbiAgICAgICAgcmV0dXJuICgoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmNyZWF0ZSkgfHwgdGhpcy5jcmVhdGVGKShzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1t0aGlzLmlkXSA+PiAxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IHN0YXRlLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudXBkYXRlRihvbGRWYWwsIHRyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlRihvbGRWYWwsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbdGhpcy5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFN0YXRlLmZpZWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgdGhpcyBmaWVsZCBhbmQgb3ZlcnJpZGVzIHRoZVxuICAgIHdheSBpdCBpcyBpbml0aWFsaXplZC4gQ2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHByb3ZpZGUgYVxuICAgIG5vbi1kZWZhdWx0IHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgZmllbGQuXG4gICAgKi9cbiAgICBpbml0KGNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gW3RoaXMsIGluaXRGaWVsZC5vZih7IGZpZWxkOiB0aGlzLCBjcmVhdGUgfSldO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGF0ZSBmaWVsZCBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgYXNcbiAgICBbYEV4dGVuc2lvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRXh0ZW5zaW9uKSB2YWx1ZXMgdG8gZW5hYmxlIHRoZSBmaWVsZCBpbiBhXG4gICAgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgZXh0ZW5zaW9uKCkgeyByZXR1cm4gdGhpczsgfVxufVxuY29uc3QgUHJlY18gPSB7IGxvd2VzdDogNCwgbG93OiAzLCBkZWZhdWx0OiAyLCBoaWdoOiAxLCBoaWdoZXN0OiAwIH07XG5mdW5jdGlvbiBwcmVjKHZhbHVlKSB7XG4gICAgcmV0dXJuIChleHQpID0+IG5ldyBQcmVjRXh0ZW5zaW9uKGV4dCwgdmFsdWUpO1xufVxuLyoqXG5CeSBkZWZhdWx0IGV4dGVuc2lvbnMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGZvdW5kXG5pbiB0aGUgZmxhdHRlbmVkIGZvcm0gb2YgbmVzdGVkIGFycmF5IHRoYXQgd2FzIHByb3ZpZGVkLlxuSW5kaXZpZHVhbCBleHRlbnNpb24gdmFsdWVzIGNhbiBiZSBhc3NpZ25lZCBhIHByZWNlZGVuY2UgdG9cbm92ZXJyaWRlIHRoaXMuIEV4dGVuc2lvbnMgdGhhdCBkbyBub3QgaGF2ZSBhIHByZWNlZGVuY2Ugc2V0IGdldFxudGhlIHByZWNlZGVuY2Ugb2YgdGhlIG5lYXJlc3QgcGFyZW50IHdpdGggYSBwcmVjZWRlbmNlLCBvclxuW2BkZWZhdWx0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5QcmVjLmRlZmF1bHQpIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcGFyZW50LiBUaGVcbmZpbmFsIG9yZGVyaW5nIG9mIGV4dGVuc2lvbnMgaXMgZGV0ZXJtaW5lZCBieSBmaXJzdCBzb3J0aW5nIGJ5XG5wcmVjZWRlbmNlIGFuZCB0aGVuIGJ5IG9yZGVyIHdpdGhpbiBlYWNoIHByZWNlZGVuY2UuXG4qL1xuY29uc3QgUHJlYyA9IHtcbiAgICAvKipcbiAgICBUaGUgaGlnaGVzdCBwcmVjZWRlbmNlIGxldmVsLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcHJlY2VkZW5jZSBvcmRlcmluZy5cbiAgICAqL1xuICAgIGhpZ2hlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2hlc3QpLFxuICAgIC8qKlxuICAgIEEgaGlnaGVyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZFxuICAgIGNvbWUgYmVmb3JlIHRob3NlIHdpdGggZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgaGlnaDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaCksXG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgcHJlY2VkZW5jZSwgd2hpY2ggaXMgYWxzbyB1c2VkIGZvciBleHRlbnNpb25zXG4gICAgd2l0aG91dCBhbiBleHBsaWNpdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgZGVmYXVsdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uZGVmYXVsdCksXG4gICAgLyoqXG4gICAgQSBsb3dlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGxvdzogLypAX19QVVJFX18qL3ByZWMoUHJlY18ubG93KSxcbiAgICAvKipcbiAgICBUaGUgbG93ZXN0IHByZWNlZGVuY2UgbGV2ZWwuIE1lYW50IGZvciB0aGluZ3MgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgZW5kIG9mIHRoZSBleHRlbnNpb24gb3JkZXIuXG4gICAgKi9cbiAgICBsb3dlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvd2VzdClcbn07XG5jbGFzcyBQcmVjRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lciwgcHJlYykge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMucHJlYyA9IHByZWM7XG4gICAgfVxufVxuLyoqXG5FeHRlbnNpb24gY29tcGFydG1lbnRzIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBjb25maWd1cmF0aW9uXG5keW5hbWljLiBCeSBbd3JhcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQub2YpIHBhcnQgb2YgeW91clxuY29uZmlndXJhdGlvbiBpbiBhIGNvbXBhcnRtZW50LCB5b3UgY2FuIGxhdGVyXG5bcmVwbGFjZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkgdGhhdCBwYXJ0IHRocm91Z2ggYVxudHJhbnNhY3Rpb24uXG4qL1xuY2xhc3MgQ29tcGFydG1lbnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNvbXBhcnRtZW50IHRvIGFkZCB0byB5b3VyIFtzdGF0ZVxuICAgIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVDb25maWcuZXh0ZW5zaW9ucykuXG4gICAgKi9cbiAgICBvZihleHQpIHsgcmV0dXJuIG5ldyBDb21wYXJ0bWVudEluc3RhbmNlKHRoaXMsIGV4dCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdGhhdFxuICAgIHJlY29uZmlndXJlcyB0aGlzIGNvbXBhcnRtZW50LlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29udGVudCkge1xuICAgICAgICByZXR1cm4gQ29tcGFydG1lbnQucmVjb25maWd1cmUub2YoeyBjb21wYXJ0bWVudDogdGhpcywgZXh0ZW5zaW9uOiBjb250ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgY29tcGFydG1lbnQgaW4gdGhlIHN0YXRlLCBvclxuICAgIGB1bmRlZmluZWRgIGlmIGl0IGlzbid0IHByZXNlbnQuXG4gICAgKi9cbiAgICBnZXQoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5jb21wYXJ0bWVudHMuZ2V0KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBhcnRtZW50SW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcnRtZW50LCBpbm5lcikge1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50ID0gY29tcGFydG1lbnQ7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBjb21wYXJ0bWVudHMsIGR5bmFtaWNTbG90cywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpIHtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudHMgPSBjb21wYXJ0bWVudHM7XG4gICAgICAgIHRoaXMuZHluYW1pY1Nsb3RzID0gZHluYW1pY1Nsb3RzO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLnN0YXRpY1ZhbHVlcyA9IHN0YXRpY1ZhbHVlcztcbiAgICAgICAgdGhpcy5mYWNldHMgPSBmYWNldHM7XG4gICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzVGVtcGxhdGUubGVuZ3RoIDwgZHluYW1pY1Nsb3RzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUucHVzaCgwIC8qIFNsb3RTdGF0dXMuVW5yZXNvbHZlZCAqLyk7XG4gICAgfVxuICAgIHN0YXRpY0ZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgcmV0dXJuIGFkZHIgPT0gbnVsbCA/IGZhY2V0LmRlZmF1bHQgOiB0aGlzLnN0YXRpY1ZhbHVlc1thZGRyID4+IDFdO1xuICAgIH1cbiAgICBzdGF0aWMgcmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIG9sZFN0YXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGZhY2V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBuZXdDb21wYXJ0bWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGV4dCBvZiBmbGF0dGVuKGJhc2UsIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSkge1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpXG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAoZmFjZXRzW2V4dC5mYWNldC5pZF0gfHwgKGZhY2V0c1tleHQuZmFjZXQuaWRdID0gW10pKS5wdXNoKGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZHJlc3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgc3RhdGljVmFsdWVzID0gW107XG4gICAgICAgIGxldCBkeW5hbWljU2xvdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBhZGRyZXNzW2ZpZWxkLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZmllbGQuc2xvdChhKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZEZhY2V0cyA9IG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5jb25maWcuZmFjZXRzO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiBmYWNldHMpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcnMgPSBmYWNldHNbaWRdLCBmYWNldCA9IHByb3ZpZGVyc1swXS5mYWNldDtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRGYWNldHMgJiYgb2xkRmFjZXRzW2lkXSB8fCBbXTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcnMuZXZlcnkocCA9PiBwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgaWYgKHNhbWVBcnJheShvbGRQcm92aWRlcnMsIHByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUuZmFjZXQoZmFjZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZhY2V0LmNvbWJpbmUocHJvdmlkZXJzLm1hcChwID0+IHAudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUgJiYgZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkU3RhdGUuZmFjZXQoZmFjZXQpKSA/IG9sZFN0YXRlLmZhY2V0KGZhY2V0KSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gocC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBwLmR5bmFtaWNTbG90KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGR5bmFtaWNGYWNldFNsb3QoYSwgZmFjZXQsIHByb3ZpZGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkeW5hbWljID0gZHluYW1pY1Nsb3RzLm1hcChmID0+IGYoYWRkcmVzcykpO1xuICAgICAgICByZXR1cm4gbmV3IENvbmZpZ3VyYXRpb24oYmFzZSwgbmV3Q29tcGFydG1lbnRzLCBkeW5hbWljLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmxhdHRlbihleHRlbnNpb24sIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtbXSwgW10sIFtdLCBbXSwgW11dO1xuICAgIGxldCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGlubmVyKGV4dCwgcHJlYykge1xuICAgICAgICBsZXQga25vd24gPSBzZWVuLmdldChleHQpO1xuICAgICAgICBpZiAoa25vd24gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGtub3duIDw9IHByZWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gcmVzdWx0W2tub3duXS5pbmRleE9mKGV4dCk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSlcbiAgICAgICAgICAgICAgICByZXN1bHRba25vd25dLnNwbGljZShmb3VuZCwgMSk7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuZGVsZXRlKGV4dC5jb21wYXJ0bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5zZXQoZXh0LCBwcmVjKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiBleHQpXG4gICAgICAgICAgICAgICAgaW5uZXIoZSwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKG5ld0NvbXBhcnRtZW50cy5oYXMoZXh0LmNvbXBhcnRtZW50KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRHVwbGljYXRlIHVzZSBvZiBjb21wYXJ0bWVudCBpbiBleHRlbnNpb25zYCk7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGNvbXBhcnRtZW50cy5nZXQoZXh0LmNvbXBhcnRtZW50KSB8fCBleHQuaW5uZXI7XG4gICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuc2V0KGV4dC5jb21wYXJ0bWVudCwgY29udGVudCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBQcmVjRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpbm5lcihleHQuaW5uZXIsIGV4dC5wcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5wcm92aWRlcylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQucHJvdmlkZXMsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIEZhY2V0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LmZhY2V0LmV4dGVuc2lvbnMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LmZhY2V0LmV4dGVuc2lvbnMsIFByZWNfLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBleHQuZXh0ZW5zaW9uO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGV4dGVuc2lvbiB2YWx1ZSBpbiBleHRlbnNpb24gc2V0ICgke2V4dH0pLiBUaGlzIHNvbWV0aW1lcyBoYXBwZW5zIGJlY2F1c2UgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIEBjb2RlbWlycm9yL3N0YXRlIGFyZSBsb2FkZWQsIGJyZWFraW5nIGluc3RhbmNlb2YgY2hlY2tzLmApO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5uZXIoZXh0ZW5zaW9uLCBQcmVjXy5kZWZhdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xufVxuZnVuY3Rpb24gZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikge1xuICAgIGlmIChhZGRyICYgMSlcbiAgICAgICAgcmV0dXJuIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLztcbiAgICBsZXQgaWR4ID0gYWRkciA+PiAxO1xuICAgIGxldCBzdGF0dXMgPSBzdGF0ZS5zdGF0dXNbaWR4XTtcbiAgICBpZiAoc3RhdHVzID09IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5IGJldHdlZW4gZmllbGRzIGFuZC9vciBmYWNldHNcIik7XG4gICAgaWYgKHN0YXR1cyAmIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLylcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICBzdGF0ZS5zdGF0dXNbaWR4XSA9IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi87XG4gICAgbGV0IGNoYW5nZWQgPSBzdGF0ZS5jb21wdXRlU2xvdChzdGF0ZSwgc3RhdGUuY29uZmlnLmR5bmFtaWNTbG90c1tpZHhdKTtcbiAgICByZXR1cm4gc3RhdGUuc3RhdHVzW2lkeF0gPSAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8gfCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QWRkcihzdGF0ZSwgYWRkcikge1xuICAgIHJldHVybiBhZGRyICYgMSA/IHN0YXRlLmNvbmZpZy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXSA6IHN0YXRlLnZhbHVlc1thZGRyID4+IDFdO1xufVxuXG5jb25zdCBsYW5ndWFnZURhdGEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh2ID0+IHYpLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBsaW5lU2VwYXJhdG9yID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB1bmRlZmluZWQsXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGNoYW5nZUZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25FeHRlbmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHJlYWRPbmx5ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBmYWxzZVxufSk7XG5cbi8qKlxuQW5ub3RhdGlvbnMgYXJlIHRhZ2dlZCB2YWx1ZXMgdGhhdCBhcmUgdXNlZCB0byBhZGQgbWV0YWRhdGEgdG9cbnRyYW5zYWN0aW9ucyBpbiBhbiBleHRlbnNpYmxlIHdheS4gVGhleSBzaG91bGQgYmUgdXNlZCB0byBtb2RlbFxudGhpbmdzIHRoYXQgZWZmZWN0IHRoZSBlbnRpcmUgdHJhbnNhY3Rpb24gKHN1Y2ggYXMgaXRzIFt0aW1lXG5zdGFtcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl50aW1lKSBvciBpbmZvcm1hdGlvbiBhYm91dCBpdHNcbltvcmlnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSkuIEZvciBlZmZlY3RzIHRoYXQgaGFwcGVuXG5fYWxvbmdzaWRlXyB0aGUgb3RoZXIgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbiwgW3N0YXRlXG5lZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBhcmUgbW9yZSBhcHByb3ByaWF0ZS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhbm5vdGF0aW9uIHR5cGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgdHlwZSBvZiBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZSgpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uVHlwZSgpOyB9XG59XG4vKipcbk1hcmtlciB0aGF0IGlkZW50aWZpZXMgYSB0eXBlIG9mIFthbm5vdGF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkFubm90YXRpb24pLlxuKi9cbmNsYXNzIEFubm90YXRpb25UeXBlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5SZXByZXNlbnRhdGlvbiBvZiBhIHR5cGUgb2Ygc3RhdGUgZWZmZWN0LiBEZWZpbmVkIHdpdGhcbltgU3RhdGVFZmZlY3QuZGVmaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5kZWZpbmUpLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0VHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgYGFueWAgdHlwZXMgaW4gdGhlc2UgZnVuY3Rpb24gdHlwZXMgYXJlIHRoZXJlIHRvIHdvcmtcbiAgICAvLyBhcm91bmQgVHlwZVNjcmlwdCBpc3N1ZSAjMzc2MzEsIHdoZXJlIHRoZSB0eXBlIGd1YXJkIG9uXG4gICAgLy8gYFN0YXRlRWZmZWN0LmlzYCBteXN0ZXJpb3VzbHkgc3RvcHMgd29ya2luZyB3aGVuIHRoZXNlIHByb3Blcmx5XG4gICAgLy8gaGF2ZSB0eXBlIGBWYWx1ZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtzdGF0ZSBlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGluc3RhbmNlIG9mIHRoaXNcbiAgICB0eXBlLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdCh0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuU3RhdGUgZWZmZWN0cyBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYWRkaXRpb25hbCBlZmZlY3RzXG5hc3NvY2lhdGVkIHdpdGggYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uZWZmZWN0cykuIFRoZXlcbmFyZSBvZnRlbiB1c2VmdWwgdG8gbW9kZWwgY2hhbmdlcyB0byBjdXN0b20gW3N0YXRlXG5maWVsZHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCksIHdoZW4gdGhvc2UgY2hhbmdlcyBhcmVuJ3QgaW1wbGljaXQgaW5cbmRvY3VtZW50IG9yIHNlbGVjdGlvbiBjaGFuZ2VzLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgZWZmZWN0LlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBlZmZlY3QgdGhyb3VnaCBhIHBvc2l0aW9uIG1hcHBpbmcuIFdpbGwgcmV0dXJuXG4gICAgYHVuZGVmaW5lZGAgd2hlbiB0aGF0IGVuZHMgdXAgZGVsZXRpbmcgdGhlIGVmZmVjdC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLnR5cGUubWFwKHRoaXMudmFsdWUsIG1hcHBpbmcpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtYXBwZWQgPT0gdGhpcy52YWx1ZSA/IHRoaXMgOiBuZXcgU3RhdGVFZmZlY3QodGhpcy50eXBlLCBtYXBwZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIGVmZmVjdCBvYmplY3QgaXMgb2YgYSBnaXZlblxuICAgIFt0eXBlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0VHlwZSkuXG4gICAgKi9cbiAgICBpcyh0eXBlKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZTsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBlZmZlY3QgdHlwZS4gVGhlIHR5cGUgcGFyYW1ldGVyIGluZGljYXRlcyB0aGUgdHlwZVxuICAgIG9mIHZhbHVlcyB0aGF0IGhpcyBlZmZlY3QgaG9sZHMuIEl0IHNob3VsZCBiZSBhIHR5cGUgdGhhdFxuICAgIGRvZXNuJ3QgaW5jbHVkZSBgdW5kZWZpbmVkYCwgc2luY2UgdGhhdCBpcyB1c2VkIGluXG4gICAgW21hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QubWFwKSB0byBpbmRpY2F0ZSB0aGF0IGFuIGVmZmVjdCBpc1xuICAgIHJlbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlRWZmZWN0VHlwZShzcGVjLm1hcCB8fCAodiA9PiB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhbiBhcnJheSBvZiBlZmZlY3RzIHRocm91Z2ggYSBjaGFuZ2Ugc2V0LlxuICAgICovXG4gICAgc3RhdGljIG1hcEVmZmVjdHMoZWZmZWN0cywgbWFwcGluZykge1xuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBlZmZlY3QubWFwKG1hcHBpbmcpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGlzIGVmZmVjdCBjYW4gYmUgdXNlZCB0byByZWNvbmZpZ3VyZSB0aGUgcm9vdCBleHRlbnNpb25zIG9mXG50aGUgZWRpdG9yLiBEb2luZyB0aGlzIHdpbGwgZGlzY2FyZCBhbnkgZXh0ZW5zaW9uc1xuW2FwcGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmFwcGVuZENvbmZpZyksIGJ1dCBkb2VzIG5vdCByZXNldFxudGhlIGNvbnRlbnQgb2YgW3JlY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSlcbmNvbXBhcnRtZW50cy5cbiovXG5TdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQXBwZW5kIGV4dGVuc2lvbnMgdG8gdGhlIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBlZGl0b3IuXG4qL1xuU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5DaGFuZ2VzIHRvIHRoZSBlZGl0b3Igc3RhdGUgYXJlIGdyb3VwZWQgaW50byB0cmFuc2FjdGlvbnMuXG5UeXBpY2FsbHksIGEgdXNlciBhY3Rpb24gY3JlYXRlcyBhIHNpbmdsZSB0cmFuc2FjdGlvbiwgd2hpY2ggbWF5XG5jb250YWluIGFueSBudW1iZXIgb2YgZG9jdW1lbnQgY2hhbmdlcywgbWF5IGNoYW5nZSB0aGUgc2VsZWN0aW9uLFxub3IgaGF2ZSBvdGhlciBlZmZlY3RzLiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBieSBjYWxsaW5nXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSwgb3IgaW1tZWRpYXRlbHlcbmRpc3BhdGNoIG9uZSBieSBjYWxsaW5nXG5bYEVkaXRvclZpZXcuZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGF0ZSBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiBzdGFydHMuXG4gICAgKi9cbiAgICBzdGFydFN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBjaGFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uIHNldCBieSB0aGlzIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgaXRcbiAgICBkb2Vzbid0IGV4cGxpY2l0bHkgc2V0IGEgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBUaGUgZWZmZWN0cyBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBlZmZlY3RzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFubm90YXRpb25zLCBcbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlciB0aGlzXG4gICAgdHJhbnNhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kb2MgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgY2hhbmdlcy5uZXdMZW5ndGgpO1xuICAgICAgICBpZiAoIWFubm90YXRpb25zLnNvbWUoKGEpID0+IGEudHlwZSA9PSBUcmFuc2FjdGlvbi50aW1lKSlcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udGltZS5vZihEYXRlLm5vdygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbnRyYXJ5IHRvXG4gICAgW2Auc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKWAuZG9jYCwgYWNjZXNzaW5nIHRoaXMgd29uJ3RcbiAgICBmb3JjZSB0aGUgZW50aXJlIG5ldyBzdGF0ZSB0byBiZSBjb21wdXRlZCByaWdodCBhd2F5LCBzbyBpdCBpc1xuICAgIHJlY29tbWVuZGVkIHRoYXQgW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgdXNlIHRoaXMgZ2V0dGVyXG4gICAgd2hlbiB0aGV5IG5lZWQgdG8gbG9vayBhdCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IG5ld0RvYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvYyB8fCAodGhpcy5fZG9jID0gdGhpcy5jaGFuZ2VzLmFwcGx5KHRoaXMuc3RhcnRTdGF0ZS5kb2MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzZWxlY3Rpb24gcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBJZlxuICAgIFtgdGhpcy5zZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNlbGVjdGlvbikgaXMgdW5kZWZpbmVkLFxuICAgIHRoaXMgd2lsbCBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbi5tYXApIHRoZSBzdGFydCBzdGF0ZSdzXG4gICAgY3VycmVudCBzZWxlY3Rpb24gdGhyb3VnaCB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBuZXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiB8fCB0aGlzLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1hcCh0aGlzLmNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHN0YXRlIGNyZWF0ZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb21wdXRlZCBvbiBkZW1hbmRcbiAgICAoYnV0IHJldGFpbmVkIGZvciBzdWJzZXF1ZW50IGFjY2VzcyksIHNvIGl0IGlzIHJlY29tbWVuZGVkIG5vdCB0b1xuICAgIGFjY2VzcyBpdCBpbiBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB3aGVuIHBvc3NpYmxlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlKVxuICAgICAgICAgICAgdGhpcy5zdGFydFN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYW5ub3RhdGlvbiB0eXBlLCBpZiBhbnkuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgYW5uIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG4gICAgICAgICAgICBpZiAoYW5uLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5uLnZhbHVlO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlZCB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHsgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRyYW5zYWN0aW9uIHJlY29uZmlndXJlcyB0aGUgc3RhdGVcbiAgICAodGhyb3VnaCBhIFtjb25maWd1cmF0aW9uIGNvbXBhcnRtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50KSBvclxuICAgIHdpdGggYSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvblxuICAgIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RecmVjb25maWd1cmUpLlxuICAgICovXG4gICAgZ2V0IHJlY29uZmlndXJlZCgpIHsgcmV0dXJuIHRoaXMuc3RhcnRTdGF0ZS5jb25maWcgIT0gdGhpcy5zdGF0ZS5jb25maWc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIFt1c2VyXG4gICAgZXZlbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSBhbm5vdGF0aW9uIHRoYXQgaXMgZXF1YWwgdG9cbiAgICBvciBtb3JlIHNwZWNpZmljIHRoYW4gYGV2ZW50YC4gRm9yIGV4YW1wbGUsIGlmIHRoZSB0cmFuc2FjdGlvblxuICAgIGhhcyBgXCJzZWxlY3QucG9pbnRlclwiYCBhcyB1c2VyIGV2ZW50LCBgXCJzZWxlY3RcImAgYW5kXG4gICAgYFwic2VsZWN0LnBvaW50ZXJcImAgd2lsbCBtYXRjaCBpdC5cbiAgICAqL1xuICAgIGlzVXNlckV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIHJldHVybiAhIShlICYmIChlID09IGV2ZW50IHx8IGUubGVuZ3RoID4gZXZlbnQubGVuZ3RoICYmIGUuc2xpY2UoMCwgZXZlbnQubGVuZ3RoKSA9PSBldmVudCAmJiBlW2V2ZW50Lmxlbmd0aF0gPT0gXCIuXCIpKTtcbiAgICB9XG59XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBzdG9yZSB0cmFuc2FjdGlvbiB0aW1lc3RhbXBzLiBBdXRvbWF0aWNhbGx5XG5hZGRlZCB0byBldmVyeSB0cmFuc2FjdGlvbiwgaG9sZGluZyBgRGF0ZS5ub3coKWAuXG4qL1xuVHJhbnNhY3Rpb24udGltZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHVzZXIgaW50ZXJmYWNlXG5ldmVudC4gSG9sZHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGV2ZW50LCB1c2luZyBhXG5kb3Qtc2VwYXJhdGVkIGZvcm1hdCB0byBzdXBwb3J0IGF0dGFjaGluZyBtb3JlIHNwZWNpZmljXG5pbmZvcm1hdGlvbi4gVGhlIGV2ZW50cyB1c2VkIGJ5IHRoZSBjb3JlIGxpYnJhcmllcyBhcmU6XG5cbiAtIGBcImlucHV0XCJgIHdoZW4gY29udGVudCBpcyBlbnRlcmVkXG4gICAtIGBcImlucHV0LnR5cGVcImAgZm9yIHR5cGVkIGlucHV0XG4gICAgIC0gYFwiaW5wdXQudHlwZS5jb21wb3NlXCJgIGZvciBjb21wb3NpdGlvblxuICAgLSBgXCJpbnB1dC5wYXN0ZVwiYCBmb3IgcGFzdGVkIGlucHV0XG4gICAtIGBcImlucHV0LmRyb3BcImAgd2hlbiBhZGRpbmcgY29udGVudCB3aXRoIGRyYWctYW5kLWRyb3BcbiAgIC0gYFwiaW5wdXQuY29tcGxldGVcImAgd2hlbiBhdXRvY29tcGxldGluZ1xuIC0gYFwiZGVsZXRlXCJgIHdoZW4gdGhlIHVzZXIgZGVsZXRlcyBjb250ZW50XG4gICAtIGBcImRlbGV0ZS5zZWxlY3Rpb25cImAgd2hlbiBkZWxldGluZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5mb3J3YXJkXCJgIHdoZW4gZGVsZXRpbmcgZm9yd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmJhY2t3YXJkXCJgIHdoZW4gZGVsZXRpbmcgYmFja3dhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5jdXRcImAgd2hlbiBjdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmRcbiAtIGBcIm1vdmVcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkXG4gICAtIGBcIm1vdmUuZHJvcFwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWQgd2l0aGluIHRoZSBlZGl0b3IgdGhyb3VnaCBkcmFnLWFuZC1kcm9wXG4gLSBgXCJzZWxlY3RcImAgd2hlbiBleHBsaWNpdGx5IGNoYW5naW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwic2VsZWN0LnBvaW50ZXJcImAgd2hlbiBzZWxlY3Rpbmcgd2l0aCBhIG1vdXNlIG9yIG90aGVyIHBvaW50aW5nIGRldmljZVxuIC0gYFwidW5kb1wiYCBhbmQgYFwicmVkb1wiYCBmb3IgaGlzdG9yeSBhY3Rpb25zXG5cblVzZSBbYGlzVXNlckV2ZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5pc1VzZXJFdmVudCkgdG8gY2hlY2tcbndoZXRoZXIgdGhlIGFubm90YXRpb24gbWF0Y2hlcyBhIGdpdmVuIGV2ZW50LlxuKi9cblRyYW5zYWN0aW9uLnVzZXJFdmVudCA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgd2hldGhlciBhIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHVuZG8gaGlzdG9yeSBvciBub3QuXG4qL1xuVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyAod2hlbiBwcmVzZW50IGFuZCB0cnVlKSB0aGF0IGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudHMgYSBjaGFuZ2UgbWFkZSBieSBzb21lIG90aGVyIGFjdG9yLCBub3QgdGhlIHVzZXIuIFRoaXNcbmlzIHVzZWQsIGZvciBleGFtcGxlLCB0byB0YWcgb3RoZXIgcGVvcGxlJ3MgY2hhbmdlcyBpblxuY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuKi9cblRyYW5zYWN0aW9uLnJlbW90ZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gam9pblJhbmdlcyhhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAoaUEgPCBhLmxlbmd0aCAmJiAoaUIgPT0gYi5sZW5ndGggfHwgYltpQl0gPj0gYVtpQV0pKSB7XG4gICAgICAgICAgICBmcm9tID0gYVtpQSsrXTtcbiAgICAgICAgICAgIHRvID0gYVtpQSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpQiA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tID0gYltpQisrXTtcbiAgICAgICAgICAgIHRvID0gYltpQisrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IGZyb20pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCB0bylcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVRyYW5zYWN0aW9uKGEsIGIsIHNlcXVlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG1hcEZvckEsIG1hcEZvckIsIGNoYW5nZXM7XG4gICAgaWYgKHNlcXVlbnRpYWwpIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcztcbiAgICAgICAgbWFwRm9yQiA9IENoYW5nZVNldC5lbXB0eShiLmNoYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKGIuY2hhbmdlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzLm1hcChhLmNoYW5nZXMpO1xuICAgICAgICBtYXBGb3JCID0gYS5jaGFuZ2VzLm1hcERlc2MoYi5jaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKG1hcEZvckEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IGIuc2VsZWN0aW9uID8gYi5zZWxlY3Rpb24ubWFwKG1hcEZvckIpIDogKF9hID0gYS5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAobWFwRm9yQSksXG4gICAgICAgIGVmZmVjdHM6IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYS5lZmZlY3RzLCBtYXBGb3JBKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhiLmVmZmVjdHMsIG1hcEZvckIpKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IGEuYW5ub3RhdGlvbnMubGVuZ3RoID8gYS5hbm5vdGF0aW9ucy5jb25jYXQoYi5hbm5vdGF0aW9ucykgOiBiLmFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogYS5zY3JvbGxJbnRvVmlldyB8fCBiLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjLCBkb2NTaXplKSB7XG4gICAgbGV0IHNlbCA9IHNwZWMuc2VsZWN0aW9uLCBhbm5vdGF0aW9ucyA9IGFzQXJyYXkoc3BlYy5hbm5vdGF0aW9ucyk7XG4gICAgaWYgKHNwZWMudXNlckV2ZW50KVxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yoc3BlYy51c2VyRXZlbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiBzcGVjLmNoYW5nZXMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQgPyBzcGVjLmNoYW5nZXNcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxuICAgICAgICBzZWxlY3Rpb246IHNlbCAmJiAoc2VsIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gc2VsIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShzZWwuYW5jaG9yLCBzZWwuaGVhZCkpLFxuICAgICAgICBlZmZlY3RzOiBhc0FycmF5KHNwZWMuZWZmZWN0cyksXG4gICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzcGVjLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgc3BlY3MsIGZpbHRlcikge1xuICAgIGxldCBzID0gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzLmxlbmd0aCA/IHNwZWNzWzBdIDoge30sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VxID0gISFzcGVjc1tpXS5zZXF1ZW50aWFsO1xuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcbiAgICB9XG4gICAgbGV0IHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBzLmNoYW5nZXMsIHMuc2VsZWN0aW9uLCBzLmVmZmVjdHMsIHMuYW5ub3RhdGlvbnMsIHMuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XG59XG4vLyBGaW5pc2ggYSB0cmFuc2FjdGlvbiBieSBhcHBseWluZyBmaWx0ZXJzIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZTtcbiAgICAvLyBDaGFuZ2UgZmlsdGVyc1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChjaGFuZ2VGaWx0ZXIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZpbHRlcih0cik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB0cnVlID8gdmFsdWUgOiBqb2luUmFuZ2VzKHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzLCBiYWNrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFjayA9IHRyLmNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgICAgICAgICAgY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eShzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHRyLmNoYW5nZXMuZmlsdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcbiAgICAgICAgICAgIGJhY2sgPSBmaWx0ZXJlZC5maWx0ZXJlZC5tYXBEZXNjKGZpbHRlcmVkLmNoYW5nZXMpLmludmVydGVkRGVzYztcbiAgICAgICAgfVxuICAgICAgICB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgY2hhbmdlcywgdHIuc2VsZWN0aW9uICYmIHRyLnNlbGVjdGlvbi5tYXAoYmFjayksIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHModHIuZWZmZWN0cywgYmFjayksIHRyLmFubm90YXRpb25zLCB0ci5zY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8vIFRyYW5zYWN0aW9uIGZpbHRlcnNcbiAgICBsZXQgZmlsdGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRmlsdGVyKTtcbiAgICBmb3IgKGxldCBpID0gZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSBmaWx0ZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcmVkKSAmJiBmaWx0ZXJlZC5sZW5ndGggPT0gMSAmJiBmaWx0ZXJlZFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZFswXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIgPSByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIGFzQXJyYXkoZmlsdGVyZWQpLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGV4dGVuZFRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZSwgZXh0ZW5kZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25FeHRlbmRlciksIHNwZWMgPSB0cjtcbiAgICBmb3IgKGxldCBpID0gZXh0ZW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbmRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIE9iamVjdC5rZXlzKGV4dGVuc2lvbikubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYyA9IG1lcmdlVHJhbnNhY3Rpb24oc3BlYywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIGV4dGVuc2lvbiwgdHIuY2hhbmdlcy5uZXdMZW5ndGgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMgPT0gdHIgPyB0ciA6IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgdHIuY2hhbmdlcywgdHIuc2VsZWN0aW9uLCBzcGVjLmVmZmVjdHMsIHNwZWMuYW5ub3RhdGlvbnMsIHNwZWMuc2Nyb2xsSW50b1ZpZXcpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbm9uZSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vKipcblRoZSBjYXRlZ29yaWVzIHByb2R1Y2VkIGJ5IGEgW2NoYXJhY3RlclxuY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKS4gVGhlc2UgYXJlIHVzZWRcbmRvIHRoaW5ncyBsaWtlIHNlbGVjdGluZyBieSB3b3JkLlxuKi9cbnZhciBDaGFyQ2F0ZWdvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDaGFyQ2F0ZWdvcnkpIHtcbiAgICAvKipcbiAgICBXb3JkIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiV29yZFwiXSA9IDBdID0gXCJXb3JkXCI7XG4gICAgLyoqXG4gICAgV2hpdGVzcGFjZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJTcGFjZVwiXSA9IDFdID0gXCJTcGFjZVwiO1xuICAgIC8qKlxuICAgIEFueXRoaW5nIGVsc2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiT3RoZXJcIl0gPSAyXSA9IFwiT3RoZXJcIjtcbnJldHVybiBDaGFyQ2F0ZWdvcnl9KShDaGFyQ2F0ZWdvcnkgfHwgKENoYXJDYXRlZ29yeSA9IHt9KSk7XG5jb25zdCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbmxldCB3b3JkQ2hhcjtcbnRyeSB7XG4gICAgd29yZENoYXIgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fXVwiLCBcInVcIik7XG59XG5jYXRjaCAoXykgeyB9XG5mdW5jdGlvbiBoYXNXb3JkQ2hhcihzdHIpIHtcbiAgICBpZiAod29yZENoYXIpXG4gICAgICAgIHJldHVybiB3b3JkQ2hhci50ZXN0KHN0cik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoID0gc3RyW2ldO1xuICAgICAgICBpZiAoL1xcdy8udGVzdChjaCkgfHwgY2ggPiBcIlxceDgwXCIgJiYgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWFrZUNhdGVnb3JpemVyKHdvcmRDaGFycykge1xuICAgIHJldHVybiAoY2hhcikgPT4ge1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LlNwYWNlO1xuICAgICAgICBpZiAoaGFzV29yZENoYXIoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNoYXIuaW5kZXhPZih3b3JkQ2hhcnNbaV0pID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5Lk90aGVyO1xuICAgIH07XG59XG5cbi8qKlxuVGhlIGVkaXRvciBzdGF0ZSBjbGFzcyBpcyBhIHBlcnNpc3RlbnQgKGltbXV0YWJsZSkgZGF0YSBzdHJ1Y3R1cmUuXG5UbyB1cGRhdGUgYSBzdGF0ZSwgeW91IFtjcmVhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSBhXG5bdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pLCB3aGljaCBwcm9kdWNlcyBhIF9uZXdfIHN0YXRlXG5pbnN0YW5jZSwgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cblxuQXMgc3VjaCwgX25ldmVyXyBtdXRhdGUgcHJvcGVydGllcyBvZiBhIHN0YXRlIGRpcmVjdGx5LiBUaGF0J2xsXG5qdXN0IGJyZWFrIHRoaW5ncy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25maWcsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsdWVzLCBjb21wdXRlU2xvdCwgdHIpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gY29uZmlnLnN0YXR1c1RlbXBsYXRlLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVNsb3QgPSBjb21wdXRlU2xvdDtcbiAgICAgICAgLy8gRmlsbCBpbiB0aGUgY29tcHV0ZWQgc3RhdGUgaW1tZWRpYXRlbHksIHNvIHRoYXQgZnVydGhlciBxdWVyaWVzXG4gICAgICAgIC8vIGZvciBpdCBtYWRlIGR1cmluZyB0aGUgdXBkYXRlIHJldHVybiB0aGlzIHN0YXRlXG4gICAgICAgIGlmICh0cilcbiAgICAgICAgICAgIHRyLl9zdGF0ZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcuZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBpIDw8IDEpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gbnVsbDtcbiAgICB9XG4gICAgZmllbGQoZmllbGQsIHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmaWVsZC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmllbGQgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCB1cGRhdGVzIHRoaXNcbiAgICBzdGF0ZS4gQW55IG51bWJlciBvZiBbdHJhbnNhY3Rpb24gc3BlY3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKVxuICAgIGNhbiBiZSBwYXNzZWQuIFVubGVzc1xuICAgIFtgc2VxdWVudGlhbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlcXVlbnRpYWwpIGlzIHNldCwgdGhlXG4gICAgW2NoYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmNoYW5nZXMpIChpZiBhbnkpIG9mIGVhY2ggc3BlY1xuICAgIGFyZSBhc3N1bWVkIHRvIHN0YXJ0IGluIHRoZSBfY3VycmVudF8gZG9jdW1lbnQgKG5vdCB0aGUgZG9jdW1lbnRcbiAgICBwcm9kdWNlZCBieSBwcmV2aW91cyBzcGVjcyksIGFuZCBpdHNcbiAgICBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGFuZFxuICAgIFtlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSBhcmUgYXNzdW1lZCB0byByZWZlclxuICAgIHRvIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IGl0cyBfb3duXyBjaGFuZ2VzLiBUaGUgcmVzdWx0aW5nXG4gICAgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhbGwgdGhlIGRpZmZlcmVudFxuICAgIHNwZWNzLiBGb3IgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSwgbGF0ZXJcbiAgICBzcGVjcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBlYXJsaWVyIG9uZXMuXG4gICAgKi9cbiAgICB1cGRhdGUoLi4uc3BlY3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2FjdGlvbih0aGlzLCBzcGVjcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbih0cikge1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMuY29uZmlnLCB7IGJhc2UsIGNvbXBhcnRtZW50cyB9ID0gY29uZjtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoQ29tcGFydG1lbnQucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFydG1lbnRzID0gbmV3IE1hcDtcbiAgICAgICAgICAgICAgICAgICAgY29uZi5jb21wYXJ0bWVudHMuZm9yRWFjaCgodmFsLCBrZXkpID0+IGNvbXBhcnRtZW50cy5zZXQoa2V5LCB2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cy5zZXQoZWZmZWN0LnZhbHVlLmNvbXBhcnRtZW50LCBlZmZlY3QudmFsdWUuZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gYXNBcnJheShiYXNlKS5jb25jYXQoZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRWYWx1ZXM7XG4gICAgICAgIGlmICghY29uZikge1xuICAgICAgICAgICAgY29uZiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIHRoaXMpO1xuICAgICAgICAgICAgbGV0IGludGVybWVkaWF0ZVN0YXRlID0gbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRoaXMuZG9jLCB0aGlzLnNlbGVjdGlvbiwgY29uZi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QucmVjb25maWd1cmUoc3RhdGUsIHRoaXMpLCBudWxsKTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gaW50ZXJtZWRpYXRlU3RhdGUudmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSB0ci5zdGFydFN0YXRlLnZhbHVlcy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0ci5zdGFydFN0YXRlLmZhY2V0KGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSA/IHRyLm5ld1NlbGVjdGlvbiA6IHRyLm5ld1NlbGVjdGlvbi5hc1NpbmdsZSgpO1xuICAgICAgICBuZXcgRWRpdG9yU3RhdGUoY29uZiwgdHIubmV3RG9jLCBzZWxlY3Rpb24sIHN0YXJ0VmFsdWVzLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QudXBkYXRlKHN0YXRlLCB0ciksIHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3RyYW5zYWN0aW9uIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSB0aGF0XG4gICAgcmVwbGFjZXMgZXZlcnkgc2VsZWN0aW9uIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy50b1RleHQodGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4gKHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIHRleHQubGVuZ3RoKSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBjaGFuZ2VzIGFuZCBhIG5ldyBzZWxlY3Rpb24gYnkgcnVubmluZyB0aGUgZ2l2ZW5cbiAgICBmdW5jdGlvbiBmb3IgZWFjaCByYW5nZSBpbiB0aGUgYWN0aXZlIHNlbGVjdGlvbi4gVGhlIGZ1bmN0aW9uXG4gICAgY2FuIHJldHVybiBhbiBvcHRpb25hbCBzZXQgb2YgY2hhbmdlcyAoaW4gdGhlIGNvb3JkaW5hdGUgc3BhY2VcbiAgICBvZiB0aGUgc3RhcnQgZG9jdW1lbnQpLCBwbHVzIGFuIHVwZGF0ZWQgcmFuZ2UgKGluIHRoZSBjb29yZGluYXRlXG4gICAgc3BhY2Ugb2YgdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IHRoZSBjYWxsJ3Mgb3duIGNoYW5nZXMpLiBUaGlzXG4gICAgbWV0aG9kIHdpbGwgbWVyZ2UgYWxsIHRoZSBjaGFuZ2VzIGFuZCByYW5nZXMgaW50byBhIHNpbmdsZVxuICAgIGNoYW5nZXNldCBhbmQgc2VsZWN0aW9uLCBhbmQgcmV0dXJuIGl0IGFzIGEgW3RyYW5zYWN0aW9uXG4gICAgc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpLCB3aGljaCBjYW4gYmUgcGFzc2VkIHRvXG4gICAgW2B1cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkuXG4gICAgKi9cbiAgICBjaGFuZ2VCeVJhbmdlKGYpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmVzdWx0MSA9IGYoc2VsLnJhbmdlc1swXSk7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdDEuY2hhbmdlcyksIHJhbmdlcyA9IFtyZXN1bHQxLnJhbmdlXTtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBhc0FycmF5KHJlc3VsdDEuZWZmZWN0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGYoc2VsLnJhbmdlc1tpXSk7XG4gICAgICAgICAgICBsZXQgbmV3Q2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQuY2hhbmdlcyksIG5ld01hcHBlZCA9IG5ld0NoYW5nZXMubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gcmFuZ2VzW2pdLm1hcChuZXdNYXBwZWQpO1xuICAgICAgICAgICAgbGV0IG1hcEJ5ID0gY2hhbmdlcy5tYXBEZXNjKG5ld0NoYW5nZXMsIHRydWUpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmVzdWx0LnJhbmdlLm1hcChtYXBCeSkpO1xuICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMuY29tcG9zZShuZXdNYXBwZWQpO1xuICAgICAgICAgICAgZWZmZWN0cyA9IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZWZmZWN0cywgbmV3TWFwcGVkKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhhc0FycmF5KHJlc3VsdC5lZmZlY3RzKSwgbWFwQnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHNlbC5tYWluSW5kZXgpLFxuICAgICAgICAgICAgZWZmZWN0c1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpIGZyb20gdGhlIGdpdmVuIGNoYW5nZVxuICAgIGRlc2NyaXB0aW9uLCB0YWtpbmcgdGhlIHN0YXRlJ3MgZG9jdW1lbnQgbGVuZ3RoIGFuZCBsaW5lXG4gICAgc2VwYXJhdG9yIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIGNoYW5nZXMoc3BlYyA9IFtdKSB7XG4gICAgICAgIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KVxuICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgIHJldHVybiBDaGFuZ2VTZXQub2Yoc3BlYywgdGhpcy5kb2MubGVuZ3RoLCB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNpbmcgdGhlIHN0YXRlJ3MgW2xpbmVcbiAgICBzZXBhcmF0b3JdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvciksIGNyZWF0ZSBhXG4gICAgW2BUZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0KSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICB0b1RleHQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBUZXh0Lm9mKHN0cmluZy5zcGxpdCh0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGdpdmVuIHJhbmdlIG9mIHRoZSBkb2N1bWVudCBhcyBhIHN0cmluZy5cbiAgICAqL1xuICAgIHNsaWNlRG9jKGZyb20gPSAwLCB0byA9IHRoaXMuZG9jLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIHRoaXMubGluZUJyZWFrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiBhIHN0YXRlIFtmYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldCkuXG4gICAgKi9cbiAgICBmYWNldChmYWNldCkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmFjZXQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhY2V0LmRlZmF1bHQ7XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgc3RhdGUgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QuIFdoZW4gY3VzdG9tXG4gICAgZmllbGRzIHNob3VsZCBiZSBzZXJpYWxpemVkLCB5b3UgY2FuIHBhc3MgdGhlbSBpbiBhcyBhbiBvYmplY3RcbiAgICBtYXBwaW5nIHByb3BlcnR5IG5hbWVzIChpbiB0aGUgcmVzdWx0aW5nIG9iamVjdCwgd2hpY2ggc2hvdWxkXG4gICAgbm90IHVzZSBgZG9jYCBvciBgc2VsZWN0aW9uYCkgdG8gZmllbGRzLlxuICAgICovXG4gICAgdG9KU09OKGZpZWxkcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZG9jOiB0aGlzLnNsaWNlRG9jKCksXG4gICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZpZWxkc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkICYmIHRoaXMuY29uZmlnLmFkZHJlc3NbdmFsdWUuaWRdICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHZhbHVlLnNwZWMudG9KU09OKHRoaXMuZmllbGQoZmllbGRzW3Byb3BdKSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc3RhdGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIGRlc2VyaWFsaXplZCwgcGFzcyB0aGUgc2FtZSBvYmplY3QgeW91IHBhc3NlZFxuICAgIHRvIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIHdoZW4gc2VyaWFsaXppbmcgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uLCBjb25maWcgPSB7fSwgZmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5kb2MgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTdGF0ZVwiKTtcbiAgICAgICAgbGV0IGZpZWxkSW5pdCA9IFtdO1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1twcm9wXSwgdmFsdWUgPSBqc29uW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEluaXQucHVzaChmaWVsZC5pbml0KHN0YXRlID0+IGZpZWxkLnNwZWMuZnJvbUpTT04odmFsdWUsIHN0YXRlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICBkb2M6IGpzb24uZG9jLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zZWxlY3Rpb24pLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogY29uZmlnLmV4dGVuc2lvbnMgPyBmaWVsZEluaXQuY29uY2F0KFtjb25maWcuZXh0ZW5zaW9uc10pIDogZmllbGRJbml0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUuIFlvdSdsbCB1c3VhbGx5IG9ubHkgbmVlZCB0aGlzIHdoZW5cbiAgICBpbml0aWFsaXppbmcgYW4gZWRpdG9y4oCUdXBkYXRlZCBzdGF0ZXMgYXJlIGNyZWF0ZWQgYnkgYXBwbHlpbmdcbiAgICB0cmFuc2FjdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGxldCBjb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbi5yZXNvbHZlKGNvbmZpZy5leHRlbnNpb25zIHx8IFtdLCBuZXcgTWFwKTtcbiAgICAgICAgbGV0IGRvYyA9IGNvbmZpZy5kb2MgaW5zdGFuY2VvZiBUZXh0ID8gY29uZmlnLmRvY1xuICAgICAgICAgICAgOiBUZXh0Lm9mKChjb25maWcuZG9jIHx8IFwiXCIpLnNwbGl0KGNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSAhY29uZmlnLnNlbGVjdGlvbiA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoMClcbiAgICAgICAgICAgIDogY29uZmlnLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IGNvbmZpZy5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICA6IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoY29uZmlnLnNlbGVjdGlvbi5hbmNob3IsIGNvbmZpZy5zZWxlY3Rpb24uaGVhZCk7XG4gICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jLmxlbmd0aCk7XG4gICAgICAgIGlmICghY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykpXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uYXNTaW5nbGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShjb25maWd1cmF0aW9uLCBkb2MsIHNlbGVjdGlvbiwgY29uZmlndXJhdGlvbi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QuY3JlYXRlKHN0YXRlKSwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIChpbiBjb2x1bW5zKSBvZiBhIHRhYiBpbiB0aGUgZG9jdW1lbnQsIGRldGVybWluZWQgYnlcbiAgICB0aGUgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSBmYWNldC5cbiAgICAqL1xuICAgIGdldCB0YWJTaXplKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS50YWJTaXplKTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJvcGVyIFtsaW5lLWJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpXG4gICAgc3RyaW5nIGZvciB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgXCJcXG5cIjsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICBbY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5yZWFkT25seSkgdG8gYmUgcmVhZC1vbmx5LlxuICAgICovXG4gICAgZ2V0IHJlYWRPbmx5KCkgeyByZXR1cm4gdGhpcy5mYWNldChyZWFkT25seSk7IH1cbiAgICAvKipcbiAgICBMb29rIHVwIGEgdHJhbnNsYXRpb24gZm9yIHRoZSBnaXZlbiBwaHJhc2UgKHZpYSB0aGVcbiAgICBbYHBocmFzZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnBocmFzZXMpIGZhY2V0KSwgb3IgcmV0dXJuIHRoZVxuICAgIG9yaWdpbmFsIHN0cmluZyBpZiBubyB0cmFuc2xhdGlvbiBpcyBmb3VuZC5cbiAgICBcbiAgICBJZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcGFzc2VkLCB0aGV5IHdpbGwgYmUgaW5zZXJ0ZWQgaW5cbiAgICBwbGFjZSBvZiBtYXJrZXJzIGxpa2UgYCQxYCAoZm9yIHRoZSBmaXJzdCB2YWx1ZSkgYW5kIGAkMmAsIGV0Yy5cbiAgICBBIHNpbmdsZSBgJGAgaXMgZXF1aXZhbGVudCB0byBgJDFgLCBhbmQgYCQkYCB3aWxsIHByb2R1Y2UgYVxuICAgIGxpdGVyYWwgZG9sbGFyIHNpZ24uXG4gICAgKi9cbiAgICBwaHJhc2UocGhyYXNlLCAuLi5pbnNlcnQpIHtcbiAgICAgICAgZm9yIChsZXQgbWFwIG9mIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgcGhyYXNlKSkge1xuICAgICAgICAgICAgICAgIHBocmFzZSA9IG1hcFtwaHJhc2VdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaW5zZXJ0Lmxlbmd0aClcbiAgICAgICAgICAgIHBocmFzZSA9IHBocmFzZS5yZXBsYWNlKC9cXCQoXFwkfFxcZCopL2csIChtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gXCIkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgICAgICAgICBsZXQgbiA9ICsoaSB8fCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW4gfHwgbiA+IGluc2VydC5sZW5ndGggPyBtIDogaW5zZXJ0W24gLSAxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGhyYXNlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UgZGF0YSBmaWVsZCwgcHJvdmlkZWQgYnkgdGhlXG4gICAgdGhlIFtgbGFuZ3VhZ2VEYXRhYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5sYW5ndWFnZURhdGEpIGZhY2V0LlxuICAgIFxuICAgIEV4YW1wbGVzIG9mIGxhbmd1YWdlIGRhdGEgZmllbGRzIGFyZS4uLlxuICAgIFxuICAgIC0gW2BcImNvbW1lbnRUb2tlbnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgZm9yIHNwZWNpZnlpbmdcbiAgICAgIGNvbW1lbnQgc3ludGF4LlxuICAgIC0gW2BcImF1dG9jb21wbGV0ZVwiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuYXV0b2NvbXBsZXRpb25eY29uZmlnLm92ZXJyaWRlKVxuICAgICAgZm9yIHByb3ZpZGluZyBsYW5ndWFnZS1zcGVjaWZpYyBjb21wbGV0aW9uIHNvdXJjZXMuXG4gICAgLSBbYFwid29yZENoYXJzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgZm9yIGFkZGluZ1xuICAgICAgY2hhcmFjdGVycyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2Ygd29yZHMgaW4gdGhpc1xuICAgICAgbGFuZ3VhZ2UuXG4gICAgLSBbYFwiY2xvc2VCcmFja2V0c1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ2xvc2VCcmFja2V0Q29uZmlnKSBjb250cm9sc1xuICAgICAgYnJhY2tldCBjbG9zaW5nIGJlaGF2aW9yLlxuICAgICovXG4gICAgbGFuZ3VhZ2VEYXRhQXQobmFtZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwcm92aWRlciBvZiB0aGlzLmZhY2V0KGxhbmd1YWdlRGF0YSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJlc3VsdCBvZiBwcm92aWRlcih0aGlzLCBwb3MsIHNpZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChyZXN1bHRbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGNhdGVnb3JpemUgc3RyaW5ncyAoZXhwZWN0ZWQgdG9cbiAgICByZXByZXNlbnQgYSBzaW5nbGUgW2dyYXBoZW1lIGNsdXN0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuZmluZENsdXN0ZXJCcmVhaykpXG4gICAgaW50byBvbmUgb2Y6XG4gICAgXG4gICAgIC0gV29yZCAoY29udGFpbnMgYW4gYWxwaGFudW1lcmljIGNoYXJhY3RlciBvciBhIGNoYXJhY3RlclxuICAgICAgIGV4cGxpY2l0bHkgbGlzdGVkIGluIHRoZSBsb2NhbCBsYW5ndWFnZSdzIGBcIndvcmRDaGFyc1wiYFxuICAgICAgIGxhbmd1YWdlIGRhdGEsIHdoaWNoIHNob3VsZCBiZSBhIHN0cmluZylcbiAgICAgLSBTcGFjZSAoY29udGFpbnMgb25seSB3aGl0ZXNwYWNlKVxuICAgICAtIE90aGVyIChhbnl0aGluZyBlbHNlKVxuICAgICovXG4gICAgY2hhckNhdGVnb3JpemVyKGF0KSB7XG4gICAgICAgIHJldHVybiBtYWtlQ2F0ZWdvcml6ZXIodGhpcy5sYW5ndWFnZURhdGFBdChcIndvcmRDaGFyc1wiLCBhdCkuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBtZWFuaW5nIHRoZSByYW5nZVxuICAgIGNvbnRhaW5pbmcgYWxsIFt3b3JkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYXJDYXRlZ29yeS5Xb3JkKSBjaGFyYWN0ZXJzXG4gICAgYXJvdW5kIGl0LiBJZiBubyB3b3JkIGNoYXJhY3RlcnMgYXJlIGFkamFjZW50IHRvIHRoZSBwb3NpdGlvbixcbiAgICB0aGlzIHJldHVybnMgbnVsbC5cbiAgICAqL1xuICAgIHdvcmRBdChwb3MpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSwgbGVuZ3RoIH0gPSB0aGlzLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGNhdCA9IHRoaXMuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcyAtIGZyb20sIGVuZCA9IHBvcyAtIGZyb207XG4gICAgICAgIHdoaWxlIChzdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKHByZXYsIHN0YXJ0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdGFydCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVuZCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIGVuZCk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UoZW5kLCBuZXh0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbmQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydCA9PSBlbmQgPyBudWxsIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHN0YXJ0ICsgZnJvbSwgZW5kICsgZnJvbSk7XG4gICAgfVxufVxuLyoqXG5BIGZhY2V0IHRoYXQsIHdoZW4gZW5hYmxlZCwgY2F1c2VzIHRoZSBlZGl0b3IgdG8gYWxsb3cgbXVsdGlwbGVcbnJhbmdlcyB0byBiZSBzZWxlY3RlZC4gQmUgY2FyZWZ1bCB0aG91Z2gsIGJlY2F1c2UgYnkgZGVmYXVsdCB0aGVcbmVkaXRvciByZWxpZXMgb24gdGhlIG5hdGl2ZSBET00gc2VsZWN0aW9uLCB3aGljaCBjYW5ub3QgaGFuZGxlXG5tdWx0aXBsZSBzZWxlY3Rpb25zLiBBbiBleHRlbnNpb24gbGlrZVxuW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNhbiBiZSB1c2VkIHRvIG1ha2VcbnNlY29uZGFyeSBzZWxlY3Rpb25zIHZpc2libGUgdG8gdGhlIHVzZXIuXG4qL1xuRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSBhbGxvd011bHRpcGxlU2VsZWN0aW9ucztcbi8qKlxuQ29uZmlndXJlcyB0aGUgdGFiIHNpemUgdG8gdXNlIGluIHRoaXMgc3RhdGUuIFRoZSBmaXJzdFxuKGhpZ2hlc3QtcHJlY2VkZW5jZSkgdmFsdWUgb2YgdGhlIGZhY2V0IGlzIHVzZWQuIElmIG5vIHZhbHVlIGlzXG5naXZlbiwgdGhpcyBkZWZhdWx0cyB0byA0LlxuKi9cbkVkaXRvclN0YXRlLnRhYlNpemUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IDRcbn0pO1xuLyoqXG5UaGUgbGluZSBzZXBhcmF0b3IgdG8gdXNlLiBCeSBkZWZhdWx0LCBhbnkgb2YgYFwiXFxuXCJgLCBgXCJcXHJcXG5cImBcbmFuZCBgXCJcXHJcImAgaXMgdHJlYXRlZCBhcyBhIHNlcGFyYXRvciB3aGVuIHNwbGl0dGluZyBsaW5lcywgYW5kXG5saW5lcyBhcmUgam9pbmVkIHdpdGggYFwiXFxuXCJgLlxuXG5XaGVuIHlvdSBjb25maWd1cmUgYSB2YWx1ZSBoZXJlLCBvbmx5IHRoYXQgcHJlY2lzZSBzZXBhcmF0b3JcbndpbGwgYmUgdXNlZCwgYWxsb3dpbmcgeW91IHRvIHJvdW5kLXRyaXAgZG9jdW1lbnRzIHRocm91Z2ggdGhlXG5lZGl0b3Igd2l0aG91dCBub3JtYWxpemluZyBsaW5lIHNlcGFyYXRvcnMuXG4qL1xuRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvciA9IGxpbmVTZXBhcmF0b3I7XG4vKipcblRoaXMgZmFjZXQgY29udHJvbHMgdGhlIHZhbHVlIG9mIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGdldHRlciwgd2hpY2ggaXNcbmNvbnN1bHRlZCBieSBjb21tYW5kcyBhbmQgZXh0ZW5zaW9ucyB0aGF0IGltcGxlbWVudCBlZGl0aW5nXG5mdW5jdGlvbmFsaXR5IHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXkgc2hvdWxkIGFwcGx5LiBJdFxuZGVmYXVsdHMgdG8gZmFsc2UsIGJ1dCB3aGVuIGl0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXNcbmB0cnVlYCwgc3VjaCBmdW5jdGlvbmFsaXR5IGRpc2FibGVzIGl0c2VsZi5cblxuTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGhcbltgRWRpdG9yVmlldy5lZGl0YWJsZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRhYmxlKSwgd2hpY2hcbmNvbnRyb2xzIHdoZXRoZXIgdGhlIGVkaXRvcidzIERPTSBpcyBzZXQgdG8gYmUgZWRpdGFibGUgKGFuZFxudGh1cyBmb2N1c2FibGUpLlxuKi9cbkVkaXRvclN0YXRlLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4vKipcblJlZ2lzdGVycyB0cmFuc2xhdGlvbiBwaHJhc2VzLiBUaGVcbltgcGhyYXNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5waHJhc2UpIG1ldGhvZCB3aWxsIGxvb2sgdGhyb3VnaFxuYWxsIG9iamVjdHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgZmFjZXQgdG8gZmluZCB0cmFuc2xhdGlvbnMgZm9yXG5pdHMgYXJndW1lbnQuXG4qL1xuRWRpdG9yU3RhdGUucGhyYXNlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbXBhcmUoYSwgYikge1xuICAgICAgICBsZXQga0EgPSBPYmplY3Qua2V5cyhhKSwga0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtBLmxlbmd0aCA9PSBrQi5sZW5ndGggJiYga0EuZXZlcnkoayA9PiBhW2tdID09IGJba10pO1xuICAgIH1cbn0pO1xuLyoqXG5BIGZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSBwcm92aWRlcnMuXG4qL1xuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhID0gbGFuZ3VhZ2VEYXRhO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGNoYW5nZSBmaWx0ZXJzLCB3aGljaCBhcmUgY2FsbGVkIGZvciBlYWNoXG50cmFuc2FjdGlvbiAodW5sZXNzIGV4cGxpY2l0bHlcbltkaXNhYmxlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSksIGFuZCBjYW4gc3VwcHJlc3NcbnBhcnQgb2YgdGhlIHRyYW5zYWN0aW9uJ3MgY2hhbmdlcy5cblxuU3VjaCBhIGZ1bmN0aW9uIGNhbiByZXR1cm4gYHRydWVgIHRvIGluZGljYXRlIHRoYXQgaXQgZG9lc24ndFxud2FudCB0byBkbyBhbnl0aGluZywgYGZhbHNlYCB0byBjb21wbGV0ZWx5IHN0b3AgdGhlIGNoYW5nZXMgaW5cbnRoZSB0cmFuc2FjdGlvbiwgb3IgYSBzZXQgb2YgcmFuZ2VzIGluIHdoaWNoIGNoYW5nZXMgc2hvdWxkIGJlXG5zdXBwcmVzc2VkLiBTdWNoIHJhbmdlcyBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgbnVtYmVycyxcbndpdGggZWFjaCBwYWlyIG9mIHR3byBudW1iZXJzIGluZGljYXRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgYVxucmFuZ2UuIFNvIGZvciBleGFtcGxlIGBbMTAsIDIwLCAxMDAsIDExMF1gIHN1cHByZXNzZXMgY2hhbmdlc1xuYmV0d2VlbiAxMCBhbmQgMjAsIGFuZCBiZXR3ZWVuIDEwMCBhbmQgMTEwLlxuKi9cbkVkaXRvclN0YXRlLmNoYW5nZUZpbHRlciA9IGNoYW5nZUZpbHRlcjtcbi8qKlxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBhIGhvb2sgdGhhdCBnZXRzIGEgY2hhbmNlIHRvIHVwZGF0ZSBvclxucmVwbGFjZSB0cmFuc2FjdGlvbiBzcGVjcyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZC4gVGhpcyB3aWxsXG5vbmx5IGJlIGFwcGxpZWQgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGRvbid0IGhhdmVcbltgZmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSBzZXQgdG8gYGZhbHNlYC4gWW91XG5jYW4gZWl0aGVyIHJldHVybiBhIHNpbmdsZSB0cmFuc2FjdGlvbiBzcGVjIChwb3NzaWJseSB0aGUgaW5wdXRcbnRyYW5zYWN0aW9uKSwgb3IgYW4gYXJyYXkgb2Ygc3BlY3MgKHdoaWNoIHdpbGwgYmUgY29tYmluZWQgaW5cbnRoZSBzYW1lIHdheSBhcyB0aGUgYXJndW1lbnRzIHRvXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSkuXG5cbldoZW4gcG9zc2libGUsIGl0IGlzIHJlY29tbWVuZGVkIHRvIGF2b2lkIGFjY2Vzc2luZ1xuW2BUcmFuc2FjdGlvbi5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpIGluIGEgZmlsdGVyLFxuc2luY2UgaXQgd2lsbCBmb3JjZSBjcmVhdGlvbiBvZiBhIHN0YXRlIHRoYXQgd2lsbCB0aGVuIGJlXG5kaXNjYXJkZWQgYWdhaW4sIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhY3R1YWxseSBmaWx0ZXJlZC5cblxuKFRoaXMgZnVuY3Rpb25hbGl0eSBzaG91bGQgYmUgdXNlZCB3aXRoIGNhcmUuIEluZGlzY3JpbWluYXRlbHlcbm1vZGlmeWluZyB0cmFuc2FjdGlvbiBpcyBsaWtlbHkgdG8gYnJlYWsgc29tZXRoaW5nIG9yIGRlZ3JhZGVcbnRoZSB1c2VyIGV4cGVyaWVuY2UuKVxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRmlsdGVyID0gdHJhbnNhY3Rpb25GaWx0ZXI7XG4vKipcblRoaXMgaXMgYSBtb3JlIGxpbWl0ZWQgZm9ybSBvZlxuW2B0cmFuc2FjdGlvbkZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpLFxud2hpY2ggY2FuIG9ubHkgYWRkXG5bYW5ub3RhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmFubm90YXRpb25zKSBhbmRcbltlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKS4gX0J1dF8sIHRoaXMgdHlwZVxub2YgZmlsdGVyIHJ1bnMgZXZlbiBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGRpc2FibGVkIHJlZ3VsYXJcbltmaWx0ZXJpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlciksIG1ha2luZyBpdCBzdWl0YWJsZVxuZm9yIGVmZmVjdHMgdGhhdCBkb24ndCBuZWVkIHRvIHRvdWNoIHRoZSBjaGFuZ2VzIG9yIHNlbGVjdGlvbixcbmJ1dCBkbyB3YW50IHRvIHByb2Nlc3MgZXZlcnkgdHJhbnNhY3Rpb24uXG5cbkV4dGVuZGVycyBydW4gX2FmdGVyXyBmaWx0ZXJzLCB3aGVuIGJvdGggYXJlIHByZXNlbnQuXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25FeHRlbmRlciA9IHRyYW5zYWN0aW9uRXh0ZW5kZXI7XG5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcblxuLyoqXG5VdGlsaXR5IGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgYmVoYXZpb3JzIHRvIGZpbGwgaW4gYSBjb25maWdcbm9iamVjdCBmcm9tIGFuIGFycmF5IG9mIHByb3ZpZGVkIGNvbmZpZ3MuIGBkZWZhdWx0c2Agc2hvdWxkIGhvbGRcbmRlZmF1bHQgdmFsdWVzIGZvciBhbGwgb3B0aW9uYWwgZmllbGRzIGluIGBDb25maWdgLlxuXG5UaGUgZnVuY3Rpb24gd2lsbCwgYnkgZGVmYXVsdCwgZXJyb3JcbndoZW4gYSBmaWVsZCBnZXRzIHR3byB2YWx1ZXMgdGhhdCBhcmVuJ3QgYD09PWAtZXF1YWwsIGJ1dCB5b3UgY2FuXG5wcm92aWRlIGNvbWJpbmUgZnVuY3Rpb25zIHBlciBmaWVsZCB0byBkbyBzb21ldGhpbmcgZWxzZS5cbiovXG5mdW5jdGlvbiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIGRlZmF1bHRzLCAvLyBTaG91bGQgaG9sZCBvbmx5IHRoZSBvcHRpb25hbCBwcm9wZXJ0aWVzIG9mIENvbmZpZywgYnV0IEkgaGF2ZW4ndCBtYW5hZ2VkIHRvIGV4cHJlc3MgdGhhdFxuY29tYmluZSA9IHt9KSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKVxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoY29uZmlnKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gY29uZmlnW2tleV0sIGN1cnJlbnQgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQgPT09IHZhbHVlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIDsgLy8gTm8gY29uZmxpY3RcbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbWJpbmUsIGtleSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjb21iaW5lW2tleV0oY3VycmVudCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmZpZyBtZXJnZSBjb25mbGljdCBmb3IgZmllbGQgXCIgKyBrZXkpO1xuICAgICAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRzKVxuICAgICAgICBpZiAocmVzdWx0W2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbkVhY2ggcmFuZ2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdmFsdWUsIHdoaWNoIG11c3QgaW5oZXJpdCBmcm9tXG50aGlzIGNsYXNzLlxuKi9cbmNsYXNzIFJhbmdlVmFsdWUge1xuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyB2YWx1ZSB3aXRoIGFub3RoZXIgdmFsdWUuIFVzZWQgd2hlbiBjb21wYXJpbmdcbiAgICByYW5nZXNldHMuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGNvbXBhcmVzIGJ5IGlkZW50aXR5LlxuICAgIFVubGVzcyB5b3UgYXJlIG9ubHkgY3JlYXRpbmcgYSBmaXhlZCBudW1iZXIgb2YgdW5pcXVlIGluc3RhbmNlc1xuICAgIG9mIHlvdXIgdmFsdWUgdHlwZSwgaXQgaXMgYSBnb29kIGlkZWEgdG8gaW1wbGVtZW50IHRoaXNcbiAgICBwcm9wZXJseS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzID09IG90aGVyOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSB3aXRoIHRoaXMgdmFsdWUuXG4gICAgKi9cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHsgcmV0dXJuIFJhbmdlLmNyZWF0ZShmcm9tLCB0bywgdGhpcyk7IH1cbn1cblJhbmdlVmFsdWUucHJvdG90eXBlLnN0YXJ0U2lkZSA9IFJhbmdlVmFsdWUucHJvdG90eXBlLmVuZFNpZGUgPSAwO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcblJhbmdlVmFsdWUucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrRGVsO1xuLyoqXG5BIHJhbmdlIGFzc29jaWF0ZXMgYSB2YWx1ZSB3aXRoIGEgcmFuZ2Ugb2YgcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmFuZ2UncyBzdGFydCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIEl0cyBlbmQgcG9zaXRpb24uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJhbmdlLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShmcm9tLCB0bywgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNtcFJhbmdlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudmFsdWUuc3RhcnRTaWRlIC0gYi52YWx1ZS5zdGFydFNpZGU7XG59XG5jbGFzcyBDaHVuayB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHZhbHVlLCBcbiAgICAvLyBDaHVua3MgYXJlIG1hcmtlZCB3aXRoIHRoZSBsYXJnZXN0IHBvaW50IHRoYXQgb2NjdXJzXG4gICAgLy8gaW4gdGhlbSAob3IgLTEgZm9yIG5vIHBvaW50cyksIHNvIHRoYXQgc2NhbnMgdGhhdCBhcmVcbiAgICAvLyBvbmx5IGludGVyZXN0ZWQgaW4gcG9pbnRzIChzdWNoIGFzIHRoZVxuICAgIC8vIGhlaWdodG1hcC1yZWxhdGVkIGxvZ2ljKSBjYW4gc2tpcCByYW5nZS1vbmx5IGNodW5rcy5cbiAgICBtYXhQb2ludCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50b1t0aGlzLnRvLmxlbmd0aCAtIDFdOyB9XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlLiBVc2UgdGhlIHJhbmdlcydcbiAgICAvLyBgZnJvbWAgcG9zIHdoZW4gYGVuZCA9PSBmYWxzZWAsIGB0b2Agd2hlbiBgZW5kID09IHRydWVgLlxuICAgIGZpbmRJbmRleChwb3MsIHNpZGUsIGVuZCwgc3RhcnRBdCA9IDApIHtcbiAgICAgICAgbGV0IGFyciA9IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207XG4gICAgICAgIGZvciAobGV0IGxvID0gc3RhcnRBdCwgaGkgPSBhcnIubGVuZ3RoOzspIHtcbiAgICAgICAgICAgIGlmIChsbyA9PSBoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbG87XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgICAgICAgICBsZXQgZGlmZiA9IGFyclttaWRdIC0gcG9zIHx8IChlbmQgPyB0aGlzLnZhbHVlW21pZF0uZW5kU2lkZSA6IHRoaXMudmFsdWVbbWlkXS5zdGFydFNpZGUpIC0gc2lkZTtcbiAgICAgICAgICAgIGlmIChtaWQgPT0gbG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPj0gMCA/IGxvIDogaGk7XG4gICAgICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiZXR3ZWVuKG9mZnNldCwgZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmluZEluZGV4KGZyb20sIC0xMDAwMDAwMDAwIC8qIEMuRmFyICovLCB0cnVlKSwgZSA9IHRoaXMuZmluZEluZGV4KHRvLCAxMDAwMDAwMDAwIC8qIEMuRmFyICovLCBmYWxzZSwgaSk7IGkgPCBlOyBpKyspXG4gICAgICAgICAgICBpZiAoZih0aGlzLmZyb21baV0gKyBvZmZzZXQsIHRoaXMudG9baV0gKyBvZmZzZXQsIHRoaXMudmFsdWVbaV0pID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcChvZmZzZXQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gW10sIGZyb20gPSBbXSwgdG8gPSBbXSwgbmV3UG9zID0gLTEsIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMudmFsdWVbaV0sIGN1ckZyb20gPSB0aGlzLmZyb21baV0gKyBvZmZzZXQsIGN1clRvID0gdGhpcy50b1tpXSArIG9mZnNldCwgbmV3RnJvbSwgbmV3VG87XG4gICAgICAgICAgICBpZiAoY3VyRnJvbSA9PSBjdXJUbykge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlLCB2YWwubWFwTW9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gbmV3VG8gPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5zdGFydFNpZGUgIT0gdmFsLmVuZFNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUbyA8IG5ld0Zyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSk7XG4gICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJUbywgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdGcm9tID4gbmV3VG8gfHwgbmV3RnJvbSA9PSBuZXdUbyAmJiB2YWwuc3RhcnRTaWRlID4gMCAmJiB2YWwuZW5kU2lkZSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobmV3VG8gLSBuZXdGcm9tIHx8IHZhbC5lbmRTaWRlIC0gdmFsLnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5ld1BvcyA8IDApXG4gICAgICAgICAgICAgICAgbmV3UG9zID0gbmV3RnJvbTtcbiAgICAgICAgICAgIGlmICh2YWwucG9pbnQpXG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbmV3VG8gLSBuZXdGcm9tKTtcbiAgICAgICAgICAgIHZhbHVlLnB1c2godmFsKTtcbiAgICAgICAgICAgIGZyb20ucHVzaChuZXdGcm9tIC0gbmV3UG9zKTtcbiAgICAgICAgICAgIHRvLnB1c2gobmV3VG8gLSBuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcHBlZDogdmFsdWUubGVuZ3RoID8gbmV3IENodW5rKGZyb20sIHRvLCB2YWx1ZSwgbWF4UG9pbnQpIDogbnVsbCwgcG9zOiBuZXdQb3MgfTtcbiAgICB9XG59XG4vKipcbkEgcmFuZ2Ugc2V0IHN0b3JlcyBhIGNvbGxlY3Rpb24gb2YgW3Jhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgaW4gYVxud2F5IHRoYXQgbWFrZXMgdGhlbSBlZmZpY2llbnQgdG8gW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldC5tYXApIGFuZFxuW3VwZGF0ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldC51cGRhdGUpLiBUaGlzIGlzIGFuIGltbXV0YWJsZSBkYXRhXG5zdHJ1Y3R1cmUuXG4qL1xuY2xhc3MgUmFuZ2VTZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtQb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmssIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmV4dExheWVyLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBjaHVua1BvcztcbiAgICAgICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG5leHRMYXllcjtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY2h1bmtQb3MsIGNodW5rLCBuZXh0TGF5ZXIsIG1heFBvaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VTZXQoY2h1bmtQb3MsIGNodW5rLCBuZXh0TGF5ZXIsIG1heFBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY2h1bmsubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGxhc3QgPCAwID8gMCA6IE1hdGgubWF4KHRoaXMuY2h1bmtFbmQobGFzdCksIHRoaXMubmV4dExheWVyLmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgcmFuZ2VzIGluIHRoZSBzZXQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMubmV4dExheWVyLnNpemU7XG4gICAgICAgIGZvciAobGV0IGNodW5rIG9mIHRoaXMuY2h1bmspXG4gICAgICAgICAgICBzaXplICs9IGNodW5rLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtFbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmtQb3NbaW5kZXhdICsgdGhpcy5jaHVua1tpbmRleF0ubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHJhbmdlIHNldCwgb3B0aW9uYWxseSBhZGRpbmcgbmV3IHJhbmdlcyBvciBmaWx0ZXJpbmdcbiAgICBvdXQgZXhpc3Rpbmcgb25lcy5cbiAgICBcbiAgICAoTm90ZTogVGhlIHR5cGUgcGFyYW1ldGVyIGlzIGp1c3QgdGhlcmUgYXMgYSBrbHVkZ2UgdG8gd29ya1xuICAgIGFyb3VuZCBUeXBlU2NyaXB0IHZhcmlhbmNlIGlzc3VlcyB0aGF0IHByZXZlbnRlZCBgUmFuZ2VTZXQ8WD5gXG4gICAgZnJvbSBiZWluZyBhIHN1YnR5cGUgb2YgYFJhbmdlU2V0PFk+YCB3aGVuIGBYYCBpcyBhIHN1YnR5cGUgb2ZcbiAgICBgWWAuKVxuICAgICovXG4gICAgdXBkYXRlKHVwZGF0ZVNwZWMpIHtcbiAgICAgICAgbGV0IHsgYWRkID0gW10sIHNvcnQgPSBmYWxzZSwgZmlsdGVyRnJvbSA9IDAsIGZpbHRlclRvID0gdGhpcy5sZW5ndGggfSA9IHVwZGF0ZVNwZWM7XG4gICAgICAgIGxldCBmaWx0ZXIgPSB1cGRhdGVTcGVjLmZpbHRlcjtcbiAgICAgICAgaWYgKGFkZC5sZW5ndGggPT0gMCAmJiAhZmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChzb3J0KVxuICAgICAgICAgICAgYWRkID0gYWRkLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gYWRkLmxlbmd0aCA/IFJhbmdlU2V0Lm9mKGFkZCkgOiB0aGlzO1xuICAgICAgICBsZXQgY3VyID0gbmV3IExheWVyQ3Vyc29yKHRoaXMsIG51bGwsIC0xKS5nb3RvKDApLCBpID0gMCwgc3BpbGwgPSBbXTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIHdoaWxlIChjdXIudmFsdWUgfHwgaSA8IGFkZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIDwgYWRkLmxlbmd0aCAmJiAoY3VyLmZyb20gLSBhZGRbaV0uZnJvbSB8fCBjdXIuc3RhcnRTaWRlIC0gYWRkW2ldLnZhbHVlLnN0YXJ0U2lkZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGFkZFtpKytdO1xuICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ci5yYW5nZUluZGV4ID09IDEgJiYgY3VyLmNodW5rSW5kZXggPCB0aGlzLmNodW5rLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIChpID09IGFkZC5sZW5ndGggfHwgdGhpcy5jaHVua0VuZChjdXIuY2h1bmtJbmRleCkgPCBhZGRbaV0uZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXJGcm9tID4gdGhpcy5jaHVua0VuZChjdXIuY2h1bmtJbmRleCkgfHwgZmlsdGVyVG8gPCB0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSkgJiZcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZENodW5rKHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdLCB0aGlzLmNodW5rW2N1ci5jaHVua0luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjdXIubmV4dENodW5rKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXJGcm9tID4gY3VyLnRvIHx8IGZpbHRlclRvIDwgY3VyLmZyb20gfHwgZmlsdGVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKFJhbmdlLmNyZWF0ZShjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2hJbm5lcih0aGlzLm5leHRMYXllci5pc0VtcHR5ICYmICFzcGlsbC5sZW5ndGggPyBSYW5nZVNldC5lbXB0eVxuICAgICAgICAgICAgOiB0aGlzLm5leHRMYXllci51cGRhdGUoeyBhZGQ6IHNwaWxsLCBmaWx0ZXIsIGZpbHRlckZyb20sIGZpbHRlclRvIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgcmFuZ2Ugc2V0IHRocm91Z2ggYSBzZXQgb2YgY2hhbmdlcywgcmV0dXJuIHRoZSBuZXcgc2V0LlxuICAgICovXG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgfHwgdGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBjaHVua3MgPSBbXSwgY2h1bmtQb3MgPSBbXSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBsZXQgdG91Y2ggPSBjaGFuZ2VzLnRvdWNoZXNSYW5nZShzdGFydCwgc3RhcnQgKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHRvdWNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIGNodW5rLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChjaGFuZ2VzLm1hcFBvcyhzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXBwZWQsIHBvcyB9ID0gY2h1bmsubWFwKHN0YXJ0LCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG1hcHBlZC5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLm5leHRMYXllci5tYXAoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiBjaHVua3MubGVuZ3RoID09IDAgPyBuZXh0IDogbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVua3MsIG5leHQgfHwgUmFuZ2VTZXQuZW1wdHksIG1heFBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgdGhhdCB0b3VjaCB0aGUgcmVnaW9uIGBmcm9tYCB0byBgdG9gLFxuICAgIGNhbGxpbmcgYGZgIGZvciBlYWNoLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2VzIHdpbGxcbiAgICBiZSByZXBvcnRlZCBpbiBhbnkgc3BlY2lmaWMgb3JkZXIuIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICBgZmFsc2VgLCBpdGVyYXRpb24gc3RvcHMuXG4gICAgKi9cbiAgICBiZXR3ZWVuKGZyb20sIHRvLCBmKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgaWYgKHRvID49IHN0YXJ0ICYmIGZyb20gPD0gc3RhcnQgKyBjaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjaHVuay5iZXR3ZWVuKHN0YXJ0LCBmcm9tIC0gc3RhcnQsIHRvIC0gc3RhcnQsIGYpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIuYmV0d2Vlbihmcm9tLCB0bywgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGluIHRoaXMgc2V0LCBpbiBvcmRlciwgaW5jbHVkaW5nIGFsbFxuICAgIHJhbmdlcyB0aGF0IGVuZCBhdCBvciBhZnRlciBgZnJvbWAuXG4gICAgKi9cbiAgICBpdGVyKGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oW3RoaXNdKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpc0VtcHR5KCkgeyByZXR1cm4gdGhpcy5uZXh0TGF5ZXIgPT0gdGhpczsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGluIGEgY29sbGVjdGlvbiBvZiBzZXRzLCBpbiBvcmRlcixcbiAgICBzdGFydGluZyBmcm9tIGBmcm9tYC5cbiAgICAqL1xuICAgIHN0YXRpYyBpdGVyKHNldHMsIGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oc2V0cykuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHR3byBncm91cHMgb2Ygc2V0cywgY2FsbGluZyBtZXRob2RzIG9uIGBjb21wYXJhdG9yYFxuICAgIHRvIG5vdGlmeSBpdCBvZiBwb3NzaWJsZSBkaWZmZXJlbmNlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlKG9sZFNldHMsIG5ld1NldHMsIFxuICAgIC8qKlxuICAgIFRoaXMgaW5kaWNhdGVzIGhvdyB0aGUgdW5kZXJseWluZyBkYXRhIGNoYW5nZWQgYmV0d2VlbiB0aGVzZVxuICAgIHJhbmdlcywgYW5kIGlzIG5lZWRlZCB0byBzeW5jaHJvbml6ZSB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgdGV4dERpZmYsIGNvbXBhcmF0b3IsIFxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGlnbm9yZSBhbGwgbm9uLXBvaW50IHJhbmdlcywgYW5kIHBvaW50cyBiZWxvd1xuICAgIHRoZSBnaXZlbiBzaXplLiBXaGVuIC0xLCBhbGwgcmFuZ2VzIGFyZSBjb21wYXJlZC5cbiAgICAqL1xuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+IDAgfHwgIXNldC5pc0VtcHR5ICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcbiAgICAgICAgdGV4dERpZmYuaXRlckdhcHMoKGZyb21BLCBmcm9tQiwgbGVuZ3RoKSA9PiBjb21wYXJlKHNpZGVBLCBmcm9tQSwgc2lkZUIsIGZyb21CLCBsZW5ndGgsIGNvbXBhcmF0b3IpKTtcbiAgICAgICAgaWYgKHRleHREaWZmLmVtcHR5ICYmIHRleHREaWZmLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgY29tcGFyZShzaWRlQSwgMCwgc2lkZUIsIDAsIDAsIGNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoZSBjb250ZW50cyBvZiB0d28gZ3JvdXBzIG9mIHJhbmdlIHNldHMsIHJldHVybmluZyB0cnVlXG4gICAgaWYgdGhleSBhcmUgZXF1aXZhbGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZXEob2xkU2V0cywgbmV3U2V0cywgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovIC0gMTtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG5ld1NldHMuaW5kZXhPZihzZXQpIDwgMCk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBvbGRTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghYS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYik7XG4gICAgICAgIGxldCBzaWRlQSA9IG5ldyBTcGFuQ3Vyc29yKGEsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKSwgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byAhPSBzaWRlQi50byB8fFxuICAgICAgICAgICAgICAgICFzYW1lVmFsdWVzKHNpZGVBLmFjdGl2ZSwgc2lkZUIuYWN0aXZlKSB8fFxuICAgICAgICAgICAgICAgIHNpZGVBLnBvaW50ICYmICghc2lkZUIucG9pbnQgfHwgIXNpZGVBLnBvaW50LmVxKHNpZGVCLnBvaW50KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpZGVBLnRvID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzaWRlQS5uZXh0KCk7XG4gICAgICAgICAgICBzaWRlQi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgZ3JvdXAgb2YgcmFuZ2Ugc2V0cyBhdCB0aGUgc2FtZSB0aW1lLCBub3RpZnlpbmdcbiAgICB0aGUgaXRlcmF0b3IgYWJvdXQgdGhlIHJhbmdlcyBjb3ZlcmluZyBldmVyeSBnaXZlbiBwaWVjZSBvZlxuICAgIGNvbnRlbnQuIFJldHVybnMgdGhlIG9wZW4gY291bnQgKHNlZVxuICAgIFtgU3Bhbkl0ZXJhdG9yLnNwYW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNwYW5JdGVyYXRvci5zcGFuKSkgYXQgdGhlIGVuZFxuICAgIG9mIHRoZSBpdGVyYXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgc3BhbnMoc2V0cywgZnJvbSwgdG8sIGl0ZXJhdG9yLCBcbiAgICAvKipcbiAgICBXaGVuIGdpdmVuIGFuZCBncmVhdGVyIHRoYW4gLTEsIG9ubHkgcG9pbnRzIG9mIGF0IGxlYXN0IHRoaXNcbiAgICBzaXplIGFyZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFNwYW5DdXJzb3Ioc2V0cywgbnVsbCwgbWluUG9pbnRTaXplKS5nb3RvKGZyb20pLCBwb3MgPSBmcm9tO1xuICAgICAgICBsZXQgb3BlblJhbmdlcyA9IGN1cnNvci5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBjdXJUbyA9IE1hdGgubWluKGN1cnNvci50bywgdG8pO1xuICAgICAgICAgICAgaWYgKGN1cnNvci5wb2ludCkge1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBjdXJzb3IuYWN0aXZlRm9yUG9pbnQoY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBsZXQgb3BlbkNvdW50ID0gY3Vyc29yLnBvaW50RnJvbSA8IGZyb20gPyBhY3RpdmUubGVuZ3RoICsgMSA6IE1hdGgubWluKGFjdGl2ZS5sZW5ndGgsIG9wZW5SYW5nZXMpO1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnBvaW50KHBvcywgY3VyVG8sIGN1cnNvci5wb2ludCwgYWN0aXZlLCBvcGVuQ291bnQsIGN1cnNvci5wb2ludFJhbmspO1xuICAgICAgICAgICAgICAgIG9wZW5SYW5nZXMgPSBNYXRoLm1pbihjdXJzb3Iub3BlbkVuZChjdXJUbyksIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyVG8gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5zcGFuKHBvcywgY3VyVG8sIGN1cnNvci5hY3RpdmUsIG9wZW5SYW5nZXMpO1xuICAgICAgICAgICAgICAgIG9wZW5SYW5nZXMgPSBjdXJzb3Iub3BlbkVuZChjdXJUbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5SYW5nZXMgKyAoY3Vyc29yLnBvaW50ICYmIGN1cnNvci50byA+IHRvID8gMSA6IDApO1xuICAgICAgICAgICAgcG9zID0gY3Vyc29yLnRvO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSByYW5nZSBzZXQgZm9yIHRoZSBnaXZlbiByYW5nZSBvciBhcnJheSBvZiByYW5nZXMuIEJ5XG4gICAgZGVmYXVsdCwgdGhpcyBleHBlY3RzIHRoZSByYW5nZXMgdG8gYmUgX3NvcnRlZF8gKGJ5IHN0YXJ0XG4gICAgcG9zaXRpb24gYW5kLCBpZiB0d28gc3RhcnQgYXQgdGhlIHNhbWUgcG9zaXRpb24sXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApLiBZb3UgY2FuIHBhc3MgYHRydWVgIGFzIHNlY29uZCBhcmd1bWVudCB0b1xuICAgIGNhdXNlIHRoZSBtZXRob2QgdG8gc29ydCB0aGVtLlxuICAgICovXG4gICAgc3RhdGljIG9mKHJhbmdlcywgc29ydCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBidWlsZCA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgcmFuZ2VzIGluc3RhbmNlb2YgUmFuZ2UgPyBbcmFuZ2VzXSA6IHNvcnQgPyBsYXp5U29ydChyYW5nZXMpIDogcmFuZ2VzKVxuICAgICAgICAgICAgYnVpbGQuYWRkKHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBidWlsZC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSm9pbiBhbiBhcnJheSBvZiByYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LlxuICAgICovXG4gICAgc3RhdGljIGpvaW4oc2V0cykge1xuICAgICAgICBpZiAoIXNldHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFJhbmdlU2V0LmVtcHR5O1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2V0c1tzZXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKGxldCBpID0gc2V0cy5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZm9yIChsZXQgbGF5ZXIgPSBzZXRzW2ldOyBsYXllciAhPSBSYW5nZVNldC5lbXB0eTsgbGF5ZXIgPSBsYXllci5uZXh0TGF5ZXIpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFJhbmdlU2V0KGxheWVyLmNodW5rUG9zLCBsYXllci5jaHVuaywgcmVzdWx0LCBNYXRoLm1heChsYXllci5tYXhQb2ludCwgcmVzdWx0Lm1heFBvaW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgcmFuZ2VzLlxuKi9cblJhbmdlU2V0LmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBSYW5nZVNldChbXSwgW10sIG51bGwsIC0xKTtcbmZ1bmN0aW9uIGxhenlTb3J0KHJhbmdlcykge1xuICAgIGlmIChyYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgZm9yIChsZXQgcHJldiA9IHJhbmdlc1swXSwgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSByYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAoY21wUmFuZ2UocHJldiwgY3VyKSA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlcy5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xuICAgICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5SYW5nZVNldC5lbXB0eS5uZXh0TGF5ZXIgPSBSYW5nZVNldC5lbXB0eTtcbi8qKlxuQSByYW5nZSBzZXQgYnVpbGRlciBpcyBhIGRhdGEgc3RydWN0dXJlIHRoYXQgaGVscHMgYnVpbGQgdXAgYVxuW3JhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldCkgZGlyZWN0bHksIHdpdGhvdXQgZmlyc3QgYWxsb2NhdGluZ1xuYW4gYXJyYXkgb2YgW2BSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIG9iamVjdHMuXG4qL1xuY2xhc3MgUmFuZ2VTZXRCdWlsZGVyIHtcbiAgICBmaW5pc2hDaHVuayhuZXdBcnJheXMpIHtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgQ2h1bmsodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnZhbHVlLCB0aGlzLm1heFBvaW50KSk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IE1hdGgubWF4KHRoaXMuc2V0TWF4UG9pbnQsIHRoaXMubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XG4gICAgICAgIGlmIChuZXdBcnJheXMpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBidWlsZGVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5sYXN0VG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSByYW5nZS4gUmFuZ2VzIHNob3VsZCBiZSBhZGRlZCBpbiBzb3J0ZWQgKGJ5IGBmcm9tYCBhbmRcbiAgICBgdmFsdWUuc3RhcnRTaWRlYCkgb3JkZXIuXG4gICAgKi9cbiAgICBhZGQoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5hZGRJbm5lcihmcm9tLCB0bywgdmFsdWUpKVxuICAgICAgICAgICAgKHRoaXMubmV4dExheWVyIHx8ICh0aGlzLm5leHRMYXllciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIpKS5hZGQoZnJvbSwgdG8sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRJbm5lcihmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSBmcm9tIC0gdGhpcy5sYXN0VG8gfHwgdmFsdWUuc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGU7XG4gICAgICAgIGlmIChkaWZmIDw9IDAgJiYgKGZyb20gLSB0aGlzLmxhc3RGcm9tIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5zdGFydFNpZGUpIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlcyBtdXN0IGJlIGFkZGVkIHNvcnRlZCBieSBgZnJvbWAgcG9zaXRpb24gYW5kIGBzdGFydFNpZGVgXCIpO1xuICAgICAgICBpZiAoZGlmZiA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmZyb20ubGVuZ3RoID09IDI1MCAvKiBDLkNodW5rU2l6ZSAqLylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5mcm9tLnB1c2goZnJvbSAtIHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMudG8ucHVzaCh0byAtIHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMubGFzdCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlLnBvaW50KVxuICAgICAgICAgICAgdGhpcy5tYXhQb2ludCA9IE1hdGgubWF4KHRoaXMubWF4UG9pbnQsIHRvIC0gZnJvbSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZENodW5rKGZyb20sIGNodW5rKSB7XG4gICAgICAgIGlmICgoZnJvbSAtIHRoaXMubGFzdFRvIHx8IGNodW5rLnZhbHVlWzBdLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlKSA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmZyb20ubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayh0cnVlKTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IE1hdGgubWF4KHRoaXMuc2V0TWF4UG9pbnQsIGNodW5rLm1heFBvaW50KTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaChmcm9tKTtcbiAgICAgICAgbGV0IGxhc3QgPSBjaHVuay52YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmxhc3QgPSBjaHVuay52YWx1ZVtsYXN0XTtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGNodW5rLmZyb21bbGFzdF0gKyBmcm9tO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IGNodW5rLnRvW2xhc3RdICsgZnJvbTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmlzaCB0aGUgcmFuZ2Ugc2V0LiBSZXR1cm5zIHRoZSBuZXcgc2V0LiBUaGUgYnVpbGRlciBjYW4ndCBiZVxuICAgIHVzZWQgYW55bW9yZSBhZnRlciB0aGlzIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAqL1xuICAgIGZpbmlzaCgpIHsgcmV0dXJuIHRoaXMuZmluaXNoSW5uZXIoUmFuZ2VTZXQuZW1wdHkpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5pc2hJbm5lcihuZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20ubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayhmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICBsZXQgcmVzdWx0ID0gUmFuZ2VTZXQuY3JlYXRlKHRoaXMuY2h1bmtQb3MsIHRoaXMuY2h1bmtzLCB0aGlzLm5leHRMYXllciA/IHRoaXMubmV4dExheWVyLmZpbmlzaElubmVyKG5leHQpIDogbmV4dCwgdGhpcy5zZXRNYXhQb2ludCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IG51bGw7IC8vIE1ha2Ugc3VyZSBmdXJ0aGVyIGBhZGRgIGNhbGxzIHByb2R1Y2UgZXJyb3JzXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZFNoYXJlZENodW5rcyhhLCBiLCB0ZXh0RGlmZikge1xuICAgIGxldCBpbkEgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgc2V0IG9mIGEpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNodW5rLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldC5jaHVua1tpXS5tYXhQb2ludCA8PSAwKVxuICAgICAgICAgICAgICAgIGluQS5zZXQoc2V0LmNodW5rW2ldLCBzZXQuY2h1bmtQb3NbaV0pO1xuICAgIGxldCBzaGFyZWQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgc2V0IG9mIGIpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQga25vd24gPSBpbkEuZ2V0KHNldC5jaHVua1tpXSk7XG4gICAgICAgICAgICBpZiAoa25vd24gIT0gbnVsbCAmJiAodGV4dERpZmYgPyB0ZXh0RGlmZi5tYXBQb3Moa25vd24pIDoga25vd24pID09IHNldC5jaHVua1Bvc1tpXSAmJlxuICAgICAgICAgICAgICAgICEodGV4dERpZmYgPT09IG51bGwgfHwgdGV4dERpZmYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHREaWZmLnRvdWNoZXNSYW5nZShrbm93biwga25vd24gKyBzZXQuY2h1bmtbaV0ubGVuZ3RoKSkpXG4gICAgICAgICAgICAgICAgc2hhcmVkLmFkZChzZXQuY2h1bmtbaV0pO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHNoYXJlZDtcbn1cbmNsYXNzIExheWVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihsYXllciwgc2tpcCwgbWluUG9pbnQsIHJhbmsgPSAwKSB7XG4gICAgICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xuICAgICAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdldCBlbmRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuZW5kU2lkZSA6IDA7IH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIHRoaXMuY2h1bmtJbmRleCA9IHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ290b0lubmVyKHBvcywgc2lkZSwgZm9yd2FyZCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEodGhpcy5za2lwICYmIHRoaXMuc2tpcC5oYXMobmV4dCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVyLmNodW5rRW5kKHRoaXMuY2h1bmtJbmRleCkgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICBuZXh0Lm1heFBvaW50IDwgdGhpcy5taW5Qb2ludCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIGZvcndhcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByYW5nZUluZGV4ID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLmZpbmRJbmRleChwb3MgLSB0aGlzLmxheWVyLmNodW5rUG9zW3RoaXMuY2h1bmtJbmRleF0sIHNpZGUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFmb3J3YXJkIHx8IHRoaXMucmFuZ2VJbmRleCA8IHJhbmdlSW5kZXgpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHJhbmdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoKHRoaXMudG8gLSBwb3MgfHwgdGhpcy5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5nb3RvSW5uZXIocG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA9PSB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNodW5rUG9zID0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBjaHVuayA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGNodW5rUG9zICsgY2h1bmsuZnJvbVt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IGNodW5rUG9zICsgY2h1bmsudG9bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gY2h1bmsudmFsdWVbdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5kZXgodGhpcy5yYW5nZUluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWluUG9pbnQgPCAwIHx8IHRoaXMudmFsdWUucG9pbnQgJiYgdGhpcy50byAtIHRoaXMuZnJvbSA+PSB0aGlzLm1pblBvaW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRSYW5nZUluZGV4KGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0udmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGggJiYgdGhpcy5za2lwLmhhcyh0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0Q2h1bmsoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tIC0gb3RoZXIuZnJvbSB8fCB0aGlzLnN0YXJ0U2lkZSAtIG90aGVyLnN0YXJ0U2lkZSB8fCB0aGlzLnJhbmsgLSBvdGhlci5yYW5rIHx8XG4gICAgICAgICAgICB0aGlzLnRvIC0gb3RoZXIudG8gfHwgdGhpcy5lbmRTaWRlIC0gb3RoZXIuZW5kU2lkZTtcbiAgICB9XG59XG5jbGFzcyBIZWFwQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihoZWFwKSB7XG4gICAgICAgIHRoaXMuaGVhcCA9IGhlYXA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNldHMsIHNraXAgPSBudWxsLCBtaW5Qb2ludCA9IC0xKSB7XG4gICAgICAgIGxldCBoZWFwID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY3VyID0gc2V0c1tpXTsgIWN1ci5pc0VtcHR5OyBjdXIgPSBjdXIubmV4dExheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5tYXhQb2ludCA+PSBtaW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgaGVhcC5wdXNoKG5ldyBMYXllckN1cnNvcihjdXIsIHNraXAsIG1pblBvaW50LCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYXAubGVuZ3RoID09IDEgPyBoZWFwWzBdIDogbmV3IEhlYXBDdXJzb3IoaGVhcCk7XG4gICAgfVxuICAgIGdldCBzdGFydFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwOyB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxuICAgICAgICAgICAgY3VyLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgZm9yIChsZXQgY3VyIG9mIHRoaXMuaGVhcClcbiAgICAgICAgICAgIGN1ci5mb3J3YXJkKHBvcywgc2lkZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIGkpO1xuICAgICAgICBpZiAoKHRoaXMudG8gLSBwb3MgfHwgdGhpcy52YWx1ZS5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYXAubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJhbmsgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLmhlYXBbMF07XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0b3AuZnJvbTtcbiAgICAgICAgICAgIHRoaXMudG8gPSB0b3AudG87XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdG9wLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gdG9wLnJhbms7XG4gICAgICAgICAgICBpZiAodG9wLnZhbHVlKVxuICAgICAgICAgICAgICAgIHRvcC5uZXh0KCk7XG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoZWFwQnViYmxlKGhlYXAsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgY3VyID0gaGVhcFtpbmRleF07Oykge1xuICAgICAgICBsZXQgY2hpbGRJbmRleCA9IChpbmRleCA8PCAxKSArIDE7XG4gICAgICAgIGlmIChjaGlsZEluZGV4ID49IGhlYXAubGVuZ3RoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleF07XG4gICAgICAgIGlmIChjaGlsZEluZGV4ICsgMSA8IGhlYXAubGVuZ3RoICYmIGNoaWxkLmNvbXBhcmUoaGVhcFtjaGlsZEluZGV4ICsgMV0pID49IDApIHtcbiAgICAgICAgICAgIGNoaWxkID0gaGVhcFtjaGlsZEluZGV4ICsgMV07XG4gICAgICAgICAgICBjaGlsZEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5jb21wYXJlKGNoaWxkKSA8IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaGVhcFtjaGlsZEluZGV4XSA9IGN1cjtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBjaGlsZDtcbiAgICAgICAgaW5kZXggPSBjaGlsZEluZGV4O1xuICAgIH1cbn1cbmNsYXNzIFNwYW5DdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNldHMsIHNraXAsIG1pblBvaW50KSB7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVUbyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVJhbmsgPSBbXTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgLy8gQSBjdXJyZW50bHkgYWN0aXZlIHBvaW50IHJhbmdlLCBpZiBhbnlcbiAgICAgICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRGcm9tID0gMDtcbiAgICAgICAgdGhpcy5wb2ludFJhbmsgPSAwO1xuICAgICAgICB0aGlzLnRvID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IDA7XG4gICAgICAgIC8vIFRoZSBhbW91bnQgb2Ygb3BlbiBhY3RpdmUgcmFuZ2VzIGF0IHRoZSBzdGFydCBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgIC8vIE5vdCBpbmNsdWRpbmcgcG9pbnRzLlxuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmN1cnNvciA9IEhlYXBDdXJzb3IuZnJvbShzZXRzLCBza2lwLCBtaW5Qb2ludCk7XG4gICAgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgdGhpcy5jdXJzb3IuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICB0aGlzLmFjdGl2ZS5sZW5ndGggPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCA9IHRoaXMuYWN0aXZlUmFuay5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IC0xO1xuICAgICAgICB0aGlzLnRvID0gcG9zO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSBzaWRlO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1pbkFjdGl2ZSA+IC0xICYmICh0aGlzLmFjdGl2ZVRvW3RoaXMubWluQWN0aXZlXSAtIHBvcyB8fCB0aGlzLmFjdGl2ZVt0aGlzLm1pbkFjdGl2ZV0uZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKHRoaXMubWluQWN0aXZlKTtcbiAgICAgICAgdGhpcy5jdXJzb3IuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgIH1cbiAgICByZW1vdmVBY3RpdmUoaW5kZXgpIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlLCBpbmRleCk7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZVRvLCBpbmRleCk7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZVJhbmssIGluZGV4KTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICAgIH1cbiAgICBhZGRBY3RpdmUodHJhY2tPcGVuKSB7XG4gICAgICAgIGxldCBpID0gMCwgeyB2YWx1ZSwgdG8sIHJhbmsgfSA9IHRoaXMuY3Vyc29yO1xuICAgICAgICAvLyBPcmdhbml6ZSBhY3RpdmUgbWFya3MgYnkgcmFuayBmaXJzdCwgdGhlbiBieSBzaXplXG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCAmJiAocmFuayAtIHRoaXMuYWN0aXZlUmFua1tpXSB8fCB0byAtIHRoaXMuYWN0aXZlVG9baV0pID4gMClcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlLCBpLCB2YWx1ZSk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVRvLCBpLCB0byk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVJhbmssIGksIHJhbmspO1xuICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgaW5zZXJ0KHRyYWNrT3BlbiwgaSwgdGhpcy5jdXJzb3IuZnJvbSk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgY2FsbGluZyB0aGlzLCBpZiBgdGhpcy5wb2ludGAgIT0gbnVsbCwgdGhlIG5leHQgcmFuZ2UgaXMgYVxuICAgIC8vIHBvaW50LiBPdGhlcndpc2UsIGl0J3MgYSByZWd1bGFyIHJhbmdlLCBjb3ZlcmVkIGJ5IGB0aGlzLmFjdGl2ZWAuXG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnRvLCB3YXNQb2ludCA9IHRoaXMucG9pbnQ7XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICBsZXQgdHJhY2tPcGVuID0gdGhpcy5vcGVuU3RhcnQgPCAwID8gW10gOiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMubWluQWN0aXZlO1xuICAgICAgICAgICAgaWYgKGEgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1thXSAtIHRoaXMuY3Vyc29yLmZyb20gfHwgdGhpcy5hY3RpdmVbYV0uZW5kU2lkZSAtIHRoaXMuY3Vyc29yLnN0YXJ0U2lkZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9bYV0gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmFjdGl2ZVRvW2FdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUoYSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHRyYWNrT3BlbiwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJzb3IudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5lbmRTaWRlID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3Vyc29yLmZyb20gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRWYWwgPSB0aGlzLmN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRWYWwucG9pbnQpIHsgLy8gT3BlbmluZyBhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQWN0aXZlKHRyYWNrT3Blbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2FzUG9pbnQgJiYgdGhpcy5jdXJzb3IudG8gPT0gdGhpcy50byAmJiB0aGlzLmN1cnNvci5mcm9tIDwgdGhpcy5jdXJzb3IudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBub24tZW1wdHkgcG9pbnRzIHRoYXQgZW5kIHByZWNpc2VseSBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIE5ldyBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ID0gbmV4dFZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEZyb20gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50UmFuayA9IHRoaXMuY3Vyc29yLnJhbms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci50bztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gbmV4dFZhbC5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCh0aGlzLnRvLCB0aGlzLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRyYWNrT3Blbi5sZW5ndGggLSAxOyBpID49IDAgJiYgdHJhY2tPcGVuW2ldIDwgZnJvbTsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWN0aXZlRm9yUG9pbnQodG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVSYW5rW2ldIDwgdGhpcy5wb2ludFJhbmspXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1tpXSA+IHRvIHx8IHRoaXMuYWN0aXZlVG9baV0gPT0gdG8gJiYgdGhpcy5hY3RpdmVbaV0uZW5kU2lkZSA+PSB0aGlzLnBvaW50LmVuZFNpZGUpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2godGhpcy5hY3RpdmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBvcGVuRW5kKHRvKSB7XG4gICAgICAgIGxldCBvcGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRoaXMuYWN0aXZlVG9baV0gPiB0bzsgaS0tKVxuICAgICAgICAgICAgb3BlbisrO1xuICAgICAgICByZXR1cm4gb3BlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIHN0YXJ0QSwgYiwgc3RhcnRCLCBsZW5ndGgsIGNvbXBhcmF0b3IpIHtcbiAgICBhLmdvdG8oc3RhcnRBKTtcbiAgICBiLmdvdG8oc3RhcnRCKTtcbiAgICBsZXQgZW5kQiA9IHN0YXJ0QiArIGxlbmd0aDtcbiAgICBsZXQgcG9zID0gc3RhcnRCLCBkUG9zID0gc3RhcnRCIC0gc3RhcnRBO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGRpZmYgPSAoYS50byArIGRQb3MpIC0gYi50byB8fCBhLmVuZFNpZGUgLSBiLmVuZFNpZGU7XG4gICAgICAgIGxldCBlbmQgPSBkaWZmIDwgMCA/IGEudG8gKyBkUG9zIDogYi50bywgY2xpcEVuZCA9IE1hdGgubWluKGVuZCwgZW5kQik7XG4gICAgICAgIGlmIChhLnBvaW50IHx8IGIucG9pbnQpIHtcbiAgICAgICAgICAgIGlmICghKGEucG9pbnQgJiYgYi5wb2ludCAmJiAoYS5wb2ludCA9PSBiLnBvaW50IHx8IGEucG9pbnQuZXEoYi5wb2ludCkpICYmXG4gICAgICAgICAgICAgICAgc2FtZVZhbHVlcyhhLmFjdGl2ZUZvclBvaW50KGEudG8pLCBiLmFjdGl2ZUZvclBvaW50KGIudG8pKSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUG9pbnQocG9zLCBjbGlwRW5kLCBhLnBvaW50LCBiLnBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGlwRW5kID4gcG9zICYmICFzYW1lVmFsdWVzKGEuYWN0aXZlLCBiLmFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvci5jb21wYXJlUmFuZ2UocG9zLCBjbGlwRW5kLCBhLmFjdGl2ZSwgYi5hY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPiBlbmRCKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgaWYgKGRpZmYgPD0gMClcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZVZhbHVlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldICYmICFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCwgZSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPCBlOyBpKyspXG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIDFdO1xuICAgIGFycmF5LnBvcCgpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSBpbmRleDsgaS0tKVxuICAgICAgICBhcnJheVtpICsgMV0gPSBhcnJheVtpXTtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRNaW5JbmRleCh2YWx1ZSwgYXJyYXkpIHtcbiAgICBsZXQgZm91bmQgPSAtMSwgZm91bmRQb3MgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICgoYXJyYXlbaV0gLSBmb3VuZFBvcyB8fCB2YWx1ZVtpXS5lbmRTaWRlIC0gdmFsdWVbZm91bmRdLmVuZFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgZm91bmRQb3MgPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG5Db3VudCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQgaW50byB0aGUgc3RyaW5nLFxudGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuXG4qL1xuZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCB0YWJTaXplLCB0byA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bzspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpIHtcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5GaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gY29sdW1uIHBvc2l0aW9uIGluIGFcbnN0cmluZywgdGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuIEJ5XG5kZWZhdWx0LCB0aGUgc3RyaW5nIGxlbmd0aCBpcyByZXR1cm5lZCB3aGVuIGl0IGlzIHRvbyBzaG9ydCB0b1xucmVhY2ggdGhlIGNvbHVtbi4gUGFzcyBgc3RyaWN0YCB0cnVlIHRvIG1ha2UgaXQgcmV0dXJuIC0xIGluIHRoYXRcbnNpdHVhdGlvbi5cbiovXG5mdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgY29sLCB0YWJTaXplLCBzdHJpY3QpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IDA7Oykge1xuICAgICAgICBpZiAobiA+PSBjb2wpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgaWYgKGkgPT0gc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkgPyB0YWJTaXplIC0gKG4gJSB0YWJTaXplKSA6IDE7XG4gICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpY3QgPT09IHRydWUgPyAtMSA6IHN0cmluZy5sZW5ndGg7XG59XG5cbmV4cG9ydCB7IEFubm90YXRpb24sIEFubm90YXRpb25UeXBlLCBDaGFuZ2VEZXNjLCBDaGFuZ2VTZXQsIENoYXJDYXRlZ29yeSwgQ29tcGFydG1lbnQsIEVkaXRvclNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIEZhY2V0LCBMaW5lLCBNYXBNb2RlLCBQcmVjLCBSYW5nZSwgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUmFuZ2VWYWx1ZSwgU2VsZWN0aW9uUmFuZ2UsIFN0YXRlRWZmZWN0LCBTdGF0ZUVmZmVjdFR5cGUsIFN0YXRlRmllbGQsIFRleHQsIFRyYW5zYWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY29tYmluZUNvbmZpZywgY291bnRDb2x1bW4sIGZpbmRDbHVzdGVyQnJlYWssIGZpbmRDb2x1bW4sIGZyb21Db2RlUG9pbnQgfTtcbiJdLCJuYW1lcyI6WyJUZXh0IiwibGluZUF0IiwicG9zIiwibGVuZ3RoIiwiUmFuZ2VFcnJvciIsImxpbmVJbm5lciIsImxpbmUiLCJuIiwibGluZXMiLCJyZXBsYWNlIiwiZnJvbSIsInRvIiwidGV4dCIsImNsaXAiLCJwYXJ0cyIsImRlY29tcG9zZSIsIlRleHROb2RlIiwiYXBwZW5kIiwib3RoZXIiLCJzbGljZSIsImVxIiwic3RhcnQiLCJzY2FuSWRlbnRpY2FsIiwiZW5kIiwiYSIsIlJhd1RleHRDdXJzb3IiLCJiIiwic2tpcCIsIm5leHQiLCJsaW5lQnJlYWsiLCJkb25lIiwidmFsdWUiLCJpdGVyIiwiZGlyIiwiaXRlclJhbmdlIiwiUGFydGlhbFRleHRDdXJzb3IiLCJpdGVyTGluZXMiLCJpbm5lciIsIk1hdGgiLCJtYXgiLCJMaW5lQ3Vyc29yIiwidG9TdHJpbmciLCJzbGljZVN0cmluZyIsInRvSlNPTiIsImZsYXR0ZW4iLCJjb25zdHJ1Y3RvciIsIm9mIiwiZW1wdHkiLCJUZXh0TGVhZiIsInNwbGl0IiwidGV4dExlbmd0aCIsImNoaWxkcmVuIiwidGFyZ2V0IiwiaXNMaW5lIiwib2Zmc2V0IiwiaSIsInN0cmluZyIsIkxpbmUiLCJvcGVuIiwic2xpY2VUZXh0IiwibWluIiwicHJldiIsInBvcCIsImpvaW5lZCIsImFwcGVuZFRleHQiLCJwdXNoIiwibWlkIiwibmV3TGVuIiwibGluZVNlcCIsInJlc3VsdCIsInBhcnQiLCJsZW4iLCJjaGlsZCIsImVuZExpbmUiLCJjaGlsZE9wZW4iLCJ1cGRhdGVkIiwidG90YWxMaW5lcyIsImNvcHkiLCJpQSIsImlCIiwiZUEiLCJlQiIsImNoQSIsImNoQiIsInJlZHVjZSIsImwiLCJjaCIsImZsYXQiLCJjaHVuayIsIm1heENodW5rIiwibWluQ2h1bmsiLCJjaHVua2VkIiwiY3VycmVudExpbmVzIiwiY3VycmVudExlbiIsImN1cnJlbnRDaHVuayIsImFkZCIsImxhc3QiLCJub2RlIiwiZmx1c2giLCJjb25jYXQiLCJmaXJzdCIsIm5vZGVzIiwib2Zmc2V0cyIsIm5leHRJbm5lciIsInRvcCIsIm9mZnNldFZhbHVlIiwic2l6ZSIsImN1cnNvciIsImxpbWl0IiwiYWZ0ZXJCcmVhayIsIlN5bWJvbCIsInByb3RvdHlwZSIsIml0ZXJhdG9yIiwibnVtYmVyIiwiZXh0ZW5kIiwibWFwIiwicyIsInBhcnNlSW50IiwiaXNFeHRlbmRpbmdDaGFyIiwiY29kZSIsImlzUmVnaW9uYWxJbmRpY2F0b3IiLCJaV0oiLCJmaW5kQ2x1c3RlckJyZWFrIiwic3RyIiwiZm9yd2FyZCIsImluY2x1ZGVFeHRlbmRpbmciLCJuZXh0Q2x1c3RlckJyZWFrIiwicHJldkNsdXN0ZXJCcmVhayIsInN1cnJvZ2F0ZUxvdyIsImNoYXJDb2RlQXQiLCJzdXJyb2dhdGVIaWdoIiwiY29kZVBvaW50QXQiLCJjb2RlUG9pbnRTaXplIiwiY291bnRCZWZvcmUiLCJmb3VuZCIsImNvZGUwIiwiY29kZTEiLCJmcm9tQ29kZVBvaW50IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiRGVmYXVsdFNwbGl0IiwiTWFwTW9kZSIsIkNoYW5nZURlc2MiLCJzZWN0aW9ucyIsIm5ld0xlbmd0aCIsImlucyIsIml0ZXJHYXBzIiwiZiIsInBvc0EiLCJwb3NCIiwiaXRlckNoYW5nZWRSYW5nZXMiLCJpbmRpdmlkdWFsIiwiaXRlckNoYW5nZXMiLCJpbnZlcnRlZERlc2MiLCJjb21wb3NlRGVzYyIsImNvbXBvc2VTZXRzIiwibWFwRGVzYyIsImJlZm9yZSIsIm1hcFNldCIsIm1hcFBvcyIsImFzc29jIiwibW9kZSIsIlNpbXBsZSIsImVuZEEiLCJUcmFja0RlbCIsIlRyYWNrQmVmb3JlIiwiVHJhY2tBZnRlciIsInRvdWNoZXNSYW5nZSIsImZyb21KU09OIiwianNvbiIsIkFycmF5IiwiaXNBcnJheSIsInNvbWUiLCJjcmVhdGUiLCJDaGFuZ2VTZXQiLCJpbnNlcnRlZCIsImFwcGx5IiwiZG9jIiwiZnJvbUEiLCJ0b0EiLCJmcm9tQiIsIl90b0IiLCJpbnZlcnQiLCJpbmRleCIsImNvbXBvc2UiLCJkZXNjIiwiZmlsdGVyIiwicmFuZ2VzIiwicmVzdWx0U2VjdGlvbnMiLCJyZXN1bHRJbnNlcnRlZCIsImZpbHRlcmVkU2VjdGlvbnMiLCJTZWN0aW9uSXRlciIsImFkZFNlY3Rpb24iLCJvZmYiLCJhZGRJbnNlcnQiLCJjaGFuZ2VzIiwiZmlsdGVyZWQiLCJ0b3RhbCIsImZvcmNlIiwic2V0IiwicHJvY2VzcyIsInNwZWMiLCJzdWIiLCJpbnNlcnQiLCJpbnNUZXh0IiwiaW5zTGVuIiwiZSIsImNyZWF0ZVNldCIsImZvcmNlSm9pbiIsInZhbHVlcyIsImVuZEIiLCJzZXRBIiwic2V0QiIsIm1rU2V0IiwicGllY2UiLCJsZWZ0IiwiRXJyb3IiLCJsZW4yIiwic2VjdGlvbkxlbiIsImluc0IiLCJ0ZXh0Qml0IiwiZm9yd2FyZDIiLCJ1bmRlZmluZWQiLCJTZWxlY3Rpb25SYW5nZSIsImZsYWdzIiwiYW5jaG9yIiwiaGVhZCIsImJpZGlMZXZlbCIsImxldmVsIiwiZ29hbENvbHVtbiIsImNoYW5nZSIsIkVkaXRvclNlbGVjdGlvbiIsInJhbmdlIiwiYWJzIiwiaW5jbHVkZUFzc29jIiwibWFpbkluZGV4IiwiciIsIm1haW4iLCJhc1NpbmdsZSIsImFkZFJhbmdlIiwicmVwbGFjZVJhbmdlIiwid2hpY2giLCJzaW5nbGUiLCJub3JtYWxpemVkIiwic29ydCIsImluZGV4T2YiLCJzcGxpY2UiLCJjaGVja1NlbGVjdGlvbiIsInNlbGVjdGlvbiIsImRvY0xlbmd0aCIsIm5leHRJRCIsIkZhY2V0IiwiY29tYmluZSIsImNvbXBhcmVJbnB1dCIsImNvbXBhcmUiLCJpc1N0YXRpYyIsImVuYWJsZXMiLCJpZCIsImRlZmF1bHQiLCJleHRlbnNpb25zIiwicmVhZGVyIiwiZGVmaW5lIiwiY29uZmlnIiwic2FtZUFycmF5Iiwic3RhdGljIiwiRmFjZXRQcm92aWRlciIsImNvbXB1dGUiLCJkZXBzIiwiZ2V0IiwiY29tcHV0ZU4iLCJmaWVsZCIsIngiLCJzdGF0ZSIsImV2ZXJ5IiwiZGVwZW5kZW5jaWVzIiwiZmFjZXQiLCJ0eXBlIiwiZHluYW1pY1Nsb3QiLCJhZGRyZXNzZXMiLCJfYSIsImdldHRlciIsImlkeCIsIm11bHRpIiwiZGVwRG9jIiwiZGVwU2VsIiwiZGVwQWRkcnMiLCJkZXAiLCJ1cGRhdGUiLCJ0ciIsImRvY0NoYW5nZWQiLCJlbnN1cmVBbGwiLCJuZXdWYWwiLCJjb21wYXJlQXJyYXkiLCJyZWNvbmZpZ3VyZSIsIm9sZFN0YXRlIiwib2xkQWRkciIsImFkZHJlc3MiLCJvbGRWYWwiLCJnZXRBZGRyIiwiU3RhdGVGaWVsZCIsImFkZHJzIiwiY2hhbmdlZCIsImFkZHIiLCJlbnN1cmVBZGRyIiwiZHluYW1pY0ZhY2V0U2xvdCIsInByb3ZpZGVycyIsInByb3ZpZGVyQWRkcnMiLCJwIiwicHJvdmlkZXJUeXBlcyIsImR5bmFtaWMiLCJ2YWwiLCJkZXBDaGFuZ2VkIiwib2xkUHJvdmlkZXJzIiwiZmFjZXRzIiwib2xkVmFsdWUiLCJpbml0RmllbGQiLCJjcmVhdGVGIiwidXBkYXRlRiIsImNvbXBhcmVGIiwicHJvdmlkZXMiLCJwcm92aWRlIiwiaW5pdCIsImZpbmQiLCJzbG90IiwiZXh0ZW5zaW9uIiwiUHJlY18iLCJsb3dlc3QiLCJsb3ciLCJoaWdoIiwiaGlnaGVzdCIsInByZWMiLCJleHQiLCJQcmVjRXh0ZW5zaW9uIiwiUHJlYyIsIkNvbXBhcnRtZW50IiwiQ29tcGFydG1lbnRJbnN0YW5jZSIsImNvbnRlbnQiLCJjb21wYXJ0bWVudCIsImNvbXBhcnRtZW50cyIsIkNvbmZpZ3VyYXRpb24iLCJiYXNlIiwiZHluYW1pY1Nsb3RzIiwic3RhdGljVmFsdWVzIiwic3RhdHVzVGVtcGxhdGUiLCJzdGF0aWNGYWNldCIsInJlc29sdmUiLCJmaWVsZHMiLCJPYmplY3QiLCJuZXdDb21wYXJ0bWVudHMiLCJNYXAiLCJvbGRGYWNldHMiLCJzZWVuIiwia25vd24iLCJkZWxldGUiLCJoYXMiLCJzdGF0dXMiLCJjb21wdXRlU2xvdCIsImxhbmd1YWdlRGF0YSIsImFsbG93TXVsdGlwbGVTZWxlY3Rpb25zIiwidiIsImxpbmVTZXBhcmF0b3IiLCJjaGFuZ2VGaWx0ZXIiLCJ0cmFuc2FjdGlvbkZpbHRlciIsInRyYW5zYWN0aW9uRXh0ZW5kZXIiLCJyZWFkT25seSIsIkFubm90YXRpb24iLCJBbm5vdGF0aW9uVHlwZSIsIlN0YXRlRWZmZWN0VHlwZSIsIlN0YXRlRWZmZWN0IiwibWFwcGluZyIsIm1hcHBlZCIsImlzIiwibWFwRWZmZWN0cyIsImVmZmVjdHMiLCJlZmZlY3QiLCJhcHBlbmRDb25maWciLCJUcmFuc2FjdGlvbiIsInN0YXJ0U3RhdGUiLCJhbm5vdGF0aW9ucyIsInNjcm9sbEludG9WaWV3IiwiX2RvYyIsIl9zdGF0ZSIsInRpbWUiLCJEYXRlIiwibm93IiwibmV3RG9jIiwibmV3U2VsZWN0aW9uIiwiYXBwbHlUcmFuc2FjdGlvbiIsImFubm90YXRpb24iLCJhbm4iLCJyZWNvbmZpZ3VyZWQiLCJpc1VzZXJFdmVudCIsImV2ZW50IiwidXNlckV2ZW50IiwiYWRkVG9IaXN0b3J5IiwicmVtb3RlIiwiam9pblJhbmdlcyIsIm1lcmdlVHJhbnNhY3Rpb24iLCJzZXF1ZW50aWFsIiwibWFwRm9yQSIsIm1hcEZvckIiLCJyZXNvbHZlVHJhbnNhY3Rpb25Jbm5lciIsImRvY1NpemUiLCJzZWwiLCJhc0FycmF5IiwicmVzb2x2ZVRyYW5zYWN0aW9uIiwic3BlY3MiLCJzZXEiLCJleHRlbmRUcmFuc2FjdGlvbiIsImZpbHRlclRyYW5zYWN0aW9uIiwiYmFjayIsImZpbHRlcnMiLCJleHRlbmRlcnMiLCJrZXlzIiwibm9uZSIsIkNoYXJDYXRlZ29yeSIsIm5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyIiwid29yZENoYXIiLCJSZWdFeHAiLCJfIiwiaGFzV29yZENoYXIiLCJ0ZXN0IiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsIm1ha2VDYXRlZ29yaXplciIsIndvcmRDaGFycyIsImNoYXIiLCJTcGFjZSIsIldvcmQiLCJPdGhlciIsIkVkaXRvclN0YXRlIiwicmVxdWlyZSIsImNvbmYiLCJmb3JFYWNoIiwia2V5Iiwic3RhcnRWYWx1ZXMiLCJpbnRlcm1lZGlhdGVTdGF0ZSIsInJlcGxhY2VTZWxlY3Rpb24iLCJ0b1RleHQiLCJjaGFuZ2VCeVJhbmdlIiwicmVzdWx0MSIsIm5ld0NoYW5nZXMiLCJuZXdNYXBwZWQiLCJqIiwibWFwQnkiLCJzbGljZURvYyIsInByb3AiLCJmaWVsZEluaXQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJjb25maWd1cmF0aW9uIiwidGFiU2l6ZSIsInBocmFzZSIsInBocmFzZXMiLCJtIiwibGFuZ3VhZ2VEYXRhQXQiLCJuYW1lIiwic2lkZSIsInByb3ZpZGVyIiwiY2hhckNhdGVnb3JpemVyIiwiYXQiLCJqb2luIiwid29yZEF0IiwiY2F0Iiwia0EiLCJrQiIsImsiLCJjb21iaW5lQ29uZmlnIiwiY29uZmlncyIsImRlZmF1bHRzIiwiY3VycmVudCIsIlJhbmdlVmFsdWUiLCJSYW5nZSIsInN0YXJ0U2lkZSIsImVuZFNpZGUiLCJwb2ludCIsIm1hcE1vZGUiLCJjbXBSYW5nZSIsIkNodW5rIiwibWF4UG9pbnQiLCJmaW5kSW5kZXgiLCJzdGFydEF0IiwiYXJyIiwibG8iLCJoaSIsImRpZmYiLCJiZXR3ZWVuIiwibmV3UG9zIiwiY3VyRnJvbSIsImN1clRvIiwibmV3RnJvbSIsIm5ld1RvIiwiUmFuZ2VTZXQiLCJjaHVua1BvcyIsIm5leHRMYXllciIsImNodW5rRW5kIiwiaXNFbXB0eSIsInVwZGF0ZVNwZWMiLCJmaWx0ZXJGcm9tIiwiZmlsdGVyVG8iLCJjdXIiLCJMYXllckN1cnNvciIsImdvdG8iLCJzcGlsbCIsImJ1aWxkZXIiLCJSYW5nZVNldEJ1aWxkZXIiLCJhZGRJbm5lciIsInJhbmdlSW5kZXgiLCJjaHVua0luZGV4IiwiYWRkQ2h1bmsiLCJuZXh0Q2h1bmsiLCJmaW5pc2hJbm5lciIsImNodW5rcyIsInRvdWNoIiwiSGVhcEN1cnNvciIsInNldHMiLCJvbGRTZXRzIiwibmV3U2V0cyIsInRleHREaWZmIiwiY29tcGFyYXRvciIsIm1pblBvaW50U2l6ZSIsInNoYXJlZENodW5rcyIsImZpbmRTaGFyZWRDaHVua3MiLCJzaWRlQSIsIlNwYW5DdXJzb3IiLCJzaWRlQiIsInNhbWVWYWx1ZXMiLCJhY3RpdmUiLCJzcGFucyIsIm9wZW5SYW5nZXMiLCJvcGVuU3RhcnQiLCJhY3RpdmVGb3JQb2ludCIsIm9wZW5Db3VudCIsInBvaW50RnJvbSIsInBvaW50UmFuayIsIm9wZW5FbmQiLCJzcGFuIiwiYnVpbGQiLCJsYXp5U29ydCIsImZpbmlzaCIsImxheWVyIiwiZmluaXNoQ2h1bmsiLCJuZXdBcnJheXMiLCJjaHVua1N0YXJ0Iiwic2V0TWF4UG9pbnQiLCJsYXN0RnJvbSIsImxhc3RUbyIsImluQSIsInNoYXJlZCIsIlNldCIsIm1pblBvaW50IiwicmFuayIsImdvdG9Jbm5lciIsInNldFJhbmdlSW5kZXgiLCJoZWFwIiwiaGVhcEJ1YmJsZSIsImNoaWxkSW5kZXgiLCJhY3RpdmVUbyIsImFjdGl2ZVJhbmsiLCJtaW5BY3RpdmUiLCJyZW1vdmVBY3RpdmUiLCJyZW1vdmUiLCJmaW5kTWluSW5kZXgiLCJhZGRBY3RpdmUiLCJ0cmFja09wZW4iLCJ3YXNQb2ludCIsIm5leHRWYWwiLCJyZXZlcnNlIiwic3RhcnRBIiwic3RhcnRCIiwiZFBvcyIsImNsaXBFbmQiLCJjb21wYXJlUG9pbnQiLCJjb21wYXJlUmFuZ2UiLCJhcnJheSIsImZvdW5kUG9zIiwiY291bnRDb2x1bW4iLCJmaW5kQ29sdW1uIiwiY29sIiwic3RyaWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/state/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/theme-one-dark/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/theme-one-dark/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   color: () => (/* binding */ color),\n/* harmony export */   oneDark: () => (/* binding */ oneDark),\n/* harmony export */   oneDarkHighlightStyle: () => (/* binding */ oneDarkHighlightStyle),\n/* harmony export */   oneDarkTheme: () => (/* binding */ oneDarkTheme)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// Using https://github.com/one-dark/vscode-one-dark-theme/ as reference for the colors\nconst chalky = \"#e5c07b\", coral = \"#e06c75\", cyan = \"#56b6c2\", invalid = \"#ffffff\", ivory = \"#abb2bf\", stone = \"#7d8799\", malibu = \"#61afef\", sage = \"#98c379\", whiskey = \"#d19a66\", violet = \"#c678dd\", darkBackground = \"#21252b\", highlightBackground = \"#2c313a\", background = \"#282c34\", tooltipBackground = \"#353a42\", selection = \"#3E4451\", cursor = \"#528bff\";\n/**\nThe colors used in the theme, as CSS color strings.\n*/ const color = {\n    chalky,\n    coral,\n    cyan,\n    invalid,\n    ivory,\n    stone,\n    malibu,\n    sage,\n    whiskey,\n    violet,\n    darkBackground,\n    highlightBackground,\n    background,\n    tooltipBackground,\n    selection,\n    cursor\n};\n/**\nThe editor theme styles for One Dark.\n*/ const oneDarkTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.theme({\n    \"&\": {\n        color: ivory,\n        backgroundColor: background\n    },\n    \".cm-content\": {\n        caretColor: cursor\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeftColor: cursor\n    },\n    \"&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection\": {\n        backgroundColor: selection\n    },\n    \".cm-panels\": {\n        backgroundColor: darkBackground,\n        color: ivory\n    },\n    \".cm-panels.cm-panels-top\": {\n        borderBottom: \"2px solid black\"\n    },\n    \".cm-panels.cm-panels-bottom\": {\n        borderTop: \"2px solid black\"\n    },\n    \".cm-searchMatch\": {\n        backgroundColor: \"#72a1ff59\",\n        outline: \"1px solid #457dff\"\n    },\n    \".cm-searchMatch.cm-searchMatch-selected\": {\n        backgroundColor: \"#6199ff2f\"\n    },\n    \".cm-activeLine\": {\n        backgroundColor: \"#6699ff0b\"\n    },\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#aafe661a\"\n    },\n    \"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bad0f847\"\n    },\n    \".cm-gutters\": {\n        backgroundColor: background,\n        color: stone,\n        border: \"none\"\n    },\n    \".cm-activeLineGutter\": {\n        backgroundColor: highlightBackground\n    },\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"transparent\",\n        border: \"none\",\n        color: \"#ddd\"\n    },\n    \".cm-tooltip\": {\n        border: \"none\",\n        backgroundColor: tooltipBackground\n    },\n    \".cm-tooltip .cm-tooltip-arrow:before\": {\n        borderTopColor: \"transparent\",\n        borderBottomColor: \"transparent\"\n    },\n    \".cm-tooltip .cm-tooltip-arrow:after\": {\n        borderTopColor: tooltipBackground,\n        borderBottomColor: tooltipBackground\n    },\n    \".cm-tooltip-autocomplete\": {\n        \"& > ul > li[aria-selected]\": {\n            backgroundColor: highlightBackground,\n            color: ivory\n        }\n    }\n}, {\n    dark: true\n});\n/**\nThe highlighting style for code in the One Dark theme.\n*/ const oneDarkHighlightStyle = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.keyword,\n        color: violet\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.deleted,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.character,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.propertyName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.macroName\n        ],\n        color: coral\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.labelName\n        ],\n        color: malibu\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.color,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.constant(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name),\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name)\n        ],\n        color: whiskey\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.separator\n        ],\n        color: ivory\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.className,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.number,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.changed,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.annotation,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.modifier,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.self,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.namespace\n        ],\n        color: chalky\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operatorKeyword,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.escape,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string)\n        ],\n        color: cyan\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.meta,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.comment\n        ],\n        color: stone\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n        color: stone,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.heading,\n        fontWeight: \"bold\",\n        color: coral\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.bool,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName)\n        ],\n        color: whiskey\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.processingInstruction,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.inserted\n        ],\n        color: sage\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.invalid,\n        color: invalid\n    }\n]);\n/**\nExtension to enable the One Dark theme (both the editor theme and\nthe highlight style).\n*/ const oneDark = [\n    oneDarkTheme,\n    /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxHighlighting)(oneDarkHighlightStyle)\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvdGhlbWUtb25lLWRhcmsvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQThDO0FBQzRCO0FBQ2xDO0FBRXhDLHVGQUF1RjtBQUN2RixNQUFNSSxTQUFTLFdBQVdDLFFBQVEsV0FBV0MsT0FBTyxXQUFXQyxVQUFVLFdBQVdDLFFBQVEsV0FBV0MsUUFBUSxXQUMvR0MsU0FBUyxXQUFXQyxPQUFPLFdBQVdDLFVBQVUsV0FBV0MsU0FBUyxXQUFXQyxpQkFBaUIsV0FBV0Msc0JBQXNCLFdBQVdDLGFBQWEsV0FBV0Msb0JBQW9CLFdBQVdDLFlBQVksV0FBV0MsU0FBUztBQUNuTzs7QUFFQSxHQUNBLE1BQU1DLFFBQVE7SUFDVmhCO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLE1BQU1FLGVBQWUsV0FBVyxHQUFFckIsd0RBQVVBLENBQUNzQixLQUFLLENBQUM7SUFDL0MsS0FBSztRQUNERixPQUFPWjtRQUNQZSxpQkFBaUJQO0lBQ3JCO0lBQ0EsZUFBZTtRQUNYUSxZQUFZTDtJQUNoQjtJQUNBLDhCQUE4QjtRQUFFTSxpQkFBaUJOO0lBQU87SUFDeEQsOEhBQThIO1FBQUVJLGlCQUFpQkw7SUFBVTtJQUMzSixjQUFjO1FBQUVLLGlCQUFpQlQ7UUFBZ0JNLE9BQU9aO0lBQU07SUFDOUQsNEJBQTRCO1FBQUVrQixjQUFjO0lBQWtCO0lBQzlELCtCQUErQjtRQUFFQyxXQUFXO0lBQWtCO0lBQzlELG1CQUFtQjtRQUNmSixpQkFBaUI7UUFDakJLLFNBQVM7SUFDYjtJQUNBLDJDQUEyQztRQUN2Q0wsaUJBQWlCO0lBQ3JCO0lBQ0Esa0JBQWtCO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ2pELHNCQUFzQjtRQUFFQSxpQkFBaUI7SUFBWTtJQUNyRCx5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Q3ZCO1FBQUVqQyxLQUFLaEMsa0RBQUlBLENBQUNrRSxRQUFRO1FBQ2hCQyxXQUFXO0lBQVM7SUFDeEI7UUFBRW5DLEtBQUtoQyxrREFBSUEsQ0FBQ29FLGFBQWE7UUFDckJDLGdCQUFnQjtJQUFlO0lBQ25DO1FBQUVyQyxLQUFLaEMsa0RBQUlBLENBQUMyRCxJQUFJO1FBQ1oxQyxPQUFPWDtRQUNQK0QsZ0JBQWdCO0lBQVk7SUFDaEM7UUFBRXJDLEtBQUtoQyxrREFBSUEsQ0FBQ3NFLE9BQU87UUFDZkwsWUFBWTtRQUNaaEQsT0FBT2Y7SUFBTTtJQUNqQjtRQUFFOEIsS0FBSztZQUFDaEMsa0RBQUlBLENBQUN1RSxJQUFJO1lBQUV2RSxrREFBSUEsQ0FBQ3dFLElBQUk7WUFBRSxXQUFXLEdBQUV4RSxrREFBSUEsQ0FBQzRELE9BQU8sQ0FBQzVELGtEQUFJQSxDQUFDd0MsWUFBWTtTQUFFO1FBQ3ZFdkIsT0FBT1I7SUFBUTtJQUNuQjtRQUFFdUIsS0FBSztZQUFDaEMsa0RBQUlBLENBQUN5RSxxQkFBcUI7WUFBRXpFLGtEQUFJQSxDQUFDNkQsTUFBTTtZQUFFN0Qsa0RBQUlBLENBQUMwRSxRQUFRO1NBQUM7UUFDM0R6RCxPQUFPVDtJQUFLO0lBQ2hCO1FBQUV3QixLQUFLaEMsa0RBQUlBLENBQUNJLE9BQU87UUFDZmEsT0FBT2I7SUFBUTtDQUN0QjtBQUNEOzs7QUFHQSxHQUNBLE1BQU11RSxVQUFVO0lBQUN6RDtJQUFjLFdBQVcsR0FBRW5CLHdFQUFrQkEsQ0FBQytCO0NBQXVCO0FBRXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvdGhlbWUtb25lLWRhcmsvZGlzdC9pbmRleC5qcz9iNzhkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IEhpZ2hsaWdodFN0eWxlLCBzeW50YXhIaWdobGlnaHRpbmcgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyB0YWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5cbi8vIFVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9vbmUtZGFyay92c2NvZGUtb25lLWRhcmstdGhlbWUvIGFzIHJlZmVyZW5jZSBmb3IgdGhlIGNvbG9yc1xuY29uc3QgY2hhbGt5ID0gXCIjZTVjMDdiXCIsIGNvcmFsID0gXCIjZTA2Yzc1XCIsIGN5YW4gPSBcIiM1NmI2YzJcIiwgaW52YWxpZCA9IFwiI2ZmZmZmZlwiLCBpdm9yeSA9IFwiI2FiYjJiZlwiLCBzdG9uZSA9IFwiIzdkODc5OVwiLCAvLyBCcmlnaHRlbmVkIGNvbXBhcmVkIHRvIG9yaWdpbmFsIHRvIGluY3JlYXNlIGNvbnRyYXN0XG5tYWxpYnUgPSBcIiM2MWFmZWZcIiwgc2FnZSA9IFwiIzk4YzM3OVwiLCB3aGlza2V5ID0gXCIjZDE5YTY2XCIsIHZpb2xldCA9IFwiI2M2NzhkZFwiLCBkYXJrQmFja2dyb3VuZCA9IFwiIzIxMjUyYlwiLCBoaWdobGlnaHRCYWNrZ3JvdW5kID0gXCIjMmMzMTNhXCIsIGJhY2tncm91bmQgPSBcIiMyODJjMzRcIiwgdG9vbHRpcEJhY2tncm91bmQgPSBcIiMzNTNhNDJcIiwgc2VsZWN0aW9uID0gXCIjM0U0NDUxXCIsIGN1cnNvciA9IFwiIzUyOGJmZlwiO1xuLyoqXG5UaGUgY29sb3JzIHVzZWQgaW4gdGhlIHRoZW1lLCBhcyBDU1MgY29sb3Igc3RyaW5ncy5cbiovXG5jb25zdCBjb2xvciA9IHtcbiAgICBjaGFsa3ksXG4gICAgY29yYWwsXG4gICAgY3lhbixcbiAgICBpbnZhbGlkLFxuICAgIGl2b3J5LFxuICAgIHN0b25lLFxuICAgIG1hbGlidSxcbiAgICBzYWdlLFxuICAgIHdoaXNrZXksXG4gICAgdmlvbGV0LFxuICAgIGRhcmtCYWNrZ3JvdW5kLFxuICAgIGhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgYmFja2dyb3VuZCxcbiAgICB0b29sdGlwQmFja2dyb3VuZCxcbiAgICBzZWxlY3Rpb24sXG4gICAgY3Vyc29yXG59O1xuLyoqXG5UaGUgZWRpdG9yIHRoZW1lIHN0eWxlcyBmb3IgT25lIERhcmsuXG4qL1xuY29uc3Qgb25lRGFya1RoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcudGhlbWUoe1xuICAgIFwiJlwiOiB7XG4gICAgICAgIGNvbG9yOiBpdm9yeSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kXG4gICAgfSxcbiAgICBcIi5jbS1jb250ZW50XCI6IHtcbiAgICAgICAgY2FyZXRDb2xvcjogY3Vyc29yXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yXCI6IHsgYm9yZGVyTGVmdENvbG9yOiBjdXJzb3IgfSxcbiAgICBcIiYuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZCwgLmNtLXNlbGVjdGlvbkJhY2tncm91bmQsIC5jbS1jb250ZW50IDo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBzZWxlY3Rpb24gfSxcbiAgICBcIi5jbS1wYW5lbHNcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IGRhcmtCYWNrZ3JvdW5kLCBjb2xvcjogaXZvcnkgfSxcbiAgICBcIi5jbS1wYW5lbHMuY20tcGFuZWxzLXRvcFwiOiB7IGJvcmRlckJvdHRvbTogXCIycHggc29saWQgYmxhY2tcIiB9LFxuICAgIFwiLmNtLXBhbmVscy5jbS1wYW5lbHMtYm90dG9tXCI6IHsgYm9yZGVyVG9wOiBcIjJweCBzb2xpZCBibGFja1wiIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2hcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzcyYTFmZjU5XCIsXG4gICAgICAgIG91dGxpbmU6IFwiMXB4IHNvbGlkICM0NTdkZmZcIlxuICAgIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2guY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzYxOTlmZjJmXCJcbiAgICB9LFxuICAgIFwiLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzY2OTlmZjBiXCIgfSxcbiAgICBcIi5jbS1zZWxlY3Rpb25NYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjYWFmZTY2MWFcIiB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1tYXRjaGluZ0JyYWNrZXQsICYuY20tZm9jdXNlZCAuY20tbm9ubWF0Y2hpbmdCcmFja2V0XCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNiYWQwZjg0N1wiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kLFxuICAgICAgICBjb2xvcjogc3RvbmUsXG4gICAgICAgIGJvcmRlcjogXCJub25lXCJcbiAgICB9LFxuICAgIFwiLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmRcbiAgICB9LFxuICAgIFwiLmNtLWZvbGRQbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBjb2xvcjogXCIjZGRkXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRvb2x0aXBCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93OmJlZm9yZVwiOiB7XG4gICAgICAgIGJvcmRlclRvcENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3c6YWZ0ZXJcIjoge1xuICAgICAgICBib3JkZXJUb3BDb2xvcjogdG9vbHRpcEJhY2tncm91bmQsXG4gICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0b29sdGlwQmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC1hdXRvY29tcGxldGVcIjoge1xuICAgICAgICBcIiYgPiB1bCA+IGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaGlnaGxpZ2h0QmFja2dyb3VuZCxcbiAgICAgICAgICAgIGNvbG9yOiBpdm9yeVxuICAgICAgICB9XG4gICAgfVxufSwgeyBkYXJrOiB0cnVlIH0pO1xuLyoqXG5UaGUgaGlnaGxpZ2h0aW5nIHN0eWxlIGZvciBjb2RlIGluIHRoZSBPbmUgRGFyayB0aGVtZS5cbiovXG5jb25zdCBvbmVEYXJrSGlnaGxpZ2h0U3R5bGUgPSAvKkBfX1BVUkVfXyovSGlnaGxpZ2h0U3R5bGUuZGVmaW5lKFtcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLFxuICAgICAgICBjb2xvcjogdmlvbGV0IH0sXG4gICAgeyB0YWc6IFt0YWdzLm5hbWUsIHRhZ3MuZGVsZXRlZCwgdGFncy5jaGFyYWN0ZXIsIHRhZ3MucHJvcGVydHlOYW1lLCB0YWdzLm1hY3JvTmFtZV0sXG4gICAgICAgIGNvbG9yOiBjb3JhbCB9LFxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3MuZnVuY3Rpb24odGFncy52YXJpYWJsZU5hbWUpLCB0YWdzLmxhYmVsTmFtZV0sXG4gICAgICAgIGNvbG9yOiBtYWxpYnUgfSxcbiAgICB7IHRhZzogW3RhZ3MuY29sb3IsIC8qQF9fUFVSRV9fKi90YWdzLmNvbnN0YW50KHRhZ3MubmFtZSksIC8qQF9fUFVSRV9fKi90YWdzLnN0YW5kYXJkKHRhZ3MubmFtZSldLFxuICAgICAgICBjb2xvcjogd2hpc2tleSB9LFxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLm5hbWUpLCB0YWdzLnNlcGFyYXRvcl0sXG4gICAgICAgIGNvbG9yOiBpdm9yeSB9LFxuICAgIHsgdGFnOiBbdGFncy50eXBlTmFtZSwgdGFncy5jbGFzc05hbWUsIHRhZ3MubnVtYmVyLCB0YWdzLmNoYW5nZWQsIHRhZ3MuYW5ub3RhdGlvbiwgdGFncy5tb2RpZmllciwgdGFncy5zZWxmLCB0YWdzLm5hbWVzcGFjZV0sXG4gICAgICAgIGNvbG9yOiBjaGFsa3kgfSxcbiAgICB7IHRhZzogW3RhZ3Mub3BlcmF0b3IsIHRhZ3Mub3BlcmF0b3JLZXl3b3JkLCB0YWdzLnVybCwgdGFncy5lc2NhcGUsIHRhZ3MucmVnZXhwLCB0YWdzLmxpbmssIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSxcbiAgICAgICAgY29sb3I6IGN5YW4gfSxcbiAgICB7IHRhZzogW3RhZ3MubWV0YSwgdGFncy5jb21tZW50XSxcbiAgICAgICAgY29sb3I6IHN0b25lIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLFxuICAgICAgICBmb250U3R5bGU6IFwiaXRhbGljXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpa2V0aHJvdWdoLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJsaW5lLXRocm91Z2hcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpbmssXG4gICAgICAgIGNvbG9yOiBzdG9uZSxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICAgICAgY29sb3I6IGNvcmFsIH0sXG4gICAgeyB0YWc6IFt0YWdzLmF0b20sIHRhZ3MuYm9vbCwgLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSldLFxuICAgICAgICBjb2xvcjogd2hpc2tleSB9LFxuICAgIHsgdGFnOiBbdGFncy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIHRhZ3Muc3RyaW5nLCB0YWdzLmluc2VydGVkXSxcbiAgICAgICAgY29sb3I6IHNhZ2UgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLFxuICAgICAgICBjb2xvcjogaW52YWxpZCB9LFxuXSk7XG4vKipcbkV4dGVuc2lvbiB0byBlbmFibGUgdGhlIE9uZSBEYXJrIHRoZW1lIChib3RoIHRoZSBlZGl0b3IgdGhlbWUgYW5kXG50aGUgaGlnaGxpZ2h0IHN0eWxlKS5cbiovXG5jb25zdCBvbmVEYXJrID0gW29uZURhcmtUaGVtZSwgLypAX19QVVJFX18qL3N5bnRheEhpZ2hsaWdodGluZyhvbmVEYXJrSGlnaGxpZ2h0U3R5bGUpXTtcblxuZXhwb3J0IHsgY29sb3IsIG9uZURhcmssIG9uZURhcmtIaWdobGlnaHRTdHlsZSwgb25lRGFya1RoZW1lIH07XG4iXSwibmFtZXMiOlsiRWRpdG9yVmlldyIsIkhpZ2hsaWdodFN0eWxlIiwic3ludGF4SGlnaGxpZ2h0aW5nIiwidGFncyIsImNoYWxreSIsImNvcmFsIiwiY3lhbiIsImludmFsaWQiLCJpdm9yeSIsInN0b25lIiwibWFsaWJ1Iiwic2FnZSIsIndoaXNrZXkiLCJ2aW9sZXQiLCJkYXJrQmFja2dyb3VuZCIsImhpZ2hsaWdodEJhY2tncm91bmQiLCJiYWNrZ3JvdW5kIiwidG9vbHRpcEJhY2tncm91bmQiLCJzZWxlY3Rpb24iLCJjdXJzb3IiLCJjb2xvciIsIm9uZURhcmtUaGVtZSIsInRoZW1lIiwiYmFja2dyb3VuZENvbG9yIiwiY2FyZXRDb2xvciIsImJvcmRlckxlZnRDb2xvciIsImJvcmRlckJvdHRvbSIsImJvcmRlclRvcCIsIm91dGxpbmUiLCJib3JkZXIiLCJib3JkZXJUb3BDb2xvciIsImJvcmRlckJvdHRvbUNvbG9yIiwiZGFyayIsIm9uZURhcmtIaWdobGlnaHRTdHlsZSIsImRlZmluZSIsInRhZyIsImtleXdvcmQiLCJuYW1lIiwiZGVsZXRlZCIsImNoYXJhY3RlciIsInByb3BlcnR5TmFtZSIsIm1hY3JvTmFtZSIsImZ1bmN0aW9uIiwidmFyaWFibGVOYW1lIiwibGFiZWxOYW1lIiwiY29uc3RhbnQiLCJzdGFuZGFyZCIsImRlZmluaXRpb24iLCJzZXBhcmF0b3IiLCJ0eXBlTmFtZSIsImNsYXNzTmFtZSIsIm51bWJlciIsImNoYW5nZWQiLCJhbm5vdGF0aW9uIiwibW9kaWZpZXIiLCJzZWxmIiwibmFtZXNwYWNlIiwib3BlcmF0b3IiLCJvcGVyYXRvcktleXdvcmQiLCJ1cmwiLCJlc2NhcGUiLCJyZWdleHAiLCJsaW5rIiwic3BlY2lhbCIsInN0cmluZyIsIm1ldGEiLCJjb21tZW50Iiwic3Ryb25nIiwiZm9udFdlaWdodCIsImVtcGhhc2lzIiwiZm9udFN0eWxlIiwic3RyaWtldGhyb3VnaCIsInRleHREZWNvcmF0aW9uIiwiaGVhZGluZyIsImF0b20iLCJib29sIiwicHJvY2Vzc2luZ0luc3RydWN0aW9uIiwiaW5zZXJ0ZWQiLCJvbmVEYXJrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/theme-one-dark/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BidiSpan: () => (/* binding */ BidiSpan),\n/* harmony export */   BlockInfo: () => (/* binding */ BlockInfo),\n/* harmony export */   BlockType: () => (/* binding */ BlockType),\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   Direction: () => (/* binding */ Direction),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   GutterMarker: () => (/* binding */ GutterMarker),\n/* harmony export */   MatchDecorator: () => (/* binding */ MatchDecorator),\n/* harmony export */   RectangleMarker: () => (/* binding */ RectangleMarker),\n/* harmony export */   ViewPlugin: () => (/* binding */ ViewPlugin),\n/* harmony export */   ViewUpdate: () => (/* binding */ ViewUpdate),\n/* harmony export */   WidgetType: () => (/* binding */ WidgetType),\n/* harmony export */   __test: () => (/* binding */ __test),\n/* harmony export */   closeHoverTooltips: () => (/* binding */ closeHoverTooltips),\n/* harmony export */   crosshairCursor: () => (/* binding */ crosshairCursor),\n/* harmony export */   drawSelection: () => (/* binding */ drawSelection),\n/* harmony export */   dropCursor: () => (/* binding */ dropCursor),\n/* harmony export */   getDrawSelectionConfig: () => (/* binding */ getDrawSelectionConfig),\n/* harmony export */   getPanel: () => (/* binding */ getPanel),\n/* harmony export */   getTooltip: () => (/* binding */ getTooltip),\n/* harmony export */   gutter: () => (/* binding */ gutter),\n/* harmony export */   gutterLineClass: () => (/* binding */ gutterLineClass),\n/* harmony export */   gutters: () => (/* binding */ gutters),\n/* harmony export */   hasHoverTooltips: () => (/* binding */ hasHoverTooltips),\n/* harmony export */   highlightActiveLine: () => (/* binding */ highlightActiveLine),\n/* harmony export */   highlightActiveLineGutter: () => (/* binding */ highlightActiveLineGutter),\n/* harmony export */   highlightSpecialChars: () => (/* binding */ highlightSpecialChars),\n/* harmony export */   highlightTrailingWhitespace: () => (/* binding */ highlightTrailingWhitespace),\n/* harmony export */   highlightWhitespace: () => (/* binding */ highlightWhitespace),\n/* harmony export */   hoverTooltip: () => (/* binding */ hoverTooltip),\n/* harmony export */   keymap: () => (/* binding */ keymap),\n/* harmony export */   layer: () => (/* binding */ layer),\n/* harmony export */   lineNumberMarkers: () => (/* binding */ lineNumberMarkers),\n/* harmony export */   lineNumbers: () => (/* binding */ lineNumbers),\n/* harmony export */   logException: () => (/* binding */ logException),\n/* harmony export */   panels: () => (/* binding */ panels),\n/* harmony export */   placeholder: () => (/* binding */ placeholder),\n/* harmony export */   rectangularSelection: () => (/* binding */ rectangularSelection),\n/* harmony export */   repositionTooltips: () => (/* binding */ repositionTooltips),\n/* harmony export */   runScopeHandlers: () => (/* binding */ runScopeHandlers),\n/* harmony export */   scrollPastEnd: () => (/* binding */ scrollPastEnd),\n/* harmony export */   showPanel: () => (/* binding */ showPanel),\n/* harmony export */   showTooltip: () => (/* binding */ showTooltip),\n/* harmony export */   tooltips: () => (/* binding */ tooltips)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ \"(ssr)/./node_modules/w3c-keyname/index.js\");\n\n\n\nfunction getSelection(root) {\n    let target;\n    // Browsers differ on whether shadow roots have a getSelection\n    // method. If it exists, use that, otherwise, call it on the\n    // document.\n    if (root.nodeType == 11) {\n        target = root.getSelection ? root : root.ownerDocument;\n    } else {\n        target = root;\n    }\n    return target.getSelection();\n}\nfunction contains(dom, node) {\n    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while(elt && elt.shadowRoot)elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return contains(dom, selection.anchorNode);\n    } catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();\n    else if (dom.nodeType == 1) return dom.getClientRects();\n    else return [];\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;\n}\nfunction domIndex(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\") return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1) return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.nodeType == 1 && node.contentEditable == \"false\") return false;\n            off = dir < 0 ? maxOffset(node) : 0;\n        } else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction flattenRect(rect, left) {\n    let x = left ? rect.left : rect.right;\n    return {\n        left: x,\n        right: x,\n        top: rect.top,\n        bottom: rect.bottom\n    };\n}\nfunction windowRect(win) {\n    return {\n        left: 0,\n        right: win.innerWidth,\n        top: 0,\n        bottom: win.innerHeight\n    };\n}\nfunction getScale(elt, rect) {\n    let scaleX = rect.width / elt.offsetWidth;\n    let scaleY = rect.height / elt.offsetHeight;\n    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1) scaleX = 1;\n    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1) scaleY = 1;\n    return {\n        scaleX,\n        scaleY\n    };\n}\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    for(let cur = dom, stop = false; cur && !stop;){\n        if (cur.nodeType == 1) {\n            let bounding, top = cur == doc.body;\n            let scaleX = 1, scaleY = 1;\n            if (top) {\n                bounding = windowRect(win);\n            } else {\n                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position)) stop = true;\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.assignedSlot || cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                ({ scaleX, scaleY } = getScale(cur, rect));\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = {\n                    left: rect.left,\n                    right: rect.left + cur.clientWidth * scaleX,\n                    top: rect.top,\n                    bottom: rect.top + cur.clientHeight * scaleY\n                };\n            }\n            let moveX = 0, moveY = 0;\n            if (y == \"nearest\") {\n                if (rect.top < bounding.top) {\n                    moveY = -(bounding.top - rect.top + yMargin);\n                    if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + yMargin;\n                } else if (rect.bottom > bounding.bottom) {\n                    moveY = rect.bottom - bounding.bottom + yMargin;\n                    if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + yMargin);\n                }\n            } else {\n                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;\n                let targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;\n                moveY = targetTop - bounding.top;\n            }\n            if (x == \"nearest\") {\n                if (rect.left < bounding.left) {\n                    moveX = -(bounding.left - rect.left + xMargin);\n                    if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + xMargin;\n                } else if (rect.right > bounding.right) {\n                    moveX = rect.right - bounding.right + xMargin;\n                    if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + xMargin);\n                }\n            } else {\n                let targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == \"start\" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;\n                moveX = targetLeft - bounding.left;\n            }\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                } else {\n                    let movedX = 0, movedY = 0;\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY / scaleY;\n                        movedY = (cur.scrollTop - start) * scaleY;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX / scaleX;\n                        movedX = (cur.scrollLeft - start) * scaleX;\n                    }\n                    rect = {\n                        left: rect.left - movedX,\n                        top: rect.top - movedY,\n                        right: rect.right - movedX,\n                        bottom: rect.bottom - movedY\n                    };\n                    if (movedX && Math.abs(movedX - moveX) < 1) x = \"nearest\";\n                    if (movedY && Math.abs(movedY - moveY) < 1) y = \"nearest\";\n                }\n            }\n            if (top) break;\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n}\nfunction scrollableParent(dom) {\n    let doc = dom.ownerDocument;\n    for(let cur = dom.parentNode; cur;){\n        if (cur == doc.body) {\n            break;\n        } else if (cur.nodeType == 1) {\n            if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth) return cur;\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n    return null;\n}\nclass DOMSelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    setRange(range) {\n        let { anchorNode, focusNode } = range;\n        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)\n        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));\n    }\n    set(anchorNode, anchorOffset, focusNode, focusOffset) {\n        this.anchorNode = anchorNode;\n        this.anchorOffset = anchorOffset;\n        this.focusNode = focusNode;\n        this.focusOffset = focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stack = [];\n    for(let cur = dom; cur; cur = cur.parentNode){\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\n        if (cur == cur.ownerDocument) break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for(let i = 0; i < stack.length;){\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top) elt.scrollTop = top;\n            if (elt.scrollLeft != left) elt.scrollLeft = left;\n        }\n    }\n}\nlet scratchRange;\nfunction textRange(node, from, to = from) {\n    let range = scratchRange || (scratchRange = document.createRange());\n    range.setEnd(node, to);\n    range.setStart(node, from);\n    return range;\n}\nfunction dispatchKey(elt, name, code) {\n    let options = {\n        key: name,\n        code: name,\n        keyCode: code,\n        which: code,\n        cancelable: true\n    };\n    let down = new KeyboardEvent(\"keydown\", options);\n    down.synthetic = true;\n    elt.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    up.synthetic = true;\n    elt.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\nfunction getRoot(node) {\n    while(node){\n        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;\n        node = node.assignedSlot || node.parentNode;\n    }\n    return null;\n}\nfunction clearAttributes(node) {\n    while(node.attributes.length)node.removeAttributeNode(node.attributes[0]);\n}\nfunction atElementStart(doc, selection) {\n    let node = selection.focusNode, offset = selection.focusOffset;\n    if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;\n    // Safari can report bogus offsets (#1152)\n    offset = Math.min(offset, maxOffset(node));\n    for(;;){\n        if (offset) {\n            if (node.nodeType != 1) return false;\n            let prev = node.childNodes[offset - 1];\n            if (prev.contentEditable == \"false\") offset--;\n            else {\n                node = prev;\n                offset = maxOffset(node);\n            }\n        } else if (node == doc) {\n            return true;\n        } else {\n            offset = domIndex(node);\n            node = node.parentNode;\n        }\n    }\n}\nfunction isScrolledToBottom(elt) {\n    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);\n}\nclass DOMPos {\n    constructor(node, offset, precise = true){\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom), precise);\n    }\n    static after(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);\n    }\n}\nconst noChildren = [];\nclass ContentView {\n    constructor(){\n        this.parent = null;\n        this.dom = null;\n        this.flags = 2 /* ViewFlag.NodeDirty */ ;\n    }\n    get overrideDOMText() {\n        return null;\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children){\n            if (child == view) return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    sync(view, track) {\n        if (this.flags & 2 /* ViewFlag.NodeDirty */ ) {\n            let parent = this.dom;\n            let prev = null, next;\n            for (let child of this.children){\n                if (child.flags & 7 /* ViewFlag.Dirty */ ) {\n                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {\n                        let contentView = ContentView.get(next);\n                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);\n                    }\n                    child.sync(view, track);\n                    child.flags &= ~7 /* ViewFlag.Dirty */ ;\n                }\n                next = prev ? prev.nextSibling : parent.firstChild;\n                if (track && !track.written && track.node == parent && next != child.dom) track.written = true;\n                if (child.dom.parentNode == parent) {\n                    while(next && next != child.dom)next = rm$1(next);\n                } else {\n                    parent.insertBefore(child.dom, next);\n                }\n                prev = child.dom;\n            }\n            next = prev ? prev.nextSibling : parent.firstChild;\n            if (next && track && track.node == parent) track.written = true;\n            while(next)next = rm$1(next);\n        } else if (this.flags & 1 /* ViewFlag.ChildDirty */ ) {\n            for (let child of this.children)if (child.flags & 7 /* ViewFlag.Dirty */ ) {\n                child.sync(view, track);\n                child.flags &= ~7 /* ViewFlag.Dirty */ ;\n            }\n        }\n    }\n    reuseDOM(_dom) {}\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        } else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for(;;){\n                let parent = node.parentNode;\n                if (parent == this.dom) break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild) bias = -1;\n                    else bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0) after = node;\n            else after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild) return 0;\n        while(after && !ContentView.get(after))after = after.nextSibling;\n        if (!after) return this.length;\n        for(let i = 0, pos = 0;; i++){\n            let child = this.children[i];\n            if (child.dom == after) return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for(let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to) return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (pos > to && child.dom.parentNode == this.dom) {\n                toI = i;\n                toEnd = prevEnd;\n                break;\n            }\n            prevEnd = end;\n            pos = end + child.breakAfter;\n        }\n        return {\n            from: fromStart,\n            to: toEnd < 0 ? offset + this.length : toEnd,\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null\n        };\n    }\n    markDirty(andParent = false) {\n        this.flags |= 2 /* ViewFlag.NodeDirty */ ;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for(let parent = this.parent; parent; parent = parent.parent){\n            if (childList) parent.flags |= 2 /* ViewFlag.NodeDirty */ ;\n            if (parent.flags & 1 /* ViewFlag.ChildDirty */ ) return;\n            parent.flags |= 1 /* ViewFlag.ChildDirty */ ;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.flags & 7 /* ViewFlag.Dirty */ ) this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        if (this.dom == dom) return;\n        if (this.dom) this.dom.cmView = null;\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for(let v = this;;){\n            let parent = v.parent;\n            if (!parent) return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = noChildren) {\n        this.markDirty();\n        for(let i = from; i < to; i++){\n            let child = this.children[i];\n            if (child.parent == this && children.indexOf(child) < 0) child.destroy();\n        }\n        this.children.splice(from, to - from, ...children);\n        for(let i = 0; i < children.length; i++)children[i].setParent(this);\n    }\n    ignoreMutation(_rec) {\n        return false;\n    }\n    ignoreEvent(_event) {\n        return false;\n    }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" : this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") + (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) {\n        return node.cmView;\n    }\n    get isEditable() {\n        return true;\n    }\n    get isWidget() {\n        return false;\n    }\n    get isHidden() {\n        return false;\n    }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        return false;\n    }\n    become(other) {\n        return false;\n    }\n    canReuseDOM(other) {\n        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */ );\n    }\n    // When this is a zero-length view with a side, this should return a\n    // number <= 0 to indicate it is before its position, or a\n    // number > 0 when after its position.\n    getSide() {\n        return 0;\n    }\n    destroy() {\n        for (let child of this.children)if (child.parent == this) child.destroy();\n        this.parent = null;\n    }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm$1(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nclass ChildCursor {\n    constructor(children, pos, i){\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for(;;){\n            if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\nfunction replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {\n    let { children } = parent;\n    let before = children.length ? children[fromI] : null;\n    let last = insert.length ? insert[insert.length - 1] : null;\n    let breakAtEnd = last ? last.breakAfter : breakAtStart;\n    // Change within a single child\n    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd)) return;\n    if (toI < children.length) {\n        let after = children[toI];\n        // Make sure the end of the child after the update is preserved in `after`\n        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {\n            // If we're splitting a child, separate part of it to avoid that\n            // being mangled when updating the child before the update.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n                insert[insert.length - 1] = after;\n            } else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff || after.children.length && !after.children[0].length) after.merge(0, toOff, null, false, 0, openEnd);\n                insert.push(after);\n            }\n        } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last) last.breakAfter = 1;\n            else breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n    }\n    if (before) {\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {\n                before.breakAfter = insert.shift().breakAfter;\n            } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false, openStart, 0);\n            }\n            fromI++;\n        }\n    }\n    // Try to merge widgets on the boundaries of the replacement\n    while(fromI < toI && insert.length){\n        if (children[toI - 1].become(insert[insert.length - 1])) {\n            toI--;\n            insert.pop();\n            openEnd = insert.length ? 0 : openStart;\n        } else if (children[fromI].become(insert[0])) {\n            fromI++;\n            insert.shift();\n            openStart = insert.length ? 0 : openEnd;\n        } else {\n            break;\n        }\n    }\n    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;\n    if (fromI < toI || insert.length) parent.replaceChildren(fromI, toI, insert);\n}\nfunction mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {\n    let cur = parent.childCursor();\n    let { i: toI, off: toOff } = cur.findPos(to, 1);\n    let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n    let dLen = from - to;\n    for (let view of insert)dLen += view.length;\n    parent.length += dLen;\n    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);\n}\nlet nav = typeof navigator != \"undefined\" ? navigator : {\n    userAgent: \"\",\n    vendor: \"\",\n    platform: \"\"\n};\nlet doc = typeof document != \"undefined\" ? document : {\n    documentElement: {\n        style: {}\n    }\n};\nconst ie_edge = /*@__PURE__*/ /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /*@__PURE__*/ /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /*@__PURE__*/ /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /*@__PURE__*/ /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /*@__PURE__*/ /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\nconst safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);\nconst ios = safari && /*@__PURE__*/ (/Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\nvar browser = {\n    mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),\n    windows: /*@__PURE__*/ /Win/.test(nav.platform),\n    linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +/*@__PURE__*/ (/Firefox\\/(\\d+)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios,\n    android: /*@__PURE__*/ /Android\\b/.test(nav.userAgent),\n    webkit,\n    safari,\n    webkit_version: webkit ? +/*@__PURE__*/ (/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nconst MaxJoinLen = 256;\nclass TextView extends ContentView {\n    constructor(text){\n        super();\n        this.text = text;\n    }\n    get length() {\n        return this.text.length;\n    }\n    createDOM(textDOM) {\n        this.setDOM(textDOM || document.createTextNode(this.text));\n    }\n    sync(view, track) {\n        if (!this.dom) this.createDOM();\n        if (this.dom.nodeValue != this.text) {\n            if (track && track.node == this.dom) track.written = true;\n            this.dom.nodeValue = this.text;\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType == 3) this.createDOM(dom);\n    }\n    merge(from, to, source) {\n        if (this.flags & 8 /* ViewFlag.Composition */  || source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8 /* ViewFlag.Composition */ )) return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = new TextView(this.text.slice(from));\n        this.text = this.text.slice(0, from);\n        this.markDirty();\n        result.flags |= this.flags & 8 /* ViewFlag.Composition */ ;\n        return result;\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.dom ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) {\n        return new DOMPos(this.dom, pos);\n    }\n    domBoundsAround(_from, _to, offset) {\n        return {\n            from: offset,\n            to: offset + this.length,\n            startDOM: this.dom,\n            endDOM: this.dom.nextSibling\n        };\n    }\n    coordsAt(pos, side) {\n        return textCoords(this.dom, pos, side);\n    }\n}\nclass MarkView extends ContentView {\n    constructor(mark, children = [], length = 0){\n        super();\n        this.mark = mark;\n        this.children = children;\n        this.length = length;\n        for (let ch of children)ch.setParent(this);\n    }\n    setAttrs(dom) {\n        clearAttributes(dom);\n        if (this.mark.class) dom.className = this.mark.class;\n        if (this.mark.attrs) for(let name in this.mark.attrs)dom.setAttribute(name, this.mark.attrs[name]);\n        return dom;\n    }\n    canReuseDOM(other) {\n        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */ );\n    }\n    reuseDOM(node) {\n        if (node.nodeName == this.mark.tagName.toUpperCase()) {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */  | 2 /* ViewFlag.NodeDirty */ ;\n        }\n    }\n    sync(view, track) {\n        if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));\n        else if (this.flags & 4 /* ViewFlag.AttrsDirty */ ) this.setAttrs(this.dom);\n        super.sync(view, track);\n    }\n    merge(from, to, source, _hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = [], off = 0, detachFrom = -1, i = 0;\n        for (let elt of this.children){\n            let end = off + elt.length;\n            if (end > from) result.push(off < from ? elt.split(from - off) : elt);\n            if (detachFrom < 0 && off >= from) detachFrom = i;\n            off = end;\n            i++;\n        }\n        let length = this.length - from;\n        this.length = from;\n        if (detachFrom > -1) {\n            this.children.length = detachFrom;\n            this.markDirty();\n        }\n        return new MarkView(this.mark, result, length);\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n}\nfunction textCoords(text, pos, side) {\n    let length = text.nodeValue.length;\n    if (pos > length) pos = length;\n    let from = pos, to = pos, flatten = 0;\n    if (pos == 0 && side < 0 || pos == length && side >= 0) {\n        if (!(browser.chrome || browser.gecko)) {\n            if (pos) {\n                from--;\n                flatten = 1;\n            } else if (to < length) {\n                to++;\n                flatten = -1;\n            }\n        }\n    } else {\n        if (side < 0) from--;\n        else if (to < length) to++;\n    }\n    let rects = textRange(text, from, to).getClientRects();\n    if (!rects.length) return null;\n    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n    if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, (r)=>r.width) || rect;\n    return flatten ? flattenRect(rect, flatten < 0) : rect || null;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends ContentView {\n    static create(widget, length, side) {\n        return new WidgetView(widget, length, side);\n    }\n    constructor(widget, length, side){\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n        this.prevWidget = null;\n    }\n    split(from) {\n        let result = WidgetView.create(this.widget, this.length - from, this.side);\n        this.length -= from;\n        return result;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            if (!this.widget.editable) this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() {\n        return this.side;\n    }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    become(other) {\n        if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {\n            if (!this.widget.compare(other.widget)) this.markDirty(true);\n            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() {\n        return true;\n    }\n    ignoreEvent(event) {\n        return this.widget.ignoreEvent(event);\n    }\n    get overrideDOMText() {\n        if (this.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n        let top = this;\n        while(top.parent)top = top.parent;\n        let { view } = top, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    domAtPos(pos) {\n        return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() {\n        return null;\n    }\n    coordsAt(pos, side) {\n        let custom = this.widget.coordsAt(this.dom, pos, side);\n        if (custom) return custom;\n        let rects = this.dom.getClientRects(), rect = null;\n        if (!rects.length) return null;\n        let fromBack = this.side ? this.side < 0 : pos > 0;\n        for(let i = fromBack ? rects.length - 1 : 0;; i += fromBack ? -1 : 1){\n            rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;\n        }\n        return flattenRect(rect, !fromBack);\n    }\n    get isEditable() {\n        return false;\n    }\n    get isWidget() {\n        return true;\n    }\n    get isHidden() {\n        return this.widget.isHidden;\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom) this.widget.destroy(this.dom);\n    }\n}\n// These are drawn around uneditable widgets to avoid a number of\n// browser bugs that show up when the cursor is directly next to\n// uneditable inline content.\nclass WidgetBufferView extends ContentView {\n    constructor(side){\n        super();\n        this.side = side;\n    }\n    get length() {\n        return 0;\n    }\n    merge() {\n        return false;\n    }\n    become(other) {\n        return other instanceof WidgetBufferView && other.side == this.side;\n    }\n    split() {\n        return new WidgetBufferView(this.side);\n    }\n    sync() {\n        if (!this.dom) {\n            let dom = document.createElement(\"img\");\n            dom.className = \"cm-widgetBuffer\";\n            dom.setAttribute(\"aria-hidden\", \"true\");\n            this.setDOM(dom);\n        }\n    }\n    getSide() {\n        return this.side;\n    }\n    domAtPos(pos) {\n        return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);\n    }\n    localPosFromDOM() {\n        return 0;\n    }\n    domBoundsAround() {\n        return null;\n    }\n    coordsAt(pos) {\n        return this.dom.getBoundingClientRect();\n    }\n    get overrideDOMText() {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    get isHidden() {\n        return true;\n    }\n}\nTextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;\nfunction inlineDOMAtPos(parent, pos) {\n    let dom = parent.dom, { children } = parent, i = 0;\n    for(let off = 0; i < children.length; i++){\n        let child = children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0) continue;\n        if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);\n        if (pos <= off) break;\n        off = end;\n    }\n    for(let j = i; j > 0; j--){\n        let prev = children[j - 1];\n        if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);\n    }\n    for(let j = i; j < children.length; j++){\n        let next = children[j];\n        if (next.dom.parentNode == dom) return next.domAtPos(0);\n    }\n    return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n    let last, { children } = parent;\n    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n        joinInlineInto(last, view.children[0], open - 1);\n    } else {\n        children.push(view);\n        view.setParent(parent);\n    }\n    parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n    let before = null, beforePos = -1, after = null, afterPos = -1;\n    function scan(view, pos) {\n        for(let i = 0, off = 0; i < view.children.length && off <= pos; i++){\n            let child = view.children[i], end = off + child.length;\n            if (end >= pos) {\n                if (child.children.length) {\n                    scan(child, pos - off);\n                } else if ((!after || after.isHidden && side > 0) && (end > pos || off == end && child.getSide() > 0)) {\n                    after = child;\n                    afterPos = pos - off;\n                } else if (off < pos || off == end && child.getSide() < 0 && !child.isHidden) {\n                    before = child;\n                    beforePos = pos - off;\n                }\n            }\n            off = end;\n        }\n    }\n    scan(view, pos);\n    let target = (side < 0 ? before : after) || before || after;\n    if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);\n    return fallbackRect(view);\n}\nfunction fallbackRect(view) {\n    let last = view.dom.lastChild;\n    if (!last) return view.dom.getBoundingClientRect();\n    let rects = clientRectsFor(last);\n    return rects[rects.length - 1] || null;\n}\nfunction combineAttrs(source, target) {\n    for(let name in source){\n        if (name == \"class\" && target.class) target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style) target.style += \";\" + source.style;\n        else target[name] = source[name];\n    }\n    return target;\n}\nconst noAttrs = /*@__PURE__*/ Object.create(null);\nfunction attrsEq(a, b, ignore) {\n    if (a == b) return true;\n    if (!a) a = noAttrs;\n    if (!b) b = noAttrs;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;\n    for (let key of keysA){\n        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    let changed = false;\n    if (prev) {\n        for(let name in prev)if (!(attrs && name in attrs)) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = \"\";\n            else dom.removeAttribute(name);\n        }\n    }\n    if (attrs) {\n        for(let name in attrs)if (!(prev && prev[name] == attrs[name])) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = attrs[name];\n            else dom.setAttribute(name, attrs[name]);\n        }\n    }\n    return changed;\n}\nfunction getAttrs(dom) {\n    let attrs = Object.create(null);\n    for(let i = 0; i < dom.attributes.length; i++){\n        let attr = dom.attributes[i];\n        attrs[attr.name] = attr.value;\n    }\n    return attrs;\n}\nclass LineView extends ContentView {\n    constructor(){\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source) {\n            if (!(source instanceof LineView)) return false;\n            if (!this.dom) source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (hasStart) this.setDeco(source ? source.attrs : null);\n        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0) return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].split(off), 0);\n            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);\n            i++;\n        }\n        for(let j = i; j < this.children.length; j++)end.append(this.children[j], 0);\n        while(i > 0 && this.children[i - 1].length == 0)this.children[--i].destroy();\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom) return;\n        this.markDirty();\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    append(child, openStart) {\n        joinInlineInto(this, child, openStart);\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes, cls = deco.spec.class;\n        if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});\n        if (cls) this.attrs = combineAttrs({\n            class: cls\n        }, this.attrs || {});\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    reuseDOM(node) {\n        if (node.nodeName == \"DIV\") {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */  | 2 /* ViewFlag.NodeDirty */ ;\n        }\n    }\n    sync(view, track) {\n        var _a;\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        } else if (this.flags & 4 /* ViewFlag.AttrsDirty */ ) {\n            clearAttributes(this.dom);\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(\"cm-line\");\n            this.prevAttrs = undefined;\n        }\n        super.sync(view, track);\n        let last = this.dom.lastChild;\n        while(last && ContentView.get(last) instanceof MarkView)last = last.lastChild;\n        if (!last || !this.length || last.nodeName != \"BR\" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some((ch)=>ch instanceof TextView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20) return null;\n        let totalWidth = 0, textHeight;\n        for (let child of this.children){\n            if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1) return null;\n            totalWidth += rects[0].width;\n            textHeight = rects[0].height;\n        }\n        return !totalWidth ? null : {\n            lineHeight: this.dom.getBoundingClientRect().height,\n            charWidth: totalWidth / this.length,\n            textHeight\n        };\n    }\n    coordsAt(pos, side) {\n        let rect = coordsInChildren(this, pos, side);\n        // Correct rectangle height for empty lines when the returned\n        // height is larger than the text height.\n        if (!this.children.length && rect && this.parent) {\n            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;\n            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {\n                let dist = (height - heightOracle.textHeight) / 2;\n                return {\n                    top: rect.top + dist,\n                    bottom: rect.bottom - dist,\n                    left: rect.left,\n                    right: rect.left\n                };\n            }\n        }\n        return rect;\n    }\n    become(_other) {\n        return false;\n    }\n    covers() {\n        return true;\n    }\n    static find(docView, pos) {\n        for(let i = 0, off = 0; i < docView.children.length; i++){\n            let block = docView.children[i], end = off + block.length;\n            if (end >= pos) {\n                if (block instanceof LineView) return block;\n                if (end > pos) break;\n            }\n            off = end + block.breakAfter;\n        }\n        return null;\n    }\n}\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, deco){\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.deco = deco;\n        this.breakAfter = 0;\n        this.prevWidget = null;\n    }\n    merge(from, to, source, _takeDeco, openStart, openEnd) {\n        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        let end = new BlockWidgetView(this.widget, len, this.deco);\n        end.breakAfter = this.breakAfter;\n        return end;\n    }\n    get children() {\n        return noChildren;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            if (!this.widget.editable) this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    domBoundsAround() {\n        return null;\n    }\n    become(other) {\n        if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.compare(this.widget)) this.markDirty(true);\n            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            this.deco = other.deco;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() {\n        return true;\n    }\n    ignoreEvent(event) {\n        return this.widget.ignoreEvent(event);\n    }\n    get isEditable() {\n        return false;\n    }\n    get isWidget() {\n        return true;\n    }\n    coordsAt(pos, side) {\n        return this.widget.coordsAt(this.dom, pos, side);\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom) this.widget.destroy(this.dom);\n    }\n    covers(side) {\n        let { startSide, endSide } = this.deco;\n        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;\n    }\n}\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even if the decorations\nthat define them are recreated.\n*/ class WidgetType {\n    /**\n    Compare this instance to another instance of the same type.\n    (TypeScript can't express this, but only instances of the same\n    specific class will be passed to this method.) This is used to\n    avoid redrawing widgets when they are replaced by a new\n    decoration of the same type. The default implementation just\n    returns `false`, which will cause new instances of the widget to\n    always be redrawn.\n    */ eq(widget) {\n        return false;\n    }\n    /**\n    Update a DOM element created by a widget of the same type (but\n    different, non-`eq` content) to reflect this widget. May return\n    true to indicate that it could update, false to indicate it\n    couldn't (in which case the widget will be redrawn). The default\n    implementation just returns false.\n    */ updateDOM(dom, view) {\n        return false;\n    }\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    The estimated height this widget will have, to be used when\n    estimating the height of content that hasn't been drawn. May\n    return -1 to indicate you don't know. The default implementation\n    returns -1.\n    */ get estimatedHeight() {\n        return -1;\n    }\n    /**\n    For inline widgets that are displayed inline (as opposed to\n    `inline-block`) and introduce line breaks (through `<br>` tags\n    or textual newlines), this must indicate the amount of line\n    breaks they introduce. Defaults to 0.\n    */ get lineBreaks() {\n        return 0;\n    }\n    /**\n    Can be used to configure which kinds of events inside the widget\n    should be ignored by the editor. The default is to ignore all\n    events.\n    */ ignoreEvent(event) {\n        return true;\n    }\n    /**\n    Override the way screen coordinates for positions at/in the\n    widget are found. `pos` will be the offset into the widget, and\n    `side` the side of the position that is being queried—less than\n    zero for before, greater than zero for after, and zero for\n    directly at that position.\n    */ coordsAt(dom, pos, side) {\n        return null;\n    }\n    /**\n    @internal\n    */ get isHidden() {\n        return false;\n    }\n    /**\n    @internal\n    */ get editable() {\n        return false;\n    }\n    /**\n    This is called when the an instance of the widget is removed\n    from the editor view.\n    */ destroy(dom) {}\n}\n/**\nThe different types of blocks that can occur in an editor view.\n*/ var BlockType = /*@__PURE__*/ function(BlockType) {\n    /**\n    A line of text.\n    */ BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /**\n    A block widget associated with the position after it.\n    */ BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /**\n    A block widget associated with the position before it.\n    */ BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /**\n    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n    */ BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n    return BlockType;\n}(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.\n@nonabstract\n*/ class Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n    constructor(/**\n    @internal\n    */ startSide, /**\n    @internal\n    */ endSide, /**\n    @internal\n    */ widget, /**\n    The config object used to create this decoration. You can\n    include additional properties in there to store metadata about\n    your decoration.\n    */ spec){\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /**\n    @internal\n    */ get heightRelevant() {\n        return false;\n    }\n    /**\n    Create a mark decoration, which influences the styling of the\n    content in its range. Nested mark decorations will cause nested\n    DOM elements to be created. Nesting order is determined by\n    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\n    the higher-precedence decorations creating the inner DOM nodes.\n    Such elements are split on line boundaries and on the boundaries\n    of lower-precedence decorations.\n    */ static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /**\n    Create a widget decoration, which displays a DOM element at the\n    given position.\n    */ static widget(spec) {\n        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;\n        side += block && !spec.inlineOrder ? side > 0 ? 300000000 /* Side.BlockAfter */  : -400000000 /* Side.BlockBefore */  : side > 0 ? 100000000 /* Side.InlineAfter */  : -100000000 /* Side.InlineBefore */ ;\n        return new PointDecoration(spec, side, side, block, spec.widget || null, false);\n    }\n    /**\n    Create a replace decoration which replaces the given range with\n    a widget, or simply hides it.\n    */ static replace(spec) {\n        let block = !!spec.block, startSide, endSide;\n        if (spec.isBlockGap) {\n            startSide = -500000000 /* Side.GapStart */ ;\n            endSide = 400000000 /* Side.GapEnd */ ;\n        } else {\n            let { start, end } = getInclusive(spec, block);\n            startSide = (start ? block ? -300000000 /* Side.BlockIncStart */  : -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ ) - 1;\n            endSide = (end ? block ? 200000000 /* Side.BlockIncEnd */  : 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ ) + 1;\n        }\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /**\n    Create a line decoration, which can add DOM attributes to the\n    line starting at the given position.\n    */ static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /**\n    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n    decorated range or ranges. If the ranges aren't already sorted,\n    pass `true` for `sort` to make the library sort them for you.\n    */ static set(of, sort = false) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(of, sort);\n    }\n    /**\n    @internal\n    */ hasHeight() {\n        return this.widget ? this.widget.estimatedHeight > -1 : false;\n    }\n}\n/**\nThe empty set of decorations.\n*/ Decoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec){\n        let { start, end } = getInclusive(spec);\n        super(start ? -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ , end ? 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ , null, spec);\n        this.tagName = spec.tagName || \"span\";\n        this.class = spec.class || \"\";\n        this.attrs = spec.attributes || null;\n    }\n    eq(other) {\n        var _a, _b;\n        return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, \"class\");\n    }\n    range(from, to = from) {\n        if (from >= to) throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n    constructor(spec){\n        super(-200000000 /* Side.Line */ , -200000000 /* Side.Line */ , null, spec);\n    }\n    eq(other) {\n        return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from) throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace){\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackAfter;\n    }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() {\n        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);\n    }\n    eq(other) {\n        return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from) throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec, block = false) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null) start = spec.inclusive;\n    if (end == null) end = spec.inclusive;\n    return {\n        start: start !== null && start !== void 0 ? start : block,\n        end: end !== null && end !== void 0 ? end : block\n    };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);\n    else ranges.push(from, to);\n}\nclass ContentBuilder {\n    constructor(doc, pos, end, disallowBlockEffectsFor){\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.disallowBlockEffectsFor = disallowBlockEffectsFor;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.pendingBuffer = 0 /* Buf.No */ ;\n        this.bufferMarks = [];\n        // Set to false directly after a widget that covers the position after it\n        this.atCursorPos = true;\n        this.openStart = -1;\n        this.openEnd = -1;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);\n    }\n    getLine() {\n        if (!this.curLine) {\n            this.content.push(this.curLine = new LineView);\n            this.atCursorPos = true;\n        }\n        return this.curLine;\n    }\n    flushBuffer(active = this.bufferMarks) {\n        if (this.pendingBuffer) {\n            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);\n            this.pendingBuffer = 0 /* Buf.No */ ;\n        }\n    }\n    addBlockWidget(view) {\n        this.flushBuffer();\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish(openEnd) {\n        if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();\n        else this.pendingBuffer = 0 /* Buf.No */ ;\n        if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView)) this.getLine();\n    }\n    buildText(length, active, openStart) {\n        while(length > 0){\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done) throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered()) this.getLine();\n                    if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;\n                    else this.breakAtStart = 1;\n                    this.flushBuffer();\n                    this.curLine = null;\n                    this.atCursorPos = true;\n                    length--;\n                    continue;\n                } else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */ );\n            this.flushBuffer(active.slice(active.length - openStart));\n            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n            this.atCursorPos = true;\n            this.textOff += take;\n            length -= take;\n            openStart = 0;\n        }\n    }\n    span(from, to, active, openStart) {\n        this.buildText(to - from, active, openStart);\n        this.pos = to;\n        if (this.openStart < 0) this.openStart = openStart;\n    }\n    point(from, to, deco, active, openStart, index) {\n        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {\n            if (deco.block) throw new RangeError(\"Block decorations may not be specified via plugins\");\n            if (to > this.doc.lineAt(this.pos).to) throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\n        }\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                if (deco.startSide > 0 && !this.posCovered()) this.getLine();\n                this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, deco));\n            } else {\n                let view = WidgetView.create(deco.widget || new NullWidget(\"span\"), len, len ? 0 : deco.startSide);\n                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);\n                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);\n                let line = this.getLine();\n                if (this.pendingBuffer == 2 /* Buf.IfCursor */  && !cursorBefore && !view.isEditable) this.pendingBuffer = 0 /* Buf.No */ ;\n                this.flushBuffer(active);\n                if (cursorBefore) {\n                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);\n                    openStart = active.length + Math.max(0, openStart - active.length);\n                }\n                line.append(wrapMarks(view, active), openStart);\n                this.atCursorPos = cursorAfter;\n                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */  : from < to || openStart > active.length ? 1 /* Buf.Yes */  : 2 /* Buf.IfCursor */ ;\n                if (this.pendingBuffer) this.bufferMarks = active.slice();\n            }\n        } else if (this.doc.lineAt(this.pos).from == this.pos) {\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            } else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n        if (this.openStart < 0) this.openStart = openStart;\n    }\n    static build(text, from, to, decorations, dynamicDecorationMap) {\n        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);\n        builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder);\n        if (builder.openStart < 0) builder.openStart = builder.openEnd;\n        builder.finish(builder.openEnd);\n        return builder;\n    }\n}\nfunction wrapMarks(view, active) {\n    for (let mark of active)view = new MarkView(mark, [\n        view\n    ], view.length);\n    return view;\n}\nclass NullWidget extends WidgetType {\n    constructor(tag){\n        super();\n        this.tag = tag;\n    }\n    eq(other) {\n        return other.tag == this.tag;\n    }\n    toDOM() {\n        return document.createElement(this.tag);\n    }\n    updateDOM(elt) {\n        return elt.nodeName.toLowerCase() == this.tag;\n    }\n    get isHidden() {\n        return true;\n    }\n}\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/ var Direction = /*@__PURE__*/ function(Direction) {\n    // (These are chosen to match the base levels, in bidi algorithm\n    // terms, of spans in that direction.)\n    /**\n    Left-to-right.\n    */ Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n    /**\n    Right-to-left.\n    */ Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n    return Direction;\n}(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n    let result = [];\n    for(let i = 0; i < str.length; i++)result.push(1 << +str[i]);\n    return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = /*@__PURE__*/ dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = /*@__PURE__*/ dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nconst Brackets = /*@__PURE__*/ Object.create(null), BracketStack = [];\n// There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\nfor (let p of [\n    \"()\",\n    \"[]\",\n    \"{}\"\n]){\n    let l = /*@__PURE__*/ p.charCodeAt(0), r = /*@__PURE__*/ p.charCodeAt(1);\n    Brackets[l] = r;\n    Brackets[r] = -l;\n}\nfunction charType(ch) {\n    return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */  : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */  : 0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */  : 0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */  : 1 /* T.L */ ;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/ class BidiSpan {\n    /**\n    The direction of this span.\n    */ get dir() {\n        return this.level % 2 ? RTL : LTR;\n    }\n    /**\n    @internal\n    */ constructor(/**\n    The start of the span (relative to the start of the line).\n    */ from, /**\n    The end of the span.\n    */ to, /**\n    The [\"bidi\n    level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n    of the span (in this context, 0 means\n    left-to-right, 1 means right-to-left, 2 means left-to-right\n    number inside right-to-left text).\n    */ level){\n        this.from = from;\n        this.to = to;\n        this.level = level;\n    }\n    /**\n    @internal\n    */ side(end, dir) {\n        return this.dir == dir == end ? this.to : this.from;\n    }\n    /**\n    @internal\n    */ forward(forward, dir) {\n        return forward == (this.dir == dir);\n    }\n    /**\n    @internal\n    */ static find(order, index, level, assoc) {\n        let maybe = -1;\n        for(let i = 0; i < order.length; i++){\n            let span = order[i];\n            if (span.from <= index && span.to >= index) {\n                if (span.level == level) return i;\n                // When multiple spans match, if assoc != 0, take the one that\n                // covers that side, otherwise take the one with the minimum\n                // level.\n                if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;\n            }\n        }\n        if (maybe < 0) throw new RangeError(\"Index out of range\");\n        return maybe;\n    }\n}\nfunction isolatesEq(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++){\n        let iA = a[i], iB = b[i];\n        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;\n    }\n    return true;\n}\n// Reused array of character types\nconst types = [];\n// Fill in the character types (in `types`) from `from` to `to` and\n// apply W normalization rules.\nfunction computeCharTypes(line, rFrom, rTo, isolates, outerType) {\n    for(let iI = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        let prevType = iI ? 256 /* T.NI */  : outerType;\n        // W1. Examine each non-spacing mark (NSM) in the level run, and\n        // change the type of the NSM to the type of the previous\n        // character. If the NSM is at the start of the level run, it will\n        // get the type of sor.\n        // W2. Search backwards from each instance of a European number\n        // until the first strong type (R, L, AL, or sor) is found. If an\n        // AL is found, change the type of the European number to Arabic\n        // number.\n        // W3. Change all ALs to R.\n        // (Left after this: L, R, EN, AN, ET, CS, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = charType(line.charCodeAt(i));\n            if (type == 512 /* T.NSM */ ) type = prev;\n            else if (type == 8 /* T.EN */  && prevStrong == 4 /* T.AL */ ) type = 16 /* T.AN */ ;\n            types[i] = type == 4 /* T.AL */  ? 2 /* T.R */  : type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n            prev = type;\n        }\n        // W5. A sequence of European terminators adjacent to European\n        // numbers changes to all European numbers.\n        // W6. Otherwise, separators and terminators change to Other\n        // Neutral.\n        // W7. Search backwards from each instance of a European number\n        // until the first strong type (R, L, or sor) is found. If an L is\n        // found, then change the type of the European number to L.\n        // (Left after this: L, R, EN+AN, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = types[i];\n            if (type == 128 /* T.CS */ ) {\n                if (i < to - 1 && prev == types[i + 1] && prev & 24 /* T.Num */ ) type = types[i] = prev;\n                else types[i] = 256 /* T.NI */ ;\n            } else if (type == 64 /* T.ET */ ) {\n                let end = i + 1;\n                while(end < to && types[end] == 64 /* T.ET */ )end++;\n                let replace = i && prev == 8 /* T.EN */  || end < rTo && types[end] == 8 /* T.EN */  ? prevStrong == 1 /* T.L */  ? 1 /* T.L */  : 8 /* T.EN */  : 256 /* T.NI */ ;\n                for(let j = i; j < end; j++)types[j] = replace;\n                i = end - 1;\n            } else if (type == 8 /* T.EN */  && prevStrong == 1 /* T.L */ ) {\n                types[i] = 1 /* T.L */ ;\n            }\n            prev = type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n        }\n    }\n}\n// Process brackets throughout a run sequence.\nfunction processBracketPairs(line, rFrom, rTo, isolates, outerType) {\n    let oppositeType = outerType == 1 /* T.L */  ? 2 /* T.R */  : 1 /* T.L */ ;\n    for(let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N0. Process bracket pairs in an isolating run sequence\n        // sequentially in the logical order of the text positions of the\n        // opening paired brackets using the logic given below. Within this\n        // scope, bidirectional types EN and AN are treated as R.\n        for(let i = from, ch, br, type; i < to; i++){\n            // Keeps [startIndex, type, strongSeen] triples for each open\n            // bracket on BracketStack.\n            if (br = Brackets[ch = line.charCodeAt(i)]) {\n                if (br < 0) {\n                    for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                        if (BracketStack[sJ + 1] == -br) {\n                            let flags = BracketStack[sJ + 2];\n                            let type = flags & 2 /* Bracketed.EmbedInside */  ? outerType : !(flags & 4 /* Bracketed.OppositeInside */ ) ? 0 : flags & 1 /* Bracketed.OppositeBefore */  ? oppositeType : outerType;\n                            if (type) types[i] = types[BracketStack[sJ]] = type;\n                            sI = sJ;\n                            break;\n                        }\n                    }\n                } else if (BracketStack.length == 189 /* Bracketed.MaxDepth */ ) {\n                    break;\n                } else {\n                    BracketStack[sI++] = i;\n                    BracketStack[sI++] = ch;\n                    BracketStack[sI++] = context;\n                }\n            } else if ((type = types[i]) == 2 /* T.R */  || type == 1 /* T.L */ ) {\n                let embed = type == outerType;\n                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */ ;\n                for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                    let cur = BracketStack[sJ + 2];\n                    if (cur & 2 /* Bracketed.EmbedInside */ ) break;\n                    if (embed) {\n                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */ ;\n                    } else {\n                        if (cur & 4 /* Bracketed.OppositeInside */ ) break;\n                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */ ;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction processNeutrals(rFrom, rTo, isolates, outerType) {\n    for(let iI = 0, prev = outerType; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N1. A sequence of neutrals takes the direction of the\n        // surrounding strong text if the text on both sides has the same\n        // direction. European and Arabic numbers act as if they were R in\n        // terms of their influence on neutrals. Start-of-level-run (sor)\n        // and end-of-level-run (eor) are used at level run boundaries.\n        // N2. Any remaining neutrals take the embedding direction.\n        // (Left after this: L, R, EN+AN)\n        for(let i = from; i < to;){\n            let type = types[i];\n            if (type == 256 /* T.NI */ ) {\n                let end = i + 1;\n                for(;;){\n                    if (end == to) {\n                        if (iI == isolates.length) break;\n                        end = isolates[iI++].to;\n                        to = iI < isolates.length ? isolates[iI].from : rTo;\n                    } else if (types[end] == 256 /* T.NI */ ) {\n                        end++;\n                    } else {\n                        break;\n                    }\n                }\n                let beforeL = prev == 1 /* T.L */ ;\n                let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */ ;\n                let replace = beforeL == afterL ? beforeL ? 1 /* T.L */  : 2 /* T.R */  : outerType;\n                for(let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;){\n                    if (j == fromJ) {\n                        j = isolates[--jI].from;\n                        fromJ = jI ? isolates[jI - 1].to : rFrom;\n                    }\n                    types[--j] = replace;\n                }\n                i = end;\n            } else {\n                prev = type;\n                i++;\n            }\n        }\n    }\n}\n// Find the contiguous ranges of character types in a given range, and\n// emit spans for them. Flip the order of the spans as appropriate\n// based on the level, and call through to compute the spans for\n// isolates at the proper point.\nfunction emitSpans(line, from, to, level, baseLevel, isolates, order) {\n    let ourType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    if (level % 2 == baseLevel % 2) {\n        for(let iCh = from, iI = 0; iCh < to;){\n            // Scan a section of characters in direction ourType, unless\n            // there's another type of char right after iCh, in which case\n            // we scan a section of other characters (which, if ourType ==\n            // T.L, may contain both T.R and T.AN chars).\n            let sameDir = true, isNum = false;\n            if (iI == isolates.length || iCh < isolates[iI].from) {\n                let next = types[iCh];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            // Holds an array of isolates to pass to a recursive call if we\n            // must recurse (to distinguish T.AN inside an RTL section in\n            // LTR text), null if we can emit directly\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI < isolates.length && iScan == isolates[iI].from) {\n                    if (isNum) break run;\n                    let iso = isolates[iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.to, jI = iI + 1;;){\n                        if (upto == to) break run;\n                        if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;\n                        else if (types[upto] == ourType) break run;\n                        else break;\n                    }\n                    iI++;\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.to;\n                    }\n                    iScan = iso.to;\n                } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {\n                    break;\n                } else {\n                    iScan++;\n                }\n            }\n            if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);\n            else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));\n            iCh = iScan;\n        }\n    } else {\n        // Iterate in reverse to flip the span order. Same code again, but\n        // going from the back of the section to the front\n        for(let iCh = to, iI = isolates.length; iCh > from;){\n            let sameDir = true, isNum = false;\n            if (!iI || iCh > isolates[iI - 1].to) {\n                let next = types[iCh - 1];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI && iScan == isolates[iI - 1].to) {\n                    if (isNum) break run;\n                    let iso = isolates[--iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.from, jI = iI;;){\n                        if (upto == from) break run;\n                        if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from;\n                        else if (types[upto - 1] == ourType) break run;\n                        else break;\n                    }\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.from;\n                    }\n                    iScan = iso.from;\n                } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {\n                    break;\n                } else {\n                    iScan--;\n                }\n            }\n            if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);\n            else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel));\n            iCh = iScan;\n        }\n    }\n}\nfunction computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {\n    let outerType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    computeCharTypes(line, from, to, isolates, outerType);\n    processBracketPairs(line, from, to, isolates, outerType);\n    processNeutrals(from, to, isolates, outerType);\n    emitSpans(line, from, to, level, baseLevel, isolates, order);\n}\nfunction computeOrder(line, direction, isolates) {\n    if (!line) return [\n        new BidiSpan(0, 0, direction == RTL ? 1 : 0)\n    ];\n    if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);\n    if (isolates.length) while(line.length > types.length)types[types.length] = 256 /* T.NI */ ; // Make sure types array has no gaps\n    let order = [], level = direction == LTR ? 0 : 1;\n    computeSectionOrder(line, level, level, isolates, 0, line.length, order);\n    return order;\n}\nfunction trivialOrder(length) {\n    return [\n        new BidiSpan(0, length, 0)\n    ];\n}\nlet movedOver = \"\";\n// This implementation moves strictly visually, without concern for a\n// traversal visiting every logical position in the string. It will\n// still do so for simple input, but situations like multiple isolates\n// with the same level next to each other, or text going against the\n// main dir at the end of the line, will make some positions\n// unreachable with this motion. Each visible cursor position will\n// correspond to the lower-level bidi span that touches it.\n//\n// The alternative would be to solve an order globally for a given\n// line, making sure that it includes every position, but that would\n// require associating non-canonical (higher bidi span level)\n// positions with a given visual position, which is likely to confuse\n// people. (And would generally be a lot more complicated.)\nfunction moveVisually(line, order, dir, start, forward) {\n    var _a;\n    let startIndex = start.head - line.from;\n    let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n    let span = order[spanI], spanEnd = span.side(forward, dir);\n    // End of span\n    if (startIndex == spanEnd) {\n        let nextI = spanI += forward ? 1 : -1;\n        if (nextI < 0 || nextI >= order.length) return null;\n        span = order[spanI = nextI];\n        startIndex = span.side(!forward, dir);\n        spanEnd = span.side(forward, dir);\n    }\n    let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, startIndex, span.forward(forward, dir));\n    if (nextIndex < span.from || nextIndex > span.to) nextIndex = spanEnd;\n    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);\n}\nfunction autoDirection(text, from, to) {\n    for(let i = from; i < to; i++){\n        let type = charType(text.charCodeAt(i));\n        if (type == 1 /* T.L */ ) return LTR;\n        if (type == 2 /* T.R */  || type == 4 /* T.AL */ ) return RTL;\n    }\n    return LTR;\n}\nconst clickAddsSelectionRange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst dragMovesSelection$1 = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst mouseSelectionStyle = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst exceptionSink = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst updateListener = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst inputHandler = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst focusChangeEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst perLineTextDirection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nconst nativeSelectionHidden = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nclass ScrollTarget {\n    constructor(range, y = \"nearest\", x = \"nearest\", yMargin = 5, xMargin = 5, // This data structure is abused to also store precise scroll\n    // snapshots, instead of a `scrollIntoView` request. When this\n    // flag is `true`, `range` points at a position in the reference\n    // line, `yMargin` holds the difference between the top of that\n    // line and the top of the editor, and `xMargin` holds the\n    // editor's `scrollLeft`.\n    isSnapshot = false){\n        this.range = range;\n        this.y = y;\n        this.x = x;\n        this.yMargin = yMargin;\n        this.xMargin = xMargin;\n        this.isSnapshot = isSnapshot;\n    }\n    map(changes) {\n        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n    clip(state) {\n        return this.range.to <= state.doc.length ? this : new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n}\nconst scrollIntoView = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map: (t, ch)=>t.map(ch)\n});\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/ function logException(state, exception, context) {\n    let handler = state.facet(exceptionSink);\n    if (handler.length) handler[0](exception);\n    else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);\n    else if (context) console.error(context + \":\", exception);\n    else console.error(exception);\n}\nconst editable = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.length ? values[0] : true\n});\nlet nextPluginID = 0;\nconst viewPlugin = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view.\n*/ class ViewPlugin {\n    constructor(/**\n    @internal\n    */ id, /**\n    @internal\n    */ create, /**\n    @internal\n    */ domEventHandlers, /**\n    @internal\n    */ domEventObservers, buildExtensions){\n        this.id = id;\n        this.create = create;\n        this.domEventHandlers = domEventHandlers;\n        this.domEventObservers = domEventObservers;\n        this.extension = buildExtensions(this);\n    }\n    /**\n    Define a plugin from a constructor function that creates the\n    plugin's value, given an editor view.\n    */ static define(create, spec) {\n        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};\n        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin)=>{\n            let ext = [\n                viewPlugin.of(plugin)\n            ];\n            if (deco) ext.push(decorations.of((view)=>{\n                let pluginInst = view.plugin(plugin);\n                return pluginInst ? deco(pluginInst) : Decoration.none;\n            }));\n            if (provide) ext.push(provide(plugin));\n            return ext;\n        });\n    }\n    /**\n    Create a plugin for a class whose constructor takes a single\n    editor view as argument.\n    */ static fromClass(cls, spec) {\n        return ViewPlugin.define((view)=>new cls(view), spec);\n    }\n}\nclass PluginInstance {\n    constructor(spec){\n        this.spec = spec;\n        // When starting an update, all plugins have this field set to the\n        // update object, indicating they need to be updated. When finished\n        // updating, it is set to `false`. Retrieving a plugin that needs to\n        // be updated with `view.plugin` forces an eager update.\n        this.mustUpdate = null;\n        // This is null when the plugin is initially created, but\n        // initialized on the first update.\n        this.value = null;\n    }\n    update(view) {\n        if (!this.value) {\n            if (this.spec) {\n                try {\n                    this.value = this.spec.create(view);\n                } catch (e) {\n                    logException(view.state, e, \"CodeMirror plugin crashed\");\n                    this.deactivate();\n                }\n            }\n        } else if (this.mustUpdate) {\n            let update = this.mustUpdate;\n            this.mustUpdate = null;\n            if (this.value.update) {\n                try {\n                    this.value.update(update);\n                } catch (e) {\n                    logException(update.state, e, \"CodeMirror plugin crashed\");\n                    if (this.value.destroy) try {\n                        this.value.destroy();\n                    } catch (_) {}\n                    this.deactivate();\n                }\n            }\n        }\n        return this;\n    }\n    destroy(view) {\n        var _a;\n        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n            try {\n                this.value.destroy();\n            } catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n            }\n        }\n    }\n    deactivate() {\n        this.spec = this.value = null;\n    }\n}\nconst editorAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst contentAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n// Provide decorations\nconst decorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst outerDecorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst atomicRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst bidiIsolatedRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getIsolatedRanges(view, line) {\n    let isolates = view.state.facet(bidiIsolatedRanges);\n    if (!isolates.length) return isolates;\n    let sets = isolates.map((i)=>i instanceof Function ? i(view) : i);\n    let result = [];\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(sets, line.from, line.to, {\n        point () {},\n        span (fromDoc, toDoc, active, open) {\n            let from = fromDoc - line.from, to = toDoc - line.from;\n            let level = result;\n            for(let i = active.length - 1; i >= 0; i--, open--){\n                let direction = active[i].spec.bidiIsolate, update;\n                if (direction == null) direction = autoDirection(line.text, from, to);\n                if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {\n                    update.to = to;\n                    level = update.inner;\n                } else {\n                    let add = {\n                        from,\n                        to,\n                        direction,\n                        inner: []\n                    };\n                    level.push(add);\n                    level = add.inner;\n                }\n            }\n        }\n    });\n    return result;\n}\nconst scrollMargins = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getScrollMargins(view) {\n    let left = 0, right = 0, top = 0, bottom = 0;\n    for (let source of view.state.facet(scrollMargins)){\n        let m = source(view);\n        if (m) {\n            if (m.left != null) left = Math.max(left, m.left);\n            if (m.right != null) right = Math.max(right, m.right);\n            if (m.top != null) top = Math.max(top, m.top);\n            if (m.bottom != null) bottom = Math.max(bottom, m.bottom);\n        }\n    }\n    return {\n        left,\n        right,\n        top,\n        bottom\n    };\n}\nconst styleModule = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass ChangedRange {\n    constructor(fromA, toA, fromB, toB){\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    addToSet(set) {\n        let i = set.length, me = this;\n        for(; i > 0; i--){\n            let range = set[i - 1];\n            if (range.fromA > me.toA) continue;\n            if (range.toA < me.fromA) break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    static extendWithRanges(diff, ranges) {\n        if (ranges.length == 0) return diff;\n        let result = [];\n        for(let dI = 0, rI = 0, posA = 0, posB = 0;; dI++){\n            let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n            let end = next ? next.fromB : 1e9;\n            while(rI < ranges.length && ranges[rI] < end){\n                let from = ranges[rI], to = ranges[rI + 1];\n                let fromB = Math.max(posB, from), toB = Math.min(end, to);\n                if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n                if (to > end) break;\n                else rI += 2;\n            }\n            if (!next) return result;\n            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n            posA = next.toA;\n            posB = next.toB;\n        }\n    }\n}\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/ class ViewUpdate {\n    constructor(/**\n    The editor view that the update is associated with.\n    */ view, /**\n    The new editor state.\n    */ state, /**\n    The transactions involved in the update. May be empty.\n    */ transactions){\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /**\n        @internal\n        */ this.flags = 0;\n        this.startState = view.state;\n        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.startState.doc.length);\n        for (let tr of transactions)this.changes = this.changes.compose(tr.changes);\n        let changedRanges = [];\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB)=>changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n        this.changedRanges = changedRanges;\n    }\n    /**\n    @internal\n    */ static create(view, state, transactions) {\n        return new ViewUpdate(view, state, transactions);\n    }\n    /**\n    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n    update.\n    */ get viewportChanged() {\n        return (this.flags & 4 /* UpdateFlag.Viewport */ ) > 0;\n    }\n    /**\n    Indicates whether the height of a block element in the editor\n    changed in this update.\n    */ get heightChanged() {\n        return (this.flags & 2 /* UpdateFlag.Height */ ) > 0;\n    }\n    /**\n    Returns true when the document was modified or the size of the\n    editor, or elements within the editor, changed.\n    */ get geometryChanged() {\n        return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ )) > 0;\n    }\n    /**\n    True when this update indicates a focus change.\n    */ get focusChanged() {\n        return (this.flags & 1 /* UpdateFlag.Focus */ ) > 0;\n    }\n    /**\n    Whether the document changed in this update.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Whether the selection was explicitly set in this update.\n    */ get selectionSet() {\n        return this.transactions.some((tr)=>tr.selection);\n    }\n    /**\n    @internal\n    */ get empty() {\n        return this.flags == 0 && this.transactions.length == 0;\n    }\n}\nclass DocView extends ContentView {\n    get length() {\n        return this.view.state.doc.length;\n    }\n    constructor(view){\n        super();\n        this.view = view;\n        this.decorations = [];\n        this.dynamicDecorationMap = [];\n        this.domChanged = null;\n        this.hasComposition = null;\n        this.markedForComposition = new Set;\n        // Track a minimum width for the editor. When measuring sizes in\n        // measureVisibleLineHeights, this is updated to point at the width\n        // of a given element and its extent in the document. When a change\n        // happens in that range, these are reset. That way, once we've seen\n        // a line/element of a given length, we keep the editor wide enough\n        // to fit at least that element, until it is changed, at which point\n        // we forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.forceSelection = false;\n        // Used by the resize observer to ignore resizes that we caused\n        // ourselves\n        this.lastUpdate = Date.now();\n        this.setDOM(view.contentDOM);\n        this.children = [\n            new LineView\n        ];\n        this.children[0].setParent(this);\n        this.updateDeco();\n        this.updateInner([\n            new ChangedRange(0, 0, 0, view.state.doc.length)\n        ], 0, null);\n    }\n    // Update the document view to a given state.\n    update(update) {\n        var _a;\n        let changedRanges = update.changedRanges;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA })=>toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\n            } else {\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n            }\n        }\n        let readCompositionAt = -1;\n        if (this.view.inputState.composing >= 0) {\n            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel) readCompositionAt = this.domChanged.newSel.head;\n            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet) readCompositionAt = update.state.selection.main.head;\n        }\n        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;\n        this.domChanged = null;\n        if (this.hasComposition) {\n            this.markedForComposition.clear();\n            let { from, to } = this.hasComposition;\n            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());\n        }\n        this.hasComposition = composition ? {\n            from: composition.range.fromB,\n            to: composition.range.toB\n        } : null;\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n        if (!(this.flags & 7 /* ViewFlag.Dirty */ ) && changedRanges.length == 0) {\n            return false;\n        } else {\n            this.updateInner(changedRanges, update.startState.doc.length, composition);\n            if (update.transactions.length) this.lastUpdate = Date.now();\n            return true;\n        }\n    }\n    // Used by update and the constructor do perform the actual DOM\n    // update\n    updateInner(changes, oldLength, composition) {\n        this.view.viewState.mustMeasureContent = true;\n        this.updateChildren(changes, oldLength, composition);\n        let { observer } = this.view;\n        observer.ignore(()=>{\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + \"px\";\n            this.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\n            // Chrome will sometimes, when DOM mutations occur directly\n            // around the selection, get confused and report a different\n            // selection from the one it displays (issue #218). This tries\n            // to detect that situation.\n            let track = browser.chrome || browser.ios ? {\n                node: observer.selectionRange.focusNode,\n                written: false\n            } : undefined;\n            this.sync(this.view, track);\n            this.flags &= ~7 /* ViewFlag.Dirty */ ;\n            if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;\n            this.dom.style.height = \"\";\n        });\n        this.markedForComposition.forEach((cView)=>cView.flags &= ~8 /* ViewFlag.Composition */ );\n        let gaps = [];\n        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {\n            for (let child of this.children)if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);\n        }\n        observer.updateGaps(gaps);\n    }\n    updateChildren(changes, oldLength, composition) {\n        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;\n        let cursor = this.childCursor(oldLength);\n        for(let i = ranges.length - 1;; i--){\n            let next = i >= 0 ? ranges[i] : null;\n            if (!next) break;\n            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;\n            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {\n                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);\n                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);\n                breakAtStart = before.breakAtStart;\n                openStart = before.openStart;\n                openEnd = after.openEnd;\n                let compLine = this.compositionView(composition);\n                if (after.breakAtStart) {\n                    compLine.breakAfter = 1;\n                } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {\n                    compLine.breakAfter = after.content[0].breakAfter;\n                    after.content.shift();\n                }\n                if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {\n                    before.content.pop();\n                }\n                content = before.content.concat(compLine).concat(after.content);\n            } else {\n                ({ content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));\n            }\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n        }\n        if (composition) this.fixCompositionDOM(composition);\n    }\n    compositionView(composition) {\n        let cur = new TextView(composition.text.nodeValue);\n        cur.flags |= 8 /* ViewFlag.Composition */ ;\n        for (let { deco } of composition.marks)cur = new MarkView(deco, [\n            cur\n        ], cur.length);\n        let line = new LineView;\n        line.append(cur, 0);\n        return line;\n    }\n    fixCompositionDOM(composition) {\n        let fix = (dom, cView)=>{\n            cView.flags |= 8 /* ViewFlag.Composition */  | (cView.children.some((c)=>c.flags & 7 /* ViewFlag.Dirty */ ) ? 1 /* ViewFlag.ChildDirty */  : 0);\n            this.markedForComposition.add(cView);\n            let prev = ContentView.get(dom);\n            if (prev && prev != cView) prev.dom = null;\n            cView.setDOM(dom);\n        };\n        let pos = this.childPos(composition.range.fromB, 1);\n        let cView = this.children[pos.i];\n        fix(composition.line, cView);\n        for(let i = composition.marks.length - 1; i >= -1; i--){\n            pos = cView.childPos(pos.off, 1);\n            cView = cView.children[pos.i];\n            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);\n        }\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(mustRead = false, fromPointer = false) {\n        if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();\n        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;\n        let selectionNotFocus = !focused && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));\n        if (!(focused || fromPointer || selectionNotFocus)) return;\n        let force = this.forceSelection;\n        this.forceSelection = false;\n        let main = this.view.state.selection.main;\n        let anchor = this.moveToLine(this.domAtPos(main.anchor));\n        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));\n        // Always reset on Firefox when next to an uneditable node to\n        // avoid invisible cursor bugs (#111)\n        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {\n            let dummy = document.createTextNode(\"\");\n            this.view.observer.ignore(()=>anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n            anchor = head = new DOMPos(dummy, 0);\n            force = true;\n        }\n        let domSel = this.view.observer.selectionRange;\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {\n            this.view.observer.ignore(()=>{\n                // Chrome Android will hide the virtual keyboard when tapping\n                // inside an uneditable node, and not bring it back when we\n                // move the cursor to its proper position. This tries to\n                // restore the keyboard by cycling focus.\n                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {\n                    this.dom.blur();\n                    this.dom.focus({\n                        preventScroll: true\n                    });\n                }\n                let rawSel = getSelection(this.view.root);\n                if (!rawSel) ;\n                else if (main.empty) {\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n                    if (browser.gecko) {\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\n                        if (nextTo && nextTo != (1 /* NextTo.Before */  | 2 /* NextTo.After */ )) {\n                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */  ? 1 : -1);\n                            if (text) anchor = new DOMPos(text.node, text.offset);\n                        }\n                    }\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined) rawSel.caretBidiLevel = main.bidiLevel;\n                } else if (rawSel.extend) {\n                    // Selection.extend can be used to create an 'inverted' selection\n                    // (one where the focus is before the anchor), but not all\n                    // browsers support it yet.\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    // Safari will ignore the call above when the editor is\n                    // hidden, and then raise an error on the call to extend\n                    // (#940).\n                    try {\n                        rawSel.extend(head.node, head.offset);\n                    } catch (_) {}\n                } else {\n                    // Primitive (IE) way\n                    let range = document.createRange();\n                    if (main.anchor > main.head) [anchor, head] = [\n                        head,\n                        anchor\n                    ];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    rawSel.removeAllRanges();\n                    rawSel.addRange(range);\n                }\n                if (selectionNotFocus && this.view.root.activeElement == this.dom) {\n                    this.dom.blur();\n                    if (activeElt) activeElt.focus();\n                }\n            });\n            this.view.observer.setSelectionRange(anchor, head);\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    // If a zero-length widget is inserted next to the cursor during\n    // composition, avoid moving it across it and disrupting the\n    // composition.\n    suppressWidgetCursorChange(sel, cursor) {\n        return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;\n    }\n    enforceCursorAssoc() {\n        if (this.hasComposition) return;\n        let { view } = this, cursor = view.state.selection.main;\n        let sel = getSelection(view.root);\n        let { anchorNode, anchorOffset } = view.observer.selectionRange;\n        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;\n        let line = LineView.find(this, cursor.head);\n        if (!line) return;\n        let lineStart = line.posAtStart;\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n        if (!before || !after || before.bottom > after.top) return;\n        let dom = this.domAtPos(cursor.head + cursor.assoc);\n        sel.collapse(dom.node, dom.offset);\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n        // This can go wrong in corner cases like single-character lines,\n        // so check and reset if necessary.\n        view.observer.readSelectionRange();\n        let newRange = view.observer.selectionRange;\n        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);\n    }\n    // If a position is in/near a block widget, move it to a nearby text\n    // line, since we don't want the cursor inside a block widget.\n    moveToLine(pos) {\n        // Block widgets will return positions before/after them, which\n        // are thus directly in the document DOM element.\n        let dom = this.dom, newPos;\n        if (pos.node != dom) return pos;\n        for(let i = pos.offset; !newPos && i < dom.childNodes.length; i++){\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView) newPos = view.domAtPos(0);\n        }\n        for(let i = pos.offset - 1; !newPos && i >= 0; i--){\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView) newPos = view.domAtPos(view.length);\n        }\n        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;\n    }\n    nearest(dom) {\n        for(let cur = dom; cur;){\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this) return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view) throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for(; i < this.children.length - 1;){\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView) break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos, side) {\n        let best = null, bestPos = 0;\n        for(let off = this.length, i = this.children.length - 1; i >= 0; i--){\n            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;\n            if (end < pos) break;\n            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {\n                best = child;\n                bestPos = start;\n            }\n            off = start;\n        }\n        return best ? best.coordsAt(pos - bestPos, side) : null;\n    }\n    coordsForChar(pos) {\n        let { i, off } = this.childPos(pos, 1), child = this.children[i];\n        if (!(child instanceof LineView)) return null;\n        while(child.children.length){\n            let { i, off: childOff } = child.childPos(off, 1);\n            for(;; i++){\n                if (i == child.children.length) return null;\n                if ((child = child.children[i]).length) break;\n            }\n            off = childOff;\n        }\n        if (!(child instanceof TextView)) return null;\n        let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(child.text, off);\n        if (end == off) return null;\n        let rects = textRange(child.dom, off, end).getClientRects();\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right) return rect;\n        }\n        return null;\n    }\n    measureVisibleLineHeights(viewport) {\n        let result = [], { from, to } = viewport;\n        let contentWidth = this.view.contentDOM.clientWidth;\n        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        let widest = -1, ltr = this.view.textDirection == Direction.LTR;\n        for(let pos = 0, i = 0; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (end > to) break;\n            if (pos >= from) {\n                let childRect = child.dom.getBoundingClientRect();\n                result.push(childRect.height);\n                if (isWider) {\n                    let last = child.dom.lastChild;\n                    let rects = last ? clientRectsFor(last) : [];\n                    if (rects.length) {\n                        let rect = rects[rects.length - 1];\n                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;\n                        if (width > widest) {\n                            widest = width;\n                            this.minWidth = contentWidth;\n                            this.minWidthFrom = pos;\n                            this.minWidthTo = end;\n                        }\n                    }\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    textDirectionAt(pos) {\n        let { i } = this.childPos(pos, 1);\n        return getComputedStyle(this.children[i].dom).direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n    }\n    measureTextSize() {\n        for (let child of this.children){\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure) return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth, textHeight;\n        dummy.className = \"cm-line\";\n        dummy.style.width = \"99999px\";\n        dummy.style.position = \"absolute\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(()=>{\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            textHeight = rect ? rect.height : lineHeight;\n            dummy.remove();\n        });\n        return {\n            lineHeight,\n            charWidth,\n            textHeight\n        };\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i) pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let deco = [], vs = this.view.viewState;\n        for(let pos = 0, i = 0;; i++){\n            let next = i == vs.viewports.length ? null : vs.viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;\n                deco.push(Decoration.replace({\n                    widget: new BlockGapWidget(height),\n                    block: true,\n                    inclusive: true,\n                    isBlockGap: true\n                }).range(pos, end));\n            }\n            if (!next) break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        let allDeco = this.view.state.facet(decorations).map((d, i)=>{\n            let dynamic = this.dynamicDecorationMap[i] = typeof d == \"function\";\n            return dynamic ? d(this.view) : d;\n        });\n        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i)=>{\n            let dynamic = typeof d == \"function\";\n            if (dynamic) dynamicOuter = true;\n            return dynamic ? d(this.view) : d;\n        });\n        if (outerDeco.length) {\n            this.dynamicDecorationMap[allDeco.length] = dynamicOuter;\n            allDeco.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.join(outerDeco));\n        }\n        for(let i = allDeco.length; i < allDeco.length + 3; i++)this.dynamicDecorationMap[i] = false;\n        return this.decorations = [\n            ...allDeco,\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco\n        ];\n    }\n    scrollIntoView(target) {\n        if (target.isSnapshot) {\n            let ref = this.view.viewState.lineBlockAt(target.range.head);\n            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;\n            this.view.scrollDOM.scrollLeft = target.xMargin;\n            return;\n        }\n        let { range } = target;\n        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;\n        if (!rect) return;\n        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {\n            left: Math.min(rect.left, other.left),\n            top: Math.min(rect.top, other.top),\n            right: Math.max(rect.right, other.right),\n            bottom: Math.max(rect.bottom, other.bottom)\n        };\n        let margins = getScrollMargins(this.view);\n        let targetRect = {\n            left: rect.left - margins.left,\n            top: rect.top - margins.top,\n            right: rect.right + margins.right,\n            bottom: rect.bottom + margins.bottom\n        };\n        let { offsetWidth, offsetHeight } = this.view.scrollDOM;\n        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);\n    }\n}\nfunction betweenUneditable(pos) {\n    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nclass BlockGapWidget extends WidgetType {\n    constructor(height){\n        super();\n        this.height = height;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-gap\";\n        this.updateDOM(elt);\n        return elt;\n    }\n    eq(other) {\n        return other.height == this.height;\n    }\n    updateDOM(elt) {\n        elt.style.height = this.height + \"px\";\n        return true;\n    }\n    get editable() {\n        return true;\n    }\n    get estimatedHeight() {\n        return this.height;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nfunction findCompositionNode(view, headPos) {\n    let sel = view.observer.selectionRange;\n    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n    if (!textNode) return null;\n    let from = headPos - textNode.offset;\n    return {\n        from,\n        to: from + textNode.node.nodeValue.length,\n        node: textNode.node\n    };\n}\nfunction findCompositionRange(view, changes, headPos) {\n    let found = findCompositionNode(view, headPos);\n    if (!found) return null;\n    let { node: textNode, from, to } = found, text = textNode.nodeValue;\n    // Don't try to preserve multi-line compositions\n    if (/[\\n\\r]/.test(text)) return null;\n    if (view.state.doc.sliceString(found.from, found.to) != text) return null;\n    let inv = changes.invertedDesc;\n    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);\n    let marks = [];\n    for(let parent = textNode.parentNode;; parent = parent.parentNode){\n        let parentView = ContentView.get(parent);\n        if (parentView instanceof MarkView) marks.push({\n            node: parent,\n            deco: parentView.mark\n        });\n        else if (parentView instanceof LineView || parent.nodeName == \"DIV\" && parent.parentNode == view.contentDOM) return {\n            range,\n            text: textNode,\n            marks,\n            line: parent\n        };\n        else if (parent != view.contentDOM) marks.push({\n            node: parent,\n            deco: new MarkDecoration({\n                inclusive: true,\n                attributes: getAttrs(parent),\n                tagName: parent.tagName.toLowerCase()\n            })\n        });\n        else return null;\n    }\n}\nfunction nearbyTextNode(startNode, startOffset, side) {\n    if (side <= 0) for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3) return {\n            node: node,\n            offset: offset\n        };\n        if (node.nodeType == 1 && offset > 0) {\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        } else {\n            break;\n        }\n    }\n    if (side >= 0) for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3) return {\n            node: node,\n            offset: offset\n        };\n        if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n            node = node.childNodes[offset];\n            offset = 0;\n        } else {\n            break;\n        }\n    }\n    return null;\n}\nfunction nextToUneditable(node, offset) {\n    if (node.nodeType != 1) return 0;\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* NextTo.Before */  : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* NextTo.After */  : 0);\n}\nlet DecorationComparator$1 = class DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange(from, to) {\n        addRange(from, to, this.changes);\n    }\n    comparePoint(from, to) {\n        addRange(from, to, this.changes);\n    }\n};\nfunction findChangedDeco(a, b, diff) {\n    let comp = new DecorationComparator$1;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\nfunction inUneditable(node, inside) {\n    for(let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode){\n        if (cur.nodeType == 1 && cur.contentEditable == \"false\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction touchesComposition(changes, composition) {\n    let touched = false;\n    if (composition) changes.iterChangedRanges((from, to)=>{\n        if (from < composition.to && to > composition.from) touched = true;\n    });\n    return touched;\n}\nfunction groupAt(state, pos, bias = 1) {\n    let categorize = state.charCategorizer(pos);\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\n    if (line.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n    if (linePos == 0) bias = 1;\n    else if (linePos == line.length) bias = -1;\n    let from = linePos, to = linePos;\n    if (bias < 0) from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos, false);\n    else to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos);\n    let cat = categorize(line.text.slice(from, to));\n    while(from > 0){\n        let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, from, false);\n        if (categorize(line.text.slice(prev, from)) != cat) break;\n        from = prev;\n    }\n    while(to < line.length){\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, to);\n        if (categorize(line.text.slice(to, next)) != cat) break;\n        to = next;\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? {\n        top,\n        left: rect.left,\n        right: rect.right,\n        bottom: rect.bottom\n    } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? {\n        top: rect.top,\n        left: rect.left,\n        right: rect.right,\n        bottom\n    } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY, closestOverlap = false;\n    let above, below, aboveRect, belowRect;\n    for(let child = parent.firstChild; child; child = child.nextSibling){\n        let rects = clientRectsFor(child);\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n                let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;\n                closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            } else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            } else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    } else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest) return {\n        node: parent,\n        offset: 0\n    };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3) return domPosInText(closest, clipX, y);\n    if (closestOverlap && closest.contentEditable != \"false\") return domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return {\n        node: parent,\n        offset\n    };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length;\n    let closestOffset = -1, closestDY = 1e9, generalSide = 0;\n    for(let i = 0; i < len; i++){\n        let rects = textRange(node, i, i + 1).getClientRects();\n        for(let j = 0; j < rects.length; j++){\n            let rect = rects[j];\n            if (rect.top == rect.bottom) continue;\n            if (!generalSide) generalSide = x - rect.left;\n            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\n            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    let rectBefore = textRange(node, i).getBoundingClientRect();\n                    if (rectBefore.left == rect.right) after = !right;\n                }\n                if (dy <= 0) return {\n                    node,\n                    offset: i + (after ? 1 : 0)\n                };\n                closestOffset = i + (after ? 1 : 0);\n                closestDY = dy;\n            }\n        }\n    }\n    return {\n        node,\n        offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0\n    };\n}\nfunction posAtCoords(view, coords, precise, bias = -1) {\n    var _a, _b;\n    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;\n    let block, { docHeight } = view.viewState;\n    let { x, y } = coords, yOffset = y - docTop;\n    if (yOffset < 0) return 0;\n    if (yOffset > docHeight) return view.state.doc.length;\n    // Scan for a text block near the queried y position\n    for(let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;){\n        block = view.elementAtHeight(yOffset);\n        if (block.type == BlockType.Text) break;\n        for(;;){\n            // Move the y position out of this block\n            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n            if (yOffset >= 0 && yOffset <= docHeight) break;\n            // If the document consists entirely of replaced widgets, we\n            // won't find a text block, so return 0\n            if (bounced) return precise ? null : 0;\n            bounced = true;\n            bias = -bias;\n        }\n    }\n    y = docTop + yOffset;\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\n    let doc = view.dom.ownerDocument;\n    let root = view.root.elementFromPoint ? view.root : doc;\n    let element = root.elementFromPoint(x, y);\n    if (element && !view.contentDOM.contains(element)) element = null;\n    // If the element is unexpected, clip x at the sides of the content area and try again\n    if (!element) {\n        x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n        element = root.elementFromPoint(x, y);\n        if (element && !view.contentDOM.contains(element)) element = null;\n    }\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {\n        if (doc.caretPositionFromPoint) {\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos) ({ offsetNode: node, offset } = pos);\n        } else if (doc.caretRangeFromPoint) {\n            let range = doc.caretRangeFromPoint(x, y);\n            if (range) {\n                ({ startContainer: node, startOffset: offset } = range);\n                if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)) node = undefined;\n            }\n        }\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node || !view.docView.dom.contains(node)) {\n        let line = LineView.find(view.docView, lineStart);\n        if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    let nearest = view.docView.nearest(node);\n    if (!nearest) return null;\n    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {\n        let rect = nearest.dom.getBoundingClientRect();\n        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;\n    } else {\n        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;\n    }\n}\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n        let textHeight = view.viewState.heightOracle.textHeight;\n        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);\n        into += line * view.viewState.heightOracle.lineLength;\n    }\n    let content = view.state.sliceDoc(block.from, block.to);\n    return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(content, into, view.state.tabSize);\n}\n// In case of a high line height, Safari's caretRangeFromPoint treats\n// the space between lines as belonging to the last character of the\n// line before. This is used to detect such a result so that it can be\n// ignored (issue #401).\nfunction isSuspiciousSafariCaretResult(node, offset, x) {\n    let len;\n    if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;\n    for(let next = node.nextSibling; next; next = next.nextSibling)if (next.nodeType != 1 || next.nodeName != \"BR\") return false;\n    return textRange(node, len - 1, len).getBoundingClientRect().left > x;\n}\n// Chrome will move positions between lines to the start of the next line\nfunction isSuspiciousChromeCaretResult(node, offset, x) {\n    if (offset != 0) return false;\n    for(let cur = node;;){\n        let parent = cur.parentNode;\n        if (!parent || parent.nodeType != 1 || parent.firstChild != cur) return false;\n        if (parent.classList.contains(\"cm-line\")) break;\n        cur = parent;\n    }\n    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();\n    return x - rect.left > 5;\n}\nfunction blockAt(view, pos) {\n    let line = view.lineBlockAt(pos);\n    if (Array.isArray(line.type)) for (let l of line.type){\n        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text)) return l;\n    }\n    return line;\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n    let line = blockAt(view, start.head);\n    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n    if (coords) {\n        let editorRect = view.dom.getBoundingClientRect();\n        let direction = view.textDirectionAt(line.from);\n        let pos = view.posAtCoords({\n            x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n            y: (coords.top + coords.bottom) / 2\n        });\n        if (pos != null) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, forward ? -1 : 1);\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n    let direction = view.textDirectionAt(line.from);\n    for(let cur = start, check = null;;){\n        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;\n        if (!next) {\n            if (line.number == (forward ? view.state.doc.lines : 1)) return cur;\n            char = \"\\n\";\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\n            spans = view.bidiSpans(line);\n            next = view.visualLineSide(line, !forward);\n        }\n        if (!check) {\n            if (!by) return next;\n            check = by(char);\n        } else if (!check(char)) {\n            return cur;\n        }\n        cur = next;\n    }\n}\nfunction byGroup(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start);\n    return (next)=>{\n        let nextCat = categorize(next);\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Space) cat = nextCat;\n        return cat == nextCat;\n    };\n}\nfunction moveVertically(view, start, forward, distance) {\n    let startPos = start.head, dir = forward ? 1 : -1;\n    if (startPos == (forward ? view.state.doc.length : 0)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(startPos, start.assoc);\n    let goal = start.goalColumn, startY;\n    let rect = view.contentDOM.getBoundingClientRect();\n    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;\n    if (startCoords) {\n        if (goal == null) goal = startCoords.left - rect.left;\n        startY = dir < 0 ? startCoords.top : startCoords.bottom;\n    } else {\n        let line = view.viewState.lineBlockAt(startPos);\n        if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n        startY = (dir < 0 ? line.top : line.bottom) + docTop;\n    }\n    let resolvedGoal = rect.left + goal;\n    let dist = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;\n    for(let extra = 0;; extra += 10){\n        let curY = startY + (dist + extra) * dir;\n        let pos = posAtCoords(view, {\n            x: resolvedGoal,\n            y: curY\n        }, false, dir);\n        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {\n            let charRect = view.docView.coordsForChar(pos);\n            let assoc = !charRect || curY < charRect.top ? -1 : 1;\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, assoc, undefined, goal);\n        }\n    }\n}\nfunction skipAtomicRanges(atoms, pos, bias) {\n    for(;;){\n        let moved = 0;\n        for (let set of atoms){\n            set.between(pos - 1, pos + 1, (from, to, value)=>{\n                if (pos > from && pos < to) {\n                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);\n                    pos = side < 0 ? from : to;\n                    moved = side;\n                }\n            });\n        }\n        if (!moved) return pos;\n    }\n}\nfunction skipAtoms(view, oldPos, pos) {\n    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f)=>f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);\n    return newPos == pos.from ? pos : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);\n}\n// This will also be where dragging info and such goes\nclass InputState {\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    constructor(view){\n        this.view = view;\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastTouchTime = 0;\n        this.lastFocusTime = 0;\n        this.lastScrollTop = 0;\n        this.lastScrollLeft = 0;\n        // On iOS, some keys need to have their default behavior happen\n        // (after which we retroactively handle them and reset the DOM) to\n        // avoid messing up the virtual keyboard state.\n        this.pendingIOSKey = undefined;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastEscPress = 0;\n        this.lastContextMenu = 0;\n        this.scrollHandlers = [];\n        this.handlers = Object.create(null);\n        // -1 means not in a composition. Otherwise, this counts the number\n        // of changes made during the composition. The count is used to\n        // avoid treating the start state of the composition, before any\n        // changes have been made, as part of the composition.\n        this.composing = -1;\n        // Tracks whether the next change should be marked as starting the\n        // composition (null means no composition, true means next is the\n        // first, false means first has already been marked for this\n        // composition)\n        this.compositionFirstChange = null;\n        // End time of the previous composition\n        this.compositionEndedAt = 0;\n        // Used in a kludge to detect when an Enter keypress should be\n        // considered part of the composition on Safari, which fires events\n        // in the wrong order\n        this.compositionPendingKey = false;\n        // Used to categorize changes as part of a composition, even when\n        // the mutation events fire shortly after the compositionend event\n        this.compositionPendingChange = false;\n        this.mouseSelection = null;\n        // When a drag from the editor is active, this points at the range\n        // being dragged.\n        this.draggedContent = null;\n        this.handleEvent = this.handleEvent.bind(this);\n        this.notifiedFocused = view.hasFocus;\n        // On Safari adding an input event handler somehow prevents an\n        // issue where the composition vanishes when you press enter.\n        if (browser.safari) view.contentDOM.addEventListener(\"input\", ()=>null);\n        if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);\n    }\n    handleEvent(event) {\n        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;\n        if (event.type == \"keydown\" && this.keydown(event)) return;\n        this.runHandlers(event.type, event);\n    }\n    runHandlers(type, event) {\n        let handlers = this.handlers[type];\n        if (handlers) {\n            for (let observer of handlers.observers)observer(this.view, event);\n            for (let handler of handlers.handlers){\n                if (event.defaultPrevented) break;\n                if (handler(this.view, event)) {\n                    event.preventDefault();\n                    break;\n                }\n            }\n        }\n    }\n    ensureHandlers(plugins) {\n        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;\n        for(let type in handlers)if (type != \"scroll\") {\n            let passive = !handlers[type].handlers.length;\n            let exists = prev[type];\n            if (exists && passive != !exists.handlers.length) {\n                dom.removeEventListener(type, this.handleEvent);\n                exists = null;\n            }\n            if (!exists) dom.addEventListener(type, this.handleEvent, {\n                passive\n            });\n        }\n        for(let type in prev)if (type != \"scroll\" && !handlers[type]) dom.removeEventListener(type, this.handleEvent);\n        this.handlers = handlers;\n    }\n    keydown(event) {\n        // Must always run, even if a custom handler handled the event\n        this.lastKeyCode = event.keyCode;\n        this.lastKeyTime = Date.now();\n        if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000) return true;\n        if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.view.inputState.lastEscPress = 0;\n        // Chrome for Android usually doesn't fire proper key events, but\n        // occasionally does, usually surrounded by a bunch of complicated\n        // composition changes. When an enter or backspace key event is\n        // seen, hold off on handling DOM events for a bit, and then\n        // dispatch it.\n        if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {\n            this.view.observer.delayAndroidKey(event.key, event.keyCode);\n            return true;\n        }\n        // Preventing the default behavior of Enter on iOS makes the\n        // virtual keyboard get stuck in the wrong (lowercase)\n        // state. So we let it go through, and then, in\n        // applyDOMChange, notify key handlers of it and reset to\n        // the state they produce.\n        let pending;\n        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key)=>key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {\n            this.pendingIOSKey = pending || event;\n            setTimeout(()=>this.flushIOSKey(), 250);\n            return true;\n        }\n        if (event.keyCode != 229) this.view.observer.forceFlush();\n        return false;\n    }\n    flushIOSKey() {\n        let key = this.pendingIOSKey;\n        if (!key) return false;\n        this.pendingIOSKey = undefined;\n        return dispatchKey(this.view.contentDOM, key.key, key.keyCode);\n    }\n    ignoreDuringComposition(event) {\n        if (!/^key/.test(event.type)) return false;\n        if (this.composing > 0) return true;\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n        // On some input method editors (IMEs), the Enter key is used to\n        // confirm character selection. On Safari, when Enter is pressed,\n        // compositionend and keydown events are sometimes emitted in the\n        // wrong order. The key event should still be ignored, even when\n        // it happens after the compositionend event.\n        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {\n            this.compositionPendingKey = false;\n            return true;\n        }\n        return false;\n    }\n    startMouseSelection(mouseSelection) {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n        this.mouseSelection = mouseSelection;\n    }\n    update(update) {\n        if (this.mouseSelection) this.mouseSelection.update(update);\n        if (this.draggedContent && update.docChanged) this.draggedContent = this.draggedContent.map(update.changes);\n        if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n    }\n}\nfunction bindHandler(plugin, handler) {\n    return (view, event)=>{\n        try {\n            return handler.call(plugin, event, view);\n        } catch (e) {\n            logException(view.state, e);\n        }\n    };\n}\nfunction computeHandlers(plugins) {\n    let result = Object.create(null);\n    function record(type) {\n        return result[type] || (result[type] = {\n            observers: [],\n            handlers: []\n        });\n    }\n    for (let plugin of plugins){\n        let spec = plugin.spec;\n        if (spec && spec.domEventHandlers) for(let type in spec.domEventHandlers){\n            let f = spec.domEventHandlers[type];\n            if (f) record(type).handlers.push(bindHandler(plugin.value, f));\n        }\n        if (spec && spec.domEventObservers) for(let type in spec.domEventObservers){\n            let f = spec.domEventObservers[type];\n            if (f) record(type).observers.push(bindHandler(plugin.value, f));\n        }\n    }\n    for(let type in handlers)record(type).handlers.push(handlers[type]);\n    for(let type in observers)record(type).observers.push(observers[type]);\n    return result;\n}\nconst PendingKeys = [\n    {\n        key: \"Backspace\",\n        keyCode: 8,\n        inputType: \"deleteContentBackward\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertParagraph\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertLineBreak\"\n    },\n    {\n        key: \"Delete\",\n        keyCode: 46,\n        inputType: \"deleteContentForward\"\n    }\n];\nconst EmacsyPendingKeys = \"dthko\";\n// Key codes for modifier keys\nconst modifierCodes = [\n    16,\n    17,\n    18,\n    20,\n    91,\n    92,\n    224,\n    225\n];\nconst dragScrollMargin = 6;\nfunction dragScrollSpeed(dist) {\n    return Math.max(0, dist) * 0.7 + 8;\n}\nfunction dist(a, b) {\n    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));\n}\nclass MouseSelection {\n    constructor(view, startEvent, style, mustSelect){\n        this.view = view;\n        this.startEvent = startEvent;\n        this.style = style;\n        this.mustSelect = mustSelect;\n        this.scrollSpeed = {\n            x: 0,\n            y: 0\n        };\n        this.scrolling = -1;\n        this.lastEvent = startEvent;\n        this.scrollParent = scrollableParent(view.contentDOM);\n        this.atoms = view.state.facet(atomicRanges).map((f)=>f(view));\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = startEvent.shiftKey;\n        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;\n    }\n    start(event) {\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) this.select(event);\n    }\n    move(event) {\n        var _a;\n        if (event.buttons == 0) return this.destroy();\n        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;\n        this.select(this.lastEvent = event);\n        let sx = 0, sy = 0;\n        let rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect()) || {\n            left: 0,\n            top: 0,\n            right: this.view.win.innerWidth,\n            bottom: this.view.win.innerHeight\n        };\n        let margins = getScrollMargins(this.view);\n        if (event.clientX - margins.left <= rect.left + dragScrollMargin) sx = -dragScrollSpeed(rect.left - event.clientX);\n        else if (event.clientX + margins.right >= rect.right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - rect.right);\n        if (event.clientY - margins.top <= rect.top + dragScrollMargin) sy = -dragScrollSpeed(rect.top - event.clientY);\n        else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - rect.bottom);\n        this.setScrollSpeed(sx, sy);\n    }\n    up(event) {\n        if (this.dragging == null) this.select(this.lastEvent);\n        if (!this.dragging) event.preventDefault();\n        this.destroy();\n    }\n    destroy() {\n        this.setScrollSpeed(0, 0);\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;\n    }\n    setScrollSpeed(sx, sy) {\n        this.scrollSpeed = {\n            x: sx,\n            y: sy\n        };\n        if (sx || sy) {\n            if (this.scrolling < 0) this.scrolling = setInterval(()=>this.scroll(), 50);\n        } else if (this.scrolling > -1) {\n            clearInterval(this.scrolling);\n            this.scrolling = -1;\n        }\n    }\n    scroll() {\n        if (this.scrollParent) {\n            this.scrollParent.scrollLeft += this.scrollSpeed.x;\n            this.scrollParent.scrollTop += this.scrollSpeed.y;\n        } else {\n            this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);\n        }\n        if (this.dragging === false) this.select(this.lastEvent);\n    }\n    skipAtoms(sel) {\n        let ranges = null;\n        for(let i = 0; i < sel.ranges.length; i++){\n            let range = sel.ranges[i], updated = null;\n            if (range.empty) {\n                let pos = skipAtomicRanges(this.atoms, range.from, 0);\n                if (pos != range.from) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, -1);\n            } else {\n                let from = skipAtomicRanges(this.atoms, range.from, -1);\n                let to = skipAtomicRanges(this.atoms, range.to, 1);\n                if (from != range.from || to != range.to) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);\n            }\n            if (updated) {\n                if (!ranges) ranges = sel.ranges.slice();\n                ranges[i] = updated;\n            }\n        }\n        return ranges ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges, sel.mainIndex) : sel;\n    }\n    select(event) {\n        let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));\n        if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false)) this.view.dispatch({\n            selection,\n            userEvent: \"select.pointer\"\n        });\n        this.mustSelect = false;\n    }\n    update(update) {\n        if (this.style.update(update)) setTimeout(()=>this.select(this.lastEvent), 20);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n    let facet = view.state.facet(dragMovesSelection$1);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n    let { main } = view.state.selection;\n    if (main.empty) return false;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (!sel || sel.rangeCount == 0) return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for(let i = 0; i < rects.length; i++){\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target, cView; node != view.contentDOM; node = node.parentNode)if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;\n    return true;\n}\nconst handlers = /*@__PURE__*/ Object.create(null);\nconst observers = /*@__PURE__*/ Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;\nfunction capturePaste(view) {\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(()=>{\n        view.focus();\n        target.remove();\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction doPaste(view, input) {\n    let { state } = view, changes, i = 1, text = state.toText(input);\n    let byLine = text.lines == state.selection.ranges.length;\n    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r)=>r.empty) && lastLinewiseCopy == text.toString();\n    if (linewise) {\n        let lastLine = -1;\n        changes = state.changeByRange((range)=>{\n            let line = state.doc.lineAt(range.from);\n            if (line.from == lastLine) return {\n                range\n            };\n            lastLine = line.from;\n            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n            return {\n                changes: {\n                    from: line.from,\n                    insert\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + insert.length)\n            };\n        });\n    } else if (byLine) {\n        changes = state.changeByRange((range)=>{\n            let line = text.line(i++);\n            return {\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: line.text\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + line.length)\n            };\n        });\n    } else {\n        changes = state.replaceSelection(text);\n    }\n    view.dispatch(changes, {\n        userEvent: \"input.paste\",\n        scrollIntoView: true\n    });\n}\nobservers.scroll = (view)=>{\n    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;\n    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;\n};\nhandlers.keydown = (view, event)=>{\n    view.inputState.setSelectionOrigin(\"select\");\n    if (event.keyCode == 27) view.inputState.lastEscPress = Date.now();\n    return false;\n};\nobservers.touchstart = (view, e)=>{\n    view.inputState.lastTouchTime = Date.now();\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nobservers.touchmove = (view)=>{\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.mousedown = (view, event)=>{\n    view.observer.flush();\n    if (view.inputState.lastTouchTime > Date.now() - 2000) return false; // Ignore touch interaction\n    let style = null;\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)){\n        style = makeStyle(view, event);\n        if (style) break;\n    }\n    if (!style && event.button == 0) style = basicMouseSelection(view, event);\n    if (style) {\n        let mustFocus = !view.hasFocus;\n        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\n        if (mustFocus) view.observer.ignore(()=>focusPreventScroll(view.contentDOM));\n        let mouseSel = view.inputState.mouseSelection;\n        if (mouseSel) {\n            mouseSel.start(event);\n            return mouseSel.dragging === false;\n        }\n    }\n    return false;\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, bias);\n    } else if (type == 2) {\n        return groupAt(view.state, pos, bias);\n    } else {\n        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;\n        if (to < view.state.doc.length && to == line.to) to++;\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n    }\n}\nlet insideY = (y, rect)=>y >= rect.top && y <= rect.bottom;\nlet inside = (x, y, rect)=>insideY(y, rect) && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n    let line = LineView.find(view.docView, pos);\n    if (!line) return 1;\n    let off = pos - line.posAtStart;\n    // Line boundaries point into the line\n    if (off == 0) return 1;\n    if (off == line.length) return -1;\n    // Positions on top of an element point at that element\n    let before = line.coordsAt(off, -1);\n    if (before && inside(x, y, before)) return -1;\n    let after = line.coordsAt(off, 1);\n    if (after && inside(x, y, after)) return 1;\n    // This is probably a line wrap point. Pick before if the point is\n    // beside it.\n    return before && insideY(y, before) ? -1 : 1;\n}\nfunction queryPos(view, event) {\n    let pos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    return {\n        pos,\n        bias: findPositionSide(view, pos, event.clientX, event.clientY)\n    };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;\nfunction getClickType(event) {\n    if (!BadMouseDetail) return event.detail;\n    let last = lastMouseDown, lastTime = lastMouseDownTime;\n    lastMouseDown = event;\n    lastMouseDownTime = Date.now();\n    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n    let start = queryPos(view, event), type = getClickType(event);\n    let startSel = view.state.selection;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                start.pos = update.changes.mapPos(start.pos);\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, extend, multiple) {\n            let cur = queryPos(view, event), removed;\n            let range = rangeForClick(view, cur.pos, cur.bias, type);\n            if (start.pos != cur.pos && !extend) {\n                let startRange = rangeForClick(view, start.pos, start.bias, type);\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(to, from);\n            }\n            if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));\n            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos))) return removed;\n            else if (multiple) return startSel.addRange(range);\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create([\n                range\n            ]);\n        }\n    };\n}\nfunction removeRangeAround(sel, pos) {\n    for(let i = 0; i < sel.ranges.length; i++){\n        let { from, to } = sel.ranges[i];\n        if (from <= pos && to >= pos) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));\n    }\n    return null;\n}\nhandlers.dragstart = (view, event)=>{\n    let { selection: { main: range } } = view.state;\n    if (event.target.draggable) {\n        let cView = view.docView.nearest(event.target);\n        if (cView && cView.isWidget) {\n            let from = cView.posAtStart, to = from + cView.length;\n            if (from >= range.to || to <= range.from) range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n        }\n    }\n    let { inputState } = view;\n    if (inputState.mouseSelection) inputState.mouseSelection.dragging = true;\n    inputState.draggedContent = range;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", view.state.sliceDoc(range.from, range.to));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n    return false;\n};\nhandlers.dragend = (view)=>{\n    view.inputState.draggedContent = null;\n    return false;\n};\nfunction dropText(view, event, text, direct) {\n    if (!text) return;\n    let dropPos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let { draggedContent } = view.inputState;\n    let del = direct && draggedContent && dragMovesSelection(view, event) ? {\n        from: draggedContent.from,\n        to: draggedContent.to\n    } : null;\n    let ins = {\n        from: dropPos,\n        insert: text\n    };\n    let changes = view.state.changes(del ? [\n        del,\n        ins\n    ] : ins);\n    view.focus();\n    view.dispatch({\n        changes,\n        selection: {\n            anchor: changes.mapPos(dropPos, -1),\n            head: changes.mapPos(dropPos, 1)\n        },\n        userEvent: del ? \"move.drop\" : \"input.drop\"\n    });\n    view.inputState.draggedContent = null;\n}\nhandlers.drop = (view, event)=>{\n    if (!event.dataTransfer) return false;\n    if (view.state.readOnly) return true;\n    let files = event.dataTransfer.files;\n    if (files && files.length) {\n        let text = Array(files.length), read = 0;\n        let finishFile = ()=>{\n            if (++read == files.length) dropText(view, event, text.filter((s)=>s != null).join(view.state.lineBreak), false);\n        };\n        for(let i = 0; i < files.length; i++){\n            let reader = new FileReader;\n            reader.onerror = finishFile;\n            reader.onload = ()=>{\n                if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result)) text[i] = reader.result;\n                finishFile();\n            };\n            reader.readAsText(files[i]);\n        }\n        return true;\n    } else {\n        let text = event.dataTransfer.getData(\"Text\");\n        if (text) {\n            dropText(view, event, text, true);\n            return true;\n        }\n    }\n    return false;\n};\nhandlers.paste = (view, event)=>{\n    if (view.state.readOnly) return true;\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        doPaste(view, data.getData(\"text/plain\") || data.getData(\"text/uri-text\"));\n        return true;\n    } else {\n        capturePaste(view);\n        return false;\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(()=>{\n        target.remove();\n        view.focus();\n    }, 50);\n}\nfunction copiedRange(state) {\n    let content = [], ranges = [], linewise = false;\n    for (let range of state.selection.ranges)if (!range.empty) {\n        content.push(state.sliceDoc(range.from, range.to));\n        ranges.push(range);\n    }\n    if (!content.length) {\n        // Nothing selected, do a line-wise copy\n        let upto = -1;\n        for (let { from } of state.selection.ranges){\n            let line = state.doc.lineAt(from);\n            if (line.number > upto) {\n                content.push(line.text);\n                ranges.push({\n                    from: line.from,\n                    to: Math.min(state.doc.length, line.to + 1)\n                });\n            }\n            upto = line.number;\n        }\n        linewise = true;\n    }\n    return {\n        text: content.join(state.lineBreak),\n        ranges,\n        linewise\n    };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event)=>{\n    let { text, ranges, linewise } = copiedRange(view.state);\n    if (!text && !linewise) return false;\n    lastLinewiseCopy = linewise ? text : null;\n    if (event.type == \"cut\" && !view.state.readOnly) view.dispatch({\n        changes: ranges,\n        scrollIntoView: true,\n        userEvent: \"delete.cut\"\n    });\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        data.clearData();\n        data.setData(\"text/plain\", text);\n        return true;\n    } else {\n        captureCopy(view, text);\n        return false;\n    }\n};\nconst isFocusChange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Annotation.define();\nfunction focusChangeTransaction(state, focus) {\n    let effects = [];\n    for (let getEffect of state.facet(focusChangeEffect)){\n        let effect = getEffect(state, focus);\n        if (effect) effects.push(effect);\n    }\n    return effects ? state.update({\n        effects,\n        annotations: isFocusChange.of(true)\n    }) : null;\n}\nfunction updateForFocusChange(view) {\n    setTimeout(()=>{\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            let tr = focusChangeTransaction(view.state, focus);\n            if (tr) view.dispatch(tr);\n            else view.update([]);\n        }\n    }, 10);\n}\nobservers.focus = (view)=>{\n    view.inputState.lastFocusTime = Date.now();\n    // When focusing reset the scroll position, move it back to where it was\n    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {\n        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;\n        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;\n    }\n    updateForFocusChange(view);\n};\nobservers.blur = (view)=>{\n    view.observer.clearSelectionRange();\n    updateForFocusChange(view);\n};\nobservers.compositionstart = observers.compositionupdate = (view)=>{\n    if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;\n    if (view.inputState.composing < 0) {\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = 0;\n    }\n};\nobservers.compositionend = (view)=>{\n    view.inputState.composing = -1;\n    view.inputState.compositionEndedAt = Date.now();\n    view.inputState.compositionPendingKey = true;\n    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;\n    view.inputState.compositionFirstChange = null;\n    if (browser.chrome && browser.android) {\n        // Delay flushing for a bit on Android because it'll often fire a\n        // bunch of contradictory changes in a row at end of compositon\n        view.observer.flushSoon();\n    } else if (view.inputState.compositionPendingChange) {\n        // If we found pending records, schedule a flush.\n        Promise.resolve().then(()=>view.observer.flush());\n    } else {\n        // Otherwise, make sure that, if no changes come in soon, the\n        // composition view is cleared.\n        setTimeout(()=>{\n            if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);\n        }, 50);\n    }\n};\nobservers.contextmenu = (view)=>{\n    view.inputState.lastContextMenu = Date.now();\n};\nhandlers.beforeinput = (view, event)=>{\n    var _a;\n    // Because Chrome Android doesn't fire useful key events, use\n    // beforeinput to detect backspace (and possibly enter and delete,\n    // but those usually don't even seem to fire beforeinput events at\n    // the moment) and fake a key event for it.\n    //\n    // (preventDefault on beforeinput, though supported in the spec,\n    // seems to do nothing at all on Chrome).\n    let pending;\n    if (browser.chrome && browser.android && (pending = PendingKeys.find((key)=>key.inputType == event.inputType))) {\n        view.observer.delayAndroidKey(pending.key, pending.keyCode);\n        if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\n            let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;\n            setTimeout(()=>{\n                var _a;\n                // Backspacing near uneditable nodes on Chrome Android sometimes\n                // closes the virtual keyboard. This tries to crudely detect\n                // that and refocus to get it back.\n                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\n                    view.contentDOM.blur();\n                    view.focus();\n                }\n            }, 100);\n        }\n    }\n    return false;\n};\nconst appliedFirefoxHack = /*@__PURE__*/ new Set;\n// In Firefox, when cut/copy handlers are added to the document, that\n// somehow avoids a bug where those events aren't fired when the\n// selection is empty. See https://github.com/codemirror/dev/issues/1082\n// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961\nfunction firefoxCopyCutHack(doc) {\n    if (!appliedFirefoxHack.has(doc)) {\n        appliedFirefoxHack.add(doc);\n        doc.addEventListener(\"copy\", ()=>{});\n        doc.addEventListener(\"cut\", ()=>{});\n    }\n}\nconst wrappingWhiteSpace = [\n    \"pre-wrap\",\n    \"normal\",\n    \"pre-line\",\n    \"break-spaces\"\n];\nclass HeightOracle {\n    constructor(lineWrapping){\n        this.lineWrapping = lineWrapping;\n        this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n        this.heightSamples = {};\n        this.lineHeight = 14; // The height of an entire line (line-height)\n        this.charWidth = 7;\n        this.textHeight = 14; // The height of the actual font (font-size)\n        this.lineLength = 30;\n        // Used to track, during updateHeight, if any actual heights changed\n        this.heightChanged = false;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping) lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping) return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) {\n        this.doc = doc;\n        return this;\n    }\n    mustRefreshForWrapping(whiteSpace) {\n        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;\n    }\n    mustRefreshForHeights(lineHeights) {\n        let newHeight = false;\n        for(let i = 0; i < lineHeights.length; i++){\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            } else if (!this.heightSamples[Math.floor(h * 10)]) {\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight;\n    }\n    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;\n        this.lineWrapping = lineWrapping;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.textHeight = textHeight;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for(let i = 0; i < knownHeights.length; i++){\n                let h = knownHeights[i];\n                if (h < 0) i++;\n                else this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights){\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() {\n        return this.index < this.heights.length;\n    }\n}\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/ class BlockInfo {\n    /**\n    @internal\n    */ constructor(/**\n    The start of the element in the document.\n    */ from, /**\n    The length of the element.\n    */ length, /**\n    The top position of the element (relative to the top of the\n    document).\n    */ top, /**\n    Its height.\n    */ height, /**\n    @internal Weird packed field that holds an array of children\n    for composite blocks, a decoration for block widgets, and a\n    number indicating the amount of widget-create line breaks for\n    text blocks.\n    */ _content){\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this._content = _content;\n    }\n    /**\n    The type of element this is. When querying lines, this may be\n    an array of all the blocks that make up the line.\n    */ get type() {\n        return typeof this._content == \"number\" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;\n    }\n    /**\n    The end of the element as a document position.\n    */ get to() {\n        return this.from + this.length;\n    }\n    /**\n    The bottom position of the element.\n    */ get bottom() {\n        return this.top + this.height;\n    }\n    /**\n    If this is a widget block, this will return the widget\n    associated with it.\n    */ get widget() {\n        return this._content instanceof PointDecoration ? this._content.widget : null;\n    }\n    /**\n    If this is a textblock, this holds the number of line breaks\n    that appear in widgets inside the block.\n    */ get widgetLineBreaks() {\n        return typeof this._content == \"number\" ? this._content : 0;\n    }\n    /**\n    @internal\n    */ join(other) {\n        let content = (Array.isArray(this._content) ? this._content : [\n            this\n        ]).concat(Array.isArray(other._content) ? other._content : [\n            other\n        ]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);\n    }\n}\nvar QueryType = /*@__PURE__*/ function(QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n    return QueryType;\n}(QueryType || (QueryType = {}));\nconst Epsilon = 1e-3;\nclass HeightMap {\n    constructor(length, height, flags = 2 /* Flag.Outdated */ ){\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() {\n        return (this.flags & 2 /* Flag.Outdated */ ) > 0;\n    }\n    set outdated(value) {\n        this.flags = (value ? 2 /* Flag.Outdated */  : 0) | this.flags & ~2 /* Flag.Outdated */ ;\n    }\n    setHeight(oracle, height) {\n        if (this.height != height) {\n            if (Math.abs(this.height - height) > Epsilon) oracle.heightChanged = true;\n            this.height = height;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) {\n        result.push(this);\n    }\n    decomposeRight(_from, result) {\n        result.push(this);\n    }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this, doc = oracle.doc;\n        for(let i = changes.length - 1; i >= 0; i--){\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while(i > 0 && start.from <= changes[i - 1].toA){\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);\n            me = me.replace(fromA, toA, nodes);\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() {\n        return new HeightMapText(0, 0);\n    }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1) return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for(;;){\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break) nodes.splice(--i, 1, split.left, null, split.right);\n                    else nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                } else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break) nodes.splice(j, 1, split.left, null, split.right);\n                    else nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                } else {\n                    break;\n                }\n            } else if (before < after) {\n                let next = nodes[i++];\n                if (next) before += next.size;\n            } else {\n                let next = nodes[--j];\n                if (next) after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        } else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, deco){\n        super(length, height);\n        this.deco = deco;\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);\n    }\n    lineAt(_value, _type, oracle, top, offset) {\n        return this.blockAt(0, oracle, top, offset);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        if (from <= offset + this.length && to >= offset) f(this.blockAt(0, oracle, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `block(${this.length})`;\n    }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height){\n        super(length, height, null);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n        this.breaks = 0; // Number of widget-introduced line breaks on the line\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.breaks);\n    }\n    replace(_from, _to, nodes) {\n        let node = nodes[0];\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4 /* Flag.SingleLine */ ) && Math.abs(this.length - node.length) < 10) {\n            if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);\n            else node.height = this.height;\n            if (!this.outdated) node.outdated = false;\n            return node;\n        } else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);\n        else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length){\n        super(length, 0);\n    }\n    heightMetrics(oracle, offset) {\n        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;\n        let lines = lastLine - firstLine + 1;\n        let perLine, perChar = 0;\n        if (oracle.lineWrapping) {\n            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);\n            perLine = totalPerLine / lines;\n            if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);\n        } else {\n            perLine = this.height / lines;\n        }\n        return {\n            firstLine,\n            lastLine,\n            perLine,\n            perChar\n        };\n    }\n    blockAt(height, oracle, top, offset) {\n        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        if (oracle.lineWrapping) {\n            let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length);\n            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;\n            let lineTop = Math.max(top, height - lineHeight / 2);\n            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);\n        } else {\n            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));\n            let { from, length } = oracle.doc.line(firstLine + line);\n            return new BlockInfo(from, length, top + perLine * line, perLine, 0);\n        }\n    }\n    lineAt(value, type, oracle, top, offset) {\n        if (type == QueryType.ByHeight) return this.blockAt(value, oracle, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { from, to } = oracle.doc.lineAt(value);\n            return new BlockInfo(from, to - from, 0, 0, 0);\n        }\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;\n        let linesAbove = line.number - firstLine;\n        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);\n        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        from = Math.max(from, offset);\n        to = Math.min(to, offset + this.length);\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        for(let pos = from, lineTop = top; pos <= to;){\n            let line = oracle.doc.lineAt(pos);\n            if (pos == from) {\n                let linesAbove = line.number - firstLine;\n                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);\n            }\n            let lineHeight = perLine + perChar * line.length;\n            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));\n            lineTop += lineHeight;\n            pos = line.to + 1;\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);\n            else nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(new HeightMapGap(to - 1), null);\n    }\n    decomposeRight(from, result) {\n        result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;\n            if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while(pos <= end && measured.more){\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length) nodes.push(null);\n                let height = measured.heights[measured.index++];\n                if (singleHeight == -1) singleHeight = height;\n                else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;\n                let line = new HeightMapText(len, height);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            let result = HeightMap.of(nodes);\n            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) oracle.heightChanged = true;\n            return result;\n        } else if (force || this.outdated) {\n            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() {\n        return `gap(${this.length})`;\n    }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right){\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */  : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() {\n        return this.flags & 1 /* Flag.Break */ ;\n    }\n    blockAt(height, oracle, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid ? this.left.blockAt(height, oracle, top, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, oracle, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, oracle, top, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left) return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));\n        else return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset) this.left.forEachLine(from, to, oracle, top, offset, f);\n            if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);\n        } else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);\n            if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);\n            if (mid.to >= from && mid.from <= to) f(mid);\n            if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0) this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)result.push(node);\n        if (from > 0) mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left) return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left) result.push(null);\n        }\n        if (to > left) this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right) return this.right.decomposeRight(from - right, result);\n        if (from < left) this.left.decomposeRight(from, result);\n        if (this.break && from < right) result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [\n            left,\n            null,\n            right\n        ] : [\n            left,\n            right\n        ]);\n        this.left = left;\n        this.right = right;\n        this.height = left.height + right.height;\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else right.updateHeight(oracle, rightStart, force);\n        if (rebalance) return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return this.left + (this.break ? \" \" : \"-\") + this.right;\n    }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle){\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText) last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? deco.widget.estimatedHeight : 0;\n            let breaks = deco.widget ? deco.widget.lineBreaks : 0;\n            if (height < 0) height = this.oracle.lineHeight;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco));\n            } else if (len || breaks || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, breaks, len);\n            }\n        } else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n    enterLine() {\n        if (this.lineStart > -1) return;\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = from;\n        this.lineEnd = to;\n        if (this.writtenTo < from) {\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));\n        this.writtenTo = this.pos;\n    }\n    blankContent(from, to) {\n        let gap = new HeightMapGap(to - from);\n        if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4 /* Flag.SingleLine */ ;\n        return gap;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText) return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        let deco = block.deco;\n        if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (deco && deco.endSide > 0) this.covering = block;\n    }\n    addLineDeco(height, breaks, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        line.breaks += breaks;\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n        let pos = from;\n        for (let node of this.nodes){\n            if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder, 0);\n        return builder.finish(from);\n    }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n    let comp = new DecorationComparator;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp, 0);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange() {}\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);\n    }\n}\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);\n    for(let parent = dom.parentNode; parent && parent != doc.body;){\n        if (parent.nodeType == 1) {\n            let elt = parent;\n            let style = window.getComputedStyle(elt);\n            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != \"visible\") {\n                let parentRect = elt.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);\n            }\n            parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\n        } else if (parent.nodeType == 11) {\n            parent = parent.host;\n        } else {\n            break;\n        }\n    }\n    return {\n        left: left - rect.left,\n        right: Math.max(left, right) - rect.left,\n        top: top - (rect.top + paddingTop),\n        bottom: Math.max(top, bottom) - (rect.top + paddingTop)\n    };\n}\nfunction fullPixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    return {\n        left: 0,\n        right: rect.right - rect.left,\n        top: paddingTop,\n        bottom: rect.bottom - (rect.top + paddingTop)\n    };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size){\n        this.from = from;\n        this.to = to;\n        this.size = size;\n    }\n    static same(a, b) {\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++){\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;\n        }\n        return true;\n    }\n    draw(viewState, wrapping) {\n        return Decoration.replace({\n            widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)\n        }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    constructor(size, vertical){\n        super();\n        this.size = size;\n        this.vertical = vertical;\n    }\n    eq(other) {\n        return other.size == this.size && other.vertical == this.vertical;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.vertical) {\n            elt.style.height = this.size + \"px\";\n        } else {\n            elt.style.width = this.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    get estimatedHeight() {\n        return this.vertical ? this.size : -1;\n    }\n}\nclass ViewState {\n    constructor(state){\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = {\n            left: 0,\n            right: window.innerWidth,\n            top: 0,\n            bottom: 0\n        };\n        this.inView = true;\n        this.paddingTop = 0; // Padding above the document, scaled\n        this.paddingBottom = 0; // Padding below the document, scaled\n        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width\n        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height\n        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled\n        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled\n        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled\n        this.scrolledToBottom = true;\n        // The CSS-transformation scale of the editor (transformed size /\n        // concrete size)\n        this.scaleX = 1;\n        this.scaleY = 1;\n        // The vertical position (document-relative) to which to anchor the\n        // scroll position. -1 means anchor to the end of the document.\n        this.scrollAnchorPos = 0;\n        // The height at the anchor position. Set by the DOM update phase.\n        // -1 means no height available.\n        this.scrollAnchorHeight = -1;\n        // See VP.MaxDOMHeight\n        this.scaler = IdScaler;\n        this.scrollTarget = null;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        // Flag set when editor content was redrawn, so that the next\n        // measure stage knows it must read DOM layout\n        this.mustMeasureContent = true;\n        this.defaultTextDirection = Direction.LTR;\n        this.visibleRanges = [];\n        // Cursor 'assoc' is only significant when the cursor is on a line\n        // wrap point, where it must stick to the character that it is\n        // associated with. Since browsers don't provide a reasonable\n        // interface to set or query this, when a selection is set that\n        // might cause this to be significant, this flag is set. The next\n        // measure phase will check whether the cursor is on a line-wrapping\n        // boundary and, if so, reset it to make sure it is positioned in\n        // the right place.\n        this.mustEnforceCursorAssoc = false;\n        let guessWrapping = state.facet(contentAttributes).some((v)=>typeof v != \"function\" && v.class == \"cm-lineWrapping\");\n        this.heightOracle = new HeightOracle(guessWrapping);\n        this.stateDeco = state.facet(decorations).filter((d)=>typeof d != \"function\");\n        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle.setDoc(state.doc), [\n            new ChangedRange(0, 0, 0, state.doc.length)\n        ]);\n        this.viewport = this.getViewport(0, null);\n        this.updateViewportLines();\n        this.updateForViewport();\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map((gap)=>gap.draw(this, false)));\n        this.computeVisibleRanges();\n    }\n    updateForViewport() {\n        let viewports = [\n            this.viewport\n        ], { main } = this.state.selection;\n        for(let i = 0; i <= 1; i++){\n            let pos = i ? main.head : main.anchor;\n            if (!viewports.some(({ from, to })=>pos >= from && pos <= to)) {\n                let { from, to } = this.lineBlockAt(pos);\n                viewports.push(new Viewport(from, to));\n            }\n        }\n        this.viewports = viewports.sort((a, b)=>a.from - b.from);\n        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */  ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);\n    }\n    updateViewportLines() {\n        this.viewportLines = [];\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block)=>{\n            this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));\n        });\n    }\n    update(update, scrollTarget = null) {\n        this.state = update.state;\n        let prevDeco = this.stateDeco;\n        this.stateDeco = this.state.facet(decorations).filter((d)=>typeof d != \"function\");\n        let contentChanges = update.changedRanges;\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.state.doc.length)));\n        let prevHeight = this.heightMap.height;\n        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);\n        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight) update.flags |= 2 /* UpdateFlag.Height */ ;\n        if (scrollAnchor) {\n            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);\n            this.scrollAnchorHeight = scrollAnchor.top;\n        } else {\n            this.scrollAnchorPos = -1;\n            this.scrollAnchorHeight = this.heightMap.height;\n        }\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);\n        let updateLines = !update.changes.empty || update.flags & 2 /* UpdateFlag.Height */  || viewport.from != this.viewport.from || viewport.to != this.viewport.to;\n        this.viewport = viewport;\n        this.updateForViewport();\n        if (updateLines) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        update.flags |= this.computeVisibleRanges();\n        if (scrollTarget) this.scrollTarget = scrollTarget;\n        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;\n    }\n    measure(view) {\n        let dom = view.contentDOM, style = window.getComputedStyle(dom);\n        let oracle = this.heightOracle;\n        let whiteSpace = style.whiteSpace;\n        this.defaultTextDirection = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);\n        let domRect = dom.getBoundingClientRect();\n        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;\n        this.contentDOMHeight = domRect.height;\n        this.mustMeasureContent = false;\n        let result = 0, bias = 0;\n        if (domRect.width && domRect.height) {\n            let { scaleX, scaleY } = getScale(dom, domRect);\n            if (this.scaleX != scaleX || this.scaleY != scaleY) {\n                this.scaleX = scaleX;\n                this.scaleY = scaleY;\n                result |= 8 /* UpdateFlag.Geometry */ ;\n                refresh = measureContent = true;\n            }\n        }\n        // Vertical padding\n        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;\n        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;\n        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n            this.paddingTop = paddingTop;\n            this.paddingBottom = paddingBottom;\n            result |= 8 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ ;\n        }\n        if (this.editorWidth != view.scrollDOM.clientWidth) {\n            if (oracle.lineWrapping) measureContent = true;\n            this.editorWidth = view.scrollDOM.clientWidth;\n            result |= 8 /* UpdateFlag.Geometry */ ;\n        }\n        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;\n        if (this.scrollTop != scrollTop) {\n            this.scrollAnchorHeight = -1;\n            this.scrollTop = scrollTop;\n        }\n        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);\n        // Pixel viewport\n        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n        if (inView != this.inView) {\n            this.inView = inView;\n            if (inView) measureContent = true;\n        }\n        if (!this.inView && !this.scrollTarget) return 0;\n        let contentWidth = domRect.width;\n        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {\n            this.contentDOMWidth = domRect.width;\n            this.editorHeight = view.scrollDOM.clientHeight;\n            result |= 8 /* UpdateFlag.Geometry */ ;\n        }\n        if (measureContent) {\n            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);\n            if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;\n            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\n                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();\n                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);\n                if (refresh) {\n                    view.docView.minWidth = 0;\n                    result |= 8 /* UpdateFlag.Geometry */ ;\n                }\n            }\n            if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);\n            oracle.heightChanged = false;\n            for (let vp of this.viewports){\n                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);\n                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle, [\n                    new ChangedRange(0, 0, 0, view.state.doc.length)\n                ]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));\n            }\n            if (oracle.heightChanged) result |= 2 /* UpdateFlag.Height */ ;\n        }\n        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\n        if (viewportChange) this.viewport = this.getViewport(bias, this.scrollTarget);\n        this.updateForViewport();\n        if (result & 2 /* UpdateFlag.Height */  || viewportChange) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));\n        result |= this.computeVisibleRanges();\n        if (this.mustEnforceCursorAssoc) {\n            this.mustEnforceCursorAssoc = false;\n            // This is done in the read stage, because moving the selection\n            // to a line end is going to trigger a layout anyway, so it\n            // can't be a pure write. It should be rare that it does any\n            // writing.\n            view.docView.enforceCursorAssoc();\n        }\n        return result;\n    }\n    get visibleTop() {\n        return this.scaler.fromDOM(this.pixelViewport.top);\n    }\n    get visibleBottom() {\n        return this.scaler.fromDOM(this.pixelViewport.bottom);\n    }\n    getViewport(bias, scrollTarget) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */  / 2));\n        let map = this.heightMap, oracle = this.heightOracle;\n        let { visibleTop, visibleBottom } = this;\n        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).to);\n        // If scrollTarget is given, make sure the viewport includes that position\n        if (scrollTarget) {\n            let { head } = scrollTarget.range;\n            if (head < viewport.from || head > viewport.to) {\n                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);\n                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;\n                if (scrollTarget.y == \"center\") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;\n                else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from) topPos = block.top;\n                else topPos = block.bottom - viewHeight;\n                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);\n    }\n    // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n    viewportIsAppropriate({ from, to }, bias = 0) {\n        if (!this.inView) return true;\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { visibleTop, visibleBottom } = this;\n        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */ , Math.min(-bias, 250 /* VP.MaxCoverMargin */ ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */ , Math.min(bias, 250 /* VP.MaxCoverMargin */ ))) && top > visibleTop - 2 * 1000 /* VP.Margin */  && bottom < visibleBottom + 2 * 1000 /* VP.Margin */ ;\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || changes.empty) return gaps;\n        let mapped = [];\n        for (let gap of gaps)if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current, mayMeasure) {\n        let wrapping = this.heightOracle.lineWrapping;\n        let margin = wrapping ? 10000 /* LG.MarginWrap */  : 2000 /* LG.Margin */ , halfMargin = margin >> 1, doubleMargin = margin << 1;\n        // The non-wrapping logic won't work at all in predominantly right-to-left text.\n        if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];\n        let gaps = [];\n        let addGap = (from, to, line, structure)=>{\n            if (to - from < halfMargin) return;\n            let sel = this.state.selection.main, avoid = [\n                sel.from\n            ];\n            if (!sel.empty) avoid.push(sel.to);\n            for (let pos of avoid){\n                if (pos > from && pos < to) {\n                    addGap(from, pos - 10 /* LG.SelectionMargin */ , line, structure);\n                    addGap(pos + 10 /* LG.SelectionMargin */ , to, line, structure);\n                    return;\n                }\n            }\n            let gap = find(current, (gap)=>gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some((pos)=>gap.from < pos && gap.to > pos));\n            if (!gap) {\n                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping\n                if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r)=>r.from <= to && r.to >= to)) {\n                    let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(to), false, true).head;\n                    if (lineStart > from) to = lineStart;\n                }\n                gap = new LineGap(from, to, this.gapSize(line, from, to, structure));\n            }\n            gaps.push(gap);\n        };\n        for (let line of this.viewportLines){\n            if (line.length < doubleMargin) continue;\n            let structure = lineStructure(line.from, line.to, this.stateDeco);\n            if (structure.total < doubleMargin) continue;\n            let target = this.scrollTarget ? this.scrollTarget.range.head : null;\n            let viewFrom, viewTo;\n            if (wrapping) {\n                let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;\n                let top, bot;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;\n                    top = targetFrac - spaceFrac;\n                    bot = targetFrac + spaceFrac;\n                } else {\n                    top = (this.visibleTop - line.top - marginHeight) / line.height;\n                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;\n                }\n                viewFrom = findPosition(structure, top);\n                viewTo = findPosition(structure, bot);\n            } else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                let marginWidth = margin * this.heightOracle.charWidth;\n                let left, right;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;\n                    left = targetFrac - spaceFrac;\n                    right = targetFrac + spaceFrac;\n                } else {\n                    left = (this.pixelViewport.left - marginWidth) / totalWidth;\n                    right = (this.pixelViewport.right + marginWidth) / totalWidth;\n                }\n                viewFrom = findPosition(structure, left);\n                viewTo = findPosition(structure, right);\n            }\n            if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);\n            if (viewTo < line.to) addGap(viewTo, line.to, line, structure);\n        }\n        return gaps;\n    }\n    gapSize(line, from, to, structure) {\n        let fraction = findFraction(structure, to) - findFraction(structure, from);\n        if (this.heightOracle.lineWrapping) {\n            return line.height * fraction;\n        } else {\n            return structure.total * this.heightOracle.charWidth * fraction;\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map((gap)=>gap.draw(this, this.heightOracle.lineWrapping)));\n        }\n    }\n    computeVisibleRanges() {\n        let deco = this.stateDeco;\n        if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span (from, to) {\n                ranges.push({\n                    from,\n                    to\n                });\n            },\n            point () {}\n        }, 20);\n        let changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i)=>r.from != ranges[i].from || r.to != ranges[i].to);\n        this.visibleRanges = ranges;\n        return changed ? 4 /* UpdateFlag.Viewport */  : 0;\n    }\n    lineBlockAt(pos) {\n        return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b)=>b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);\n    }\n    lineBlockAtHeight(height) {\n        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);\n    }\n    scrollAnchorAt(scrollTop) {\n        let block = this.lineBlockAtHeight(scrollTop + 8);\n        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];\n    }\n    elementAtHeight(height) {\n        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);\n    }\n    get docHeight() {\n        return this.scaler.toDOM(this.heightMap.height);\n    }\n    get contentHeight() {\n        return this.docHeight + this.paddingTop + this.paddingBottom;\n    }\n}\nclass Viewport {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\nfunction lineStructure(from, to, stateDeco) {\n    let ranges = [], pos = from, total = 0;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(stateDeco, from, to, {\n        span () {},\n        point (from, to) {\n            if (from > pos) {\n                ranges.push({\n                    from: pos,\n                    to: from\n                });\n                total += from - pos;\n            }\n            pos = to;\n        }\n    }, 20); // We're only interested in collapsed ranges of a significant size\n    if (pos < to) {\n        ranges.push({\n            from: pos,\n            to\n        });\n        total += to - pos;\n    }\n    return {\n        total,\n        ranges\n    };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0) return ranges[0].from;\n    if (ratio >= 1) return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for(let i = 0;; i++){\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size) return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges){\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)if (f(val)) return val;\n    return undefined;\n}\n// Don't scale when the document height is within the range of what\n// the DOM can handle.\nconst IdScaler = {\n    toDOM (n) {\n        return n;\n    },\n    fromDOM (n) {\n        return n;\n    },\n    scale: 1\n};\n// When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\nclass BigScaler {\n    constructor(oracle, heightMap, viewports){\n        let vpHeight = 0, base = 0, domBase = 0;\n        this.viewports = viewports.map(({ from, to })=>{\n            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;\n            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;\n            vpHeight += bottom - top;\n            return {\n                from,\n                to,\n                top,\n                bottom,\n                domTop: 0,\n                domBottom: 0\n            };\n        });\n        this.scale = (7000000 /* VP.MaxDOMHeight */  - vpHeight) / (heightMap.height - vpHeight);\n        for (let obj of this.viewports){\n            obj.domTop = domBase + (obj.top - base) * this.scale;\n            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n            base = obj.bottom;\n        }\n    }\n    toDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.top) return domBase + (n - base) * this.scale;\n            if (n <= vp.bottom) return vp.domTop + (n - vp.top);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    fromDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale;\n            if (n <= vp.domBottom) return vp.top + (n - vp.domTop);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n}\nfunction scaleBlock(block, scaler) {\n    if (scaler.scale == 1) return block;\n    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);\n    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b)=>scaleBlock(b, scaler)) : block._content);\n}\nconst theme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (strs)=>strs.join(\" \")\n});\nconst darkTheme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.indexOf(true) > -1\n});\nconst baseThemeID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseLightID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseDarkID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nconst lightDarkIDs = {\n    \"&light\": \".\" + baseLightID,\n    \"&dark\": \".\" + baseDarkID\n};\nfunction buildTheme(main, spec, scopes) {\n    return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n        finish (sel) {\n            return /&/.test(sel) ? sel.replace(/&\\w*/, (m)=>{\n                if (m == \"&\") return main;\n                if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);\n                return scopes[m];\n            }) : main + \" \" + sel;\n        }\n    });\n}\nconst baseTheme$1 = /*@__PURE__*/ buildTheme(\".\" + baseThemeID, {\n    \"&\": {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.cm-focused\": {\n            // Provide a simple default outline to make sure a focused\n            // editor is visually distinct. Can't leave the default behavior\n            // because that will apply to the content element, which is\n            // inside the scrollable container and doesn't include the\n            // gutters. We also can't use an 'auto' outline, since those\n            // are, for some reason, drawn behind the element content, which\n            // will cause things like the active line background to cover\n            // the outline (#297).\n            outline: \"1px dotted #212121\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    \".cm-scroller\": {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\",\n        position: \"relative\",\n        zIndex: 0\n    },\n    \".cm-content\": {\n        margin: 0,\n        flexGrow: 2,\n        flexShrink: 0,\n        display: \"block\",\n        whiteSpace: \"pre\",\n        wordWrap: \"normal\",\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        padding: \"4px 0\",\n        outline: \"none\",\n        \"&[contenteditable=true]\": {\n            WebkitUserModify: \"read-write-plaintext-only\"\n        }\n    },\n    \".cm-lineWrapping\": {\n        whiteSpace_fallback: \"pre-wrap\",\n        whiteSpace: \"break-spaces\",\n        wordBreak: \"break-word\",\n        overflowWrap: \"anywhere\",\n        flexShrink: 1\n    },\n    \"&light .cm-content\": {\n        caretColor: \"black\"\n    },\n    \"&dark .cm-content\": {\n        caretColor: \"white\"\n    },\n    \".cm-line\": {\n        display: \"block\",\n        padding: \"0 2px 0 6px\"\n    },\n    \".cm-layer\": {\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        contain: \"size style\",\n        \"& > *\": {\n            position: \"absolute\"\n        }\n    },\n    \"&light .cm-selectionBackground\": {\n        background: \"#d9d9d9\"\n    },\n    \"&dark .cm-selectionBackground\": {\n        background: \"#222\"\n    },\n    \"&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#d7d4f0\"\n    },\n    \"&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#233\"\n    },\n    \".cm-cursorLayer\": {\n        pointerEvents: \"none\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer\": {\n        animation: \"steps(1) cm-blink 1.2s infinite\"\n    },\n    // Two animations defined so that we can switch between them to\n    // restart the animation without forcing another style\n    // recomputation.\n    \"@keyframes cm-blink\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \"@keyframes cm-blink2\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeft: \"1.2px solid black\",\n        marginLeft: \"-0.6px\",\n        pointerEvents: \"none\"\n    },\n    \".cm-cursor\": {\n        display: \"none\"\n    },\n    \"&dark .cm-cursor\": {\n        borderLeftColor: \"#444\"\n    },\n    \".cm-dropCursor\": {\n        position: \"absolute\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor\": {\n        display: \"block\"\n    },\n    \".cm-iso\": {\n        unicodeBidi: \"isolate\"\n    },\n    \".cm-announced\": {\n        position: \"fixed\",\n        top: \"-10000px\"\n    },\n    \"@media print\": {\n        \".cm-announced\": {\n            display: \"none\"\n        }\n    },\n    \"&light .cm-activeLine\": {\n        backgroundColor: \"#cceeff44\"\n    },\n    \"&dark .cm-activeLine\": {\n        backgroundColor: \"#99eeff33\"\n    },\n    \"&light .cm-specialChar\": {\n        color: \"red\"\n    },\n    \"&dark .cm-specialChar\": {\n        color: \"#f78\"\n    },\n    \".cm-gutters\": {\n        flexShrink: 0,\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        insetInlineStart: 0,\n        zIndex: 200\n    },\n    \"&light .cm-gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#6c6c6c\",\n        borderRight: \"1px solid #ddd\"\n    },\n    \"&dark .cm-gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    \".cm-gutter\": {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        overflow: \"hidden\"\n    },\n    \".cm-gutterElement\": {\n        boxSizing: \"border-box\"\n    },\n    \".cm-lineNumbers .cm-gutterElement\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    },\n    \"&light .cm-activeLineGutter\": {\n        backgroundColor: \"#e2f2ff\"\n    },\n    \"&dark .cm-activeLineGutter\": {\n        backgroundColor: \"#222227\"\n    },\n    \".cm-panels\": {\n        boxSizing: \"border-box\",\n        position: \"sticky\",\n        left: 0,\n        right: 0\n    },\n    \"&light .cm-panels\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"black\"\n    },\n    \"&light .cm-panels-top\": {\n        borderBottom: \"1px solid #ddd\"\n    },\n    \"&light .cm-panels-bottom\": {\n        borderTop: \"1px solid #ddd\"\n    },\n    \"&dark .cm-panels\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tab\": {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    },\n    \".cm-widgetBuffer\": {\n        verticalAlign: \"text-top\",\n        height: \"1em\",\n        width: 0,\n        display: \"inline\"\n    },\n    \".cm-placeholder\": {\n        color: \"#888\",\n        display: \"inline-block\",\n        verticalAlign: \"top\"\n    },\n    \".cm-highlightSpace:before\": {\n        content: \"attr(data-display)\",\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        color: \"#888\"\n    },\n    \".cm-highlightTab\": {\n        backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\n        backgroundSize: \"auto 100%\",\n        backgroundPosition: \"right 90%\",\n        backgroundRepeat: \"no-repeat\"\n    },\n    \".cm-trailingSpace\": {\n        backgroundColor: \"#ff332255\"\n    },\n    \".cm-button\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        padding: \".2em 1em\",\n        borderRadius: \"1px\"\n    },\n    \"&light .cm-button\": {\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n        }\n    },\n    \"&dark .cm-button\": {\n        backgroundImage: \"linear-gradient(#393939, #111)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#111, #333)\"\n        }\n    },\n    \".cm-textfield\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        border: \"1px solid silver\",\n        padding: \".2em .5em\"\n    },\n    \"&light .cm-textfield\": {\n        backgroundColor: \"white\"\n    },\n    \"&dark .cm-textfield\": {\n        border: \"1px solid #555\",\n        backgroundColor: \"inherit\"\n    }\n}, lightDarkIDs);\nconst LineBreakPlaceholder = \"￿\";\nclass DOMReader {\n    constructor(points, state){\n        this.points = points;\n        this.text = \"\";\n        this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.lineSeparator);\n    }\n    append(text) {\n        this.text += text;\n    }\n    lineBreak() {\n        this.text += LineBreakPlaceholder;\n    }\n    readRange(start, end) {\n        if (!start) return this;\n        let parent = start.parentNode;\n        for(let cur = start;;){\n            this.findPointBefore(parent, cur);\n            let oldLen = this.text.length;\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end) break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore) && this.text.length > oldLen) this.lineBreak();\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n        return this;\n    }\n    readTextNode(node) {\n        let text = node.nodeValue;\n        for (let point of this.points)if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);\n        for(let off = 0, re = this.lineSeparator ? null : /\\r\\n?|\\n/g;;){\n            let nextBreak = -1, breakSize = 1, m;\n            if (this.lineSeparator) {\n                nextBreak = text.indexOf(this.lineSeparator, off);\n                breakSize = this.lineSeparator.length;\n            } else if (m = re.exec(text)) {\n                nextBreak = m.index;\n                breakSize = m[0].length;\n            }\n            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));\n            if (nextBreak < 0) break;\n            this.lineBreak();\n            if (breakSize > 1) {\n                for (let point of this.points)if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;\n            }\n            off = nextBreak + breakSize;\n        }\n    }\n    readNode(node) {\n        if (node.cmIgnore) return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        if (fromView != null) {\n            this.findPointInside(node, fromView.length);\n            for(let i = fromView.iter(); !i.next().done;){\n                if (i.lineBreak) this.lineBreak();\n                else this.append(i.value);\n            }\n        } else if (node.nodeType == 3) {\n            this.readTextNode(node);\n        } else if (node.nodeName == \"BR\") {\n            if (node.nextSibling) this.lineBreak();\n        } else if (node.nodeType == 1) {\n            this.readRange(node.firstChild, null);\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;\n    }\n    findPointInside(node, length) {\n        for (let point of this.points)if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);\n    }\n}\nfunction isAtEnd(parent, node, offset) {\n    for(;;){\n        if (!node || offset < maxOffset(node)) return false;\n        if (node == parent) return true;\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nclass DOMPoint {\n    constructor(node, offset){\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nclass DOMChange {\n    constructor(view, start, end, typeOver){\n        this.typeOver = typeOver;\n        this.bounds = null;\n        this.text = \"\";\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        if (view.state.readOnly && start > -1) {\n            // Ignore changes when the editor is read-only\n            this.newSel = null;\n        } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {\n            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);\n            let reader = new DOMReader(selPoints, view.state);\n            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);\n            this.text = reader.text;\n            this.newSel = selectionFromPoints(selPoints, this.bounds.from);\n        } else {\n            let domSel = view.observer.selectionRange;\n            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n            // iOS will refuse to select the block gaps when doing\n            // select-all.\n            // Chrome will put the selection *inside* them, confusing\n            // posFromDOM\n            let vp = view.viewport;\n            if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {\n                let from = Math.min(head, anchor), to = Math.max(head, anchor);\n                let offFrom = vp.from - from, offTo = vp.to - to;\n                if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {\n                    head = 0;\n                    anchor = view.state.doc.length;\n                }\n            }\n            this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor, head);\n        }\n    }\n}\nfunction applyDOMChange(view, domChange) {\n    let change;\n    let { newSel } = domChange, sel = view.state.selection.main;\n    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;\n    if (domChange.bounds) {\n        let { from, to } = domChange.bounds;\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed (or, on\n        // Android, when something was deleted)\n        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);\n        if (diff) {\n            // Chrome inserts two newlines when pressing shift-enter at the\n            // end of a line. DomChange drops one of those.\n            if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;\n            change = {\n                from: from + diff.from,\n                to: from + diff.toA,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))\n            };\n        }\n    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {\n        newSel = null;\n    }\n    if (!change && !newSel) return false;\n    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {\n        // Heuristic to notice typing over a selected character\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, sel.to)\n        };\n    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {\n        // If the change is inside the selection and covers most of it,\n        // assume it is a selection replace (with identical characters at\n        // the start/end not included in the diff)\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n        };\n    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") {\n        // Detect insert-period-on-double-space Mac and Android behavior,\n        // and transform it into a regular space insert.\n        if (newSel && change.insert.length == 2) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\n                \" \"\n            ])\n        };\n    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == \"\\n \" && view.lineWrapping) {\n        // In Chrome, if you insert a space at the start of a wrapped\n        // line, it will actually insert a newline and a space, causing a\n        // bogus new line to be created in CodeMirror (#968)\n        if (newSel) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\n                \" \"\n            ])\n        };\n    }\n    if (change) {\n        if (browser.ios && view.inputState.flushIOSKey()) return true;\n        // Android browsers don't fire reasonable key events for enter,\n        // backspace, or delete. So this detects changes that look like\n        // they're caused by those keys, and reinterprets them as key\n        // events. (Some of these keys are also handled by beforeinput\n        // events and the pendingAndroidKey mechanism, but that's not\n        // reliable in all situations.)\n        if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, \"Enter\", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, \"Backspace\", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Delete\", 46))) return true;\n        let text = change.insert.toString();\n        if (view.inputState.composing >= 0) view.inputState.composing++;\n        let defaultTr;\n        let defaultInsert = ()=>defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));\n        if (!view.state.facet(inputHandler).some((h)=>h(view, change.from, change.to, text, defaultInsert))) view.dispatch(defaultInsert());\n        return true;\n    } else if (newSel && !newSel.main.eq(sel)) {\n        let scrollIntoView = false, userEvent = \"select\";\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"select\") scrollIntoView = true;\n            userEvent = view.inputState.lastSelectionOrigin;\n        }\n        view.dispatch({\n            selection: newSel,\n            scrollIntoView,\n            userEvent\n        });\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction applyDefaultInsert(view, change, newSel) {\n    let tr, startState = view.state, sel = startState.selection.main;\n    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {\n        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n    } else {\n        let changes = startState.changes(change);\n        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;\n        // Try to apply a composition change to all cursors\n        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {\n            let replaced = view.state.sliceDoc(change.from, change.to);\n            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);\n            if (composition) {\n                let dLen = change.insert.length - (change.to - change.from);\n                compositionRange = {\n                    from: composition.from,\n                    to: composition.to - dLen\n                };\n            } else {\n                compositionRange = view.state.doc.lineAt(sel.head);\n            }\n            let offset = sel.to - change.to, size = sel.to - sel.from;\n            tr = startState.changeByRange((range)=>{\n                if (range.from == sel.from && range.to == sel.to) return {\n                    changes,\n                    range: mainSel || range.map(changes)\n                };\n                let to = range.to - offset, from = to - replaced.length;\n                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple\n                // changes in the same node work without aborting\n                // composition, so cursors in the composition range are\n                // ignored.\n                range.to >= compositionRange.from && range.from <= compositionRange.to) return {\n                    range\n                };\n                let rangeChanges = startState.changes({\n                    from,\n                    to,\n                    insert: change.insert\n                }), selOff = range.to - sel.to;\n                return {\n                    changes: rangeChanges,\n                    range: !mainSel ? range.map(rangeChanges) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\n                };\n            });\n        } else {\n            tr = {\n                changes,\n                selection: mainSel && startState.selection.replaceRange(mainSel)\n            };\n        }\n    }\n    let userEvent = \"input.type\";\n    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {\n        view.inputState.compositionPendingChange = false;\n        userEvent += \".compose\";\n        if (view.inputState.compositionFirstChange) {\n            userEvent += \".start\";\n            view.inputState.compositionFirstChange = false;\n        }\n    }\n    return startState.update(tr, {\n        userEvent,\n        scrollIntoView: true\n    });\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while(from < minLen && a.charCodeAt(from) == b.charCodeAt(from))from++;\n    if (from == minLen && a.length == b.length) return null;\n    let toA = a.length, toB = b.length;\n    while(toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)){\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    } else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return {\n        from,\n        toA,\n        toB\n    };\n}\nfunction selectionPoints(view) {\n    let result = [];\n    if (view.root.activeElement != view.contentDOM) return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0) return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor + base, head + base) : null;\n}\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    attributes: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view){\n        this.view = view;\n        this.active = false;\n        // The known selection. Kept in our own object, as opposed to just\n        // directly accessing the selection because:\n        //  - Safari doesn't report the right selection in shadow DOM\n        //  - Reading from the selection forces a DOM layout\n        //  - This way, we can ignore selectionchange events if we have\n        //    already seen the 'new' selection\n        this.selectionRange = new DOMSelectionState;\n        // Set when a selection change is detected, cleared on flush\n        this.selectionChanged = false;\n        this.delayedFlush = -1;\n        this.resizeTimeout = -1;\n        this.queue = [];\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n        this.lastChange = 0;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.resizeScroll = null;\n        this.intersecting = false;\n        this.gapIntersection = null;\n        this.gaps = [];\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver((mutations)=>{\n            for (let mut of mutations)this.queue.push(mut);\n            // IE11 will sometimes (on typing over a selection or\n            // backspacing out a single character text node) call the\n            // observer callback before actually updating the DOM.\n            //\n            // Unrelatedly, iOS Safari will, when ending a composition,\n            // sometimes first clear it, deliver the mutations, and then\n            // reinsert the finished text. CodeMirror's handling of the\n            // deletion will prevent the reinsertion from happening,\n            // breaking composition.\n            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();\n            else this.flush();\n        });\n        if (useCharData) this.onCharData = (event)=>{\n            this.queue.push({\n                target: event.target,\n                type: \"characterData\",\n                oldValue: event.prevValue\n            });\n            this.flushSoon();\n        };\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n        this.onResize = this.onResize.bind(this);\n        this.onPrint = this.onPrint.bind(this);\n        this.onScroll = this.onScroll.bind(this);\n        if (typeof ResizeObserver == \"function\") {\n            this.resizeScroll = new ResizeObserver(()=>{\n                var _a;\n                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75) this.onResize();\n            });\n            this.resizeScroll.observe(view.scrollDOM);\n        }\n        this.addWindowListeners(this.win = view.win);\n        this.start();\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver((entries)=>{\n                if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent(\"Event\"));\n                }\n            }, {\n                threshold: [\n                    0,\n                    .001\n                ]\n            });\n            this.intersection.observe(this.dom);\n            this.gapIntersection = new IntersectionObserver((entries)=>{\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent(\"Event\"));\n            }, {});\n        }\n        this.listenForScroll();\n        this.readSelectionRange();\n    }\n    onScrollChanged(e) {\n        this.view.inputState.runHandlers(\"scroll\", e);\n        if (this.intersecting) this.view.measure();\n    }\n    onScroll(e) {\n        if (this.intersecting) this.flush(false);\n        this.onScrollChanged(e);\n    }\n    onResize() {\n        if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(()=>{\n            this.resizeTimeout = -1;\n            this.view.requestMeasure();\n        }, 50);\n    }\n    onPrint() {\n        this.view.viewState.printing = true;\n        this.view.measure();\n        setTimeout(()=>{\n            this.view.viewState.printing = false;\n            this.view.requestMeasure();\n        }, 500);\n    }\n    updateGaps(gaps) {\n        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i)=>g != gaps[i]))) {\n            this.gapIntersection.disconnect();\n            for (let gap of gaps)this.gapIntersection.observe(gap);\n            this.gaps = gaps;\n        }\n    }\n    onSelectionChange(event) {\n        let wasChanged = this.selectionChanged;\n        if (!this.readSelectionRange() || this.delayedAndroidKey) return;\n        let { view } = this, sel = this.selectionRange;\n        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;\n        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n        if (context && context.ignoreEvent(event)) {\n            if (!wasChanged) this.selectionChanged = false;\n            return;\n        }\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        // Chrome Android has a similar issue when backspacing out a\n        // selection (#645).\n        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)\n        sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();\n        else this.flush(false);\n    }\n    readSelectionRange() {\n        let { view } = this;\n        // The Selection object is broken in shadow roots in Safari. See\n        // https://github.com/codemirror/dev/issues/414\n        let range = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);\n        if (!range || this.selectionRange.eq(range)) return false;\n        let local = hasSelection(this.dom, range);\n        // Detect the situation where the browser has, on focus, moved the\n        // selection to the start of the content element. Reset it to the\n        // position from the editor state.\n        if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {\n            this.view.inputState.lastFocusTime = 0;\n            view.docView.updateSelection();\n            return false;\n        }\n        this.selectionRange.setRange(range);\n        if (local) this.selectionChanged = true;\n        return true;\n    }\n    setSelectionRange(anchor, head) {\n        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\n        this.selectionChanged = false;\n    }\n    clearSelectionRange() {\n        this.selectionRange.set(null, 0, null, 0);\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for(let dom = this.dom; dom;){\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;\n                else if (!changed) changed = this.scrollTargets.slice(0, i);\n                if (changed) changed.push(dom);\n                dom = dom.assignedSlot || dom.parentNode;\n            } else if (dom.nodeType == 11) {\n                dom = dom.host;\n            } else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active) return f();\n        try {\n            this.stop();\n            return f();\n        } finally{\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active) return;\n        this.observer.observe(this.dom, observeOptions);\n        if (useCharData) this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active) return;\n        this.active = false;\n        this.observer.disconnect();\n        if (useCharData) this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    // Throw away any pending changes\n    clear() {\n        this.processRecords();\n        this.queue.length = 0;\n        this.selectionChanged = false;\n    }\n    // Chrome Android, especially in combination with GBoard, not only\n    // doesn't reliably fire regular key events, but also often\n    // surrounds the effect of enter or backspace with a bunch of\n    // composition events that, when interrupted, cause text duplication\n    // or other kinds of corruption. This hack makes the editor back off\n    // from handling DOM changes for a moment when such a key is\n    // detected (via beforeinput or keydown), and then tries to flush\n    // them or, if that has no effect, dispatches the given key.\n    delayAndroidKey(key, keyCode) {\n        var _a;\n        if (!this.delayedAndroidKey) {\n            let flush = ()=>{\n                let key = this.delayedAndroidKey;\n                if (key) {\n                    this.clearDelayedAndroidKey();\n                    this.view.inputState.lastKeyCode = key.keyCode;\n                    this.view.inputState.lastKeyTime = Date.now();\n                    let flushed = this.flush();\n                    if (!flushed && key.force) dispatchKey(this.dom, key.key, key.keyCode);\n                }\n            };\n            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);\n        }\n        // Since backspace beforeinput is sometimes signalled spuriously,\n        // Enter always takes precedence.\n        if (!this.delayedAndroidKey || key == \"Enter\") this.delayedAndroidKey = {\n            key,\n            keyCode,\n            // Only run the key handler when no changes are detected if\n            // this isn't coming right after another change, in which case\n            // it is probably part of a weird chain of updates, and should\n            // be ignored if it returns the DOM to its previous state.\n            force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)\n        };\n    }\n    clearDelayedAndroidKey() {\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n    }\n    flushSoon() {\n        if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(()=>{\n            this.delayedFlush = -1;\n            this.flush();\n        });\n    }\n    forceFlush() {\n        if (this.delayedFlush >= 0) {\n            this.view.win.cancelAnimationFrame(this.delayedFlush);\n            this.delayedFlush = -1;\n        }\n        this.flush();\n    }\n    pendingRecords() {\n        for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    processRecords() {\n        let records = this.pendingRecords();\n        if (records.length) this.queue = [];\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records){\n            let range = this.readMutation(record);\n            if (!range) continue;\n            if (range.typeOver) typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            } else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        return {\n            from,\n            to,\n            typeOver\n        };\n    }\n    readChange() {\n        let { from, to, typeOver } = this.processRecords();\n        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\n        if (from < 0 && !newSel) return null;\n        if (from > -1) this.lastChange = Date.now();\n        this.view.inputState.lastFocusTime = 0;\n        this.selectionChanged = false;\n        let change = new DOMChange(this.view, from, to, typeOver);\n        this.view.docView.domChanged = {\n            newSel: change.newSel ? change.newSel.main : null\n        };\n        return change;\n    }\n    // Apply pending changes, if any\n    flush(readSelection = true) {\n        // Completely hold off flushing when pending keys are set—the code\n        // managing those will make sure processRecords is called and the\n        // view is resynchronized after\n        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;\n        if (readSelection) this.readSelectionRange();\n        let domChange = this.readChange();\n        if (!domChange) {\n            this.view.requestMeasure();\n            return false;\n        }\n        let startState = this.view.state;\n        let handled = applyDOMChange(this.view, domChange);\n        // The view wasn't updated\n        if (this.view.state == startState) this.view.update([]);\n        return handled;\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec)) return null;\n        cView.markDirty(rec.type == \"attributes\");\n        if (rec.type == \"attributes\") cView.flags |= 4 /* ViewFlag.AttrsDirty */ ;\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return {\n                from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,\n                typeOver: false\n            };\n        } else if (rec.type == \"characterData\") {\n            return {\n                from: cView.posAtStart,\n                to: cView.posAtEnd,\n                typeOver: rec.target.nodeValue == rec.oldValue\n            };\n        } else {\n            return null;\n        }\n    }\n    setWindow(win) {\n        if (win != this.win) {\n            this.removeWindowListeners(this.win);\n            this.win = win;\n            this.addWindowListeners(this.win);\n        }\n    }\n    addWindowListeners(win) {\n        win.addEventListener(\"resize\", this.onResize);\n        win.addEventListener(\"beforeprint\", this.onPrint);\n        win.addEventListener(\"scroll\", this.onScroll);\n        win.document.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    removeWindowListeners(win) {\n        win.removeEventListener(\"scroll\", this.onScroll);\n        win.removeEventListener(\"resize\", this.onResize);\n        win.removeEventListener(\"beforeprint\", this.onPrint);\n        win.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.stop();\n        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();\n        for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n        this.removeWindowListeners(this.win);\n        clearTimeout(this.parentCheck);\n        clearTimeout(this.resizeTimeout);\n        this.win.cancelAnimationFrame(this.delayedFlush);\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while(dom){\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView) return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\n// Used to work around a Safari Selection/shadow DOM bug (#414)\nfunction safariSelectionRangeHack(view) {\n    let found = null;\n    // Because Safari (at least in 2018-2021) doesn't provide regular\n    // access to the selection inside a shadowroot, we have to perform a\n    // ridiculous hack to get at it—using `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    view.contentDOM.addEventListener(\"beforeinput\", read, true);\n    view.dom.ownerDocument.execCommand(\"indent\");\n    view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n    if (!found) return null;\n    let anchorNode = found.startContainer, anchorOffset = found.startOffset;\n    let focusNode = found.endContainer, focusOffset = found.endOffset;\n    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// The editor's update state machine looks something like this:\n//\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\n//                                         ↑      ↓\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/ class EditorView {\n    /**\n    The current editor state.\n    */ get state() {\n        return this.viewState.state;\n    }\n    /**\n    To be able to display large documents without consuming too much\n    memory or overloading the browser, CodeMirror only draws the\n    code that is visible (plus a margin around it) to the DOM. This\n    property tells you the extent of the current drawn viewport, in\n    document positions.\n    */ get viewport() {\n        return this.viewState.viewport;\n    }\n    /**\n    When there are, for example, large collapsed ranges in the\n    viewport, its size can be a lot bigger than the actual visible\n    content. Thus, if you are doing something like styling the\n    content in the viewport, it is preferable to only do so for\n    these ranges, which are the subset of the viewport that is\n    actually drawn.\n    */ get visibleRanges() {\n        return this.viewState.visibleRanges;\n    }\n    /**\n    Returns false when the editor is entirely scrolled out of view\n    or otherwise hidden.\n    */ get inView() {\n        return this.viewState.inView;\n    }\n    /**\n    Indicates whether the user is currently composing text via\n    [IME](https://en.wikipedia.org/wiki/Input_method), and at least\n    one change has been made in the current composition.\n    */ get composing() {\n        return this.inputState.composing > 0;\n    }\n    /**\n    Indicates whether the user is currently in composing state. Note\n    that on some platforms, like Android, this will be the case a\n    lot, since just putting the cursor on a word starts a\n    composition there.\n    */ get compositionStarted() {\n        return this.inputState.composing >= 0;\n    }\n    /**\n    The document or shadow root that the view lives in.\n    */ get root() {\n        return this._root;\n    }\n    /**\n    @internal\n    */ get win() {\n        return this.dom.ownerDocument.defaultView || window;\n    }\n    /**\n    Construct a new view. You'll want to either provide a `parent`\n    option, or put `view.dom` into your document after creating a\n    view, so that the user can see the editor.\n    */ constructor(config = {}){\n        this.plugins = [];\n        this.pluginMap = new Map;\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.bidiCache = [];\n        this.destroyed = false;\n        /**\n        @internal\n        */ this.updateState = 2 /* UpdateState.Updating */ ;\n        /**\n        @internal\n        */ this.measureScheduled = -1;\n        /**\n        @internal\n        */ this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.tabIndex = -1;\n        this.scrollDOM.className = \"cm-scroller\";\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.announceDOM = document.createElement(\"div\");\n        this.announceDOM.className = \"cm-announced\";\n        this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.announceDOM);\n        this.dom.appendChild(this.scrollDOM);\n        if (config.parent) config.parent.appendChild(this.dom);\n        let { dispatch } = config;\n        this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs)=>trs.forEach((tr)=>dispatch(tr, this))) || ((trs)=>this.update(trs));\n        this.dispatch = this.dispatch.bind(this);\n        this._root = config.root || getRoot(config.parent) || document;\n        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create(config));\n        if (config.scrollTo && config.scrollTo.is(scrollIntoView)) this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);\n        this.plugins = this.state.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n        for (let plugin of this.plugins)plugin.update(this);\n        this.observer = new DOMObserver(this);\n        this.inputState = new InputState(this);\n        this.inputState.ensureHandlers(this.plugins);\n        this.docView = new DocView(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* UpdateState.Idle */ ;\n        this.requestMeasure();\n    }\n    dispatch(...input) {\n        let trs = input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [\n            this.state.update(...input)\n        ];\n        this.dispatchTransactions(trs, this);\n    }\n    /**\n    Update the view for the given array of transactions. This will\n    update the visible document and selection to match the state\n    produced by the transactions, and notify view plugins of the\n    change. You should usually call\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n    as a primitive.\n    */ update(transactions) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        let redrawn = false, attrsChanged = false, update;\n        let state = this.state;\n        for (let tr of transactions){\n            if (tr.startState != state) throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n            state = tr.state;\n        }\n        if (this.destroyed) {\n            this.viewState.state = state;\n            return;\n        }\n        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;\n        if (transactions.some((tr)=>tr.annotation(isFocusChange))) {\n            this.inputState.notifiedFocused = focus;\n            // If a focus-change transaction is being dispatched, set this update flag.\n            focusFlag = 1 /* UpdateFlag.Focus */ ;\n        } else if (focus != this.inputState.notifiedFocused) {\n            this.inputState.notifiedFocused = focus;\n            // Schedule a separate focus transaction if necessary, otherwise\n            // add a flag to this update\n            dispatchFocus = focusChangeTransaction(state, focus);\n            if (!dispatchFocus) focusFlag = 1 /* UpdateFlag.Focus */ ;\n        }\n        // If there was a pending DOM change, eagerly read it and try to\n        // apply it after the given transactions.\n        let pendingKey = this.observer.delayedAndroidKey, domChange = null;\n        if (pendingKey) {\n            this.observer.clearDelayedAndroidKey();\n            domChange = this.observer.readChange();\n            // Only try to apply DOM changes if the transactions didn't\n            // change the doc or selection.\n            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;\n        } else {\n            this.observer.clear();\n        }\n        // When the phrases change, redraw the editor\n        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases)) return this.setState(state);\n        update = ViewUpdate.create(this, state, transactions);\n        update.flags |= focusFlag;\n        let scrollTarget = this.viewState.scrollTarget;\n        try {\n            this.updateState = 2 /* UpdateState.Updating */ ;\n            for (let tr of transactions){\n                if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);\n                if (tr.scrollIntoView) {\n                    let { main } = tr.state.selection;\n                    scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\n                }\n                for (let e of tr.effects)if (e.is(scrollIntoView)) scrollTarget = e.value.clip(this.state);\n            }\n            this.viewState.update(update, scrollTarget);\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n            if (!update.empty) {\n                this.updatePlugins(update);\n                this.inputState.update(update);\n            }\n            redrawn = this.docView.update(update);\n            if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();\n            attrsChanged = this.updateAttrs();\n            this.showAnnouncements(transactions);\n            this.docView.updateSelection(redrawn, transactions.some((tr)=>tr.isUserEvent(\"select.pointer\")));\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;\n        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();\n        if (!update.empty) for (let listener of this.state.facet(updateListener)){\n            try {\n                listener(update);\n            } catch (e) {\n                logException(this.state, e, \"update listener\");\n            }\n        }\n        if (dispatchFocus || domChange) Promise.resolve().then(()=>{\n            if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus);\n            if (domChange) {\n                if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);\n            }\n        });\n    }\n    /**\n    Reset the view to the given state. (This will cause the entire\n    document to be redrawn and all view plugins to be reinitialized,\n    so you should probably only use it when the new state isn't\n    derived from the old state. Otherwise, use\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n    */ setState(newState) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n        if (this.destroyed) {\n            this.viewState.state = newState;\n            return;\n        }\n        this.updateState = 2 /* UpdateState.Updating */ ;\n        let hadFocus = this.hasFocus;\n        try {\n            for (let plugin of this.plugins)plugin.destroy(this);\n            this.viewState = new ViewState(newState);\n            this.plugins = newState.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n            this.pluginMap.clear();\n            for (let plugin of this.plugins)plugin.update(this);\n            this.docView.destroy();\n            this.docView = new DocView(this);\n            this.inputState.ensureHandlers(this.plugins);\n            this.mountStyles();\n            this.updateAttrs();\n            this.bidiCache = [];\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (hadFocus) this.focus();\n        this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [];\n            for (let spec of specs){\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(new PluginInstance(spec));\n                } else {\n                    let plugin = this.plugins[found];\n                    plugin.mustUpdate = update;\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)if (plugin.mustUpdate != update) plugin.destroy(this);\n            this.plugins = newPlugins;\n            this.pluginMap.clear();\n        } else {\n            for (let p of this.plugins)p.mustUpdate = update;\n        }\n        for(let i = 0; i < this.plugins.length; i++)this.plugins[i].update(this);\n        if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);\n    }\n    /**\n    @internal\n    */ measure(flush = true) {\n        if (this.destroyed) return;\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        if (this.observer.delayedAndroidKey) {\n            this.measureScheduled = -1;\n            this.requestMeasure();\n            return;\n        }\n        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\n        if (flush) this.observer.forceFlush();\n        let updated = null;\n        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;\n        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;\n        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;\n        this.viewState.scrollAnchorHeight = -1;\n        try {\n            for(let i = 0;; i++){\n                if (scrollAnchorHeight < 0) {\n                    if (isScrolledToBottom(sDOM)) {\n                        scrollAnchorPos = -1;\n                        scrollAnchorHeight = this.viewState.heightMap.height;\n                    } else {\n                        let block = this.viewState.scrollAnchorAt(scrollTop);\n                        scrollAnchorPos = block.from;\n                        scrollAnchorHeight = block.top;\n                    }\n                }\n                this.updateState = 1 /* UpdateState.Measuring */ ;\n                let changed = this.viewState.measure(this);\n                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;\n                if (i > 5) {\n                    console.warn(this.measureRequests.length ? \"Measure loop restarted more than 5 times\" : \"Viewport failed to stabilize\");\n                    break;\n                }\n                let measuring = [];\n                // Only run measure requests in this cycle when the viewport didn't change\n                if (!(changed & 4 /* UpdateFlag.Viewport */ )) [this.measureRequests, measuring] = [\n                    measuring,\n                    this.measureRequests\n                ];\n                let measured = measuring.map((m)=>{\n                    try {\n                        return m.read(this);\n                    } catch (e) {\n                        logException(this.state, e);\n                        return BadMeasure;\n                    }\n                });\n                let update = ViewUpdate.create(this, this.state, []), redrawn = false;\n                update.flags |= changed;\n                if (!updated) updated = update;\n                else updated.flags |= changed;\n                this.updateState = 2 /* UpdateState.Updating */ ;\n                if (!update.empty) {\n                    this.updatePlugins(update);\n                    this.inputState.update(update);\n                    this.updateAttrs();\n                    redrawn = this.docView.update(update);\n                }\n                for(let i = 0; i < measuring.length; i++)if (measured[i] != BadMeasure) {\n                    try {\n                        let m = measuring[i];\n                        if (m.write) m.write(measured[i], this);\n                    } catch (e) {\n                        logException(this.state, e);\n                    }\n                }\n                if (redrawn) this.docView.updateSelection(true);\n                if (!update.viewportChanged && this.measureRequests.length == 0) {\n                    if (this.viewState.editorHeight) {\n                        if (this.viewState.scrollTarget) {\n                            this.docView.scrollIntoView(this.viewState.scrollTarget);\n                            this.viewState.scrollTarget = null;\n                            scrollAnchorHeight = -1;\n                            continue;\n                        } else {\n                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;\n                            let diff = newAnchorHeight - scrollAnchorHeight;\n                            if (diff > 1 || diff < -1) {\n                                scrollTop = scrollTop + diff;\n                                sDOM.scrollTop = scrollTop / this.scaleY;\n                                scrollAnchorHeight = -1;\n                                continue;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n            this.measureScheduled = -1;\n        }\n        if (updated && !updated.empty) for (let listener of this.state.facet(updateListener))listener(updated);\n    }\n    /**\n    Get the CSS classes for the currently active editor themes.\n    */ get themeClasses() {\n        return baseThemeID + \" \" + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" + this.state.facet(theme);\n    }\n    updateAttrs() {\n        let editorAttrs = attrsFromFacet(this, editorAttributes, {\n            class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n        });\n        let contentAttrs = {\n            spellcheck: \"false\",\n            autocorrect: \"off\",\n            autocapitalize: \"off\",\n            translate: \"no\",\n            contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\n            class: \"cm-content\",\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\n            role: \"textbox\",\n            \"aria-multiline\": \"true\"\n        };\n        if (this.state.readOnly) contentAttrs[\"aria-readonly\"] = \"true\";\n        attrsFromFacet(this, contentAttributes, contentAttrs);\n        let changed = this.observer.ignore(()=>{\n            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n            return changedContent || changedEditor;\n        });\n        this.editorAttrs = editorAttrs;\n        this.contentAttrs = contentAttrs;\n        return changed;\n    }\n    showAnnouncements(trs) {\n        let first = true;\n        for (let tr of trs)for (let effect of tr.effects)if (effect.is(EditorView.announce)) {\n            if (first) this.announceDOM.textContent = \"\";\n            first = false;\n            let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n            div.textContent = effect.value;\n        }\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        let nonce = this.state.facet(EditorView.cspNonce);\n        style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? {\n            nonce\n        } : undefined);\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* UpdateState.Updating */ ) throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* UpdateState.Idle */  && this.measureScheduled > -1) this.measure(false);\n    }\n    /**\n    Schedule a layout measurement, optionally providing callbacks to\n    do custom DOM measuring followed by a DOM write phase. Using\n    this is preferable reading DOM layout directly from, for\n    example, an event handler, because it'll make sure measuring and\n    drawing done by other components is synchronized, avoiding\n    unnecessary DOM layout computations.\n    */ requestMeasure(request) {\n        if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(()=>this.measure());\n        if (request) {\n            if (this.measureRequests.indexOf(request) > -1) return;\n            if (request.key != null) for(let i = 0; i < this.measureRequests.length; i++){\n                if (this.measureRequests[i].key === request.key) {\n                    this.measureRequests[i] = request;\n                    return;\n                }\n            }\n            this.measureRequests.push(request);\n        }\n    }\n    /**\n    Get the value of a specific plugin, if present. Note that\n    plugins that crash can be dropped from a view, so even when you\n    know you registered a given plugin, it is recommended to check\n    the return value of this method.\n    */ plugin(plugin) {\n        let known = this.pluginMap.get(plugin);\n        if (known === undefined || known && known.spec != plugin) this.pluginMap.set(plugin, known = this.plugins.find((p)=>p.spec == plugin) || null);\n        return known && known.update(this).value;\n    }\n    /**\n    The top position of the document, in screen coordinates. This\n    may be negative when the editor is scrolled down. Points\n    directly to the top of the first line, not above the padding.\n    */ get documentTop() {\n        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n    }\n    /**\n    Reports the padding above and below the document.\n    */ get documentPadding() {\n        return {\n            top: this.viewState.paddingTop,\n            bottom: this.viewState.paddingBottom\n        };\n    }\n    /**\n    If the editor is transformed with CSS, this provides the scale\n    along the X axis. Otherwise, it will just be 1. Note that\n    transforms other than translation and scaling are not supported.\n    */ get scaleX() {\n        return this.viewState.scaleX;\n    }\n    /**\n    Provide the CSS transformed scale along the Y axis.\n    */ get scaleY() {\n        return this.viewState.scaleY;\n    }\n    /**\n    Find the text line or block widget at the given vertical\n    position (which is interpreted as relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\n    */ elementAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.elementAtHeight(height);\n    }\n    /**\n    Find the line block (see\n    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given\n    height, again interpreted relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\n    */ lineBlockAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.lineBlockAtHeight(height);\n    }\n    /**\n    Get the extent and vertical position of all [line\n    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n    are relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n    */ get viewportLineBlocks() {\n        return this.viewState.viewportLines;\n    }\n    /**\n    Find the line block around the given document position. A line\n    block is a range delimited on both sides by either a\n    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the\n    start/end of the document. It will usually just hold a line of\n    text, but may be broken into multiple textblocks by block\n    widgets.\n    */ lineBlockAt(pos) {\n        return this.viewState.lineBlockAt(pos);\n    }\n    /**\n    The editor's total content height.\n    */ get contentHeight() {\n        return this.viewState.contentHeight;\n    }\n    /**\n    Move a cursor position by [grapheme\n    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\n    the motion is away from the line start, or towards it. In\n    bidirectional text, the line is traversed in visual order, using\n    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n    When the start position was the last one on the line, the\n    returned position will be across the line break. If there is no\n    further line, the original position is returned.\n    \n    By default, this method moves over a single cluster. The\n    optional `by` argument can be used to move across more. It will\n    be called with the first cluster as argument, and should return\n    a predicate that determines, for each subsequent cluster,\n    whether it should also be moved over.\n    */ moveByChar(start, forward, by) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, by));\n    }\n    /**\n    Move a cursor position across the next group of either\n    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n    non-whitespace characters.\n    */ moveByGroup(start, forward) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, (initial)=>byGroup(this, start.head, initial)));\n    }\n    /**\n    Get the cursor position visually at the start or end of a line.\n    Note that this may differ from the _logical_ position at its\n    start or end (which is simply at `line.from`/`line.to`) if text\n    at the start or end goes against the line's base text direction.\n    */ visualLineSide(line, end) {\n        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);\n        let span = order[end ? order.length - 1 : 0];\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);\n    }\n    /**\n    Move to the next line boundary in the given direction. If\n    `includeWrap` is true, line wrapping is on, and there is a\n    further wrap point on the current line, the wrap point will be\n    returned. Otherwise this function will return the start or end\n    of the line.\n    */ moveToLineBoundary(start, forward, includeWrap = true) {\n        return moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /**\n    Move a cursor position vertically. When `distance` isn't given,\n    it defaults to moving to the next line (including wrapped\n    lines). Otherwise, `distance` should provide a positive distance\n    in pixels.\n    \n    When `start` has a\n    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n    motion will use that as a target horizontal position. Otherwise,\n    the cursor's own horizontal position is used. The returned\n    cursor will have its goal column set to whichever column was\n    used.\n    */ moveVertically(start, forward, distance) {\n        return skipAtoms(this, start, moveVertically(this, start, forward, distance));\n    }\n    /**\n    Find the DOM parent node and offset (child offset if `node` is\n    an element, character offset when it is a text node) at the\n    given document position.\n    \n    Note that for positions that aren't currently in\n    `visibleRanges`, the resulting DOM position isn't necessarily\n    meaningful (it may just point before or after a placeholder\n    element).\n    */ domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /**\n    Find the document position at the given DOM node. Can be useful\n    for associating positions with DOM events. Will raise an error\n    when `node` isn't part of the editor content.\n    */ posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    posAtCoords(coords, precise = true) {\n        this.readMeasured();\n        return posAtCoords(this, coords, precise);\n    }\n    /**\n    Get the screen coordinates at the given document position.\n    `side` determines whether the coordinates are based on the\n    element before (-1) or after (1) the position (if no element is\n    available on the given side, the method will transparently use\n    another strategy to get reasonable coordinates).\n    */ coordsAtPos(pos, side = 1) {\n        this.readMeasured();\n        let rect = this.docView.coordsAt(pos, side);\n        if (!rect || rect.left == rect.right) return rect;\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n        return flattenRect(rect, span.dir == Direction.LTR == side > 0);\n    }\n    /**\n    Return the rectangle around a given character. If `pos` does not\n    point in front of a character that is in the viewport and\n    rendered (i.e. not replaced, not a line break), this will return\n    null. For space characters that are a line wrap point, this will\n    return the position before the line break.\n    */ coordsForChar(pos) {\n        this.readMeasured();\n        return this.docView.coordsForChar(pos);\n    }\n    /**\n    The default width of a character in the editor. May not\n    accurately reflect the width of all characters (given variable\n    width fonts or styling of invididual ranges).\n    */ get defaultCharacterWidth() {\n        return this.viewState.heightOracle.charWidth;\n    }\n    /**\n    The default height of a line in the editor. May not be accurate\n    for all lines.\n    */ get defaultLineHeight() {\n        return this.viewState.heightOracle.lineHeight;\n    }\n    /**\n    The text direction\n    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n    CSS property) of the editor's content element.\n    */ get textDirection() {\n        return this.viewState.defaultTextDirection;\n    }\n    /**\n    Find the text direction of the block at the given position, as\n    assigned by CSS. If\n    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\n    isn't enabled, or the given position is outside of the viewport,\n    this will always return the same as\n    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\n    this may trigger a DOM layout.\n    */ textDirectionAt(pos) {\n        let perLine = this.state.facet(perLineTextDirection);\n        if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;\n        this.readMeasured();\n        return this.docView.textDirectionAt(pos);\n    }\n    /**\n    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n    (as determined by the\n    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n    CSS property of its content element).\n    */ get lineWrapping() {\n        return this.viewState.heightOracle.lineWrapping;\n    }\n    /**\n    Returns the bidirectional text structure of the given line\n    (which should be in the current document) as an array of span\n    objects. The order of these spans matches the [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is\n    left-to-right, the leftmost spans come first, otherwise the\n    rightmost spans come first.\n    */ bidiSpans(line) {\n        if (line.length > MaxBidiLine) return trivialOrder(line.length);\n        let dir = this.textDirectionAt(line.from), isolates;\n        for (let entry of this.bidiCache){\n            if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line)))) return entry.order;\n        }\n        if (!isolates) isolates = getIsolatedRanges(this, line);\n        let order = computeOrder(line.text, dir, isolates);\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));\n        return order;\n    }\n    /**\n    Check whether the editor has focus.\n    */ get hasFocus() {\n        var _a;\n        // Safari return false for hasFocus when the context menu is open\n        // or closing, which leads us to ignore selection changes from the\n        // context menu because it looks like the editor isn't focused.\n        // This kludges around that.\n        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;\n    }\n    /**\n    Put focus on the editor.\n    */ focus() {\n        this.observer.ignore(()=>{\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /**\n    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\n    necessary when moving the editor's existing DOM to a new window or shadow root.\n    */ setRoot(root) {\n        if (this._root != root) {\n            this._root = root;\n            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);\n            this.mountStyles();\n        }\n    }\n    /**\n    Clean up this editor view, removing its element from the\n    document, unregistering event handlers, and notifying\n    plugins. The view instance can no longer be used after\n    calling this.\n    */ destroy() {\n        for (let plugin of this.plugins)plugin.destroy(this);\n        this.plugins = [];\n        this.inputState.destroy();\n        this.docView.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        this.destroyed = true;\n    }\n    /**\n    Returns an effect that can be\n    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n    cause it to scroll the given position or range into view.\n    */ static scrollIntoView(pos, options = {}) {\n        return scrollIntoView.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\n    }\n    /**\n    Return an effect that resets the editor to its current (at the\n    time this method was called) scroll position. Note that this\n    only affects the editor's own scrollable element, not parents.\n    See also\n    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).\n    \n    The effect should be used with a document identical to the one\n    it was created for. Failing to do so is not an error, but may\n    not scroll to the expected position. You can\n    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.\n    */ scrollSnapshot() {\n        let { scrollTop, scrollLeft } = this.scrollDOM;\n        let ref = this.viewState.scrollAnchorAt(scrollTop);\n        return scrollIntoView.of(new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(ref.from), \"start\", \"start\", ref.top - scrollTop, scrollLeft, true));\n    }\n    /**\n    Returns an extension that can be used to add DOM event handlers.\n    The value should be an object mapping event names to handler\n    functions. For any given event, such functions are ordered by\n    extension precedence, and the first handler to return true will\n    be assumed to have handled that event, and no other handlers or\n    built-in behavior will be activated for it. These are registered\n    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\n    for `scroll` handlers, which will be called any time the\n    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\n    its parent nodes is scrolled.\n    */ static domEventHandlers(handlers) {\n        return ViewPlugin.define(()=>({}), {\n            eventHandlers: handlers\n        });\n    }\n    /**\n    Create an extension that registers DOM event observers. Contrary\n    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),\n    observers can't be prevented from running by a higher-precedence\n    handler returning true. They also don't prevent other handlers\n    and observers from running when they return true, and should not\n    call `preventDefault`.\n    */ static domEventObservers(observers) {\n        return ViewPlugin.define(()=>({}), {\n            eventObservers: observers\n        });\n    }\n    /**\n    Create a theme extension. The first argument can be a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    style spec providing the styles for the theme. These will be\n    prefixed with a generated class for the style.\n    \n    Because the selectors will be prefixed with a scope class, rule\n    that directly match the editor's [wrapper\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be\n    added—need to be explicitly differentiated by adding an `&` to\n    the selector for that element—for example\n    `&.cm-focused`.\n    \n    When `dark` is set to true, the theme will be marked as dark,\n    which will cause the `&dark` rules from [base\n    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n    `&light` when a light theme is active).\n    */ static theme(spec, options) {\n        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n        let result = [\n            theme.of(prefix),\n            styleModule.of(buildTheme(`.${prefix}`, spec))\n        ];\n        if (options && options.dark) result.push(darkTheme.of(true));\n        return result;\n    }\n    /**\n    Create an extension that adds styles to the base theme. Like\n    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n    place of the editor wrapper element when directly targeting\n    that. You can also use `&dark` or `&light` instead to only\n    target editors with a dark or light theme.\n    */ static baseTheme(spec) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n    }\n    /**\n    Retrieve an editor view instance from the view's DOM\n    representation.\n    */ static findFromDOM(dom) {\n        var _a;\n        let content = dom.querySelector(\".cm-content\");\n        let cView = content && ContentView.get(content) || ContentView.get(dom);\n        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;\n    }\n}\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/ EditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n\nThe `insert` argument can be used to get the default transaction\nthat would be applied for this input. This can be useful when\ndispatching the custom behavior as a separate transaction.\n*/ EditorView.inputHandler = inputHandler;\n/**\nThis facet can be used to provide functions that create effects\nto be dispatched when the editor's focus state changes.\n*/ EditorView.focusChangeEffect = focusChangeEffect;\n/**\nBy default, the editor assumes all its content has the same\n[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`\nvalue to make it read the text direction of every (rendered)\nline separately.\n*/ EditorView.perLineTextDirection = perLineTextDirection;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/ EditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/ EditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot have its `contenteditable` attribute set. (Note that this\ndoesn't affect API calls that change the editor content, even\nwhen those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/ EditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/ EditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/ EditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds a\nnew range to the existing selection or replaces it entirely. The\ndefault behavior is to check `event.metaKey` on macOS, and\n`event.ctrlKey` elsewhere.\n*/ EditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. Decorations can be provided in two\nways—directly, or via a function that takes an editor view.\n\nOnly decoration sets provided directly are allowed to influence\nthe editor's vertical layout structure. The ones provided as\nfunctions are called _after_ the new viewport has been computed,\nand thus **must not** introduce block widgets or replacing\ndecorations that cover line breaks.\n\nIf you want decorated ranges to behave like atomic units for\ncursor motion and deletion purposes, also provide the range set\ncontaining the decorations to\n[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).\n*/ EditorView.decorations = decorations;\n/**\nFacet that works much like\n[`decorations`](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), but puts its\ninputs at the very bottom of the precedence stack, meaning mark\ndecorations provided here will only be split by other, partially\noverlapping \\`outerDecorations\\` ranges, and wrap around all\nregular decorations. Use this for mark elements that should, as\nmuch as possible, remain in one piece.\n*/ EditorView.outerDecorations = outerDecorations;\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/ EditorView.atomicRanges = atomicRanges;\n/**\nWhen range decorations add a `unicode-bidi: isolate` style, they\nshould also include a\n[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property\nin their decoration spec, and be exposed through this facet, so\nthat the editor can compute the proper text order. (Other values\nfor `unicode-bidi`, except of course `normal`, are not\nsupported.)\n*/ EditorView.bidiIsolatedRanges = bidiIsolatedRanges;\n/**\nFacet that allows extensions to provide additional scroll\nmargins (space around the sides of the scrolling element that\nshould be considered invisible). This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/ EditorView.scrollMargins = scrollMargins;\n/**\nThis facet records whether a dark theme is active. The extension\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\nincludes an instance of this when the `dark` option is set to\ntrue.\n*/ EditorView.darkTheme = darkTheme;\n/**\nProvides a Content Security Policy nonce to use when creating\nthe style sheets for the editor. Holds the empty string when no\nnonce has been provided.\n*/ EditorView.cspNonce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.length ? values[0] : \"\"\n});\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/ EditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/ EditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/ EditorView.lineWrapping = /*@__PURE__*/ EditorView.contentAttributes.of({\n    \"class\": \"cm-lineWrapping\"\n});\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/ EditorView.announce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nconst BadMeasure = {};\nclass CachedOrder {\n    constructor(from, to, dir, isolates, fresh, order){\n        this.from = from;\n        this.to = to;\n        this.dir = dir;\n        this.isolates = isolates;\n        this.fresh = fresh;\n        this.order = order;\n    }\n    static update(cache, changes) {\n        if (changes.empty && !cache.some((c)=>c.fresh)) return cache;\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n        for(let i = Math.max(0, cache.length - 10); i < cache.length; i++){\n            let entry = cache[i];\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));\n        }\n        return result;\n    }\n}\nfunction attrsFromFacet(view, facet, base) {\n    for(let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--){\n        let source = sources[i], value = typeof source == \"function\" ? source(view) : source;\n        if (value) combineAttrs(value, base);\n    }\n    return base;\n}\nconst currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\nfunction normalizeKeyName(name, platform) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\") result = \" \";\n    let alt, ctrl, shift, meta;\n    for(let i = 0; i < parts.length - 1; ++i){\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) meta = true;\n        else if (/^a(lt)?$/i.test(mod)) alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n        else if (/^s(hift)?$/i.test(mod)) shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (platform == \"mac\") meta = true;\n            else ctrl = true;\n        } else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) result = \"Alt-\" + result;\n    if (ctrl) result = \"Ctrl-\" + result;\n    if (meta) result = \"Meta-\" + result;\n    if (shift) result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey) name = \"Alt-\" + name;\n    if (event.ctrlKey) name = \"Ctrl-\" + name;\n    if (event.metaKey) name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n}\nconst handleKeyEvents = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.default(/*@__PURE__*/ EditorView.domEventHandlers({\n    keydown (event, view) {\n        return runHandlers(getKeymap(view.state), event, view, \"editor\");\n    }\n}));\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/ const keymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: handleKeyEvents\n});\nconst Keymaps = /*@__PURE__*/ new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n    let bindings = state.facet(keymap);\n    let map = Keymaps.get(bindings);\n    if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b)=>a.concat(b), [])));\n    return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be a `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/ function runScopeHandlers(view, event, scope) {\n    return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n    let bound = Object.create(null);\n    let isPrefix = Object.create(null);\n    let checkPrefix = (name, is)=>{\n        let current = isPrefix[name];\n        if (current == null) isPrefix[name] = is;\n        else if (current != is) throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n    };\n    let add = (scope, key, command, preventDefault, stopPropagation)=>{\n        var _a, _b;\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n        let parts = key.split(/ (?!$)/).map((k)=>normalizeKeyName(k, platform));\n        for(let i = 1; i < parts.length; i++){\n            let prefix = parts.slice(0, i).join(\" \");\n            checkPrefix(prefix, true);\n            if (!scopeObj[prefix]) scopeObj[prefix] = {\n                preventDefault: true,\n                stopPropagation: false,\n                run: [\n                    (view)=>{\n                        let ourObj = storedPrefix = {\n                            view,\n                            prefix,\n                            scope\n                        };\n                        setTimeout(()=>{\n                            if (storedPrefix == ourObj) storedPrefix = null;\n                        }, PrefixTimeout);\n                        return true;\n                    }\n                ]\n            };\n        }\n        let full = parts.join(\" \");\n        checkPrefix(full, false);\n        let binding = scopeObj[full] || (scopeObj[full] = {\n            preventDefault: false,\n            stopPropagation: false,\n            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []\n        });\n        if (command) binding.run.push(command);\n        if (preventDefault) binding.preventDefault = true;\n        if (stopPropagation) binding.stopPropagation = true;\n    };\n    for (let b of bindings){\n        let scopes = b.scope ? b.scope.split(\" \") : [\n            \"editor\"\n        ];\n        if (b.any) for (let scope of scopes){\n            let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n            if (!scopeObj._any) scopeObj._any = {\n                preventDefault: false,\n                stopPropagation: false,\n                run: []\n            };\n            for(let key in scopeObj)scopeObj[key].run.push(b.any);\n        }\n        let name = b[platform] || b.key;\n        if (!name) continue;\n        for (let scope of scopes){\n            add(scope, name, b.run, b.preventDefault, b.stopPropagation);\n            if (b.shift) add(scope, \"Shift-\" + name, b.shift, b.preventDefault, b.stopPropagation);\n        }\n    }\n    return bound;\n}\nfunction runHandlers(map, event, view, scope) {\n    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);\n    let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(name, 0), isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(charCode) == name.length && name != \" \";\n    let prefix = \"\", handled = false, prevented = false, stopPropagation = false;\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n        prefix = storedPrefix.prefix + \" \";\n        if (modifierCodes.indexOf(event.keyCode) < 0) {\n            prevented = true;\n            storedPrefix = null;\n        }\n    }\n    let ran = new Set;\n    let runFor = (binding)=>{\n        if (binding) {\n            for (let cmd of binding.run)if (!ran.has(cmd)) {\n                ran.add(cmd);\n                if (cmd(view, event)) {\n                    if (binding.stopPropagation) stopPropagation = true;\n                    return true;\n                }\n            }\n            if (binding.preventDefault) {\n                if (binding.stopPropagation) stopPropagation = true;\n                prevented = true;\n            }\n        }\n        return false;\n    };\n    let scopeObj = map[scope], baseName, shiftName;\n    if (scopeObj) {\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {\n            handled = true;\n        } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows\n        !(browser.windows && event.ctrlKey && event.altKey) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {\n                handled = true;\n            } else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {\n                handled = true;\n            }\n        } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name, event, true)])) {\n            handled = true;\n        }\n        if (!handled && runFor(scopeObj._any)) handled = true;\n    }\n    if (prevented) handled = true;\n    if (handled && stopPropagation) event.stopPropagation();\n    return handled;\n}\n/**\nImplementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates\na rectangle at a given set of coordinates.\n*/ class RectangleMarker {\n    /**\n    Create a marker with the given class and dimensions. If `width`\n    is null, the DOM element will get no width style.\n    */ constructor(className, /**\n    The left position of the marker (in pixels, document-relative).\n    */ left, /**\n    The top position of the marker.\n    */ top, /**\n    The width of the marker, or null if it shouldn't get a width assigned.\n    */ width, /**\n    The height of the marker.\n    */ height){\n        this.className = className;\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    update(elt, prev) {\n        if (prev.className != this.className) return false;\n        this.adjust(elt);\n        return true;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        if (this.width != null) elt.style.width = this.width + \"px\";\n        elt.style.height = this.height + \"px\";\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;\n    }\n    /**\n    Create a set of rectangles for the given selection range,\n    assigning them theclass`className`. Will create a single\n    rectangle for empty ranges, and a set of selection-style\n    rectangles covering the range's content (in a bidi-aware\n    way) for non-empty ones.\n    */ static forRange(view, className, range) {\n        if (range.empty) {\n            let pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (!pos) return [];\n            let base = getBase(view);\n            return [\n                new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)\n            ];\n        } else {\n            return rectanglesForRange(view, className, range);\n        }\n    }\n}\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;\n    return {\n        left: left - view.scrollDOM.scrollLeft * view.scaleX,\n        top: rect.top - view.scrollDOM.scrollTop * view.scaleY\n    };\n}\nfunction wrappedLine(view, pos, inside) {\n    let range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n    return {\n        from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),\n        type: BlockType.Text\n    };\n}\nfunction rectanglesForRange(view, className, range) {\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n    let ltr = view.textDirection == Direction.LTR;\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n    let lineElt = content.querySelector(\".cm-line\"), lineStyle = lineElt && window.getComputedStyle(lineElt);\n    let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);\n    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);\n    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);\n    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks)) visualStart = wrappedLine(view, from, visualStart);\n    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks)) visualEnd = wrappedLine(view, to, visualEnd);\n    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {\n        return pieces(drawForLine(range.from, range.to, visualStart));\n    } else {\n        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n        let between = [];\n        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\n        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n        return pieces(top).concat(between).concat(pieces(bottom));\n    }\n    function piece(left, top, right, bottom) {\n        return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */ , right - left, bottom - top + 0.01 /* C.Epsilon */ );\n    }\n    function pieces({ top, bottom, horizontal }) {\n        let pieces = [];\n        for(let i = 0; i < horizontal.length; i += 2)pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n        return pieces;\n    }\n    // Gets passed from/to in line-local positions\n    function drawForLine(from, to, line) {\n        let top = 1e9, bottom = -1e9, horizontal = [];\n        function addSpan(from, fromOpen, to, toOpen, dir) {\n            // Passing 2/-2 is a kludge to force the view to return\n            // coordinates on the proper side of block widgets, since\n            // normalizing the side there, though appropriate for most\n            // coordsAtPos queries, would break selection drawing.\n            let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);\n            let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);\n            if (!fromCoords || !toCoords) return;\n            top = Math.min(fromCoords.top, toCoords.top, top);\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n            if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\n            else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n        }\n        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;\n        // Split the range by visible range and document line\n        for (let r of view.visibleRanges)if (r.to > start && r.from < end) {\n            for(let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;){\n                let docLine = view.state.doc.lineAt(pos);\n                for (let span of view.bidiSpans(docLine)){\n                    let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n                    if (spanFrom >= endPos) break;\n                    if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n                }\n                pos = docLine.to + 1;\n                if (pos >= endPos) break;\n            }\n        }\n        if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);\n        return {\n            top,\n            bottom,\n            horizontal\n        };\n    }\n    function drawForWidget(block, top) {\n        let y = contentRect.top + (top ? block.top : block.bottom);\n        return {\n            top: y,\n            bottom: y,\n            horizontal: []\n        };\n    }\n}\nfunction sameMarker(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nclass LayerView {\n    constructor(view, layer){\n        this.view = view;\n        this.layer = layer;\n        this.drawn = [];\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.measureReq = {\n            read: this.measure.bind(this),\n            write: this.draw.bind(this)\n        };\n        this.dom = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.dom.classList.add(\"cm-layer\");\n        if (layer.above) this.dom.classList.add(\"cm-layer-above\");\n        if (layer.class) this.dom.classList.add(layer.class);\n        this.scale();\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.setOrder(view.state);\n        view.requestMeasure(this.measureReq);\n        if (layer.mount) layer.mount(this.dom, view);\n    }\n    update(update) {\n        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder)) this.setOrder(update.state);\n        if (this.layer.update(update, this.dom) || update.geometryChanged) {\n            this.scale();\n            update.view.requestMeasure(this.measureReq);\n        }\n    }\n    setOrder(state) {\n        let pos = 0, order = state.facet(layerOrder);\n        while(pos < order.length && order[pos] != this.layer)pos++;\n        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);\n    }\n    measure() {\n        return this.layer.markers(this.view);\n    }\n    scale() {\n        let { scaleX, scaleY } = this.view;\n        if (scaleX != this.scaleX || scaleY != this.scaleY) {\n            this.scaleX = scaleX;\n            this.scaleY = scaleY;\n            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;\n        }\n    }\n    draw(markers) {\n        if (markers.length != this.drawn.length || markers.some((p, i)=>!sameMarker(p, this.drawn[i]))) {\n            let old = this.dom.firstChild, oldI = 0;\n            for (let marker of markers){\n                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {\n                    old = old.nextSibling;\n                    oldI++;\n                } else {\n                    this.dom.insertBefore(marker.draw(), old);\n                }\n            }\n            while(old){\n                let next = old.nextSibling;\n                old.remove();\n                old = next;\n            }\n            this.drawn = markers;\n        }\n    }\n    destroy() {\n        if (this.layer.destroy) this.layer.destroy(this.dom, this.view);\n        this.dom.remove();\n    }\n}\nconst layerOrder = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine a layer.\n*/ function layer(config) {\n    return [\n        ViewPlugin.define((v)=>new LayerView(v, config)),\n        layerOrder.of(config)\n    ];\n}\nconst CanHidePrimary = !browser.ios; // FIXME test IE\nconst selectionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            cursorBlinkRate: 1200,\n            drawRangeCursor: true\n        }, {\n            cursorBlinkRate: (a, b)=>Math.min(a, b),\n            drawRangeCursor: (a, b)=>a || b\n        });\n    }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/ function drawSelection(config = {}) {\n    return [\n        selectionConfig.of(config),\n        cursorLayer,\n        selectionLayer,\n        hideNativeSelection,\n        nativeSelectionHidden.of(true)\n    ];\n}\n/**\nRetrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration\nfor this state. (Note that this will return a set of defaults even\nif `drawSelection` isn't enabled.)\n*/ function getDrawSelectionConfig(state) {\n    return state.facet(selectionConfig);\n}\nfunction configChanged(update) {\n    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n}\nconst cursorLayer = /*@__PURE__*/ layer({\n    above: true,\n    markers (view) {\n        let { state } = view, conf = state.facet(selectionConfig);\n        let cursors = [];\n        for (let r of state.selection.ranges){\n            let prim = r == state.selection.main;\n            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n                let className = prim ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\";\n                let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);\n                for (let piece of RectangleMarker.forRange(view, className, cursor))cursors.push(piece);\n            }\n        }\n        return cursors;\n    },\n    update (update, dom) {\n        if (update.transactions.some((tr)=>tr.selection)) dom.style.animationName = dom.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        let confChange = configChanged(update);\n        if (confChange) setBlinkRate(update.state, dom);\n        return update.docChanged || update.selectionSet || confChange;\n    },\n    mount (dom, view) {\n        setBlinkRate(view.state, dom);\n    },\n    class: \"cm-cursorLayer\"\n});\nfunction setBlinkRate(state, dom) {\n    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n}\nconst selectionLayer = /*@__PURE__*/ layer({\n    above: false,\n    markers (view) {\n        return view.state.selection.ranges.map((r)=>r.empty ? [] : RectangleMarker.forRange(view, \"cm-selectionBackground\", r)).reduce((a, b)=>a.concat(b));\n    },\n    update (update, dom) {\n        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);\n    },\n    class: \"cm-selectionLayer\"\n});\nconst themeSpec = {\n    \".cm-line\": {\n        \"& ::selection\": {\n            backgroundColor: \"transparent !important\"\n        },\n        \"&::selection\": {\n            backgroundColor: \"transparent !important\"\n        }\n    }\n};\nif (CanHidePrimary) {\n    themeSpec[\".cm-line\"].caretColor = \"transparent !important\";\n    themeSpec[\".cm-content\"] = {\n        caretColor: \"transparent !important\"\n    };\n}\nconst hideNativeSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.highest(/*@__PURE__*/ EditorView.theme(themeSpec));\nconst setDropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map (pos, mapping) {\n        return pos == null ? null : mapping.mapPos(pos);\n    }\n});\nconst dropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return null;\n    },\n    update (pos, tr) {\n        if (pos != null) pos = tr.changes.mapPos(pos);\n        return tr.effects.reduce((pos, e)=>e.is(setDropCursorPos) ? e.value : pos, pos);\n    }\n});\nconst drawDropCursor = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.cursor = null;\n        this.measureReq = {\n            read: this.readPos.bind(this),\n            write: this.drawCursor.bind(this)\n        };\n    }\n    update(update) {\n        var _a;\n        let cursorPos = update.state.field(dropCursorPos);\n        if (cursorPos == null) {\n            if (this.cursor != null) {\n                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\n                this.cursor = null;\n            }\n        } else {\n            if (!this.cursor) {\n                this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\n                this.cursor.className = \"cm-dropCursor\";\n            }\n            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);\n        }\n    }\n    readPos() {\n        let { view } = this;\n        let pos = view.state.field(dropCursorPos);\n        let rect = pos != null && view.coordsAtPos(pos);\n        if (!rect) return null;\n        let outer = view.scrollDOM.getBoundingClientRect();\n        return {\n            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,\n            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,\n            height: rect.bottom - rect.top\n        };\n    }\n    drawCursor(pos) {\n        if (this.cursor) {\n            let { scaleX, scaleY } = this.view;\n            if (pos) {\n                this.cursor.style.left = pos.left / scaleX + \"px\";\n                this.cursor.style.top = pos.top / scaleY + \"px\";\n                this.cursor.style.height = pos.height / scaleY + \"px\";\n            } else {\n                this.cursor.style.left = \"-100000px\";\n            }\n        }\n    }\n    destroy() {\n        if (this.cursor) this.cursor.remove();\n    }\n    setDropPos(pos) {\n        if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({\n            effects: setDropCursorPos.of(pos)\n        });\n    }\n}, {\n    eventObservers: {\n        dragover (event) {\n            this.setDropPos(this.view.posAtCoords({\n                x: event.clientX,\n                y: event.clientY\n            }));\n        },\n        dragleave (event) {\n            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);\n        },\n        dragend () {\n            this.setDropPos(null);\n        },\n        drop () {\n            this.setDropPos(null);\n        }\n    }\n});\n/**\nDraws a cursor at the current drop position when something is\ndragged over the editor.\n*/ function dropCursor() {\n    return [\n        dropCursorPos,\n        drawDropCursor\n    ];\n}\nfunction iterMatches(doc, re, from, to, f) {\n    re.lastIndex = 0;\n    for(let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length){\n        if (!cursor.lineBreak) while(m = re.exec(cursor.value))f(pos + m.index, m);\n    }\n}\nfunction matchRanges(view, maxLength) {\n    let visible = view.visibleRanges;\n    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;\n    let result = [];\n    for (let { from, to } of visible){\n        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\n        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\n        if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;\n        else result.push({\n            from,\n            to\n        });\n    }\n    return result;\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/ class MatchDecorator {\n    /**\n    Create a decorator.\n    */ constructor(config){\n        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;\n        if (!regexp.global) throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n        this.regexp = regexp;\n        if (decorate) {\n            this.addMatch = (match, view, from, add)=>decorate(add, from, from + match[0].length, match, view);\n        } else if (typeof decoration == \"function\") {\n            this.addMatch = (match, view, from, add)=>{\n                let deco = decoration(match, view, from);\n                if (deco) add(from, from + match[0].length, deco);\n            };\n        } else if (decoration) {\n            this.addMatch = (match, _view, from, add)=>add(from, from + match[0].length, decoration);\n        } else {\n            throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\n        }\n        this.boundary = boundary;\n        this.maxLength = maxLength;\n    }\n    /**\n    Compute the full set of decorations for matches in the given\n    view's viewport. You'll want to call this when initializing your\n    plugin.\n    */ createDeco(view) {\n        let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSetBuilder(), add = build.add.bind(build);\n        for (let { from, to } of matchRanges(view, this.maxLength))iterMatches(view.state.doc, this.regexp, from, to, (from, m)=>this.addMatch(m, view, from, add));\n        return build.finish();\n    }\n    /**\n    Update a set of decorations for a view update. `deco` _must_ be\n    the set of decorations produced by _this_ `MatchDecorator` for\n    the view state before the update.\n    */ updateDeco(update, deco) {\n        let changeFrom = 1e9, changeTo = -1;\n        if (update.docChanged) update.changes.iterChanges((_f, _t, from, to)=>{\n            if (to > update.view.viewport.from && from < update.view.viewport.to) {\n                changeFrom = Math.min(from, changeFrom);\n                changeTo = Math.max(to, changeTo);\n            }\n        });\n        if (update.viewportChanged || changeTo - changeFrom > 1000) return this.createDeco(update.view);\n        if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n        return deco;\n    }\n    updateRange(view, deco, updateFrom, updateTo) {\n        for (let r of view.visibleRanges){\n            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);\n            if (to > from) {\n                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);\n                if (this.boundary) {\n                    for(; from > fromLine.from; from--)if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n                        start = from;\n                        break;\n                    }\n                    for(; to < toLine.to; to++)if (this.boundary.test(toLine.text[to - toLine.from])) {\n                        end = to;\n                        break;\n                    }\n                }\n                let ranges = [], m;\n                let add = (from, to, deco)=>ranges.push(deco.range(from, to));\n                if (fromLine == toLine) {\n                    this.regexp.lastIndex = start - fromLine.from;\n                    while((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)this.addMatch(m, view, m.index + fromLine.from, add);\n                } else {\n                    iterMatches(view.state.doc, this.regexp, start, end, (from, m)=>this.addMatch(m, view, from, add));\n                }\n                deco = deco.update({\n                    filterFrom: start,\n                    filterTo: end,\n                    filter: (from, to)=>from < start || to > end,\n                    add: ranges\n                });\n            }\n        }\n        return deco;\n    }\n}\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst Specials = /*@__PURE__*/ new RegExp(\"[\\x00-\\b\\n-\\x1f\\x7f-\\x9f\\xad؜​‎‏\\u2028\\u2029‭‮⁦⁧⁩\\uFEFF￹-￼]\", UnicodeRegexpSupport);\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8237: \"left-to-right override\",\n    8238: \"right-to-left override\",\n    8294: \"left-to-right isolate\",\n    8295: \"right-to-left isolate\",\n    8297: \"pop directional isolate\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n    var _a;\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n        let styles = document.body.style;\n        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n    }\n    return _supportsTabSize || false;\n}\nconst specialCharConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp(\"\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n        if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n        return config;\n    }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/ function highlightSpecialChars(/**\nConfiguration options.\n*/ config = {}) {\n    return [\n        specialCharConfig.of(config),\n        specialCharPlugin()\n    ];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n    return _plugin || (_plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.decorations = Decoration.none;\n            this.decorationCache = Object.create(null);\n            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n            this.decorations = this.decorator.createDeco(view);\n        }\n        makeDecorator(conf) {\n            return new MatchDecorator({\n                regexp: conf.specialChars,\n                decoration: (m, view, pos)=>{\n                    let { doc } = view.state;\n                    let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(m[0], 0);\n                    if (code == 9) {\n                        let line = doc.lineAt(pos);\n                        let size = view.state.tabSize, col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, size, pos - line.from);\n                        return Decoration.replace({\n                            widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)\n                        });\n                    }\n                    return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({\n                        widget: new SpecialCharWidget(conf, code)\n                    }));\n                },\n                boundary: conf.replaceTabs ? undefined : /[^]/\n            });\n        }\n        update(update) {\n            let conf = update.state.facet(specialCharConfig);\n            if (update.startState.facet(specialCharConfig) != conf) {\n                this.decorator = this.makeDecorator(conf);\n                this.decorations = this.decorator.createDeco(update.view);\n            } else {\n                this.decorations = this.decorator.updateDeco(update, this.decorations);\n            }\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    }));\n}\nconst DefaultPlaceholder = \"•\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder$1(code) {\n    if (code >= 32) return DefaultPlaceholder;\n    if (code == 10) return \"␤\";\n    return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code){\n        super();\n        this.options = options;\n        this.code = code;\n    }\n    eq(other) {\n        return other.code == this.code;\n    }\n    toDOM(view) {\n        let ph = placeholder$1(this.code);\n        let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\n        if (custom) return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.className = \"cm-specialChar\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nclass TabWidget extends WidgetType {\n    constructor(width){\n        super();\n        this.width = width;\n    }\n    eq(other) {\n        return other.width == this.width;\n    }\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\t\";\n        span.className = \"cm-tab\";\n        span.style.width = this.width + \"px\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nconst plugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(){\n        this.height = 1000;\n        this.attrs = {\n            style: \"padding-bottom: 1000px\"\n        };\n    }\n    update(update) {\n        let { view } = update;\n        let height = view.viewState.editorHeight * view.scaleY - view.defaultLineHeight - view.documentPadding.top - 0.5;\n        if (height >= 0 && height != this.height) {\n            this.height = height;\n            this.attrs = {\n                style: `padding-bottom: ${height}px`\n            };\n        }\n    }\n});\n/**\nReturns an extension that makes sure the content has a bottom\nmargin equivalent to the height of the editor, minus one line\nheight, so that every line in the document can be scrolled to the\ntop of the editor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/ function scrollPastEnd() {\n    return [\n        plugin,\n        contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;\n        })\n    ];\n}\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/ function highlightActiveLine() {\n    return activeLineHighlighter;\n}\nconst lineDeco = /*@__PURE__*/ Decoration.line({\n    class: \"cm-activeLine\"\n});\nconst activeLineHighlighter = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let lastLineStart = -1, deco = [];\n        for (let r of view.state.selection.ranges){\n            let line = view.lineBlockAt(r.head);\n            if (line.from > lastLineStart) {\n                deco.push(lineDeco.range(line.from));\n                lastLineStart = line.from;\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nclass Placeholder extends WidgetType {\n    constructor(content){\n        super();\n        this.content = content;\n    }\n    toDOM() {\n        let wrap = document.createElement(\"span\");\n        wrap.className = \"cm-placeholder\";\n        wrap.style.pointerEvents = \"none\";\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n        if (typeof this.content == \"string\") wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);\n        else wrap.setAttribute(\"aria-hidden\", \"true\");\n        return wrap;\n    }\n    coordsAt(dom) {\n        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];\n        if (!rects.length) return null;\n        let style = window.getComputedStyle(dom.parentNode);\n        let rect = flattenRect(rects[0], style.direction != \"rtl\");\n        let lineHeight = parseInt(style.lineHeight);\n        if (rect.bottom - rect.top > lineHeight * 1.5) return {\n            left: rect.left,\n            right: rect.right,\n            top: rect.top,\n            bottom: rect.top + lineHeight\n        };\n        return rect;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\n/**\nExtension that enables a placeholder—a piece of example content\nto show when the editor is empty.\n*/ function placeholder(content) {\n    return ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.placeholder = content ? Decoration.set([\n                Decoration.widget({\n                    widget: new Placeholder(content),\n                    side: 1\n                }).range(0)\n            ]) : Decoration.none;\n        }\n        get decorations() {\n            return this.view.state.doc.length ? Decoration.none : this.placeholder;\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    });\n}\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            if (line.length <= endOff) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    } else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, startCol, state.tabSize, true);\n            if (start < 0) {\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(line.to));\n            } else {\n                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, endCol, state.tabSize);\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + start, line.from + end));\n            }\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n    return {\n        line: line.number,\n        col,\n        off\n    };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start) return null;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = {\n                    line: newLine.number,\n                    col: start.col,\n                    off: Math.min(start.off, newLine.length)\n                };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur) return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length) return startSel;\n            if (multiple) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.concat(startSel.ranges));\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges);\n        }\n    };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/ function rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e)=>e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event)=>filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\nconst keys = {\n    Alt: [\n        18,\n        (e)=>!!e.altKey\n    ],\n    Control: [\n        17,\n        (e)=>!!e.ctrlKey\n    ],\n    Shift: [\n        16,\n        (e)=>!!e.shiftKey\n    ],\n    Meta: [\n        91,\n        (e)=>!!e.metaKey\n    ]\n};\nconst showCrosshair = {\n    style: \"cursor: crosshair\"\n};\n/**\nReturns an extension that turns the pointer cursor into a\ncrosshair when a given modifier key, defaulting to Alt, is held\ndown. Can serve as a visual hint that rectangular selection is\ngoing to happen when paired with\n[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).\n*/ function crosshairCursor(options = {}) {\n    let [code, getter] = keys[options.key || \"Alt\"];\n    let plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.isDown = false;\n        }\n        set(isDown) {\n            if (this.isDown != isDown) {\n                this.isDown = isDown;\n                this.view.update([]);\n            }\n        }\n    }, {\n        eventObservers: {\n            keydown (e) {\n                this.set(e.keyCode == code || getter(e));\n            },\n            keyup (e) {\n                if (e.keyCode == code || !getter(e)) this.set(false);\n            },\n            mousemove (e) {\n                this.set(getter(e));\n            }\n        }\n    });\n    return [\n        plugin,\n        EditorView.contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;\n        })\n    ];\n}\nconst Outside = \"-10000px\";\nclass TooltipViewManager {\n    constructor(view, facet, createTooltipView, removeTooltipView){\n        this.facet = facet;\n        this.createTooltipView = createTooltipView;\n        this.removeTooltipView = removeTooltipView;\n        this.input = view.state.facet(facet);\n        this.tooltips = this.input.filter((t)=>t);\n        let prev = null;\n        this.tooltipViews = this.tooltips.map((t)=>prev = createTooltipView(t, prev));\n    }\n    update(update, above) {\n        var _a;\n        let input = update.state.facet(this.facet);\n        let tooltips = input.filter((x)=>x);\n        if (input === this.input) {\n            for (let t of this.tooltipViews)if (t.update) t.update(update);\n            return false;\n        }\n        let tooltipViews = [], newAbove = above ? [] : null;\n        for(let i = 0; i < tooltips.length; i++){\n            let tip = tooltips[i], known = -1;\n            if (!tip) continue;\n            for(let i = 0; i < this.tooltips.length; i++){\n                let other = this.tooltips[i];\n                if (other && other.create == tip.create) known = i;\n            }\n            if (known < 0) {\n                tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);\n                if (newAbove) newAbove[i] = !!tip.above;\n            } else {\n                let tooltipView = tooltipViews[i] = this.tooltipViews[known];\n                if (newAbove) newAbove[i] = above[known];\n                if (tooltipView.update) tooltipView.update(update);\n            }\n        }\n        for (let t of this.tooltipViews)if (tooltipViews.indexOf(t) < 0) {\n            this.removeTooltipView(t);\n            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n        }\n        if (above) {\n            newAbove.forEach((val, i)=>above[i] = val);\n            above.length = newAbove.length;\n        }\n        this.input = input;\n        this.tooltips = tooltips;\n        this.tooltipViews = tooltipViews;\n        return true;\n    }\n}\n/**\nCreates an extension that configures tooltip behavior.\n*/ function tooltips(config = {}) {\n    return tooltipConfig.of(config);\n}\nfunction windowSpace(view) {\n    let { win } = view;\n    return {\n        top: 0,\n        left: 0,\n        bottom: win.innerHeight,\n        right: win.innerWidth\n    };\n}\nconst tooltipConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>{\n        var _a, _b, _c;\n        return {\n            position: browser.ios ? \"absolute\" : ((_a = values.find((conf)=>conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n            parent: ((_b = values.find((conf)=>conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,\n            tooltipSpace: ((_c = values.find((conf)=>conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace\n        };\n    }\n});\nconst knownHeight = /*@__PURE__*/ new WeakMap();\nconst tooltipPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.above = [];\n        this.inView = true;\n        this.madeAbsolute = false;\n        this.lastTransaction = 0;\n        this.measureTimeout = -1;\n        let config = view.state.facet(tooltipConfig);\n        this.position = config.position;\n        this.parent = config.parent;\n        this.classes = view.themeClasses;\n        this.createContainer();\n        this.measureReq = {\n            read: this.readMeasure.bind(this),\n            write: this.writeMeasure.bind(this),\n            key: this\n        };\n        this.resizeObserver = typeof ResizeObserver == \"function\" ? new ResizeObserver(()=>this.measureSoon()) : null;\n        this.manager = new TooltipViewManager(view, showTooltip, (t, p)=>this.createTooltip(t, p), (t)=>{\n            if (this.resizeObserver) this.resizeObserver.unobserve(t.dom);\n            t.dom.remove();\n        });\n        this.above = this.manager.tooltips.map((t)=>!!t.above);\n        this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver((entries)=>{\n            if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();\n        }, {\n            threshold: [\n                1\n            ]\n        }) : null;\n        this.observeIntersection();\n        view.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\n        this.maybeMeasure();\n    }\n    createContainer() {\n        if (this.parent) {\n            this.container = document.createElement(\"div\");\n            this.container.style.position = \"relative\";\n            this.container.className = this.view.themeClasses;\n            this.parent.appendChild(this.container);\n        } else {\n            this.container = this.view.dom;\n        }\n    }\n    observeIntersection() {\n        if (this.intersectionObserver) {\n            this.intersectionObserver.disconnect();\n            for (let tooltip of this.manager.tooltipViews)this.intersectionObserver.observe(tooltip.dom);\n        }\n    }\n    measureSoon() {\n        if (this.measureTimeout < 0) this.measureTimeout = setTimeout(()=>{\n            this.measureTimeout = -1;\n            this.maybeMeasure();\n        }, 50);\n    }\n    update(update) {\n        if (update.transactions.length) this.lastTransaction = Date.now();\n        let updated = this.manager.update(update, this.above);\n        if (updated) this.observeIntersection();\n        let shouldMeasure = updated || update.geometryChanged;\n        let newConfig = update.state.facet(tooltipConfig);\n        if (newConfig.position != this.position && !this.madeAbsolute) {\n            this.position = newConfig.position;\n            for (let t of this.manager.tooltipViews)t.dom.style.position = this.position;\n            shouldMeasure = true;\n        }\n        if (newConfig.parent != this.parent) {\n            if (this.parent) this.container.remove();\n            this.parent = newConfig.parent;\n            this.createContainer();\n            for (let t of this.manager.tooltipViews)this.container.appendChild(t.dom);\n            shouldMeasure = true;\n        } else if (this.parent && this.view.themeClasses != this.classes) {\n            this.classes = this.container.className = this.view.themeClasses;\n        }\n        if (shouldMeasure) this.maybeMeasure();\n    }\n    createTooltip(tooltip, prev) {\n        let tooltipView = tooltip.create(this.view);\n        let before = prev ? prev.dom : null;\n        tooltipView.dom.classList.add(\"cm-tooltip\");\n        if (tooltip.arrow && !tooltipView.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\n            let arrow = document.createElement(\"div\");\n            arrow.className = \"cm-tooltip-arrow\";\n            tooltipView.dom.insertBefore(arrow, before);\n        }\n        tooltipView.dom.style.position = this.position;\n        tooltipView.dom.style.top = Outside;\n        tooltipView.dom.style.left = \"0px\";\n        this.container.insertBefore(tooltipView.dom, before);\n        if (tooltipView.mount) tooltipView.mount(this.view);\n        if (this.resizeObserver) this.resizeObserver.observe(tooltipView.dom);\n        return tooltipView;\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.view.win.removeEventListener(\"resize\", this.measureSoon);\n        for (let tooltipView of this.manager.tooltipViews){\n            tooltipView.dom.remove();\n            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);\n        }\n        if (this.parent) this.container.remove();\n        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();\n        clearTimeout(this.measureTimeout);\n    }\n    readMeasure() {\n        let editor = this.view.dom.getBoundingClientRect();\n        let scaleX = 1, scaleY = 1, makeAbsolute = false;\n        if (this.position == \"fixed\" && this.manager.tooltipViews.length) {\n            let { dom } = this.manager.tooltipViews[0];\n            if (browser.gecko) {\n                // Firefox sets the element's `offsetParent` to the\n                // transformed element when a transform interferes with fixed\n                // positioning.\n                makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;\n            } else if (dom.style.top == Outside && dom.style.left == \"0px\") {\n                // On other browsers, we have to awkwardly try and use other\n                // information to detect a transform.\n                let rect = dom.getBoundingClientRect();\n                makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;\n            }\n        }\n        if (makeAbsolute || this.position == \"absolute\") {\n            if (this.parent) {\n                let rect = this.parent.getBoundingClientRect();\n                if (rect.width && rect.height) {\n                    scaleX = rect.width / this.parent.offsetWidth;\n                    scaleY = rect.height / this.parent.offsetHeight;\n                }\n            } else {\n                ({ scaleX, scaleY } = this.view.viewState);\n            }\n        }\n        return {\n            editor,\n            parent: this.parent ? this.container.getBoundingClientRect() : editor,\n            pos: this.manager.tooltips.map((t, i)=>{\n                let tv = this.manager.tooltipViews[i];\n                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);\n            }),\n            size: this.manager.tooltipViews.map(({ dom })=>dom.getBoundingClientRect()),\n            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),\n            scaleX,\n            scaleY,\n            makeAbsolute\n        };\n    }\n    writeMeasure(measured) {\n        var _a;\n        if (measured.makeAbsolute) {\n            this.madeAbsolute = true;\n            this.position = \"absolute\";\n            for (let t of this.manager.tooltipViews)t.dom.style.position = \"absolute\";\n        }\n        let { editor, space, scaleX, scaleY } = measured;\n        let others = [];\n        for(let i = 0; i < this.manager.tooltips.length; i++){\n            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - .1 || pos.left > Math.min(editor.right, space.right) + .1) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\n            let arrowHeight = arrow ? 7 /* Arrow.Size */  : 0;\n            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;\n            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;\n            let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */  : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */  : 0) - offset.x);\n            let above = this.above[i];\n            if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space.top : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = this.above[i] = !above;\n            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;\n            if (spaceVert < height && tView.resize !== false) {\n                if (spaceVert < this.view.defaultLineHeight) {\n                    dom.style.top = Outside;\n                    continue;\n                }\n                knownHeight.set(tView, height);\n                dom.style.height = (height = spaceVert) / scaleY + \"px\";\n            } else if (dom.style.height) {\n                dom.style.height = \"\";\n            }\n            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\n            let right = left + width;\n            if (tView.overlap !== true) {\n                for (let r of others)if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\n            }\n            if (this.position == \"absolute\") {\n                dom.style.top = (top - measured.parent.top) / scaleY + \"px\";\n                dom.style.left = (left - measured.parent.left) / scaleX + \"px\";\n            } else {\n                dom.style.top = top / scaleY + \"px\";\n                dom.style.left = left / scaleX + \"px\";\n            }\n            if (arrow) {\n                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */  - 7 /* Arrow.Size */ );\n                arrow.style.left = arrowLeft / scaleX + \"px\";\n            }\n            if (tView.overlap !== true) others.push({\n                left,\n                top,\n                right,\n                bottom: top + height\n            });\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned) tView.positioned(measured.space);\n        }\n    }\n    maybeMeasure() {\n        if (this.manager.tooltips.length) {\n            if (this.view.inView) this.view.requestMeasure(this.measureReq);\n            if (this.inView != this.view.inView) {\n                this.inView = this.view.inView;\n                if (!this.inView) for (let tv of this.manager.tooltipViews)tv.dom.style.top = Outside;\n            }\n        }\n    }\n}, {\n    eventObservers: {\n        scroll () {\n            this.maybeMeasure();\n        }\n    }\n});\nconst baseTheme = /*@__PURE__*/ EditorView.baseTheme({\n    \".cm-tooltip\": {\n        zIndex: 100,\n        boxSizing: \"border-box\"\n    },\n    \"&light .cm-tooltip\": {\n        border: \"1px solid #bbb\",\n        backgroundColor: \"#f5f5f5\"\n    },\n    \"&light .cm-tooltip-section:not(:first-child)\": {\n        borderTop: \"1px solid #bbb\"\n    },\n    \"&dark .cm-tooltip\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tooltip-arrow\": {\n        height: `${7 /* Arrow.Size */ }px`,\n        width: `${7 /* Arrow.Size */  * 2}px`,\n        position: \"absolute\",\n        zIndex: -1,\n        overflow: \"hidden\",\n        \"&:before, &:after\": {\n            content: \"''\",\n            position: \"absolute\",\n            width: 0,\n            height: 0,\n            borderLeft: `${7 /* Arrow.Size */ }px solid transparent`,\n            borderRight: `${7 /* Arrow.Size */ }px solid transparent`\n        },\n        \".cm-tooltip-above &\": {\n            bottom: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                bottom: \"1px\"\n            }\n        },\n        \".cm-tooltip-below &\": {\n            top: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                top: \"1px\"\n            }\n        }\n    },\n    \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n        \"&:before\": {\n            borderTopColor: \"#333338\",\n            borderBottomColor: \"#333338\"\n        },\n        \"&:after\": {\n            borderTopColor: \"transparent\",\n            borderBottomColor: \"transparent\"\n        }\n    }\n});\nconst noOffset = {\n    x: 0,\n    y: 0\n};\n/**\nFacet to which an extension can add a value to show a tooltip.\n*/ const showTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: [\n        tooltipPlugin,\n        baseTheme\n    ]\n});\nconst showHoverTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (inputs)=>inputs.reduce((a, i)=>a.concat(i), [])\n});\nclass HoverTooltipHost {\n    // Needs to be static so that host tooltip instances always match\n    static create(view) {\n        return new HoverTooltipHost(view);\n    }\n    constructor(view){\n        this.view = view;\n        this.mounted = false;\n        this.dom = document.createElement(\"div\");\n        this.dom.classList.add(\"cm-tooltip-hover\");\n        this.manager = new TooltipViewManager(view, showHoverTooltip, (t, p)=>this.createHostedView(t, p), (t)=>t.dom.remove());\n    }\n    createHostedView(tooltip, prev) {\n        let hostedView = tooltip.create(this.view);\n        hostedView.dom.classList.add(\"cm-tooltip-section\");\n        this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);\n        if (this.mounted && hostedView.mount) hostedView.mount(this.view);\n        return hostedView;\n    }\n    mount(view) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.mount) hostedView.mount(view);\n        }\n        this.mounted = true;\n    }\n    positioned(space) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.positioned) hostedView.positioned(space);\n        }\n    }\n    update(update) {\n        this.manager.update(update);\n    }\n    destroy() {\n        var _a;\n        for (let t of this.manager.tooltipViews)(_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n    }\n    passProp(name) {\n        let value = undefined;\n        for (let view of this.manager.tooltipViews){\n            let given = view[name];\n            if (given !== undefined) {\n                if (value === undefined) value = given;\n                else if (value !== given) return undefined;\n            }\n        }\n        return value;\n    }\n    get offset() {\n        return this.passProp(\"offset\");\n    }\n    get getCoords() {\n        return this.passProp(\"getCoords\");\n    }\n    get overlap() {\n        return this.passProp(\"overlap\");\n    }\n    get resize() {\n        return this.passProp(\"resize\");\n    }\n}\nconst showHoverTooltipHost = /*@__PURE__*/ showTooltip.compute([\n    showHoverTooltip\n], (state)=>{\n    let tooltips = state.facet(showHoverTooltip);\n    if (tooltips.length === 0) return null;\n    return {\n        pos: Math.min(...tooltips.map((t)=>t.pos)),\n        end: Math.max(...tooltips.map((t)=>{\n            var _a;\n            return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos;\n        })),\n        create: HoverTooltipHost.create,\n        above: tooltips[0].above,\n        arrow: tooltips.some((t)=>t.arrow)\n    };\n});\nclass HoverPlugin {\n    constructor(view, source, field, setHover, hoverTime){\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.hoverTime = hoverTime;\n        this.hoverTimeout = -1;\n        this.restartTimeout = -1;\n        this.pending = null;\n        this.lastMove = {\n            x: 0,\n            y: 0,\n            target: view.dom,\n            time: 0\n        };\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    update() {\n        if (this.pending) {\n            this.pending = null;\n            clearTimeout(this.restartTimeout);\n            this.restartTimeout = setTimeout(()=>this.startHover(), 20);\n        }\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (this.active.length) return;\n        let hovered = Date.now() - this.lastMove.time;\n        if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);\n        else this.startHover();\n    }\n    startHover() {\n        clearTimeout(this.restartTimeout);\n        let { view, lastMove } = this;\n        let desc = view.docView.nearest(lastMove.target);\n        if (!desc) return;\n        let pos, side = 1;\n        if (desc instanceof WidgetView) {\n            pos = desc.posAtStart;\n        } else {\n            pos = view.posAtCoords(lastMove);\n            if (pos == null) return;\n            let posCoords = view.coordsAtPos(pos);\n            if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;\n            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s)=>s.from <= pos && s.to >= pos);\n            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n            side = lastMove.x < posCoords.left ? -rtl : rtl;\n        }\n        let open = this.source(view, pos, side);\n        if (open === null || open === void 0 ? void 0 : open.then) {\n            let pending = this.pending = {\n                pos\n            };\n            open.then((result)=>{\n                if (this.pending == pending) {\n                    this.pending = null;\n                    if (result && !(Array.isArray(result) && !result.length)) view.dispatch({\n                        effects: this.setHover.of(Array.isArray(result) ? result : [\n                            result\n                        ])\n                    });\n                }\n            }, (e)=>logException(view.state, e, \"hover tooltip\"));\n        } else if (open && !(Array.isArray(open) && !open.length)) {\n            view.dispatch({\n                effects: this.setHover.of(Array.isArray(open) ? open : [\n                    open\n                ])\n            });\n        }\n    }\n    get tooltip() {\n        let plugin = this.view.plugin(tooltipPlugin);\n        let index = plugin ? plugin.manager.tooltips.findIndex((t)=>t.create == HoverTooltipHost.create) : -1;\n        return index > -1 ? plugin.manager.tooltipViews[index] : null;\n    }\n    mousemove(event) {\n        var _a, _b;\n        this.lastMove = {\n            x: event.clientX,\n            y: event.clientY,\n            target: event.target,\n            time: Date.now()\n        };\n        if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n        let { active, tooltip } = this;\n        if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {\n            let { pos } = active[0] || this.pending, end = (_b = (_a = active[0]) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : pos;\n            if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {\n                this.view.dispatch({\n                    effects: this.setHover.of([])\n                });\n                this.pending = null;\n            }\n        }\n    }\n    mouseleave(event) {\n        clearTimeout(this.hoverTimeout);\n        this.hoverTimeout = -1;\n        let { active } = this;\n        if (active.length) {\n            let { tooltip } = this;\n            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);\n            if (!inTooltip) this.view.dispatch({\n                effects: this.setHover.of([])\n            });\n            else this.watchTooltipLeave(tooltip.dom);\n        }\n    }\n    watchTooltipLeave(tooltip) {\n        let watch = (event)=>{\n            tooltip.removeEventListener(\"mouseleave\", watch);\n            if (this.active.length && !this.view.dom.contains(event.relatedTarget)) this.view.dispatch({\n                effects: this.setHover.of([])\n            });\n        };\n        tooltip.addEventListener(\"mouseleave\", watch);\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nconst tooltipMargin = 4;\nfunction isInTooltip(tooltip, event) {\n    let rect = tooltip.getBoundingClientRect();\n    return event.clientX >= rect.left - tooltipMargin && event.clientX <= rect.right + tooltipMargin && event.clientY >= rect.top - tooltipMargin && event.clientY <= rect.bottom + tooltipMargin;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;\n    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;\n    let pos = view.posAtCoords({\n        x,\n        y\n    }, false);\n    return pos >= from && pos <= to;\n}\n/**\nSet up a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos`, return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer is—it will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n*/ function hoverTooltip(source, options = {}) {\n    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n        create () {\n            return [];\n        },\n        update (value, tr) {\n            if (value.length) {\n                if (options.hideOnChange && (tr.docChanged || tr.selection)) value = [];\n                else if (options.hideOn) value = value.filter((v)=>!options.hideOn(tr, v));\n                if (tr.docChanged) {\n                    for (let tooltip of value){\n                        let newPos = tr.changes.mapPos(tooltip.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel);\n                        if (newPos != null) {\n                            let copy = Object.assign(Object.create(null), tooltip);\n                            copy.pos = newPos;\n                            if (copy.end != null) copy.end = tr.changes.mapPos(copy.end);\n                        }\n                    }\n                }\n            }\n            for (let effect of tr.effects){\n                if (effect.is(setHover)) value = effect.value;\n                if (effect.is(closeHoverTooltipEffect)) value = [];\n            }\n            return value;\n        },\n        provide: (f)=>showHoverTooltip.from(f)\n    });\n    return [\n        hoverState,\n        ViewPlugin.define((view)=>new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */ )),\n        showHoverTooltipHost\n    ];\n}\n/**\nGet the active tooltip view for a given tooltip, if available.\n*/ function getTooltip(view, tooltip) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (!plugin) return null;\n    let found = plugin.manager.tooltips.indexOf(tooltip);\n    return found < 0 ? null : plugin.manager.tooltipViews[found];\n}\n/**\nReturns true if any hover tooltips are currently active.\n*/ function hasHoverTooltips(state) {\n    return state.facet(showHoverTooltip).some((x)=>x);\n}\nconst closeHoverTooltipEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n/**\nTransaction effect that closes all hover tooltips.\n*/ const closeHoverTooltips = /*@__PURE__*/ closeHoverTooltipEffect.of(null);\n/**\nTell the tooltip extension to recompute the position of the active\ntooltips. This can be useful when something happens (such as a\nre-positioning or CSS change affecting the editor) that could\ninvalidate the existing tooltip positions.\n*/ function repositionTooltips(view) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (plugin) plugin.maybeMeasure();\n}\nconst panelConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        let topContainer, bottomContainer;\n        for (let c of configs){\n            topContainer = topContainer || c.topContainer;\n            bottomContainer = bottomContainer || c.bottomContainer;\n        }\n        return {\n            topContainer,\n            bottomContainer\n        };\n    }\n});\n/**\nConfigures the panel-managing extension.\n*/ function panels(config) {\n    return config ? [\n        panelConfig.of(config)\n    ] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/ function getPanel(view, panel) {\n    let plugin = view.plugin(panelPlugin);\n    let index = plugin ? plugin.specs.indexOf(panel) : -1;\n    return index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.input = view.state.facet(showPanel);\n        this.specs = this.input.filter((s)=>s);\n        this.panels = this.specs.map((spec)=>spec(view));\n        let conf = view.state.facet(panelConfig);\n        this.top = new PanelGroup(view, true, conf.topContainer);\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n        this.top.sync(this.panels.filter((p)=>p.top));\n        this.bottom.sync(this.panels.filter((p)=>!p.top));\n        for (let p of this.panels){\n            p.dom.classList.add(\"cm-panel\");\n            if (p.mount) p.mount();\n        }\n    }\n    update(update) {\n        let conf = update.state.facet(panelConfig);\n        if (this.top.container != conf.topContainer) {\n            this.top.sync([]);\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\n        }\n        if (this.bottom.container != conf.bottomContainer) {\n            this.bottom.sync([]);\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n        }\n        this.top.syncClasses();\n        this.bottom.syncClasses();\n        let input = update.state.facet(showPanel);\n        if (input != this.input) {\n            let specs = input.filter((x)=>x);\n            let panels = [], top = [], bottom = [], mount = [];\n            for (let spec of specs){\n                let known = this.specs.indexOf(spec), panel;\n                if (known < 0) {\n                    panel = spec(update.view);\n                    mount.push(panel);\n                } else {\n                    panel = this.panels[known];\n                    if (panel.update) panel.update(update);\n                }\n                panels.push(panel);\n                (panel.top ? top : bottom).push(panel);\n            }\n            this.specs = specs;\n            this.panels = panels;\n            this.top.sync(top);\n            this.bottom.sync(bottom);\n            for (let p of mount){\n                p.dom.classList.add(\"cm-panel\");\n                if (p.mount) p.mount();\n            }\n        } else {\n            for (let p of this.panels)if (p.update) p.update(update);\n        }\n    }\n    destroy() {\n        this.top.sync([]);\n        this.bottom.sync([]);\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            return value && {\n                top: value.top.scrollMargin(),\n                bottom: value.bottom.scrollMargin()\n            };\n        })\n});\nclass PanelGroup {\n    constructor(view, top, container){\n        this.view = view;\n        this.top = top;\n        this.container = container;\n        this.dom = undefined;\n        this.classes = \"\";\n        this.panels = [];\n        this.syncClasses();\n    }\n    sync(panels) {\n        for (let p of this.panels)if (p.destroy && panels.indexOf(p) < 0) p.destroy();\n        this.panels = panels;\n        this.syncDOM();\n    }\n    syncDOM() {\n        if (this.panels.length == 0) {\n            if (this.dom) {\n                this.dom.remove();\n                this.dom = undefined;\n            }\n            return;\n        }\n        if (!this.dom) {\n            this.dom = document.createElement(\"div\");\n            this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n            let parent = this.container || this.view.dom;\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n        }\n        let curDOM = this.dom.firstChild;\n        for (let panel of this.panels){\n            if (panel.dom.parentNode == this.dom) {\n                while(curDOM != panel.dom)curDOM = rm(curDOM);\n                curDOM = curDOM.nextSibling;\n            } else {\n                this.dom.insertBefore(panel.dom, curDOM);\n            }\n        }\n        while(curDOM)curDOM = rm(curDOM);\n    }\n    scrollMargin() {\n        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n    }\n    syncClasses() {\n        if (!this.container || this.classes == this.view.themeClasses) return;\n        for (let cls of this.classes.split(\" \"))if (cls) this.container.classList.remove(cls);\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))if (cls) this.container.classList.add(cls);\n    }\n}\nfunction rm(node) {\n    let next = node.nextSibling;\n    node.remove();\n    return next;\n}\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/ const showPanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: panelPlugin\n});\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/ class GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    Compare this marker to another marker of the same type.\n    */ eq(other) {\n        return false;\n    }\n    /**\n    Called if the marker has a `toDOM` method and its representation\n    was removed from a gutter.\n    */ destroy(dom) {}\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/ const gutterLineClass = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst defaults = {\n    class: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: ()=>_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty,\n    lineMarker: ()=>null,\n    widgetMarker: ()=>null,\n    lineMarkerChange: null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/ function gutter(config) {\n    return [\n        gutters(),\n        activeGutters.of(Object.assign(Object.assign({}, defaults), config))\n    ];\n}\nconst unfixGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/ function gutters(config) {\n    let result = [\n        gutterView\n    ];\n    if (config && config.fixed === false) result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.prevViewport = view.viewport;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutters\";\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\";\n        this.gutters = view.state.facet(activeGutters).map((conf)=>new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        this.syncGutters(false);\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    update(update) {\n        if (this.updateGutters(update)) {\n            // Detach during sync when the viewport changed significantly\n            // (such as during scrolling), since for large updates that is\n            // faster.\n            let vpA = this.prevViewport, vpB = update.view.viewport;\n            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n        }\n        if (update.geometryChanged) this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        if (this.view.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n        this.prevViewport = update.view.viewport;\n    }\n    syncGutters(detach) {\n        let after = this.dom.nextSibling;\n        if (detach) this.dom.remove();\n        let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n        let classSet = [];\n        let contexts = this.gutters.map((gutter)=>new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n        for (let line of this.view.viewportLineBlocks){\n            if (classSet.length) classSet = [];\n            if (Array.isArray(line.type)) {\n                let first = true;\n                for (let b of line.type){\n                    if (b.type == BlockType.Text && first) {\n                        advanceCursor(lineClasses, classSet, b.from);\n                        for (let cx of contexts)cx.line(this.view, b, classSet);\n                        first = false;\n                    } else if (b.widget) {\n                        for (let cx of contexts)cx.widget(this.view, b);\n                    }\n                }\n            } else if (line.type == BlockType.Text) {\n                advanceCursor(lineClasses, classSet, line.from);\n                for (let cx of contexts)cx.line(this.view, line, classSet);\n            } else if (line.widget) {\n                for (let cx of contexts)cx.widget(this.view, line);\n            }\n        }\n        for (let cx of contexts)cx.finish();\n        if (detach) this.view.scrollDOM.insertBefore(this.dom, after);\n    }\n    updateGutters(update) {\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged || !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n        if (prev == cur) {\n            for (let gutter of this.gutters)if (gutter.update(update)) change = true;\n        } else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur){\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                } else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters){\n                g.dom.remove();\n                if (gutters.indexOf(g) < 0) g.destroy();\n            }\n            for (let g of gutters)this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        for (let view of this.gutters)view.destroy();\n        this.dom.remove();\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            if (!value || value.gutters.length == 0 || !value.fixed) return null;\n            return view.textDirection == Direction.LTR ? {\n                left: value.dom.offsetWidth * view.scaleX\n            } : {\n                right: value.dom.offsetWidth * view.scaleX\n            };\n        })\n});\nfunction asArray(val) {\n    return Array.isArray(val) ? val : [\n        val\n    ];\n}\nfunction advanceCursor(cursor, collect, pos) {\n    while(cursor.value && cursor.from <= pos){\n        if (cursor.from == pos) collect.push(cursor.value);\n        cursor.next();\n    }\n}\nclass UpdateContext {\n    constructor(gutter, viewport, height){\n        this.gutter = gutter;\n        this.height = height;\n        this.i = 0;\n        this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(gutter.markers, viewport.from);\n    }\n    addElement(view, block, markers) {\n        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, height, above, markers);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        } else {\n            gutter.elements[this.i].update(view, height, above, markers);\n        }\n        this.height = block.bottom;\n        this.i++;\n    }\n    line(view, line, extraMarkers) {\n        let localMarkers = [];\n        advanceCursor(this.cursor, localMarkers, line.from);\n        if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);\n        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n        if (forLine) localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n        this.addElement(view, line, localMarkers);\n    }\n    widget(view, block) {\n        let marker = this.gutter.config.widgetMarker(view, block.widget, block);\n        if (marker) this.addElement(view, block, [\n            marker\n        ]);\n    }\n    finish() {\n        let gutter = this.gutter;\n        while(gutter.elements.length > this.i){\n            let last = gutter.elements.pop();\n            gutter.dom.removeChild(last.dom);\n            last.destroy();\n        }\n    }\n}\nclass SingleGutterView {\n    constructor(view, config){\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n        for(let prop in config.domEventHandlers){\n            this.dom.addEventListener(prop, (event)=>{\n                let target = event.target, y;\n                if (target != this.dom && this.dom.contains(target)) {\n                    while(target.parentNode != this.dom)target = target.parentNode;\n                    let rect = target.getBoundingClientRect();\n                    y = (rect.top + rect.bottom) / 2;\n                } else {\n                    y = event.clientY;\n                }\n                let line = view.lineBlockAtHeight(y - view.documentTop);\n                if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n            });\n        }\n        this.markers = asArray(config.markers(view));\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [\n                config.initialSpacer(view)\n            ]);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = asArray(this.config.markers(update.view));\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [\n                updated\n            ]);\n        }\n        let vp = update.view.viewport;\n        return !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n    }\n    destroy() {\n        for (let elt of this.elements)elt.destroy();\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers){\n        this.height = -1;\n        this.above = 0;\n        this.markers = [];\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutterElement\";\n        this.update(view, height, above, markers);\n    }\n    update(view, height, above, markers) {\n        if (this.height != height) {\n            this.height = height;\n            this.dom.style.height = height + \"px\";\n        }\n        if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n    }\n    setMarkers(view, markers) {\n        let cls = \"cm-gutterElement\", domPos = this.dom.firstChild;\n        for(let iNew = 0, iOld = 0;;){\n            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;\n            if (marker) {\n                let c = marker.elementClass;\n                if (c) cls += \" \" + c;\n                for(let i = iOld; i < this.markers.length; i++)if (this.markers[i].compare(marker)) {\n                    skipTo = i;\n                    matched = true;\n                    break;\n                }\n            } else {\n                skipTo = this.markers.length;\n            }\n            while(iOld < skipTo){\n                let next = this.markers[iOld++];\n                if (next.toDOM) {\n                    next.destroy(domPos);\n                    let after = domPos.nextSibling;\n                    domPos.remove();\n                    domPos = after;\n                }\n            }\n            if (!marker) break;\n            if (marker.toDOM) {\n                if (matched) domPos = domPos.nextSibling;\n                else this.dom.insertBefore(marker.toDOM(view), domPos);\n            }\n            if (matched) iOld++;\n        }\n        this.dom.className = cls;\n        this.markers = markers;\n    }\n    destroy() {\n        this.setMarkers(null, []); // First argument not used unless creating markers\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].compare(b[i])) return false;\n    return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/ const lineNumberMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst lineNumberConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(values, {\n            formatNumber: String,\n            domEventHandlers: {}\n        }, {\n            domEventHandlers (a, b) {\n                let result = Object.assign({}, a);\n                for(let event in b){\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event)=>exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number){\n        super();\n        this.number = number;\n    }\n    eq(other) {\n        return this.number == other.number;\n    }\n    toDOM() {\n        return document.createTextNode(this.number);\n    }\n}\nfunction formatNumber(view, number) {\n    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/ activeGutters.compute([\n    lineNumberConfig\n], (state)=>({\n        class: \"cm-lineNumbers\",\n        renderEmptyElements: false,\n        markers (view) {\n            return view.state.facet(lineNumberMarkers);\n        },\n        lineMarker (view, line, others) {\n            if (others.some((m)=>m.toDOM)) return null;\n            return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n        },\n        widgetMarker: ()=>null,\n        lineMarkerChange: (update)=>update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n        initialSpacer (view) {\n            return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n        },\n        updateSpacer (spacer, update) {\n            let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n            return max == spacer.number ? spacer : new NumberMarker(max);\n        },\n        domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n    }));\n/**\nCreate a line number gutter extension.\n*/ function lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        gutters(),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while(last < lines)last = last * 10 + 9;\n    return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/ new class extends GutterMarker {\n    constructor(){\n        super(...arguments);\n        this.elementClass = \"cm-activeLineGutter\";\n    }\n};\nconst activeLineGutterHighlighter = /*@__PURE__*/ gutterLineClass.compute([\n    \"selection\"\n], (state)=>{\n    let marks = [], last = -1;\n    for (let range of state.selection.ranges){\n        let linePos = state.doc.lineAt(range.head).from;\n        if (linePos > last) {\n            last = linePos;\n            marks.push(activeLineGutterMarker.range(linePos));\n        }\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/ function highlightActiveLineGutter() {\n    return activeLineGutterHighlighter;\n}\nconst WhitespaceDeco = /*@__PURE__*/ new Map();\nfunction getWhitespaceDeco(space) {\n    let deco = WhitespaceDeco.get(space);\n    if (!deco) WhitespaceDeco.set(space, deco = Decoration.mark({\n        attributes: space === \"\t\" ? {\n            class: \"cm-highlightTab\"\n        } : {\n            class: \"cm-highlightSpace\",\n            \"data-display\": space.replace(/ /g, \"\\xb7\")\n        }\n    }));\n    return deco;\n}\nfunction matcher(decorator) {\n    return ViewPlugin.define((view)=>({\n            decorations: decorator.createDeco(view),\n            update (u) {\n                this.decorations = decorator.updateDeco(u, this.decorations);\n            }\n        }), {\n        decorations: (v)=>v.decorations\n    });\n}\nconst whitespaceHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\t| +/g,\n    decoration: (match)=>getWhitespaceDeco(match[0]),\n    boundary: /\\S/\n}));\n/**\nReturns an extension that highlights whitespace, adding a\n`cm-highlightSpace` class to stretches of spaces, and a\n`cm-highlightTab` class to individual tab characters. By default,\nthe former are shown as faint dots, and the latter as arrows.\n*/ function highlightWhitespace() {\n    return whitespaceHighlighter;\n}\nconst trailingHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\s+$/g,\n    decoration: /*@__PURE__*/ Decoration.mark({\n        class: \"cm-trailingSpace\"\n    }),\n    boundary: /\\S/\n}));\n/**\nReturns an extension that adds a `cm-trailingSpace` class to all\ntrailing whitespace.\n*/ function highlightTrailingWhitespace() {\n    return trailingHighlighter;\n}\n/**\n@internal\n*/ const __test = {\n    HeightMap,\n    HeightOracle,\n    MeasuredHeights,\n    QueryType,\n    ChangedRange,\n    computeOrder,\n    moveVisually\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFTO0FBQzdQO0FBQ1c7QUFFbkQsU0FBU3lCLGFBQWFDLElBQUk7SUFDdEIsSUFBSUM7SUFDSiw4REFBOEQ7SUFDOUQsNERBQTREO0lBQzVELFlBQVk7SUFDWixJQUFJRCxLQUFLRSxRQUFRLElBQUksSUFBSTtRQUNyQkQsU0FBU0QsS0FBS0QsWUFBWSxHQUFHQyxPQUFPQSxLQUFLRyxhQUFhO0lBQzFELE9BQ0s7UUFDREYsU0FBU0Q7SUFDYjtJQUNBLE9BQU9DLE9BQU9GLFlBQVk7QUFDOUI7QUFDQSxTQUFTSyxTQUFTQyxHQUFHLEVBQUVDLElBQUk7SUFDdkIsT0FBT0EsT0FBT0QsT0FBT0MsUUFBUUQsSUFBSUQsUUFBUSxDQUFDRSxLQUFLSixRQUFRLElBQUksSUFBSUksS0FBS0MsVUFBVSxHQUFHRCxRQUFRO0FBQzdGO0FBQ0EsU0FBU0Usa0JBQWtCQyxHQUFHO0lBQzFCLElBQUlDLE1BQU1ELElBQUlFLGFBQWE7SUFDM0IsTUFBT0QsT0FBT0EsSUFBSUUsVUFBVSxDQUN4QkYsTUFBTUEsSUFBSUUsVUFBVSxDQUFDRCxhQUFhO0lBQ3RDLE9BQU9EO0FBQ1g7QUFDQSxTQUFTRyxhQUFhUixHQUFHLEVBQUVTLFNBQVM7SUFDaEMsSUFBSSxDQUFDQSxVQUFVQyxVQUFVLEVBQ3JCLE9BQU87SUFDWCxJQUFJO1FBQ0EsK0RBQStEO1FBQy9ELDhEQUE4RDtRQUM5RCxXQUFXO1FBQ1gsT0FBT1gsU0FBU0MsS0FBS1MsVUFBVUMsVUFBVTtJQUM3QyxFQUNBLE9BQU9DLEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNDLGVBQWVaLEdBQUc7SUFDdkIsSUFBSUEsSUFBSUgsUUFBUSxJQUFJLEdBQ2hCLE9BQU9nQixVQUFVYixLQUFLLEdBQUdBLElBQUljLFNBQVMsQ0FBQ0MsTUFBTSxFQUFFQyxjQUFjO1NBQzVELElBQUloQixJQUFJSCxRQUFRLElBQUksR0FDckIsT0FBT0csSUFBSWdCLGNBQWM7U0FFekIsT0FBTyxFQUFFO0FBQ2pCO0FBQ0EscUVBQXFFO0FBQ3JFLGtFQUFrRTtBQUNsRSw2Q0FBNkM7QUFDN0MsU0FBU0MscUJBQXFCaEIsSUFBSSxFQUFFaUIsR0FBRyxFQUFFQyxVQUFVLEVBQUVDLFNBQVM7SUFDMUQsT0FBT0QsYUFBY0UsUUFBUXBCLE1BQU1pQixLQUFLQyxZQUFZQyxXQUFXLENBQUMsTUFDNURDLFFBQVFwQixNQUFNaUIsS0FBS0MsWUFBWUMsV0FBVyxLQUFNO0FBQ3hEO0FBQ0EsU0FBU0UsU0FBU3JCLElBQUk7SUFDbEIsSUFBSyxJQUFJc0IsUUFBUSxJQUFJQSxRQUFTO1FBQzFCdEIsT0FBT0EsS0FBS3VCLGVBQWU7UUFDM0IsSUFBSSxDQUFDdkIsTUFDRCxPQUFPc0I7SUFDZjtBQUNKO0FBQ0EsU0FBU0YsUUFBUXBCLElBQUksRUFBRWlCLEdBQUcsRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQUVLLEdBQUc7SUFDbEQsT0FBUztRQUNMLElBQUl4QixRQUFRa0IsY0FBY0QsT0FBT0UsV0FDN0IsT0FBTztRQUNYLElBQUlGLE9BQVFPLENBQUFBLE1BQU0sSUFBSSxJQUFJQyxVQUFVekIsS0FBSSxHQUFJO1lBQ3hDLElBQUlBLEtBQUswQixRQUFRLElBQUksT0FDakIsT0FBTztZQUNYLElBQUlDLFNBQVMzQixLQUFLQyxVQUFVO1lBQzVCLElBQUksQ0FBQzBCLFVBQVVBLE9BQU8vQixRQUFRLElBQUksR0FDOUIsT0FBTztZQUNYcUIsTUFBTUksU0FBU3JCLFFBQVN3QixDQUFBQSxNQUFNLElBQUksSUFBSTtZQUN0Q3hCLE9BQU8yQjtRQUNYLE9BQ0ssSUFBSTNCLEtBQUtKLFFBQVEsSUFBSSxHQUFHO1lBQ3pCSSxPQUFPQSxLQUFLNEIsVUFBVSxDQUFDWCxNQUFPTyxDQUFBQSxNQUFNLElBQUksQ0FBQyxJQUFJLEdBQUc7WUFDaEQsSUFBSXhCLEtBQUtKLFFBQVEsSUFBSSxLQUFLSSxLQUFLNkIsZUFBZSxJQUFJLFNBQzlDLE9BQU87WUFDWFosTUFBTU8sTUFBTSxJQUFJQyxVQUFVekIsUUFBUTtRQUN0QyxPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLFNBQVN5QixVQUFVekIsSUFBSTtJQUNuQixPQUFPQSxLQUFLSixRQUFRLElBQUksSUFBSUksS0FBS2EsU0FBUyxDQUFDQyxNQUFNLEdBQUdkLEtBQUs0QixVQUFVLENBQUNkLE1BQU07QUFDOUU7QUFDQSxTQUFTZ0IsWUFBWUMsSUFBSSxFQUFFQyxJQUFJO0lBQzNCLElBQUlDLElBQUlELE9BQU9ELEtBQUtDLElBQUksR0FBR0QsS0FBS0csS0FBSztJQUNyQyxPQUFPO1FBQUVGLE1BQU1DO1FBQUdDLE9BQU9EO1FBQUdFLEtBQUtKLEtBQUtJLEdBQUc7UUFBRUMsUUFBUUwsS0FBS0ssTUFBTTtJQUFDO0FBQ25FO0FBQ0EsU0FBU0MsV0FBV0MsR0FBRztJQUNuQixPQUFPO1FBQUVOLE1BQU07UUFBR0UsT0FBT0ksSUFBSUMsVUFBVTtRQUNuQ0osS0FBSztRQUFHQyxRQUFRRSxJQUFJRSxXQUFXO0lBQUM7QUFDeEM7QUFDQSxTQUFTQyxTQUFTckMsR0FBRyxFQUFFMkIsSUFBSTtJQUN2QixJQUFJVyxTQUFTWCxLQUFLWSxLQUFLLEdBQUd2QyxJQUFJd0MsV0FBVztJQUN6QyxJQUFJQyxTQUFTZCxLQUFLZSxNQUFNLEdBQUcxQyxJQUFJMkMsWUFBWTtJQUMzQyxJQUFJTCxTQUFTLFNBQVNBLFNBQVMsU0FBUyxDQUFDTSxTQUFTTixXQUFXTyxLQUFLQyxHQUFHLENBQUNuQixLQUFLWSxLQUFLLEdBQUd2QyxJQUFJd0MsV0FBVyxJQUFJLEdBQ2xHRixTQUFTO0lBQ2IsSUFBSUcsU0FBUyxTQUFTQSxTQUFTLFNBQVMsQ0FBQ0csU0FBU0gsV0FBV0ksS0FBS0MsR0FBRyxDQUFDbkIsS0FBS2UsTUFBTSxHQUFHMUMsSUFBSTJDLFlBQVksSUFBSSxHQUNwR0YsU0FBUztJQUNiLE9BQU87UUFBRUg7UUFBUUc7SUFBTztBQUM1QjtBQUNBLFNBQVNNLG1CQUFtQnBELEdBQUcsRUFBRWdDLElBQUksRUFBRXFCLElBQUksRUFBRW5CLENBQUMsRUFBRW9CLENBQUMsRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLEdBQUc7SUFDcEUsSUFBSXJELE1BQU1KLElBQUlGLGFBQWEsRUFBRXlDLE1BQU1uQyxJQUFJc0QsV0FBVyxJQUFJQztJQUN0RCxJQUFLLElBQUlDLE1BQU01RCxLQUFLNkQsT0FBTyxPQUFPRCxPQUFPLENBQUNDLE1BQU87UUFDN0MsSUFBSUQsSUFBSS9ELFFBQVEsSUFBSSxHQUFHO1lBQ25CLElBQUlpRSxVQUFVMUIsTUFBTXdCLE9BQU94RCxJQUFJMkQsSUFBSTtZQUNuQyxJQUFJcEIsU0FBUyxHQUFHRyxTQUFTO1lBQ3pCLElBQUlWLEtBQUs7Z0JBQ0wwQixXQUFXeEIsV0FBV0M7WUFDMUIsT0FDSztnQkFDRCxJQUFJLG1CQUFtQnlCLElBQUksQ0FBQ0MsaUJBQWlCTCxLQUFLTSxRQUFRLEdBQ3RETCxPQUFPO2dCQUNYLElBQUlELElBQUlPLFlBQVksSUFBSVAsSUFBSVEsWUFBWSxJQUFJUixJQUFJUyxXQUFXLElBQUlULElBQUlVLFdBQVcsRUFBRTtvQkFDNUVWLE1BQU1BLElBQUlXLFlBQVksSUFBSVgsSUFBSTFELFVBQVU7b0JBQ3hDO2dCQUNKO2dCQUNBLElBQUk4QixPQUFPNEIsSUFBSVkscUJBQXFCO2dCQUNuQyxHQUFFN0IsTUFBTSxFQUFFRyxNQUFNLEVBQUUsR0FBR0osU0FBU2tCLEtBQUs1QixLQUFJO2dCQUN4Qyw0REFBNEQ7Z0JBQzVEOEIsV0FBVztvQkFBRTdCLE1BQU1ELEtBQUtDLElBQUk7b0JBQUVFLE9BQU9ILEtBQUtDLElBQUksR0FBRzJCLElBQUlVLFdBQVcsR0FBRzNCO29CQUMvRFAsS0FBS0osS0FBS0ksR0FBRztvQkFBRUMsUUFBUUwsS0FBS0ksR0FBRyxHQUFHd0IsSUFBSVEsWUFBWSxHQUFHdEI7Z0JBQU87WUFDcEU7WUFDQSxJQUFJMkIsUUFBUSxHQUFHQyxRQUFRO1lBQ3ZCLElBQUlwQixLQUFLLFdBQVc7Z0JBQ2hCLElBQUl0QixLQUFLSSxHQUFHLEdBQUcwQixTQUFTMUIsR0FBRyxFQUFFO29CQUN6QnNDLFFBQVEsQ0FBRVosQ0FBQUEsU0FBUzFCLEdBQUcsR0FBR0osS0FBS0ksR0FBRyxHQUFHb0IsT0FBTTtvQkFDMUMsSUFBSUgsT0FBTyxLQUFLckIsS0FBS0ssTUFBTSxHQUFHeUIsU0FBU3pCLE1BQU0sR0FBR3FDLE9BQzVDQSxRQUFRMUMsS0FBS0ssTUFBTSxHQUFHeUIsU0FBU3pCLE1BQU0sR0FBR3FDLFFBQVFsQjtnQkFDeEQsT0FDSyxJQUFJeEIsS0FBS0ssTUFBTSxHQUFHeUIsU0FBU3pCLE1BQU0sRUFBRTtvQkFDcENxQyxRQUFRMUMsS0FBS0ssTUFBTSxHQUFHeUIsU0FBU3pCLE1BQU0sR0FBR21CO29CQUN4QyxJQUFJSCxPQUFPLEtBQUssS0FBTWpCLEdBQUcsR0FBR3NDLFFBQVNaLFNBQVMxQixHQUFHLEVBQzdDc0MsUUFBUSxDQUFFWixDQUFBQSxTQUFTMUIsR0FBRyxHQUFHc0MsUUFBUTFDLEtBQUtJLEdBQUcsR0FBR29CLE9BQU07Z0JBQzFEO1lBQ0osT0FDSztnQkFDRCxJQUFJbUIsYUFBYTNDLEtBQUtLLE1BQU0sR0FBR0wsS0FBS0ksR0FBRyxFQUFFd0MsaUJBQWlCZCxTQUFTekIsTUFBTSxHQUFHeUIsU0FBUzFCLEdBQUc7Z0JBQ3hGLElBQUl5QyxZQUFZdkIsS0FBSyxZQUFZcUIsY0FBY0MsaUJBQWlCNUMsS0FBS0ksR0FBRyxHQUFHdUMsYUFBYSxJQUFJQyxpQkFBaUIsSUFDekd0QixLQUFLLFdBQVdBLEtBQUssWUFBWUQsT0FBTyxJQUFJckIsS0FBS0ksR0FBRyxHQUFHb0IsVUFDbkR4QixLQUFLSyxNQUFNLEdBQUd1QyxpQkFBaUJwQjtnQkFDdkNrQixRQUFRRyxZQUFZZixTQUFTMUIsR0FBRztZQUNwQztZQUNBLElBQUlGLEtBQUssV0FBVztnQkFDaEIsSUFBSUYsS0FBS0MsSUFBSSxHQUFHNkIsU0FBUzdCLElBQUksRUFBRTtvQkFDM0J3QyxRQUFRLENBQUVYLENBQUFBLFNBQVM3QixJQUFJLEdBQUdELEtBQUtDLElBQUksR0FBR3NCLE9BQU07b0JBQzVDLElBQUlGLE9BQU8sS0FBS3JCLEtBQUtHLEtBQUssR0FBRzJCLFNBQVMzQixLQUFLLEdBQUdzQyxPQUMxQ0EsUUFBUXpDLEtBQUtHLEtBQUssR0FBRzJCLFNBQVMzQixLQUFLLEdBQUdzQyxRQUFRbEI7Z0JBQ3RELE9BQ0ssSUFBSXZCLEtBQUtHLEtBQUssR0FBRzJCLFNBQVMzQixLQUFLLEVBQUU7b0JBQ2xDc0MsUUFBUXpDLEtBQUtHLEtBQUssR0FBRzJCLFNBQVMzQixLQUFLLEdBQUdvQjtvQkFDdEMsSUFBSUYsT0FBTyxLQUFLckIsS0FBS0MsSUFBSSxHQUFHNkIsU0FBUzdCLElBQUksR0FBR3dDLE9BQ3hDQSxRQUFRLENBQUVYLENBQUFBLFNBQVM3QixJQUFJLEdBQUd3QyxRQUFRekMsS0FBS0MsSUFBSSxHQUFHc0IsT0FBTTtnQkFDNUQ7WUFDSixPQUNLO2dCQUNELElBQUl1QixhQUFhNUMsS0FBSyxXQUFXRixLQUFLQyxJQUFJLEdBQUcsQ0FBQ0QsS0FBS0csS0FBSyxHQUFHSCxLQUFLQyxJQUFJLElBQUksSUFBSSxDQUFDNkIsU0FBUzNCLEtBQUssR0FBRzJCLFNBQVM3QixJQUFJLElBQUksSUFDM0csS0FBTSxXQUFZd0IsTUFBTXpCLEtBQUtDLElBQUksR0FBR3NCLFVBQ2hDdkIsS0FBS0csS0FBSyxHQUFJMkIsQ0FBQUEsU0FBUzNCLEtBQUssR0FBRzJCLFNBQVM3QixJQUFJLElBQUlzQjtnQkFDeERrQixRQUFRSyxhQUFhaEIsU0FBUzdCLElBQUk7WUFDdEM7WUFDQSxJQUFJd0MsU0FBU0MsT0FBTztnQkFDaEIsSUFBSXRDLEtBQUs7b0JBQ0xHLElBQUl3QyxRQUFRLENBQUNOLE9BQU9DO2dCQUN4QixPQUNLO29CQUNELElBQUlNLFNBQVMsR0FBR0MsU0FBUztvQkFDekIsSUFBSVAsT0FBTzt3QkFDUCxJQUFJUSxRQUFRdEIsSUFBSXVCLFNBQVM7d0JBQ3pCdkIsSUFBSXVCLFNBQVMsSUFBSVQsUUFBUTVCO3dCQUN6Qm1DLFNBQVMsQ0FBQ3JCLElBQUl1QixTQUFTLEdBQUdELEtBQUksSUFBS3BDO29CQUN2QztvQkFDQSxJQUFJMkIsT0FBTzt3QkFDUCxJQUFJUyxRQUFRdEIsSUFBSXdCLFVBQVU7d0JBQzFCeEIsSUFBSXdCLFVBQVUsSUFBSVgsUUFBUTlCO3dCQUMxQnFDLFNBQVMsQ0FBQ3BCLElBQUl3QixVQUFVLEdBQUdGLEtBQUksSUFBS3ZDO29CQUN4QztvQkFDQVgsT0FBTzt3QkFBRUMsTUFBTUQsS0FBS0MsSUFBSSxHQUFHK0M7d0JBQVE1QyxLQUFLSixLQUFLSSxHQUFHLEdBQUc2Qzt3QkFDL0M5QyxPQUFPSCxLQUFLRyxLQUFLLEdBQUc2Qzt3QkFBUTNDLFFBQVFMLEtBQUtLLE1BQU0sR0FBRzRDO29CQUFPO29CQUM3RCxJQUFJRCxVQUFVOUIsS0FBS0MsR0FBRyxDQUFDNkIsU0FBU1AsU0FBUyxHQUNyQ3ZDLElBQUk7b0JBQ1IsSUFBSStDLFVBQVUvQixLQUFLQyxHQUFHLENBQUM4QixTQUFTUCxTQUFTLEdBQ3JDcEIsSUFBSTtnQkFDWjtZQUNKO1lBQ0EsSUFBSWxCLEtBQ0E7WUFDSndCLE1BQU1BLElBQUlXLFlBQVksSUFBSVgsSUFBSTFELFVBQVU7UUFDNUMsT0FDSyxJQUFJMEQsSUFBSS9ELFFBQVEsSUFBSSxJQUFJO1lBQ3pCK0QsTUFBTUEsSUFBSXlCLElBQUk7UUFDbEIsT0FDSztZQUNEO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBU0MsaUJBQWlCdEYsR0FBRztJQUN6QixJQUFJSSxNQUFNSixJQUFJRixhQUFhO0lBQzNCLElBQUssSUFBSThELE1BQU01RCxJQUFJRSxVQUFVLEVBQUUwRCxLQUFNO1FBQ2pDLElBQUlBLE9BQU94RCxJQUFJMkQsSUFBSSxFQUFFO1lBQ2pCO1FBQ0osT0FDSyxJQUFJSCxJQUFJL0QsUUFBUSxJQUFJLEdBQUc7WUFDeEIsSUFBSStELElBQUlPLFlBQVksR0FBR1AsSUFBSVEsWUFBWSxJQUFJUixJQUFJUyxXQUFXLEdBQUdULElBQUlVLFdBQVcsRUFDeEUsT0FBT1Y7WUFDWEEsTUFBTUEsSUFBSVcsWUFBWSxJQUFJWCxJQUFJMUQsVUFBVTtRQUM1QyxPQUNLLElBQUkwRCxJQUFJL0QsUUFBUSxJQUFJLElBQUk7WUFDekIrRCxNQUFNQSxJQUFJeUIsSUFBSTtRQUNsQixPQUNLO1lBQ0Q7UUFDSjtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0EsTUFBTUU7SUFDRkMsYUFBYztRQUNWLElBQUksQ0FBQzlFLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUMrRSxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7SUFDdkI7SUFDQUMsR0FBR0MsTUFBTSxFQUFFO1FBQ1AsT0FBTyxJQUFJLENBQUNuRixVQUFVLElBQUltRixPQUFPbkYsVUFBVSxJQUFJLElBQUksQ0FBQytFLFlBQVksSUFBSUksT0FBT0osWUFBWSxJQUNuRixJQUFJLENBQUNDLFNBQVMsSUFBSUcsT0FBT0gsU0FBUyxJQUFJLElBQUksQ0FBQ0MsV0FBVyxJQUFJRSxPQUFPRixXQUFXO0lBQ3BGO0lBQ0FHLFNBQVNDLEtBQUssRUFBRTtRQUNaLElBQUksRUFBRXJGLFVBQVUsRUFBRWdGLFNBQVMsRUFBRSxHQUFHSztRQUNoQyx1RkFBdUY7UUFDdkYsSUFBSSxDQUFDQyxHQUFHLENBQUN0RixZQUFZd0MsS0FBSytDLEdBQUcsQ0FBQ0YsTUFBTU4sWUFBWSxFQUFFL0UsYUFBYWdCLFVBQVVoQixjQUFjLElBQUlnRixXQUFXeEMsS0FBSytDLEdBQUcsQ0FBQ0YsTUFBTUosV0FBVyxFQUFFRCxZQUFZaEUsVUFBVWdFLGFBQWE7SUFDeks7SUFDQU0sSUFBSXRGLFVBQVUsRUFBRStFLFlBQVksRUFBRUMsU0FBUyxFQUFFQyxXQUFXLEVBQUU7UUFDbEQsSUFBSSxDQUFDakYsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUMrRSxZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFdBQVcsR0FBR0E7SUFDdkI7QUFDSjtBQUNBLElBQUlPLHlCQUF5QjtBQUM3QixzRUFBc0U7QUFDdEUsd0NBQXdDO0FBQ3hDLFNBQVNDLG1CQUFtQm5HLEdBQUc7SUFDM0IsSUFBSUEsSUFBSW9HLFNBQVMsRUFDYixPQUFPcEcsSUFBSW9HLFNBQVMsSUFBSSxRQUFRO0lBQ3BDLElBQUlGLHdCQUNBLE9BQU9sRyxJQUFJcUcsS0FBSyxDQUFDSDtJQUNyQixJQUFJSSxRQUFRLEVBQUU7SUFDZCxJQUFLLElBQUkxQyxNQUFNNUQsS0FBSzRELEtBQUtBLE1BQU1BLElBQUkxRCxVQUFVLENBQUU7UUFDM0NvRyxNQUFNQyxJQUFJLENBQUMzQyxLQUFLQSxJQUFJdUIsU0FBUyxFQUFFdkIsSUFBSXdCLFVBQVU7UUFDN0MsSUFBSXhCLE9BQU9BLElBQUk5RCxhQUFhLEVBQ3hCO0lBQ1I7SUFDQUUsSUFBSXFHLEtBQUssQ0FBQ0gsMEJBQTBCLE9BQU87UUFDdkMsSUFBSU0saUJBQWdCO1lBQ2hCTix5QkFBeUI7Z0JBQUVNLGVBQWU7WUFBSztZQUMvQyxPQUFPO1FBQ1g7SUFDSixJQUFJQztJQUNKLElBQUksQ0FBQ1Asd0JBQXdCO1FBQ3pCQSx5QkFBeUI7UUFDekIsSUFBSyxJQUFJUSxJQUFJLEdBQUdBLElBQUlKLE1BQU12RixNQUFNLEVBQUc7WUFDL0IsSUFBSVYsTUFBTWlHLEtBQUssQ0FBQ0ksSUFBSSxFQUFFdEUsTUFBTWtFLEtBQUssQ0FBQ0ksSUFBSSxFQUFFekUsT0FBT3FFLEtBQUssQ0FBQ0ksSUFBSTtZQUN6RCxJQUFJckcsSUFBSThFLFNBQVMsSUFBSS9DLEtBQ2pCL0IsSUFBSThFLFNBQVMsR0FBRy9DO1lBQ3BCLElBQUkvQixJQUFJK0UsVUFBVSxJQUFJbkQsTUFDbEI1QixJQUFJK0UsVUFBVSxHQUFHbkQ7UUFDekI7SUFDSjtBQUNKO0FBQ0EsSUFBSTBFO0FBQ0osU0FBUzlGLFVBQVVaLElBQUksRUFBRTJHLElBQUksRUFBRUMsS0FBS0QsSUFBSTtJQUNwQyxJQUFJYixRQUFRWSxnQkFBaUJBLENBQUFBLGVBQWVHLFNBQVNDLFdBQVcsRUFBQztJQUNqRWhCLE1BQU1pQixNQUFNLENBQUMvRyxNQUFNNEc7SUFDbkJkLE1BQU1rQixRQUFRLENBQUNoSCxNQUFNMkc7SUFDckIsT0FBT2I7QUFDWDtBQUNBLFNBQVNtQixZQUFZN0csR0FBRyxFQUFFOEcsSUFBSSxFQUFFQyxJQUFJO0lBQ2hDLElBQUlDLFVBQVU7UUFBRUMsS0FBS0g7UUFBTUMsTUFBTUQ7UUFBTUksU0FBU0g7UUFBTUksT0FBT0o7UUFBTUssWUFBWTtJQUFLO0lBQ3BGLElBQUlDLE9BQU8sSUFBSUMsY0FBYyxXQUFXTjtJQUN4Q0ssS0FBS0UsU0FBUyxHQUFHO0lBQ2pCdkgsSUFBSXdILGFBQWEsQ0FBQ0g7SUFDbEIsSUFBSUksS0FBSyxJQUFJSCxjQUFjLFNBQVNOO0lBQ3BDUyxHQUFHRixTQUFTLEdBQUc7SUFDZnZILElBQUl3SCxhQUFhLENBQUNDO0lBQ2xCLE9BQU9KLEtBQUtLLGdCQUFnQixJQUFJRCxHQUFHQyxnQkFBZ0I7QUFDdkQ7QUFDQSxTQUFTQyxRQUFRL0gsSUFBSTtJQUNqQixNQUFPQSxLQUFNO1FBQ1QsSUFBSUEsUUFBU0EsQ0FBQUEsS0FBS0osUUFBUSxJQUFJLEtBQUtJLEtBQUtKLFFBQVEsSUFBSSxNQUFNSSxLQUFLb0YsSUFBSSxHQUMvRCxPQUFPcEY7UUFDWEEsT0FBT0EsS0FBS3NFLFlBQVksSUFBSXRFLEtBQUtDLFVBQVU7SUFDL0M7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTK0gsZ0JBQWdCaEksSUFBSTtJQUN6QixNQUFPQSxLQUFLaUksVUFBVSxDQUFDbkgsTUFBTSxDQUN6QmQsS0FBS2tJLG1CQUFtQixDQUFDbEksS0FBS2lJLFVBQVUsQ0FBQyxFQUFFO0FBQ25EO0FBQ0EsU0FBU0UsZUFBZWhJLEdBQUcsRUFBRUssU0FBUztJQUNsQyxJQUFJUixPQUFPUSxVQUFVaUYsU0FBUyxFQUFFMkMsU0FBUzVILFVBQVVrRixXQUFXO0lBQzlELElBQUksQ0FBQzFGLFFBQVFRLFVBQVVDLFVBQVUsSUFBSVQsUUFBUVEsVUFBVWdGLFlBQVksSUFBSTRDLFFBQ25FLE9BQU87SUFDWCwwQ0FBMEM7SUFDMUNBLFNBQVNuRixLQUFLK0MsR0FBRyxDQUFDb0MsUUFBUTNHLFVBQVV6QjtJQUNwQyxPQUFTO1FBQ0wsSUFBSW9JLFFBQVE7WUFDUixJQUFJcEksS0FBS0osUUFBUSxJQUFJLEdBQ2pCLE9BQU87WUFDWCxJQUFJeUksT0FBT3JJLEtBQUs0QixVQUFVLENBQUN3RyxTQUFTLEVBQUU7WUFDdEMsSUFBSUMsS0FBS3hHLGVBQWUsSUFBSSxTQUN4QnVHO2lCQUNDO2dCQUNEcEksT0FBT3FJO2dCQUNQRCxTQUFTM0csVUFBVXpCO1lBQ3ZCO1FBQ0osT0FDSyxJQUFJQSxRQUFRRyxLQUFLO1lBQ2xCLE9BQU87UUFDWCxPQUNLO1lBQ0RpSSxTQUFTL0csU0FBU3JCO1lBQ2xCQSxPQUFPQSxLQUFLQyxVQUFVO1FBQzFCO0lBQ0o7QUFDSjtBQUNBLFNBQVNxSSxtQkFBbUJsSSxHQUFHO0lBQzNCLE9BQU9BLElBQUk4RSxTQUFTLEdBQUdqQyxLQUFLc0YsR0FBRyxDQUFDLEdBQUduSSxJQUFJOEQsWUFBWSxHQUFHOUQsSUFBSStELFlBQVksR0FBRztBQUM3RTtBQUVBLE1BQU1xRTtJQUNGakQsWUFBWXZGLElBQUksRUFBRW9JLE1BQU0sRUFBRUssVUFBVSxJQUFJLENBQUU7UUFDdEMsSUFBSSxDQUFDekksSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ29JLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNLLE9BQU8sR0FBR0E7SUFDbkI7SUFDQSxPQUFPQyxPQUFPM0ksR0FBRyxFQUFFMEksT0FBTyxFQUFFO1FBQUUsT0FBTyxJQUFJRCxPQUFPekksSUFBSUUsVUFBVSxFQUFFb0IsU0FBU3RCLE1BQU0wSTtJQUFVO0lBQ3pGLE9BQU9FLE1BQU01SSxHQUFHLEVBQUUwSSxPQUFPLEVBQUU7UUFBRSxPQUFPLElBQUlELE9BQU96SSxJQUFJRSxVQUFVLEVBQUVvQixTQUFTdEIsT0FBTyxHQUFHMEk7SUFBVTtBQUNoRztBQUNBLE1BQU1HLGFBQWEsRUFBRTtBQUNyQixNQUFNQztJQUNGdEQsYUFBYztRQUNWLElBQUksQ0FBQzVELE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQzVCLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQytJLEtBQUssR0FBRyxFQUFFLHNCQUFzQjtJQUN6QztJQUNBLElBQUlDLGtCQUFrQjtRQUFFLE9BQU87SUFBTTtJQUNyQyxJQUFJQyxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUNySCxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUNzSCxTQUFTLENBQUMsSUFBSSxJQUFJO0lBQ3ZEO0lBQ0EsSUFBSUMsV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDRixVQUFVLEdBQUcsSUFBSSxDQUFDbEksTUFBTTtJQUN4QztJQUNBbUksVUFBVUUsSUFBSSxFQUFFO1FBQ1osSUFBSUMsTUFBTSxJQUFJLENBQUNKLFVBQVU7UUFDekIsS0FBSyxJQUFJSyxTQUFTLElBQUksQ0FBQ0MsUUFBUSxDQUFFO1lBQzdCLElBQUlELFNBQVNGLE1BQ1QsT0FBT0M7WUFDWEEsT0FBT0MsTUFBTXZJLE1BQU0sR0FBR3VJLE1BQU1FLFVBQVU7UUFDMUM7UUFDQSxNQUFNLElBQUlDLFdBQVc7SUFDekI7SUFDQUMsU0FBU04sSUFBSSxFQUFFO1FBQ1gsT0FBTyxJQUFJLENBQUNGLFNBQVMsQ0FBQ0UsUUFBUUEsS0FBS3JJLE1BQU07SUFDN0M7SUFDQTRJLEtBQUtQLElBQUksRUFBRVEsS0FBSyxFQUFFO1FBQ2QsSUFBSSxJQUFJLENBQUNiLEtBQUssR0FBRyxFQUFFLHNCQUFzQixLQUFJO1lBQ3pDLElBQUluSCxTQUFTLElBQUksQ0FBQzVCLEdBQUc7WUFDckIsSUFBSXNJLE9BQU8sTUFBTXVCO1lBQ2pCLEtBQUssSUFBSVAsU0FBUyxJQUFJLENBQUNDLFFBQVEsQ0FBRTtnQkFDN0IsSUFBSUQsTUFBTVAsS0FBSyxHQUFHLEVBQUUsa0JBQWtCLEtBQUk7b0JBQ3RDLElBQUksQ0FBQ08sTUFBTXRKLEdBQUcsSUFBSzZKLENBQUFBLE9BQU92QixPQUFPQSxLQUFLd0IsV0FBVyxHQUFHbEksT0FBT21JLFVBQVUsR0FBRzt3QkFDcEUsSUFBSUMsY0FBY2xCLFlBQVltQixHQUFHLENBQUNKO3dCQUNsQyxJQUFJLENBQUNHLGVBQWUsQ0FBQ0EsWUFBWXBJLE1BQU0sSUFBSW9JLFlBQVlFLFdBQVcsQ0FBQ1osUUFDL0RBLE1BQU1hLFFBQVEsQ0FBQ047b0JBQ3ZCO29CQUNBUCxNQUFNSyxJQUFJLENBQUNQLE1BQU1RO29CQUNqQk4sTUFBTVAsS0FBSyxJQUFJLENBQUMsRUFBRSxrQkFBa0I7Z0JBQ3hDO2dCQUNBYyxPQUFPdkIsT0FBT0EsS0FBS3dCLFdBQVcsR0FBR2xJLE9BQU9tSSxVQUFVO2dCQUNsRCxJQUFJSCxTQUFTLENBQUNBLE1BQU1RLE9BQU8sSUFBSVIsTUFBTTNKLElBQUksSUFBSTJCLFVBQVVpSSxRQUFRUCxNQUFNdEosR0FBRyxFQUNwRTRKLE1BQU1RLE9BQU8sR0FBRztnQkFDcEIsSUFBSWQsTUFBTXRKLEdBQUcsQ0FBQ0UsVUFBVSxJQUFJMEIsUUFBUTtvQkFDaEMsTUFBT2lJLFFBQVFBLFFBQVFQLE1BQU10SixHQUFHLENBQzVCNkosT0FBT1EsS0FBS1I7Z0JBQ3BCLE9BQ0s7b0JBQ0RqSSxPQUFPMEksWUFBWSxDQUFDaEIsTUFBTXRKLEdBQUcsRUFBRTZKO2dCQUNuQztnQkFDQXZCLE9BQU9nQixNQUFNdEosR0FBRztZQUNwQjtZQUNBNkosT0FBT3ZCLE9BQU9BLEtBQUt3QixXQUFXLEdBQUdsSSxPQUFPbUksVUFBVTtZQUNsRCxJQUFJRixRQUFRRCxTQUFTQSxNQUFNM0osSUFBSSxJQUFJMkIsUUFDL0JnSSxNQUFNUSxPQUFPLEdBQUc7WUFDcEIsTUFBT1AsS0FDSEEsT0FBT1EsS0FBS1I7UUFDcEIsT0FDSyxJQUFJLElBQUksQ0FBQ2QsS0FBSyxHQUFHLEVBQUUsdUJBQXVCLEtBQUk7WUFDL0MsS0FBSyxJQUFJTyxTQUFTLElBQUksQ0FBQ0MsUUFBUSxDQUMzQixJQUFJRCxNQUFNUCxLQUFLLEdBQUcsRUFBRSxrQkFBa0IsS0FBSTtnQkFDdENPLE1BQU1LLElBQUksQ0FBQ1AsTUFBTVE7Z0JBQ2pCTixNQUFNUCxLQUFLLElBQUksQ0FBQyxFQUFFLGtCQUFrQjtZQUN4QztRQUNSO0lBQ0o7SUFDQW9CLFNBQVNJLElBQUksRUFBRSxDQUFFO0lBQ2pCQyxnQkFBZ0J2SyxJQUFJLEVBQUVvSSxNQUFNLEVBQUU7UUFDMUIsSUFBSU87UUFDSixJQUFJM0ksUUFBUSxJQUFJLENBQUNELEdBQUcsRUFBRTtZQUNsQjRJLFFBQVEsSUFBSSxDQUFDNUksR0FBRyxDQUFDNkIsVUFBVSxDQUFDd0csT0FBTztRQUN2QyxPQUNLO1lBQ0QsSUFBSW9DLE9BQU8vSSxVQUFVekIsU0FBUyxJQUFJLElBQUlvSSxVQUFVLElBQUksQ0FBQyxJQUFJO1lBQ3pELE9BQVM7Z0JBQ0wsSUFBSXpHLFNBQVMzQixLQUFLQyxVQUFVO2dCQUM1QixJQUFJMEIsVUFBVSxJQUFJLENBQUM1QixHQUFHLEVBQ2xCO2dCQUNKLElBQUl5SyxRQUFRLEtBQUs3SSxPQUFPbUksVUFBVSxJQUFJbkksT0FBTzhJLFNBQVMsRUFBRTtvQkFDcEQsSUFBSXpLLFFBQVEyQixPQUFPbUksVUFBVSxFQUN6QlUsT0FBTyxDQUFDO3lCQUVSQSxPQUFPO2dCQUNmO2dCQUNBeEssT0FBTzJCO1lBQ1g7WUFDQSxJQUFJNkksT0FBTyxHQUNQN0IsUUFBUTNJO2lCQUVSMkksUUFBUTNJLEtBQUs2SixXQUFXO1FBQ2hDO1FBQ0EsSUFBSWxCLFNBQVMsSUFBSSxDQUFDNUksR0FBRyxDQUFDK0osVUFBVSxFQUM1QixPQUFPO1FBQ1gsTUFBT25CLFNBQVMsQ0FBQ0UsWUFBWW1CLEdBQUcsQ0FBQ3JCLE9BQzdCQSxRQUFRQSxNQUFNa0IsV0FBVztRQUM3QixJQUFJLENBQUNsQixPQUNELE9BQU8sSUFBSSxDQUFDN0gsTUFBTTtRQUN0QixJQUFLLElBQUkyRixJQUFJLEdBQUcyQyxNQUFNLElBQUkzQyxJQUFLO1lBQzNCLElBQUk0QyxRQUFRLElBQUksQ0FBQ0MsUUFBUSxDQUFDN0MsRUFBRTtZQUM1QixJQUFJNEMsTUFBTXRKLEdBQUcsSUFBSTRJLE9BQ2IsT0FBT1M7WUFDWEEsT0FBT0MsTUFBTXZJLE1BQU0sR0FBR3VJLE1BQU1FLFVBQVU7UUFDMUM7SUFDSjtJQUNBbUIsZ0JBQWdCL0QsSUFBSSxFQUFFQyxFQUFFLEVBQUV3QixTQUFTLENBQUMsRUFBRTtRQUNsQyxJQUFJdUMsUUFBUSxDQUFDLEdBQUdDLFlBQVksQ0FBQyxHQUFHQyxNQUFNLENBQUMsR0FBR0MsUUFBUSxDQUFDO1FBQ25ELElBQUssSUFBSXJFLElBQUksR0FBRzJDLE1BQU1oQixRQUFRMkMsVUFBVTNDLFFBQVEzQixJQUFJLElBQUksQ0FBQzZDLFFBQVEsQ0FBQ3hJLE1BQU0sRUFBRTJGLElBQUs7WUFDM0UsSUFBSTRDLFFBQVEsSUFBSSxDQUFDQyxRQUFRLENBQUM3QyxFQUFFLEVBQUV1RSxNQUFNNUIsTUFBTUMsTUFBTXZJLE1BQU07WUFDdEQsSUFBSXNJLE1BQU16QyxRQUFRcUUsTUFBTXBFLElBQ3BCLE9BQU95QyxNQUFNcUIsZUFBZSxDQUFDL0QsTUFBTUMsSUFBSXdDO1lBQzNDLElBQUk0QixPQUFPckUsUUFBUWdFLFNBQVMsQ0FBQyxHQUFHO2dCQUM1QkEsUUFBUWxFO2dCQUNSbUUsWUFBWXhCO1lBQ2hCO1lBQ0EsSUFBSUEsTUFBTXhDLE1BQU15QyxNQUFNdEosR0FBRyxDQUFDRSxVQUFVLElBQUksSUFBSSxDQUFDRixHQUFHLEVBQUU7Z0JBQzlDOEssTUFBTXBFO2dCQUNOcUUsUUFBUUM7Z0JBQ1I7WUFDSjtZQUNBQSxVQUFVQztZQUNWNUIsTUFBTTRCLE1BQU0zQixNQUFNRSxVQUFVO1FBQ2hDO1FBQ0EsT0FBTztZQUFFNUMsTUFBTWlFO1lBQVdoRSxJQUFJa0UsUUFBUSxJQUFJMUMsU0FBUyxJQUFJLENBQUN0SCxNQUFNLEdBQUdnSztZQUM3REcsVUFBVSxDQUFDTixRQUFRLElBQUksQ0FBQ3JCLFFBQVEsQ0FBQ3FCLFFBQVEsRUFBRSxDQUFDNUssR0FBRyxDQUFDOEosV0FBVyxHQUFHLElBQUcsS0FBTSxJQUFJLENBQUM5SixHQUFHLENBQUMrSixVQUFVO1lBQzFGb0IsUUFBUUwsTUFBTSxJQUFJLENBQUN2QixRQUFRLENBQUN4SSxNQUFNLElBQUkrSixPQUFPLElBQUksSUFBSSxDQUFDdkIsUUFBUSxDQUFDdUIsSUFBSSxDQUFDOUssR0FBRyxHQUFHO1FBQUs7SUFDdkY7SUFDQW9MLFVBQVVDLFlBQVksS0FBSyxFQUFFO1FBQ3pCLElBQUksQ0FBQ3RDLEtBQUssSUFBSSxFQUFFLHNCQUFzQjtRQUN0QyxJQUFJLENBQUN1QyxnQkFBZ0IsQ0FBQ0Q7SUFDMUI7SUFDQUMsaUJBQWlCQyxTQUFTLEVBQUU7UUFDeEIsSUFBSyxJQUFJM0osU0FBUyxJQUFJLENBQUNBLE1BQU0sRUFBRUEsUUFBUUEsU0FBU0EsT0FBT0EsTUFBTSxDQUFFO1lBQzNELElBQUkySixXQUNBM0osT0FBT21ILEtBQUssSUFBSSxFQUFFLHNCQUFzQjtZQUM1QyxJQUFJbkgsT0FBT21ILEtBQUssR0FBRyxFQUFFLHVCQUF1QixLQUN4QztZQUNKbkgsT0FBT21ILEtBQUssSUFBSSxFQUFFLHVCQUF1QjtZQUN6Q3dDLFlBQVk7UUFDaEI7SUFDSjtJQUNBQyxVQUFVNUosTUFBTSxFQUFFO1FBQ2QsSUFBSSxJQUFJLENBQUNBLE1BQU0sSUFBSUEsUUFBUTtZQUN2QixJQUFJLENBQUNBLE1BQU0sR0FBR0E7WUFDZCxJQUFJLElBQUksQ0FBQ21ILEtBQUssR0FBRyxFQUFFLGtCQUFrQixLQUNqQyxJQUFJLENBQUN1QyxnQkFBZ0IsQ0FBQztRQUM5QjtJQUNKO0lBQ0FHLE9BQU96TCxHQUFHLEVBQUU7UUFDUixJQUFJLElBQUksQ0FBQ0EsR0FBRyxJQUFJQSxLQUNaO1FBQ0osSUFBSSxJQUFJLENBQUNBLEdBQUcsRUFDUixJQUFJLENBQUNBLEdBQUcsQ0FBQzBMLE1BQU0sR0FBRztRQUN0QixJQUFJLENBQUMxTCxHQUFHLEdBQUdBO1FBQ1hBLElBQUkwTCxNQUFNLEdBQUcsSUFBSTtJQUNyQjtJQUNBLElBQUlDLFdBQVc7UUFDWCxJQUFLLElBQUlDLElBQUksSUFBSSxHQUFJO1lBQ2pCLElBQUloSyxTQUFTZ0ssRUFBRWhLLE1BQU07WUFDckIsSUFBSSxDQUFDQSxRQUNELE9BQU9nSztZQUNYQSxJQUFJaEs7UUFDUjtJQUNKO0lBQ0FpSyxnQkFBZ0JqRixJQUFJLEVBQUVDLEVBQUUsRUFBRTBDLFdBQVdWLFVBQVUsRUFBRTtRQUM3QyxJQUFJLENBQUN1QyxTQUFTO1FBQ2QsSUFBSyxJQUFJMUUsSUFBSUUsTUFBTUYsSUFBSUcsSUFBSUgsSUFBSztZQUM1QixJQUFJNEMsUUFBUSxJQUFJLENBQUNDLFFBQVEsQ0FBQzdDLEVBQUU7WUFDNUIsSUFBSTRDLE1BQU0xSCxNQUFNLElBQUksSUFBSSxJQUFJMkgsU0FBU3VDLE9BQU8sQ0FBQ3hDLFNBQVMsR0FDbERBLE1BQU15QyxPQUFPO1FBQ3JCO1FBQ0EsSUFBSSxDQUFDeEMsUUFBUSxDQUFDeUMsTUFBTSxDQUFDcEYsTUFBTUMsS0FBS0QsU0FBUzJDO1FBQ3pDLElBQUssSUFBSTdDLElBQUksR0FBR0EsSUFBSTZDLFNBQVN4SSxNQUFNLEVBQUUyRixJQUNqQzZDLFFBQVEsQ0FBQzdDLEVBQUUsQ0FBQzhFLFNBQVMsQ0FBQyxJQUFJO0lBQ2xDO0lBQ0FTLGVBQWVDLElBQUksRUFBRTtRQUFFLE9BQU87SUFBTztJQUNyQ0MsWUFBWUMsTUFBTSxFQUFFO1FBQUUsT0FBTztJQUFPO0lBQ3BDQyxZQUFZaEQsTUFBTSxJQUFJLENBQUN0SSxNQUFNLEVBQUU7UUFDM0IsT0FBTyxJQUFJdUwsWUFBWSxJQUFJLENBQUMvQyxRQUFRLEVBQUVGLEtBQUssSUFBSSxDQUFDRSxRQUFRLENBQUN4SSxNQUFNO0lBQ25FO0lBQ0F3TCxTQUFTbEQsR0FBRyxFQUFFb0IsT0FBTyxDQUFDLEVBQUU7UUFDcEIsT0FBTyxJQUFJLENBQUM0QixXQUFXLEdBQUdHLE9BQU8sQ0FBQ25ELEtBQUtvQjtJQUMzQztJQUNBZ0MsV0FBVztRQUNQLElBQUl0RixPQUFPLElBQUksQ0FBQzNCLFdBQVcsQ0FBQzJCLElBQUksQ0FBQ3VGLE9BQU8sQ0FBQyxRQUFRO1FBQ2pELE9BQU92RixPQUFRLEtBQUksQ0FBQ29DLFFBQVEsQ0FBQ3hJLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQ3dJLFFBQVEsQ0FBQ29ELElBQUksS0FBSyxNQUMvRCxJQUFJLENBQUM1TCxNQUFNLEdBQUcsTUFBT29HLENBQUFBLFFBQVEsU0FBUyxJQUFJLENBQUN5RixJQUFJLEdBQUcsSUFBSSxDQUFDN0wsTUFBTSxJQUFJLE1BQU0sRUFBQyxJQUN2RSxLQUFJLENBQUN5SSxVQUFVLEdBQUcsTUFBTSxFQUFDO0lBQ2xDO0lBQ0EsT0FBT1MsSUFBSWhLLElBQUksRUFBRTtRQUFFLE9BQU9BLEtBQUt5TCxNQUFNO0lBQUU7SUFDdkMsSUFBSW1CLGFBQWE7UUFBRSxPQUFPO0lBQU07SUFDaEMsSUFBSUMsV0FBVztRQUFFLE9BQU87SUFBTztJQUMvQixJQUFJQyxXQUFXO1FBQUUsT0FBTztJQUFPO0lBQy9CQyxNQUFNcEcsSUFBSSxFQUFFQyxFQUFFLEVBQUVvRyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxPQUFPLEVBQUU7UUFDbEQsT0FBTztJQUNYO0lBQ0FDLE9BQU9DLEtBQUssRUFBRTtRQUFFLE9BQU87SUFBTztJQUM5QnBELFlBQVlvRCxLQUFLLEVBQUU7UUFDZixPQUFPQSxNQUFNOUgsV0FBVyxJQUFJLElBQUksQ0FBQ0EsV0FBVyxJQUFJLENBQUUsRUFBQyxJQUFJLENBQUN1RCxLQUFLLEdBQUd1RSxNQUFNdkUsS0FBSyxJQUFJLEVBQUUsd0JBQXdCLEdBQTFCO0lBQ25GO0lBQ0Esb0VBQW9FO0lBQ3BFLDBEQUEwRDtJQUMxRCxzQ0FBc0M7SUFDdEN3RSxVQUFVO1FBQUUsT0FBTztJQUFHO0lBQ3RCeEIsVUFBVTtRQUNOLEtBQUssSUFBSXpDLFNBQVMsSUFBSSxDQUFDQyxRQUFRLENBQzNCLElBQUlELE1BQU0xSCxNQUFNLElBQUksSUFBSSxFQUNwQjBILE1BQU15QyxPQUFPO1FBQ3JCLElBQUksQ0FBQ25LLE1BQU0sR0FBRztJQUNsQjtBQUNKO0FBQ0FrSCxZQUFZMEUsU0FBUyxDQUFDaEUsVUFBVSxHQUFHO0FBQ25DLGlEQUFpRDtBQUNqRCxTQUFTYSxLQUFLckssR0FBRztJQUNiLElBQUk2SixPQUFPN0osSUFBSThKLFdBQVc7SUFDMUI5SixJQUFJRSxVQUFVLENBQUN1TixXQUFXLENBQUN6TjtJQUMzQixPQUFPNko7QUFDWDtBQUNBLE1BQU15QztJQUNGOUcsWUFBWStELFFBQVEsRUFBRUYsR0FBRyxFQUFFM0MsQ0FBQyxDQUFFO1FBQzFCLElBQUksQ0FBQzZDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDRixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDM0MsQ0FBQyxHQUFHQTtRQUNULElBQUksQ0FBQ3hGLEdBQUcsR0FBRztJQUNmO0lBQ0FzTCxRQUFRbkQsR0FBRyxFQUFFb0IsT0FBTyxDQUFDLEVBQUU7UUFDbkIsT0FBUztZQUNMLElBQUlwQixNQUFNLElBQUksQ0FBQ0EsR0FBRyxJQUFJQSxPQUFPLElBQUksQ0FBQ0EsR0FBRyxJQUNoQ29CLENBQUFBLE9BQU8sS0FBSyxJQUFJLENBQUMvRCxDQUFDLElBQUksS0FBSyxJQUFJLENBQUM2QyxRQUFRLENBQUMsSUFBSSxDQUFDN0MsQ0FBQyxHQUFHLEVBQUUsQ0FBQzhDLFVBQVUsR0FBRztnQkFDbkUsSUFBSSxDQUFDdEksR0FBRyxHQUFHbUksTUFBTSxJQUFJLENBQUNBLEdBQUc7Z0JBQ3pCLE9BQU8sSUFBSTtZQUNmO1lBQ0EsSUFBSVEsT0FBTyxJQUFJLENBQUNOLFFBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQzdDLENBQUMsQ0FBQztZQUNsQyxJQUFJLENBQUMyQyxHQUFHLElBQUlRLEtBQUs5SSxNQUFNLEdBQUc4SSxLQUFLTCxVQUFVO1FBQzdDO0lBQ0o7QUFDSjtBQUNBLFNBQVNrRSxhQUFhOUwsTUFBTSxFQUFFZ0osS0FBSyxFQUFFK0MsT0FBTyxFQUFFN0MsR0FBRyxFQUFFOEMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLFlBQVksRUFBRVgsU0FBUyxFQUFFQyxPQUFPO0lBQzlGLElBQUksRUFBRTdELFFBQVEsRUFBRSxHQUFHM0g7SUFDbkIsSUFBSStHLFNBQVNZLFNBQVN4SSxNQUFNLEdBQUd3SSxRQUFRLENBQUNxQixNQUFNLEdBQUc7SUFDakQsSUFBSW1ELE9BQU9GLE9BQU85TSxNQUFNLEdBQUc4TSxNQUFNLENBQUNBLE9BQU85TSxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQ3ZELElBQUlpTixhQUFhRCxPQUFPQSxLQUFLdkUsVUFBVSxHQUFHc0U7SUFDMUMsK0JBQStCO0lBQy9CLElBQUlsRCxTQUFTRSxPQUFPbkMsVUFBVSxDQUFDbUYsZ0JBQWdCLENBQUNFLGNBQWNILE9BQU85TSxNQUFNLEdBQUcsS0FDMUU0SCxPQUFPcUUsS0FBSyxDQUFDVyxTQUFTQyxPQUFPQyxPQUFPOU0sTUFBTSxHQUFHZ04sT0FBTyxNQUFNSixXQUFXLEdBQUdSLFdBQVdDLFVBQ25GO0lBQ0osSUFBSXRDLE1BQU12QixTQUFTeEksTUFBTSxFQUFFO1FBQ3ZCLElBQUk2SCxRQUFRVyxRQUFRLENBQUN1QixJQUFJO1FBQ3pCLDBFQUEwRTtRQUMxRSxJQUFJbEMsU0FBVWdGLENBQUFBLFFBQVFoRixNQUFNN0gsTUFBTSxJQUFJNkgsTUFBTVksVUFBVSxJQUFLdUUsQ0FBQUEsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUt2RSxVQUFVLElBQUk7WUFDdEgsZ0VBQWdFO1lBQ2hFLDJEQUEyRDtZQUMzRCxJQUFJb0IsU0FBU0UsS0FBSztnQkFDZGxDLFFBQVFBLE1BQU1xRixLQUFLLENBQUNMO2dCQUNwQkEsUUFBUTtZQUNaO1lBQ0EsNkRBQTZEO1lBQzdELCtDQUErQztZQUMvQyxJQUFJLENBQUNJLGNBQWNELFFBQVFuRixNQUFNb0UsS0FBSyxDQUFDLEdBQUdZLE9BQU9HLE1BQU0sTUFBTSxHQUFHWCxVQUFVO2dCQUN0RVMsTUFBTSxDQUFDQSxPQUFPOU0sTUFBTSxHQUFHLEVBQUUsR0FBRzZIO1lBQ2hDLE9BQ0s7Z0JBQ0QsMkRBQTJEO2dCQUMzRCx1QkFBdUI7Z0JBQ3ZCLElBQUlnRixTQUFTaEYsTUFBTVcsUUFBUSxDQUFDeEksTUFBTSxJQUFJLENBQUM2SCxNQUFNVyxRQUFRLENBQUMsRUFBRSxDQUFDeEksTUFBTSxFQUMzRDZILE1BQU1vRSxLQUFLLENBQUMsR0FBR1ksT0FBTyxNQUFNLE9BQU8sR0FBR1I7Z0JBQzFDUyxPQUFPdEgsSUFBSSxDQUFDcUM7WUFDaEI7UUFDSixPQUNLLElBQUlBLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUksS0FBSyxJQUFJQSxNQUFNWSxVQUFVLEVBQUU7WUFDckUsMERBQTBEO1lBQzFELG1DQUFtQztZQUNuQyxJQUFJdUUsTUFDQUEsS0FBS3ZFLFVBQVUsR0FBRztpQkFFbEJzRSxlQUFlO1FBQ3ZCO1FBQ0EsaUVBQWlFO1FBQ2pFLDBDQUEwQztRQUMxQ2hEO0lBQ0o7SUFDQSxJQUFJbkMsUUFBUTtRQUNSQSxPQUFPYSxVQUFVLEdBQUdzRTtRQUNwQixJQUFJSCxVQUFVLEdBQUc7WUFDYixJQUFJLENBQUNHLGdCQUFnQkQsT0FBTzlNLE1BQU0sSUFBSTRILE9BQU9xRSxLQUFLLENBQUNXLFNBQVNoRixPQUFPNUgsTUFBTSxFQUFFOE0sTUFBTSxDQUFDLEVBQUUsRUFBRSxPQUFPVixXQUFXLElBQUk7Z0JBQ3hHeEUsT0FBT2EsVUFBVSxHQUFHcUUsT0FBT3BPLEtBQUssR0FBRytKLFVBQVU7WUFDakQsT0FDSyxJQUFJbUUsVUFBVWhGLE9BQU81SCxNQUFNLElBQUk0SCxPQUFPWSxRQUFRLENBQUN4SSxNQUFNLElBQUk0SCxPQUFPWSxRQUFRLENBQUNaLE9BQU9ZLFFBQVEsQ0FBQ3hJLE1BQU0sR0FBRyxFQUFFLENBQUNBLE1BQU0sSUFBSSxHQUFHO2dCQUNuSDRILE9BQU9xRSxLQUFLLENBQUNXLFNBQVNoRixPQUFPNUgsTUFBTSxFQUFFLE1BQU0sT0FBT29NLFdBQVc7WUFDakU7WUFDQXZDO1FBQ0o7SUFDSjtJQUNBLDREQUE0RDtJQUM1RCxNQUFPQSxRQUFRRSxPQUFPK0MsT0FBTzlNLE1BQU0sQ0FBRTtRQUNqQyxJQUFJd0ksUUFBUSxDQUFDdUIsTUFBTSxFQUFFLENBQUN1QyxNQUFNLENBQUNRLE1BQU0sQ0FBQ0EsT0FBTzlNLE1BQU0sR0FBRyxFQUFFLEdBQUc7WUFDckQrSjtZQUNBK0MsT0FBT0ssR0FBRztZQUNWZCxVQUFVUyxPQUFPOU0sTUFBTSxHQUFHLElBQUlvTTtRQUNsQyxPQUNLLElBQUk1RCxRQUFRLENBQUNxQixNQUFNLENBQUN5QyxNQUFNLENBQUNRLE1BQU0sQ0FBQyxFQUFFLEdBQUc7WUFDeENqRDtZQUNBaUQsT0FBT3BPLEtBQUs7WUFDWjBOLFlBQVlVLE9BQU85TSxNQUFNLEdBQUcsSUFBSXFNO1FBQ3BDLE9BQ0s7WUFDRDtRQUNKO0lBQ0o7SUFDQSxJQUFJLENBQUNTLE9BQU85TSxNQUFNLElBQUk2SixTQUFTRSxNQUFNdkIsU0FBU3hJLE1BQU0sSUFBSSxDQUFDd0ksUUFBUSxDQUFDcUIsUUFBUSxFQUFFLENBQUNwQixVQUFVLElBQ25GRCxRQUFRLENBQUN1QixJQUFJLENBQUNrQyxLQUFLLENBQUMsR0FBRyxHQUFHekQsUUFBUSxDQUFDcUIsUUFBUSxFQUFFLEVBQUUsT0FBT3VDLFdBQVdDLFVBQ2pFeEM7SUFDSixJQUFJQSxRQUFRRSxPQUFPK0MsT0FBTzlNLE1BQU0sRUFDNUJhLE9BQU9pSyxlQUFlLENBQUNqQixPQUFPRSxLQUFLK0M7QUFDM0M7QUFDQSxTQUFTTSxrQkFBa0J2TSxNQUFNLEVBQUVnRixJQUFJLEVBQUVDLEVBQUUsRUFBRWdILE1BQU0sRUFBRVYsU0FBUyxFQUFFQyxPQUFPO0lBQ25FLElBQUl4SixNQUFNaEMsT0FBT3lLLFdBQVc7SUFDNUIsSUFBSSxFQUFFM0YsR0FBR29FLEdBQUcsRUFBRTVKLEtBQUswTSxLQUFLLEVBQUUsR0FBR2hLLElBQUk0SSxPQUFPLENBQUMzRixJQUFJO0lBQzdDLElBQUksRUFBRUgsR0FBR2tFLEtBQUssRUFBRTFKLEtBQUt5TSxPQUFPLEVBQUUsR0FBRy9KLElBQUk0SSxPQUFPLENBQUM1RixNQUFNLENBQUM7SUFDcEQsSUFBSXdILE9BQU94SCxPQUFPQztJQUNsQixLQUFLLElBQUl1QyxRQUFReUUsT0FDYk8sUUFBUWhGLEtBQUtySSxNQUFNO0lBQ3ZCYSxPQUFPYixNQUFNLElBQUlxTjtJQUNqQlYsYUFBYTlMLFFBQVFnSixPQUFPK0MsU0FBUzdDLEtBQUs4QyxPQUFPQyxRQUFRLEdBQUdWLFdBQVdDO0FBQzNFO0FBRUEsSUFBSWlCLE1BQU0sT0FBT0MsYUFBYSxjQUFjQSxZQUFZO0lBQUVDLFdBQVc7SUFBSUMsUUFBUTtJQUFJQyxVQUFVO0FBQUc7QUFDbEcsSUFBSXJPLE1BQU0sT0FBTzBHLFlBQVksY0FBY0EsV0FBVztJQUFFNEgsaUJBQWlCO1FBQUVDLE9BQU8sQ0FBQztJQUFFO0FBQUU7QUFDdkYsTUFBTUMsVUFBVSxXQUFXLEdBQUUsY0FBY0MsSUFBSSxDQUFDUixJQUFJRSxTQUFTO0FBQzdELE1BQU1PLFlBQVksV0FBVyxHQUFFLFVBQVU5SyxJQUFJLENBQUNxSyxJQUFJRSxTQUFTO0FBQzNELE1BQU1RLFVBQVUsV0FBVyxHQUFFLHdDQUF3Q0YsSUFBSSxDQUFDUixJQUFJRSxTQUFTO0FBQ3ZGLE1BQU1TLEtBQUssQ0FBQyxDQUFFRixDQUFBQSxhQUFhQyxXQUFXSCxPQUFNO0FBQzVDLE1BQU1LLFFBQVEsQ0FBQ0QsTUFBTSxXQUFXLEdBQUUsZ0JBQWdCaEwsSUFBSSxDQUFDcUssSUFBSUUsU0FBUztBQUNwRSxNQUFNVyxTQUFTLENBQUNGLE1BQU0sV0FBVyxHQUFFLGdCQUFnQkgsSUFBSSxDQUFDUixJQUFJRSxTQUFTO0FBQ3JFLE1BQU1ZLFNBQVMseUJBQXlCL08sSUFBSXNPLGVBQWUsQ0FBQ0MsS0FBSztBQUNqRSxNQUFNUyxTQUFTLENBQUNKLE1BQU0sV0FBVyxHQUFFLGlCQUFpQmhMLElBQUksQ0FBQ3FLLElBQUlHLE1BQU07QUFDbkUsTUFBTWEsTUFBTUQsVUFBVyxXQUFXLEdBQUUsZUFBY3BMLElBQUksQ0FBQ3FLLElBQUlFLFNBQVMsS0FBS0YsSUFBSWlCLGNBQWMsR0FBRztBQUM5RixJQUFJQyxVQUFVO0lBQ1ZDLEtBQUtILE9BQU8sV0FBVyxHQUFFLE1BQU1yTCxJQUFJLENBQUNxSyxJQUFJSSxRQUFRO0lBQ2hEZ0IsU0FBUyxXQUFXLEdBQUUsTUFBTXpMLElBQUksQ0FBQ3FLLElBQUlJLFFBQVE7SUFDN0NpQixPQUFPLFdBQVcsR0FBRSxZQUFZMUwsSUFBSSxDQUFDcUssSUFBSUksUUFBUTtJQUNqRE87SUFDQVcsWUFBWWIsWUFBWTFPLElBQUl3UCxZQUFZLElBQUksSUFBSWIsVUFBVSxDQUFDQSxPQUFPLENBQUMsRUFBRSxHQUFHSCxVQUFVLENBQUNBLE9BQU8sQ0FBQyxFQUFFLEdBQUc7SUFDaEdLO0lBQ0FZLGVBQWVaLFFBQVEsQ0FBQyxXQUFZLEdBQUUsa0JBQWlCSixJQUFJLENBQUNSLElBQUlFLFNBQVMsS0FBSztRQUFDO1FBQUc7S0FBRSxDQUFDLENBQUMsRUFBRSxHQUFHO0lBQzNGVyxRQUFRLENBQUMsQ0FBQ0E7SUFDVlksZ0JBQWdCWixTQUFTLENBQUNBLE1BQU0sQ0FBQyxFQUFFLEdBQUc7SUFDdENHO0lBQ0FVLFNBQVMsV0FBVyxHQUFFLFlBQVkvTCxJQUFJLENBQUNxSyxJQUFJRSxTQUFTO0lBQ3BEWTtJQUNBQztJQUNBWSxnQkFBZ0JiLFNBQVMsQ0FBQyxXQUFZLEdBQUUsd0JBQXVCTixJQUFJLENBQUNQLFVBQVVDLFNBQVMsS0FBSztRQUFDO1FBQUc7S0FBRSxDQUFDLENBQUMsRUFBRSxHQUFHO0lBQ3pHMEIsU0FBUzdQLElBQUlzTyxlQUFlLENBQUNDLEtBQUssQ0FBQ3NCLE9BQU8sSUFBSSxPQUFPLGFBQWE7QUFDdEU7QUFFQSxNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLGlCQUFpQnJIO0lBQ25CdEQsWUFBWW9ILElBQUksQ0FBRTtRQUNkLEtBQUs7UUFDTCxJQUFJLENBQUNBLElBQUksR0FBR0E7SUFDaEI7SUFDQSxJQUFJN0wsU0FBUztRQUFFLE9BQU8sSUFBSSxDQUFDNkwsSUFBSSxDQUFDN0wsTUFBTTtJQUFFO0lBQ3hDcVAsVUFBVUMsT0FBTyxFQUFFO1FBQ2YsSUFBSSxDQUFDNUUsTUFBTSxDQUFDNEUsV0FBV3ZKLFNBQVN3SixjQUFjLENBQUMsSUFBSSxDQUFDMUQsSUFBSTtJQUM1RDtJQUNBakQsS0FBS1AsSUFBSSxFQUFFUSxLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDNUosR0FBRyxFQUNULElBQUksQ0FBQ29RLFNBQVM7UUFDbEIsSUFBSSxJQUFJLENBQUNwUSxHQUFHLENBQUNjLFNBQVMsSUFBSSxJQUFJLENBQUM4TCxJQUFJLEVBQUU7WUFDakMsSUFBSWhELFNBQVNBLE1BQU0zSixJQUFJLElBQUksSUFBSSxDQUFDRCxHQUFHLEVBQy9CNEosTUFBTVEsT0FBTyxHQUFHO1lBQ3BCLElBQUksQ0FBQ3BLLEdBQUcsQ0FBQ2MsU0FBUyxHQUFHLElBQUksQ0FBQzhMLElBQUk7UUFDbEM7SUFDSjtJQUNBekMsU0FBU25LLEdBQUcsRUFBRTtRQUNWLElBQUlBLElBQUlILFFBQVEsSUFBSSxHQUNoQixJQUFJLENBQUN1USxTQUFTLENBQUNwUTtJQUN2QjtJQUNBZ04sTUFBTXBHLElBQUksRUFBRUMsRUFBRSxFQUFFb0csTUFBTSxFQUFFO1FBQ3BCLElBQUksSUFBSyxDQUFDbEUsS0FBSyxHQUFHLEVBQUUsd0JBQXdCLE9BQ3hDa0UsVUFBVyxFQUFFQSxDQUFBQSxrQkFBa0JrRCxRQUFPLEtBQ2xDLElBQUksQ0FBQ3BQLE1BQU0sR0FBSThGLENBQUFBLEtBQUtELElBQUcsSUFBS3FHLE9BQU9sTSxNQUFNLEdBQUdtUCxjQUMzQ2pELE9BQU9sRSxLQUFLLEdBQUcsRUFBRSx3QkFBd0IsR0FBRSxHQUNoRCxPQUFPO1FBQ1gsSUFBSSxDQUFDNkQsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxDQUFDMkQsS0FBSyxDQUFDLEdBQUczSixRQUFTcUcsQ0FBQUEsU0FBU0EsT0FBT0wsSUFBSSxHQUFHLEVBQUMsSUFBSyxJQUFJLENBQUNBLElBQUksQ0FBQzJELEtBQUssQ0FBQzFKO1FBQ3JGLElBQUksQ0FBQ3VFLFNBQVM7UUFDZCxPQUFPO0lBQ1g7SUFDQTZDLE1BQU1ySCxJQUFJLEVBQUU7UUFDUixJQUFJNEosU0FBUyxJQUFJTCxTQUFTLElBQUksQ0FBQ3ZELElBQUksQ0FBQzJELEtBQUssQ0FBQzNKO1FBQzFDLElBQUksQ0FBQ2dHLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksQ0FBQzJELEtBQUssQ0FBQyxHQUFHM0o7UUFDL0IsSUFBSSxDQUFDd0UsU0FBUztRQUNkb0YsT0FBT3pILEtBQUssSUFBSSxJQUFJLENBQUNBLEtBQUssR0FBRyxFQUFFLHdCQUF3QjtRQUN2RCxPQUFPeUg7SUFDWDtJQUNBaEcsZ0JBQWdCdkssSUFBSSxFQUFFb0ksTUFBTSxFQUFFO1FBQzFCLE9BQU9wSSxRQUFRLElBQUksQ0FBQ0QsR0FBRyxHQUFHcUksU0FBU0EsU0FBUyxJQUFJLENBQUN1RSxJQUFJLENBQUM3TCxNQUFNLEdBQUc7SUFDbkU7SUFDQTBQLFNBQVNwSCxHQUFHLEVBQUU7UUFBRSxPQUFPLElBQUlaLE9BQU8sSUFBSSxDQUFDekksR0FBRyxFQUFFcUo7SUFBTTtJQUNsRHNCLGdCQUFnQitGLEtBQUssRUFBRUMsR0FBRyxFQUFFdEksTUFBTSxFQUFFO1FBQ2hDLE9BQU87WUFBRXpCLE1BQU15QjtZQUFReEIsSUFBSXdCLFNBQVMsSUFBSSxDQUFDdEgsTUFBTTtZQUFFbUssVUFBVSxJQUFJLENBQUNsTCxHQUFHO1lBQUVtTCxRQUFRLElBQUksQ0FBQ25MLEdBQUcsQ0FBQzhKLFdBQVc7UUFBQztJQUN0RztJQUNBOEcsU0FBU3ZILEdBQUcsRUFBRWhHLElBQUksRUFBRTtRQUNoQixPQUFPd04sV0FBVyxJQUFJLENBQUM3USxHQUFHLEVBQUVxSixLQUFLaEc7SUFDckM7QUFDSjtBQUNBLE1BQU15TixpQkFBaUJoSTtJQUNuQnRELFlBQVl1TCxJQUFJLEVBQUV4SCxXQUFXLEVBQUUsRUFBRXhJLFNBQVMsQ0FBQyxDQUFFO1FBQ3pDLEtBQUs7UUFDTCxJQUFJLENBQUNnUSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDeEgsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUN4SSxNQUFNLEdBQUdBO1FBQ2QsS0FBSyxJQUFJaVEsTUFBTXpILFNBQ1h5SCxHQUFHeEYsU0FBUyxDQUFDLElBQUk7SUFDekI7SUFDQXlGLFNBQVNqUixHQUFHLEVBQUU7UUFDVmlJLGdCQUFnQmpJO1FBQ2hCLElBQUksSUFBSSxDQUFDK1EsSUFBSSxDQUFDRyxLQUFLLEVBQ2ZsUixJQUFJbVIsU0FBUyxHQUFHLElBQUksQ0FBQ0osSUFBSSxDQUFDRyxLQUFLO1FBQ25DLElBQUksSUFBSSxDQUFDSCxJQUFJLENBQUNLLEtBQUssRUFDZixJQUFLLElBQUlqSyxRQUFRLElBQUksQ0FBQzRKLElBQUksQ0FBQ0ssS0FBSyxDQUM1QnBSLElBQUlxUixZQUFZLENBQUNsSyxNQUFNLElBQUksQ0FBQzRKLElBQUksQ0FBQ0ssS0FBSyxDQUFDakssS0FBSztRQUNwRCxPQUFPbkg7SUFDWDtJQUNBa0ssWUFBWW9ELEtBQUssRUFBRTtRQUNmLE9BQU8sS0FBSyxDQUFDcEQsWUFBWW9ELFVBQVUsQ0FBRSxFQUFDLElBQUksQ0FBQ3ZFLEtBQUssR0FBR3VFLE1BQU12RSxLQUFLLElBQUksRUFBRSx3QkFBd0IsR0FBMUI7SUFDdEU7SUFDQW9CLFNBQVNsSyxJQUFJLEVBQUU7UUFDWCxJQUFJQSxLQUFLMEIsUUFBUSxJQUFJLElBQUksQ0FBQ29QLElBQUksQ0FBQ08sT0FBTyxDQUFDQyxXQUFXLElBQUk7WUFDbEQsSUFBSSxDQUFDOUYsTUFBTSxDQUFDeEw7WUFDWixJQUFJLENBQUM4SSxLQUFLLElBQUksRUFBRSx1QkFBdUIsTUFBSyxFQUFFLHNCQUFzQjtRQUN4RTtJQUNKO0lBQ0FZLEtBQUtQLElBQUksRUFBRVEsS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQzVKLEdBQUcsRUFDVCxJQUFJLENBQUN5TCxNQUFNLENBQUMsSUFBSSxDQUFDd0YsUUFBUSxDQUFDbkssU0FBUzBLLGFBQWEsQ0FBQyxJQUFJLENBQUNULElBQUksQ0FBQ08sT0FBTzthQUNqRSxJQUFJLElBQUksQ0FBQ3ZJLEtBQUssR0FBRyxFQUFFLHVCQUF1QixLQUMzQyxJQUFJLENBQUNrSSxRQUFRLENBQUMsSUFBSSxDQUFDalIsR0FBRztRQUMxQixLQUFLLENBQUMySixLQUFLUCxNQUFNUTtJQUNyQjtJQUNBb0QsTUFBTXBHLElBQUksRUFBRUMsRUFBRSxFQUFFb0csTUFBTSxFQUFFd0UsU0FBUyxFQUFFdEUsU0FBUyxFQUFFQyxPQUFPLEVBQUU7UUFDbkQsSUFBSUgsVUFBVyxFQUFFQSxDQUFBQSxrQkFBa0I2RCxZQUFZN0QsT0FBTzhELElBQUksQ0FBQ25MLEVBQUUsQ0FBQyxJQUFJLENBQUNtTCxJQUFJLE1BQ2xFbkssUUFBUXVHLGFBQWEsS0FBT3RHLEtBQUssSUFBSSxDQUFDOUYsTUFBTSxJQUFJcU0sV0FBVyxDQUFDLEdBQzdELE9BQU87UUFDWGUsa0JBQWtCLElBQUksRUFBRXZILE1BQU1DLElBQUlvRyxTQUFTQSxPQUFPMUQsUUFBUSxDQUFDZ0gsS0FBSyxLQUFLLEVBQUUsRUFBRXBELFlBQVksR0FBR0MsVUFBVTtRQUNsRyxJQUFJLENBQUNoQyxTQUFTO1FBQ2QsT0FBTztJQUNYO0lBQ0E2QyxNQUFNckgsSUFBSSxFQUFFO1FBQ1IsSUFBSTRKLFNBQVMsRUFBRSxFQUFFdFAsTUFBTSxHQUFHd1EsYUFBYSxDQUFDLEdBQUdoTCxJQUFJO1FBQy9DLEtBQUssSUFBSXJHLE9BQU8sSUFBSSxDQUFDa0osUUFBUSxDQUFFO1lBQzNCLElBQUkwQixNQUFNL0osTUFBTWIsSUFBSVUsTUFBTTtZQUMxQixJQUFJa0ssTUFBTXJFLE1BQ040SixPQUFPakssSUFBSSxDQUFDckYsTUFBTTBGLE9BQU92RyxJQUFJNE4sS0FBSyxDQUFDckgsT0FBTzFGLE9BQU9iO1lBQ3JELElBQUlxUixhQUFhLEtBQUt4USxPQUFPMEYsTUFDekI4SyxhQUFhaEw7WUFDakJ4RixNQUFNK0o7WUFDTnZFO1FBQ0o7UUFDQSxJQUFJM0YsU0FBUyxJQUFJLENBQUNBLE1BQU0sR0FBRzZGO1FBQzNCLElBQUksQ0FBQzdGLE1BQU0sR0FBRzZGO1FBQ2QsSUFBSThLLGFBQWEsQ0FBQyxHQUFHO1lBQ2pCLElBQUksQ0FBQ25JLFFBQVEsQ0FBQ3hJLE1BQU0sR0FBRzJRO1lBQ3ZCLElBQUksQ0FBQ3RHLFNBQVM7UUFDbEI7UUFDQSxPQUFPLElBQUkwRixTQUFTLElBQUksQ0FBQ0MsSUFBSSxFQUFFUCxRQUFRelA7SUFDM0M7SUFDQTBQLFNBQVNwSCxHQUFHLEVBQUU7UUFDVixPQUFPc0ksZUFBZSxJQUFJLEVBQUV0STtJQUNoQztJQUNBdUgsU0FBU3ZILEdBQUcsRUFBRWhHLElBQUksRUFBRTtRQUNoQixPQUFPdU8saUJBQWlCLElBQUksRUFBRXZJLEtBQUtoRztJQUN2QztBQUNKO0FBQ0EsU0FBU3dOLFdBQVdqRSxJQUFJLEVBQUV2RCxHQUFHLEVBQUVoRyxJQUFJO0lBQy9CLElBQUl0QyxTQUFTNkwsS0FBSzlMLFNBQVMsQ0FBQ0MsTUFBTTtJQUNsQyxJQUFJc0ksTUFBTXRJLFFBQ05zSSxNQUFNdEk7SUFDVixJQUFJNkYsT0FBT3lDLEtBQUt4QyxLQUFLd0MsS0FBS3dJLFVBQVU7SUFDcEMsSUFBSXhJLE9BQU8sS0FBS2hHLE9BQU8sS0FBS2dHLE9BQU90SSxVQUFVc0MsUUFBUSxHQUFHO1FBQ3BELElBQUksQ0FBRWtNLENBQUFBLFFBQVFMLE1BQU0sSUFBSUssUUFBUU4sS0FBSyxHQUFHO1lBQ3BDLElBQUk1RixLQUFLO2dCQUNMekM7Z0JBQ0FpTCxVQUFVO1lBQ2QsT0FDSyxJQUFJaEwsS0FBSzlGLFFBQVE7Z0JBQ2xCOEY7Z0JBQ0FnTCxVQUFVLENBQUM7WUFDZjtRQUNKO0lBQ0osT0FDSztRQUNELElBQUl4TyxPQUFPLEdBQ1B1RDthQUNDLElBQUlDLEtBQUs5RixRQUNWOEY7SUFDUjtJQUNBLElBQUlpTCxRQUFRalIsVUFBVStMLE1BQU1oRyxNQUFNQyxJQUFJN0YsY0FBYztJQUNwRCxJQUFJLENBQUM4USxNQUFNL1EsTUFBTSxFQUNiLE9BQU87SUFDWCxJQUFJaUIsT0FBTzhQLEtBQUssQ0FBQyxDQUFDRCxVQUFVQSxVQUFVLElBQUl4TyxRQUFRLEtBQUssSUFBSXlPLE1BQU0vUSxNQUFNLEdBQUcsRUFBRTtJQUM1RSxJQUFJd08sUUFBUUgsTUFBTSxJQUFJLENBQUN5QyxXQUFXN1AsS0FBS1ksS0FBSyxJQUFJLEdBQzVDWixPQUFPK1AsTUFBTXZFLFNBQVMsQ0FBQ3dFLElBQUksQ0FBQ0MsSUFBSSxDQUFDSCxPQUFPSSxDQUFBQSxJQUFLQSxFQUFFdFAsS0FBSyxLQUFLWjtJQUM3RCxPQUFPNlAsVUFBVTlQLFlBQVlDLE1BQU02UCxVQUFVLEtBQUs3UCxRQUFRO0FBQzlEO0FBQ0EsdUVBQXVFO0FBQ3ZFLE1BQU1tUSxtQkFBbUJySjtJQUNyQixPQUFPc0osT0FBT0MsTUFBTSxFQUFFdFIsTUFBTSxFQUFFc0MsSUFBSSxFQUFFO1FBQ2hDLE9BQU8sSUFBSThPLFdBQVdFLFFBQVF0UixRQUFRc0M7SUFDMUM7SUFDQW1DLFlBQVk2TSxNQUFNLEVBQUV0UixNQUFNLEVBQUVzQyxJQUFJLENBQUU7UUFDOUIsS0FBSztRQUNMLElBQUksQ0FBQ2dQLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUN0UixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDc0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2lQLFVBQVUsR0FBRztJQUN0QjtJQUNBckUsTUFBTXJILElBQUksRUFBRTtRQUNSLElBQUk0SixTQUFTMkIsV0FBV0MsTUFBTSxDQUFDLElBQUksQ0FBQ0MsTUFBTSxFQUFFLElBQUksQ0FBQ3RSLE1BQU0sR0FBRzZGLE1BQU0sSUFBSSxDQUFDdkQsSUFBSTtRQUN6RSxJQUFJLENBQUN0QyxNQUFNLElBQUk2RjtRQUNmLE9BQU80SjtJQUNYO0lBQ0E3RyxLQUFLUCxJQUFJLEVBQUU7UUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDcEosR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDcVMsTUFBTSxDQUFDRSxTQUFTLENBQUMsSUFBSSxDQUFDdlMsR0FBRyxFQUFFb0osT0FBTztZQUNyRCxJQUFJLElBQUksQ0FBQ3BKLEdBQUcsSUFBSSxJQUFJLENBQUNzUyxVQUFVLEVBQzNCLElBQUksQ0FBQ0EsVUFBVSxDQUFDdkcsT0FBTyxDQUFDLElBQUksQ0FBQy9MLEdBQUc7WUFDcEMsSUFBSSxDQUFDc1MsVUFBVSxHQUFHO1lBQ2xCLElBQUksQ0FBQzdHLE1BQU0sQ0FBQyxJQUFJLENBQUM0RyxNQUFNLENBQUNHLEtBQUssQ0FBQ3BKO1lBQzlCLElBQUksQ0FBQyxJQUFJLENBQUNpSixNQUFNLENBQUNJLFFBQVEsRUFDckIsSUFBSSxDQUFDelMsR0FBRyxDQUFDOEIsZUFBZSxHQUFHO1FBQ25DO0lBQ0o7SUFDQXlMLFVBQVU7UUFBRSxPQUFPLElBQUksQ0FBQ2xLLElBQUk7SUFBRTtJQUM5QjJKLE1BQU1wRyxJQUFJLEVBQUVDLEVBQUUsRUFBRW9HLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxTQUFTLEVBQUVDLE9BQU8sRUFBRTtRQUNsRCxJQUFJSCxVQUFXLEVBQUVBLENBQUFBLGtCQUFrQmtGLFVBQVMsS0FBTSxDQUFDLElBQUksQ0FBQ0UsTUFBTSxDQUFDSyxPQUFPLENBQUN6RixPQUFPb0YsTUFBTSxLQUNoRnpMLE9BQU8sS0FBS3VHLGFBQWEsS0FBS3RHLEtBQUssSUFBSSxDQUFDOUYsTUFBTSxJQUFJcU0sV0FBVyxJQUM3RCxPQUFPO1FBQ1gsSUFBSSxDQUFDck0sTUFBTSxHQUFHNkYsT0FBUXFHLENBQUFBLFNBQVNBLE9BQU9sTSxNQUFNLEdBQUcsS0FBTSxLQUFJLENBQUNBLE1BQU0sR0FBRzhGLEVBQUM7UUFDcEUsT0FBTztJQUNYO0lBQ0F3RyxPQUFPQyxLQUFLLEVBQUU7UUFDVixJQUFJQSxpQkFBaUI2RSxjQUFjN0UsTUFBTWpLLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUksSUFDdEQsSUFBSSxDQUFDZ1AsTUFBTSxDQUFDN00sV0FBVyxJQUFJOEgsTUFBTStFLE1BQU0sQ0FBQzdNLFdBQVcsRUFBRTtZQUNyRCxJQUFJLENBQUMsSUFBSSxDQUFDNk0sTUFBTSxDQUFDSyxPQUFPLENBQUNwRixNQUFNK0UsTUFBTSxHQUNqQyxJQUFJLENBQUNqSCxTQUFTLENBQUM7WUFDbkIsSUFBSSxJQUFJLENBQUNwTCxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUNzUyxVQUFVLEVBQzVCLElBQUksQ0FBQ0EsVUFBVSxHQUFHLElBQUksQ0FBQ0QsTUFBTTtZQUNqQyxJQUFJLENBQUNBLE1BQU0sR0FBRy9FLE1BQU0rRSxNQUFNO1lBQzFCLElBQUksQ0FBQ3RSLE1BQU0sR0FBR3VNLE1BQU12TSxNQUFNO1lBQzFCLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBa0wsaUJBQWlCO1FBQUUsT0FBTztJQUFNO0lBQ2hDRSxZQUFZd0csS0FBSyxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUNOLE1BQU0sQ0FBQ2xHLFdBQVcsQ0FBQ3dHO0lBQVE7SUFDNUQsSUFBSTNKLGtCQUFrQjtRQUNsQixJQUFJLElBQUksQ0FBQ2pJLE1BQU0sSUFBSSxHQUNmLE9BQU85QyxtREFBSUEsQ0FBQzJVLEtBQUs7UUFDckIsSUFBSXhRLE1BQU0sSUFBSTtRQUNkLE1BQU9BLElBQUlSLE1BQU0sQ0FDYlEsTUFBTUEsSUFBSVIsTUFBTTtRQUNwQixJQUFJLEVBQUV3SCxJQUFJLEVBQUUsR0FBR2hILEtBQUt3SyxPQUFPeEQsUUFBUUEsS0FBS3lKLEtBQUssQ0FBQ3pTLEdBQUcsRUFBRThFLFFBQVEsSUFBSSxDQUFDK0QsVUFBVTtRQUMxRSxPQUFPMkQsT0FBT0EsS0FBSzJELEtBQUssQ0FBQ3JMLE9BQU9BLFFBQVEsSUFBSSxDQUFDbkUsTUFBTSxJQUFJOUMsbURBQUlBLENBQUMyVSxLQUFLO0lBQ3JFO0lBQ0FuQyxTQUFTcEgsR0FBRyxFQUFFO1FBQ1YsT0FBTyxDQUFDLElBQUksQ0FBQ3RJLE1BQU0sR0FBR3NJLE9BQU8sSUFBSSxJQUFJLENBQUNoRyxJQUFJLEdBQUcsS0FDdkNvRixPQUFPRSxNQUFNLENBQUMsSUFBSSxDQUFDM0ksR0FBRyxJQUN0QnlJLE9BQU9HLEtBQUssQ0FBQyxJQUFJLENBQUM1SSxHQUFHLEVBQUVxSixPQUFPLElBQUksQ0FBQ3RJLE1BQU07SUFDbkQ7SUFDQTRKLGtCQUFrQjtRQUFFLE9BQU87SUFBTTtJQUNqQ2lHLFNBQVN2SCxHQUFHLEVBQUVoRyxJQUFJLEVBQUU7UUFDaEIsSUFBSXlQLFNBQVMsSUFBSSxDQUFDVCxNQUFNLENBQUN6QixRQUFRLENBQUMsSUFBSSxDQUFDNVEsR0FBRyxFQUFFcUosS0FBS2hHO1FBQ2pELElBQUl5UCxRQUNBLE9BQU9BO1FBQ1gsSUFBSWhCLFFBQVEsSUFBSSxDQUFDOVIsR0FBRyxDQUFDZ0IsY0FBYyxJQUFJZ0IsT0FBTztRQUM5QyxJQUFJLENBQUM4UCxNQUFNL1EsTUFBTSxFQUNiLE9BQU87UUFDWCxJQUFJZ1MsV0FBVyxJQUFJLENBQUMxUCxJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJLEdBQUcsSUFBSWdHLE1BQU07UUFDakQsSUFBSyxJQUFJM0MsSUFBSXFNLFdBQVdqQixNQUFNL1EsTUFBTSxHQUFHLElBQUksSUFBSTJGLEtBQU1xTSxXQUFXLENBQUMsSUFBSSxFQUFJO1lBQ3JFL1EsT0FBTzhQLEtBQUssQ0FBQ3BMLEVBQUU7WUFDZixJQUFJMkMsTUFBTSxJQUFJM0MsS0FBSyxJQUFJQSxLQUFLb0wsTUFBTS9RLE1BQU0sR0FBRyxLQUFLaUIsS0FBS0ksR0FBRyxHQUFHSixLQUFLSyxNQUFNLEVBQ2xFO1FBQ1I7UUFDQSxPQUFPTixZQUFZQyxNQUFNLENBQUMrUTtJQUM5QjtJQUNBLElBQUlsRyxhQUFhO1FBQUUsT0FBTztJQUFPO0lBQ2pDLElBQUlDLFdBQVc7UUFBRSxPQUFPO0lBQU07SUFDOUIsSUFBSUMsV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFDc0YsTUFBTSxDQUFDdEYsUUFBUTtJQUFFO0lBQzlDaEIsVUFBVTtRQUNOLEtBQUssQ0FBQ0E7UUFDTixJQUFJLElBQUksQ0FBQy9MLEdBQUcsRUFDUixJQUFJLENBQUNxUyxNQUFNLENBQUN0RyxPQUFPLENBQUMsSUFBSSxDQUFDL0wsR0FBRztJQUNwQztBQUNKO0FBQ0EsaUVBQWlFO0FBQ2pFLGdFQUFnRTtBQUNoRSw2QkFBNkI7QUFDN0IsTUFBTWdULHlCQUF5QmxLO0lBQzNCdEQsWUFBWW5DLElBQUksQ0FBRTtRQUNkLEtBQUs7UUFDTCxJQUFJLENBQUNBLElBQUksR0FBR0E7SUFDaEI7SUFDQSxJQUFJdEMsU0FBUztRQUFFLE9BQU87SUFBRztJQUN6QmlNLFFBQVE7UUFBRSxPQUFPO0lBQU87SUFDeEJLLE9BQU9DLEtBQUssRUFBRTtRQUNWLE9BQU9BLGlCQUFpQjBGLG9CQUFvQjFGLE1BQU1qSyxJQUFJLElBQUksSUFBSSxDQUFDQSxJQUFJO0lBQ3ZFO0lBQ0E0SyxRQUFRO1FBQUUsT0FBTyxJQUFJK0UsaUJBQWlCLElBQUksQ0FBQzNQLElBQUk7SUFBRztJQUNsRHNHLE9BQU87UUFDSCxJQUFJLENBQUMsSUFBSSxDQUFDM0osR0FBRyxFQUFFO1lBQ1gsSUFBSUEsTUFBTThHLFNBQVMwSyxhQUFhLENBQUM7WUFDakN4UixJQUFJbVIsU0FBUyxHQUFHO1lBQ2hCblIsSUFBSXFSLFlBQVksQ0FBQyxlQUFlO1lBQ2hDLElBQUksQ0FBQzVGLE1BQU0sQ0FBQ3pMO1FBQ2hCO0lBQ0o7SUFDQXVOLFVBQVU7UUFBRSxPQUFPLElBQUksQ0FBQ2xLLElBQUk7SUFBRTtJQUM5Qm9OLFNBQVNwSCxHQUFHLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQ2hHLElBQUksR0FBRyxJQUFJb0YsT0FBT0UsTUFBTSxDQUFDLElBQUksQ0FBQzNJLEdBQUcsSUFBSXlJLE9BQU9HLEtBQUssQ0FBQyxJQUFJLENBQUM1SSxHQUFHO0lBQUc7SUFDekZ3SyxrQkFBa0I7UUFBRSxPQUFPO0lBQUc7SUFDOUJHLGtCQUFrQjtRQUFFLE9BQU87SUFBTTtJQUNqQ2lHLFNBQVN2SCxHQUFHLEVBQUU7UUFDVixPQUFPLElBQUksQ0FBQ3JKLEdBQUcsQ0FBQ3dFLHFCQUFxQjtJQUN6QztJQUNBLElBQUl3RSxrQkFBa0I7UUFDbEIsT0FBTy9LLG1EQUFJQSxDQUFDMlUsS0FBSztJQUNyQjtJQUNBLElBQUk3RixXQUFXO1FBQUUsT0FBTztJQUFNO0FBQ2xDO0FBQ0FvRCxTQUFTM0MsU0FBUyxDQUFDakUsUUFBUSxHQUFHNEksV0FBVzNFLFNBQVMsQ0FBQ2pFLFFBQVEsR0FBR3lKLGlCQUFpQnhGLFNBQVMsQ0FBQ2pFLFFBQVEsR0FBR1Y7QUFDcEcsU0FBUzhJLGVBQWUvUCxNQUFNLEVBQUV5SCxHQUFHO0lBQy9CLElBQUlySixNQUFNNEIsT0FBTzVCLEdBQUcsRUFBRSxFQUFFdUosUUFBUSxFQUFFLEdBQUczSCxRQUFROEUsSUFBSTtJQUNqRCxJQUFLLElBQUl4RixNQUFNLEdBQUd3RixJQUFJNkMsU0FBU3hJLE1BQU0sRUFBRTJGLElBQUs7UUFDeEMsSUFBSTRDLFFBQVFDLFFBQVEsQ0FBQzdDLEVBQUUsRUFBRXVFLE1BQU0vSixNQUFNb0ksTUFBTXZJLE1BQU07UUFDakQsSUFBSWtLLE9BQU8vSixPQUFPb0ksTUFBTWlFLE9BQU8sTUFBTSxHQUNqQztRQUNKLElBQUlsRSxNQUFNbkksT0FBT21JLE1BQU00QixPQUFPM0IsTUFBTXRKLEdBQUcsQ0FBQ0UsVUFBVSxJQUFJRixLQUNsRCxPQUFPc0osTUFBTW1ILFFBQVEsQ0FBQ3BILE1BQU1uSTtRQUNoQyxJQUFJbUksT0FBT25JLEtBQ1A7UUFDSkEsTUFBTStKO0lBQ1Y7SUFDQSxJQUFLLElBQUlnSSxJQUFJdk0sR0FBR3VNLElBQUksR0FBR0EsSUFBSztRQUN4QixJQUFJM0ssT0FBT2lCLFFBQVEsQ0FBQzBKLElBQUksRUFBRTtRQUMxQixJQUFJM0ssS0FBS3RJLEdBQUcsQ0FBQ0UsVUFBVSxJQUFJRixLQUN2QixPQUFPc0ksS0FBS21JLFFBQVEsQ0FBQ25JLEtBQUt2SCxNQUFNO0lBQ3hDO0lBQ0EsSUFBSyxJQUFJa1MsSUFBSXZNLEdBQUd1TSxJQUFJMUosU0FBU3hJLE1BQU0sRUFBRWtTLElBQUs7UUFDdEMsSUFBSXBKLE9BQU9OLFFBQVEsQ0FBQzBKLEVBQUU7UUFDdEIsSUFBSXBKLEtBQUs3SixHQUFHLENBQUNFLFVBQVUsSUFBSUYsS0FDdkIsT0FBTzZKLEtBQUs0RyxRQUFRLENBQUM7SUFDN0I7SUFDQSxPQUFPLElBQUloSSxPQUFPekksS0FBSztBQUMzQjtBQUNBLHlEQUF5RDtBQUN6RCxTQUFTa1QsZUFBZXRSLE1BQU0sRUFBRXdILElBQUksRUFBRStKLElBQUk7SUFDdEMsSUFBSXBGLE1BQU0sRUFBRXhFLFFBQVEsRUFBRSxHQUFHM0g7SUFDekIsSUFBSXVSLE9BQU8sS0FBSy9KLGdCQUFnQjBILFlBQVl2SCxTQUFTeEksTUFBTSxJQUN2RCxDQUFDZ04sT0FBT3hFLFFBQVEsQ0FBQ0EsU0FBU3hJLE1BQU0sR0FBRyxFQUFFLGFBQWErUCxZQUFZL0MsS0FBS2dELElBQUksQ0FBQ25MLEVBQUUsQ0FBQ3dELEtBQUsySCxJQUFJLEdBQUc7UUFDdkZtQyxlQUFlbkYsTUFBTTNFLEtBQUtHLFFBQVEsQ0FBQyxFQUFFLEVBQUU0SixPQUFPO0lBQ2xELE9BQ0s7UUFDRDVKLFNBQVNoRCxJQUFJLENBQUM2QztRQUNkQSxLQUFLb0MsU0FBUyxDQUFDNUo7SUFDbkI7SUFDQUEsT0FBT2IsTUFBTSxJQUFJcUksS0FBS3JJLE1BQU07QUFDaEM7QUFDQSxTQUFTNlEsaUJBQWlCeEksSUFBSSxFQUFFQyxHQUFHLEVBQUVoRyxJQUFJO0lBQ3JDLElBQUlzRixTQUFTLE1BQU15SyxZQUFZLENBQUMsR0FBR3hLLFFBQVEsTUFBTXlLLFdBQVcsQ0FBQztJQUM3RCxTQUFTQyxLQUFLbEssSUFBSSxFQUFFQyxHQUFHO1FBQ25CLElBQUssSUFBSTNDLElBQUksR0FBR3hGLE1BQU0sR0FBR3dGLElBQUkwQyxLQUFLRyxRQUFRLENBQUN4SSxNQUFNLElBQUlHLE9BQU9tSSxLQUFLM0MsSUFBSztZQUNsRSxJQUFJNEMsUUFBUUYsS0FBS0csUUFBUSxDQUFDN0MsRUFBRSxFQUFFdUUsTUFBTS9KLE1BQU1vSSxNQUFNdkksTUFBTTtZQUN0RCxJQUFJa0ssT0FBTzVCLEtBQUs7Z0JBQ1osSUFBSUMsTUFBTUMsUUFBUSxDQUFDeEksTUFBTSxFQUFFO29CQUN2QnVTLEtBQUtoSyxPQUFPRCxNQUFNbkk7Z0JBQ3RCLE9BQ0ssSUFBSSxDQUFDLENBQUMwSCxTQUFTQSxNQUFNbUUsUUFBUSxJQUFJMUosT0FBTyxNQUN4QzRILENBQUFBLE1BQU01QixPQUFPbkksT0FBTytKLE9BQU8zQixNQUFNaUUsT0FBTyxLQUFLLElBQUk7b0JBQ2xEM0UsUUFBUVU7b0JBQ1IrSixXQUFXaEssTUFBTW5JO2dCQUNyQixPQUNLLElBQUlBLE1BQU1tSSxPQUFPLE9BQVE0QixPQUFPM0IsTUFBTWlFLE9BQU8sS0FBSyxLQUFNLENBQUNqRSxNQUFNeUQsUUFBUSxFQUFFO29CQUMxRXBFLFNBQVNXO29CQUNUOEosWUFBWS9KLE1BQU1uSTtnQkFDdEI7WUFDSjtZQUNBQSxNQUFNK0o7UUFDVjtJQUNKO0lBQ0FxSSxLQUFLbEssTUFBTUM7SUFDWCxJQUFJekosU0FBUyxDQUFDeUQsT0FBTyxJQUFJc0YsU0FBU0MsS0FBSSxLQUFNRCxVQUFVQztJQUN0RCxJQUFJaEosUUFDQSxPQUFPQSxPQUFPZ1IsUUFBUSxDQUFDMU4sS0FBS3NGLEdBQUcsQ0FBQyxHQUFHNUksVUFBVStJLFNBQVN5SyxZQUFZQyxXQUFXaFE7SUFDakYsT0FBT2tRLGFBQWFuSztBQUN4QjtBQUNBLFNBQVNtSyxhQUFhbkssSUFBSTtJQUN0QixJQUFJMkUsT0FBTzNFLEtBQUtwSixHQUFHLENBQUMwSyxTQUFTO0lBQzdCLElBQUksQ0FBQ3FELE1BQ0QsT0FBTzNFLEtBQUtwSixHQUFHLENBQUN3RSxxQkFBcUI7SUFDekMsSUFBSXNOLFFBQVFsUixlQUFlbU47SUFDM0IsT0FBTytELEtBQUssQ0FBQ0EsTUFBTS9RLE1BQU0sR0FBRyxFQUFFLElBQUk7QUFDdEM7QUFFQSxTQUFTeVMsYUFBYXZHLE1BQU0sRUFBRXJOLE1BQU07SUFDaEMsSUFBSyxJQUFJdUgsUUFBUThGLE9BQVE7UUFDckIsSUFBSTlGLFFBQVEsV0FBV3ZILE9BQU9zUixLQUFLLEVBQy9CdFIsT0FBT3NSLEtBQUssSUFBSSxNQUFNakUsT0FBT2lFLEtBQUs7YUFDakMsSUFBSS9KLFFBQVEsV0FBV3ZILE9BQU8rTyxLQUFLLEVBQ3BDL08sT0FBTytPLEtBQUssSUFBSSxNQUFNMUIsT0FBTzBCLEtBQUs7YUFFbEMvTyxNQUFNLENBQUN1SCxLQUFLLEdBQUc4RixNQUFNLENBQUM5RixLQUFLO0lBQ25DO0lBQ0EsT0FBT3ZIO0FBQ1g7QUFDQSxNQUFNNlQsVUFBVSxXQUFXLEdBQUVDLE9BQU90QixNQUFNLENBQUM7QUFDM0MsU0FBU3VCLFFBQVFDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxNQUFNO0lBQ3pCLElBQUlGLEtBQUtDLEdBQ0wsT0FBTztJQUNYLElBQUksQ0FBQ0QsR0FDREEsSUFBSUg7SUFDUixJQUFJLENBQUNJLEdBQ0RBLElBQUlKO0lBQ1IsSUFBSU0sUUFBUUwsT0FBT00sSUFBSSxDQUFDSixJQUFJSyxRQUFRUCxPQUFPTSxJQUFJLENBQUNIO0lBQ2hELElBQUlFLE1BQU1oVCxNQUFNLEdBQUkrUyxDQUFBQSxVQUFVQyxNQUFNakksT0FBTyxDQUFDZ0ksVUFBVSxDQUFDLElBQUksSUFBSSxNQUMzREcsTUFBTWxULE1BQU0sR0FBSStTLENBQUFBLFVBQVVHLE1BQU1uSSxPQUFPLENBQUNnSSxVQUFVLENBQUMsSUFBSSxJQUFJLElBQzNELE9BQU87SUFDWCxLQUFLLElBQUl4TSxPQUFPeU0sTUFBTztRQUNuQixJQUFJek0sT0FBT3dNLFVBQVdHLENBQUFBLE1BQU1uSSxPQUFPLENBQUN4RSxRQUFRLENBQUMsS0FBS3NNLENBQUMsQ0FBQ3RNLElBQUksS0FBS3VNLENBQUMsQ0FBQ3ZNLElBQUksR0FDL0QsT0FBTztJQUNmO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBUzRNLFlBQVlsVSxHQUFHLEVBQUVzSSxJQUFJLEVBQUU4SSxLQUFLO0lBQ2pDLElBQUkrQyxVQUFVO0lBQ2QsSUFBSTdMLE1BQ0E7UUFBQSxJQUFLLElBQUluQixRQUFRbUIsS0FDYixJQUFJLENBQUU4SSxDQUFBQSxTQUFTakssUUFBUWlLLEtBQUksR0FBSTtZQUMzQitDLFVBQVU7WUFDVixJQUFJaE4sUUFBUSxTQUNSbkgsSUFBSTJPLEtBQUssQ0FBQ3lGLE9BQU8sR0FBRztpQkFFcEJwVSxJQUFJcVUsZUFBZSxDQUFDbE47UUFDNUI7SUFBQTtJQUNSLElBQUlpSyxPQUNBO1FBQUEsSUFBSyxJQUFJakssUUFBUWlLLE1BQ2IsSUFBSSxDQUFFOUksQ0FBQUEsUUFBUUEsSUFBSSxDQUFDbkIsS0FBSyxJQUFJaUssS0FBSyxDQUFDakssS0FBSyxHQUFHO1lBQ3RDZ04sVUFBVTtZQUNWLElBQUloTixRQUFRLFNBQ1JuSCxJQUFJMk8sS0FBSyxDQUFDeUYsT0FBTyxHQUFHaEQsS0FBSyxDQUFDakssS0FBSztpQkFFL0JuSCxJQUFJcVIsWUFBWSxDQUFDbEssTUFBTWlLLEtBQUssQ0FBQ2pLLEtBQUs7UUFDMUM7SUFBQTtJQUNSLE9BQU9nTjtBQUNYO0FBQ0EsU0FBU0csU0FBU3RVLEdBQUc7SUFDakIsSUFBSW9SLFFBQVFzQyxPQUFPdEIsTUFBTSxDQUFDO0lBQzFCLElBQUssSUFBSTFMLElBQUksR0FBR0EsSUFBSTFHLElBQUlrSSxVQUFVLENBQUNuSCxNQUFNLEVBQUUyRixJQUFLO1FBQzVDLElBQUk2TixPQUFPdlUsSUFBSWtJLFVBQVUsQ0FBQ3hCLEVBQUU7UUFDNUIwSyxLQUFLLENBQUNtRCxLQUFLcE4sSUFBSSxDQUFDLEdBQUdvTixLQUFLQyxLQUFLO0lBQ2pDO0lBQ0EsT0FBT3BEO0FBQ1g7QUFFQSxNQUFNcUQsaUJBQWlCM0w7SUFDbkJ0RCxhQUFjO1FBQ1YsS0FBSyxJQUFJa1A7UUFDVCxJQUFJLENBQUNuTCxRQUFRLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUN4SSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUM0VCxTQUFTLEdBQUdsTztRQUNqQixJQUFJLENBQUMySyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUM1SCxVQUFVLEdBQUc7SUFDdEI7SUFDQSxrQkFBa0I7SUFDbEJ3RCxNQUFNcEcsSUFBSSxFQUFFQyxFQUFFLEVBQUVvRyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxPQUFPLEVBQUU7UUFDbEQsSUFBSUgsUUFBUTtZQUNSLElBQUksQ0FBRUEsQ0FBQUEsa0JBQWtCd0gsUUFBTyxHQUMzQixPQUFPO1lBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQ3pVLEdBQUcsRUFDVGlOLE9BQU8ySCxXQUFXLENBQUMsSUFBSSxHQUFHLG9DQUFvQztRQUN0RTtRQUNBLElBQUkxSCxVQUNBLElBQUksQ0FBQzJILE9BQU8sQ0FBQzVILFNBQVNBLE9BQU9tRSxLQUFLLEdBQUc7UUFDekNqRCxrQkFBa0IsSUFBSSxFQUFFdkgsTUFBTUMsSUFBSW9HLFNBQVNBLE9BQU8xRCxRQUFRLENBQUNnSCxLQUFLLEtBQUssRUFBRSxFQUFFcEQsV0FBV0M7UUFDcEYsT0FBTztJQUNYO0lBQ0FhLE1BQU02RyxFQUFFLEVBQUU7UUFDTixJQUFJN0osTUFBTSxJQUFJd0o7UUFDZHhKLElBQUl6QixVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVO1FBQ2hDLElBQUksSUFBSSxDQUFDekksTUFBTSxJQUFJLEdBQ2YsT0FBT2tLO1FBQ1gsSUFBSSxFQUFFdkUsQ0FBQyxFQUFFeEYsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDcUwsUUFBUSxDQUFDdUk7UUFDL0IsSUFBSTVULEtBQUs7WUFDTCtKLElBQUk4SixNQUFNLENBQUMsSUFBSSxDQUFDeEwsUUFBUSxDQUFDN0MsRUFBRSxDQUFDdUgsS0FBSyxDQUFDL00sTUFBTTtZQUN4QyxJQUFJLENBQUNxSSxRQUFRLENBQUM3QyxFQUFFLENBQUNzRyxLQUFLLENBQUM5TCxLQUFLLElBQUksQ0FBQ3FJLFFBQVEsQ0FBQzdDLEVBQUUsQ0FBQzNGLE1BQU0sRUFBRSxNQUFNLE9BQU8sR0FBRztZQUNyRTJGO1FBQ0o7UUFDQSxJQUFLLElBQUl1TSxJQUFJdk0sR0FBR3VNLElBQUksSUFBSSxDQUFDMUosUUFBUSxDQUFDeEksTUFBTSxFQUFFa1MsSUFDdENoSSxJQUFJOEosTUFBTSxDQUFDLElBQUksQ0FBQ3hMLFFBQVEsQ0FBQzBKLEVBQUUsRUFBRTtRQUNqQyxNQUFPdk0sSUFBSSxLQUFLLElBQUksQ0FBQzZDLFFBQVEsQ0FBQzdDLElBQUksRUFBRSxDQUFDM0YsTUFBTSxJQUFJLEVBQzNDLElBQUksQ0FBQ3dJLFFBQVEsQ0FBQyxFQUFFN0MsRUFBRSxDQUFDcUYsT0FBTztRQUM5QixJQUFJLENBQUN4QyxRQUFRLENBQUN4SSxNQUFNLEdBQUcyRjtRQUN2QixJQUFJLENBQUMwRSxTQUFTO1FBQ2QsSUFBSSxDQUFDckssTUFBTSxHQUFHK1Q7UUFDZCxPQUFPN0o7SUFDWDtJQUNBMkosWUFBWXRILEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQyxJQUFJLENBQUN0TixHQUFHLEVBQ1Q7UUFDSixJQUFJLENBQUNvTCxTQUFTO1FBQ2RrQyxNQUFNN0IsTUFBTSxDQUFDLElBQUksQ0FBQ3pMLEdBQUc7UUFDckJzTixNQUFNcUgsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUyxLQUFLbE8sWUFBWSxJQUFJLENBQUMySyxLQUFLLEdBQUcsSUFBSSxDQUFDdUQsU0FBUztRQUM1RSxJQUFJLENBQUNBLFNBQVMsR0FBR2xPO1FBQ2pCLElBQUksQ0FBQ3pHLEdBQUcsR0FBRztJQUNmO0lBQ0E2VSxRQUFRekQsS0FBSyxFQUFFO1FBQ1gsSUFBSSxDQUFDdUMsUUFBUSxJQUFJLENBQUN2QyxLQUFLLEVBQUVBLFFBQVE7WUFDN0IsSUFBSSxJQUFJLENBQUNwUixHQUFHLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDMlUsU0FBUyxHQUFHLElBQUksQ0FBQ3ZELEtBQUs7Z0JBQzNCLElBQUksQ0FBQ2hHLFNBQVM7WUFDbEI7WUFDQSxJQUFJLENBQUNnRyxLQUFLLEdBQUdBO1FBQ2pCO0lBQ0o7SUFDQTJELE9BQU96TCxLQUFLLEVBQUU2RCxTQUFTLEVBQUU7UUFDckIrRixlQUFlLElBQUksRUFBRTVKLE9BQU82RDtJQUNoQztJQUNBLDBEQUEwRDtJQUMxRDZILFlBQVlDLElBQUksRUFBRTtRQUNkLElBQUk3RCxRQUFRNkQsS0FBS0MsSUFBSSxDQUFDaE4sVUFBVSxFQUFFaU4sTUFBTUYsS0FBS0MsSUFBSSxDQUFDaEUsS0FBSztRQUN2RCxJQUFJRSxPQUNBLElBQUksQ0FBQ0EsS0FBSyxHQUFHb0MsYUFBYXBDLE9BQU8sSUFBSSxDQUFDQSxLQUFLLElBQUksQ0FBQztRQUNwRCxJQUFJK0QsS0FDQSxJQUFJLENBQUMvRCxLQUFLLEdBQUdvQyxhQUFhO1lBQUV0QyxPQUFPaUU7UUFBSSxHQUFHLElBQUksQ0FBQy9ELEtBQUssSUFBSSxDQUFDO0lBQ2pFO0lBQ0FYLFNBQVNwSCxHQUFHLEVBQUU7UUFDVixPQUFPc0ksZUFBZSxJQUFJLEVBQUV0STtJQUNoQztJQUNBYyxTQUFTbEssSUFBSSxFQUFFO1FBQ1gsSUFBSUEsS0FBSzBCLFFBQVEsSUFBSSxPQUFPO1lBQ3hCLElBQUksQ0FBQzhKLE1BQU0sQ0FBQ3hMO1lBQ1osSUFBSSxDQUFDOEksS0FBSyxJQUFJLEVBQUUsdUJBQXVCLE1BQUssRUFBRSxzQkFBc0I7UUFDeEU7SUFDSjtJQUNBWSxLQUFLUCxJQUFJLEVBQUVRLEtBQUssRUFBRTtRQUNkLElBQUl3TDtRQUNKLElBQUksQ0FBQyxJQUFJLENBQUNwVixHQUFHLEVBQUU7WUFDWCxJQUFJLENBQUN5TCxNQUFNLENBQUMzRSxTQUFTMEssYUFBYSxDQUFDO1lBQ25DLElBQUksQ0FBQ3hSLEdBQUcsQ0FBQ21SLFNBQVMsR0FBRztZQUNyQixJQUFJLENBQUN3RCxTQUFTLEdBQUcsSUFBSSxDQUFDdkQsS0FBSyxHQUFHLE9BQU8zSztRQUN6QyxPQUNLLElBQUksSUFBSSxDQUFDc0MsS0FBSyxHQUFHLEVBQUUsdUJBQXVCLEtBQUk7WUFDL0NkLGdCQUFnQixJQUFJLENBQUNqSSxHQUFHO1lBQ3hCLElBQUksQ0FBQ0EsR0FBRyxDQUFDbVIsU0FBUyxHQUFHO1lBQ3JCLElBQUksQ0FBQ3dELFNBQVMsR0FBRyxJQUFJLENBQUN2RCxLQUFLLEdBQUcsT0FBTzNLO1FBQ3pDO1FBQ0EsSUFBSSxJQUFJLENBQUNrTyxTQUFTLEtBQUtsTyxXQUFXO1lBQzlCeU4sWUFBWSxJQUFJLENBQUNsVSxHQUFHLEVBQUUsSUFBSSxDQUFDMlUsU0FBUyxFQUFFLElBQUksQ0FBQ3ZELEtBQUs7WUFDaEQsSUFBSSxDQUFDcFIsR0FBRyxDQUFDcVYsU0FBUyxDQUFDQyxHQUFHLENBQUM7WUFDdkIsSUFBSSxDQUFDWCxTQUFTLEdBQUdsTztRQUNyQjtRQUNBLEtBQUssQ0FBQ2tELEtBQUtQLE1BQU1RO1FBQ2pCLElBQUltRSxPQUFPLElBQUksQ0FBQy9OLEdBQUcsQ0FBQzBLLFNBQVM7UUFDN0IsTUFBT3FELFFBQVFqRixZQUFZbUIsR0FBRyxDQUFDOEQsaUJBQWlCK0MsU0FDNUMvQyxPQUFPQSxLQUFLckQsU0FBUztRQUN6QixJQUFJLENBQUNxRCxRQUFRLENBQUMsSUFBSSxDQUFDaE4sTUFBTSxJQUNyQmdOLEtBQUtwTSxRQUFRLElBQUksUUFBUSxDQUFDLENBQUN5VCxLQUFLdE0sWUFBWW1CLEdBQUcsQ0FBQzhELEtBQUksTUFBTyxRQUFRcUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdkksVUFBVSxLQUFLLFNBQ3pHLEVBQUMwQyxRQUFRRixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM5RixRQUFRLENBQUNnTSxJQUFJLENBQUN2RSxDQUFBQSxLQUFNQSxjQUFjYixTQUFRLEdBQUk7WUFDekUsSUFBSXFGLE9BQU8xTyxTQUFTMEssYUFBYSxDQUFDO1lBQ2xDZ0UsS0FBS0MsUUFBUSxHQUFHO1lBQ2hCLElBQUksQ0FBQ3pWLEdBQUcsQ0FBQzBWLFdBQVcsQ0FBQ0Y7UUFDekI7SUFDSjtJQUNBRyxrQkFBa0I7UUFDZCxJQUFJLElBQUksQ0FBQ3BNLFFBQVEsQ0FBQ3hJLE1BQU0sSUFBSSxLQUFLLElBQUksQ0FBQ0EsTUFBTSxHQUFHLElBQzNDLE9BQU87UUFDWCxJQUFJNlUsYUFBYSxHQUFHQztRQUNwQixLQUFLLElBQUl2TSxTQUFTLElBQUksQ0FBQ0MsUUFBUSxDQUFFO1lBQzdCLElBQUksQ0FBRUQsQ0FBQUEsaUJBQWlCNkcsUUFBTyxLQUFNLFNBQVNuTSxJQUFJLENBQUNzRixNQUFNc0QsSUFBSSxHQUN4RCxPQUFPO1lBQ1gsSUFBSWtGLFFBQVFsUixlQUFlMEksTUFBTXRKLEdBQUc7WUFDcEMsSUFBSThSLE1BQU0vUSxNQUFNLElBQUksR0FDaEIsT0FBTztZQUNYNlUsY0FBYzlELEtBQUssQ0FBQyxFQUFFLENBQUNsUCxLQUFLO1lBQzVCaVQsYUFBYS9ELEtBQUssQ0FBQyxFQUFFLENBQUMvTyxNQUFNO1FBQ2hDO1FBQ0EsT0FBTyxDQUFDNlMsYUFBYSxPQUFPO1lBQ3hCRSxZQUFZLElBQUksQ0FBQzlWLEdBQUcsQ0FBQ3dFLHFCQUFxQixHQUFHekIsTUFBTTtZQUNuRGdULFdBQVdILGFBQWEsSUFBSSxDQUFDN1UsTUFBTTtZQUNuQzhVO1FBQ0o7SUFDSjtJQUNBakYsU0FBU3ZILEdBQUcsRUFBRWhHLElBQUksRUFBRTtRQUNoQixJQUFJckIsT0FBTzRQLGlCQUFpQixJQUFJLEVBQUV2SSxLQUFLaEc7UUFDdkMsNkRBQTZEO1FBQzdELHlDQUF5QztRQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDa0csUUFBUSxDQUFDeEksTUFBTSxJQUFJaUIsUUFBUSxJQUFJLENBQUNKLE1BQU0sRUFBRTtZQUM5QyxJQUFJLEVBQUVvVSxZQUFZLEVBQUUsR0FBRyxJQUFJLENBQUNwVSxNQUFNLENBQUN3SCxJQUFJLENBQUM2TSxTQUFTLEVBQUVsVCxTQUFTZixLQUFLSyxNQUFNLEdBQUdMLEtBQUtJLEdBQUc7WUFDbEYsSUFBSWMsS0FBS0MsR0FBRyxDQUFDSixTQUFTaVQsYUFBYUYsVUFBVSxJQUFJLEtBQUtFLGFBQWFILFVBQVUsR0FBRzlTLFFBQVE7Z0JBQ3BGLElBQUltVCxPQUFPLENBQUNuVCxTQUFTaVQsYUFBYUgsVUFBVSxJQUFJO2dCQUNoRCxPQUFPO29CQUFFelQsS0FBS0osS0FBS0ksR0FBRyxHQUFHOFQ7b0JBQU03VCxRQUFRTCxLQUFLSyxNQUFNLEdBQUc2VDtvQkFBTWpVLE1BQU1ELEtBQUtDLElBQUk7b0JBQUVFLE9BQU9ILEtBQUtDLElBQUk7Z0JBQUM7WUFDakc7UUFDSjtRQUNBLE9BQU9EO0lBQ1g7SUFDQXFMLE9BQU84SSxNQUFNLEVBQUU7UUFBRSxPQUFPO0lBQU87SUFDL0JDLFNBQVM7UUFBRSxPQUFPO0lBQU07SUFDeEIsT0FBT3BFLEtBQUtxRSxPQUFPLEVBQUVoTixHQUFHLEVBQUU7UUFDdEIsSUFBSyxJQUFJM0MsSUFBSSxHQUFHeEYsTUFBTSxHQUFHd0YsSUFBSTJQLFFBQVE5TSxRQUFRLENBQUN4SSxNQUFNLEVBQUUyRixJQUFLO1lBQ3ZELElBQUk0UCxRQUFRRCxRQUFROU0sUUFBUSxDQUFDN0MsRUFBRSxFQUFFdUUsTUFBTS9KLE1BQU1vVixNQUFNdlYsTUFBTTtZQUN6RCxJQUFJa0ssT0FBTzVCLEtBQUs7Z0JBQ1osSUFBSWlOLGlCQUFpQjdCLFVBQ2pCLE9BQU82QjtnQkFDWCxJQUFJckwsTUFBTTVCLEtBQ047WUFDUjtZQUNBbkksTUFBTStKLE1BQU1xTCxNQUFNOU0sVUFBVTtRQUNoQztRQUNBLE9BQU87SUFDWDtBQUNKO0FBQ0EsTUFBTStNLHdCQUF3QnpOO0lBQzFCdEQsWUFBWTZNLE1BQU0sRUFBRXRSLE1BQU0sRUFBRWtVLElBQUksQ0FBRTtRQUM5QixLQUFLO1FBQ0wsSUFBSSxDQUFDNUMsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3RSLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNrVSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDekwsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQzhJLFVBQVUsR0FBRztJQUN0QjtJQUNBdEYsTUFBTXBHLElBQUksRUFBRUMsRUFBRSxFQUFFb0csTUFBTSxFQUFFdUosU0FBUyxFQUFFckosU0FBUyxFQUFFQyxPQUFPLEVBQUU7UUFDbkQsSUFBSUgsVUFBVyxFQUFFQSxDQUFBQSxrQkFBa0JzSixlQUFjLEtBQU0sQ0FBQyxJQUFJLENBQUNsRSxNQUFNLENBQUNLLE9BQU8sQ0FBQ3pGLE9BQU9vRixNQUFNLEtBQ3JGekwsT0FBTyxLQUFLdUcsYUFBYSxLQUFLdEcsS0FBSyxJQUFJLENBQUM5RixNQUFNLElBQUlxTSxXQUFXLElBQzdELE9BQU87UUFDWCxJQUFJLENBQUNyTSxNQUFNLEdBQUc2RixPQUFRcUcsQ0FBQUEsU0FBU0EsT0FBT2xNLE1BQU0sR0FBRyxLQUFNLEtBQUksQ0FBQ0EsTUFBTSxHQUFHOEYsRUFBQztRQUNwRSxPQUFPO0lBQ1g7SUFDQTRKLFNBQVNwSCxHQUFHLEVBQUU7UUFDVixPQUFPQSxPQUFPLElBQUlaLE9BQU9FLE1BQU0sQ0FBQyxJQUFJLENBQUMzSSxHQUFHLElBQUl5SSxPQUFPRyxLQUFLLENBQUMsSUFBSSxDQUFDNUksR0FBRyxFQUFFcUosT0FBTyxJQUFJLENBQUN0SSxNQUFNO0lBQ3pGO0lBQ0FrTixNQUFNNkcsRUFBRSxFQUFFO1FBQ04sSUFBSTJCLE1BQU0sSUFBSSxDQUFDMVYsTUFBTSxHQUFHK1Q7UUFDeEIsSUFBSSxDQUFDL1QsTUFBTSxHQUFHK1Q7UUFDZCxJQUFJN0osTUFBTSxJQUFJc0wsZ0JBQWdCLElBQUksQ0FBQ2xFLE1BQU0sRUFBRW9FLEtBQUssSUFBSSxDQUFDeEIsSUFBSTtRQUN6RGhLLElBQUl6QixVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVO1FBQ2hDLE9BQU95QjtJQUNYO0lBQ0EsSUFBSTFCLFdBQVc7UUFBRSxPQUFPVjtJQUFZO0lBQ3BDYyxLQUFLUCxJQUFJLEVBQUU7UUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDcEosR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDcVMsTUFBTSxDQUFDRSxTQUFTLENBQUMsSUFBSSxDQUFDdlMsR0FBRyxFQUFFb0osT0FBTztZQUNyRCxJQUFJLElBQUksQ0FBQ3BKLEdBQUcsSUFBSSxJQUFJLENBQUNzUyxVQUFVLEVBQzNCLElBQUksQ0FBQ0EsVUFBVSxDQUFDdkcsT0FBTyxDQUFDLElBQUksQ0FBQy9MLEdBQUc7WUFDcEMsSUFBSSxDQUFDc1MsVUFBVSxHQUFHO1lBQ2xCLElBQUksQ0FBQzdHLE1BQU0sQ0FBQyxJQUFJLENBQUM0RyxNQUFNLENBQUNHLEtBQUssQ0FBQ3BKO1lBQzlCLElBQUksQ0FBQyxJQUFJLENBQUNpSixNQUFNLENBQUNJLFFBQVEsRUFDckIsSUFBSSxDQUFDelMsR0FBRyxDQUFDOEIsZUFBZSxHQUFHO1FBQ25DO0lBQ0o7SUFDQSxJQUFJa0gsa0JBQWtCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDcEgsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDd0gsSUFBSSxDQUFDeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDbVEsS0FBSyxDQUFDLElBQUksQ0FBQ3RILFVBQVUsRUFBRSxJQUFJLENBQUNFLFFBQVEsSUFBSWxMLG1EQUFJQSxDQUFDMlUsS0FBSztJQUN0RztJQUNBakksa0JBQWtCO1FBQUUsT0FBTztJQUFNO0lBQ2pDMEMsT0FBT0MsS0FBSyxFQUFFO1FBQ1YsSUFBSUEsaUJBQWlCaUosbUJBQ2pCakosTUFBTStFLE1BQU0sQ0FBQzdNLFdBQVcsSUFBSSxJQUFJLENBQUM2TSxNQUFNLENBQUM3TSxXQUFXLEVBQUU7WUFDckQsSUFBSSxDQUFDOEgsTUFBTStFLE1BQU0sQ0FBQ0ssT0FBTyxDQUFDLElBQUksQ0FBQ0wsTUFBTSxHQUNqQyxJQUFJLENBQUNqSCxTQUFTLENBQUM7WUFDbkIsSUFBSSxJQUFJLENBQUNwTCxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUNzUyxVQUFVLEVBQzVCLElBQUksQ0FBQ0EsVUFBVSxHQUFHLElBQUksQ0FBQ0QsTUFBTTtZQUNqQyxJQUFJLENBQUNBLE1BQU0sR0FBRy9FLE1BQU0rRSxNQUFNO1lBQzFCLElBQUksQ0FBQ3RSLE1BQU0sR0FBR3VNLE1BQU12TSxNQUFNO1lBQzFCLElBQUksQ0FBQ2tVLElBQUksR0FBRzNILE1BQU0ySCxJQUFJO1lBQ3RCLElBQUksQ0FBQ3pMLFVBQVUsR0FBRzhELE1BQU05RCxVQUFVO1lBQ2xDLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBeUMsaUJBQWlCO1FBQUUsT0FBTztJQUFNO0lBQ2hDRSxZQUFZd0csS0FBSyxFQUFFO1FBQUUsT0FBTyxJQUFJLENBQUNOLE1BQU0sQ0FBQ2xHLFdBQVcsQ0FBQ3dHO0lBQVE7SUFDNUQsSUFBSTlGLGFBQWE7UUFBRSxPQUFPO0lBQU87SUFDakMsSUFBSUMsV0FBVztRQUFFLE9BQU87SUFBTTtJQUM5QjhELFNBQVN2SCxHQUFHLEVBQUVoRyxJQUFJLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNnUCxNQUFNLENBQUN6QixRQUFRLENBQUMsSUFBSSxDQUFDNVEsR0FBRyxFQUFFcUosS0FBS2hHO0lBQy9DO0lBQ0EwSSxVQUFVO1FBQ04sS0FBSyxDQUFDQTtRQUNOLElBQUksSUFBSSxDQUFDL0wsR0FBRyxFQUNSLElBQUksQ0FBQ3FTLE1BQU0sQ0FBQ3RHLE9BQU8sQ0FBQyxJQUFJLENBQUMvTCxHQUFHO0lBQ3BDO0lBQ0FvVyxPQUFPL1MsSUFBSSxFQUFFO1FBQ1QsSUFBSSxFQUFFcVQsU0FBUyxFQUFFQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMxQixJQUFJO1FBQ3RDLE9BQU95QixhQUFhQyxVQUFVLFFBQVF0VCxPQUFPLElBQUlxVCxZQUFZLElBQUlDLFVBQVU7SUFDL0U7QUFDSjtBQUVBOzs7Ozs7QUFNQSxHQUNBLE1BQU1DO0lBQ0Y7Ozs7Ozs7O0lBUUEsR0FDQWhSLEdBQUd5TSxNQUFNLEVBQUU7UUFBRSxPQUFPO0lBQU87SUFDM0I7Ozs7OztJQU1BLEdBQ0FFLFVBQVV2UyxHQUFHLEVBQUVvSixJQUFJLEVBQUU7UUFBRSxPQUFPO0lBQU87SUFDckM7O0lBRUEsR0FDQXNKLFFBQVFwRixLQUFLLEVBQUU7UUFDWCxPQUFPLElBQUksSUFBSUEsU0FBUyxJQUFJLENBQUM5SCxXQUFXLElBQUk4SCxNQUFNOUgsV0FBVyxJQUFJLElBQUksQ0FBQ0ksRUFBRSxDQUFDMEg7SUFDN0U7SUFDQTs7Ozs7SUFLQSxHQUNBLElBQUl1SixrQkFBa0I7UUFBRSxPQUFPLENBQUM7SUFBRztJQUNuQzs7Ozs7SUFLQSxHQUNBLElBQUlDLGFBQWE7UUFBRSxPQUFPO0lBQUc7SUFDN0I7Ozs7SUFJQSxHQUNBM0ssWUFBWXdHLEtBQUssRUFBRTtRQUFFLE9BQU87SUFBTTtJQUNsQzs7Ozs7O0lBTUEsR0FDQS9CLFNBQVM1USxHQUFHLEVBQUVxSixHQUFHLEVBQUVoRyxJQUFJLEVBQUU7UUFBRSxPQUFPO0lBQU07SUFDeEM7O0lBRUEsR0FDQSxJQUFJMEosV0FBVztRQUFFLE9BQU87SUFBTztJQUMvQjs7SUFFQSxHQUNBLElBQUkwRixXQUFXO1FBQUUsT0FBTztJQUFPO0lBQy9COzs7SUFHQSxHQUNBMUcsUUFBUS9MLEdBQUcsRUFBRSxDQUFFO0FBQ25CO0FBQ0E7O0FBRUEsR0FDQSxJQUFJK1csWUFBeUIsV0FBRixHQUFHLFNBQVVBLFNBQVM7SUFDN0M7O0lBRUEsR0FDQUEsU0FBUyxDQUFDQSxTQUFTLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNuQzs7SUFFQSxHQUNBQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQzNDOztJQUVBLEdBQ0FBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUc7SUFDMUM7O0lBRUEsR0FDQUEsU0FBUyxDQUFDQSxTQUFTLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUM5QyxPQUFPQTtBQUFTLEVBQUdBLGFBQWNBLENBQUFBLFlBQVksQ0FBQztBQUM5Qzs7Ozs7QUFLQSxHQUNBLE1BQU1DLG1CQUFtQjVZLHlEQUFVQTtJQUMvQm9ILFlBQ0E7O0lBRUEsR0FDQWtSLFNBQVMsRUFDVDs7SUFFQSxHQUNBQyxPQUFPLEVBQ1A7O0lBRUEsR0FDQXRFLE1BQU0sRUFDTjs7OztJQUlBLEdBQ0E2QyxJQUFJLENBQUU7UUFDRixLQUFLO1FBQ0wsSUFBSSxDQUFDd0IsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUN0RSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNkMsSUFBSSxHQUFHQTtJQUNoQjtJQUNBOztJQUVBLEdBQ0EsSUFBSStCLGlCQUFpQjtRQUFFLE9BQU87SUFBTztJQUNyQzs7Ozs7Ozs7SUFRQSxHQUNBLE9BQU9sRyxLQUFLbUUsSUFBSSxFQUFFO1FBQ2QsT0FBTyxJQUFJZ0MsZUFBZWhDO0lBQzlCO0lBQ0E7OztJQUdBLEdBQ0EsT0FBTzdDLE9BQU82QyxJQUFJLEVBQUU7UUFDaEIsSUFBSTdSLE9BQU9ILEtBQUtzRixHQUFHLENBQUMsQ0FBQyxPQUFPdEYsS0FBSytDLEdBQUcsQ0FBQyxPQUFPaVAsS0FBSzdSLElBQUksSUFBSSxLQUFLaVQsUUFBUSxDQUFDLENBQUNwQixLQUFLb0IsS0FBSztRQUNsRmpULFFBQVEsU0FBVSxDQUFDNlIsS0FBS2lDLFdBQVcsR0FDNUI5VCxPQUFPLElBQUksVUFBVSxtQkFBbUIsTUFBSyxDQUFDLFVBQVUsb0JBQW9CLE1BQzVFQSxPQUFPLElBQUksVUFBVSxvQkFBb0IsTUFBSyxDQUFDLFVBQVUscUJBQXFCO1FBQ3JGLE9BQU8sSUFBSStULGdCQUFnQmxDLE1BQU03UixNQUFNQSxNQUFNaVQsT0FBT3BCLEtBQUs3QyxNQUFNLElBQUksTUFBTTtJQUM3RTtJQUNBOzs7SUFHQSxHQUNBLE9BQU8zRixRQUFRd0ksSUFBSSxFQUFFO1FBQ2pCLElBQUlvQixRQUFRLENBQUMsQ0FBQ3BCLEtBQUtvQixLQUFLLEVBQUVJLFdBQVdDO1FBQ3JDLElBQUl6QixLQUFLbUMsVUFBVSxFQUFFO1lBQ2pCWCxZQUFZLENBQUMsVUFBVSxpQkFBaUI7WUFDeENDLFVBQVUsVUFBVSxlQUFlO1FBQ3ZDLE9BQ0s7WUFDRCxJQUFJLEVBQUV6UixLQUFLLEVBQUUrRixHQUFHLEVBQUUsR0FBR3FNLGFBQWFwQyxNQUFNb0I7WUFDeENJLFlBQVksQ0FBQ3hSLFFBQVNvUixRQUFRLENBQUMsVUFBVSxzQkFBc0IsTUFBSyxDQUFDLEVBQUUsdUJBQXVCLE1BQU0sVUFBVSxvQkFBb0IsR0FBdEIsSUFBNEI7WUFDeElLLFVBQVUsQ0FBQzFMLE1BQU9xTCxRQUFRLFVBQVUsb0JBQW9CLE1BQUssRUFBRSxxQkFBcUIsTUFBTSxDQUFDLFVBQVUsa0JBQWtCLEdBQXBCLElBQTBCO1FBQ2pJO1FBQ0EsT0FBTyxJQUFJYyxnQkFBZ0JsQyxNQUFNd0IsV0FBV0MsU0FBU0wsT0FBT3BCLEtBQUs3QyxNQUFNLElBQUksTUFBTTtJQUNyRjtJQUNBOzs7SUFHQSxHQUNBLE9BQU9rRixLQUFLckMsSUFBSSxFQUFFO1FBQ2QsT0FBTyxJQUFJc0MsZUFBZXRDO0lBQzlCO0lBQ0E7Ozs7SUFJQSxHQUNBLE9BQU9sUCxJQUFJeVIsRUFBRSxFQUFFQyxPQUFPLEtBQUssRUFBRTtRQUN6QixPQUFPeFosdURBQVFBLENBQUN1WixFQUFFLENBQUNBLElBQUlDO0lBQzNCO0lBQ0E7O0lBRUEsR0FDQUMsWUFBWTtRQUFFLE9BQU8sSUFBSSxDQUFDdEYsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxDQUFDd0UsZUFBZSxHQUFHLENBQUMsSUFBSTtJQUFPO0FBQ2pGO0FBQ0E7O0FBRUEsR0FDQUcsV0FBV1ksSUFBSSxHQUFHMVosdURBQVFBLENBQUMwVSxLQUFLO0FBQ2hDLE1BQU1zRSx1QkFBdUJGO0lBQ3pCeFIsWUFBWTBQLElBQUksQ0FBRTtRQUNkLElBQUksRUFBRWhRLEtBQUssRUFBRStGLEdBQUcsRUFBRSxHQUFHcU0sYUFBYXBDO1FBQ2xDLEtBQUssQ0FBQ2hRLFFBQVEsQ0FBQyxFQUFFLHVCQUF1QixNQUFLLFVBQVUsb0JBQW9CLEtBQUkrRixNQUFNLEVBQUUscUJBQXFCLE1BQUssQ0FBQyxVQUFVLGtCQUFrQixLQUFJLE1BQU1pSztRQUN4SixJQUFJLENBQUM1RCxPQUFPLEdBQUc0RCxLQUFLNUQsT0FBTyxJQUFJO1FBQy9CLElBQUksQ0FBQ0osS0FBSyxHQUFHZ0UsS0FBS2hFLEtBQUssSUFBSTtRQUMzQixJQUFJLENBQUNFLEtBQUssR0FBRzhELEtBQUtoTixVQUFVLElBQUk7SUFDcEM7SUFDQXRDLEdBQUcwSCxLQUFLLEVBQUU7UUFDTixJQUFJOEgsSUFBSXlDO1FBQ1IsT0FBTyxJQUFJLElBQUl2SyxTQUNYQSxpQkFBaUI0SixrQkFDYixJQUFJLENBQUM1RixPQUFPLElBQUloRSxNQUFNZ0UsT0FBTyxJQUM3QixDQUFDLElBQUksQ0FBQ0osS0FBSyxJQUFLLEVBQUNrRSxLQUFLLElBQUksQ0FBQ2hFLEtBQUssTUFBTSxRQUFRZ0UsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbEUsS0FBSyxNQUFPNUQsQ0FBQUEsTUFBTTRELEtBQUssSUFBSyxFQUFDMkcsS0FBS3ZLLE1BQU04RCxLQUFLLE1BQU0sUUFBUXlHLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzNHLEtBQUssTUFDdEt5QyxRQUFRLElBQUksQ0FBQ3ZDLEtBQUssRUFBRTlELE1BQU04RCxLQUFLLEVBQUU7SUFDN0M7SUFDQXJMLE1BQU1hLElBQUksRUFBRUMsS0FBS0QsSUFBSSxFQUFFO1FBQ25CLElBQUlBLFFBQVFDLElBQ1IsTUFBTSxJQUFJNEMsV0FBVztRQUN6QixPQUFPLEtBQUssQ0FBQzFELE1BQU1hLE1BQU1DO0lBQzdCO0FBQ0o7QUFDQXFRLGVBQWUxSixTQUFTLENBQUNzSyxLQUFLLEdBQUc7QUFDakMsTUFBTU4sdUJBQXVCUjtJQUN6QnhSLFlBQVkwUCxJQUFJLENBQUU7UUFDZCxLQUFLLENBQUMsQ0FBQyxVQUFVLGFBQWEsS0FBSSxDQUFDLFVBQVUsYUFBYSxLQUFJLE1BQU1BO0lBQ3hFO0lBQ0F0UCxHQUFHMEgsS0FBSyxFQUFFO1FBQ04sT0FBT0EsaUJBQWlCa0ssa0JBQ3BCLElBQUksQ0FBQ3RDLElBQUksQ0FBQ2hFLEtBQUssSUFBSTVELE1BQU00SCxJQUFJLENBQUNoRSxLQUFLLElBQ25DeUMsUUFBUSxJQUFJLENBQUN1QixJQUFJLENBQUNoTixVQUFVLEVBQUVvRixNQUFNNEgsSUFBSSxDQUFDaE4sVUFBVTtJQUMzRDtJQUNBbkMsTUFBTWEsSUFBSSxFQUFFQyxLQUFLRCxJQUFJLEVBQUU7UUFDbkIsSUFBSUMsTUFBTUQsTUFDTixNQUFNLElBQUk2QyxXQUFXO1FBQ3pCLE9BQU8sS0FBSyxDQUFDMUQsTUFBTWEsTUFBTUM7SUFDN0I7QUFDSjtBQUNBMlEsZUFBZWhLLFNBQVMsQ0FBQ3VLLE9BQU8sR0FBRzVaLHNEQUFPQSxDQUFDNlosV0FBVztBQUN0RFIsZUFBZWhLLFNBQVMsQ0FBQ3NLLEtBQUssR0FBRztBQUNqQyxNQUFNVix3QkFBd0JKO0lBQzFCeFIsWUFBWTBQLElBQUksRUFBRXdCLFNBQVMsRUFBRUMsT0FBTyxFQUFFTCxLQUFLLEVBQUVqRSxNQUFNLEVBQUU0RixTQUFTLENBQUU7UUFDNUQsS0FBSyxDQUFDdkIsV0FBV0MsU0FBU3RFLFFBQVE2QztRQUNsQyxJQUFJLENBQUNvQixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDMkIsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNGLE9BQU8sR0FBRyxDQUFDekIsUUFBUW5ZLHNEQUFPQSxDQUFDK1osUUFBUSxHQUFHeEIsYUFBYSxJQUFJdlksc0RBQU9BLENBQUM2WixXQUFXLEdBQUc3WixzREFBT0EsQ0FBQ2dhLFVBQVU7SUFDeEc7SUFDQSx3Q0FBd0M7SUFDeEMsSUFBSUMsT0FBTztRQUNQLE9BQU8sSUFBSSxDQUFDMUIsU0FBUyxJQUFJLElBQUksQ0FBQ0MsT0FBTyxHQUFHSSxVQUFVc0IsV0FBVyxHQUN2RCxJQUFJLENBQUMzQixTQUFTLElBQUksSUFBSUssVUFBVXVCLFlBQVksR0FBR3ZCLFVBQVV3QixXQUFXO0lBQzlFO0lBQ0EsSUFBSXRCLGlCQUFpQjtRQUNqQixPQUFPLElBQUksQ0FBQ1gsS0FBSyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUNqRSxNQUFNLElBQUssS0FBSSxDQUFDQSxNQUFNLENBQUN3RSxlQUFlLElBQUksS0FBSyxJQUFJLENBQUN4RSxNQUFNLENBQUN5RSxVQUFVLEdBQUc7SUFDeEc7SUFDQWxSLEdBQUcwSCxLQUFLLEVBQUU7UUFDTixPQUFPQSxpQkFBaUI4SixtQkFDcEJvQixVQUFVLElBQUksQ0FBQ25HLE1BQU0sRUFBRS9FLE1BQU0rRSxNQUFNLEtBQ25DLElBQUksQ0FBQ2lFLEtBQUssSUFBSWhKLE1BQU1nSixLQUFLLElBQ3pCLElBQUksQ0FBQ0ksU0FBUyxJQUFJcEosTUFBTW9KLFNBQVMsSUFBSSxJQUFJLENBQUNDLE9BQU8sSUFBSXJKLE1BQU1xSixPQUFPO0lBQzFFO0lBQ0E1USxNQUFNYSxJQUFJLEVBQUVDLEtBQUtELElBQUksRUFBRTtRQUNuQixJQUFJLElBQUksQ0FBQ3FSLFNBQVMsSUFBS3JSLENBQUFBLE9BQU9DLE1BQU9ELFFBQVFDLE1BQU0sSUFBSSxDQUFDNlAsU0FBUyxHQUFHLEtBQUssSUFBSSxDQUFDQyxPQUFPLElBQUksQ0FBQyxHQUN0RixNQUFNLElBQUlsTixXQUFXO1FBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUN3TyxTQUFTLElBQUlwUixNQUFNRCxNQUN6QixNQUFNLElBQUk2QyxXQUFXO1FBQ3pCLE9BQU8sS0FBSyxDQUFDMUQsTUFBTWEsTUFBTUM7SUFDN0I7QUFDSjtBQUNBdVEsZ0JBQWdCNUosU0FBUyxDQUFDc0ssS0FBSyxHQUFHO0FBQ2xDLFNBQVNSLGFBQWFwQyxJQUFJLEVBQUVvQixRQUFRLEtBQUs7SUFDckMsSUFBSSxFQUFFbUMsZ0JBQWdCdlQsS0FBSyxFQUFFd1QsY0FBY3pOLEdBQUcsRUFBRSxHQUFHaUs7SUFDbkQsSUFBSWhRLFNBQVMsTUFDVEEsUUFBUWdRLEtBQUt5RCxTQUFTO0lBQzFCLElBQUkxTixPQUFPLE1BQ1BBLE1BQU1pSyxLQUFLeUQsU0FBUztJQUN4QixPQUFPO1FBQUV6VCxPQUFPQSxVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJQSxRQUFRb1I7UUFBT3JMLEtBQUtBLFFBQVEsUUFBUUEsUUFBUSxLQUFLLElBQUlBLE1BQU1xTDtJQUFNO0FBQzFIO0FBQ0EsU0FBU2tDLFVBQVU1RSxDQUFDLEVBQUVDLENBQUM7SUFDbkIsT0FBT0QsS0FBS0MsS0FBSyxDQUFDLENBQUVELENBQUFBLEtBQUtDLEtBQUtELEVBQUVsQixPQUFPLENBQUNtQixFQUFDO0FBQzdDO0FBQ0EsU0FBUytFLFNBQVNoUyxJQUFJLEVBQUVDLEVBQUUsRUFBRWdTLE1BQU0sRUFBRUMsU0FBUyxDQUFDO0lBQzFDLElBQUkvSyxPQUFPOEssT0FBTzlYLE1BQU0sR0FBRztJQUMzQixJQUFJZ04sUUFBUSxLQUFLOEssTUFBTSxDQUFDOUssS0FBSyxHQUFHK0ssVUFBVWxTLE1BQ3RDaVMsTUFBTSxDQUFDOUssS0FBSyxHQUFHN0ssS0FBS3NGLEdBQUcsQ0FBQ3FRLE1BQU0sQ0FBQzlLLEtBQUssRUFBRWxIO1NBRXRDZ1MsT0FBT3RTLElBQUksQ0FBQ0ssTUFBTUM7QUFDMUI7QUFFQSxNQUFNa1M7SUFDRnZULFlBQVlwRixHQUFHLEVBQUVpSixHQUFHLEVBQUU0QixHQUFHLEVBQUUrTix1QkFBdUIsQ0FBRTtRQUNoRCxJQUFJLENBQUM1WSxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDaUosR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQzRCLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUMrTix1QkFBdUIsR0FBR0E7UUFDL0IsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ3BMLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNxTCxhQUFhLEdBQUcsRUFBRSxVQUFVO1FBQ2pDLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEVBQUU7UUFDckIseUVBQXlFO1FBQ3pFLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ2xNLFNBQVMsR0FBRyxDQUFDO1FBQ2xCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUM7UUFDaEIsSUFBSSxDQUFDUixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUMwTSxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE1BQU0sR0FBR25aLElBQUlvWixJQUFJO1FBQ3RCLElBQUksQ0FBQ0MsSUFBSSxHQUFHcFE7SUFDaEI7SUFDQXFRLGFBQWE7UUFDVCxJQUFJLElBQUksQ0FBQ1QsT0FBTyxDQUFDbFksTUFBTSxJQUFJLEdBQ3ZCLE9BQU8sQ0FBQyxJQUFJLENBQUMrTSxZQUFZLElBQUksSUFBSSxDQUFDMU4sR0FBRyxDQUFDdVosTUFBTSxDQUFDLElBQUksQ0FBQ3RRLEdBQUcsRUFBRXpDLElBQUksSUFBSSxJQUFJLENBQUN5QyxHQUFHO1FBQzNFLElBQUkwRSxPQUFPLElBQUksQ0FBQ2tMLE9BQU8sQ0FBQyxJQUFJLENBQUNBLE9BQU8sQ0FBQ2xZLE1BQU0sR0FBRyxFQUFFO1FBQ2hELE9BQU8sQ0FBRWdOLENBQUFBLEtBQUt2RSxVQUFVLElBQUl1RSxnQkFBZ0J3SSxtQkFBbUJ4SSxLQUFLa0gsSUFBSSxDQUFDMEIsT0FBTyxHQUFHO0lBQ3ZGO0lBQ0FpRCxVQUFVO1FBQ04sSUFBSSxDQUFDLElBQUksQ0FBQ1YsT0FBTyxFQUFFO1lBQ2YsSUFBSSxDQUFDRCxPQUFPLENBQUMxUyxJQUFJLENBQUMsSUFBSSxDQUFDMlMsT0FBTyxHQUFHLElBQUl6RTtZQUNyQyxJQUFJLENBQUM0RSxXQUFXLEdBQUc7UUFDdkI7UUFDQSxPQUFPLElBQUksQ0FBQ0gsT0FBTztJQUN2QjtJQUNBVyxZQUFZQyxTQUFTLElBQUksQ0FBQ1YsV0FBVyxFQUFFO1FBQ25DLElBQUksSUFBSSxDQUFDRCxhQUFhLEVBQUU7WUFDcEIsSUFBSSxDQUFDRCxPQUFPLENBQUNuRSxNQUFNLENBQUNnRixVQUFVLElBQUkvRyxpQkFBaUIsQ0FBQyxJQUFJOEcsU0FBU0EsT0FBTy9ZLE1BQU07WUFDOUUsSUFBSSxDQUFDb1ksYUFBYSxHQUFHLEVBQUUsVUFBVTtRQUNyQztJQUNKO0lBQ0FhLGVBQWU1USxJQUFJLEVBQUU7UUFDakIsSUFBSSxDQUFDeVEsV0FBVztRQUNoQixJQUFJLENBQUNYLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0QsT0FBTyxDQUFDMVMsSUFBSSxDQUFDNkM7SUFDdEI7SUFDQTZRLE9BQU83TSxPQUFPLEVBQUU7UUFDWixJQUFJLElBQUksQ0FBQytMLGFBQWEsSUFBSS9MLFdBQVcsSUFBSSxDQUFDZ00sV0FBVyxDQUFDclksTUFBTSxFQUN4RCxJQUFJLENBQUM4WSxXQUFXO2FBRWhCLElBQUksQ0FBQ1YsYUFBYSxHQUFHLEVBQUUsVUFBVTtRQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDTyxVQUFVLE1BQ2hCLENBQUV0TSxDQUFBQSxXQUFXLElBQUksQ0FBQzZMLE9BQU8sQ0FBQ2xZLE1BQU0sSUFBSSxJQUFJLENBQUNrWSxPQUFPLENBQUMsSUFBSSxDQUFDQSxPQUFPLENBQUNsWSxNQUFNLEdBQUcsRUFBRSxZQUFZd1YsZUFBYyxHQUNuRyxJQUFJLENBQUNxRCxPQUFPO0lBQ3BCO0lBQ0FNLFVBQVVuWixNQUFNLEVBQUUrWSxNQUFNLEVBQUUzTSxTQUFTLEVBQUU7UUFDakMsTUFBT3BNLFNBQVMsRUFBRztZQUNmLElBQUksSUFBSSxDQUFDdVksT0FBTyxJQUFJLElBQUksQ0FBQzFNLElBQUksQ0FBQzdMLE1BQU0sRUFBRTtnQkFDbEMsSUFBSSxFQUFFeVQsS0FBSyxFQUFFMkYsU0FBUyxFQUFFQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUNiLE1BQU0sQ0FBQzFQLElBQUksQ0FBQyxJQUFJLENBQUM0UCxJQUFJO2dCQUMzRCxJQUFJLENBQUNBLElBQUksR0FBRztnQkFDWixJQUFJVyxNQUNBLE1BQU0sSUFBSUMsTUFBTTtnQkFDcEIsSUFBSUYsV0FBVztvQkFDWCxJQUFJLENBQUMsSUFBSSxDQUFDVCxVQUFVLElBQ2hCLElBQUksQ0FBQ0UsT0FBTztvQkFDaEIsSUFBSSxJQUFJLENBQUNYLE9BQU8sQ0FBQ2xZLE1BQU0sRUFDbkIsSUFBSSxDQUFDa1ksT0FBTyxDQUFDLElBQUksQ0FBQ0EsT0FBTyxDQUFDbFksTUFBTSxHQUFHLEVBQUUsQ0FBQ3lJLFVBQVUsR0FBRzt5QkFFbkQsSUFBSSxDQUFDc0UsWUFBWSxHQUFHO29CQUN4QixJQUFJLENBQUMrTCxXQUFXO29CQUNoQixJQUFJLENBQUNYLE9BQU8sR0FBRztvQkFDZixJQUFJLENBQUNHLFdBQVcsR0FBRztvQkFDbkJ0WTtvQkFDQTtnQkFDSixPQUNLO29CQUNELElBQUksQ0FBQzZMLElBQUksR0FBRzRIO29CQUNaLElBQUksQ0FBQzhFLE9BQU8sR0FBRztnQkFDbkI7WUFDSjtZQUNBLElBQUlnQixPQUFPcFgsS0FBSytDLEdBQUcsQ0FBQyxJQUFJLENBQUMyRyxJQUFJLENBQUM3TCxNQUFNLEdBQUcsSUFBSSxDQUFDdVksT0FBTyxFQUFFdlksUUFBUSxJQUFJLFdBQVc7WUFDNUUsSUFBSSxDQUFDOFksV0FBVyxDQUFDQyxPQUFPdkosS0FBSyxDQUFDdUosT0FBTy9ZLE1BQU0sR0FBR29NO1lBQzlDLElBQUksQ0FBQ3lNLE9BQU8sR0FBRzdFLE1BQU0sQ0FBQ2dGLFVBQVUsSUFBSTVKLFNBQVMsSUFBSSxDQUFDdkQsSUFBSSxDQUFDMkQsS0FBSyxDQUFDLElBQUksQ0FBQytJLE9BQU8sRUFBRSxJQUFJLENBQUNBLE9BQU8sR0FBR2dCLFFBQVFSLFNBQVMzTTtZQUMzRyxJQUFJLENBQUNrTSxXQUFXLEdBQUc7WUFDbkIsSUFBSSxDQUFDQyxPQUFPLElBQUlnQjtZQUNoQnZaLFVBQVV1WjtZQUNWbk4sWUFBWTtRQUNoQjtJQUNKO0lBQ0FvTixLQUFLM1QsSUFBSSxFQUFFQyxFQUFFLEVBQUVpVCxNQUFNLEVBQUUzTSxTQUFTLEVBQUU7UUFDOUIsSUFBSSxDQUFDK00sU0FBUyxDQUFDclQsS0FBS0QsTUFBTWtULFFBQVEzTTtRQUNsQyxJQUFJLENBQUM5RCxHQUFHLEdBQUd4QztRQUNYLElBQUksSUFBSSxDQUFDc0csU0FBUyxHQUFHLEdBQ2pCLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtJQUN6QjtJQUNBMkssTUFBTWxSLElBQUksRUFBRUMsRUFBRSxFQUFFb08sSUFBSSxFQUFFNkUsTUFBTSxFQUFFM00sU0FBUyxFQUFFNUwsS0FBSyxFQUFFO1FBQzVDLElBQUksSUFBSSxDQUFDeVgsdUJBQXVCLENBQUN6WCxNQUFNLElBQUkwVCxnQkFBZ0JtQyxpQkFBaUI7WUFDeEUsSUFBSW5DLEtBQUtxQixLQUFLLEVBQ1YsTUFBTSxJQUFJN00sV0FBVztZQUN6QixJQUFJNUMsS0FBSyxJQUFJLENBQUN6RyxHQUFHLENBQUN1WixNQUFNLENBQUMsSUFBSSxDQUFDdFEsR0FBRyxFQUFFeEMsRUFBRSxFQUNqQyxNQUFNLElBQUk0QyxXQUFXO1FBQzdCO1FBQ0EsSUFBSWdOLE1BQU01UCxLQUFLRDtRQUNmLElBQUlxTyxnQkFBZ0JtQyxpQkFBaUI7WUFDakMsSUFBSW5DLEtBQUtxQixLQUFLLEVBQUU7Z0JBQ1osSUFBSXJCLEtBQUt5QixTQUFTLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQ2dELFVBQVUsSUFDdEMsSUFBSSxDQUFDRSxPQUFPO2dCQUNoQixJQUFJLENBQUNJLGNBQWMsQ0FBQyxJQUFJekQsZ0JBQWdCdEIsS0FBSzVDLE1BQU0sSUFBSSxJQUFJbUksV0FBVyxRQUFRL0QsS0FBS3hCO1lBQ3ZGLE9BQ0s7Z0JBQ0QsSUFBSTdMLE9BQU8rSSxXQUFXQyxNQUFNLENBQUM2QyxLQUFLNUMsTUFBTSxJQUFJLElBQUltSSxXQUFXLFNBQVMvRCxLQUFLQSxNQUFNLElBQUl4QixLQUFLeUIsU0FBUztnQkFDakcsSUFBSStELGVBQWUsSUFBSSxDQUFDcEIsV0FBVyxJQUFJLENBQUNqUSxLQUFLeUQsVUFBVSxJQUFJTSxhQUFhMk0sT0FBTy9ZLE1BQU0sSUFDaEY2RixDQUFBQSxPQUFPQyxNQUFNb08sS0FBS3lCLFNBQVMsR0FBRztnQkFDbkMsSUFBSWdFLGNBQWMsQ0FBQ3RSLEtBQUt5RCxVQUFVLElBQUtqRyxDQUFBQSxPQUFPQyxNQUFNc0csWUFBWTJNLE9BQU8vWSxNQUFNLElBQUlrVSxLQUFLeUIsU0FBUyxJQUFJO2dCQUNuRyxJQUFJYSxPQUFPLElBQUksQ0FBQ3FDLE9BQU87Z0JBQ3ZCLElBQUksSUFBSSxDQUFDVCxhQUFhLElBQUksRUFBRSxnQkFBZ0IsT0FBTSxDQUFDc0IsZ0JBQWdCLENBQUNyUixLQUFLeUQsVUFBVSxFQUMvRSxJQUFJLENBQUNzTSxhQUFhLEdBQUcsRUFBRSxVQUFVO2dCQUNyQyxJQUFJLENBQUNVLFdBQVcsQ0FBQ0M7Z0JBQ2pCLElBQUlXLGNBQWM7b0JBQ2RsRCxLQUFLeEMsTUFBTSxDQUFDZ0YsVUFBVSxJQUFJL0csaUJBQWlCLElBQUk4RyxTQUFTM007b0JBQ3hEQSxZQUFZMk0sT0FBTy9ZLE1BQU0sR0FBR21DLEtBQUtzRixHQUFHLENBQUMsR0FBRzJFLFlBQVkyTSxPQUFPL1ksTUFBTTtnQkFDckU7Z0JBQ0F3VyxLQUFLeEMsTUFBTSxDQUFDZ0YsVUFBVTNRLE1BQU0wUSxTQUFTM007Z0JBQ3JDLElBQUksQ0FBQ2tNLFdBQVcsR0FBR3FCO2dCQUNuQixJQUFJLENBQUN2QixhQUFhLEdBQUcsQ0FBQ3VCLGNBQWMsRUFBRSxVQUFVLE1BQUs5VCxPQUFPQyxNQUFNc0csWUFBWTJNLE9BQU8vWSxNQUFNLEdBQUcsRUFBRSxXQUFXLE1BQUssRUFBRSxnQkFBZ0I7Z0JBQ2xJLElBQUksSUFBSSxDQUFDb1ksYUFBYSxFQUNsQixJQUFJLENBQUNDLFdBQVcsR0FBR1UsT0FBT3ZKLEtBQUs7WUFDdkM7UUFDSixPQUNLLElBQUksSUFBSSxDQUFDblEsR0FBRyxDQUFDdVosTUFBTSxDQUFDLElBQUksQ0FBQ3RRLEdBQUcsRUFBRXpDLElBQUksSUFBSSxJQUFJLENBQUN5QyxHQUFHLEVBQUU7WUFDakQsSUFBSSxDQUFDdVEsT0FBTyxHQUFHNUUsV0FBVyxDQUFDQztRQUMvQjtRQUNBLElBQUl3QixLQUFLO1lBQ0wsaURBQWlEO1lBQ2pELElBQUksSUFBSSxDQUFDNkMsT0FBTyxHQUFHN0MsT0FBTyxJQUFJLENBQUM3SixJQUFJLENBQUM3TCxNQUFNLEVBQUU7Z0JBQ3hDLElBQUksQ0FBQ3VZLE9BQU8sSUFBSTdDO1lBQ3BCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDZ0QsSUFBSSxJQUFJaEQsTUFBTyxLQUFJLENBQUM3SixJQUFJLENBQUM3TCxNQUFNLEdBQUcsSUFBSSxDQUFDdVksT0FBTztnQkFDbkQsSUFBSSxDQUFDMU0sSUFBSSxHQUFHO2dCQUNaLElBQUksQ0FBQzBNLE9BQU8sR0FBRztZQUNuQjtZQUNBLElBQUksQ0FBQ2pRLEdBQUcsR0FBR3hDO1FBQ2Y7UUFDQSxJQUFJLElBQUksQ0FBQ3NHLFNBQVMsR0FBRyxHQUNqQixJQUFJLENBQUNBLFNBQVMsR0FBR0E7SUFDekI7SUFDQSxPQUFPd04sTUFBTS9OLElBQUksRUFBRWhHLElBQUksRUFBRUMsRUFBRSxFQUFFK1QsV0FBVyxFQUFFQyxvQkFBb0IsRUFBRTtRQUM1RCxJQUFJQyxVQUFVLElBQUkvQixlQUFlbk0sTUFBTWhHLE1BQU1DLElBQUlnVTtRQUNqREMsUUFBUTFOLE9BQU8sR0FBR2xQLHVEQUFRQSxDQUFDNmMsS0FBSyxDQUFDSCxhQUFhaFUsTUFBTUMsSUFBSWlVO1FBQ3hELElBQUlBLFFBQVEzTixTQUFTLEdBQUcsR0FDcEIyTixRQUFRM04sU0FBUyxHQUFHMk4sUUFBUTFOLE9BQU87UUFDdkMwTixRQUFRYixNQUFNLENBQUNhLFFBQVExTixPQUFPO1FBQzlCLE9BQU8wTjtJQUNYO0FBQ0o7QUFDQSxTQUFTZixVQUFVM1EsSUFBSSxFQUFFMFEsTUFBTTtJQUMzQixLQUFLLElBQUkvSSxRQUFRK0ksT0FDYjFRLE9BQU8sSUFBSTBILFNBQVNDLE1BQU07UUFBQzNIO0tBQUssRUFBRUEsS0FBS3JJLE1BQU07SUFDakQsT0FBT3FJO0FBQ1g7QUFDQSxNQUFNb1IsbUJBQW1CNUQ7SUFDckJwUixZQUFZd1YsR0FBRyxDQUFFO1FBQ2IsS0FBSztRQUNMLElBQUksQ0FBQ0EsR0FBRyxHQUFHQTtJQUNmO0lBQ0FwVixHQUFHMEgsS0FBSyxFQUFFO1FBQUUsT0FBT0EsTUFBTTBOLEdBQUcsSUFBSSxJQUFJLENBQUNBLEdBQUc7SUFBRTtJQUMxQ3hJLFFBQVE7UUFBRSxPQUFPMUwsU0FBUzBLLGFBQWEsQ0FBQyxJQUFJLENBQUN3SixHQUFHO0lBQUc7SUFDbkR6SSxVQUFVbFMsR0FBRyxFQUFFO1FBQUUsT0FBT0EsSUFBSXNCLFFBQVEsQ0FBQ3NaLFdBQVcsTUFBTSxJQUFJLENBQUNELEdBQUc7SUFBRTtJQUNoRSxJQUFJak8sV0FBVztRQUFFLE9BQU87SUFBTTtBQUNsQztBQUVBOztBQUVBLEdBQ0EsSUFBSW1PLFlBQXlCLFdBQUYsR0FBRyxTQUFVQSxTQUFTO0lBQzdDLGdFQUFnRTtJQUNoRSxzQ0FBc0M7SUFDdEM7O0lBRUEsR0FDQUEsU0FBUyxDQUFDQSxTQUFTLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUNsQzs7SUFFQSxHQUNBQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQ3RDLE9BQU9BO0FBQVMsRUFBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlDLE1BQU1DLE1BQU1ELFVBQVVDLEdBQUcsRUFBRUMsTUFBTUYsVUFBVUUsR0FBRztBQUM5Qyx1REFBdUQ7QUFDdkQsU0FBU0MsSUFBSUMsR0FBRztJQUNaLElBQUk5SyxTQUFTLEVBQUU7SUFDZixJQUFLLElBQUk5SixJQUFJLEdBQUdBLElBQUk0VSxJQUFJdmEsTUFBTSxFQUFFMkYsSUFDNUI4SixPQUFPakssSUFBSSxDQUFDLEtBQUssQ0FBQytVLEdBQUcsQ0FBQzVVLEVBQUU7SUFDNUIsT0FBTzhKO0FBQ1g7QUFDQSwyQ0FBMkM7QUFDM0MsTUFBTStLLFdBQVcsV0FBVyxHQUFFRixJQUFJO0FBQ2xDLGdEQUFnRDtBQUNoRCxNQUFNRyxjQUFjLFdBQVcsR0FBRUgsSUFBSTtBQUNyQyxNQUFNSSxXQUFXLFdBQVcsR0FBRS9ILE9BQU90QixNQUFNLENBQUMsT0FBT3NKLGVBQWUsRUFBRTtBQUNwRSx3QkFBd0I7QUFDeEIsa0VBQWtFO0FBQ2xFLDZDQUE2QztBQUM3QyxLQUFLLElBQUlDLEtBQUs7SUFBQztJQUFNO0lBQU07Q0FBSyxDQUFFO0lBQzlCLElBQUlDLElBQUksV0FBVyxHQUFFRCxFQUFFRSxVQUFVLENBQUMsSUFBSTNKLElBQUksV0FBVyxHQUFFeUosRUFBRUUsVUFBVSxDQUFDO0lBQ3BFSixRQUFRLENBQUNHLEVBQUUsR0FBRzFKO0lBQ2R1SixRQUFRLENBQUN2SixFQUFFLEdBQUcsQ0FBQzBKO0FBQ25CO0FBQ0EsU0FBU0UsU0FBUzlLLEVBQUU7SUFDaEIsT0FBT0EsTUFBTSxPQUFPdUssUUFBUSxDQUFDdkssR0FBRyxHQUM1QixTQUFTQSxNQUFNQSxNQUFNLFFBQVEsRUFBRSxPQUFPLE1BQ2xDLFNBQVNBLE1BQU1BLE1BQU0sUUFBUXdLLFdBQVcsQ0FBQ3hLLEtBQUssTUFBTSxHQUNoRCxTQUFTQSxNQUFNQSxNQUFNLFFBQVEsRUFBRSxRQUFRLE1BQ25DLFVBQVVBLE1BQU1BLE1BQU0sU0FBUyxJQUFJLFFBQVEsTUFDdkMsVUFBVUEsTUFBTUEsTUFBTSxTQUFTLEVBQUUsUUFBUSxNQUFLLEVBQUUsT0FBTztBQUMvRTtBQUNBLE1BQU0rSyxTQUFTO0FBQ2Y7OztBQUdBLEdBQ0EsTUFBTUM7SUFDRjs7SUFFQSxHQUNBLElBQUl2YSxNQUFNO1FBQUUsT0FBTyxJQUFJLENBQUN3YSxLQUFLLEdBQUcsSUFBSWIsTUFBTUQ7SUFBSztJQUMvQzs7SUFFQSxHQUNBM1YsWUFDQTs7SUFFQSxHQUNBb0IsSUFBSSxFQUNKOztJQUVBLEdBQ0FDLEVBQUUsRUFDRjs7Ozs7O0lBTUEsR0FDQW9WLEtBQUssQ0FBRTtRQUNILElBQUksQ0FBQ3JWLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNvVixLQUFLLEdBQUdBO0lBQ2pCO0lBQ0E7O0lBRUEsR0FDQTVZLEtBQUs0SCxHQUFHLEVBQUV4SixHQUFHLEVBQUU7UUFBRSxPQUFPLElBQUssQ0FBQ0EsR0FBRyxJQUFJQSxPQUFRd0osTUFBTSxJQUFJLENBQUNwRSxFQUFFLEdBQUcsSUFBSSxDQUFDRCxJQUFJO0lBQUU7SUFDeEU7O0lBRUEsR0FDQXNWLFFBQVFBLE9BQU8sRUFBRXphLEdBQUcsRUFBRTtRQUFFLE9BQU95YSxXQUFZLEtBQUksQ0FBQ3phLEdBQUcsSUFBSUEsR0FBRTtJQUFJO0lBQzdEOztJQUVBLEdBQ0EsT0FBT3VRLEtBQUttSyxLQUFLLEVBQUU1YSxLQUFLLEVBQUUwYSxLQUFLLEVBQUVHLEtBQUssRUFBRTtRQUNwQyxJQUFJQyxRQUFRLENBQUM7UUFDYixJQUFLLElBQUkzVixJQUFJLEdBQUdBLElBQUl5VixNQUFNcGIsTUFBTSxFQUFFMkYsSUFBSztZQUNuQyxJQUFJNlQsT0FBTzRCLEtBQUssQ0FBQ3pWLEVBQUU7WUFDbkIsSUFBSTZULEtBQUszVCxJQUFJLElBQUlyRixTQUFTZ1osS0FBSzFULEVBQUUsSUFBSXRGLE9BQU87Z0JBQ3hDLElBQUlnWixLQUFLMEIsS0FBSyxJQUFJQSxPQUNkLE9BQU92VjtnQkFDWCw4REFBOEQ7Z0JBQzlELDREQUE0RDtnQkFDNUQsU0FBUztnQkFDVCxJQUFJMlYsUUFBUSxLQUFNRCxDQUFBQSxTQUFTLElBQUtBLFFBQVEsSUFBSTdCLEtBQUszVCxJQUFJLEdBQUdyRixRQUFRZ1osS0FBSzFULEVBQUUsR0FBR3RGLFFBQVM0YSxLQUFLLENBQUNFLE1BQU0sQ0FBQ0osS0FBSyxHQUFHMUIsS0FBSzBCLEtBQUssR0FDOUdJLFFBQVEzVjtZQUNoQjtRQUNKO1FBQ0EsSUFBSTJWLFFBQVEsR0FDUixNQUFNLElBQUk1UyxXQUFXO1FBQ3pCLE9BQU80UztJQUNYO0FBQ0o7QUFDQSxTQUFTQyxXQUFXMUksQ0FBQyxFQUFFQyxDQUFDO0lBQ3BCLElBQUlELEVBQUU3UyxNQUFNLElBQUk4UyxFQUFFOVMsTUFBTSxFQUNwQixPQUFPO0lBQ1gsSUFBSyxJQUFJMkYsSUFBSSxHQUFHQSxJQUFJa04sRUFBRTdTLE1BQU0sRUFBRTJGLElBQUs7UUFDL0IsSUFBSTZWLEtBQUszSSxDQUFDLENBQUNsTixFQUFFLEVBQUU4VixLQUFLM0ksQ0FBQyxDQUFDbk4sRUFBRTtRQUN4QixJQUFJNlYsR0FBRzNWLElBQUksSUFBSTRWLEdBQUc1VixJQUFJLElBQUkyVixHQUFHMVYsRUFBRSxJQUFJMlYsR0FBRzNWLEVBQUUsSUFBSTBWLEdBQUdFLFNBQVMsSUFBSUQsR0FBR0MsU0FBUyxJQUFJLENBQUNILFdBQVdDLEdBQUdHLEtBQUssRUFBRUYsR0FBR0UsS0FBSyxHQUN0RyxPQUFPO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQSxrQ0FBa0M7QUFDbEMsTUFBTUMsUUFBUSxFQUFFO0FBQ2hCLG1FQUFtRTtBQUNuRSwrQkFBK0I7QUFDL0IsU0FBU0MsaUJBQWlCckYsSUFBSSxFQUFFc0YsS0FBSyxFQUFFQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsU0FBUztJQUMzRCxJQUFLLElBQUlDLEtBQUssR0FBR0EsTUFBTUYsU0FBU2hjLE1BQU0sRUFBRWtjLEtBQU07UUFDMUMsSUFBSXJXLE9BQU9xVyxLQUFLRixRQUFRLENBQUNFLEtBQUssRUFBRSxDQUFDcFcsRUFBRSxHQUFHZ1csT0FBT2hXLEtBQUtvVyxLQUFLRixTQUFTaGMsTUFBTSxHQUFHZ2MsUUFBUSxDQUFDRSxHQUFHLENBQUNyVyxJQUFJLEdBQUdrVztRQUM3RixJQUFJSSxXQUFXRCxLQUFLLElBQUksUUFBUSxNQUFLRDtRQUNyQyxnRUFBZ0U7UUFDaEUseURBQXlEO1FBQ3pELGtFQUFrRTtRQUNsRSx1QkFBdUI7UUFDdkIsK0RBQStEO1FBQy9ELGlFQUFpRTtRQUNqRSxnRUFBZ0U7UUFDaEUsVUFBVTtRQUNWLDJCQUEyQjtRQUMzQiw4Q0FBOEM7UUFDOUMsSUFBSyxJQUFJdFcsSUFBSUUsTUFBTTBCLE9BQU80VSxVQUFVQyxhQUFhRCxVQUFVeFcsSUFBSUcsSUFBSUgsSUFBSztZQUNwRSxJQUFJMFIsT0FBTzBELFNBQVN2RSxLQUFLc0UsVUFBVSxDQUFDblY7WUFDcEMsSUFBSTBSLFFBQVEsSUFBSSxTQUFTLEtBQ3JCQSxPQUFPOVA7aUJBQ04sSUFBSThQLFFBQVEsRUFBRSxRQUFRLE9BQU0rRSxjQUFjLEVBQUUsUUFBUSxLQUNyRC9FLE9BQU8sR0FBRyxRQUFRO1lBQ3RCdUUsS0FBSyxDQUFDalcsRUFBRSxHQUFHMFIsUUFBUSxFQUFFLFFBQVEsTUFBSyxFQUFFLE9BQU8sTUFBS0E7WUFDaEQsSUFBSUEsT0FBTyxFQUFFLFlBQVksS0FDckIrRSxhQUFhL0U7WUFDakI5UCxPQUFPOFA7UUFDWDtRQUNBLDhEQUE4RDtRQUM5RCwyQ0FBMkM7UUFDM0MsNERBQTREO1FBQzVELFdBQVc7UUFDWCwrREFBK0Q7UUFDL0Qsa0VBQWtFO1FBQ2xFLDJEQUEyRDtRQUMzRCxxQ0FBcUM7UUFDckMsSUFBSyxJQUFJMVIsSUFBSUUsTUFBTTBCLE9BQU80VSxVQUFVQyxhQUFhRCxVQUFVeFcsSUFBSUcsSUFBSUgsSUFBSztZQUNwRSxJQUFJMFIsT0FBT3VFLEtBQUssQ0FBQ2pXLEVBQUU7WUFDbkIsSUFBSTBSLFFBQVEsSUFBSSxRQUFRLEtBQUk7Z0JBQ3hCLElBQUkxUixJQUFJRyxLQUFLLEtBQUt5QixRQUFRcVUsS0FBSyxDQUFDalcsSUFBSSxFQUFFLElBQUs0QixPQUFPLEdBQUcsU0FBUyxLQUMxRDhQLE9BQU91RSxLQUFLLENBQUNqVyxFQUFFLEdBQUc0QjtxQkFFbEJxVSxLQUFLLENBQUNqVyxFQUFFLEdBQUcsSUFBSSxRQUFRO1lBQy9CLE9BQ0ssSUFBSTBSLFFBQVEsR0FBRyxRQUFRLEtBQUk7Z0JBQzVCLElBQUluTixNQUFNdkUsSUFBSTtnQkFDZCxNQUFPdUUsTUFBTXBFLE1BQU04VixLQUFLLENBQUMxUixJQUFJLElBQUksR0FBRyxRQUFRLElBQ3hDQTtnQkFDSixJQUFJeUIsVUFBVSxLQUFNcEUsUUFBUSxFQUFFLFFBQVEsT0FBUTJDLE1BQU02UixPQUFPSCxLQUFLLENBQUMxUixJQUFJLElBQUksRUFBRSxRQUFRLE1BQU9rUyxjQUFjLEVBQUUsT0FBTyxNQUFLLEVBQUUsT0FBTyxNQUFLLEVBQUUsUUFBUSxNQUFNLElBQUksUUFBUTtnQkFDaEssSUFBSyxJQUFJbEssSUFBSXZNLEdBQUd1TSxJQUFJaEksS0FBS2dJLElBQ3JCMEosS0FBSyxDQUFDMUosRUFBRSxHQUFHdkc7Z0JBQ2ZoRyxJQUFJdUUsTUFBTTtZQUNkLE9BQ0ssSUFBSW1OLFFBQVEsRUFBRSxRQUFRLE9BQU0rRSxjQUFjLEVBQUUsT0FBTyxLQUFJO2dCQUN4RFIsS0FBSyxDQUFDalcsRUFBRSxHQUFHLEVBQUUsT0FBTztZQUN4QjtZQUNBNEIsT0FBTzhQO1lBQ1AsSUFBSUEsT0FBTyxFQUFFLFlBQVksS0FDckIrRSxhQUFhL0U7UUFDckI7SUFDSjtBQUNKO0FBQ0EsOENBQThDO0FBQzlDLFNBQVNnRixvQkFBb0I3RixJQUFJLEVBQUVzRixLQUFLLEVBQUVDLEdBQUcsRUFBRUMsUUFBUSxFQUFFQyxTQUFTO0lBQzlELElBQUlLLGVBQWVMLGFBQWEsRUFBRSxPQUFPLE1BQUssRUFBRSxPQUFPLE1BQUssRUFBRSxPQUFPO0lBQ3JFLElBQUssSUFBSUMsS0FBSyxHQUFHSyxLQUFLLEdBQUdDLFVBQVUsR0FBR04sTUFBTUYsU0FBU2hjLE1BQU0sRUFBRWtjLEtBQU07UUFDL0QsSUFBSXJXLE9BQU9xVyxLQUFLRixRQUFRLENBQUNFLEtBQUssRUFBRSxDQUFDcFcsRUFBRSxHQUFHZ1csT0FBT2hXLEtBQUtvVyxLQUFLRixTQUFTaGMsTUFBTSxHQUFHZ2MsUUFBUSxDQUFDRSxHQUFHLENBQUNyVyxJQUFJLEdBQUdrVztRQUM3Rix5REFBeUQ7UUFDekQsaUVBQWlFO1FBQ2pFLG1FQUFtRTtRQUNuRSx5REFBeUQ7UUFDekQsSUFBSyxJQUFJcFcsSUFBSUUsTUFBTW9LLElBQUl3TSxJQUFJcEYsTUFBTTFSLElBQUlHLElBQUlILElBQUs7WUFDMUMsNkRBQTZEO1lBQzdELDJCQUEyQjtZQUMzQixJQUFJOFcsS0FBSy9CLFFBQVEsQ0FBQ3pLLEtBQUt1RyxLQUFLc0UsVUFBVSxDQUFDblYsR0FBRyxFQUFFO2dCQUN4QyxJQUFJOFcsS0FBSyxHQUFHO29CQUNSLElBQUssSUFBSUMsS0FBS0gsS0FBSyxHQUFHRyxNQUFNLEdBQUdBLE1BQU0sRUFBRzt3QkFDcEMsSUFBSS9CLFlBQVksQ0FBQytCLEtBQUssRUFBRSxJQUFJLENBQUNELElBQUk7NEJBQzdCLElBQUl6VSxRQUFRMlMsWUFBWSxDQUFDK0IsS0FBSyxFQUFFOzRCQUNoQyxJQUFJckYsT0FBTyxRQUFTLEVBQUUseUJBQXlCLE1BQU00RSxZQUNqRCxDQUFFalUsQ0FBQUEsUUFBUSxFQUFFLDRCQUE0QixHQUE5QixJQUFvQyxJQUMxQyxRQUFTLEVBQUUsNEJBQTRCLE1BQU1zVSxlQUFlTDs0QkFDcEUsSUFBSTVFLE1BQ0F1RSxLQUFLLENBQUNqVyxFQUFFLEdBQUdpVyxLQUFLLENBQUNqQixZQUFZLENBQUMrQixHQUFHLENBQUMsR0FBR3JGOzRCQUN6Q2tGLEtBQUtHOzRCQUNMO3dCQUNKO29CQUNKO2dCQUNKLE9BQ0ssSUFBSS9CLGFBQWEzYSxNQUFNLElBQUksSUFBSSxzQkFBc0IsS0FBSTtvQkFDMUQ7Z0JBQ0osT0FDSztvQkFDRDJhLFlBQVksQ0FBQzRCLEtBQUssR0FBRzVXO29CQUNyQmdWLFlBQVksQ0FBQzRCLEtBQUssR0FBR3RNO29CQUNyQjBLLFlBQVksQ0FBQzRCLEtBQUssR0FBR0M7Z0JBQ3pCO1lBQ0osT0FDSyxJQUFJLENBQUNuRixPQUFPdUUsS0FBSyxDQUFDalcsRUFBRSxLQUFLLEVBQUUsT0FBTyxPQUFNMFIsUUFBUSxFQUFFLE9BQU8sS0FBSTtnQkFDOUQsSUFBSXNGLFFBQVF0RixRQUFRNEU7Z0JBQ3BCTyxVQUFVRyxRQUFRLElBQUksRUFBRSw0QkFBNEI7Z0JBQ3BELElBQUssSUFBSUQsS0FBS0gsS0FBSyxHQUFHRyxNQUFNLEdBQUdBLE1BQU0sRUFBRztvQkFDcEMsSUFBSTdaLE1BQU04WCxZQUFZLENBQUMrQixLQUFLLEVBQUU7b0JBQzlCLElBQUk3WixNQUFNLEVBQUUseUJBQXlCLEtBQ2pDO29CQUNKLElBQUk4WixPQUFPO3dCQUNQaEMsWUFBWSxDQUFDK0IsS0FBSyxFQUFFLElBQUksRUFBRSx5QkFBeUI7b0JBQ3ZELE9BQ0s7d0JBQ0QsSUFBSTdaLE1BQU0sRUFBRSw0QkFBNEIsS0FDcEM7d0JBQ0o4WCxZQUFZLENBQUMrQixLQUFLLEVBQUUsSUFBSSxFQUFFLDRCQUE0QjtvQkFDMUQ7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVNFLGdCQUFnQmQsS0FBSyxFQUFFQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsU0FBUztJQUNwRCxJQUFLLElBQUlDLEtBQUssR0FBRzNVLE9BQU8wVSxXQUFXQyxNQUFNRixTQUFTaGMsTUFBTSxFQUFFa2MsS0FBTTtRQUM1RCxJQUFJclcsT0FBT3FXLEtBQUtGLFFBQVEsQ0FBQ0UsS0FBSyxFQUFFLENBQUNwVyxFQUFFLEdBQUdnVyxPQUFPaFcsS0FBS29XLEtBQUtGLFNBQVNoYyxNQUFNLEdBQUdnYyxRQUFRLENBQUNFLEdBQUcsQ0FBQ3JXLElBQUksR0FBR2tXO1FBQzdGLHdEQUF3RDtRQUN4RCxpRUFBaUU7UUFDakUsa0VBQWtFO1FBQ2xFLGlFQUFpRTtRQUNqRSwrREFBK0Q7UUFDL0QsMkRBQTJEO1FBQzNELGlDQUFpQztRQUNqQyxJQUFLLElBQUlwVyxJQUFJRSxNQUFNRixJQUFJRyxJQUFLO1lBQ3hCLElBQUl1UixPQUFPdUUsS0FBSyxDQUFDalcsRUFBRTtZQUNuQixJQUFJMFIsUUFBUSxJQUFJLFFBQVEsS0FBSTtnQkFDeEIsSUFBSW5OLE1BQU12RSxJQUFJO2dCQUNkLE9BQVM7b0JBQ0wsSUFBSXVFLE9BQU9wRSxJQUFJO3dCQUNYLElBQUlvVyxNQUFNRixTQUFTaGMsTUFBTSxFQUNyQjt3QkFDSmtLLE1BQU04UixRQUFRLENBQUNFLEtBQUssQ0FBQ3BXLEVBQUU7d0JBQ3ZCQSxLQUFLb1csS0FBS0YsU0FBU2hjLE1BQU0sR0FBR2djLFFBQVEsQ0FBQ0UsR0FBRyxDQUFDclcsSUFBSSxHQUFHa1c7b0JBQ3BELE9BQ0ssSUFBSUgsS0FBSyxDQUFDMVIsSUFBSSxJQUFJLElBQUksUUFBUSxLQUFJO3dCQUNuQ0E7b0JBQ0osT0FDSzt3QkFDRDtvQkFDSjtnQkFDSjtnQkFDQSxJQUFJMlMsVUFBVXRWLFFBQVEsRUFBRSxPQUFPO2dCQUMvQixJQUFJdVYsU0FBUyxDQUFDNVMsTUFBTTZSLE1BQU1ILEtBQUssQ0FBQzFSLElBQUksR0FBRytSLFNBQVEsS0FBTSxFQUFFLE9BQU87Z0JBQzlELElBQUl0USxVQUFVa1IsV0FBV0MsU0FBVUQsVUFBVSxFQUFFLE9BQU8sTUFBSyxFQUFFLE9BQU8sTUFBTVo7Z0JBQzFFLElBQUssSUFBSS9KLElBQUloSSxLQUFLNlMsS0FBS2IsSUFBSWMsUUFBUUQsS0FBS2YsUUFBUSxDQUFDZSxLQUFLLEVBQUUsQ0FBQ2pYLEVBQUUsR0FBR2dXLE9BQU81SixJQUFJdk0sR0FBSTtvQkFDekUsSUFBSXVNLEtBQUs4SyxPQUFPO3dCQUNaOUssSUFBSThKLFFBQVEsQ0FBQyxFQUFFZSxHQUFHLENBQUNsWCxJQUFJO3dCQUN2Qm1YLFFBQVFELEtBQUtmLFFBQVEsQ0FBQ2UsS0FBSyxFQUFFLENBQUNqWCxFQUFFLEdBQUdnVztvQkFDdkM7b0JBQ0FGLEtBQUssQ0FBQyxFQUFFMUosRUFBRSxHQUFHdkc7Z0JBQ2pCO2dCQUNBaEcsSUFBSXVFO1lBQ1IsT0FDSztnQkFDRDNDLE9BQU84UDtnQkFDUDFSO1lBQ0o7UUFDSjtJQUNKO0FBQ0o7QUFDQSxzRUFBc0U7QUFDdEUsa0VBQWtFO0FBQ2xFLGdFQUFnRTtBQUNoRSxnQ0FBZ0M7QUFDaEMsU0FBU3NYLFVBQVV6RyxJQUFJLEVBQUUzUSxJQUFJLEVBQUVDLEVBQUUsRUFBRW9WLEtBQUssRUFBRWdDLFNBQVMsRUFBRWxCLFFBQVEsRUFBRVosS0FBSztJQUNoRSxJQUFJK0IsVUFBVWpDLFFBQVEsSUFBSSxFQUFFLE9BQU8sTUFBSyxFQUFFLE9BQU87SUFDakQsSUFBSSxRQUFTLEtBQU9nQyxZQUFZLEdBQUk7UUFDaEMsSUFBSyxJQUFJRSxNQUFNdlgsTUFBTXFXLEtBQUssR0FBR2tCLE1BQU10WCxJQUFLO1lBQ3BDLDREQUE0RDtZQUM1RCw4REFBOEQ7WUFDOUQsOERBQThEO1lBQzlELDZDQUE2QztZQUM3QyxJQUFJdVgsVUFBVSxNQUFNQyxRQUFRO1lBQzVCLElBQUlwQixNQUFNRixTQUFTaGMsTUFBTSxJQUFJb2QsTUFBTXBCLFFBQVEsQ0FBQ0UsR0FBRyxDQUFDclcsSUFBSSxFQUFFO2dCQUNsRCxJQUFJaUQsT0FBTzhTLEtBQUssQ0FBQ3dCLElBQUk7Z0JBQ3JCLElBQUl0VSxRQUFRcVUsU0FBUztvQkFDakJFLFVBQVU7b0JBQ1ZDLFFBQVF4VSxRQUFRLEdBQUcsUUFBUTtnQkFDL0I7WUFDSjtZQUNBLCtEQUErRDtZQUMvRCw2REFBNkQ7WUFDN0QsMENBQTBDO1lBQzFDLElBQUl5VSxVQUFVLENBQUNGLFdBQVdGLFdBQVcsRUFBRSxPQUFPLE1BQUssRUFBRSxHQUFHO1lBQ3hELElBQUlLLGFBQWFILFVBQVVuQyxRQUFRQSxRQUFRO1lBQzNDLElBQUl1QyxRQUFRTDtZQUNaTSxLQUFLLE9BQVM7Z0JBQ1YsSUFBSXhCLEtBQUtGLFNBQVNoYyxNQUFNLElBQUl5ZCxTQUFTekIsUUFBUSxDQUFDRSxHQUFHLENBQUNyVyxJQUFJLEVBQUU7b0JBQ3BELElBQUl5WCxPQUNBLE1BQU1JO29CQUNWLElBQUlDLE1BQU0zQixRQUFRLENBQUNFLEdBQUc7b0JBQ3RCLG1GQUFtRjtvQkFDbkYsSUFBSSxDQUFDbUIsU0FDRCxJQUFLLElBQUlPLE9BQU9ELElBQUk3WCxFQUFFLEVBQUVpWCxLQUFLYixLQUFLLElBQUs7d0JBQ25DLElBQUkwQixRQUFROVgsSUFDUixNQUFNNFg7d0JBQ1YsSUFBSVgsS0FBS2YsU0FBU2hjLE1BQU0sSUFBSWdjLFFBQVEsQ0FBQ2UsR0FBRyxDQUFDbFgsSUFBSSxJQUFJK1gsTUFDN0NBLE9BQU81QixRQUFRLENBQUNlLEtBQUssQ0FBQ2pYLEVBQUU7NkJBQ3ZCLElBQUk4VixLQUFLLENBQUNnQyxLQUFLLElBQUlULFNBQ3BCLE1BQU1POzZCQUVOO29CQUNSO29CQUNKeEI7b0JBQ0EsSUFBSXFCLFNBQVM7d0JBQ1RBLFFBQVEvWCxJQUFJLENBQUNtWTtvQkFDakIsT0FDSzt3QkFDRCxJQUFJQSxJQUFJOVgsSUFBSSxHQUFHdVgsS0FDWGhDLE1BQU01VixJQUFJLENBQUMsSUFBSXlWLFNBQVNtQyxLQUFLTyxJQUFJOVgsSUFBSSxFQUFFMlg7d0JBQzNDLElBQUlLLFVBQVUsSUFBS25DLFNBQVMsSUFBSXRCLE9BQVEsQ0FBRW9ELENBQUFBLGFBQWE7d0JBQ3ZETSxvQkFBb0J0SCxNQUFNcUgsVUFBVTNDLFFBQVEsSUFBSUEsT0FBT2dDLFdBQVdTLElBQUloQyxLQUFLLEVBQUVnQyxJQUFJOVgsSUFBSSxFQUFFOFgsSUFBSTdYLEVBQUUsRUFBRXNWO3dCQUMvRmdDLE1BQU1PLElBQUk3WCxFQUFFO29CQUNoQjtvQkFDQTJYLFFBQVFFLElBQUk3WCxFQUFFO2dCQUNsQixPQUNLLElBQUkyWCxTQUFTM1gsTUFBT3VYLENBQUFBLFVBQVV6QixLQUFLLENBQUM2QixNQUFNLElBQUlOLFVBQVV2QixLQUFLLENBQUM2QixNQUFNLElBQUlOLE9BQU0sR0FBSTtvQkFDbkY7Z0JBQ0osT0FDSztvQkFDRE07Z0JBQ0o7WUFDSjtZQUNBLElBQUlGLFNBQ0FOLFVBQVV6RyxNQUFNNEcsS0FBS0ssT0FBT3ZDLFFBQVEsR0FBR2dDLFdBQVdLLFNBQVNuQztpQkFDMUQsSUFBSWdDLE1BQU1LLE9BQ1hyQyxNQUFNNVYsSUFBSSxDQUFDLElBQUl5VixTQUFTbUMsS0FBS0ssT0FBT0Q7WUFDeENKLE1BQU1LO1FBQ1Y7SUFDSixPQUNLO1FBQ0Qsa0VBQWtFO1FBQ2xFLGtEQUFrRDtRQUNsRCxJQUFLLElBQUlMLE1BQU10WCxJQUFJb1csS0FBS0YsU0FBU2hjLE1BQU0sRUFBRW9kLE1BQU12WCxNQUFPO1lBQ2xELElBQUl3WCxVQUFVLE1BQU1DLFFBQVE7WUFDNUIsSUFBSSxDQUFDcEIsTUFBTWtCLE1BQU1wQixRQUFRLENBQUNFLEtBQUssRUFBRSxDQUFDcFcsRUFBRSxFQUFFO2dCQUNsQyxJQUFJZ0QsT0FBTzhTLEtBQUssQ0FBQ3dCLE1BQU0sRUFBRTtnQkFDekIsSUFBSXRVLFFBQVFxVSxTQUFTO29CQUNqQkUsVUFBVTtvQkFDVkMsUUFBUXhVLFFBQVEsR0FBRyxRQUFRO2dCQUMvQjtZQUNKO1lBQ0EsSUFBSXlVLFVBQVUsQ0FBQ0YsV0FBV0YsV0FBVyxFQUFFLE9BQU8sTUFBSyxFQUFFLEdBQUc7WUFDeEQsSUFBSUssYUFBYUgsVUFBVW5DLFFBQVFBLFFBQVE7WUFDM0MsSUFBSXVDLFFBQVFMO1lBQ1pNLEtBQUssT0FBUztnQkFDVixJQUFJeEIsTUFBTXVCLFNBQVN6QixRQUFRLENBQUNFLEtBQUssRUFBRSxDQUFDcFcsRUFBRSxFQUFFO29CQUNwQyxJQUFJd1gsT0FDQSxNQUFNSTtvQkFDVixJQUFJQyxNQUFNM0IsUUFBUSxDQUFDLEVBQUVFLEdBQUc7b0JBQ3hCLG1GQUFtRjtvQkFDbkYsSUFBSSxDQUFDbUIsU0FDRCxJQUFLLElBQUlPLE9BQU9ELElBQUk5WCxJQUFJLEVBQUVrWCxLQUFLYixLQUFNO3dCQUNqQyxJQUFJMEIsUUFBUS9YLE1BQ1IsTUFBTTZYO3dCQUNWLElBQUlYLE1BQU1mLFFBQVEsQ0FBQ2UsS0FBSyxFQUFFLENBQUNqWCxFQUFFLElBQUk4WCxNQUM3QkEsT0FBTzVCLFFBQVEsQ0FBQyxFQUFFZSxHQUFHLENBQUNsWCxJQUFJOzZCQUN6QixJQUFJK1YsS0FBSyxDQUFDZ0MsT0FBTyxFQUFFLElBQUlULFNBQ3hCLE1BQU1POzZCQUVOO29CQUNSO29CQUNKLElBQUlILFNBQVM7d0JBQ1RBLFFBQVEvWCxJQUFJLENBQUNtWTtvQkFDakIsT0FDSzt3QkFDRCxJQUFJQSxJQUFJN1gsRUFBRSxHQUFHc1gsS0FDVGhDLE1BQU01VixJQUFJLENBQUMsSUFBSXlWLFNBQVMwQyxJQUFJN1gsRUFBRSxFQUFFc1gsS0FBS0k7d0JBQ3pDLElBQUlLLFVBQVUsSUFBS25DLFNBQVMsSUFBSXRCLE9BQVEsQ0FBRW9ELENBQUFBLGFBQWE7d0JBQ3ZETSxvQkFBb0J0SCxNQUFNcUgsVUFBVTNDLFFBQVEsSUFBSUEsT0FBT2dDLFdBQVdTLElBQUloQyxLQUFLLEVBQUVnQyxJQUFJOVgsSUFBSSxFQUFFOFgsSUFBSTdYLEVBQUUsRUFBRXNWO3dCQUMvRmdDLE1BQU1PLElBQUk5WCxJQUFJO29CQUNsQjtvQkFDQTRYLFFBQVFFLElBQUk5WCxJQUFJO2dCQUNwQixPQUNLLElBQUk0WCxTQUFTNVgsUUFBU3dYLENBQUFBLFVBQVV6QixLQUFLLENBQUM2QixRQUFRLEVBQUUsSUFBSU4sVUFBVXZCLEtBQUssQ0FBQzZCLFFBQVEsRUFBRSxJQUFJTixPQUFNLEdBQUk7b0JBQzdGO2dCQUNKLE9BQ0s7b0JBQ0RNO2dCQUNKO1lBQ0o7WUFDQSxJQUFJRixTQUNBTixVQUFVekcsTUFBTWlILE9BQU9MLEtBQUtsQyxRQUFRLEdBQUdnQyxXQUFXSyxTQUFTbkM7aUJBQzFELElBQUlxQyxRQUFRTCxLQUNiaEMsTUFBTTVWLElBQUksQ0FBQyxJQUFJeVYsU0FBU3dDLE9BQU9MLEtBQUtJO1lBQ3hDSixNQUFNSztRQUNWO0lBQ0o7QUFDSjtBQUNBLFNBQVNLLG9CQUFvQnRILElBQUksRUFBRTBFLEtBQUssRUFBRWdDLFNBQVMsRUFBRWxCLFFBQVEsRUFBRW5XLElBQUksRUFBRUMsRUFBRSxFQUFFc1YsS0FBSztJQUMxRSxJQUFJYSxZQUFhZixRQUFRLElBQUksRUFBRSxPQUFPLE1BQUssRUFBRSxPQUFPO0lBQ3BEVyxpQkFBaUJyRixNQUFNM1EsTUFBTUMsSUFBSWtXLFVBQVVDO0lBQzNDSSxvQkFBb0I3RixNQUFNM1EsTUFBTUMsSUFBSWtXLFVBQVVDO0lBQzlDVyxnQkFBZ0IvVyxNQUFNQyxJQUFJa1csVUFBVUM7SUFDcENnQixVQUFVekcsTUFBTTNRLE1BQU1DLElBQUlvVixPQUFPZ0MsV0FBV2xCLFVBQVVaO0FBQzFEO0FBQ0EsU0FBUzJDLGFBQWF2SCxJQUFJLEVBQUVrRixTQUFTLEVBQUVNLFFBQVE7SUFDM0MsSUFBSSxDQUFDeEYsTUFDRCxPQUFPO1FBQUMsSUFBSXlFLFNBQVMsR0FBRyxHQUFHUyxhQUFhckIsTUFBTSxJQUFJO0tBQUc7SUFDekQsSUFBSXFCLGFBQWF0QixPQUFPLENBQUM0QixTQUFTaGMsTUFBTSxJQUFJLENBQUNnYixPQUFPL1gsSUFBSSxDQUFDdVQsT0FDckQsT0FBT3dILGFBQWF4SCxLQUFLeFcsTUFBTTtJQUNuQyxJQUFJZ2MsU0FBU2hjLE1BQU0sRUFDZixNQUFPd1csS0FBS3hXLE1BQU0sR0FBRzRiLE1BQU01YixNQUFNLENBQzdCNGIsS0FBSyxDQUFDQSxNQUFNNWIsTUFBTSxDQUFDLEdBQUcsSUFBSSxRQUFRLEtBQUksb0NBQW9DO0lBQ2xGLElBQUlvYixRQUFRLEVBQUUsRUFBRUYsUUFBUVEsYUFBYXRCLE1BQU0sSUFBSTtJQUMvQzBELG9CQUFvQnRILE1BQU0wRSxPQUFPQSxPQUFPYyxVQUFVLEdBQUd4RixLQUFLeFcsTUFBTSxFQUFFb2I7SUFDbEUsT0FBT0E7QUFDWDtBQUNBLFNBQVM0QyxhQUFhaGUsTUFBTTtJQUN4QixPQUFPO1FBQUMsSUFBSWliLFNBQVMsR0FBR2piLFFBQVE7S0FBRztBQUN2QztBQUNBLElBQUlpZSxZQUFZO0FBQ2hCLHFFQUFxRTtBQUNyRSxtRUFBbUU7QUFDbkUsc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSw0REFBNEQ7QUFDNUQsa0VBQWtFO0FBQ2xFLDJEQUEyRDtBQUMzRCxFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG9FQUFvRTtBQUNwRSw2REFBNkQ7QUFDN0QscUVBQXFFO0FBQ3JFLDJEQUEyRDtBQUMzRCxTQUFTQyxhQUFhMUgsSUFBSSxFQUFFNEUsS0FBSyxFQUFFMWEsR0FBRyxFQUFFeUQsS0FBSyxFQUFFZ1gsT0FBTztJQUNsRCxJQUFJOUc7SUFDSixJQUFJOEosYUFBYWhhLE1BQU1pYSxJQUFJLEdBQUc1SCxLQUFLM1EsSUFBSTtJQUN2QyxJQUFJd1ksUUFBUXBELFNBQVNoSyxJQUFJLENBQUNtSyxPQUFPK0MsWUFBWSxDQUFDOUosS0FBS2xRLE1BQU1tYSxTQUFTLE1BQU0sUUFBUWpLLE9BQU8sS0FBSyxJQUFJQSxLQUFLLENBQUMsR0FBR2xRLE1BQU1rWCxLQUFLO0lBQ3BILElBQUk3QixPQUFPNEIsS0FBSyxDQUFDaUQsTUFBTSxFQUFFRSxVQUFVL0UsS0FBS2xYLElBQUksQ0FBQzZZLFNBQVN6YTtJQUN0RCxjQUFjO0lBQ2QsSUFBSXlkLGNBQWNJLFNBQVM7UUFDdkIsSUFBSUMsUUFBUUgsU0FBU2xELFVBQVUsSUFBSSxDQUFDO1FBQ3BDLElBQUlxRCxRQUFRLEtBQUtBLFNBQVNwRCxNQUFNcGIsTUFBTSxFQUNsQyxPQUFPO1FBQ1h3WixPQUFPNEIsS0FBSyxDQUFDaUQsUUFBUUcsTUFBTTtRQUMzQkwsYUFBYTNFLEtBQUtsWCxJQUFJLENBQUMsQ0FBQzZZLFNBQVN6YTtRQUNqQzZkLFVBQVUvRSxLQUFLbFgsSUFBSSxDQUFDNlksU0FBU3phO0lBQ2pDO0lBQ0EsSUFBSStkLFlBQVluaEIsbUVBQWdCQSxDQUFDa1osS0FBSzNLLElBQUksRUFBRXNTLFlBQVkzRSxLQUFLMkIsT0FBTyxDQUFDQSxTQUFTemE7SUFDOUUsSUFBSStkLFlBQVlqRixLQUFLM1QsSUFBSSxJQUFJNFksWUFBWWpGLEtBQUsxVCxFQUFFLEVBQzVDMlksWUFBWUY7SUFDaEJOLFlBQVl6SCxLQUFLM0ssSUFBSSxDQUFDMkQsS0FBSyxDQUFDck4sS0FBSytDLEdBQUcsQ0FBQ2laLFlBQVlNLFlBQVl0YyxLQUFLc0YsR0FBRyxDQUFDMFcsWUFBWU07SUFDbEYsSUFBSUMsV0FBV0wsU0FBVWxELENBQUFBLFVBQVVDLE1BQU1wYixNQUFNLEdBQUcsSUFBSSxLQUFLLE9BQU9vYixLQUFLLENBQUNpRCxRQUFTbEQsQ0FBQUEsVUFBVSxJQUFJLENBQUMsR0FBRztJQUNuRyxJQUFJdUQsWUFBWUQsYUFBYUYsV0FBV0csU0FBU3hELEtBQUssR0FBSUMsQ0FBQUEsVUFBVSxJQUFJLEtBQUszQixLQUFLMEIsS0FBSyxFQUNuRixPQUFPM2QsOERBQWVBLENBQUNpYixNQUFNLENBQUNrRyxTQUFTcGMsSUFBSSxDQUFDLENBQUM2WSxTQUFTemEsT0FBTzhWLEtBQUszUSxJQUFJLEVBQUU2WSxTQUFTdkQsT0FBTyxDQUFDQSxTQUFTemEsT0FBTyxJQUFJLENBQUMsR0FBR2dlLFNBQVN4RCxLQUFLO0lBQ25JLE9BQU8zZCw4REFBZUEsQ0FBQ2liLE1BQU0sQ0FBQ2lHLFlBQVlqSSxLQUFLM1EsSUFBSSxFQUFFMlQsS0FBSzJCLE9BQU8sQ0FBQ0EsU0FBU3phLE9BQU8sQ0FBQyxJQUFJLEdBQUc4WSxLQUFLMEIsS0FBSztBQUN4RztBQUNBLFNBQVN5RCxjQUFjOVMsSUFBSSxFQUFFaEcsSUFBSSxFQUFFQyxFQUFFO0lBQ2pDLElBQUssSUFBSUgsSUFBSUUsTUFBTUYsSUFBSUcsSUFBSUgsSUFBSztRQUM1QixJQUFJMFIsT0FBTzBELFNBQVNsUCxLQUFLaVAsVUFBVSxDQUFDblY7UUFDcEMsSUFBSTBSLFFBQVEsRUFBRSxPQUFPLEtBQ2pCLE9BQU8rQztRQUNYLElBQUkvQyxRQUFRLEVBQUUsT0FBTyxPQUFNQSxRQUFRLEVBQUUsUUFBUSxLQUN6QyxPQUFPZ0Q7SUFDZjtJQUNBLE9BQU9EO0FBQ1g7QUFFQSxNQUFNd0UsMEJBQTBCLFdBQVcsR0FBRXBoQixvREFBS0EsQ0FBQ3FoQixNQUFNO0FBQ3pELE1BQU1DLHVCQUF1QixXQUFXLEdBQUV0aEIsb0RBQUtBLENBQUNxaEIsTUFBTTtBQUN0RCxNQUFNRSxzQkFBc0IsV0FBVyxHQUFFdmhCLG9EQUFLQSxDQUFDcWhCLE1BQU07QUFDckQsTUFBTUcsZ0JBQWdCLFdBQVcsR0FBRXhoQixvREFBS0EsQ0FBQ3FoQixNQUFNO0FBQy9DLE1BQU1JLGlCQUFpQixXQUFXLEdBQUV6aEIsb0RBQUtBLENBQUNxaEIsTUFBTTtBQUNoRCxNQUFNSyxlQUFlLFdBQVcsR0FBRTFoQixvREFBS0EsQ0FBQ3FoQixNQUFNO0FBQzlDLE1BQU1NLG9CQUFvQixXQUFXLEdBQUUzaEIsb0RBQUtBLENBQUNxaEIsTUFBTTtBQUNuRCxNQUFNTyx1QkFBdUIsV0FBVyxHQUFFNWhCLG9EQUFLQSxDQUFDcWhCLE1BQU0sQ0FBQztJQUNuRFEsU0FBU0MsQ0FBQUEsU0FBVUEsT0FBTzlLLElBQUksQ0FBQ3JULENBQUFBLElBQUtBO0FBQ3hDO0FBQ0EsTUFBTW9lLHdCQUF3QixXQUFXLEdBQUUvaEIsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQ3BEUSxTQUFTQyxDQUFBQSxTQUFVQSxPQUFPOUssSUFBSSxDQUFDclQsQ0FBQUEsSUFBS0E7QUFDeEM7QUFDQSxNQUFNcWU7SUFDRi9hLFlBQVlPLEtBQUssRUFBRXpDLElBQUksU0FBUyxFQUFFcEIsSUFBSSxTQUFTLEVBQUVzQixVQUFVLENBQUMsRUFBRUQsVUFBVSxDQUFDLEVBQ3pFLDZEQUE2RDtJQUM3RCw4REFBOEQ7SUFDOUQsZ0VBQWdFO0lBQ2hFLCtEQUErRDtJQUMvRCwwREFBMEQ7SUFDMUQseUJBQXlCO0lBQ3pCaWQsYUFBYSxLQUFLLENBQUU7UUFDaEIsSUFBSSxDQUFDemEsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ3pDLENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUNwQixDQUFDLEdBQUdBO1FBQ1QsSUFBSSxDQUFDc0IsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ2lkLFVBQVUsR0FBR0E7SUFDdEI7SUFDQUMsSUFBSUMsT0FBTyxFQUFFO1FBQ1QsT0FBT0EsUUFBUTlOLEtBQUssR0FBRyxJQUFJLEdBQ3ZCLElBQUkyTixhQUFhLElBQUksQ0FBQ3hhLEtBQUssQ0FBQzBhLEdBQUcsQ0FBQ0MsVUFBVSxJQUFJLENBQUNwZCxDQUFDLEVBQUUsSUFBSSxDQUFDcEIsQ0FBQyxFQUFFLElBQUksQ0FBQ3NCLE9BQU8sRUFBRSxJQUFJLENBQUNELE9BQU8sRUFBRSxJQUFJLENBQUNpZCxVQUFVO0lBQzdHO0lBQ0FHLEtBQUs5TixLQUFLLEVBQUU7UUFDUixPQUFPLElBQUksQ0FBQzlNLEtBQUssQ0FBQ2MsRUFBRSxJQUFJZ00sTUFBTXpTLEdBQUcsQ0FBQ1csTUFBTSxHQUFHLElBQUksR0FDM0MsSUFBSXdmLGFBQWFqaUIsOERBQWVBLENBQUNpYixNQUFNLENBQUMxRyxNQUFNelMsR0FBRyxDQUFDVyxNQUFNLEdBQUcsSUFBSSxDQUFDdUMsQ0FBQyxFQUFFLElBQUksQ0FBQ3BCLENBQUMsRUFBRSxJQUFJLENBQUNzQixPQUFPLEVBQUUsSUFBSSxDQUFDRCxPQUFPLEVBQUUsSUFBSSxDQUFDaWQsVUFBVTtJQUM5SDtBQUNKO0FBQ0EsTUFBTUksaUJBQWlCLFdBQVcsR0FBRXBpQiwwREFBV0EsQ0FBQ29oQixNQUFNLENBQUM7SUFBRWEsS0FBSyxDQUFDSSxHQUFHN1AsS0FBTzZQLEVBQUVKLEdBQUcsQ0FBQ3pQO0FBQUk7QUFDbkY7Ozs7Ozs7Ozs7O0FBV0EsR0FDQSxTQUFTOFAsYUFBYWpPLEtBQUssRUFBRWtPLFNBQVMsRUFBRXhELE9BQU87SUFDM0MsSUFBSXlELFVBQVVuTyxNQUFNb08sS0FBSyxDQUFDbEI7SUFDMUIsSUFBSWlCLFFBQVFqZ0IsTUFBTSxFQUNkaWdCLE9BQU8sQ0FBQyxFQUFFLENBQUNEO1NBQ1YsSUFBSXBkLE9BQU91ZCxPQUFPLEVBQ25CdmQsT0FBT3VkLE9BQU8sQ0FBQ0MsT0FBT0osWUFBWXhELFNBQVM5VyxXQUFXQSxXQUFXc2E7U0FDaEUsSUFBSXhELFNBQ0w2RCxRQUFRQyxLQUFLLENBQUM5RCxVQUFVLEtBQUt3RDtTQUU3QkssUUFBUUMsS0FBSyxDQUFDTjtBQUN0QjtBQUNBLE1BQU10TyxXQUFXLFdBQVcsR0FBRWxVLG9EQUFLQSxDQUFDcWhCLE1BQU0sQ0FBQztJQUFFUSxTQUFTQyxDQUFBQSxTQUFVQSxPQUFPdGYsTUFBTSxHQUFHc2YsTUFBTSxDQUFDLEVBQUUsR0FBRztBQUFLO0FBQ2pHLElBQUlpQixlQUFlO0FBQ25CLE1BQU1DLGFBQWEsV0FBVyxHQUFFaGpCLG9EQUFLQSxDQUFDcWhCLE1BQU07QUFDNUM7Ozs7QUFJQSxHQUNBLE1BQU00QjtJQUNGaGMsWUFDQTs7SUFFQSxHQUNBaWMsRUFBRSxFQUNGOztJQUVBLEdBQ0FyUCxNQUFNLEVBQ047O0lBRUEsR0FDQXNQLGdCQUFnQixFQUNoQjs7SUFFQSxHQUNBQyxpQkFBaUIsRUFBRUMsZUFBZSxDQUFFO1FBQ2hDLElBQUksQ0FBQ0gsRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ3JQLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNzUCxnQkFBZ0IsR0FBR0E7UUFDeEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0E7UUFDekIsSUFBSSxDQUFDRSxTQUFTLEdBQUdELGdCQUFnQixJQUFJO0lBQ3pDO0lBQ0E7OztJQUdBLEdBQ0EsT0FBT2hDLE9BQU94TixNQUFNLEVBQUU4QyxJQUFJLEVBQUU7UUFDeEIsTUFBTSxFQUFFNE0sYUFBYSxFQUFFQyxjQUFjLEVBQUVDLE9BQU8sRUFBRXBILGFBQWEzRixJQUFJLEVBQUUsR0FBR0MsUUFBUSxDQUFDO1FBQy9FLE9BQU8sSUFBSXNNLFdBQVdGLGdCQUFnQmxQLFFBQVEwUCxlQUFlQyxnQkFBZ0JFLENBQUFBO1lBQ3pFLElBQUlDLE1BQU07Z0JBQUNYLFdBQVc5SixFQUFFLENBQUN3SzthQUFRO1lBQ2pDLElBQUloTixNQUNBaU4sSUFBSTNiLElBQUksQ0FBQ3FVLFlBQVluRCxFQUFFLENBQUNyTyxDQUFBQTtnQkFDcEIsSUFBSStZLGFBQWEvWSxLQUFLNlksTUFBTSxDQUFDQTtnQkFDN0IsT0FBT0UsYUFBYWxOLEtBQUtrTixjQUFjbkwsV0FBV1ksSUFBSTtZQUMxRDtZQUNKLElBQUlvSyxTQUNBRSxJQUFJM2IsSUFBSSxDQUFDeWIsUUFBUUM7WUFDckIsT0FBT0M7UUFDWDtJQUNKO0lBQ0E7OztJQUdBLEdBQ0EsT0FBT0UsVUFBVWpOLEdBQUcsRUFBRUQsSUFBSSxFQUFFO1FBQ3hCLE9BQU9zTSxXQUFXNUIsTUFBTSxDQUFDeFcsQ0FBQUEsT0FBUSxJQUFJK0wsSUFBSS9MLE9BQU84TDtJQUNwRDtBQUNKO0FBQ0EsTUFBTW1OO0lBQ0Y3YyxZQUFZMFAsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osa0VBQWtFO1FBQ2xFLG1FQUFtRTtRQUNuRSxvRUFBb0U7UUFDcEUsd0RBQXdEO1FBQ3hELElBQUksQ0FBQ29OLFVBQVUsR0FBRztRQUNsQix5REFBeUQ7UUFDekQsbUNBQW1DO1FBQ25DLElBQUksQ0FBQzlOLEtBQUssR0FBRztJQUNqQjtJQUNBK04sT0FBT25aLElBQUksRUFBRTtRQUNULElBQUksQ0FBQyxJQUFJLENBQUNvTCxLQUFLLEVBQUU7WUFDYixJQUFJLElBQUksQ0FBQ1UsSUFBSSxFQUFFO2dCQUNYLElBQUk7b0JBQ0EsSUFBSSxDQUFDVixLQUFLLEdBQUcsSUFBSSxDQUFDVSxJQUFJLENBQUM5QyxNQUFNLENBQUNoSjtnQkFDbEMsRUFDQSxPQUFPb1osR0FBRztvQkFDTjFCLGFBQWExWCxLQUFLeUosS0FBSyxFQUFFMlAsR0FBRztvQkFDNUIsSUFBSSxDQUFDQyxVQUFVO2dCQUNuQjtZQUNKO1FBQ0osT0FDSyxJQUFJLElBQUksQ0FBQ0gsVUFBVSxFQUFFO1lBQ3RCLElBQUlDLFNBQVMsSUFBSSxDQUFDRCxVQUFVO1lBQzVCLElBQUksQ0FBQ0EsVUFBVSxHQUFHO1lBQ2xCLElBQUksSUFBSSxDQUFDOU4sS0FBSyxDQUFDK04sTUFBTSxFQUFFO2dCQUNuQixJQUFJO29CQUNBLElBQUksQ0FBQy9OLEtBQUssQ0FBQytOLE1BQU0sQ0FBQ0E7Z0JBQ3RCLEVBQ0EsT0FBT0MsR0FBRztvQkFDTjFCLGFBQWF5QixPQUFPMVAsS0FBSyxFQUFFMlAsR0FBRztvQkFDOUIsSUFBSSxJQUFJLENBQUNoTyxLQUFLLENBQUN6SSxPQUFPLEVBQ2xCLElBQUk7d0JBQ0EsSUFBSSxDQUFDeUksS0FBSyxDQUFDekksT0FBTztvQkFDdEIsRUFDQSxPQUFPcEwsR0FBRyxDQUFFO29CQUNoQixJQUFJLENBQUM4aEIsVUFBVTtnQkFDbkI7WUFDSjtRQUNKO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQTFXLFFBQVEzQyxJQUFJLEVBQUU7UUFDVixJQUFJZ007UUFDSixJQUFJLENBQUNBLEtBQUssSUFBSSxDQUFDWixLQUFLLE1BQU0sUUFBUVksT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHckosT0FBTyxFQUFFO1lBQ25FLElBQUk7Z0JBQ0EsSUFBSSxDQUFDeUksS0FBSyxDQUFDekksT0FBTztZQUN0QixFQUNBLE9BQU95VyxHQUFHO2dCQUNOMUIsYUFBYTFYLEtBQUt5SixLQUFLLEVBQUUyUCxHQUFHO1lBQ2hDO1FBQ0o7SUFDSjtJQUNBQyxhQUFhO1FBQ1QsSUFBSSxDQUFDdk4sSUFBSSxHQUFHLElBQUksQ0FBQ1YsS0FBSyxHQUFHO0lBQzdCO0FBQ0o7QUFDQSxNQUFNa08sbUJBQW1CLFdBQVcsR0FBRW5rQixvREFBS0EsQ0FBQ3FoQixNQUFNO0FBQ2xELE1BQU0rQyxvQkFBb0IsV0FBVyxHQUFFcGtCLG9EQUFLQSxDQUFDcWhCLE1BQU07QUFDbkQsc0JBQXNCO0FBQ3RCLE1BQU1oRixjQUFjLFdBQVcsR0FBRXJjLG9EQUFLQSxDQUFDcWhCLE1BQU07QUFDN0MsTUFBTWdELG1CQUFtQixXQUFXLEdBQUVya0Isb0RBQUtBLENBQUNxaEIsTUFBTTtBQUNsRCxNQUFNaUQsZUFBZSxXQUFXLEdBQUV0a0Isb0RBQUtBLENBQUNxaEIsTUFBTTtBQUM5QyxNQUFNa0QscUJBQXFCLFdBQVcsR0FBRXZrQixvREFBS0EsQ0FBQ3FoQixNQUFNO0FBQ3BELFNBQVNtRCxrQkFBa0IzWixJQUFJLEVBQUVtTyxJQUFJO0lBQ2pDLElBQUl3RixXQUFXM1QsS0FBS3lKLEtBQUssQ0FBQ29PLEtBQUssQ0FBQzZCO0lBQ2hDLElBQUksQ0FBQy9GLFNBQVNoYyxNQUFNLEVBQ2hCLE9BQU9nYztJQUNYLElBQUlpRyxPQUFPakcsU0FBUzBELEdBQUcsQ0FBQy9aLENBQUFBLElBQUtBLGFBQWF1YyxXQUFXdmMsRUFBRTBDLFFBQVExQztJQUMvRCxJQUFJOEosU0FBUyxFQUFFO0lBQ2Z0Uyx1REFBUUEsQ0FBQzZjLEtBQUssQ0FBQ2lJLE1BQU16TCxLQUFLM1EsSUFBSSxFQUFFMlEsS0FBSzFRLEVBQUUsRUFBRTtRQUNyQ2lSLFVBQVU7UUFDVnlDLE1BQUsySSxPQUFPLEVBQUVDLEtBQUssRUFBRXJKLE1BQU0sRUFBRTNHLElBQUk7WUFDN0IsSUFBSXZNLE9BQU9zYyxVQUFVM0wsS0FBSzNRLElBQUksRUFBRUMsS0FBS3NjLFFBQVE1TCxLQUFLM1EsSUFBSTtZQUN0RCxJQUFJcVYsUUFBUXpMO1lBQ1osSUFBSyxJQUFJOUosSUFBSW9ULE9BQU8vWSxNQUFNLEdBQUcsR0FBRzJGLEtBQUssR0FBR0EsS0FBS3lNLE9BQVE7Z0JBQ2pELElBQUlzSixZQUFZM0MsTUFBTSxDQUFDcFQsRUFBRSxDQUFDd08sSUFBSSxDQUFDa08sV0FBVyxFQUFFYjtnQkFDNUMsSUFBSTlGLGFBQWEsTUFDYkEsWUFBWWlELGNBQWNuSSxLQUFLM0ssSUFBSSxFQUFFaEcsTUFBTUM7Z0JBQy9DLElBQUlzTSxPQUFPLEtBQUs4SSxNQUFNbGIsTUFBTSxJQUN4QixDQUFDd2hCLFNBQVN0RyxLQUFLLENBQUNBLE1BQU1sYixNQUFNLEdBQUcsRUFBRSxFQUFFOEYsRUFBRSxJQUFJRCxRQUFRMmIsT0FBTzlGLFNBQVMsSUFBSUEsV0FBVztvQkFDaEY4RixPQUFPMWIsRUFBRSxHQUFHQTtvQkFDWm9WLFFBQVFzRyxPQUFPN0YsS0FBSztnQkFDeEIsT0FDSztvQkFDRCxJQUFJcEgsTUFBTTt3QkFBRTFPO3dCQUFNQzt3QkFBSTRWO3dCQUFXQyxPQUFPLEVBQUU7b0JBQUM7b0JBQzNDVCxNQUFNMVYsSUFBSSxDQUFDK087b0JBQ1gyRyxRQUFRM0csSUFBSW9ILEtBQUs7Z0JBQ3JCO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT2xNO0FBQ1g7QUFDQSxNQUFNNlMsZ0JBQWdCLFdBQVcsR0FBRTlrQixvREFBS0EsQ0FBQ3FoQixNQUFNO0FBQy9DLFNBQVMwRCxpQkFBaUJsYSxJQUFJO0lBQzFCLElBQUluSCxPQUFPLEdBQUdFLFFBQVEsR0FBR0MsTUFBTSxHQUFHQyxTQUFTO0lBQzNDLEtBQUssSUFBSTRLLFVBQVU3RCxLQUFLeUosS0FBSyxDQUFDb08sS0FBSyxDQUFDb0MsZUFBZ0I7UUFDaEQsSUFBSUUsSUFBSXRXLE9BQU83RDtRQUNmLElBQUltYSxHQUFHO1lBQ0gsSUFBSUEsRUFBRXRoQixJQUFJLElBQUksTUFDVkEsT0FBT2lCLEtBQUtzRixHQUFHLENBQUN2RyxNQUFNc2hCLEVBQUV0aEIsSUFBSTtZQUNoQyxJQUFJc2hCLEVBQUVwaEIsS0FBSyxJQUFJLE1BQ1hBLFFBQVFlLEtBQUtzRixHQUFHLENBQUNyRyxPQUFPb2hCLEVBQUVwaEIsS0FBSztZQUNuQyxJQUFJb2hCLEVBQUVuaEIsR0FBRyxJQUFJLE1BQ1RBLE1BQU1jLEtBQUtzRixHQUFHLENBQUNwRyxLQUFLbWhCLEVBQUVuaEIsR0FBRztZQUM3QixJQUFJbWhCLEVBQUVsaEIsTUFBTSxJQUFJLE1BQ1pBLFNBQVNhLEtBQUtzRixHQUFHLENBQUNuRyxRQUFRa2hCLEVBQUVsaEIsTUFBTTtRQUMxQztJQUNKO0lBQ0EsT0FBTztRQUFFSjtRQUFNRTtRQUFPQztRQUFLQztJQUFPO0FBQ3RDO0FBQ0EsTUFBTW1oQixjQUFjLFdBQVcsR0FBRWpsQixvREFBS0EsQ0FBQ3FoQixNQUFNO0FBQzdDLE1BQU02RDtJQUNGamUsWUFBWWtlLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLEdBQUcsQ0FBRTtRQUNoQyxJQUFJLENBQUNILEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLEdBQUcsR0FBR0E7SUFDZjtJQUNBbFgsS0FBS1csS0FBSyxFQUFFO1FBQ1IsT0FBTyxJQUFJbVcsYUFBYXZnQixLQUFLK0MsR0FBRyxDQUFDLElBQUksQ0FBQ3lkLEtBQUssRUFBRXBXLE1BQU1vVyxLQUFLLEdBQUd4Z0IsS0FBS3NGLEdBQUcsQ0FBQyxJQUFJLENBQUNtYixHQUFHLEVBQUVyVyxNQUFNcVcsR0FBRyxHQUFHemdCLEtBQUsrQyxHQUFHLENBQUMsSUFBSSxDQUFDMmQsS0FBSyxFQUFFdFcsTUFBTXNXLEtBQUssR0FBRzFnQixLQUFLc0YsR0FBRyxDQUFDLElBQUksQ0FBQ3FiLEdBQUcsRUFBRXZXLE1BQU11VyxHQUFHO0lBQzdKO0lBQ0FDLFNBQVM5ZCxHQUFHLEVBQUU7UUFDVixJQUFJVSxJQUFJVixJQUFJakYsTUFBTSxFQUFFZ2pCLEtBQUssSUFBSTtRQUM3QixNQUFPcmQsSUFBSSxHQUFHQSxJQUFLO1lBQ2YsSUFBSVgsUUFBUUMsR0FBRyxDQUFDVSxJQUFJLEVBQUU7WUFDdEIsSUFBSVgsTUFBTTJkLEtBQUssR0FBR0ssR0FBR0osR0FBRyxFQUNwQjtZQUNKLElBQUk1ZCxNQUFNNGQsR0FBRyxHQUFHSSxHQUFHTCxLQUFLLEVBQ3BCO1lBQ0pLLEtBQUtBLEdBQUdwWCxJQUFJLENBQUM1RztZQUNiQyxJQUFJZ0csTUFBTSxDQUFDdEYsSUFBSSxHQUFHO1FBQ3RCO1FBQ0FWLElBQUlnRyxNQUFNLENBQUN0RixHQUFHLEdBQUdxZDtRQUNqQixPQUFPL2Q7SUFDWDtJQUNBLE9BQU9nZSxpQkFBaUJDLElBQUksRUFBRXBMLE1BQU0sRUFBRTtRQUNsQyxJQUFJQSxPQUFPOVgsTUFBTSxJQUFJLEdBQ2pCLE9BQU9rakI7UUFDWCxJQUFJelQsU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJMFQsS0FBSyxHQUFHQyxLQUFLLEdBQUdDLE9BQU8sR0FBR0MsT0FBTyxJQUFJSCxLQUFNO1lBQ2hELElBQUlyYSxPQUFPcWEsTUFBTUQsS0FBS2xqQixNQUFNLEdBQUcsT0FBT2tqQixJQUFJLENBQUNDLEdBQUcsRUFBRWhqQixNQUFNa2pCLE9BQU9DO1lBQzdELElBQUlwWixNQUFNcEIsT0FBT0EsS0FBSytaLEtBQUssR0FBRztZQUM5QixNQUFPTyxLQUFLdEwsT0FBTzlYLE1BQU0sSUFBSThYLE1BQU0sQ0FBQ3NMLEdBQUcsR0FBR2xaLElBQUs7Z0JBQzNDLElBQUlyRSxPQUFPaVMsTUFBTSxDQUFDc0wsR0FBRyxFQUFFdGQsS0FBS2dTLE1BQU0sQ0FBQ3NMLEtBQUssRUFBRTtnQkFDMUMsSUFBSVAsUUFBUTFnQixLQUFLc0YsR0FBRyxDQUFDNmIsTUFBTXpkLE9BQU9pZCxNQUFNM2dCLEtBQUsrQyxHQUFHLENBQUNnRixLQUFLcEU7Z0JBQ3RELElBQUkrYyxTQUFTQyxLQUNULElBQUlKLGFBQWFHLFFBQVExaUIsS0FBSzJpQixNQUFNM2lCLEtBQUswaUIsT0FBT0MsS0FBS0MsUUFBUSxDQUFDdFQ7Z0JBQ2xFLElBQUkzSixLQUFLb0UsS0FDTDtxQkFFQWtaLE1BQU07WUFDZDtZQUNBLElBQUksQ0FBQ3RhLE1BQ0QsT0FBTzJHO1lBQ1gsSUFBSWlULGFBQWE1WixLQUFLNlosS0FBSyxFQUFFN1osS0FBSzhaLEdBQUcsRUFBRTlaLEtBQUsrWixLQUFLLEVBQUUvWixLQUFLZ2EsR0FBRyxFQUFFQyxRQUFRLENBQUN0VDtZQUN0RTRULE9BQU92YSxLQUFLOFosR0FBRztZQUNmVSxPQUFPeGEsS0FBS2dhLEdBQUc7UUFDbkI7SUFDSjtBQUNKO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTVM7SUFDRjllLFlBQ0E7O0lBRUEsR0FDQTRELElBQUksRUFDSjs7SUFFQSxHQUNBeUosS0FBSyxFQUNMOztJQUVBLEdBQ0EwUixZQUFZLENBQUU7UUFDVixJQUFJLENBQUNuYixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDeUosS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQzBSLFlBQVksR0FBR0E7UUFDcEI7O1FBRUEsR0FDQSxJQUFJLENBQUN4YixLQUFLLEdBQUc7UUFDYixJQUFJLENBQUN5YixVQUFVLEdBQUdwYixLQUFLeUosS0FBSztRQUM1QixJQUFJLENBQUM2TixPQUFPLEdBQUdqaUIsd0RBQVNBLENBQUNtVSxLQUFLLENBQUMsSUFBSSxDQUFDNFIsVUFBVSxDQUFDcGtCLEdBQUcsQ0FBQ1csTUFBTTtRQUN6RCxLQUFLLElBQUkwakIsTUFBTUYsYUFDWCxJQUFJLENBQUM3RCxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUNnRSxPQUFPLENBQUNELEdBQUcvRCxPQUFPO1FBQ2xELElBQUlpRSxnQkFBZ0IsRUFBRTtRQUN0QixJQUFJLENBQUNqRSxPQUFPLENBQUNrRSxpQkFBaUIsQ0FBQyxDQUFDbEIsT0FBT0MsS0FBS0MsT0FBT0MsTUFBUWMsY0FBY3BlLElBQUksQ0FBQyxJQUFJa2QsYUFBYUMsT0FBT0MsS0FBS0MsT0FBT0M7UUFDbEgsSUFBSSxDQUFDYyxhQUFhLEdBQUdBO0lBQ3pCO0lBQ0E7O0lBRUEsR0FDQSxPQUFPdlMsT0FBT2hKLElBQUksRUFBRXlKLEtBQUssRUFBRTBSLFlBQVksRUFBRTtRQUNyQyxPQUFPLElBQUlELFdBQVdsYixNQUFNeUosT0FBTzBSO0lBQ3ZDO0lBQ0E7Ozs7SUFJQSxHQUNBLElBQUlNLGtCQUFrQjtRQUNsQixPQUFPLENBQUMsSUFBSSxDQUFDOWIsS0FBSyxHQUFHLEVBQUUsdUJBQXVCLEdBQXpCLElBQStCO0lBQ3hEO0lBQ0E7OztJQUdBLEdBQ0EsSUFBSStiLGdCQUFnQjtRQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDL2IsS0FBSyxHQUFHLEVBQUUscUJBQXFCLEdBQXZCLElBQTZCO0lBQ3REO0lBQ0E7OztJQUdBLEdBQ0EsSUFBSWdjLGtCQUFrQjtRQUNsQixPQUFPLElBQUksQ0FBQ0MsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDamMsS0FBSyxHQUFJLEdBQUUsdUJBQXVCLE1BQUssRUFBRSxxQkFBcUIsR0FBdkIsQ0FBeUIsSUFBSztJQUN6RztJQUNBOztJQUVBLEdBQ0EsSUFBSWtjLGVBQWU7UUFDZixPQUFPLENBQUMsSUFBSSxDQUFDbGMsS0FBSyxHQUFHLEVBQUUsb0JBQW9CLEdBQXRCLElBQTRCO0lBQ3JEO0lBQ0E7O0lBRUEsR0FDQSxJQUFJaWMsYUFBYTtRQUNiLE9BQU8sQ0FBQyxJQUFJLENBQUN0RSxPQUFPLENBQUM5TixLQUFLO0lBQzlCO0lBQ0E7O0lBRUEsR0FDQSxJQUFJc1MsZUFBZTtRQUNmLE9BQU8sSUFBSSxDQUFDWCxZQUFZLENBQUNoUCxJQUFJLENBQUNrUCxDQUFBQSxLQUFNQSxHQUFHaGtCLFNBQVM7SUFDcEQ7SUFDQTs7SUFFQSxHQUNBLElBQUltUyxRQUFRO1FBQUUsT0FBTyxJQUFJLENBQUM3SixLQUFLLElBQUksS0FBSyxJQUFJLENBQUN3YixZQUFZLENBQUN4akIsTUFBTSxJQUFJO0lBQUc7QUFDM0U7QUFFQSxNQUFNb2tCLGdCQUFnQnJjO0lBQ2xCLElBQUkvSCxTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUNxSSxJQUFJLENBQUN5SixLQUFLLENBQUN6UyxHQUFHLENBQUNXLE1BQU07SUFBRTtJQUNsRHlFLFlBQVk0RCxJQUFJLENBQUU7UUFDZCxLQUFLO1FBQ0wsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDd1IsV0FBVyxHQUFHLEVBQUU7UUFDckIsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRyxFQUFFO1FBQzlCLElBQUksQ0FBQ3VLLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLG9CQUFvQixHQUFHLElBQUlDO1FBQ2hDLGdFQUFnRTtRQUNoRSxtRUFBbUU7UUFDbkUsbUVBQW1FO1FBQ25FLG9FQUFvRTtRQUNwRSxtRUFBbUU7UUFDbkUsb0VBQW9FO1FBQ3BFLHNCQUFzQjtRQUN0QixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixrRUFBa0U7UUFDbEUsOENBQThDO1FBQzlDLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLCtEQUErRDtRQUMvRCxZQUFZO1FBQ1osSUFBSSxDQUFDQyxVQUFVLEdBQUdDLEtBQUtDLEdBQUc7UUFDMUIsSUFBSSxDQUFDdmEsTUFBTSxDQUFDckMsS0FBSzZjLFVBQVU7UUFDM0IsSUFBSSxDQUFDMWMsUUFBUSxHQUFHO1lBQUMsSUFBSWtMO1NBQVM7UUFDOUIsSUFBSSxDQUFDbEwsUUFBUSxDQUFDLEVBQUUsQ0FBQ2lDLFNBQVMsQ0FBQyxJQUFJO1FBQy9CLElBQUksQ0FBQzBhLFVBQVU7UUFDZixJQUFJLENBQUNDLFdBQVcsQ0FBQztZQUFDLElBQUkxQyxhQUFhLEdBQUcsR0FBRyxHQUFHcmEsS0FBS3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ1csTUFBTTtTQUFFLEVBQUUsR0FBRztJQUM1RTtJQUNBLDZDQUE2QztJQUM3Q3doQixPQUFPQSxNQUFNLEVBQUU7UUFDWCxJQUFJbk47UUFDSixJQUFJdVAsZ0JBQWdCcEMsT0FBT29DLGFBQWE7UUFDeEMsSUFBSSxJQUFJLENBQUNhLFFBQVEsR0FBRyxLQUFLYixjQUFjNWpCLE1BQU0sRUFBRTtZQUMzQyxJQUFJLENBQUM0akIsY0FBY3lCLEtBQUssQ0FBQyxDQUFDLEVBQUUxQyxLQUFLLEVBQUVDLEdBQUcsRUFBRSxHQUFLQSxNQUFNLElBQUksQ0FBQzhCLFlBQVksSUFBSS9CLFFBQVEsSUFBSSxDQUFDZ0MsVUFBVSxHQUFHO2dCQUM5RixJQUFJLENBQUNGLFFBQVEsR0FBRyxJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJLENBQUNDLFVBQVUsR0FBRztZQUMxRCxPQUNLO2dCQUNELElBQUksQ0FBQ0QsWUFBWSxHQUFHbEQsT0FBTzdCLE9BQU8sQ0FBQzJGLE1BQU0sQ0FBQyxJQUFJLENBQUNaLFlBQVksRUFBRTtnQkFDN0QsSUFBSSxDQUFDQyxVQUFVLEdBQUduRCxPQUFPN0IsT0FBTyxDQUFDMkYsTUFBTSxDQUFDLElBQUksQ0FBQ1gsVUFBVSxFQUFFO1lBQzdEO1FBQ0o7UUFDQSxJQUFJWSxvQkFBb0IsQ0FBQztRQUN6QixJQUFJLElBQUksQ0FBQ2xkLElBQUksQ0FBQ21kLFVBQVUsQ0FBQ0MsU0FBUyxJQUFJLEdBQUc7WUFDckMsSUFBSSxDQUFDcFIsS0FBSyxJQUFJLENBQUNnUSxVQUFVLE1BQU0sUUFBUWhRLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3FSLE1BQU0sRUFDckVILG9CQUFvQixJQUFJLENBQUNsQixVQUFVLENBQUNxQixNQUFNLENBQUN0SCxJQUFJO2lCQUM5QyxJQUFJLENBQUN1SCxtQkFBbUJuRSxPQUFPN0IsT0FBTyxFQUFFLElBQUksQ0FBQzJFLGNBQWMsS0FBSyxDQUFDOUMsT0FBTzJDLFlBQVksRUFDckZvQixvQkFBb0IvRCxPQUFPMVAsS0FBSyxDQUFDcFMsU0FBUyxDQUFDa21CLElBQUksQ0FBQ3hILElBQUk7UUFDNUQ7UUFDQSxJQUFJeUgsY0FBY04sb0JBQW9CLENBQUMsSUFBSU8scUJBQXFCLElBQUksQ0FBQ3pkLElBQUksRUFBRW1aLE9BQU83QixPQUFPLEVBQUU0RixxQkFBcUI7UUFDaEgsSUFBSSxDQUFDbEIsVUFBVSxHQUFHO1FBQ2xCLElBQUksSUFBSSxDQUFDQyxjQUFjLEVBQUU7WUFDckIsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ3dCLEtBQUs7WUFDL0IsSUFBSSxFQUFFbGdCLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDd2UsY0FBYztZQUN0Q1YsZ0JBQWdCLElBQUlsQixhQUFhN2MsTUFBTUMsSUFBSTBiLE9BQU83QixPQUFPLENBQUMyRixNQUFNLENBQUN6ZixNQUFNLENBQUMsSUFBSTJiLE9BQU83QixPQUFPLENBQUMyRixNQUFNLENBQUN4ZixJQUFJLElBQ2pHaWQsUUFBUSxDQUFDYSxjQUFjcFUsS0FBSztRQUNyQztRQUNBLElBQUksQ0FBQzhVLGNBQWMsR0FBR3VCLGNBQWM7WUFBRWhnQixNQUFNZ2dCLFlBQVk3Z0IsS0FBSyxDQUFDNmQsS0FBSztZQUFFL2MsSUFBSStmLFlBQVk3Z0IsS0FBSyxDQUFDOGQsR0FBRztRQUFDLElBQUk7UUFDbkcsK0RBQStEO1FBQy9ELGlFQUFpRTtRQUNqRSxnRUFBZ0U7UUFDaEUsK0RBQStEO1FBQy9ELHlCQUF5QjtRQUN6QixJQUFJLENBQUN0VSxRQUFRUCxFQUFFLElBQUlPLFFBQVFMLE1BQU0sS0FBSyxDQUFDMFgsZUFBZXJFLFVBQ2xEQSxPQUFPMVAsS0FBSyxDQUFDelMsR0FBRyxDQUFDMm1CLEtBQUssSUFBSXhFLE9BQU9pQyxVQUFVLENBQUNwa0IsR0FBRyxDQUFDMm1CLEtBQUssRUFDckQsSUFBSSxDQUFDbEIsY0FBYyxHQUFHO1FBQzFCLElBQUltQixXQUFXLElBQUksQ0FBQ3BNLFdBQVcsRUFBRTNGLE9BQU8sSUFBSSxDQUFDaVIsVUFBVTtRQUN2RCxJQUFJZSxXQUFXQyxnQkFBZ0JGLFVBQVUvUixNQUFNc04sT0FBTzdCLE9BQU87UUFDN0RpRSxnQkFBZ0JsQixhQUFhTyxnQkFBZ0IsQ0FBQ1csZUFBZXNDO1FBQzdELElBQUksQ0FBRSxLQUFJLENBQUNsZSxLQUFLLEdBQUcsRUFBRSxrQkFBa0IsR0FBcEIsS0FBMkI0YixjQUFjNWpCLE1BQU0sSUFBSSxHQUFHO1lBQ3JFLE9BQU87UUFDWCxPQUNLO1lBQ0QsSUFBSSxDQUFDb2xCLFdBQVcsQ0FBQ3hCLGVBQWVwQyxPQUFPaUMsVUFBVSxDQUFDcGtCLEdBQUcsQ0FBQ1csTUFBTSxFQUFFNmxCO1lBQzlELElBQUlyRSxPQUFPZ0MsWUFBWSxDQUFDeGpCLE1BQU0sRUFDMUIsSUFBSSxDQUFDK2tCLFVBQVUsR0FBR0MsS0FBS0MsR0FBRztZQUM5QixPQUFPO1FBQ1g7SUFDSjtJQUNBLCtEQUErRDtJQUMvRCxTQUFTO0lBQ1RHLFlBQVl6RixPQUFPLEVBQUV5RyxTQUFTLEVBQUVQLFdBQVcsRUFBRTtRQUN6QyxJQUFJLENBQUN4ZCxJQUFJLENBQUM2TSxTQUFTLENBQUNtUixrQkFBa0IsR0FBRztRQUN6QyxJQUFJLENBQUNDLGNBQWMsQ0FBQzNHLFNBQVN5RyxXQUFXUDtRQUN4QyxJQUFJLEVBQUVVLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQ2xlLElBQUk7UUFDNUJrZSxTQUFTeFQsTUFBTSxDQUFDO1lBQ1osMkRBQTJEO1lBQzNELDhEQUE4RDtZQUM5RCwyREFBMkQ7WUFDM0Qsa0RBQWtEO1lBQ2xELElBQUksQ0FBQzlULEdBQUcsQ0FBQzJPLEtBQUssQ0FBQzVMLE1BQU0sR0FBRyxJQUFJLENBQUNxRyxJQUFJLENBQUM2TSxTQUFTLENBQUNzUixhQUFhLEdBQUcsSUFBSSxDQUFDbmUsSUFBSSxDQUFDdEcsTUFBTSxHQUFHO1lBQy9FLElBQUksQ0FBQzlDLEdBQUcsQ0FBQzJPLEtBQUssQ0FBQzZZLFNBQVMsR0FBRyxJQUFJLENBQUNoQyxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLEdBQUcsT0FBTztZQUNsRSwyREFBMkQ7WUFDM0QsNERBQTREO1lBQzVELDhEQUE4RDtZQUM5RCw0QkFBNEI7WUFDNUIsSUFBSTViLFFBQVEyRixRQUFRTCxNQUFNLElBQUlLLFFBQVFGLEdBQUcsR0FBRztnQkFBRXBQLE1BQU1xbkIsU0FBU0csY0FBYyxDQUFDL2hCLFNBQVM7Z0JBQUUwRSxTQUFTO1lBQU0sSUFBSTNEO1lBQzFHLElBQUksQ0FBQ2tELElBQUksQ0FBQyxJQUFJLENBQUNQLElBQUksRUFBRVE7WUFDckIsSUFBSSxDQUFDYixLQUFLLElBQUksQ0FBQyxFQUFFLGtCQUFrQjtZQUNuQyxJQUFJYSxTQUFVQSxDQUFBQSxNQUFNUSxPQUFPLElBQUlrZCxTQUFTRyxjQUFjLENBQUMvaEIsU0FBUyxJQUFJa0UsTUFBTTNKLElBQUksR0FDMUUsSUFBSSxDQUFDNGxCLGNBQWMsR0FBRztZQUMxQixJQUFJLENBQUM3bEIsR0FBRyxDQUFDMk8sS0FBSyxDQUFDNUwsTUFBTSxHQUFHO1FBQzVCO1FBQ0EsSUFBSSxDQUFDdWlCLG9CQUFvQixDQUFDb0MsT0FBTyxDQUFDQyxDQUFBQSxRQUFTQSxNQUFNNWUsS0FBSyxJQUFJLENBQUMsRUFBRSx3QkFBd0I7UUFDckYsSUFBSTZlLE9BQU8sRUFBRTtRQUNiLElBQUksSUFBSSxDQUFDeGUsSUFBSSxDQUFDeWUsUUFBUSxDQUFDamhCLElBQUksSUFBSSxJQUFJLENBQUN3QyxJQUFJLENBQUN5ZSxRQUFRLENBQUNoaEIsRUFBRSxHQUFHLElBQUksQ0FBQ3VDLElBQUksQ0FBQ3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ1csTUFBTSxFQUM3RTtZQUFBLEtBQUssSUFBSXVJLFNBQVMsSUFBSSxDQUFDQyxRQUFRLENBQzNCLElBQUlELGlCQUFpQmlOLG1CQUFtQmpOLE1BQU0rSSxNQUFNLFlBQVl5VixnQkFDNURGLEtBQUtyaEIsSUFBSSxDQUFDK0MsTUFBTXRKLEdBQUc7UUFBQztRQUNoQ3NuQixTQUFTUyxVQUFVLENBQUNIO0lBQ3hCO0lBQ0FQLGVBQWUzRyxPQUFPLEVBQUV5RyxTQUFTLEVBQUVQLFdBQVcsRUFBRTtRQUM1QyxJQUFJL04sU0FBUytOLGNBQWNBLFlBQVk3Z0IsS0FBSyxDQUFDK2QsUUFBUSxDQUFDcEQsUUFBUW5RLEtBQUssTUFBTW1RO1FBQ3pFLElBQUluSCxTQUFTLElBQUksQ0FBQ2xOLFdBQVcsQ0FBQzhhO1FBQzlCLElBQUssSUFBSXpnQixJQUFJbVMsT0FBTzlYLE1BQU0sR0FBRyxJQUFJMkYsSUFBSztZQUNsQyxJQUFJbUQsT0FBT25ELEtBQUssSUFBSW1TLE1BQU0sQ0FBQ25TLEVBQUUsR0FBRztZQUNoQyxJQUFJLENBQUNtRCxNQUNEO1lBQ0osSUFBSSxFQUFFNlosS0FBSyxFQUFFQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsR0FBRyxFQUFFLEdBQUdoYSxNQUFNb1AsU0FBU25MLGNBQWNYLFdBQVdDO1lBQ3pFLElBQUl3WixlQUFlQSxZQUFZN2dCLEtBQUssQ0FBQzZkLEtBQUssR0FBR0MsT0FBTytDLFlBQVk3Z0IsS0FBSyxDQUFDOGQsR0FBRyxHQUFHRCxPQUFPO2dCQUMvRSxJQUFJamIsU0FBU29RLGVBQWU0QixLQUFLLENBQUMsSUFBSSxDQUFDdlIsSUFBSSxDQUFDeUosS0FBSyxDQUFDelMsR0FBRyxFQUFFd2pCLE9BQU9nRCxZQUFZN2dCLEtBQUssQ0FBQzZkLEtBQUssRUFBRSxJQUFJLENBQUNoSixXQUFXLEVBQUUsSUFBSSxDQUFDQyxvQkFBb0I7Z0JBQ2xJLElBQUlqUyxRQUFRbVEsZUFBZTRCLEtBQUssQ0FBQyxJQUFJLENBQUN2UixJQUFJLENBQUN5SixLQUFLLENBQUN6UyxHQUFHLEVBQUV3bUIsWUFBWTdnQixLQUFLLENBQUM4ZCxHQUFHLEVBQUVBLEtBQUssSUFBSSxDQUFDakosV0FBVyxFQUFFLElBQUksQ0FBQ0Msb0JBQW9CO2dCQUM3SC9NLGVBQWVuRixPQUFPbUYsWUFBWTtnQkFDbENYLFlBQVl4RSxPQUFPd0UsU0FBUztnQkFDNUJDLFVBQVV4RSxNQUFNd0UsT0FBTztnQkFDdkIsSUFBSTRhLFdBQVcsSUFBSSxDQUFDQyxlQUFlLENBQUNyQjtnQkFDcEMsSUFBSWhlLE1BQU1rRixZQUFZLEVBQUU7b0JBQ3BCa2EsU0FBU3hlLFVBQVUsR0FBRztnQkFDMUIsT0FDSyxJQUFJWixNQUFNcVEsT0FBTyxDQUFDbFksTUFBTSxJQUN6QmluQixTQUFTaGIsS0FBSyxDQUFDZ2IsU0FBU2puQixNQUFNLEVBQUVpbkIsU0FBU2puQixNQUFNLEVBQUU2SCxNQUFNcVEsT0FBTyxDQUFDLEVBQUUsRUFBRSxPQUFPclEsTUFBTXVFLFNBQVMsRUFBRSxJQUFJO29CQUMvRjZhLFNBQVN4ZSxVQUFVLEdBQUdaLE1BQU1xUSxPQUFPLENBQUMsRUFBRSxDQUFDelAsVUFBVTtvQkFDakRaLE1BQU1xUSxPQUFPLENBQUN4WixLQUFLO2dCQUN2QjtnQkFDQSxJQUFJa0osT0FBT3NRLE9BQU8sQ0FBQ2xZLE1BQU0sSUFDckJpbkIsU0FBU2hiLEtBQUssQ0FBQyxHQUFHLEdBQUdyRSxPQUFPc1EsT0FBTyxDQUFDdFEsT0FBT3NRLE9BQU8sQ0FBQ2xZLE1BQU0sR0FBRyxFQUFFLEVBQUUsTUFBTSxHQUFHNEgsT0FBT3lFLE9BQU8sR0FBRztvQkFDMUZ6RSxPQUFPc1EsT0FBTyxDQUFDL0ssR0FBRztnQkFDdEI7Z0JBQ0ErSyxVQUFVdFEsT0FBT3NRLE9BQU8sQ0FBQ2lQLE1BQU0sQ0FBQ0YsVUFBVUUsTUFBTSxDQUFDdGYsTUFBTXFRLE9BQU87WUFDbEUsT0FDSztnQkFDQSxHQUFFQSxPQUFPLEVBQUVuTCxZQUFZLEVBQUVYLFNBQVMsRUFBRUMsT0FBTyxFQUFFLEdBQzFDMkwsZUFBZTRCLEtBQUssQ0FBQyxJQUFJLENBQUN2UixJQUFJLENBQUN5SixLQUFLLENBQUN6UyxHQUFHLEVBQUV3akIsT0FBT0MsS0FBSyxJQUFJLENBQUNqSixXQUFXLEVBQUUsSUFBSSxDQUFDQyxvQkFBb0I7WUFDekc7WUFDQSxJQUFJLEVBQUVuVSxHQUFHb0UsR0FBRyxFQUFFNUosS0FBSzBNLEtBQUssRUFBRSxHQUFHMkwsT0FBTy9NLE9BQU8sQ0FBQ21YLEtBQUs7WUFDakQsSUFBSSxFQUFFamQsR0FBR2tFLEtBQUssRUFBRTFKLEtBQUt5TSxPQUFPLEVBQUUsR0FBRzRMLE9BQU8vTSxPQUFPLENBQUNrWCxPQUFPLENBQUM7WUFDeERoVyxhQUFhLElBQUksRUFBRTlDLE9BQU8rQyxTQUFTN0MsS0FBSzhDLE9BQU9xTCxTQUFTbkwsY0FBY1gsV0FBV0M7UUFDckY7UUFDQSxJQUFJd1osYUFDQSxJQUFJLENBQUN1QixpQkFBaUIsQ0FBQ3ZCO0lBQy9CO0lBQ0FxQixnQkFBZ0JyQixXQUFXLEVBQUU7UUFDekIsSUFBSWhqQixNQUFNLElBQUl1TSxTQUFTeVcsWUFBWWhhLElBQUksQ0FBQzlMLFNBQVM7UUFDakQ4QyxJQUFJbUYsS0FBSyxJQUFJLEVBQUUsd0JBQXdCO1FBQ3ZDLEtBQUssSUFBSSxFQUFFa00sSUFBSSxFQUFFLElBQUkyUixZQUFZd0IsS0FBSyxDQUNsQ3hrQixNQUFNLElBQUlrTixTQUFTbUUsTUFBTTtZQUFDclI7U0FBSSxFQUFFQSxJQUFJN0MsTUFBTTtRQUM5QyxJQUFJd1csT0FBTyxJQUFJOUM7UUFDZjhDLEtBQUt4QyxNQUFNLENBQUNuUixLQUFLO1FBQ2pCLE9BQU8yVDtJQUNYO0lBQ0E0USxrQkFBa0J2QixXQUFXLEVBQUU7UUFDM0IsSUFBSXlCLE1BQU0sQ0FBQ3JvQixLQUFLMm5CO1lBQ1pBLE1BQU01ZSxLQUFLLElBQUksRUFBRSx3QkFBd0IsTUFBTTRlLENBQUFBLE1BQU1wZSxRQUFRLENBQUNnTSxJQUFJLENBQUMrUyxDQUFBQSxJQUFLQSxFQUFFdmYsS0FBSyxHQUFHLEVBQUUsa0JBQWtCLE9BQU0sRUFBRSx1QkFBdUIsTUFBSztZQUMxSSxJQUFJLENBQUN1YyxvQkFBb0IsQ0FBQ2hRLEdBQUcsQ0FBQ3FTO1lBQzlCLElBQUlyZixPQUFPUSxZQUFZbUIsR0FBRyxDQUFDaks7WUFDM0IsSUFBSXNJLFFBQVFBLFFBQVFxZixPQUNoQnJmLEtBQUt0SSxHQUFHLEdBQUc7WUFDZjJuQixNQUFNbGMsTUFBTSxDQUFDekw7UUFDakI7UUFDQSxJQUFJcUosTUFBTSxJQUFJLENBQUNrRCxRQUFRLENBQUNxYSxZQUFZN2dCLEtBQUssQ0FBQzZkLEtBQUssRUFBRTtRQUNqRCxJQUFJK0QsUUFBUSxJQUFJLENBQUNwZSxRQUFRLENBQUNGLElBQUkzQyxDQUFDLENBQUM7UUFDaEMyaEIsSUFBSXpCLFlBQVlyUCxJQUFJLEVBQUVvUTtRQUN0QixJQUFLLElBQUlqaEIsSUFBSWtnQixZQUFZd0IsS0FBSyxDQUFDcm5CLE1BQU0sR0FBRyxHQUFHMkYsS0FBSyxDQUFDLEdBQUdBLElBQUs7WUFDckQyQyxNQUFNc2UsTUFBTXBiLFFBQVEsQ0FBQ2xELElBQUluSSxHQUFHLEVBQUU7WUFDOUJ5bUIsUUFBUUEsTUFBTXBlLFFBQVEsQ0FBQ0YsSUFBSTNDLENBQUMsQ0FBQztZQUM3QjJoQixJQUFJM2hCLEtBQUssSUFBSWtnQixZQUFZd0IsS0FBSyxDQUFDMWhCLEVBQUUsQ0FBQ3pHLElBQUksR0FBRzJtQixZQUFZaGEsSUFBSSxFQUFFK2E7UUFDL0Q7SUFDSjtJQUNBLGlEQUFpRDtJQUNqRFksZ0JBQWdCQyxXQUFXLEtBQUssRUFBRUMsY0FBYyxLQUFLLEVBQUU7UUFDbkQsSUFBSUQsWUFBWSxDQUFDLElBQUksQ0FBQ3BmLElBQUksQ0FBQ2tlLFFBQVEsQ0FBQ0csY0FBYyxDQUFDL2hCLFNBQVMsRUFDeEQsSUFBSSxDQUFDMEQsSUFBSSxDQUFDa2UsUUFBUSxDQUFDb0Isa0JBQWtCO1FBQ3pDLElBQUlDLFlBQVksSUFBSSxDQUFDdmYsSUFBSSxDQUFDekosSUFBSSxDQUFDVyxhQUFhLEVBQUVzb0IsVUFBVUQsYUFBYSxJQUFJLENBQUMzb0IsR0FBRztRQUM3RSxJQUFJNm9CLG9CQUFvQixDQUFDRCxXQUNyQnBvQixhQUFhLElBQUksQ0FBQ1IsR0FBRyxFQUFFLElBQUksQ0FBQ29KLElBQUksQ0FBQ2tlLFFBQVEsQ0FBQ0csY0FBYyxLQUFLLENBQUVrQixDQUFBQSxhQUFhLElBQUksQ0FBQzNvQixHQUFHLENBQUNELFFBQVEsQ0FBQzRvQixVQUFTO1FBQzNHLElBQUksQ0FBRUMsQ0FBQUEsV0FBV0gsZUFBZUksaUJBQWdCLEdBQzVDO1FBQ0osSUFBSUMsUUFBUSxJQUFJLENBQUNqRCxjQUFjO1FBQy9CLElBQUksQ0FBQ0EsY0FBYyxHQUFHO1FBQ3RCLElBQUljLE9BQU8sSUFBSSxDQUFDdmQsSUFBSSxDQUFDeUosS0FBSyxDQUFDcFMsU0FBUyxDQUFDa21CLElBQUk7UUFDekMsSUFBSW9DLFNBQVMsSUFBSSxDQUFDQyxVQUFVLENBQUMsSUFBSSxDQUFDdlksUUFBUSxDQUFDa1csS0FBS29DLE1BQU07UUFDdEQsSUFBSTVKLE9BQU93SCxLQUFLL1QsS0FBSyxHQUFHbVcsU0FBUyxJQUFJLENBQUNDLFVBQVUsQ0FBQyxJQUFJLENBQUN2WSxRQUFRLENBQUNrVyxLQUFLeEgsSUFBSTtRQUN4RSw2REFBNkQ7UUFDN0QscUNBQXFDO1FBQ3JDLElBQUk1UCxRQUFRTixLQUFLLElBQUkwWCxLQUFLL1QsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDeVMsY0FBYyxJQUFJNEQsa0JBQWtCRixTQUFTO1lBQ2xGLElBQUlHLFFBQVFwaUIsU0FBU3dKLGNBQWMsQ0FBQztZQUNwQyxJQUFJLENBQUNsSCxJQUFJLENBQUNrZSxRQUFRLENBQUN4VCxNQUFNLENBQUMsSUFBTWlWLE9BQU85b0IsSUFBSSxDQUFDcUssWUFBWSxDQUFDNGUsT0FBT0gsT0FBTzlvQixJQUFJLENBQUM0QixVQUFVLENBQUNrbkIsT0FBTzFnQixNQUFNLENBQUMsSUFBSTtZQUN6RzBnQixTQUFTNUosT0FBTyxJQUFJMVcsT0FBT3lnQixPQUFPO1lBQ2xDSixRQUFRO1FBQ1o7UUFDQSxJQUFJampCLFNBQVMsSUFBSSxDQUFDdUQsSUFBSSxDQUFDa2UsUUFBUSxDQUFDRyxjQUFjO1FBQzlDLGlGQUFpRjtRQUNqRixJQUFJcUIsU0FBUyxDQUFDampCLE9BQU9ILFNBQVMsSUFBSSxDQUFDLENBQUN6RSxxQkFBcUI4bkIsT0FBTzlvQixJQUFJLEVBQUU4b0IsT0FBTzFnQixNQUFNLEVBQUV4QyxPQUFPbkYsVUFBVSxFQUFFbUYsT0FBT0osWUFBWSxLQUN2SCxDQUFDeEUscUJBQXFCa2UsS0FBS2xmLElBQUksRUFBRWtmLEtBQUs5VyxNQUFNLEVBQUV4QyxPQUFPSCxTQUFTLEVBQUVHLE9BQU9GLFdBQVcsTUFBTSxDQUFDLElBQUksQ0FBQ3dqQiwwQkFBMEIsQ0FBQ3RqQixRQUFROGdCLE9BQU87WUFDeEksSUFBSSxDQUFDdmQsSUFBSSxDQUFDa2UsUUFBUSxDQUFDeFQsTUFBTSxDQUFDO2dCQUN0Qiw2REFBNkQ7Z0JBQzdELDJEQUEyRDtnQkFDM0Qsd0RBQXdEO2dCQUN4RCx5Q0FBeUM7Z0JBQ3pDLElBQUl2RSxRQUFRUSxPQUFPLElBQUlSLFFBQVFMLE1BQU0sSUFBSSxJQUFJLENBQUNsUCxHQUFHLENBQUNELFFBQVEsQ0FBQzhGLE9BQU9ILFNBQVMsS0FDdkUwakIsYUFBYXZqQixPQUFPSCxTQUFTLEVBQUUsSUFBSSxDQUFDMUYsR0FBRyxHQUFHO29CQUMxQyxJQUFJLENBQUNBLEdBQUcsQ0FBQ3FwQixJQUFJO29CQUNiLElBQUksQ0FBQ3JwQixHQUFHLENBQUNxRyxLQUFLLENBQUM7d0JBQUVHLGVBQWU7b0JBQUs7Z0JBQ3pDO2dCQUNBLElBQUk4aUIsU0FBUzVwQixhQUFhLElBQUksQ0FBQzBKLElBQUksQ0FBQ3pKLElBQUk7Z0JBQ3hDLElBQUksQ0FBQzJwQjtxQkFDQSxJQUFJM0MsS0FBSy9ULEtBQUssRUFBRTtvQkFDakIsbUVBQW1FO29CQUNuRSxJQUFJckQsUUFBUU4sS0FBSyxFQUFFO3dCQUNmLElBQUlzYSxTQUFTQyxpQkFBaUJULE9BQU85b0IsSUFBSSxFQUFFOG9CLE9BQU8xZ0IsTUFBTTt3QkFDeEQsSUFBSWtoQixVQUFVQSxVQUFXLEdBQUUsaUJBQWlCLE1BQUssRUFBRSxnQkFBZ0IsR0FBbEIsR0FBdUI7NEJBQ3BFLElBQUkzYyxPQUFPNmMsZUFBZVYsT0FBTzlvQixJQUFJLEVBQUU4b0IsT0FBTzFnQixNQUFNLEVBQUVraEIsVUFBVSxFQUFFLGlCQUFpQixNQUFLLElBQUksQ0FBQzs0QkFDN0YsSUFBSTNjLE1BQ0FtYyxTQUFTLElBQUl0Z0IsT0FBT21FLEtBQUszTSxJQUFJLEVBQUUyTSxLQUFLdkUsTUFBTTt3QkFDbEQ7b0JBQ0o7b0JBQ0FpaEIsT0FBT0ksUUFBUSxDQUFDWCxPQUFPOW9CLElBQUksRUFBRThvQixPQUFPMWdCLE1BQU07b0JBQzFDLElBQUlzZSxLQUFLdEgsU0FBUyxJQUFJLFFBQVFpSyxPQUFPSyxjQUFjLEtBQUtsakIsV0FDcEQ2aUIsT0FBT0ssY0FBYyxHQUFHaEQsS0FBS3RILFNBQVM7Z0JBQzlDLE9BQ0ssSUFBSWlLLE9BQU9NLE1BQU0sRUFBRTtvQkFDcEIsaUVBQWlFO29CQUNqRSwwREFBMEQ7b0JBQzFELDJCQUEyQjtvQkFDM0JOLE9BQU9JLFFBQVEsQ0FBQ1gsT0FBTzlvQixJQUFJLEVBQUU4b0IsT0FBTzFnQixNQUFNO29CQUMxQyx1REFBdUQ7b0JBQ3ZELHdEQUF3RDtvQkFDeEQsVUFBVTtvQkFDVixJQUFJO3dCQUNBaWhCLE9BQU9NLE1BQU0sQ0FBQ3pLLEtBQUtsZixJQUFJLEVBQUVrZixLQUFLOVcsTUFBTTtvQkFDeEMsRUFDQSxPQUFPMUgsR0FBRyxDQUFFO2dCQUNoQixPQUNLO29CQUNELHFCQUFxQjtvQkFDckIsSUFBSW9GLFFBQVFlLFNBQVNDLFdBQVc7b0JBQ2hDLElBQUk0ZixLQUFLb0MsTUFBTSxHQUFHcEMsS0FBS3hILElBQUksRUFDdkIsQ0FBQzRKLFFBQVE1SixLQUFLLEdBQUc7d0JBQUNBO3dCQUFNNEo7cUJBQU87b0JBQ25DaGpCLE1BQU1pQixNQUFNLENBQUNtWSxLQUFLbGYsSUFBSSxFQUFFa2YsS0FBSzlXLE1BQU07b0JBQ25DdEMsTUFBTWtCLFFBQVEsQ0FBQzhoQixPQUFPOW9CLElBQUksRUFBRThvQixPQUFPMWdCLE1BQU07b0JBQ3pDaWhCLE9BQU9PLGVBQWU7b0JBQ3RCUCxPQUFPMVEsUUFBUSxDQUFDN1M7Z0JBQ3BCO2dCQUNBLElBQUk4aUIscUJBQXFCLElBQUksQ0FBQ3pmLElBQUksQ0FBQ3pKLElBQUksQ0FBQ1csYUFBYSxJQUFJLElBQUksQ0FBQ04sR0FBRyxFQUFFO29CQUMvRCxJQUFJLENBQUNBLEdBQUcsQ0FBQ3FwQixJQUFJO29CQUNiLElBQUlWLFdBQ0FBLFVBQVV0aUIsS0FBSztnQkFDdkI7WUFDSjtZQUNBLElBQUksQ0FBQytDLElBQUksQ0FBQ2tlLFFBQVEsQ0FBQ3dDLGlCQUFpQixDQUFDZixRQUFRNUo7UUFDakQ7UUFDQSxJQUFJLENBQUN3RyxlQUFlLEdBQUdvRCxPQUFPcmdCLE9BQU8sR0FBRyxPQUFPLElBQUlELE9BQU81QyxPQUFPbkYsVUFBVSxFQUFFbUYsT0FBT0osWUFBWTtRQUNoRyxJQUFJLENBQUNtZ0IsYUFBYSxHQUFHekcsS0FBS3pXLE9BQU8sR0FBRyxPQUFPLElBQUlELE9BQU81QyxPQUFPSCxTQUFTLEVBQUVHLE9BQU9GLFdBQVc7SUFDOUY7SUFDQSxnRUFBZ0U7SUFDaEUsNERBQTREO0lBQzVELGVBQWU7SUFDZndqQiwyQkFBMkJZLEdBQUcsRUFBRXhRLE1BQU0sRUFBRTtRQUNwQyxPQUFPLElBQUksQ0FBQzhMLGNBQWMsSUFBSTlMLE9BQU8zRyxLQUFLLElBQ3RDM1IscUJBQXFCOG9CLElBQUlya0IsU0FBUyxFQUFFcWtCLElBQUlwa0IsV0FBVyxFQUFFb2tCLElBQUlycEIsVUFBVSxFQUFFcXBCLElBQUl0a0IsWUFBWSxLQUNyRixJQUFJLENBQUN1a0IsVUFBVSxDQUFDRCxJQUFJcmtCLFNBQVMsRUFBRXFrQixJQUFJcGtCLFdBQVcsS0FBSzRULE9BQU80RixJQUFJO0lBQ3RFO0lBQ0E4SyxxQkFBcUI7UUFDakIsSUFBSSxJQUFJLENBQUM1RSxjQUFjLEVBQ25CO1FBQ0osSUFBSSxFQUFFamMsSUFBSSxFQUFFLEdBQUcsSUFBSSxFQUFFbVEsU0FBU25RLEtBQUt5SixLQUFLLENBQUNwUyxTQUFTLENBQUNrbUIsSUFBSTtRQUN2RCxJQUFJb0QsTUFBTXJxQixhQUFhMEosS0FBS3pKLElBQUk7UUFDaEMsSUFBSSxFQUFFZSxVQUFVLEVBQUUrRSxZQUFZLEVBQUUsR0FBRzJELEtBQUtrZSxRQUFRLENBQUNHLGNBQWM7UUFDL0QsSUFBSSxDQUFDc0MsT0FBTyxDQUFDeFEsT0FBTzNHLEtBQUssSUFBSSxDQUFDMkcsT0FBTzZDLEtBQUssSUFBSSxDQUFDMk4sSUFBSUcsTUFBTSxFQUNyRDtRQUNKLElBQUkzUyxPQUFPOUMsU0FBU3pDLElBQUksQ0FBQyxJQUFJLEVBQUV1SCxPQUFPNEYsSUFBSTtRQUMxQyxJQUFJLENBQUM1SCxNQUNEO1FBQ0osSUFBSTRTLFlBQVk1UyxLQUFLdE8sVUFBVTtRQUMvQixJQUFJc1EsT0FBTzRGLElBQUksSUFBSWdMLGFBQWE1USxPQUFPNEYsSUFBSSxJQUFJZ0wsWUFBWTVTLEtBQUt4VyxNQUFNLEVBQ2xFO1FBQ0osSUFBSTRILFNBQVMsSUFBSSxDQUFDaUksUUFBUSxDQUFDMkksT0FBTzRGLElBQUksRUFBRSxDQUFDLElBQUl2VyxRQUFRLElBQUksQ0FBQ2dJLFFBQVEsQ0FBQzJJLE9BQU80RixJQUFJLEVBQUU7UUFDaEYsSUFBSSxDQUFDeFcsVUFBVSxDQUFDQyxTQUFTRCxPQUFPdEcsTUFBTSxHQUFHdUcsTUFBTXhHLEdBQUcsRUFDOUM7UUFDSixJQUFJcEMsTUFBTSxJQUFJLENBQUN5USxRQUFRLENBQUM4SSxPQUFPNEYsSUFBSSxHQUFHNUYsT0FBTzZDLEtBQUs7UUFDbEQyTixJQUFJTCxRQUFRLENBQUMxcEIsSUFBSUMsSUFBSSxFQUFFRCxJQUFJcUksTUFBTTtRQUNqQzBoQixJQUFJRyxNQUFNLENBQUMsUUFBUTNRLE9BQU82QyxLQUFLLEdBQUcsSUFBSSxZQUFZLFlBQVk7UUFDOUQsaUVBQWlFO1FBQ2pFLG1DQUFtQztRQUNuQ2hULEtBQUtrZSxRQUFRLENBQUNvQixrQkFBa0I7UUFDaEMsSUFBSTBCLFdBQVdoaEIsS0FBS2tlLFFBQVEsQ0FBQ0csY0FBYztRQUMzQyxJQUFJcmUsS0FBS2lOLE9BQU8sQ0FBQzJULFVBQVUsQ0FBQ0ksU0FBUzFwQixVQUFVLEVBQUUwcEIsU0FBUzNrQixZQUFZLEtBQUs4VCxPQUFPM1MsSUFBSSxFQUNsRm1qQixJQUFJTCxRQUFRLENBQUNocEIsWUFBWStFO0lBQ2pDO0lBQ0Esb0VBQW9FO0lBQ3BFLDhEQUE4RDtJQUM5RHVqQixXQUFXM2YsR0FBRyxFQUFFO1FBQ1osK0RBQStEO1FBQy9ELGlEQUFpRDtRQUNqRCxJQUFJckosTUFBTSxJQUFJLENBQUNBLEdBQUcsRUFBRXFxQjtRQUNwQixJQUFJaGhCLElBQUlwSixJQUFJLElBQUlELEtBQ1osT0FBT3FKO1FBQ1gsSUFBSyxJQUFJM0MsSUFBSTJDLElBQUloQixNQUFNLEVBQUUsQ0FBQ2dpQixVQUFVM2pCLElBQUkxRyxJQUFJNkIsVUFBVSxDQUFDZCxNQUFNLEVBQUUyRixJQUFLO1lBQ2hFLElBQUkwQyxPQUFPTixZQUFZbUIsR0FBRyxDQUFDakssSUFBSTZCLFVBQVUsQ0FBQzZFLEVBQUU7WUFDNUMsSUFBSTBDLGdCQUFnQnFMLFVBQ2hCNFYsU0FBU2poQixLQUFLcUgsUUFBUSxDQUFDO1FBQy9CO1FBQ0EsSUFBSyxJQUFJL0osSUFBSTJDLElBQUloQixNQUFNLEdBQUcsR0FBRyxDQUFDZ2lCLFVBQVUzakIsS0FBSyxHQUFHQSxJQUFLO1lBQ2pELElBQUkwQyxPQUFPTixZQUFZbUIsR0FBRyxDQUFDakssSUFBSTZCLFVBQVUsQ0FBQzZFLEVBQUU7WUFDNUMsSUFBSTBDLGdCQUFnQnFMLFVBQ2hCNFYsU0FBU2poQixLQUFLcUgsUUFBUSxDQUFDckgsS0FBS3JJLE1BQU07UUFDMUM7UUFDQSxPQUFPc3BCLFNBQVMsSUFBSTVoQixPQUFPNGhCLE9BQU9wcUIsSUFBSSxFQUFFb3FCLE9BQU9oaUIsTUFBTSxFQUFFLFFBQVFnQjtJQUNuRTtJQUNBaWhCLFFBQVF0cUIsR0FBRyxFQUFFO1FBQ1QsSUFBSyxJQUFJNEQsTUFBTTVELEtBQUs0RCxLQUFNO1lBQ3RCLElBQUkybUIsVUFBVXpoQixZQUFZbUIsR0FBRyxDQUFDckc7WUFDOUIsSUFBSTJtQixXQUFXQSxRQUFRNWUsUUFBUSxJQUFJLElBQUksRUFDbkMsT0FBTzRlO1lBQ1gzbUIsTUFBTUEsSUFBSTFELFVBQVU7UUFDeEI7UUFDQSxPQUFPO0lBQ1g7SUFDQThwQixXQUFXL3BCLElBQUksRUFBRW9JLE1BQU0sRUFBRTtRQUNyQixJQUFJZSxPQUFPLElBQUksQ0FBQ2toQixPQUFPLENBQUNycUI7UUFDeEIsSUFBSSxDQUFDbUosTUFDRCxNQUFNLElBQUlLLFdBQVc7UUFDekIsT0FBT0wsS0FBS29CLGVBQWUsQ0FBQ3ZLLE1BQU1vSSxVQUFVZSxLQUFLSCxVQUFVO0lBQy9EO0lBQ0F3SCxTQUFTcEgsR0FBRyxFQUFFO1FBQ1YsSUFBSSxFQUFFM0MsQ0FBQyxFQUFFeEYsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDbUwsV0FBVyxHQUFHRyxPQUFPLENBQUNuRCxLQUFLLENBQUM7UUFDbEQsTUFBTzNDLElBQUksSUFBSSxDQUFDNkMsUUFBUSxDQUFDeEksTUFBTSxHQUFHLEdBQUk7WUFDbEMsSUFBSXVJLFFBQVEsSUFBSSxDQUFDQyxRQUFRLENBQUM3QyxFQUFFO1lBQzVCLElBQUl4RixNQUFNb0ksTUFBTXZJLE1BQU0sSUFBSXVJLGlCQUFpQm1MLFVBQ3ZDO1lBQ0ovTjtZQUNBeEYsTUFBTTtRQUNWO1FBQ0EsT0FBTyxJQUFJLENBQUNxSSxRQUFRLENBQUM3QyxFQUFFLENBQUMrSixRQUFRLENBQUN2UDtJQUNyQztJQUNBMFAsU0FBU3ZILEdBQUcsRUFBRWhHLElBQUksRUFBRTtRQUNoQixJQUFJbW5CLE9BQU8sTUFBTUMsVUFBVTtRQUMzQixJQUFLLElBQUl2cEIsTUFBTSxJQUFJLENBQUNILE1BQU0sRUFBRTJGLElBQUksSUFBSSxDQUFDNkMsUUFBUSxDQUFDeEksTUFBTSxHQUFHLEdBQUcyRixLQUFLLEdBQUdBLElBQUs7WUFDbkUsSUFBSTRDLFFBQVEsSUFBSSxDQUFDQyxRQUFRLENBQUM3QyxFQUFFLEVBQUV1RSxNQUFNL0osTUFBTW9JLE1BQU1FLFVBQVUsRUFBRXRFLFFBQVErRixNQUFNM0IsTUFBTXZJLE1BQU07WUFDdEYsSUFBSWtLLE1BQU01QixLQUNOO1lBQ0osSUFBSW5FLFNBQVNtRSxPQUFRbkUsQ0FBQUEsUUFBUW1FLE9BQU9DLE1BQU04TSxNQUFNLENBQUMsQ0FBQyxFQUFDLEtBQU9uTCxDQUFBQSxNQUFNNUIsT0FBT0MsTUFBTThNLE1BQU0sQ0FBQyxFQUFDLEtBQ2hGLEVBQUNvVSxRQUFRbGhCLGlCQUFpQm1MLFlBQVksQ0FBRStWLENBQUFBLGdCQUFnQi9WLFlBQVlwUixRQUFRLEVBQUMsR0FBSTtnQkFDbEZtbkIsT0FBT2xoQjtnQkFDUG1oQixVQUFVdmxCO1lBQ2Q7WUFDQWhFLE1BQU1nRTtRQUNWO1FBQ0EsT0FBT3NsQixPQUFPQSxLQUFLNVosUUFBUSxDQUFDdkgsTUFBTW9oQixTQUFTcG5CLFFBQVE7SUFDdkQ7SUFDQXFuQixjQUFjcmhCLEdBQUcsRUFBRTtRQUNmLElBQUksRUFBRTNDLENBQUMsRUFBRXhGLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQ3FMLFFBQVEsQ0FBQ2xELEtBQUssSUFBSUMsUUFBUSxJQUFJLENBQUNDLFFBQVEsQ0FBQzdDLEVBQUU7UUFDaEUsSUFBSSxDQUFFNEMsQ0FBQUEsaUJBQWlCbUwsUUFBTyxHQUMxQixPQUFPO1FBQ1gsTUFBT25MLE1BQU1DLFFBQVEsQ0FBQ3hJLE1BQU0sQ0FBRTtZQUMxQixJQUFJLEVBQUUyRixDQUFDLEVBQUV4RixLQUFLeXBCLFFBQVEsRUFBRSxHQUFHcmhCLE1BQU1pRCxRQUFRLENBQUNyTCxLQUFLO1lBQy9DLE9BQVF3RixJQUFLO2dCQUNULElBQUlBLEtBQUs0QyxNQUFNQyxRQUFRLENBQUN4SSxNQUFNLEVBQzFCLE9BQU87Z0JBQ1gsSUFBSSxDQUFDdUksUUFBUUEsTUFBTUMsUUFBUSxDQUFDN0MsRUFBRSxFQUFFM0YsTUFBTSxFQUNsQztZQUNSO1lBQ0FHLE1BQU15cEI7UUFDVjtRQUNBLElBQUksQ0FBRXJoQixDQUFBQSxpQkFBaUI2RyxRQUFPLEdBQzFCLE9BQU87UUFDWCxJQUFJbEYsTUFBTTVNLG1FQUFnQkEsQ0FBQ2lMLE1BQU1zRCxJQUFJLEVBQUUxTDtRQUN2QyxJQUFJK0osT0FBTy9KLEtBQ1AsT0FBTztRQUNYLElBQUk0USxRQUFRalIsVUFBVXlJLE1BQU10SixHQUFHLEVBQUVrQixLQUFLK0osS0FBS2pLLGNBQWM7UUFDekQsSUFBSyxJQUFJMEYsSUFBSSxHQUFHQSxJQUFJb0wsTUFBTS9RLE1BQU0sRUFBRTJGLElBQUs7WUFDbkMsSUFBSTFFLE9BQU84UCxLQUFLLENBQUNwTCxFQUFFO1lBQ25CLElBQUlBLEtBQUtvTCxNQUFNL1EsTUFBTSxHQUFHLEtBQUtpQixLQUFLSSxHQUFHLEdBQUdKLEtBQUtLLE1BQU0sSUFBSUwsS0FBS0MsSUFBSSxHQUFHRCxLQUFLRyxLQUFLLEVBQ3pFLE9BQU9IO1FBQ2Y7UUFDQSxPQUFPO0lBQ1g7SUFDQTRvQiwwQkFBMEIvQyxRQUFRLEVBQUU7UUFDaEMsSUFBSXJYLFNBQVMsRUFBRSxFQUFFLEVBQUU1SixJQUFJLEVBQUVDLEVBQUUsRUFBRSxHQUFHZ2hCO1FBQ2hDLElBQUlnRCxlQUFlLElBQUksQ0FBQ3poQixJQUFJLENBQUM2YyxVQUFVLENBQUMzaEIsV0FBVztRQUNuRCxJQUFJd21CLFVBQVVELGVBQWUzbkIsS0FBS3NGLEdBQUcsQ0FBQyxJQUFJLENBQUNZLElBQUksQ0FBQzJoQixTQUFTLENBQUN6bUIsV0FBVyxFQUFFLElBQUksQ0FBQ2toQixRQUFRLElBQUk7UUFDeEYsSUFBSXdGLFNBQVMsQ0FBQyxHQUFHdm5CLE1BQU0sSUFBSSxDQUFDMkYsSUFBSSxDQUFDNmhCLGFBQWEsSUFBSS9QLFVBQVVDLEdBQUc7UUFDL0QsSUFBSyxJQUFJOVIsTUFBTSxHQUFHM0MsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzZDLFFBQVEsQ0FBQ3hJLE1BQU0sRUFBRTJGLElBQUs7WUFDcEQsSUFBSTRDLFFBQVEsSUFBSSxDQUFDQyxRQUFRLENBQUM3QyxFQUFFLEVBQUV1RSxNQUFNNUIsTUFBTUMsTUFBTXZJLE1BQU07WUFDdEQsSUFBSWtLLE1BQU1wRSxJQUNOO1lBQ0osSUFBSXdDLE9BQU96QyxNQUFNO2dCQUNiLElBQUlza0IsWUFBWTVoQixNQUFNdEosR0FBRyxDQUFDd0UscUJBQXFCO2dCQUMvQ2dNLE9BQU9qSyxJQUFJLENBQUMya0IsVUFBVW5vQixNQUFNO2dCQUM1QixJQUFJK25CLFNBQVM7b0JBQ1QsSUFBSS9jLE9BQU96RSxNQUFNdEosR0FBRyxDQUFDMEssU0FBUztvQkFDOUIsSUFBSW9ILFFBQVEvRCxPQUFPbk4sZUFBZW1OLFFBQVEsRUFBRTtvQkFDNUMsSUFBSStELE1BQU0vUSxNQUFNLEVBQUU7d0JBQ2QsSUFBSWlCLE9BQU84UCxLQUFLLENBQUNBLE1BQU0vUSxNQUFNLEdBQUcsRUFBRTt3QkFDbEMsSUFBSTZCLFFBQVFhLE1BQU16QixLQUFLRyxLQUFLLEdBQUcrb0IsVUFBVWpwQixJQUFJLEdBQUdpcEIsVUFBVS9vQixLQUFLLEdBQUdILEtBQUtDLElBQUk7d0JBQzNFLElBQUlXLFFBQVFvb0IsUUFBUTs0QkFDaEJBLFNBQVNwb0I7NEJBQ1QsSUFBSSxDQUFDNGlCLFFBQVEsR0FBR3FGOzRCQUNoQixJQUFJLENBQUNwRixZQUFZLEdBQUdwYzs0QkFDcEIsSUFBSSxDQUFDcWMsVUFBVSxHQUFHemE7d0JBQ3RCO29CQUNKO2dCQUNKO1lBQ0o7WUFDQTVCLE1BQU00QixNQUFNM0IsTUFBTUUsVUFBVTtRQUNoQztRQUNBLE9BQU9nSDtJQUNYO0lBQ0EyYSxnQkFBZ0I5aEIsR0FBRyxFQUFFO1FBQ2pCLElBQUksRUFBRTNDLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQzZGLFFBQVEsQ0FBQ2xELEtBQUs7UUFDL0IsT0FBT3BGLGlCQUFpQixJQUFJLENBQUNzRixRQUFRLENBQUM3QyxFQUFFLENBQUMxRyxHQUFHLEVBQUV5YyxTQUFTLElBQUksUUFBUXZCLFVBQVVFLEdBQUcsR0FBR0YsVUFBVUMsR0FBRztJQUNwRztJQUNBeEYsa0JBQWtCO1FBQ2QsS0FBSyxJQUFJck0sU0FBUyxJQUFJLENBQUNDLFFBQVEsQ0FBRTtZQUM3QixJQUFJRCxpQkFBaUJtTCxVQUFVO2dCQUMzQixJQUFJMlcsVUFBVTloQixNQUFNcU0sZUFBZTtnQkFDbkMsSUFBSXlWLFNBQ0EsT0FBT0E7WUFDZjtRQUNKO1FBQ0EscUVBQXFFO1FBQ3JFLElBQUlsQyxRQUFRcGlCLFNBQVMwSyxhQUFhLENBQUMsUUFBUXNFLFlBQVlDLFdBQVdGO1FBQ2xFcVQsTUFBTS9YLFNBQVMsR0FBRztRQUNsQitYLE1BQU12YSxLQUFLLENBQUMvTCxLQUFLLEdBQUc7UUFDcEJzbUIsTUFBTXZhLEtBQUssQ0FBQ3pLLFFBQVEsR0FBRztRQUN2QmdsQixNQUFNbUMsV0FBVyxHQUFHO1FBQ3BCLElBQUksQ0FBQ2ppQixJQUFJLENBQUNrZSxRQUFRLENBQUN4VCxNQUFNLENBQUM7WUFDdEIsSUFBSSxDQUFDOVQsR0FBRyxDQUFDMFYsV0FBVyxDQUFDd1Q7WUFDckIsSUFBSWxuQixPQUFPcEIsZUFBZXNvQixNQUFNbmYsVUFBVSxDQUFDLENBQUMsRUFBRTtZQUM5QytMLGFBQWFvVCxNQUFNMWtCLHFCQUFxQixHQUFHekIsTUFBTTtZQUNqRGdULFlBQVkvVCxPQUFPQSxLQUFLWSxLQUFLLEdBQUcsS0FBSztZQUNyQ2lULGFBQWE3VCxPQUFPQSxLQUFLZSxNQUFNLEdBQUcrUztZQUNsQ29ULE1BQU1vQyxNQUFNO1FBQ2hCO1FBQ0EsT0FBTztZQUFFeFY7WUFBWUM7WUFBV0Y7UUFBVztJQUMvQztJQUNBeEosWUFBWWhELE1BQU0sSUFBSSxDQUFDdEksTUFBTSxFQUFFO1FBQzNCLDREQUE0RDtRQUM1RCxnRUFBZ0U7UUFDaEUsbUNBQW1DO1FBQ25DLElBQUkyRixJQUFJLElBQUksQ0FBQzZDLFFBQVEsQ0FBQ3hJLE1BQU07UUFDNUIsSUFBSTJGLEdBQ0EyQyxPQUFPLElBQUksQ0FBQ0UsUUFBUSxDQUFDLEVBQUU3QyxFQUFFLENBQUMzRixNQUFNO1FBQ3BDLE9BQU8sSUFBSXVMLFlBQVksSUFBSSxDQUFDL0MsUUFBUSxFQUFFRixLQUFLM0M7SUFDL0M7SUFDQTZrQixzQkFBc0I7UUFDbEIsSUFBSXRXLE9BQU8sRUFBRSxFQUFFdVcsS0FBSyxJQUFJLENBQUNwaUIsSUFBSSxDQUFDNk0sU0FBUztRQUN2QyxJQUFLLElBQUk1TSxNQUFNLEdBQUczQyxJQUFJLElBQUlBLElBQUs7WUFDM0IsSUFBSW1ELE9BQU9uRCxLQUFLOGtCLEdBQUdDLFNBQVMsQ0FBQzFxQixNQUFNLEdBQUcsT0FBT3lxQixHQUFHQyxTQUFTLENBQUMva0IsRUFBRTtZQUM1RCxJQUFJdUUsTUFBTXBCLE9BQU9BLEtBQUtqRCxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUM3RixNQUFNO1lBQzVDLElBQUlrSyxNQUFNNUIsS0FBSztnQkFDWCxJQUFJdEcsU0FBUyxDQUFDeW9CLEdBQUdFLFdBQVcsQ0FBQ3pnQixLQUFLNUksTUFBTSxHQUFHbXBCLEdBQUdFLFdBQVcsQ0FBQ3JpQixLQUFLakgsR0FBRyxJQUFJLElBQUksQ0FBQ2dILElBQUksQ0FBQ3RHLE1BQU07Z0JBQ3RGbVMsS0FBSzFPLElBQUksQ0FBQ3lRLFdBQVd0SyxPQUFPLENBQUM7b0JBQ3pCMkYsUUFBUSxJQUFJeVYsZUFBZS9rQjtvQkFDM0J1VCxPQUFPO29CQUNQcUMsV0FBVztvQkFDWHRCLFlBQVk7Z0JBQ2hCLEdBQUd0UixLQUFLLENBQUNzRCxLQUFLNEI7WUFDbEI7WUFDQSxJQUFJLENBQUNwQixNQUNEO1lBQ0pSLE1BQU1RLEtBQUtoRCxFQUFFLEdBQUc7UUFDcEI7UUFDQSxPQUFPbVEsV0FBV2hSLEdBQUcsQ0FBQ2lQO0lBQzFCO0lBQ0FpUixhQUFhO1FBQ1QsSUFBSXlGLFVBQVUsSUFBSSxDQUFDdmlCLElBQUksQ0FBQ3lKLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ3JHLGFBQWE2RixHQUFHLENBQUMsQ0FBQ21MLEdBQUdsbEI7WUFDckQsSUFBSW1sQixVQUFVLElBQUksQ0FBQ2hSLG9CQUFvQixDQUFDblUsRUFBRSxHQUFHLE9BQU9rbEIsS0FBSztZQUN6RCxPQUFPQyxVQUFVRCxFQUFFLElBQUksQ0FBQ3hpQixJQUFJLElBQUl3aUI7UUFDcEM7UUFDQSxJQUFJRSxlQUFlLE9BQU9DLFlBQVksSUFBSSxDQUFDM2lCLElBQUksQ0FBQ3lKLEtBQUssQ0FBQ29PLEtBQUssQ0FBQzJCLGtCQUFrQm5DLEdBQUcsQ0FBQyxDQUFDbUwsR0FBR2xsQjtZQUNsRixJQUFJbWxCLFVBQVUsT0FBT0QsS0FBSztZQUMxQixJQUFJQyxTQUNBQyxlQUFlO1lBQ25CLE9BQU9ELFVBQVVELEVBQUUsSUFBSSxDQUFDeGlCLElBQUksSUFBSXdpQjtRQUNwQztRQUNBLElBQUlHLFVBQVVockIsTUFBTSxFQUFFO1lBQ2xCLElBQUksQ0FBQzhaLG9CQUFvQixDQUFDOFEsUUFBUTVxQixNQUFNLENBQUMsR0FBRytxQjtZQUM1Q0gsUUFBUXBsQixJQUFJLENBQUNySSx1REFBUUEsQ0FBQ3lPLElBQUksQ0FBQ29mO1FBQy9CO1FBQ0EsSUFBSyxJQUFJcmxCLElBQUlpbEIsUUFBUTVxQixNQUFNLEVBQUUyRixJQUFJaWxCLFFBQVE1cUIsTUFBTSxHQUFHLEdBQUcyRixJQUNqRCxJQUFJLENBQUNtVSxvQkFBb0IsQ0FBQ25VLEVBQUUsR0FBRztRQUNuQyxPQUFPLElBQUksQ0FBQ2tVLFdBQVcsR0FBRztlQUNuQitRO1lBQ0gsSUFBSSxDQUFDSixtQkFBbUI7WUFDeEIsSUFBSSxDQUFDbmlCLElBQUksQ0FBQzZNLFNBQVMsQ0FBQytWLFdBQVc7U0FDbEM7SUFDTDtJQUNBcEwsZUFBZWhoQixNQUFNLEVBQUU7UUFDbkIsSUFBSUEsT0FBTzRnQixVQUFVLEVBQUU7WUFDbkIsSUFBSXlMLE1BQU0sSUFBSSxDQUFDN2lCLElBQUksQ0FBQzZNLFNBQVMsQ0FBQ3lWLFdBQVcsQ0FBQzlyQixPQUFPbUcsS0FBSyxDQUFDb1osSUFBSTtZQUMzRCxJQUFJLENBQUMvVixJQUFJLENBQUMyaEIsU0FBUyxDQUFDNWxCLFNBQVMsR0FBRzhtQixJQUFJN3BCLEdBQUcsR0FBR3hDLE9BQU80RCxPQUFPO1lBQ3hELElBQUksQ0FBQzRGLElBQUksQ0FBQzJoQixTQUFTLENBQUMzbEIsVUFBVSxHQUFHeEYsT0FBTzJELE9BQU87WUFDL0M7UUFDSjtRQUNBLElBQUksRUFBRXdDLEtBQUssRUFBRSxHQUFHbkc7UUFDaEIsSUFBSW9DLE9BQU8sSUFBSSxDQUFDNE8sUUFBUSxDQUFDN0ssTUFBTW9aLElBQUksRUFBRXBaLE1BQU02TSxLQUFLLEdBQUc3TSxNQUFNcVcsS0FBSyxHQUFHclcsTUFBTW9aLElBQUksR0FBR3BaLE1BQU1nakIsTUFBTSxHQUFHLENBQUMsSUFBSSxJQUFJemI7UUFDdEcsSUFBSSxDQUFDdEwsTUFDRDtRQUNKLElBQUksQ0FBQytELE1BQU02TSxLQUFLLElBQUt0RixDQUFBQSxRQUFRLElBQUksQ0FBQ3NELFFBQVEsQ0FBQzdLLE1BQU1nakIsTUFBTSxFQUFFaGpCLE1BQU1nakIsTUFBTSxHQUFHaGpCLE1BQU1vWixJQUFJLEdBQUcsQ0FBQyxJQUFJLEVBQUMsR0FDdkZuZCxPQUFPO1lBQUVDLE1BQU1pQixLQUFLK0MsR0FBRyxDQUFDakUsS0FBS0MsSUFBSSxFQUFFcUwsTUFBTXJMLElBQUk7WUFBR0csS0FBS2MsS0FBSytDLEdBQUcsQ0FBQ2pFLEtBQUtJLEdBQUcsRUFBRWtMLE1BQU1sTCxHQUFHO1lBQzdFRCxPQUFPZSxLQUFLc0YsR0FBRyxDQUFDeEcsS0FBS0csS0FBSyxFQUFFbUwsTUFBTW5MLEtBQUs7WUFBR0UsUUFBUWEsS0FBS3NGLEdBQUcsQ0FBQ3hHLEtBQUtLLE1BQU0sRUFBRWlMLE1BQU1qTCxNQUFNO1FBQUU7UUFDOUYsSUFBSTZwQixVQUFVNUksaUJBQWlCLElBQUksQ0FBQ2xhLElBQUk7UUFDeEMsSUFBSStpQixhQUFhO1lBQ2JscUIsTUFBTUQsS0FBS0MsSUFBSSxHQUFHaXFCLFFBQVFqcUIsSUFBSTtZQUFFRyxLQUFLSixLQUFLSSxHQUFHLEdBQUc4cEIsUUFBUTlwQixHQUFHO1lBQzNERCxPQUFPSCxLQUFLRyxLQUFLLEdBQUcrcEIsUUFBUS9wQixLQUFLO1lBQUVFLFFBQVFMLEtBQUtLLE1BQU0sR0FBRzZwQixRQUFRN3BCLE1BQU07UUFDM0U7UUFDQSxJQUFJLEVBQUVRLFdBQVcsRUFBRUcsWUFBWSxFQUFFLEdBQUcsSUFBSSxDQUFDb0csSUFBSSxDQUFDMmhCLFNBQVM7UUFDdkQzbkIsbUJBQW1CLElBQUksQ0FBQ2dHLElBQUksQ0FBQzJoQixTQUFTLEVBQUVvQixZQUFZcG1CLE1BQU1vWixJQUFJLEdBQUdwWixNQUFNZ2pCLE1BQU0sR0FBRyxDQUFDLElBQUksR0FBR25wQixPQUFPc0MsQ0FBQyxFQUFFdEMsT0FBTzBELENBQUMsRUFBRUosS0FBS3NGLEdBQUcsQ0FBQ3RGLEtBQUsrQyxHQUFHLENBQUNyRyxPQUFPMkQsT0FBTyxFQUFFVixjQUFjLENBQUNBLGNBQWNLLEtBQUtzRixHQUFHLENBQUN0RixLQUFLK0MsR0FBRyxDQUFDckcsT0FBTzRELE9BQU8sRUFBRVIsZUFBZSxDQUFDQSxlQUFlLElBQUksQ0FBQ29HLElBQUksQ0FBQzZoQixhQUFhLElBQUkvUCxVQUFVQyxHQUFHO0lBQ3hSO0FBQ0o7QUFDQSxTQUFTOE4sa0JBQWtCNWYsR0FBRztJQUMxQixPQUFPQSxJQUFJcEosSUFBSSxDQUFDSixRQUFRLElBQUksS0FBS3dKLElBQUlwSixJQUFJLENBQUM4SixVQUFVLElBQy9DVixDQUFBQSxJQUFJaEIsTUFBTSxJQUFJLEtBQUtnQixJQUFJcEosSUFBSSxDQUFDNEIsVUFBVSxDQUFDd0gsSUFBSWhCLE1BQU0sR0FBRyxFQUFFLENBQUN2RyxlQUFlLElBQUksT0FBTSxLQUNoRnVILENBQUFBLElBQUloQixNQUFNLElBQUlnQixJQUFJcEosSUFBSSxDQUFDNEIsVUFBVSxDQUFDZCxNQUFNLElBQUlzSSxJQUFJcEosSUFBSSxDQUFDNEIsVUFBVSxDQUFDd0gsSUFBSWhCLE1BQU0sQ0FBQyxDQUFDdkcsZUFBZSxJQUFJLE9BQU07QUFDOUc7QUFDQSxNQUFNZ21CLHVCQUF1QmxSO0lBQ3pCcFIsWUFBWXpDLE1BQU0sQ0FBRTtRQUNoQixLQUFLO1FBQ0wsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0lBQ2xCO0lBQ0F5UCxRQUFRO1FBQ0osSUFBSW5TLE1BQU15RyxTQUFTMEssYUFBYSxDQUFDO1FBQ2pDblIsSUFBSThRLFNBQVMsR0FBRztRQUNoQixJQUFJLENBQUNvQixTQUFTLENBQUNsUztRQUNmLE9BQU9BO0lBQ1g7SUFDQXVGLEdBQUcwSCxLQUFLLEVBQUU7UUFBRSxPQUFPQSxNQUFNdkssTUFBTSxJQUFJLElBQUksQ0FBQ0EsTUFBTTtJQUFFO0lBQ2hEd1AsVUFBVWxTLEdBQUcsRUFBRTtRQUNYQSxJQUFJc08sS0FBSyxDQUFDNUwsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxHQUFHO1FBQ2pDLE9BQU87SUFDWDtJQUNBLElBQUkwUCxXQUFXO1FBQUUsT0FBTztJQUFNO0lBQzlCLElBQUlvRSxrQkFBa0I7UUFBRSxPQUFPLElBQUksQ0FBQzlULE1BQU07SUFBRTtJQUM1Q29KLGNBQWM7UUFBRSxPQUFPO0lBQU87QUFDbEM7QUFDQSxTQUFTaWdCLG9CQUFvQmhqQixJQUFJLEVBQUVpakIsT0FBTztJQUN0QyxJQUFJdEMsTUFBTTNnQixLQUFLa2UsUUFBUSxDQUFDRyxjQUFjO0lBQ3RDLElBQUk2RSxXQUFXdkMsSUFBSXJrQixTQUFTLElBQUkrakIsZUFBZU0sSUFBSXJrQixTQUFTLEVBQUVxa0IsSUFBSXBrQixXQUFXLEVBQUU7SUFDL0UsSUFBSSxDQUFDMm1CLFVBQ0QsT0FBTztJQUNYLElBQUkxbEIsT0FBT3lsQixVQUFVQyxTQUFTamtCLE1BQU07SUFDcEMsT0FBTztRQUFFekI7UUFBTUMsSUFBSUQsT0FBTzBsQixTQUFTcnNCLElBQUksQ0FBQ2EsU0FBUyxDQUFDQyxNQUFNO1FBQUVkLE1BQU1xc0IsU0FBU3JzQixJQUFJO0lBQUM7QUFDbEY7QUFDQSxTQUFTNG1CLHFCQUFxQnpkLElBQUksRUFBRXNYLE9BQU8sRUFBRTJMLE9BQU87SUFDaEQsSUFBSUUsUUFBUUgsb0JBQW9CaGpCLE1BQU1pakI7SUFDdEMsSUFBSSxDQUFDRSxPQUNELE9BQU87SUFDWCxJQUFJLEVBQUV0c0IsTUFBTXFzQixRQUFRLEVBQUUxbEIsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBRzBsQixPQUFPM2YsT0FBTzBmLFNBQVN4ckIsU0FBUztJQUNuRSxnREFBZ0Q7SUFDaEQsSUFBSSxTQUFTa0QsSUFBSSxDQUFDNEksT0FDZCxPQUFPO0lBQ1gsSUFBSXhELEtBQUt5SixLQUFLLENBQUN6UyxHQUFHLENBQUNvc0IsV0FBVyxDQUFDRCxNQUFNM2xCLElBQUksRUFBRTJsQixNQUFNMWxCLEVBQUUsS0FBSytGLE1BQ3BELE9BQU87SUFDWCxJQUFJNmYsTUFBTS9MLFFBQVFnTSxZQUFZO0lBQzlCLElBQUkzbUIsUUFBUSxJQUFJMGQsYUFBYWdKLElBQUlwRyxNQUFNLENBQUN6ZixPQUFPNmxCLElBQUlwRyxNQUFNLENBQUN4ZixLQUFLRCxNQUFNQztJQUNyRSxJQUFJdWhCLFFBQVEsRUFBRTtJQUNkLElBQUssSUFBSXhtQixTQUFTMHFCLFNBQVNwc0IsVUFBVSxHQUFHMEIsU0FBU0EsT0FBTzFCLFVBQVUsQ0FBRTtRQUNoRSxJQUFJeXNCLGFBQWE3akIsWUFBWW1CLEdBQUcsQ0FBQ3JJO1FBQ2pDLElBQUkrcUIsc0JBQXNCN2IsVUFDdEJzWCxNQUFNN2hCLElBQUksQ0FBQztZQUFFdEcsTUFBTTJCO1lBQVFxVCxNQUFNMFgsV0FBVzViLElBQUk7UUFBQzthQUNoRCxJQUFJNGIsc0JBQXNCbFksWUFBWTdTLE9BQU9ELFFBQVEsSUFBSSxTQUFTQyxPQUFPMUIsVUFBVSxJQUFJa0osS0FBSzZjLFVBQVUsRUFDdkcsT0FBTztZQUFFbGdCO1lBQU82RyxNQUFNMGY7WUFBVWxFO1lBQU83USxNQUFNM1Y7UUFBTzthQUNuRCxJQUFJQSxVQUFVd0gsS0FBSzZjLFVBQVUsRUFDOUJtQyxNQUFNN2hCLElBQUksQ0FBQztZQUFFdEcsTUFBTTJCO1lBQVFxVCxNQUFNLElBQUlpQyxlQUFlO2dCQUM1Q3lCLFdBQVc7Z0JBQ1h6USxZQUFZb00sU0FBUzFTO2dCQUNyQjBQLFNBQVMxUCxPQUFPMFAsT0FBTyxDQUFDMkosV0FBVztZQUN2QztRQUFHO2FBRVAsT0FBTztJQUNmO0FBQ0o7QUFDQSxTQUFTd08sZUFBZW1ELFNBQVMsRUFBRUMsV0FBVyxFQUFFeHBCLElBQUk7SUFDaEQsSUFBSUEsUUFBUSxHQUNSLElBQUssSUFBSXBELE9BQU8yc0IsV0FBV3ZrQixTQUFTd2tCLGNBQWU7UUFDL0MsSUFBSTVzQixLQUFLSixRQUFRLElBQUksR0FDakIsT0FBTztZQUFFSSxNQUFNQTtZQUFNb0ksUUFBUUE7UUFBTztRQUN4QyxJQUFJcEksS0FBS0osUUFBUSxJQUFJLEtBQUt3SSxTQUFTLEdBQUc7WUFDbENwSSxPQUFPQSxLQUFLNEIsVUFBVSxDQUFDd0csU0FBUyxFQUFFO1lBQ2xDQSxTQUFTM0csVUFBVXpCO1FBQ3ZCLE9BQ0s7WUFDRDtRQUNKO0lBQ0o7SUFDSixJQUFJb0QsUUFBUSxHQUNSLElBQUssSUFBSXBELE9BQU8yc0IsV0FBV3ZrQixTQUFTd2tCLGNBQWU7UUFDL0MsSUFBSTVzQixLQUFLSixRQUFRLElBQUksR0FDakIsT0FBTztZQUFFSSxNQUFNQTtZQUFNb0ksUUFBUUE7UUFBTztRQUN4QyxJQUFJcEksS0FBS0osUUFBUSxJQUFJLEtBQUt3SSxTQUFTcEksS0FBSzRCLFVBQVUsQ0FBQ2QsTUFBTSxJQUFJc0MsUUFBUSxHQUFHO1lBQ3BFcEQsT0FBT0EsS0FBSzRCLFVBQVUsQ0FBQ3dHLE9BQU87WUFDOUJBLFNBQVM7UUFDYixPQUNLO1lBQ0Q7UUFDSjtJQUNKO0lBQ0osT0FBTztBQUNYO0FBQ0EsU0FBU21oQixpQkFBaUJ2cEIsSUFBSSxFQUFFb0ksTUFBTTtJQUNsQyxJQUFJcEksS0FBS0osUUFBUSxJQUFJLEdBQ2pCLE9BQU87SUFDWCxPQUFPLENBQUN3SSxVQUFVcEksS0FBSzRCLFVBQVUsQ0FBQ3dHLFNBQVMsRUFBRSxDQUFDdkcsZUFBZSxJQUFJLFVBQVUsRUFBRSxpQkFBaUIsTUFBSyxLQUM5RnVHLENBQUFBLFNBQVNwSSxLQUFLNEIsVUFBVSxDQUFDZCxNQUFNLElBQUlkLEtBQUs0QixVQUFVLENBQUN3RyxPQUFPLENBQUN2RyxlQUFlLElBQUksVUFBVSxFQUFFLGdCQUFnQixNQUFLO0FBQ3hIO0FBQ0EsSUFBSWdyQix5QkFBeUIsTUFBTUM7SUFDL0J2bkIsYUFBYztRQUNWLElBQUksQ0FBQ2tiLE9BQU8sR0FBRyxFQUFFO0lBQ3JCO0lBQ0FzTSxhQUFhcG1CLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQUUrUixTQUFTaFMsTUFBTUMsSUFBSSxJQUFJLENBQUM2WixPQUFPO0lBQUc7SUFDM0R1TSxhQUFhcm1CLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQUUrUixTQUFTaFMsTUFBTUMsSUFBSSxJQUFJLENBQUM2WixPQUFPO0lBQUc7QUFDL0Q7QUFDQSxTQUFTd0csZ0JBQWdCdFQsQ0FBQyxFQUFFQyxDQUFDLEVBQUVvUSxJQUFJO0lBQy9CLElBQUlpSixPQUFPLElBQUlKO0lBQ2Y1dUIsdURBQVFBLENBQUN3VSxPQUFPLENBQUNrQixHQUFHQyxHQUFHb1EsTUFBTWlKO0lBQzdCLE9BQU9BLEtBQUt4TSxPQUFPO0FBQ3ZCO0FBQ0EsU0FBUzBJLGFBQWFucEIsSUFBSSxFQUFFa3RCLE1BQU07SUFDOUIsSUFBSyxJQUFJdnBCLE1BQU0zRCxNQUFNMkQsT0FBT0EsT0FBT3VwQixRQUFRdnBCLE1BQU1BLElBQUlXLFlBQVksSUFBSVgsSUFBSTFELFVBQVUsQ0FBRTtRQUNqRixJQUFJMEQsSUFBSS9ELFFBQVEsSUFBSSxLQUFLK0QsSUFBSTlCLGVBQWUsSUFBSSxTQUFTO1lBQ3JELE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBUzRrQixtQkFBbUJoRyxPQUFPLEVBQUVrRyxXQUFXO0lBQzVDLElBQUl3RyxVQUFVO0lBQ2QsSUFBSXhHLGFBQ0FsRyxRQUFRa0UsaUJBQWlCLENBQUMsQ0FBQ2hlLE1BQU1DO1FBQzdCLElBQUlELE9BQU9nZ0IsWUFBWS9mLEVBQUUsSUFBSUEsS0FBSytmLFlBQVloZ0IsSUFBSSxFQUM5Q3dtQixVQUFVO0lBQ2xCO0lBQ0osT0FBT0E7QUFDWDtBQUVBLFNBQVNDLFFBQVF4YSxLQUFLLEVBQUV4SixHQUFHLEVBQUVvQixPQUFPLENBQUM7SUFDakMsSUFBSTZpQixhQUFhemEsTUFBTTBhLGVBQWUsQ0FBQ2xrQjtJQUN2QyxJQUFJa08sT0FBTzFFLE1BQU16UyxHQUFHLENBQUN1WixNQUFNLENBQUN0USxNQUFNbWtCLFVBQVVua0IsTUFBTWtPLEtBQUszUSxJQUFJO0lBQzNELElBQUkyUSxLQUFLeFcsTUFBTSxJQUFJLEdBQ2YsT0FBT3pDLDhEQUFlQSxDQUFDaWIsTUFBTSxDQUFDbFE7SUFDbEMsSUFBSW1rQixXQUFXLEdBQ1gvaUIsT0FBTztTQUNOLElBQUkraUIsV0FBV2pXLEtBQUt4VyxNQUFNLEVBQzNCMEosT0FBTyxDQUFDO0lBQ1osSUFBSTdELE9BQU80bUIsU0FBUzNtQixLQUFLMm1CO0lBQ3pCLElBQUkvaUIsT0FBTyxHQUNQN0QsT0FBT3ZJLG1FQUFnQkEsQ0FBQ2taLEtBQUszSyxJQUFJLEVBQUU0Z0IsU0FBUztTQUU1QzNtQixLQUFLeEksbUVBQWdCQSxDQUFDa1osS0FBSzNLLElBQUksRUFBRTRnQjtJQUNyQyxJQUFJQyxNQUFNSCxXQUFXL1YsS0FBSzNLLElBQUksQ0FBQzJELEtBQUssQ0FBQzNKLE1BQU1DO0lBQzNDLE1BQU9ELE9BQU8sRUFBRztRQUNiLElBQUkwQixPQUFPakssbUVBQWdCQSxDQUFDa1osS0FBSzNLLElBQUksRUFBRWhHLE1BQU07UUFDN0MsSUFBSTBtQixXQUFXL1YsS0FBSzNLLElBQUksQ0FBQzJELEtBQUssQ0FBQ2pJLE1BQU0xQixVQUFVNm1CLEtBQzNDO1FBQ0o3bUIsT0FBTzBCO0lBQ1g7SUFDQSxNQUFPekIsS0FBSzBRLEtBQUt4VyxNQUFNLENBQUU7UUFDckIsSUFBSThJLE9BQU94TCxtRUFBZ0JBLENBQUNrWixLQUFLM0ssSUFBSSxFQUFFL0Y7UUFDdkMsSUFBSXltQixXQUFXL1YsS0FBSzNLLElBQUksQ0FBQzJELEtBQUssQ0FBQzFKLElBQUlnRCxVQUFVNGpCLEtBQ3pDO1FBQ0o1bUIsS0FBS2dEO0lBQ1Q7SUFDQSxPQUFPdkwsOERBQWVBLENBQUN5SCxLQUFLLENBQUNhLE9BQU8yUSxLQUFLM1EsSUFBSSxFQUFFQyxLQUFLMFEsS0FBSzNRLElBQUk7QUFDakU7QUFDQSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLHFEQUFxRDtBQUNyRCxTQUFTOG1CLE1BQU14ckIsQ0FBQyxFQUFFRixJQUFJO0lBQ2xCLE9BQU9BLEtBQUtDLElBQUksR0FBR0MsSUFBSUYsS0FBS0MsSUFBSSxHQUFHQyxJQUFJZ0IsS0FBS3NGLEdBQUcsQ0FBQyxHQUFHdEcsSUFBSUYsS0FBS0csS0FBSztBQUNyRTtBQUNBLFNBQVN3ckIsTUFBTXJxQixDQUFDLEVBQUV0QixJQUFJO0lBQ2xCLE9BQU9BLEtBQUtJLEdBQUcsR0FBR2tCLElBQUl0QixLQUFLSSxHQUFHLEdBQUdrQixJQUFJSixLQUFLc0YsR0FBRyxDQUFDLEdBQUdsRixJQUFJdEIsS0FBS0ssTUFBTTtBQUNwRTtBQUNBLFNBQVN1ckIsU0FBU2hhLENBQUMsRUFBRUMsQ0FBQztJQUNsQixPQUFPRCxFQUFFeFIsR0FBRyxHQUFHeVIsRUFBRXhSLE1BQU0sR0FBRyxLQUFLdVIsRUFBRXZSLE1BQU0sR0FBR3dSLEVBQUV6UixHQUFHLEdBQUc7QUFDdEQ7QUFDQSxTQUFTeXJCLE1BQU03ckIsSUFBSSxFQUFFSSxHQUFHO0lBQ3BCLE9BQU9BLE1BQU1KLEtBQUtJLEdBQUcsR0FBRztRQUFFQTtRQUFLSCxNQUFNRCxLQUFLQyxJQUFJO1FBQUVFLE9BQU9ILEtBQUtHLEtBQUs7UUFBRUUsUUFBUUwsS0FBS0ssTUFBTTtJQUFDLElBQUlMO0FBQy9GO0FBQ0EsU0FBUzhyQixNQUFNOXJCLElBQUksRUFBRUssTUFBTTtJQUN2QixPQUFPQSxTQUFTTCxLQUFLSyxNQUFNLEdBQUc7UUFBRUQsS0FBS0osS0FBS0ksR0FBRztRQUFFSCxNQUFNRCxLQUFLQyxJQUFJO1FBQUVFLE9BQU9ILEtBQUtHLEtBQUs7UUFBRUU7SUFBTyxJQUFJTDtBQUNsRztBQUNBLFNBQVMrckIsZUFBZW5zQixNQUFNLEVBQUVNLENBQUMsRUFBRW9CLENBQUM7SUFDaEMsSUFBSTBxQixTQUFTQyxhQUFhQyxVQUFVQyxVQUFVQyxpQkFBaUI7SUFDL0QsSUFBSUMsT0FBT0MsT0FBT0MsV0FBV0M7SUFDN0IsSUFBSyxJQUFJbGxCLFFBQVExSCxPQUFPbUksVUFBVSxFQUFFVCxPQUFPQSxRQUFRQSxNQUFNUSxXQUFXLENBQUU7UUFDbEUsSUFBSWdJLFFBQVFsUixlQUFlMEk7UUFDM0IsSUFBSyxJQUFJNUMsSUFBSSxHQUFHQSxJQUFJb0wsTUFBTS9RLE1BQU0sRUFBRTJGLElBQUs7WUFDbkMsSUFBSTFFLE9BQU84UCxLQUFLLENBQUNwTCxFQUFFO1lBQ25CLElBQUl1bkIsZUFBZUwsU0FBU0ssYUFBYWpzQixPQUNyQ0EsT0FBTzZyQixNQUFNQyxNQUFNOXJCLE1BQU1pc0IsWUFBWTVyQixNQUFNLEdBQUc0ckIsWUFBWTdyQixHQUFHO1lBQ2pFLElBQUlxc0IsS0FBS2YsTUFBTXhyQixHQUFHRixPQUFPMHNCLEtBQUtmLE1BQU1ycUIsR0FBR3RCO1lBQ3ZDLElBQUl5c0IsTUFBTSxLQUFLQyxNQUFNLEdBQ2pCLE9BQU9wbEIsTUFBTXpKLFFBQVEsSUFBSSxJQUFJOHVCLGFBQWFybEIsT0FBT3BILEdBQUdvQixLQUFLeXFCLGVBQWV6a0IsT0FBT3BILEdBQUdvQjtZQUN0RixJQUFJLENBQUMwcUIsV0FBV0csV0FBV08sTUFBTVAsWUFBWU8sTUFBTVIsV0FBV08sSUFBSTtnQkFDOURULFVBQVUxa0I7Z0JBQ1Yya0IsY0FBY2pzQjtnQkFDZGtzQixXQUFXTztnQkFDWE4sV0FBV087Z0JBQ1gsSUFBSXJyQixPQUFPcXJCLEtBQU1wckIsSUFBSXRCLEtBQUtJLEdBQUcsR0FBRyxDQUFDLElBQUksSUFBS3FzQixLQUFNdnNCLElBQUlGLEtBQUtDLElBQUksR0FBRyxDQUFDLElBQUksSUFBSztnQkFDMUVtc0IsaUJBQWlCLENBQUMvcUIsUUFBU0EsQ0FBQUEsT0FBTyxJQUFJcUQsSUFBSW9MLE1BQU0vUSxNQUFNLEdBQUcsSUFBSTJGLElBQUk7WUFDckU7WUFDQSxJQUFJK25CLE1BQU0sR0FBRztnQkFDVCxJQUFJbnJCLElBQUl0QixLQUFLSyxNQUFNLElBQUssRUFBQ2tzQixhQUFhQSxVQUFVbHNCLE1BQU0sR0FBR0wsS0FBS0ssTUFBTSxHQUFHO29CQUNuRWdzQixRQUFRL2tCO29CQUNSaWxCLFlBQVl2c0I7Z0JBQ2hCLE9BQ0ssSUFBSXNCLElBQUl0QixLQUFLSSxHQUFHLElBQUssRUFBQ29zQixhQUFhQSxVQUFVcHNCLEdBQUcsR0FBR0osS0FBS0ksR0FBRyxHQUFHO29CQUMvRGtzQixRQUFRaGxCO29CQUNSa2xCLFlBQVl4c0I7Z0JBQ2hCO1lBQ0osT0FDSyxJQUFJdXNCLGFBQWFYLFNBQVNXLFdBQVd2c0IsT0FBTztnQkFDN0N1c0IsWUFBWVQsTUFBTVMsV0FBV3ZzQixLQUFLSyxNQUFNO1lBQzVDLE9BQ0ssSUFBSW1zQixhQUFhWixTQUFTWSxXQUFXeHNCLE9BQU87Z0JBQzdDd3NCLFlBQVlYLE1BQU1XLFdBQVd4c0IsS0FBS0ksR0FBRztZQUN6QztRQUNKO0lBQ0o7SUFDQSxJQUFJbXNCLGFBQWFBLFVBQVVsc0IsTUFBTSxJQUFJaUIsR0FBRztRQUNwQzBxQixVQUFVSztRQUNWSixjQUFjTTtJQUNsQixPQUNLLElBQUlDLGFBQWFBLFVBQVVwc0IsR0FBRyxJQUFJa0IsR0FBRztRQUN0QzBxQixVQUFVTTtRQUNWTCxjQUFjTztJQUNsQjtJQUNBLElBQUksQ0FBQ1IsU0FDRCxPQUFPO1FBQUUvdEIsTUFBTTJCO1FBQVF5RyxRQUFRO0lBQUU7SUFDckMsSUFBSXVtQixRQUFRMXJCLEtBQUtzRixHQUFHLENBQUN5bEIsWUFBWWhzQixJQUFJLEVBQUVpQixLQUFLK0MsR0FBRyxDQUFDZ29CLFlBQVk5ckIsS0FBSyxFQUFFRDtJQUNuRSxJQUFJOHJCLFFBQVFudUIsUUFBUSxJQUFJLEdBQ3BCLE9BQU84dUIsYUFBYVgsU0FBU1ksT0FBT3RyQjtJQUN4QyxJQUFJOHFCLGtCQUFrQkosUUFBUWxzQixlQUFlLElBQUksU0FDN0MsT0FBT2lzQixlQUFlQyxTQUFTWSxPQUFPdHJCO0lBQzFDLElBQUkrRSxTQUFTMEosTUFBTXZFLFNBQVMsQ0FBQzFCLE9BQU8sQ0FBQ21HLElBQUksQ0FBQ3JRLE9BQU9DLFVBQVUsRUFBRW1zQixXQUN4RDlyQixDQUFBQSxLQUFLLENBQUMrckIsWUFBWWhzQixJQUFJLEdBQUdnc0IsWUFBWTlyQixLQUFLLElBQUksSUFBSSxJQUFJO0lBQzNELE9BQU87UUFBRWxDLE1BQU0yQjtRQUFReUc7SUFBTztBQUNsQztBQUNBLFNBQVNzbUIsYUFBYTF1QixJQUFJLEVBQUVpQyxDQUFDLEVBQUVvQixDQUFDO0lBQzVCLElBQUltVCxNQUFNeFcsS0FBS2EsU0FBUyxDQUFDQyxNQUFNO0lBQy9CLElBQUk4dEIsZ0JBQWdCLENBQUMsR0FBR0MsWUFBWSxLQUFLQyxjQUFjO0lBQ3ZELElBQUssSUFBSXJvQixJQUFJLEdBQUdBLElBQUkrUCxLQUFLL1AsSUFBSztRQUMxQixJQUFJb0wsUUFBUWpSLFVBQVVaLE1BQU15RyxHQUFHQSxJQUFJLEdBQUcxRixjQUFjO1FBQ3BELElBQUssSUFBSWlTLElBQUksR0FBR0EsSUFBSW5CLE1BQU0vUSxNQUFNLEVBQUVrUyxJQUFLO1lBQ25DLElBQUlqUixPQUFPOFAsS0FBSyxDQUFDbUIsRUFBRTtZQUNuQixJQUFJalIsS0FBS0ksR0FBRyxJQUFJSixLQUFLSyxNQUFNLEVBQ3ZCO1lBQ0osSUFBSSxDQUFDMHNCLGFBQ0RBLGNBQWM3c0IsSUFBSUYsS0FBS0MsSUFBSTtZQUMvQixJQUFJeXNCLEtBQUssQ0FBQzFzQixLQUFLSSxHQUFHLEdBQUdrQixJQUFJdEIsS0FBS0ksR0FBRyxHQUFHa0IsSUFBSUEsSUFBSXRCLEtBQUtLLE1BQU0sSUFBSTtZQUMzRCxJQUFJTCxLQUFLQyxJQUFJLEdBQUcsS0FBS0MsS0FBS0YsS0FBS0csS0FBSyxHQUFHLEtBQUtELEtBQUt3c0IsS0FBS0ksV0FBVztnQkFDN0QsSUFBSTNzQixRQUFRRCxLQUFLLENBQUNGLEtBQUtDLElBQUksR0FBR0QsS0FBS0csS0FBSyxJQUFJLEdBQUd5RyxRQUFRekc7Z0JBQ3ZELElBQUlvTixRQUFRTCxNQUFNLElBQUlLLFFBQVFOLEtBQUssRUFBRTtvQkFDakMsd0RBQXdEO29CQUN4RCwwQkFBMEI7b0JBQzFCLElBQUkrZixhQUFhbnVCLFVBQVVaLE1BQU15RyxHQUFHbEMscUJBQXFCO29CQUN6RCxJQUFJd3FCLFdBQVcvc0IsSUFBSSxJQUFJRCxLQUFLRyxLQUFLLEVBQzdCeUcsUUFBUSxDQUFDekc7Z0JBQ2pCO2dCQUNBLElBQUl1c0IsTUFBTSxHQUNOLE9BQU87b0JBQUV6dUI7b0JBQU1vSSxRQUFRM0IsSUFBS2tDLENBQUFBLFFBQVEsSUFBSTtnQkFBRztnQkFDL0NpbUIsZ0JBQWdCbm9CLElBQUtrQyxDQUFBQSxRQUFRLElBQUk7Z0JBQ2pDa21CLFlBQVlKO1lBQ2hCO1FBQ0o7SUFDSjtJQUNBLE9BQU87UUFBRXp1QjtRQUFNb0ksUUFBUXdtQixnQkFBZ0IsQ0FBQyxJQUFJQSxnQkFBZ0JFLGNBQWMsSUFBSTl1QixLQUFLYSxTQUFTLENBQUNDLE1BQU0sR0FBRztJQUFFO0FBQzVHO0FBQ0EsU0FBU2t1QixZQUFZN2xCLElBQUksRUFBRThsQixNQUFNLEVBQUV4bUIsT0FBTyxFQUFFK0IsT0FBTyxDQUFDLENBQUM7SUFDakQsSUFBSTJLLElBQUl5QztJQUNSLElBQUlvQixVQUFVN1AsS0FBSzZjLFVBQVUsQ0FBQ3poQixxQkFBcUIsSUFBSTJxQixTQUFTbFcsUUFBUTdXLEdBQUcsR0FBR2dILEtBQUs2TSxTQUFTLENBQUNtWixVQUFVO0lBQ3ZHLElBQUk5WSxPQUFPLEVBQUUrWSxTQUFTLEVBQUUsR0FBR2ptQixLQUFLNk0sU0FBUztJQUN6QyxJQUFJLEVBQUUvVCxDQUFDLEVBQUVvQixDQUFDLEVBQUUsR0FBRzRyQixRQUFRSSxVQUFVaHNCLElBQUk2ckI7SUFDckMsSUFBSUcsVUFBVSxHQUNWLE9BQU87SUFDWCxJQUFJQSxVQUFVRCxXQUNWLE9BQU9qbUIsS0FBS3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ1csTUFBTTtJQUNoQyxvREFBb0Q7SUFDcEQsSUFBSyxJQUFJd3VCLFdBQVdubUIsS0FBSzZNLFNBQVMsQ0FBQ0QsWUFBWSxDQUFDSCxVQUFVLEdBQUcsR0FBRzJaLFVBQVUsUUFBUztRQUMvRWxaLFFBQVFsTixLQUFLcW1CLGVBQWUsQ0FBQ0g7UUFDN0IsSUFBSWhaLE1BQU04QixJQUFJLElBQUlyQixVQUFVOVksSUFBSSxFQUM1QjtRQUNKLE9BQVM7WUFDTCx3Q0FBd0M7WUFDeENxeEIsVUFBVTdrQixPQUFPLElBQUk2TCxNQUFNalUsTUFBTSxHQUFHa3RCLFdBQVdqWixNQUFNbFUsR0FBRyxHQUFHbXRCO1lBQzNELElBQUlELFdBQVcsS0FBS0EsV0FBV0QsV0FDM0I7WUFDSiw0REFBNEQ7WUFDNUQsdUNBQXVDO1lBQ3ZDLElBQUlHLFNBQ0EsT0FBTzltQixVQUFVLE9BQU87WUFDNUI4bUIsVUFBVTtZQUNWL2tCLE9BQU8sQ0FBQ0E7UUFDWjtJQUNKO0lBQ0FuSCxJQUFJNnJCLFNBQVNHO0lBQ2IsSUFBSW5GLFlBQVk3VCxNQUFNMVAsSUFBSTtJQUMxQiw2RUFBNkU7SUFDN0UsSUFBSXVqQixZQUFZL2dCLEtBQUt5ZSxRQUFRLENBQUNqaEIsSUFBSSxFQUM5QixPQUFPd0MsS0FBS3llLFFBQVEsQ0FBQ2poQixJQUFJLElBQUksSUFBSSxJQUFJOEIsVUFBVSxPQUFPZ25CLHFCQUFxQnRtQixNQUFNNlAsU0FBUzNDLE9BQU9wVSxHQUFHb0I7SUFDeEcsSUFBSTZtQixZQUFZL2dCLEtBQUt5ZSxRQUFRLENBQUNoaEIsRUFBRSxFQUM1QixPQUFPdUMsS0FBS3llLFFBQVEsQ0FBQ2hoQixFQUFFLElBQUl1QyxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDVyxNQUFNLEdBQUdxSSxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDVyxNQUFNLEdBQ3BFMkgsVUFBVSxPQUFPZ25CLHFCQUFxQnRtQixNQUFNNlAsU0FBUzNDLE9BQU9wVSxHQUFHb0I7SUFDdkUsd0ZBQXdGO0lBQ3hGLElBQUlsRCxNQUFNZ0osS0FBS3BKLEdBQUcsQ0FBQ0YsYUFBYTtJQUNoQyxJQUFJSCxPQUFPeUosS0FBS3pKLElBQUksQ0FBQ2d3QixnQkFBZ0IsR0FBR3ZtQixLQUFLekosSUFBSSxHQUFHUztJQUNwRCxJQUFJd3ZCLFVBQVVqd0IsS0FBS2d3QixnQkFBZ0IsQ0FBQ3p0QixHQUFHb0I7SUFDdkMsSUFBSXNzQixXQUFXLENBQUN4bUIsS0FBSzZjLFVBQVUsQ0FBQ2xtQixRQUFRLENBQUM2dkIsVUFDckNBLFVBQVU7SUFDZCxzRkFBc0Y7SUFDdEYsSUFBSSxDQUFDQSxTQUFTO1FBQ1YxdEIsSUFBSWdCLEtBQUtzRixHQUFHLENBQUN5USxRQUFRaFgsSUFBSSxHQUFHLEdBQUdpQixLQUFLK0MsR0FBRyxDQUFDZ1QsUUFBUTlXLEtBQUssR0FBRyxHQUFHRDtRQUMzRDB0QixVQUFVandCLEtBQUtnd0IsZ0JBQWdCLENBQUN6dEIsR0FBR29CO1FBQ25DLElBQUlzc0IsV0FBVyxDQUFDeG1CLEtBQUs2YyxVQUFVLENBQUNsbUIsUUFBUSxDQUFDNnZCLFVBQ3JDQSxVQUFVO0lBQ2xCO0lBQ0EsZ0VBQWdFO0lBQ2hFLHFEQUFxRDtJQUNyRCxJQUFJM3ZCLE1BQU1vSSxTQUFTLENBQUM7SUFDcEIsSUFBSXVuQixXQUFXLENBQUMsQ0FBQ3hhLEtBQUtoTSxLQUFLaU4sT0FBTyxDQUFDaVUsT0FBTyxDQUFDc0YsUUFBTyxNQUFPLFFBQVF4YSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd2SSxVQUFVLEtBQUssT0FBTztRQUMvRyxJQUFJek0sSUFBSXl2QixzQkFBc0IsRUFBRTtZQUM1QixJQUFJeG1CLE1BQU1qSixJQUFJeXZCLHNCQUFzQixDQUFDM3RCLEdBQUdvQjtZQUN4QyxJQUFJK0YsS0FDQyxHQUFFeW1CLFlBQVk3dkIsSUFBSSxFQUFFb0ksTUFBTSxFQUFFLEdBQUdnQixHQUFFO1FBQzFDLE9BQ0ssSUFBSWpKLElBQUkydkIsbUJBQW1CLEVBQUU7WUFDOUIsSUFBSWhxQixRQUFRM0YsSUFBSTJ2QixtQkFBbUIsQ0FBQzd0QixHQUFHb0I7WUFDdkMsSUFBSXlDLE9BQU87Z0JBQ04sR0FBRWlxQixnQkFBZ0IvdkIsSUFBSSxFQUFFNHNCLGFBQWF4a0IsTUFBTSxFQUFFLEdBQUd0QyxLQUFJO2dCQUNyRCxJQUFJLENBQUNxRCxLQUFLNmMsVUFBVSxDQUFDbG1CLFFBQVEsQ0FBQ0UsU0FDMUJzUCxRQUFRSCxNQUFNLElBQUk2Z0IsOEJBQThCaHdCLE1BQU1vSSxRQUFRbkcsTUFDOURxTixRQUFRTCxNQUFNLElBQUlnaEIsOEJBQThCandCLE1BQU1vSSxRQUFRbkcsSUFDOURqQyxPQUFPd0c7WUFDZjtRQUNKO0lBQ0o7SUFDQSxxREFBcUQ7SUFDckQsSUFBSSxDQUFDeEcsUUFBUSxDQUFDbUosS0FBS2lOLE9BQU8sQ0FBQ3JXLEdBQUcsQ0FBQ0QsUUFBUSxDQUFDRSxPQUFPO1FBQzNDLElBQUlzWCxPQUFPOUMsU0FBU3pDLElBQUksQ0FBQzVJLEtBQUtpTixPQUFPLEVBQUU4VDtRQUN2QyxJQUFJLENBQUM1UyxNQUNELE9BQU8rWCxVQUFVaFosTUFBTWxVLEdBQUcsR0FBR2tVLE1BQU12VCxNQUFNLEdBQUcsSUFBSXVULE1BQU16UCxFQUFFLEdBQUd5UCxNQUFNMVAsSUFBSTtRQUN4RSxHQUFFM0csSUFBSSxFQUFFb0ksTUFBTSxFQUFFLEdBQUcwbEIsZUFBZXhXLEtBQUt2WCxHQUFHLEVBQUVrQyxHQUFHb0IsRUFBQztJQUNyRDtJQUNBLElBQUlnbkIsVUFBVWxoQixLQUFLaU4sT0FBTyxDQUFDaVUsT0FBTyxDQUFDcnFCO0lBQ25DLElBQUksQ0FBQ3FxQixTQUNELE9BQU87SUFDWCxJQUFJQSxRQUFReGQsUUFBUSxJQUFJLENBQUMsQ0FBQytLLEtBQUt5UyxRQUFRdHFCLEdBQUcsTUFBTSxRQUFRNlgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaFksUUFBUSxLQUFLLEdBQUc7UUFDaEcsSUFBSW1DLE9BQU9zb0IsUUFBUXRxQixHQUFHLENBQUN3RSxxQkFBcUI7UUFDNUMsT0FBTzBxQixPQUFPNXJCLENBQUMsR0FBR3RCLEtBQUtJLEdBQUcsSUFBSThzQixPQUFPNXJCLENBQUMsSUFBSXRCLEtBQUtLLE1BQU0sSUFBSTZzQixPQUFPaHRCLENBQUMsSUFBSSxDQUFDRixLQUFLQyxJQUFJLEdBQUdELEtBQUtHLEtBQUssSUFBSSxJQUMxRm1vQixRQUFRcmhCLFVBQVUsR0FBR3FoQixRQUFRbmhCLFFBQVE7SUFDL0MsT0FDSztRQUNELE9BQU9taEIsUUFBUTlmLGVBQWUsQ0FBQ3ZLLE1BQU1vSSxVQUFVaWlCLFFBQVFyaEIsVUFBVTtJQUNyRTtBQUNKO0FBQ0EsU0FBU3ltQixxQkFBcUJ0bUIsSUFBSSxFQUFFK21CLFdBQVcsRUFBRTdaLEtBQUssRUFBRXBVLENBQUMsRUFBRW9CLENBQUM7SUFDeEQsSUFBSThzQixPQUFPbHRCLEtBQUttdEIsS0FBSyxDQUFDLENBQUNudUIsSUFBSWl1QixZQUFZbHVCLElBQUksSUFBSW1ILEtBQUtrbkIscUJBQXFCO0lBQ3pFLElBQUlsbkIsS0FBS21uQixZQUFZLElBQUlqYSxNQUFNdlQsTUFBTSxHQUFHcUcsS0FBS29uQixpQkFBaUIsR0FBRyxLQUFLO1FBQ2xFLElBQUkzYSxhQUFhek0sS0FBSzZNLFNBQVMsQ0FBQ0QsWUFBWSxDQUFDSCxVQUFVO1FBQ3ZELElBQUkwQixPQUFPclUsS0FBS3V0QixLQUFLLENBQUMsQ0FBQ250QixJQUFJZ1QsTUFBTWxVLEdBQUcsR0FBRyxDQUFDZ0gsS0FBS29uQixpQkFBaUIsR0FBRzNhLFVBQVMsSUFBSyxHQUFFLElBQUtBO1FBQ3RGdWEsUUFBUTdZLE9BQU9uTyxLQUFLNk0sU0FBUyxDQUFDRCxZQUFZLENBQUMwYSxVQUFVO0lBQ3pEO0lBQ0EsSUFBSXpYLFVBQVU3UCxLQUFLeUosS0FBSyxDQUFDOGQsUUFBUSxDQUFDcmEsTUFBTTFQLElBQUksRUFBRTBQLE1BQU16UCxFQUFFO0lBQ3RELE9BQU95UCxNQUFNMVAsSUFBSSxHQUFHbEksNkRBQVVBLENBQUN1YSxTQUFTbVgsTUFBTWhuQixLQUFLeUosS0FBSyxDQUFDNUMsT0FBTztBQUNwRTtBQUNBLHFFQUFxRTtBQUNyRSxvRUFBb0U7QUFDcEUsc0VBQXNFO0FBQ3RFLHdCQUF3QjtBQUN4QixTQUFTZ2dCLDhCQUE4Qmh3QixJQUFJLEVBQUVvSSxNQUFNLEVBQUVuRyxDQUFDO0lBQ2xELElBQUl1VTtJQUNKLElBQUl4VyxLQUFLSixRQUFRLElBQUksS0FBS3dJLFVBQVdvTyxDQUFBQSxNQUFNeFcsS0FBS2EsU0FBUyxDQUFDQyxNQUFNLEdBQzVELE9BQU87SUFDWCxJQUFLLElBQUk4SSxPQUFPNUosS0FBSzZKLFdBQVcsRUFBRUQsTUFBTUEsT0FBT0EsS0FBS0MsV0FBVyxDQUMzRCxJQUFJRCxLQUFLaEssUUFBUSxJQUFJLEtBQUtnSyxLQUFLbEksUUFBUSxJQUFJLE1BQ3ZDLE9BQU87SUFDZixPQUFPZCxVQUFVWixNQUFNd1csTUFBTSxHQUFHQSxLQUFLalMscUJBQXFCLEdBQUd2QyxJQUFJLEdBQUdDO0FBQ3hFO0FBQ0EseUVBQXlFO0FBQ3pFLFNBQVNndUIsOEJBQThCandCLElBQUksRUFBRW9JLE1BQU0sRUFBRW5HLENBQUM7SUFDbEQsSUFBSW1HLFVBQVUsR0FDVixPQUFPO0lBQ1gsSUFBSyxJQUFJekUsTUFBTTNELE9BQVE7UUFDbkIsSUFBSTJCLFNBQVNnQyxJQUFJMUQsVUFBVTtRQUMzQixJQUFJLENBQUMwQixVQUFVQSxPQUFPL0IsUUFBUSxJQUFJLEtBQUsrQixPQUFPbUksVUFBVSxJQUFJbkcsS0FDeEQsT0FBTztRQUNYLElBQUloQyxPQUFPeVQsU0FBUyxDQUFDdFYsUUFBUSxDQUFDLFlBQzFCO1FBQ0o2RCxNQUFNaEM7SUFDVjtJQUNBLElBQUlJLE9BQU8vQixLQUFLSixRQUFRLElBQUksSUFBSUksS0FBS3VFLHFCQUFxQixLQUNwRDNELFVBQVVaLE1BQU0sR0FBR2lELEtBQUtzRixHQUFHLENBQUN2SSxLQUFLYSxTQUFTLENBQUNDLE1BQU0sRUFBRSxJQUFJeUQscUJBQXFCO0lBQ2xGLE9BQU90QyxJQUFJRixLQUFLQyxJQUFJLEdBQUc7QUFDM0I7QUFDQSxTQUFTMnVCLFFBQVF4bkIsSUFBSSxFQUFFQyxHQUFHO0lBQ3RCLElBQUlrTyxPQUFPbk8sS0FBS3NpQixXQUFXLENBQUNyaUI7SUFDNUIsSUFBSTBJLE1BQU04ZSxPQUFPLENBQUN0WixLQUFLYSxJQUFJLEdBQ3ZCLEtBQUssSUFBSXdELEtBQUtyRSxLQUFLYSxJQUFJLENBQUU7UUFDckIsSUFBSXdELEVBQUUvVSxFQUFFLEdBQUd3QyxPQUFPdVMsRUFBRS9VLEVBQUUsSUFBSXdDLE9BQVF1UyxDQUFBQSxFQUFFL1UsRUFBRSxJQUFJMFEsS0FBSzFRLEVBQUUsSUFBSStVLEVBQUV4RCxJQUFJLElBQUlyQixVQUFVOVksSUFBSSxHQUN6RSxPQUFPMmQ7SUFDZjtJQUNKLE9BQU9yRTtBQUNYO0FBQ0EsU0FBU3VaLG1CQUFtQjFuQixJQUFJLEVBQUVsRSxLQUFLLEVBQUVnWCxPQUFPLEVBQUU2VSxXQUFXO0lBQ3pELElBQUl4WixPQUFPcVosUUFBUXhuQixNQUFNbEUsTUFBTWlhLElBQUk7SUFDbkMsSUFBSStQLFNBQVMsQ0FBQzZCLGVBQWV4WixLQUFLYSxJQUFJLElBQUlyQixVQUFVOVksSUFBSSxJQUFJLENBQUVtTCxDQUFBQSxLQUFLbW5CLFlBQVksSUFBSWhaLEtBQUt5WixnQkFBZ0IsSUFBSSxPQUN0RzVuQixLQUFLNm5CLFdBQVcsQ0FBQy9yQixNQUFNa1gsS0FBSyxHQUFHLEtBQUtsWCxNQUFNaWEsSUFBSSxHQUFHNUgsS0FBSzNRLElBQUksR0FBRzFCLE1BQU1pYSxJQUFJLEdBQUcsSUFBSWphLE1BQU1pYSxJQUFJO0lBQzlGLElBQUkrUCxRQUFRO1FBQ1IsSUFBSWdDLGFBQWE5bkIsS0FBS3BKLEdBQUcsQ0FBQ3dFLHFCQUFxQjtRQUMvQyxJQUFJaVksWUFBWXJULEtBQUsraEIsZUFBZSxDQUFDNVQsS0FBSzNRLElBQUk7UUFDOUMsSUFBSXlDLE1BQU1ELEtBQUs2bEIsV0FBVyxDQUFDO1lBQUUvc0IsR0FBR2dhLFdBQVlPLENBQUFBLGFBQWF2QixVQUFVQyxHQUFHLElBQUkrVixXQUFXL3VCLEtBQUssR0FBRyxJQUFJK3VCLFdBQVdqdkIsSUFBSSxHQUFHO1lBQy9HcUIsR0FBRyxDQUFDNHJCLE9BQU85c0IsR0FBRyxHQUFHOHNCLE9BQU83c0IsTUFBTSxJQUFJO1FBQUU7UUFDeEMsSUFBSWdILE9BQU8sTUFDUCxPQUFPL0ssOERBQWVBLENBQUNpYixNQUFNLENBQUNsUSxLQUFLNlMsVUFBVSxDQUFDLElBQUk7SUFDMUQ7SUFDQSxPQUFPNWQsOERBQWVBLENBQUNpYixNQUFNLENBQUMyQyxVQUFVM0UsS0FBSzFRLEVBQUUsR0FBRzBRLEtBQUszUSxJQUFJLEVBQUVzVixVQUFVLENBQUMsSUFBSTtBQUNoRjtBQUNBLFNBQVNpVixXQUFXL25CLElBQUksRUFBRWxFLEtBQUssRUFBRWdYLE9BQU8sRUFBRWtWLEVBQUU7SUFDeEMsSUFBSTdaLE9BQU9uTyxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDdVosTUFBTSxDQUFDelUsTUFBTWlhLElBQUksR0FBR3BFLFFBQVEzUixLQUFLaW9CLFNBQVMsQ0FBQzlaO0lBQ3JFLElBQUlrRixZQUFZclQsS0FBSytoQixlQUFlLENBQUM1VCxLQUFLM1EsSUFBSTtJQUM5QyxJQUFLLElBQUloRCxNQUFNc0IsT0FBT29zQixRQUFRLE9BQVE7UUFDbEMsSUFBSXpuQixPQUFPb1YsYUFBYTFILE1BQU13RCxPQUFPMEIsV0FBVzdZLEtBQUtzWSxVQUFVcVYsT0FBT3ZTO1FBQ3RFLElBQUksQ0FBQ25WLE1BQU07WUFDUCxJQUFJME4sS0FBS2lhLE1BQU0sSUFBS3RWLENBQUFBLFVBQVU5UyxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDMm1CLEtBQUssR0FBRyxJQUNqRCxPQUFPbmpCO1lBQ1gydEIsT0FBTztZQUNQaGEsT0FBT25PLEtBQUt5SixLQUFLLENBQUN6UyxHQUFHLENBQUNtWCxJQUFJLENBQUNBLEtBQUtpYSxNQUFNLEdBQUl0VixDQUFBQSxVQUFVLElBQUksQ0FBQztZQUN6RG5CLFFBQVEzUixLQUFLaW9CLFNBQVMsQ0FBQzlaO1lBQ3ZCMU4sT0FBT1QsS0FBS3FvQixjQUFjLENBQUNsYSxNQUFNLENBQUMyRTtRQUN0QztRQUNBLElBQUksQ0FBQ29WLE9BQU87WUFDUixJQUFJLENBQUNGLElBQ0QsT0FBT3ZuQjtZQUNYeW5CLFFBQVFGLEdBQUdHO1FBQ2YsT0FDSyxJQUFJLENBQUNELE1BQU1DLE9BQU87WUFDbkIsT0FBTzN0QjtRQUNYO1FBQ0FBLE1BQU1pRztJQUNWO0FBQ0o7QUFDQSxTQUFTNm5CLFFBQVF0b0IsSUFBSSxFQUFFQyxHQUFHLEVBQUVuRSxLQUFLO0lBQzdCLElBQUlvb0IsYUFBYWxrQixLQUFLeUosS0FBSyxDQUFDMGEsZUFBZSxDQUFDbGtCO0lBQzVDLElBQUlva0IsTUFBTUgsV0FBV3BvQjtJQUNyQixPQUFPLENBQUMyRTtRQUNKLElBQUk4bkIsVUFBVXJFLFdBQVd6akI7UUFDekIsSUFBSTRqQixPQUFPOXVCLDJEQUFZQSxDQUFDaXpCLEtBQUssRUFDekJuRSxNQUFNa0U7UUFDVixPQUFPbEUsT0FBT2tFO0lBQ2xCO0FBQ0o7QUFDQSxTQUFTRSxlQUFlem9CLElBQUksRUFBRWxFLEtBQUssRUFBRWdYLE9BQU8sRUFBRTRWLFFBQVE7SUFDbEQsSUFBSUMsV0FBVzdzQixNQUFNaWEsSUFBSSxFQUFFMWQsTUFBTXlhLFVBQVUsSUFBSSxDQUFDO0lBQ2hELElBQUk2VixZQUFhN1YsQ0FBQUEsVUFBVTlTLEtBQUt5SixLQUFLLENBQUN6UyxHQUFHLENBQUNXLE1BQU0sR0FBRyxJQUMvQyxPQUFPekMsOERBQWVBLENBQUNpYixNQUFNLENBQUN3WSxVQUFVN3NCLE1BQU1rWCxLQUFLO0lBQ3ZELElBQUk0VixPQUFPOXNCLE1BQU0rc0IsVUFBVSxFQUFFQztJQUM3QixJQUFJbHdCLE9BQU9vSCxLQUFLNmMsVUFBVSxDQUFDemhCLHFCQUFxQjtJQUNoRCxJQUFJMnRCLGNBQWMvb0IsS0FBSzZuQixXQUFXLENBQUNjLFVBQVU3c0IsTUFBTWtYLEtBQUssSUFBSSxDQUFDLElBQUkrUyxTQUFTL2xCLEtBQUtncEIsV0FBVztJQUMxRixJQUFJRCxhQUFhO1FBQ2IsSUFBSUgsUUFBUSxNQUNSQSxPQUFPRyxZQUFZbHdCLElBQUksR0FBR0QsS0FBS0MsSUFBSTtRQUN2Q2l3QixTQUFTendCLE1BQU0sSUFBSTB3QixZQUFZL3ZCLEdBQUcsR0FBRyt2QixZQUFZOXZCLE1BQU07SUFDM0QsT0FDSztRQUNELElBQUlrVixPQUFPbk8sS0FBSzZNLFNBQVMsQ0FBQ3lWLFdBQVcsQ0FBQ3FHO1FBQ3RDLElBQUlDLFFBQVEsTUFDUkEsT0FBTzl1QixLQUFLK0MsR0FBRyxDQUFDakUsS0FBS0csS0FBSyxHQUFHSCxLQUFLQyxJQUFJLEVBQUVtSCxLQUFLa25CLHFCQUFxQixHQUFJeUIsQ0FBQUEsV0FBV3hhLEtBQUszUSxJQUFJO1FBQzlGc3JCLFNBQVMsQ0FBQ3p3QixNQUFNLElBQUk4VixLQUFLblYsR0FBRyxHQUFHbVYsS0FBS2xWLE1BQU0sSUFBSThzQjtJQUNsRDtJQUNBLElBQUlrRCxlQUFlcndCLEtBQUtDLElBQUksR0FBRyt2QjtJQUMvQixJQUFJOWIsT0FBTzRiLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUlBLFdBQVkxb0IsS0FBSzZNLFNBQVMsQ0FBQ0QsWUFBWSxDQUFDSCxVQUFVLElBQUk7SUFDNUcsSUFBSyxJQUFJeWMsUUFBUSxJQUFJQSxTQUFTLEdBQUk7UUFDOUIsSUFBSUMsT0FBT0wsU0FBUyxDQUFDaGMsT0FBT29jLEtBQUksSUFBSzd3QjtRQUNyQyxJQUFJNEgsTUFBTTRsQixZQUFZN2xCLE1BQU07WUFBRWxILEdBQUdtd0I7WUFBYy91QixHQUFHaXZCO1FBQUssR0FBRyxPQUFPOXdCO1FBQ2pFLElBQUk4d0IsT0FBT3Z3QixLQUFLSSxHQUFHLElBQUltd0IsT0FBT3Z3QixLQUFLSyxNQUFNLElBQUtaLENBQUFBLE1BQU0sSUFBSTRILE1BQU0wb0IsV0FBVzFvQixNQUFNMG9CLFFBQU8sR0FBSTtZQUN0RixJQUFJUyxXQUFXcHBCLEtBQUtpTixPQUFPLENBQUNxVSxhQUFhLENBQUNyaEI7WUFDMUMsSUFBSStTLFFBQVEsQ0FBQ29XLFlBQVlELE9BQU9DLFNBQVNwd0IsR0FBRyxHQUFHLENBQUMsSUFBSTtZQUNwRCxPQUFPOUQsOERBQWVBLENBQUNpYixNQUFNLENBQUNsUSxLQUFLK1MsT0FBTzNWLFdBQVd1ckI7UUFDekQ7SUFDSjtBQUNKO0FBQ0EsU0FBU1MsaUJBQWlCQyxLQUFLLEVBQUVycEIsR0FBRyxFQUFFb0IsSUFBSTtJQUN0QyxPQUFTO1FBQ0wsSUFBSWtvQixRQUFRO1FBQ1osS0FBSyxJQUFJM3NCLE9BQU8wc0IsTUFBTztZQUNuQjFzQixJQUFJNHNCLE9BQU8sQ0FBQ3ZwQixNQUFNLEdBQUdBLE1BQU0sR0FBRyxDQUFDekMsTUFBTUMsSUFBSTJOO2dCQUNyQyxJQUFJbkwsTUFBTXpDLFFBQVF5QyxNQUFNeEMsSUFBSTtvQkFDeEIsSUFBSXhELE9BQU9zdkIsU0FBU2xvQixRQUFTcEIsQ0FBQUEsTUFBTXpDLE9BQU9DLEtBQUt3QyxNQUFNLENBQUMsSUFBSTtvQkFDMURBLE1BQU1oRyxPQUFPLElBQUl1RCxPQUFPQztvQkFDeEI4ckIsUUFBUXR2QjtnQkFDWjtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNzdkIsT0FDRCxPQUFPdHBCO0lBQ2Y7QUFDSjtBQUNBLFNBQVN3cEIsVUFBVXpwQixJQUFJLEVBQUUwcEIsTUFBTSxFQUFFenBCLEdBQUc7SUFDaEMsSUFBSWdoQixTQUFTb0ksaUJBQWlCcnBCLEtBQUt5SixLQUFLLENBQUNvTyxLQUFLLENBQUM0QixjQUFjcEMsR0FBRyxDQUFDc1MsQ0FBQUEsSUFBS0EsRUFBRTNwQixRQUFRQyxJQUFJekMsSUFBSSxFQUFFa3NCLE9BQU8zVCxJQUFJLEdBQUc5VixJQUFJekMsSUFBSSxHQUFHLENBQUMsSUFBSTtJQUN4SCxPQUFPeWpCLFVBQVVoaEIsSUFBSXpDLElBQUksR0FBR3lDLE1BQU0vSyw4REFBZUEsQ0FBQ2liLE1BQU0sQ0FBQzhRLFFBQVFBLFNBQVNoaEIsSUFBSXpDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDOUY7QUFFQSxzREFBc0Q7QUFDdEQsTUFBTW9zQjtJQUNGQyxtQkFBbUJDLE1BQU0sRUFBRTtRQUN2QixJQUFJLENBQUNDLG1CQUFtQixHQUFHRDtRQUMzQixJQUFJLENBQUNFLGlCQUFpQixHQUFHck4sS0FBS0MsR0FBRztJQUNyQztJQUNBeGdCLFlBQVk0RCxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUNBLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNpcUIsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLCtEQUErRDtRQUMvRCxrRUFBa0U7UUFDbEUsK0NBQStDO1FBQy9DLElBQUksQ0FBQ0MsYUFBYSxHQUFHbHRCO1FBQ3JCLElBQUksQ0FBQzBzQixtQkFBbUIsR0FBRztRQUMzQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ1EsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLEVBQUU7UUFDeEIsSUFBSSxDQUFDQyxRQUFRLEdBQUdyZ0IsT0FBT3RCLE1BQU0sQ0FBQztRQUM5QixtRUFBbUU7UUFDbkUsK0RBQStEO1FBQy9ELGdFQUFnRTtRQUNoRSxzREFBc0Q7UUFDdEQsSUFBSSxDQUFDb1UsU0FBUyxHQUFHLENBQUM7UUFDbEIsa0VBQWtFO1FBQ2xFLGlFQUFpRTtRQUNqRSw0REFBNEQ7UUFDNUQsZUFBZTtRQUNmLElBQUksQ0FBQ3dOLHNCQUFzQixHQUFHO1FBQzlCLHVDQUF1QztRQUN2QyxJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLDhEQUE4RDtRQUM5RCxtRUFBbUU7UUFDbkUscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0MscUJBQXFCLEdBQUc7UUFDN0IsaUVBQWlFO1FBQ2pFLGtFQUFrRTtRQUNsRSxJQUFJLENBQUNDLHdCQUF3QixHQUFHO1FBQ2hDLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLGtFQUFrRTtRQUNsRSxpQkFBaUI7UUFDakIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUNDLElBQUksQ0FBQyxJQUFJO1FBQzdDLElBQUksQ0FBQ0MsZUFBZSxHQUFHcHJCLEtBQUtxckIsUUFBUTtRQUNwQyw4REFBOEQ7UUFDOUQsNkRBQTZEO1FBQzdELElBQUlsbEIsUUFBUUgsTUFBTSxFQUNkaEcsS0FBSzZjLFVBQVUsQ0FBQ3lPLGdCQUFnQixDQUFDLFNBQVMsSUFBTTtRQUNwRCxJQUFJbmxCLFFBQVFOLEtBQUssRUFDYjBsQixtQkFBbUJ2ckIsS0FBSzZjLFVBQVUsQ0FBQ25tQixhQUFhO0lBQ3hEO0lBQ0F3MEIsWUFBWTNoQixLQUFLLEVBQUU7UUFDZixJQUFJLENBQUNpaUIscUJBQXFCLElBQUksQ0FBQ3hyQixJQUFJLEVBQUV1SixVQUFVLElBQUksQ0FBQ2tpQix1QkFBdUIsQ0FBQ2xpQixRQUN4RTtRQUNKLElBQUlBLE1BQU15RixJQUFJLElBQUksYUFBYSxJQUFJLENBQUMwYyxPQUFPLENBQUNuaUIsUUFDeEM7UUFDSixJQUFJLENBQUNvaUIsV0FBVyxDQUFDcGlCLE1BQU15RixJQUFJLEVBQUV6RjtJQUNqQztJQUNBb2lCLFlBQVkzYyxJQUFJLEVBQUV6RixLQUFLLEVBQUU7UUFDckIsSUFBSW9oQixXQUFXLElBQUksQ0FBQ0EsUUFBUSxDQUFDM2IsS0FBSztRQUNsQyxJQUFJMmIsVUFBVTtZQUNWLEtBQUssSUFBSXpNLFlBQVl5TSxTQUFTaUIsU0FBUyxDQUNuQzFOLFNBQVMsSUFBSSxDQUFDbGUsSUFBSSxFQUFFdUo7WUFDeEIsS0FBSyxJQUFJcU8sV0FBVytTLFNBQVNBLFFBQVEsQ0FBRTtnQkFDbkMsSUFBSXBoQixNQUFNNUssZ0JBQWdCLEVBQ3RCO2dCQUNKLElBQUlpWixRQUFRLElBQUksQ0FBQzVYLElBQUksRUFBRXVKLFFBQVE7b0JBQzNCQSxNQUFNc2lCLGNBQWM7b0JBQ3BCO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0lBQ0FDLGVBQWVDLE9BQU8sRUFBRTtRQUNwQixJQUFJcEIsV0FBV3FCLGdCQUFnQkQsVUFBVTdzQixPQUFPLElBQUksQ0FBQ3lyQixRQUFRLEVBQUUvekIsTUFBTSxJQUFJLENBQUNvSixJQUFJLENBQUM2YyxVQUFVO1FBQ3pGLElBQUssSUFBSTdOLFFBQVEyYixTQUNiLElBQUkzYixRQUFRLFVBQVU7WUFDbEIsSUFBSWlkLFVBQVUsQ0FBQ3RCLFFBQVEsQ0FBQzNiLEtBQUssQ0FBQzJiLFFBQVEsQ0FBQ2h6QixNQUFNO1lBQzdDLElBQUl1MEIsU0FBU2h0QixJQUFJLENBQUM4UCxLQUFLO1lBQ3ZCLElBQUlrZCxVQUFVRCxXQUFXLENBQUNDLE9BQU92QixRQUFRLENBQUNoekIsTUFBTSxFQUFFO2dCQUM5Q2YsSUFBSXUxQixtQkFBbUIsQ0FBQ25kLE1BQU0sSUFBSSxDQUFDa2MsV0FBVztnQkFDOUNnQixTQUFTO1lBQ2I7WUFDQSxJQUFJLENBQUNBLFFBQ0R0MUIsSUFBSTAwQixnQkFBZ0IsQ0FBQ3RjLE1BQU0sSUFBSSxDQUFDa2MsV0FBVyxFQUFFO2dCQUFFZTtZQUFRO1FBQy9EO1FBQ0osSUFBSyxJQUFJamQsUUFBUTlQLEtBQ2IsSUFBSThQLFFBQVEsWUFBWSxDQUFDMmIsUUFBUSxDQUFDM2IsS0FBSyxFQUNuQ3BZLElBQUl1MUIsbUJBQW1CLENBQUNuZCxNQUFNLElBQUksQ0FBQ2tjLFdBQVc7UUFDdEQsSUFBSSxDQUFDUCxRQUFRLEdBQUdBO0lBQ3BCO0lBQ0FlLFFBQVFuaUIsS0FBSyxFQUFFO1FBQ1gsOERBQThEO1FBQzlELElBQUksQ0FBQzBnQixXQUFXLEdBQUcxZ0IsTUFBTXBMLE9BQU87UUFDaEMsSUFBSSxDQUFDK3JCLFdBQVcsR0FBR3ZOLEtBQUtDLEdBQUc7UUFDM0IsSUFBSXJULE1BQU1wTCxPQUFPLElBQUksS0FBS3dlLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUM0TixZQUFZLEdBQUcsTUFDdkQsT0FBTztRQUNYLElBQUlqaEIsTUFBTXBMLE9BQU8sSUFBSSxNQUFNaXVCLGNBQWMxcEIsT0FBTyxDQUFDNkcsTUFBTXBMLE9BQU8sSUFBSSxHQUM5RCxJQUFJLENBQUM2QixJQUFJLENBQUNtZCxVQUFVLENBQUNxTixZQUFZLEdBQUc7UUFDeEMsaUVBQWlFO1FBQ2pFLGtFQUFrRTtRQUNsRSwrREFBK0Q7UUFDL0QsNERBQTREO1FBQzVELGVBQWU7UUFDZixJQUFJcmtCLFFBQVFRLE9BQU8sSUFBSVIsUUFBUUwsTUFBTSxJQUFJLENBQUN5RCxNQUFNL0ssU0FBUyxJQUNwRCtLLENBQUFBLE1BQU1wTCxPQUFPLElBQUksTUFBTW9MLE1BQU1wTCxPQUFPLElBQUksSUFBSTtZQUM3QyxJQUFJLENBQUM2QixJQUFJLENBQUNrZSxRQUFRLENBQUNtTyxlQUFlLENBQUM5aUIsTUFBTXJMLEdBQUcsRUFBRXFMLE1BQU1wTCxPQUFPO1lBQzNELE9BQU87UUFDWDtRQUNBLDREQUE0RDtRQUM1RCxzREFBc0Q7UUFDdEQsK0NBQStDO1FBQy9DLHlEQUF5RDtRQUN6RCwwQkFBMEI7UUFDMUIsSUFBSW11QjtRQUNKLElBQUlubUIsUUFBUUYsR0FBRyxJQUFJLENBQUNzRCxNQUFNL0ssU0FBUyxJQUFJLENBQUMrSyxNQUFNZ2pCLE1BQU0sSUFBSSxDQUFDaGpCLE1BQU1pakIsT0FBTyxJQUNqRSxFQUFDRixVQUFVRyxZQUFZN2pCLElBQUksQ0FBQzFLLENBQUFBLE1BQU9BLElBQUlDLE9BQU8sSUFBSW9MLE1BQU1wTCxPQUFPLE1BQU0sQ0FBQ29MLE1BQU1takIsT0FBTyxJQUNoRkMsa0JBQWtCanFCLE9BQU8sQ0FBQzZHLE1BQU1yTCxHQUFHLElBQUksQ0FBQyxLQUFLcUwsTUFBTW1qQixPQUFPLElBQUksQ0FBQ25qQixNQUFNcWpCLFFBQVEsR0FBRztZQUNwRixJQUFJLENBQUNyQyxhQUFhLEdBQUcrQixXQUFXL2lCO1lBQ2hDc2pCLFdBQVcsSUFBTSxJQUFJLENBQUNDLFdBQVcsSUFBSTtZQUNyQyxPQUFPO1FBQ1g7UUFDQSxJQUFJdmpCLE1BQU1wTCxPQUFPLElBQUksS0FDakIsSUFBSSxDQUFDNkIsSUFBSSxDQUFDa2UsUUFBUSxDQUFDNk8sVUFBVTtRQUNqQyxPQUFPO0lBQ1g7SUFDQUQsY0FBYztRQUNWLElBQUk1dUIsTUFBTSxJQUFJLENBQUNxc0IsYUFBYTtRQUM1QixJQUFJLENBQUNyc0IsS0FDRCxPQUFPO1FBQ1gsSUFBSSxDQUFDcXNCLGFBQWEsR0FBR2x0QjtRQUNyQixPQUFPUyxZQUFZLElBQUksQ0FBQ2tDLElBQUksQ0FBQzZjLFVBQVUsRUFBRTNlLElBQUlBLEdBQUcsRUFBRUEsSUFBSUMsT0FBTztJQUNqRTtJQUNBc3RCLHdCQUF3QmxpQixLQUFLLEVBQUU7UUFDM0IsSUFBSSxDQUFDLE9BQU8zTyxJQUFJLENBQUMyTyxNQUFNeUYsSUFBSSxHQUN2QixPQUFPO1FBQ1gsSUFBSSxJQUFJLENBQUNvTyxTQUFTLEdBQUcsR0FDakIsT0FBTztRQUNYLHlFQUF5RTtRQUN6RSxnRUFBZ0U7UUFDaEUsaUVBQWlFO1FBQ2pFLGlFQUFpRTtRQUNqRSxnRUFBZ0U7UUFDaEUsNkNBQTZDO1FBQzdDLElBQUlqWCxRQUFRSCxNQUFNLElBQUksQ0FBQ0csUUFBUUYsR0FBRyxJQUFJLElBQUksQ0FBQzZrQixxQkFBcUIsSUFBSW5PLEtBQUtDLEdBQUcsS0FBSyxJQUFJLENBQUNpTyxrQkFBa0IsR0FBRyxLQUFLO1lBQzVHLElBQUksQ0FBQ0MscUJBQXFCLEdBQUc7WUFDN0IsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNYO0lBQ0FrQyxvQkFBb0JoQyxjQUFjLEVBQUU7UUFDaEMsSUFBSSxJQUFJLENBQUNBLGNBQWMsRUFDbkIsSUFBSSxDQUFDQSxjQUFjLENBQUNyb0IsT0FBTztRQUMvQixJQUFJLENBQUNxb0IsY0FBYyxHQUFHQTtJQUMxQjtJQUNBN1IsT0FBT0EsTUFBTSxFQUFFO1FBQ1gsSUFBSSxJQUFJLENBQUM2UixjQUFjLEVBQ25CLElBQUksQ0FBQ0EsY0FBYyxDQUFDN1IsTUFBTSxDQUFDQTtRQUMvQixJQUFJLElBQUksQ0FBQzhSLGNBQWMsSUFBSTlSLE9BQU95QyxVQUFVLEVBQ3hDLElBQUksQ0FBQ3FQLGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWMsQ0FBQzVULEdBQUcsQ0FBQzhCLE9BQU83QixPQUFPO1FBQ2hFLElBQUk2QixPQUFPZ0MsWUFBWSxDQUFDeGpCLE1BQU0sRUFDMUIsSUFBSSxDQUFDc3lCLFdBQVcsR0FBRyxJQUFJLENBQUNELGlCQUFpQixHQUFHO0lBQ3BEO0lBQ0FybkIsVUFBVTtRQUNOLElBQUksSUFBSSxDQUFDcW9CLGNBQWMsRUFDbkIsSUFBSSxDQUFDQSxjQUFjLENBQUNyb0IsT0FBTztJQUNuQztBQUNKO0FBQ0EsU0FBU3NxQixZQUFZcFUsTUFBTSxFQUFFakIsT0FBTztJQUNoQyxPQUFPLENBQUM1WCxNQUFNdUo7UUFDVixJQUFJO1lBQ0EsT0FBT3FPLFFBQVEvTyxJQUFJLENBQUNnUSxRQUFRdFAsT0FBT3ZKO1FBQ3ZDLEVBQ0EsT0FBT29aLEdBQUc7WUFDTjFCLGFBQWExWCxLQUFLeUosS0FBSyxFQUFFMlA7UUFDN0I7SUFDSjtBQUNKO0FBQ0EsU0FBUzRTLGdCQUFnQkQsT0FBTztJQUM1QixJQUFJM2tCLFNBQVNrRCxPQUFPdEIsTUFBTSxDQUFDO0lBQzNCLFNBQVNra0IsT0FBT2xlLElBQUk7UUFDaEIsT0FBTzVILE1BQU0sQ0FBQzRILEtBQUssSUFBSzVILENBQUFBLE1BQU0sQ0FBQzRILEtBQUssR0FBRztZQUFFNGMsV0FBVyxFQUFFO1lBQUVqQixVQUFVLEVBQUU7UUFBQztJQUN6RTtJQUNBLEtBQUssSUFBSTlSLFVBQVVrVCxRQUFTO1FBQ3hCLElBQUlqZ0IsT0FBTytNLE9BQU8vTSxJQUFJO1FBQ3RCLElBQUlBLFFBQVFBLEtBQUt3TSxnQkFBZ0IsRUFDN0IsSUFBSyxJQUFJdEosUUFBUWxELEtBQUt3TSxnQkFBZ0IsQ0FBRTtZQUNwQyxJQUFJcVIsSUFBSTdkLEtBQUt3TSxnQkFBZ0IsQ0FBQ3RKLEtBQUs7WUFDbkMsSUFBSTJhLEdBQ0F1RCxPQUFPbGUsTUFBTTJiLFFBQVEsQ0FBQ3h0QixJQUFJLENBQUM4dkIsWUFBWXBVLE9BQU96TixLQUFLLEVBQUV1ZTtRQUM3RDtRQUNKLElBQUk3ZCxRQUFRQSxLQUFLeU0saUJBQWlCLEVBQzlCLElBQUssSUFBSXZKLFFBQVFsRCxLQUFLeU0saUJBQWlCLENBQUU7WUFDckMsSUFBSW9SLElBQUk3ZCxLQUFLeU0saUJBQWlCLENBQUN2SixLQUFLO1lBQ3BDLElBQUkyYSxHQUNBdUQsT0FBT2xlLE1BQU00YyxTQUFTLENBQUN6dUIsSUFBSSxDQUFDOHZCLFlBQVlwVSxPQUFPek4sS0FBSyxFQUFFdWU7UUFDOUQ7SUFDUjtJQUNBLElBQUssSUFBSTNhLFFBQVEyYixTQUNidUMsT0FBT2xlLE1BQU0yYixRQUFRLENBQUN4dEIsSUFBSSxDQUFDd3RCLFFBQVEsQ0FBQzNiLEtBQUs7SUFDN0MsSUFBSyxJQUFJQSxRQUFRNGMsVUFDYnNCLE9BQU9sZSxNQUFNNGMsU0FBUyxDQUFDenVCLElBQUksQ0FBQ3l1QixTQUFTLENBQUM1YyxLQUFLO0lBQy9DLE9BQU81SDtBQUNYO0FBQ0EsTUFBTXFsQixjQUFjO0lBQ2hCO1FBQUV2dUIsS0FBSztRQUFhQyxTQUFTO1FBQUdndkIsV0FBVztJQUF3QjtJQUNuRTtRQUFFanZCLEtBQUs7UUFBU0MsU0FBUztRQUFJZ3ZCLFdBQVc7SUFBa0I7SUFDMUQ7UUFBRWp2QixLQUFLO1FBQVNDLFNBQVM7UUFBSWd2QixXQUFXO0lBQWtCO0lBQzFEO1FBQUVqdkIsS0FBSztRQUFVQyxTQUFTO1FBQUlndkIsV0FBVztJQUF1QjtDQUNuRTtBQUNELE1BQU1SLG9CQUFvQjtBQUMxQiw4QkFBOEI7QUFDOUIsTUFBTVAsZ0JBQWdCO0lBQUM7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSztDQUFJO0FBQ3hELE1BQU1nQixtQkFBbUI7QUFDekIsU0FBU0MsZ0JBQWdCdmdCLElBQUk7SUFDekIsT0FBT2hULEtBQUtzRixHQUFHLENBQUMsR0FBRzBOLFFBQVEsTUFBTTtBQUNyQztBQUNBLFNBQVNBLEtBQUt0QyxDQUFDLEVBQUVDLENBQUM7SUFDZCxPQUFPM1EsS0FBS3NGLEdBQUcsQ0FBQ3RGLEtBQUtDLEdBQUcsQ0FBQ3lRLEVBQUU4aUIsT0FBTyxHQUFHN2lCLEVBQUU2aUIsT0FBTyxHQUFHeHpCLEtBQUtDLEdBQUcsQ0FBQ3lRLEVBQUUraUIsT0FBTyxHQUFHOWlCLEVBQUU4aUIsT0FBTztBQUNuRjtBQUNBLE1BQU1DO0lBQ0ZweEIsWUFBWTRELElBQUksRUFBRXl0QixVQUFVLEVBQUVsb0IsS0FBSyxFQUFFbW9CLFVBQVUsQ0FBRTtRQUM3QyxJQUFJLENBQUMxdEIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ3l0QixVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ2xvQixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDbW9CLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7WUFBRTcwQixHQUFHO1lBQUdvQixHQUFHO1FBQUU7UUFDaEMsSUFBSSxDQUFDMHpCLFNBQVMsR0FBRyxDQUFDO1FBQ2xCLElBQUksQ0FBQ0MsU0FBUyxHQUFHSjtRQUNqQixJQUFJLENBQUNLLFlBQVksR0FBRzV4QixpQkFBaUI4RCxLQUFLNmMsVUFBVTtRQUNwRCxJQUFJLENBQUN5TSxLQUFLLEdBQUd0cEIsS0FBS3lKLEtBQUssQ0FBQ29PLEtBQUssQ0FBQzRCLGNBQWNwQyxHQUFHLENBQUNzUyxDQUFBQSxJQUFLQSxFQUFFM3BCO1FBQ3ZELElBQUloSixNQUFNZ0osS0FBSzZjLFVBQVUsQ0FBQ25tQixhQUFhO1FBQ3ZDTSxJQUFJczBCLGdCQUFnQixDQUFDLGFBQWEsSUFBSSxDQUFDeUMsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxDQUFDNUMsSUFBSSxDQUFDLElBQUk7UUFDakVuMEIsSUFBSXMwQixnQkFBZ0IsQ0FBQyxXQUFXLElBQUksQ0FBQzVzQixFQUFFLEdBQUcsSUFBSSxDQUFDQSxFQUFFLENBQUN5c0IsSUFBSSxDQUFDLElBQUk7UUFDM0QsSUFBSSxDQUFDM0ssTUFBTSxHQUFHaU4sV0FBV2IsUUFBUTtRQUNqQyxJQUFJLENBQUNvQixRQUFRLEdBQUdodUIsS0FBS3lKLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ3BpQiwwREFBV0EsQ0FBQ3c0Qix1QkFBdUIsS0FBS0MsbUJBQW1CbHVCLE1BQU15dEI7UUFDbEcsSUFBSSxDQUFDVSxRQUFRLEdBQUdDLHFCQUFxQnB1QixNQUFNeXRCLGVBQWVZLGFBQWFaLGVBQWUsSUFBSSxPQUFPO0lBQ3JHO0lBQ0EzeEIsTUFBTXlOLEtBQUssRUFBRTtRQUNULGdFQUFnRTtRQUNoRSxtQ0FBbUM7UUFDbkMsSUFBSSxJQUFJLENBQUM0a0IsUUFBUSxLQUFLLE9BQ2xCLElBQUksQ0FBQ0csTUFBTSxDQUFDL2tCO0lBQ3BCO0lBQ0F3a0IsS0FBS3hrQixLQUFLLEVBQUU7UUFDUixJQUFJeUM7UUFDSixJQUFJekMsTUFBTWdsQixPQUFPLElBQUksR0FDakIsT0FBTyxJQUFJLENBQUM1ckIsT0FBTztRQUN2QixJQUFJLElBQUksQ0FBQ3dyQixRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRLElBQUksUUFBUXJoQixLQUFLLElBQUksQ0FBQzJnQixVQUFVLEVBQUVsa0IsU0FBUyxJQUN6RTtRQUNKLElBQUksQ0FBQytrQixNQUFNLENBQUMsSUFBSSxDQUFDVCxTQUFTLEdBQUd0a0I7UUFDN0IsSUFBSWlsQixLQUFLLEdBQUdDLEtBQUs7UUFDakIsSUFBSTcxQixPQUFPLENBQUMsQ0FBQ29ULEtBQUssSUFBSSxDQUFDOGhCLFlBQVksTUFBTSxRQUFROWhCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzVRLHFCQUFxQixFQUFDLEtBQzVGO1lBQUV2QyxNQUFNO1lBQUdHLEtBQUs7WUFBR0QsT0FBTyxJQUFJLENBQUNpSCxJQUFJLENBQUM3RyxHQUFHLENBQUNDLFVBQVU7WUFBRUgsUUFBUSxJQUFJLENBQUMrRyxJQUFJLENBQUM3RyxHQUFHLENBQUNFLFdBQVc7UUFBQztRQUM3RixJQUFJeXBCLFVBQVU1SSxpQkFBaUIsSUFBSSxDQUFDbGEsSUFBSTtRQUN4QyxJQUFJdUosTUFBTStqQixPQUFPLEdBQUd4SyxRQUFRanFCLElBQUksSUFBSUQsS0FBS0MsSUFBSSxHQUFHdTBCLGtCQUM1Q29CLEtBQUssQ0FBQ25CLGdCQUFnQnowQixLQUFLQyxJQUFJLEdBQUcwUSxNQUFNK2pCLE9BQU87YUFDOUMsSUFBSS9qQixNQUFNK2pCLE9BQU8sR0FBR3hLLFFBQVEvcEIsS0FBSyxJQUFJSCxLQUFLRyxLQUFLLEdBQUdxMEIsa0JBQ25Eb0IsS0FBS25CLGdCQUFnQjlqQixNQUFNK2pCLE9BQU8sR0FBRzEwQixLQUFLRyxLQUFLO1FBQ25ELElBQUl3USxNQUFNZ2tCLE9BQU8sR0FBR3pLLFFBQVE5cEIsR0FBRyxJQUFJSixLQUFLSSxHQUFHLEdBQUdvMEIsa0JBQzFDcUIsS0FBSyxDQUFDcEIsZ0JBQWdCejBCLEtBQUtJLEdBQUcsR0FBR3VRLE1BQU1na0IsT0FBTzthQUM3QyxJQUFJaGtCLE1BQU1na0IsT0FBTyxHQUFHekssUUFBUTdwQixNQUFNLElBQUlMLEtBQUtLLE1BQU0sR0FBR20wQixrQkFDckRxQixLQUFLcEIsZ0JBQWdCOWpCLE1BQU1na0IsT0FBTyxHQUFHMzBCLEtBQUtLLE1BQU07UUFDcEQsSUFBSSxDQUFDeTFCLGNBQWMsQ0FBQ0YsSUFBSUM7SUFDNUI7SUFDQS92QixHQUFHNkssS0FBSyxFQUFFO1FBQ04sSUFBSSxJQUFJLENBQUM0a0IsUUFBUSxJQUFJLE1BQ2pCLElBQUksQ0FBQ0csTUFBTSxDQUFDLElBQUksQ0FBQ1QsU0FBUztRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDTSxRQUFRLEVBQ2Q1a0IsTUFBTXNpQixjQUFjO1FBQ3hCLElBQUksQ0FBQ2xwQixPQUFPO0lBQ2hCO0lBQ0FBLFVBQVU7UUFDTixJQUFJLENBQUMrckIsY0FBYyxDQUFDLEdBQUc7UUFDdkIsSUFBSTEzQixNQUFNLElBQUksQ0FBQ2dKLElBQUksQ0FBQzZjLFVBQVUsQ0FBQ25tQixhQUFhO1FBQzVDTSxJQUFJbTFCLG1CQUFtQixDQUFDLGFBQWEsSUFBSSxDQUFDNEIsSUFBSTtRQUM5Qy8yQixJQUFJbTFCLG1CQUFtQixDQUFDLFdBQVcsSUFBSSxDQUFDenRCLEVBQUU7UUFDMUMsSUFBSSxDQUFDc0IsSUFBSSxDQUFDbWQsVUFBVSxDQUFDNk4sY0FBYyxHQUFHLElBQUksQ0FBQ2hyQixJQUFJLENBQUNtZCxVQUFVLENBQUM4TixjQUFjLEdBQUc7SUFDaEY7SUFDQXlELGVBQWVGLEVBQUUsRUFBRUMsRUFBRSxFQUFFO1FBQ25CLElBQUksQ0FBQ2QsV0FBVyxHQUFHO1lBQUU3MEIsR0FBRzAxQjtZQUFJdDBCLEdBQUd1MEI7UUFBRztRQUNsQyxJQUFJRCxNQUFNQyxJQUFJO1lBQ1YsSUFBSSxJQUFJLENBQUNiLFNBQVMsR0FBRyxHQUNqQixJQUFJLENBQUNBLFNBQVMsR0FBR2UsWUFBWSxJQUFNLElBQUksQ0FBQ0MsTUFBTSxJQUFJO1FBQzFELE9BQ0ssSUFBSSxJQUFJLENBQUNoQixTQUFTLEdBQUcsQ0FBQyxHQUFHO1lBQzFCaUIsY0FBYyxJQUFJLENBQUNqQixTQUFTO1lBQzVCLElBQUksQ0FBQ0EsU0FBUyxHQUFHLENBQUM7UUFDdEI7SUFDSjtJQUNBZ0IsU0FBUztRQUNMLElBQUksSUFBSSxDQUFDZCxZQUFZLEVBQUU7WUFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUM5eEIsVUFBVSxJQUFJLElBQUksQ0FBQzJ4QixXQUFXLENBQUM3MEIsQ0FBQztZQUNsRCxJQUFJLENBQUNnMUIsWUFBWSxDQUFDL3hCLFNBQVMsSUFBSSxJQUFJLENBQUM0eEIsV0FBVyxDQUFDenpCLENBQUM7UUFDckQsT0FDSztZQUNELElBQUksQ0FBQzhGLElBQUksQ0FBQzdHLEdBQUcsQ0FBQ3dDLFFBQVEsQ0FBQyxJQUFJLENBQUNneUIsV0FBVyxDQUFDNzBCLENBQUMsRUFBRSxJQUFJLENBQUM2MEIsV0FBVyxDQUFDenpCLENBQUM7UUFDakU7UUFDQSxJQUFJLElBQUksQ0FBQ2kwQixRQUFRLEtBQUssT0FDbEIsSUFBSSxDQUFDRyxNQUFNLENBQUMsSUFBSSxDQUFDVCxTQUFTO0lBQ2xDO0lBQ0FwRSxVQUFVOUksR0FBRyxFQUFFO1FBQ1gsSUFBSWxSLFNBQVM7UUFDYixJQUFLLElBQUluUyxJQUFJLEdBQUdBLElBQUlxakIsSUFBSWxSLE1BQU0sQ0FBQzlYLE1BQU0sRUFBRTJGLElBQUs7WUFDeEMsSUFBSVgsUUFBUWdrQixJQUFJbFIsTUFBTSxDQUFDblMsRUFBRSxFQUFFd3hCLFVBQVU7WUFDckMsSUFBSW55QixNQUFNNk0sS0FBSyxFQUFFO2dCQUNiLElBQUl2SixNQUFNb3BCLGlCQUFpQixJQUFJLENBQUNDLEtBQUssRUFBRTNzQixNQUFNYSxJQUFJLEVBQUU7Z0JBQ25ELElBQUl5QyxPQUFPdEQsTUFBTWEsSUFBSSxFQUNqQnN4QixVQUFVNTVCLDhEQUFlQSxDQUFDaWIsTUFBTSxDQUFDbFEsS0FBSyxDQUFDO1lBQy9DLE9BQ0s7Z0JBQ0QsSUFBSXpDLE9BQU82ckIsaUJBQWlCLElBQUksQ0FBQ0MsS0FBSyxFQUFFM3NCLE1BQU1hLElBQUksRUFBRSxDQUFDO2dCQUNyRCxJQUFJQyxLQUFLNHJCLGlCQUFpQixJQUFJLENBQUNDLEtBQUssRUFBRTNzQixNQUFNYyxFQUFFLEVBQUU7Z0JBQ2hELElBQUlELFFBQVFiLE1BQU1hLElBQUksSUFBSUMsTUFBTWQsTUFBTWMsRUFBRSxFQUNwQ3F4QixVQUFVNTVCLDhEQUFlQSxDQUFDeUgsS0FBSyxDQUFDQSxNQUFNYSxJQUFJLElBQUliLE1BQU1nakIsTUFBTSxHQUFHbmlCLE9BQU9DLElBQUlkLE1BQU1hLElBQUksSUFBSWIsTUFBTW9aLElBQUksR0FBR3ZZLE9BQU9DO1lBQ2xIO1lBQ0EsSUFBSXF4QixTQUFTO2dCQUNULElBQUksQ0FBQ3JmLFFBQ0RBLFNBQVNrUixJQUFJbFIsTUFBTSxDQUFDdEksS0FBSztnQkFDN0JzSSxNQUFNLENBQUNuUyxFQUFFLEdBQUd3eEI7WUFDaEI7UUFDSjtRQUNBLE9BQU9yZixTQUFTdmEsOERBQWVBLENBQUM4VCxNQUFNLENBQUN5RyxRQUFRa1IsSUFBSW9PLFNBQVMsSUFBSXBPO0lBQ3BFO0lBQ0EyTixPQUFPL2tCLEtBQUssRUFBRTtRQUNWLElBQUksRUFBRXZKLElBQUksRUFBRSxHQUFHLElBQUksRUFBRTNJLFlBQVksSUFBSSxDQUFDb3lCLFNBQVMsQ0FBQyxJQUFJLENBQUNsa0IsS0FBSyxDQUFDMUUsR0FBRyxDQUFDMEksT0FBTyxJQUFJLENBQUNpWCxNQUFNLEVBQUUsSUFBSSxDQUFDd04sUUFBUTtRQUNoRyxJQUFJLElBQUksQ0FBQ04sVUFBVSxJQUFJLENBQUNyMkIsVUFBVW1GLEVBQUUsQ0FBQ3dELEtBQUt5SixLQUFLLENBQUNwUyxTQUFTLEVBQUUsSUFBSSxDQUFDODJCLFFBQVEsS0FBSyxRQUN6RSxJQUFJLENBQUNudUIsSUFBSSxDQUFDZ3ZCLFFBQVEsQ0FBQztZQUNmMzNCO1lBQ0E0M0IsV0FBVztRQUNmO1FBQ0osSUFBSSxDQUFDdkIsVUFBVSxHQUFHO0lBQ3RCO0lBQ0F2VSxPQUFPQSxNQUFNLEVBQUU7UUFDWCxJQUFJLElBQUksQ0FBQzVULEtBQUssQ0FBQzRULE1BQU0sQ0FBQ0EsU0FDbEIwVCxXQUFXLElBQU0sSUFBSSxDQUFDeUIsTUFBTSxDQUFDLElBQUksQ0FBQ1QsU0FBUyxHQUFHO0lBQ3REO0FBQ0o7QUFDQSxTQUFTSyxtQkFBbUJsdUIsSUFBSSxFQUFFdUosS0FBSztJQUNuQyxJQUFJc08sUUFBUTdYLEtBQUt5SixLQUFLLENBQUNvTyxLQUFLLENBQUN0QjtJQUM3QixPQUFPc0IsTUFBTWxnQixNQUFNLEdBQUdrZ0IsS0FBSyxDQUFDLEVBQUUsQ0FBQ3RPLFNBQVNwRCxRQUFRQyxHQUFHLEdBQUdtRCxNQUFNaWpCLE9BQU8sR0FBR2pqQixNQUFNbWpCLE9BQU87QUFDdkY7QUFDQSxTQUFTd0MsbUJBQW1CbHZCLElBQUksRUFBRXVKLEtBQUs7SUFDbkMsSUFBSXNPLFFBQVE3WCxLQUFLeUosS0FBSyxDQUFDb08sS0FBSyxDQUFDcEI7SUFDN0IsT0FBT29CLE1BQU1sZ0IsTUFBTSxHQUFHa2dCLEtBQUssQ0FBQyxFQUFFLENBQUN0TyxTQUFTcEQsUUFBUUMsR0FBRyxHQUFHLENBQUNtRCxNQUFNZ2pCLE1BQU0sR0FBRyxDQUFDaGpCLE1BQU1takIsT0FBTztBQUN4RjtBQUNBLFNBQVMwQixxQkFBcUJwdUIsSUFBSSxFQUFFdUosS0FBSztJQUNyQyxJQUFJLEVBQUVnVSxJQUFJLEVBQUUsR0FBR3ZkLEtBQUt5SixLQUFLLENBQUNwUyxTQUFTO0lBQ25DLElBQUlrbUIsS0FBSy9ULEtBQUssRUFDVixPQUFPO0lBQ1gsbUVBQW1FO0lBQ25FLGdDQUFnQztJQUNoQyxJQUFJbVgsTUFBTXJxQixhQUFhMEosS0FBS3pKLElBQUk7SUFDaEMsSUFBSSxDQUFDb3FCLE9BQU9BLElBQUl3TyxVQUFVLElBQUksR0FDMUIsT0FBTztJQUNYLElBQUl6bUIsUUFBUWlZLElBQUl5TyxVQUFVLENBQUMsR0FBR3gzQixjQUFjO0lBQzVDLElBQUssSUFBSTBGLElBQUksR0FBR0EsSUFBSW9MLE1BQU0vUSxNQUFNLEVBQUUyRixJQUFLO1FBQ25DLElBQUkxRSxPQUFPOFAsS0FBSyxDQUFDcEwsRUFBRTtRQUNuQixJQUFJMUUsS0FBS0MsSUFBSSxJQUFJMFEsTUFBTStqQixPQUFPLElBQUkxMEIsS0FBS0csS0FBSyxJQUFJd1EsTUFBTStqQixPQUFPLElBQ3pEMTBCLEtBQUtJLEdBQUcsSUFBSXVRLE1BQU1na0IsT0FBTyxJQUFJMzBCLEtBQUtLLE1BQU0sSUFBSXNRLE1BQU1na0IsT0FBTyxFQUN6RCxPQUFPO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTL0IscUJBQXFCeHJCLElBQUksRUFBRXVKLEtBQUs7SUFDckMsSUFBSSxDQUFDQSxNQUFNOGxCLE9BQU8sRUFDZCxPQUFPO0lBQ1gsSUFBSTlsQixNQUFNNUssZ0JBQWdCLEVBQ3RCLE9BQU87SUFDWCxJQUFLLElBQUk5SCxPQUFPMFMsTUFBTS9TLE1BQU0sRUFBRStuQixPQUFPMW5CLFFBQVFtSixLQUFLNmMsVUFBVSxFQUFFaG1CLE9BQU9BLEtBQUtDLFVBQVUsQ0FDaEYsSUFBSSxDQUFDRCxRQUFRQSxLQUFLSixRQUFRLElBQUksTUFBTyxDQUFDOG5CLFFBQVE3ZSxZQUFZbUIsR0FBRyxDQUFDaEssS0FBSSxLQUFNMG5CLE1BQU14YixXQUFXLENBQUN3RyxRQUN0RixPQUFPO0lBQ2YsT0FBTztBQUNYO0FBQ0EsTUFBTW9oQixXQUFXLFdBQVcsR0FBRXJnQixPQUFPdEIsTUFBTSxDQUFDO0FBQzVDLE1BQU00aUIsWUFBWSxXQUFXLEdBQUV0aEIsT0FBT3RCLE1BQU0sQ0FBQztBQUM3QyxzRUFBc0U7QUFDdEUsaUVBQWlFO0FBQ2pFLDBEQUEwRDtBQUMxRCxNQUFNc21CLHFCQUFxQixRQUFTMXBCLEVBQUUsSUFBSU8sUUFBUUksVUFBVSxHQUFHLE1BQzFESixRQUFRRixHQUFHLElBQUlFLFFBQVFTLGNBQWMsR0FBRztBQUM3QyxTQUFTMm9CLGFBQWF2dkIsSUFBSTtJQUN0QixJQUFJeEgsU0FBU3dILEtBQUtwSixHQUFHLENBQUNFLFVBQVU7SUFDaEMsSUFBSSxDQUFDMEIsUUFDRDtJQUNKLElBQUloQyxTQUFTZ0MsT0FBTzhULFdBQVcsQ0FBQzVPLFNBQVMwSyxhQUFhLENBQUM7SUFDdkQ1UixPQUFPK08sS0FBSyxDQUFDeUYsT0FBTyxHQUFHO0lBQ3ZCeFUsT0FBT3lHLEtBQUs7SUFDWjR2QixXQUFXO1FBQ1A3c0IsS0FBSy9DLEtBQUs7UUFDVnpHLE9BQU8wckIsTUFBTTtRQUNic04sUUFBUXh2QixNQUFNeEosT0FBTzRVLEtBQUs7SUFDOUIsR0FBRztBQUNQO0FBQ0EsU0FBU29rQixRQUFReHZCLElBQUksRUFBRXl2QixLQUFLO0lBQ3hCLElBQUksRUFBRWhtQixLQUFLLEVBQUUsR0FBR3pKLE1BQU1zWCxTQUFTaGEsSUFBSSxHQUFHa0csT0FBT2lHLE1BQU1pbUIsTUFBTSxDQUFDRDtJQUMxRCxJQUFJRSxTQUFTbnNCLEtBQUttYSxLQUFLLElBQUlsVSxNQUFNcFMsU0FBUyxDQUFDb1ksTUFBTSxDQUFDOVgsTUFBTTtJQUN4RCxJQUFJaTRCLFdBQVdDLG9CQUFvQixRQUFRcG1CLE1BQU1wUyxTQUFTLENBQUNvWSxNQUFNLENBQUN1TixLQUFLLENBQUNsVSxDQUFBQSxJQUFLQSxFQUFFVSxLQUFLLEtBQUtxbUIsb0JBQW9CcnNCLEtBQUtILFFBQVE7SUFDMUgsSUFBSXVzQixVQUFVO1FBQ1YsSUFBSUUsV0FBVyxDQUFDO1FBQ2hCeFksVUFBVTdOLE1BQU1zbUIsYUFBYSxDQUFDcHpCLENBQUFBO1lBQzFCLElBQUl3UixPQUFPMUUsTUFBTXpTLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQzVULE1BQU1hLElBQUk7WUFDdEMsSUFBSTJRLEtBQUszUSxJQUFJLElBQUlzeUIsVUFDYixPQUFPO2dCQUFFbnpCO1lBQU07WUFDbkJtekIsV0FBVzNoQixLQUFLM1EsSUFBSTtZQUNwQixJQUFJaUgsU0FBU2dGLE1BQU1pbUIsTUFBTSxDQUFDLENBQUNDLFNBQVNuc0IsS0FBSzJLLElBQUksQ0FBQzdRLEtBQUtrRyxJQUFJLEdBQUdpc0IsS0FBSSxJQUFLaG1CLE1BQU1zSCxTQUFTO1lBQ2xGLE9BQU87Z0JBQUV1RyxTQUFTO29CQUFFOVosTUFBTTJRLEtBQUszUSxJQUFJO29CQUFFaUg7Z0JBQU87Z0JBQ3hDOUgsT0FBT3pILDhEQUFlQSxDQUFDaWIsTUFBTSxDQUFDeFQsTUFBTWEsSUFBSSxHQUFHaUgsT0FBTzlNLE1BQU07WUFBRTtRQUNsRTtJQUNKLE9BQ0ssSUFBSWc0QixRQUFRO1FBQ2JyWSxVQUFVN04sTUFBTXNtQixhQUFhLENBQUNwekIsQ0FBQUE7WUFDMUIsSUFBSXdSLE9BQU8zSyxLQUFLMkssSUFBSSxDQUFDN1E7WUFDckIsT0FBTztnQkFBRWdhLFNBQVM7b0JBQUU5WixNQUFNYixNQUFNYSxJQUFJO29CQUFFQyxJQUFJZCxNQUFNYyxFQUFFO29CQUFFZ0gsUUFBUTBKLEtBQUszSyxJQUFJO2dCQUFDO2dCQUNsRTdHLE9BQU96SCw4REFBZUEsQ0FBQ2liLE1BQU0sQ0FBQ3hULE1BQU1hLElBQUksR0FBRzJRLEtBQUt4VyxNQUFNO1lBQUU7UUFDaEU7SUFDSixPQUNLO1FBQ0QyZixVQUFVN04sTUFBTXVtQixnQkFBZ0IsQ0FBQ3hzQjtJQUNyQztJQUNBeEQsS0FBS2d2QixRQUFRLENBQUMxWCxTQUFTO1FBQ25CMlgsV0FBVztRQUNYelgsZ0JBQWdCO0lBQ3BCO0FBQ0o7QUFDQW9VLFVBQVVnRCxNQUFNLEdBQUc1dUIsQ0FBQUE7SUFDZkEsS0FBS21kLFVBQVUsQ0FBQ2tOLGFBQWEsR0FBR3JxQixLQUFLMmhCLFNBQVMsQ0FBQzVsQixTQUFTO0lBQ3hEaUUsS0FBS21kLFVBQVUsQ0FBQ21OLGNBQWMsR0FBR3RxQixLQUFLMmhCLFNBQVMsQ0FBQzNsQixVQUFVO0FBQzlEO0FBQ0EydUIsU0FBU2UsT0FBTyxHQUFHLENBQUMxckIsTUFBTXVKO0lBQ3RCdkosS0FBS21kLFVBQVUsQ0FBQzBNLGtCQUFrQixDQUFDO0lBQ25DLElBQUl0Z0IsTUFBTXBMLE9BQU8sSUFBSSxJQUNqQjZCLEtBQUttZCxVQUFVLENBQUNxTixZQUFZLEdBQUc3TixLQUFLQyxHQUFHO0lBQzNDLE9BQU87QUFDWDtBQUNBZ1AsVUFBVXFFLFVBQVUsR0FBRyxDQUFDandCLE1BQU1vWjtJQUMxQnBaLEtBQUttZCxVQUFVLENBQUNnTixhQUFhLEdBQUd4TixLQUFLQyxHQUFHO0lBQ3hDNWMsS0FBS21kLFVBQVUsQ0FBQzBNLGtCQUFrQixDQUFDO0FBQ3ZDO0FBQ0ErQixVQUFVc0UsU0FBUyxHQUFHbHdCLENBQUFBO0lBQ2xCQSxLQUFLbWQsVUFBVSxDQUFDME0sa0JBQWtCLENBQUM7QUFDdkM7QUFDQWMsU0FBU3dGLFNBQVMsR0FBRyxDQUFDbndCLE1BQU11SjtJQUN4QnZKLEtBQUtrZSxRQUFRLENBQUNrUyxLQUFLO0lBQ25CLElBQUlwd0IsS0FBS21kLFVBQVUsQ0FBQ2dOLGFBQWEsR0FBR3hOLEtBQUtDLEdBQUcsS0FBSyxNQUM3QyxPQUFPLE9BQU8sMkJBQTJCO0lBQzdDLElBQUlyWCxRQUFRO0lBQ1osS0FBSyxJQUFJOHFCLGFBQWFyd0IsS0FBS3lKLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ25CLHFCQUFzQjtRQUN6RG5SLFFBQVE4cUIsVUFBVXJ3QixNQUFNdUo7UUFDeEIsSUFBSWhFLE9BQ0E7SUFDUjtJQUNBLElBQUksQ0FBQ0EsU0FBU2dFLE1BQU0rbUIsTUFBTSxJQUFJLEdBQzFCL3FCLFFBQVFnckIsb0JBQW9CdndCLE1BQU11SjtJQUN0QyxJQUFJaEUsT0FBTztRQUNQLElBQUlpckIsWUFBWSxDQUFDeHdCLEtBQUtxckIsUUFBUTtRQUM5QnJyQixLQUFLbWQsVUFBVSxDQUFDNlAsbUJBQW1CLENBQUMsSUFBSVEsZUFBZXh0QixNQUFNdUosT0FBT2hFLE9BQU9pckI7UUFDM0UsSUFBSUEsV0FDQXh3QixLQUFLa2UsUUFBUSxDQUFDeFQsTUFBTSxDQUFDLElBQU0zTixtQkFBbUJpRCxLQUFLNmMsVUFBVTtRQUNqRSxJQUFJNFQsV0FBV3p3QixLQUFLbWQsVUFBVSxDQUFDNk4sY0FBYztRQUM3QyxJQUFJeUYsVUFBVTtZQUNWQSxTQUFTMzBCLEtBQUssQ0FBQ3lOO1lBQ2YsT0FBT2tuQixTQUFTdEMsUUFBUSxLQUFLO1FBQ2pDO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTdUMsY0FBYzF3QixJQUFJLEVBQUVDLEdBQUcsRUFBRW9CLElBQUksRUFBRTJOLElBQUk7SUFDeEMsSUFBSUEsUUFBUSxHQUFHO1FBQ1gsT0FBTzlaLDhEQUFlQSxDQUFDaWIsTUFBTSxDQUFDbFEsS0FBS29CO0lBQ3ZDLE9BQ0ssSUFBSTJOLFFBQVEsR0FBRztRQUNoQixPQUFPaVYsUUFBUWprQixLQUFLeUosS0FBSyxFQUFFeEosS0FBS29CO0lBQ3BDLE9BQ0s7UUFDRCxJQUFJc3ZCLFNBQVN0bEIsU0FBU3pDLElBQUksQ0FBQzVJLEtBQUtpTixPQUFPLEVBQUVoTixNQUFNa08sT0FBT25PLEtBQUt5SixLQUFLLENBQUN6UyxHQUFHLENBQUN1WixNQUFNLENBQUNvZ0IsU0FBU0EsT0FBTzV3QixRQUFRLEdBQUdFO1FBQ3ZHLElBQUl6QyxPQUFPbXpCLFNBQVNBLE9BQU85d0IsVUFBVSxHQUFHc08sS0FBSzNRLElBQUksRUFBRUMsS0FBS2t6QixTQUFTQSxPQUFPNXdCLFFBQVEsR0FBR29PLEtBQUsxUSxFQUFFO1FBQzFGLElBQUlBLEtBQUt1QyxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDVyxNQUFNLElBQUk4RixNQUFNMFEsS0FBSzFRLEVBQUUsRUFDM0NBO1FBQ0osT0FBT3ZJLDhEQUFlQSxDQUFDeUgsS0FBSyxDQUFDYSxNQUFNQztJQUN2QztBQUNKO0FBQ0EsSUFBSW16QixVQUFVLENBQUMxMkIsR0FBR3RCLE9BQVNzQixLQUFLdEIsS0FBS0ksR0FBRyxJQUFJa0IsS0FBS3RCLEtBQUtLLE1BQU07QUFDNUQsSUFBSThxQixTQUFTLENBQUNqckIsR0FBR29CLEdBQUd0QixPQUFTZzRCLFFBQVExMkIsR0FBR3RCLFNBQVNFLEtBQUtGLEtBQUtDLElBQUksSUFBSUMsS0FBS0YsS0FBS0csS0FBSztBQUNsRixtRUFBbUU7QUFDbkUsb0VBQW9FO0FBQ3BFLGtDQUFrQztBQUNsQyxTQUFTODNCLGlCQUFpQjd3QixJQUFJLEVBQUVDLEdBQUcsRUFBRW5ILENBQUMsRUFBRW9CLENBQUM7SUFDckMsSUFBSWlVLE9BQU85QyxTQUFTekMsSUFBSSxDQUFDNUksS0FBS2lOLE9BQU8sRUFBRWhOO0lBQ3ZDLElBQUksQ0FBQ2tPLE1BQ0QsT0FBTztJQUNYLElBQUlyVyxNQUFNbUksTUFBTWtPLEtBQUt0TyxVQUFVO0lBQy9CLHNDQUFzQztJQUN0QyxJQUFJL0gsT0FBTyxHQUNQLE9BQU87SUFDWCxJQUFJQSxPQUFPcVcsS0FBS3hXLE1BQU0sRUFDbEIsT0FBTyxDQUFDO0lBQ1osdURBQXVEO0lBQ3ZELElBQUk0SCxTQUFTNE8sS0FBSzNHLFFBQVEsQ0FBQzFQLEtBQUssQ0FBQztJQUNqQyxJQUFJeUgsVUFBVXdrQixPQUFPanJCLEdBQUdvQixHQUFHcUYsU0FDdkIsT0FBTyxDQUFDO0lBQ1osSUFBSUMsUUFBUTJPLEtBQUszRyxRQUFRLENBQUMxUCxLQUFLO0lBQy9CLElBQUkwSCxTQUFTdWtCLE9BQU9qckIsR0FBR29CLEdBQUdzRixRQUN0QixPQUFPO0lBQ1gsa0VBQWtFO0lBQ2xFLGFBQWE7SUFDYixPQUFPRCxVQUFVcXhCLFFBQVExMkIsR0FBR3FGLFVBQVUsQ0FBQyxJQUFJO0FBQy9DO0FBQ0EsU0FBU3V4QixTQUFTOXdCLElBQUksRUFBRXVKLEtBQUs7SUFDekIsSUFBSXRKLE1BQU1ELEtBQUs2bEIsV0FBVyxDQUFDO1FBQUUvc0IsR0FBR3lRLE1BQU0rakIsT0FBTztRQUFFcHpCLEdBQUdxUCxNQUFNZ2tCLE9BQU87SUFBQyxHQUFHO0lBQ25FLE9BQU87UUFBRXR0QjtRQUFLb0IsTUFBTXd2QixpQkFBaUI3d0IsTUFBTUMsS0FBS3NKLE1BQU0rakIsT0FBTyxFQUFFL2pCLE1BQU1na0IsT0FBTztJQUFFO0FBQ2xGO0FBQ0EsTUFBTXdELGlCQUFpQjVxQixRQUFRUCxFQUFFLElBQUlPLFFBQVFJLFVBQVUsSUFBSTtBQUMzRCxJQUFJeXFCLGdCQUFnQixNQUFNQyxxQkFBcUIsR0FBR0Msb0JBQW9CO0FBQ3RFLFNBQVM3QyxhQUFhOWtCLEtBQUs7SUFDdkIsSUFBSSxDQUFDd25CLGdCQUNELE9BQU94bkIsTUFBTTRuQixNQUFNO0lBQ3ZCLElBQUl4c0IsT0FBT3FzQixlQUFlSSxXQUFXRjtJQUNyQ0YsZ0JBQWdCem5CO0lBQ2hCMm5CLG9CQUFvQnZVLEtBQUtDLEdBQUc7SUFDNUIsT0FBT3FVLHFCQUFxQixDQUFDdHNCLFFBQVN5c0IsV0FBV3pVLEtBQUtDLEdBQUcsS0FBSyxPQUFPOWlCLEtBQUtDLEdBQUcsQ0FBQzRLLEtBQUsyb0IsT0FBTyxHQUFHL2pCLE1BQU0rakIsT0FBTyxJQUFJLEtBQzFHeHpCLEtBQUtDLEdBQUcsQ0FBQzRLLEtBQUs0b0IsT0FBTyxHQUFHaGtCLE1BQU1na0IsT0FBTyxJQUFJLElBQUssQ0FBQzBELHFCQUFxQixLQUFLLElBQUk7QUFDckY7QUFDQSxTQUFTVixvQkFBb0J2d0IsSUFBSSxFQUFFdUosS0FBSztJQUNwQyxJQUFJek4sUUFBUWcxQixTQUFTOXdCLE1BQU11SixRQUFReUYsT0FBT3FmLGFBQWE5a0I7SUFDdkQsSUFBSThuQixXQUFXcnhCLEtBQUt5SixLQUFLLENBQUNwUyxTQUFTO0lBQ25DLE9BQU87UUFDSDhoQixRQUFPQSxNQUFNO1lBQ1QsSUFBSUEsT0FBT3lDLFVBQVUsRUFBRTtnQkFDbkI5ZixNQUFNbUUsR0FBRyxHQUFHa1osT0FBTzdCLE9BQU8sQ0FBQzJGLE1BQU0sQ0FBQ25oQixNQUFNbUUsR0FBRztnQkFDM0NveEIsV0FBV0EsU0FBU2hhLEdBQUcsQ0FBQzhCLE9BQU83QixPQUFPO1lBQzFDO1FBQ0o7UUFDQXpXLEtBQUkwSSxLQUFLLEVBQUVpWCxNQUFNLEVBQUV3TixRQUFRO1lBQ3ZCLElBQUl4ekIsTUFBTXMyQixTQUFTOXdCLE1BQU11SixRQUFRK25CO1lBQ2pDLElBQUkzMEIsUUFBUSt6QixjQUFjMXdCLE1BQU14RixJQUFJeUYsR0FBRyxFQUFFekYsSUFBSTZHLElBQUksRUFBRTJOO1lBQ25ELElBQUlsVCxNQUFNbUUsR0FBRyxJQUFJekYsSUFBSXlGLEdBQUcsSUFBSSxDQUFDdWdCLFFBQVE7Z0JBQ2pDLElBQUkrUSxhQUFhYixjQUFjMXdCLE1BQU1sRSxNQUFNbUUsR0FBRyxFQUFFbkUsTUFBTXVGLElBQUksRUFBRTJOO2dCQUM1RCxJQUFJeFIsT0FBTzFELEtBQUsrQyxHQUFHLENBQUMwMEIsV0FBVy96QixJQUFJLEVBQUViLE1BQU1hLElBQUksR0FBR0MsS0FBSzNELEtBQUtzRixHQUFHLENBQUNteUIsV0FBVzl6QixFQUFFLEVBQUVkLE1BQU1jLEVBQUU7Z0JBQ3ZGZCxRQUFRYSxPQUFPYixNQUFNYSxJQUFJLEdBQUd0SSw4REFBZUEsQ0FBQ3lILEtBQUssQ0FBQ2EsTUFBTUMsTUFBTXZJLDhEQUFlQSxDQUFDeUgsS0FBSyxDQUFDYyxJQUFJRDtZQUM1RjtZQUNBLElBQUlnakIsUUFDQSxPQUFPNlEsU0FBUy9zQixZQUFZLENBQUMrc0IsU0FBUzlULElBQUksQ0FBQ2lELE1BQU0sQ0FBQzdqQixNQUFNYSxJQUFJLEVBQUViLE1BQU1jLEVBQUU7aUJBQ3JFLElBQUl1d0IsWUFBWWhmLFFBQVEsS0FBS3FpQixTQUFTNWhCLE1BQU0sQ0FBQzlYLE1BQU0sR0FBRyxLQUFNMjVCLENBQUFBLFVBQVVFLGtCQUFrQkgsVUFBVTcyQixJQUFJeUYsR0FBRyxJQUMxRyxPQUFPcXhCO2lCQUNOLElBQUl0RCxVQUNMLE9BQU9xRCxTQUFTN2hCLFFBQVEsQ0FBQzdTO2lCQUV6QixPQUFPekgsOERBQWVBLENBQUM4VCxNQUFNLENBQUM7Z0JBQUNyTTthQUFNO1FBQzdDO0lBQ0o7QUFDSjtBQUNBLFNBQVM2MEIsa0JBQWtCN1EsR0FBRyxFQUFFMWdCLEdBQUc7SUFDL0IsSUFBSyxJQUFJM0MsSUFBSSxHQUFHQSxJQUFJcWpCLElBQUlsUixNQUFNLENBQUM5WCxNQUFNLEVBQUUyRixJQUFLO1FBQ3hDLElBQUksRUFBRUUsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBR2tqQixJQUFJbFIsTUFBTSxDQUFDblMsRUFBRTtRQUNoQyxJQUFJRSxRQUFReUMsT0FBT3hDLE1BQU13QyxLQUNyQixPQUFPL0ssOERBQWVBLENBQUM4VCxNQUFNLENBQUMyWCxJQUFJbFIsTUFBTSxDQUFDdEksS0FBSyxDQUFDLEdBQUc3SixHQUFHd2hCLE1BQU0sQ0FBQzZCLElBQUlsUixNQUFNLENBQUN0SSxLQUFLLENBQUM3SixJQUFJLEtBQUtxakIsSUFBSW9PLFNBQVMsSUFBSXp4QixJQUFJLElBQUlxakIsSUFBSW9PLFNBQVMsR0FBSXBPLENBQUFBLElBQUlvTyxTQUFTLEdBQUd6eEIsSUFBSSxJQUFJO0lBQ2hLO0lBQ0EsT0FBTztBQUNYO0FBQ0FxdEIsU0FBUzhHLFNBQVMsR0FBRyxDQUFDenhCLE1BQU11SjtJQUN4QixJQUFJLEVBQUVsUyxXQUFXLEVBQUVrbUIsTUFBTTVnQixLQUFLLEVBQUUsRUFBRSxHQUFHcUQsS0FBS3lKLEtBQUs7SUFDL0MsSUFBSUYsTUFBTS9TLE1BQU0sQ0FBQ2s3QixTQUFTLEVBQUU7UUFDeEIsSUFBSW5ULFFBQVF2ZSxLQUFLaU4sT0FBTyxDQUFDaVUsT0FBTyxDQUFDM1gsTUFBTS9TLE1BQU07UUFDN0MsSUFBSStuQixTQUFTQSxNQUFNN2EsUUFBUSxFQUFFO1lBQ3pCLElBQUlsRyxPQUFPK2dCLE1BQU0xZSxVQUFVLEVBQUVwQyxLQUFLRCxPQUFPK2dCLE1BQU01bUIsTUFBTTtZQUNyRCxJQUFJNkYsUUFBUWIsTUFBTWMsRUFBRSxJQUFJQSxNQUFNZCxNQUFNYSxJQUFJLEVBQ3BDYixRQUFRekgsOERBQWVBLENBQUN5SCxLQUFLLENBQUNhLE1BQU1DO1FBQzVDO0lBQ0o7SUFDQSxJQUFJLEVBQUUwZixVQUFVLEVBQUUsR0FBR25kO0lBQ3JCLElBQUltZCxXQUFXNk4sY0FBYyxFQUN6QjdOLFdBQVc2TixjQUFjLENBQUNtRCxRQUFRLEdBQUc7SUFDekNoUixXQUFXOE4sY0FBYyxHQUFHdHVCO0lBQzVCLElBQUk0TSxNQUFNb29CLFlBQVksRUFBRTtRQUNwQnBvQixNQUFNb29CLFlBQVksQ0FBQ0MsT0FBTyxDQUFDLFFBQVE1eEIsS0FBS3lKLEtBQUssQ0FBQzhkLFFBQVEsQ0FBQzVxQixNQUFNYSxJQUFJLEVBQUViLE1BQU1jLEVBQUU7UUFDM0U4TCxNQUFNb29CLFlBQVksQ0FBQ0UsYUFBYSxHQUFHO0lBQ3ZDO0lBQ0EsT0FBTztBQUNYO0FBQ0FsSCxTQUFTbUgsT0FBTyxHQUFHOXhCLENBQUFBO0lBQ2ZBLEtBQUttZCxVQUFVLENBQUM4TixjQUFjLEdBQUc7SUFDakMsT0FBTztBQUNYO0FBQ0EsU0FBUzhHLFNBQVMveEIsSUFBSSxFQUFFdUosS0FBSyxFQUFFL0YsSUFBSSxFQUFFd3VCLE1BQU07SUFDdkMsSUFBSSxDQUFDeHVCLE1BQ0Q7SUFDSixJQUFJeXVCLFVBQVVqeUIsS0FBSzZsQixXQUFXLENBQUM7UUFBRS9zQixHQUFHeVEsTUFBTStqQixPQUFPO1FBQUVwekIsR0FBR3FQLE1BQU1na0IsT0FBTztJQUFDLEdBQUc7SUFDdkUsSUFBSSxFQUFFdEMsY0FBYyxFQUFFLEdBQUdqckIsS0FBS21kLFVBQVU7SUFDeEMsSUFBSStVLE1BQU1GLFVBQVUvRyxrQkFBa0JpRSxtQkFBbUJsdkIsTUFBTXVKLFNBQ3pEO1FBQUUvTCxNQUFNeXRCLGVBQWV6dEIsSUFBSTtRQUFFQyxJQUFJd3RCLGVBQWV4dEIsRUFBRTtJQUFDLElBQUk7SUFDN0QsSUFBSTAwQixNQUFNO1FBQUUzMEIsTUFBTXkwQjtRQUFTeHRCLFFBQVFqQjtJQUFLO0lBQ3hDLElBQUk4VCxVQUFVdFgsS0FBS3lKLEtBQUssQ0FBQzZOLE9BQU8sQ0FBQzRhLE1BQU07UUFBQ0E7UUFBS0M7S0FBSSxHQUFHQTtJQUNwRG55QixLQUFLL0MsS0FBSztJQUNWK0MsS0FBS2d2QixRQUFRLENBQUM7UUFDVjFYO1FBQ0FqZ0IsV0FBVztZQUFFc29CLFFBQVFySSxRQUFRMkYsTUFBTSxDQUFDZ1YsU0FBUyxDQUFDO1lBQUlsYyxNQUFNdUIsUUFBUTJGLE1BQU0sQ0FBQ2dWLFNBQVM7UUFBRztRQUNuRmhELFdBQVdpRCxNQUFNLGNBQWM7SUFDbkM7SUFDQWx5QixLQUFLbWQsVUFBVSxDQUFDOE4sY0FBYyxHQUFHO0FBQ3JDO0FBQ0FOLFNBQVN5SCxJQUFJLEdBQUcsQ0FBQ3B5QixNQUFNdUo7SUFDbkIsSUFBSSxDQUFDQSxNQUFNb29CLFlBQVksRUFDbkIsT0FBTztJQUNYLElBQUkzeEIsS0FBS3lKLEtBQUssQ0FBQzRvQixRQUFRLEVBQ25CLE9BQU87SUFDWCxJQUFJQyxRQUFRL29CLE1BQU1vb0IsWUFBWSxDQUFDVyxLQUFLO0lBQ3BDLElBQUlBLFNBQVNBLE1BQU0zNkIsTUFBTSxFQUFFO1FBQ3ZCLElBQUk2TCxPQUFPbUYsTUFBTTJwQixNQUFNMzZCLE1BQU0sR0FBRzQ2QixPQUFPO1FBQ3ZDLElBQUlDLGFBQWE7WUFDYixJQUFJLEVBQUVELFFBQVFELE1BQU0zNkIsTUFBTSxFQUN0Qm82QixTQUFTL3hCLE1BQU11SixPQUFPL0YsS0FBS2l2QixNQUFNLENBQUNDLENBQUFBLElBQUtBLEtBQUssTUFBTW52QixJQUFJLENBQUN2RCxLQUFLeUosS0FBSyxDQUFDc0gsU0FBUyxHQUFHO1FBQ3RGO1FBQ0EsSUFBSyxJQUFJelQsSUFBSSxHQUFHQSxJQUFJZzFCLE1BQU0zNkIsTUFBTSxFQUFFMkYsSUFBSztZQUNuQyxJQUFJcTFCLFNBQVMsSUFBSUM7WUFDakJELE9BQU83YSxPQUFPLEdBQUcwYTtZQUNqQkcsT0FBT0UsTUFBTSxHQUFHO2dCQUNaLElBQUksQ0FBQywwQkFBMEJqNEIsSUFBSSxDQUFDKzNCLE9BQU92ckIsTUFBTSxHQUM3QzVELElBQUksQ0FBQ2xHLEVBQUUsR0FBR3ExQixPQUFPdnJCLE1BQU07Z0JBQzNCb3JCO1lBQ0o7WUFDQUcsT0FBT0csVUFBVSxDQUFDUixLQUFLLENBQUNoMUIsRUFBRTtRQUM5QjtRQUNBLE9BQU87SUFDWCxPQUNLO1FBQ0QsSUFBSWtHLE9BQU8rRixNQUFNb29CLFlBQVksQ0FBQ29CLE9BQU8sQ0FBQztRQUN0QyxJQUFJdnZCLE1BQU07WUFDTnV1QixTQUFTL3hCLE1BQU11SixPQUFPL0YsTUFBTTtZQUM1QixPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBbW5CLFNBQVNxSSxLQUFLLEdBQUcsQ0FBQ2h6QixNQUFNdUo7SUFDcEIsSUFBSXZKLEtBQUt5SixLQUFLLENBQUM0b0IsUUFBUSxFQUNuQixPQUFPO0lBQ1hyeUIsS0FBS2tlLFFBQVEsQ0FBQ2tTLEtBQUs7SUFDbkIsSUFBSTZDLE9BQU8zRCxxQkFBcUIsT0FBTy9sQixNQUFNMnBCLGFBQWE7SUFDMUQsSUFBSUQsTUFBTTtRQUNOekQsUUFBUXh2QixNQUFNaXpCLEtBQUtGLE9BQU8sQ0FBQyxpQkFBaUJFLEtBQUtGLE9BQU8sQ0FBQztRQUN6RCxPQUFPO0lBQ1gsT0FDSztRQUNEeEQsYUFBYXZ2QjtRQUNiLE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU216QixZQUFZbnpCLElBQUksRUFBRXdELElBQUk7SUFDM0IsbUVBQW1FO0lBQ25FLCtEQUErRDtJQUMvRCxJQUFJaEwsU0FBU3dILEtBQUtwSixHQUFHLENBQUNFLFVBQVU7SUFDaEMsSUFBSSxDQUFDMEIsUUFDRDtJQUNKLElBQUloQyxTQUFTZ0MsT0FBTzhULFdBQVcsQ0FBQzVPLFNBQVMwSyxhQUFhLENBQUM7SUFDdkQ1UixPQUFPK08sS0FBSyxDQUFDeUYsT0FBTyxHQUFHO0lBQ3ZCeFUsT0FBTzRVLEtBQUssR0FBRzVIO0lBQ2ZoTixPQUFPeUcsS0FBSztJQUNaekcsT0FBTzQ4QixZQUFZLEdBQUc1dkIsS0FBSzdMLE1BQU07SUFDakNuQixPQUFPNjhCLGNBQWMsR0FBRztJQUN4QnhHLFdBQVc7UUFDUHIyQixPQUFPMHJCLE1BQU07UUFDYmxpQixLQUFLL0MsS0FBSztJQUNkLEdBQUc7QUFDUDtBQUNBLFNBQVNxMkIsWUFBWTdwQixLQUFLO0lBQ3RCLElBQUlvRyxVQUFVLEVBQUUsRUFBRUosU0FBUyxFQUFFLEVBQUVtZ0IsV0FBVztJQUMxQyxLQUFLLElBQUlqekIsU0FBUzhNLE1BQU1wUyxTQUFTLENBQUNvWSxNQUFNLENBQ3BDLElBQUksQ0FBQzlTLE1BQU02TSxLQUFLLEVBQUU7UUFDZHFHLFFBQVExUyxJQUFJLENBQUNzTSxNQUFNOGQsUUFBUSxDQUFDNXFCLE1BQU1hLElBQUksRUFBRWIsTUFBTWMsRUFBRTtRQUNoRGdTLE9BQU90UyxJQUFJLENBQUNSO0lBQ2hCO0lBQ0osSUFBSSxDQUFDa1QsUUFBUWxZLE1BQU0sRUFBRTtRQUNqQix3Q0FBd0M7UUFDeEMsSUFBSTRkLE9BQU8sQ0FBQztRQUNaLEtBQUssSUFBSSxFQUFFL1gsSUFBSSxFQUFFLElBQUlpTSxNQUFNcFMsU0FBUyxDQUFDb1ksTUFBTSxDQUFFO1lBQ3pDLElBQUl0QixPQUFPMUUsTUFBTXpTLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQy9TO1lBQzVCLElBQUkyUSxLQUFLaWEsTUFBTSxHQUFHN1MsTUFBTTtnQkFDcEIxRixRQUFRMVMsSUFBSSxDQUFDZ1IsS0FBSzNLLElBQUk7Z0JBQ3RCaU0sT0FBT3RTLElBQUksQ0FBQztvQkFBRUssTUFBTTJRLEtBQUszUSxJQUFJO29CQUFFQyxJQUFJM0QsS0FBSytDLEdBQUcsQ0FBQzRNLE1BQU16UyxHQUFHLENBQUNXLE1BQU0sRUFBRXdXLEtBQUsxUSxFQUFFLEdBQUc7Z0JBQUc7WUFDL0U7WUFDQThYLE9BQU9wSCxLQUFLaWEsTUFBTTtRQUN0QjtRQUNBd0gsV0FBVztJQUNmO0lBQ0EsT0FBTztRQUFFcHNCLE1BQU1xTSxRQUFRdE0sSUFBSSxDQUFDa0csTUFBTXNILFNBQVM7UUFBR3RCO1FBQVFtZ0I7SUFBUztBQUNuRTtBQUNBLElBQUlDLG1CQUFtQjtBQUN2QmxGLFNBQVM0SSxJQUFJLEdBQUc1SSxTQUFTNkksR0FBRyxHQUFHLENBQUN4ekIsTUFBTXVKO0lBQ2xDLElBQUksRUFBRS9GLElBQUksRUFBRWlNLE1BQU0sRUFBRW1nQixRQUFRLEVBQUUsR0FBRzBELFlBQVl0ekIsS0FBS3lKLEtBQUs7SUFDdkQsSUFBSSxDQUFDakcsUUFBUSxDQUFDb3NCLFVBQ1YsT0FBTztJQUNYQyxtQkFBbUJELFdBQVdwc0IsT0FBTztJQUNyQyxJQUFJK0YsTUFBTXlGLElBQUksSUFBSSxTQUFTLENBQUNoUCxLQUFLeUosS0FBSyxDQUFDNG9CLFFBQVEsRUFDM0NyeUIsS0FBS2d2QixRQUFRLENBQUM7UUFDVjFYLFNBQVM3SDtRQUNUK0gsZ0JBQWdCO1FBQ2hCeVgsV0FBVztJQUNmO0lBQ0osSUFBSWdFLE9BQU8zRCxxQkFBcUIsT0FBTy9sQixNQUFNMnBCLGFBQWE7SUFDMUQsSUFBSUQsTUFBTTtRQUNOQSxLQUFLUSxTQUFTO1FBQ2RSLEtBQUtyQixPQUFPLENBQUMsY0FBY3B1QjtRQUMzQixPQUFPO0lBQ1gsT0FDSztRQUNEMnZCLFlBQVluekIsTUFBTXdEO1FBQ2xCLE9BQU87SUFDWDtBQUNKO0FBQ0EsTUFBTWt3QixnQkFBZ0IsV0FBVyxHQUFFbCtCLHlEQUFVQSxDQUFDZ2hCLE1BQU07QUFDcEQsU0FBU21kLHVCQUF1QmxxQixLQUFLLEVBQUV4TSxLQUFLO0lBQ3hDLElBQUkyMkIsVUFBVSxFQUFFO0lBQ2hCLEtBQUssSUFBSUMsYUFBYXBxQixNQUFNb08sS0FBSyxDQUFDZixtQkFBb0I7UUFDbEQsSUFBSWdkLFNBQVNELFVBQVVwcUIsT0FBT3hNO1FBQzlCLElBQUk2MkIsUUFDQUYsUUFBUXoyQixJQUFJLENBQUMyMkI7SUFDckI7SUFDQSxPQUFPRixVQUFVbnFCLE1BQU0wUCxNQUFNLENBQUM7UUFBRXlhO1FBQVNHLGFBQWFMLGNBQWNybEIsRUFBRSxDQUFDO0lBQU0sS0FBSztBQUN0RjtBQUNBLFNBQVMybEIscUJBQXFCaDBCLElBQUk7SUFDOUI2c0IsV0FBVztRQUNQLElBQUk1dkIsUUFBUStDLEtBQUtxckIsUUFBUTtRQUN6QixJQUFJcHVCLFNBQVMrQyxLQUFLbWQsVUFBVSxDQUFDaU8sZUFBZSxFQUFFO1lBQzFDLElBQUkvUCxLQUFLc1ksdUJBQXVCM3pCLEtBQUt5SixLQUFLLEVBQUV4TTtZQUM1QyxJQUFJb2UsSUFDQXJiLEtBQUtndkIsUUFBUSxDQUFDM1Q7aUJBRWRyYixLQUFLbVosTUFBTSxDQUFDLEVBQUU7UUFDdEI7SUFDSixHQUFHO0FBQ1A7QUFDQXlTLFVBQVUzdUIsS0FBSyxHQUFHK0MsQ0FBQUE7SUFDZEEsS0FBS21kLFVBQVUsQ0FBQ2lOLGFBQWEsR0FBR3pOLEtBQUtDLEdBQUc7SUFDeEMsd0VBQXdFO0lBQ3hFLElBQUksQ0FBQzVjLEtBQUsyaEIsU0FBUyxDQUFDNWxCLFNBQVMsSUFBS2lFLENBQUFBLEtBQUttZCxVQUFVLENBQUNrTixhQUFhLElBQUlycUIsS0FBS21kLFVBQVUsQ0FBQ21OLGNBQWMsR0FBRztRQUNoR3RxQixLQUFLMmhCLFNBQVMsQ0FBQzVsQixTQUFTLEdBQUdpRSxLQUFLbWQsVUFBVSxDQUFDa04sYUFBYTtRQUN4RHJxQixLQUFLMmhCLFNBQVMsQ0FBQzNsQixVQUFVLEdBQUdnRSxLQUFLbWQsVUFBVSxDQUFDbU4sY0FBYztJQUM5RDtJQUNBMEoscUJBQXFCaDBCO0FBQ3pCO0FBQ0E0ckIsVUFBVTNMLElBQUksR0FBR2pnQixDQUFBQTtJQUNiQSxLQUFLa2UsUUFBUSxDQUFDK1YsbUJBQW1CO0lBQ2pDRCxxQkFBcUJoMEI7QUFDekI7QUFDQTRyQixVQUFVc0ksZ0JBQWdCLEdBQUd0SSxVQUFVdUksaUJBQWlCLEdBQUduMEIsQ0FBQUE7SUFDdkQsSUFBSUEsS0FBS21kLFVBQVUsQ0FBQ3lOLHNCQUFzQixJQUFJLE1BQzFDNXFCLEtBQUttZCxVQUFVLENBQUN5TixzQkFBc0IsR0FBRztJQUM3QyxJQUFJNXFCLEtBQUttZCxVQUFVLENBQUNDLFNBQVMsR0FBRyxHQUFHO1FBQy9CLDREQUE0RDtRQUM1RHBkLEtBQUttZCxVQUFVLENBQUNDLFNBQVMsR0FBRztJQUNoQztBQUNKO0FBQ0F3TyxVQUFVd0ksY0FBYyxHQUFHcDBCLENBQUFBO0lBQ3ZCQSxLQUFLbWQsVUFBVSxDQUFDQyxTQUFTLEdBQUcsQ0FBQztJQUM3QnBkLEtBQUttZCxVQUFVLENBQUMwTixrQkFBa0IsR0FBR2xPLEtBQUtDLEdBQUc7SUFDN0M1YyxLQUFLbWQsVUFBVSxDQUFDMk4scUJBQXFCLEdBQUc7SUFDeEM5cUIsS0FBS21kLFVBQVUsQ0FBQzROLHdCQUF3QixHQUFHL3FCLEtBQUtrZSxRQUFRLENBQUNtVyxjQUFjLEdBQUcxOEIsTUFBTSxHQUFHO0lBQ25GcUksS0FBS21kLFVBQVUsQ0FBQ3lOLHNCQUFzQixHQUFHO0lBQ3pDLElBQUl6a0IsUUFBUUwsTUFBTSxJQUFJSyxRQUFRUSxPQUFPLEVBQUU7UUFDbkMsaUVBQWlFO1FBQ2pFLCtEQUErRDtRQUMvRDNHLEtBQUtrZSxRQUFRLENBQUNvVyxTQUFTO0lBQzNCLE9BQ0ssSUFBSXQwQixLQUFLbWQsVUFBVSxDQUFDNE4sd0JBQXdCLEVBQUU7UUFDL0MsaURBQWlEO1FBQ2pEd0osUUFBUUMsT0FBTyxHQUFHQyxJQUFJLENBQUMsSUFBTXowQixLQUFLa2UsUUFBUSxDQUFDa1MsS0FBSztJQUNwRCxPQUNLO1FBQ0QsNkRBQTZEO1FBQzdELCtCQUErQjtRQUMvQnZELFdBQVc7WUFDUCxJQUFJN3NCLEtBQUttZCxVQUFVLENBQUNDLFNBQVMsR0FBRyxLQUFLcGQsS0FBS2lOLE9BQU8sQ0FBQ2dQLGNBQWMsRUFDNURqYyxLQUFLbVosTUFBTSxDQUFDLEVBQUU7UUFDdEIsR0FBRztJQUNQO0FBQ0o7QUFDQXlTLFVBQVU4SSxXQUFXLEdBQUcxMEIsQ0FBQUE7SUFDcEJBLEtBQUttZCxVQUFVLENBQUNzTixlQUFlLEdBQUc5TixLQUFLQyxHQUFHO0FBQzlDO0FBQ0ErTixTQUFTZ0ssV0FBVyxHQUFHLENBQUMzMEIsTUFBTXVKO0lBQzFCLElBQUl5QztJQUNKLDZEQUE2RDtJQUM3RCxrRUFBa0U7SUFDbEUsa0VBQWtFO0lBQ2xFLDJDQUEyQztJQUMzQyxFQUFFO0lBQ0YsZ0VBQWdFO0lBQ2hFLHlDQUF5QztJQUN6QyxJQUFJc2dCO0lBQ0osSUFBSW5tQixRQUFRTCxNQUFNLElBQUlLLFFBQVFRLE9BQU8sSUFBSzJsQixDQUFBQSxVQUFVRyxZQUFZN2pCLElBQUksQ0FBQzFLLENBQUFBLE1BQU9BLElBQUlpdkIsU0FBUyxJQUFJNWpCLE1BQU00akIsU0FBUyxJQUFJO1FBQzVHbnRCLEtBQUtrZSxRQUFRLENBQUNtTyxlQUFlLENBQUNDLFFBQVFwdUIsR0FBRyxFQUFFb3VCLFFBQVFudUIsT0FBTztRQUMxRCxJQUFJbXVCLFFBQVFwdUIsR0FBRyxJQUFJLGVBQWVvdUIsUUFBUXB1QixHQUFHLElBQUksVUFBVTtZQUN2RCxJQUFJMDJCLGtCQUFrQixDQUFDLENBQUM1b0IsS0FBS3pSLE9BQU9zNkIsY0FBYyxNQUFNLFFBQVE3b0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHclMsTUFBTSxLQUFLO1lBQ3ZHa3pCLFdBQVc7Z0JBQ1AsSUFBSTdnQjtnQkFDSixnRUFBZ0U7Z0JBQ2hFLDREQUE0RDtnQkFDNUQsbUNBQW1DO2dCQUNuQyxJQUFJLENBQUMsQ0FBQyxDQUFDQSxLQUFLelIsT0FBT3M2QixjQUFjLE1BQU0sUUFBUTdvQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdyUyxNQUFNLEtBQUssS0FBS2k3QixrQkFBa0IsTUFBTTUwQixLQUFLcXJCLFFBQVEsRUFBRTtvQkFDOUhyckIsS0FBSzZjLFVBQVUsQ0FBQ29ELElBQUk7b0JBQ3BCamdCLEtBQUsvQyxLQUFLO2dCQUNkO1lBQ0osR0FBRztRQUNQO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQSxNQUFNNjNCLHFCQUFxQixXQUFXLEdBQUUsSUFBSTNZO0FBQzVDLHFFQUFxRTtBQUNyRSxnRUFBZ0U7QUFDaEUsd0VBQXdFO0FBQ3hFLDBEQUEwRDtBQUMxRCxTQUFTb1AsbUJBQW1CdjBCLEdBQUc7SUFDM0IsSUFBSSxDQUFDODlCLG1CQUFtQkMsR0FBRyxDQUFDLzlCLE1BQU07UUFDOUI4OUIsbUJBQW1CNW9CLEdBQUcsQ0FBQ2xWO1FBQ3ZCQSxJQUFJczBCLGdCQUFnQixDQUFDLFFBQVEsS0FBUTtRQUNyQ3QwQixJQUFJczBCLGdCQUFnQixDQUFDLE9BQU8sS0FBUTtJQUN4QztBQUNKO0FBRUEsTUFBTTBKLHFCQUFxQjtJQUFDO0lBQVk7SUFBVTtJQUFZO0NBQWU7QUFDN0UsTUFBTUM7SUFDRjc0QixZQUFZK3FCLFlBQVksQ0FBRTtRQUN0QixJQUFJLENBQUNBLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDbndCLEdBQUcsR0FBR25DLG1EQUFJQSxDQUFDMlUsS0FBSztRQUNyQixJQUFJLENBQUMwckIsYUFBYSxHQUFHLENBQUM7UUFDdEIsSUFBSSxDQUFDeG9CLFVBQVUsR0FBRyxJQUFJLDZDQUE2QztRQUNuRSxJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNGLFVBQVUsR0FBRyxJQUFJLDRDQUE0QztRQUNsRSxJQUFJLENBQUM2YSxVQUFVLEdBQUc7UUFDbEIsb0VBQW9FO1FBQ3BFLElBQUksQ0FBQzVMLGFBQWEsR0FBRztJQUN6QjtJQUNBeVosYUFBYTMzQixJQUFJLEVBQUVDLEVBQUUsRUFBRTtRQUNuQixJQUFJa2dCLFFBQVEsSUFBSSxDQUFDM21CLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQzlTLElBQUkycUIsTUFBTSxHQUFHLElBQUksQ0FBQ3B4QixHQUFHLENBQUN1WixNQUFNLENBQUMvUyxNQUFNNHFCLE1BQU0sR0FBRztRQUN4RSxJQUFJLElBQUksQ0FBQ2pCLFlBQVksRUFDakJ4SixTQUFTN2pCLEtBQUtzRixHQUFHLENBQUMsR0FBR3RGLEtBQUtzN0IsSUFBSSxDQUFDLENBQUMsS0FBTTUzQixPQUFTbWdCLFFBQVEsSUFBSSxDQUFDMkosVUFBVSxHQUFHLEdBQUcsSUFBSyxJQUFJLENBQUNBLFVBQVU7UUFDcEcsT0FBTyxJQUFJLENBQUM1YSxVQUFVLEdBQUdpUjtJQUM3QjtJQUNBMFgsY0FBYzE5QixNQUFNLEVBQUU7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQ3d2QixZQUFZLEVBQ2xCLE9BQU8sSUFBSSxDQUFDemEsVUFBVTtRQUMxQixJQUFJaVIsUUFBUSxJQUFJN2pCLEtBQUtzRixHQUFHLENBQUMsR0FBR3RGLEtBQUtzN0IsSUFBSSxDQUFDLENBQUN6OUIsU0FBUyxJQUFJLENBQUMydkIsVUFBVSxJQUFLLEtBQUksQ0FBQ0EsVUFBVSxHQUFHO1FBQ3RGLE9BQU8zSixRQUFRLElBQUksQ0FBQ2pSLFVBQVU7SUFDbEM7SUFDQTRvQixPQUFPdCtCLEdBQUcsRUFBRTtRQUFFLElBQUksQ0FBQ0EsR0FBRyxHQUFHQTtRQUFLLE9BQU8sSUFBSTtJQUFFO0lBQzNDdStCLHVCQUF1QkMsVUFBVSxFQUFFO1FBQy9CLE9BQU8sbUJBQW9COXlCLE9BQU8sQ0FBQzh5QixjQUFjLENBQUMsS0FBTSxJQUFJLENBQUNyTyxZQUFZO0lBQzdFO0lBQ0FzTyxzQkFBc0JDLFdBQVcsRUFBRTtRQUMvQixJQUFJQyxZQUFZO1FBQ2hCLElBQUssSUFBSXI0QixJQUFJLEdBQUdBLElBQUlvNEIsWUFBWS85QixNQUFNLEVBQUUyRixJQUFLO1lBQ3pDLElBQUlzNEIsSUFBSUYsV0FBVyxDQUFDcDRCLEVBQUU7WUFDdEIsSUFBSXM0QixJQUFJLEdBQUc7Z0JBQ1B0NEI7WUFDSixPQUNLLElBQUksQ0FBQyxJQUFJLENBQUM0M0IsYUFBYSxDQUFDcDdCLEtBQUt1dEIsS0FBSyxDQUFDdU8sSUFBSSxJQUFJLEVBQUU7Z0JBQzlDRCxZQUFZO2dCQUNaLElBQUksQ0FBQ1QsYUFBYSxDQUFDcDdCLEtBQUt1dEIsS0FBSyxDQUFDdU8sSUFBSSxJQUFJLEdBQUc7WUFDN0M7UUFDSjtRQUNBLE9BQU9EO0lBQ1g7SUFDQUUsUUFBUUwsVUFBVSxFQUFFOW9CLFVBQVUsRUFBRUMsU0FBUyxFQUFFRixVQUFVLEVBQUU2YSxVQUFVLEVBQUV3TyxZQUFZLEVBQUU7UUFDN0UsSUFBSTNPLGVBQWU2TixtQkFBbUJ0eUIsT0FBTyxDQUFDOHlCLGNBQWMsQ0FBQztRQUM3RCxJQUFJenFCLFVBQVVqUixLQUFLbXRCLEtBQUssQ0FBQ3ZhLGVBQWU1UyxLQUFLbXRCLEtBQUssQ0FBQyxJQUFJLENBQUN2YSxVQUFVLEtBQUssSUFBSSxDQUFDeWEsWUFBWSxJQUFJQTtRQUM1RixJQUFJLENBQUNBLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDemEsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDRixVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQzZhLFVBQVUsR0FBR0E7UUFDbEIsSUFBSXZjLFNBQVM7WUFDVCxJQUFJLENBQUNtcUIsYUFBYSxHQUFHLENBQUM7WUFDdEIsSUFBSyxJQUFJNTNCLElBQUksR0FBR0EsSUFBSXc0QixhQUFhbitCLE1BQU0sRUFBRTJGLElBQUs7Z0JBQzFDLElBQUlzNEIsSUFBSUUsWUFBWSxDQUFDeDRCLEVBQUU7Z0JBQ3ZCLElBQUlzNEIsSUFBSSxHQUNKdDRCO3FCQUVBLElBQUksQ0FBQzQzQixhQUFhLENBQUNwN0IsS0FBS3V0QixLQUFLLENBQUN1TyxJQUFJLElBQUksR0FBRztZQUNqRDtRQUNKO1FBQ0EsT0FBTzdxQjtJQUNYO0FBQ0o7QUFDQSxpRUFBaUU7QUFDakUsa0VBQWtFO0FBQ2xFLGdEQUFnRDtBQUNoRCxNQUFNZ3JCO0lBQ0YzNUIsWUFBWW9CLElBQUksRUFBRXc0QixPQUFPLENBQUU7UUFDdkIsSUFBSSxDQUFDeDRCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUN3NEIsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQzc5QixLQUFLLEdBQUc7SUFDakI7SUFDQSxJQUFJODlCLE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQzk5QixLQUFLLEdBQUcsSUFBSSxDQUFDNjlCLE9BQU8sQ0FBQ3IrQixNQUFNO0lBQUU7QUFDMUQ7QUFDQTs7O0FBR0EsR0FDQSxNQUFNdStCO0lBQ0Y7O0lBRUEsR0FDQTk1QixZQUNBOztJQUVBLEdBQ0FvQixJQUFJLEVBQ0o7O0lBRUEsR0FDQTdGLE1BQU0sRUFDTjs7O0lBR0EsR0FDQXFCLEdBQUcsRUFDSDs7SUFFQSxHQUNBVyxNQUFNLEVBQ047Ozs7O0lBS0EsR0FDQXc4QixRQUFRLENBQUU7UUFDTixJQUFJLENBQUMzNEIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQzdGLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNxQixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDVyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDdzhCLFFBQVEsR0FBR0E7SUFDcEI7SUFDQTs7O0lBR0EsR0FDQSxJQUFJbm5CLE9BQU87UUFDUCxPQUFPLE9BQU8sSUFBSSxDQUFDbW5CLFFBQVEsSUFBSSxXQUFXeG9CLFVBQVU5WSxJQUFJLEdBQ3BEOFQsTUFBTThlLE9BQU8sQ0FBQyxJQUFJLENBQUMwTyxRQUFRLElBQUksSUFBSSxDQUFDQSxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLENBQUNubkIsSUFBSTtJQUN6RTtJQUNBOztJQUVBLEdBQ0EsSUFBSXZSLEtBQUs7UUFBRSxPQUFPLElBQUksQ0FBQ0QsSUFBSSxHQUFHLElBQUksQ0FBQzdGLE1BQU07SUFBRTtJQUMzQzs7SUFFQSxHQUNBLElBQUlzQixTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUNELEdBQUcsR0FBRyxJQUFJLENBQUNXLE1BQU07SUFBRTtJQUM5Qzs7O0lBR0EsR0FDQSxJQUFJc1AsU0FBUztRQUNULE9BQU8sSUFBSSxDQUFDa3RCLFFBQVEsWUFBWW5vQixrQkFBa0IsSUFBSSxDQUFDbW9CLFFBQVEsQ0FBQ2x0QixNQUFNLEdBQUc7SUFDN0U7SUFDQTs7O0lBR0EsR0FDQSxJQUFJMmUsbUJBQW1CO1FBQ25CLE9BQU8sT0FBTyxJQUFJLENBQUN1TyxRQUFRLElBQUksV0FBVyxJQUFJLENBQUNBLFFBQVEsR0FBRztJQUM5RDtJQUNBOztJQUVBLEdBQ0E1eUIsS0FBS1csS0FBSyxFQUFFO1FBQ1IsSUFBSTJMLFVBQVUsQ0FBQ2xILE1BQU04ZSxPQUFPLENBQUMsSUFBSSxDQUFDME8sUUFBUSxJQUFJLElBQUksQ0FBQ0EsUUFBUSxHQUFHO1lBQUMsSUFBSTtTQUFDLEVBQy9EclgsTUFBTSxDQUFDblcsTUFBTThlLE9BQU8sQ0FBQ3ZqQixNQUFNaXlCLFFBQVEsSUFBSWp5QixNQUFNaXlCLFFBQVEsR0FBRztZQUFDanlCO1NBQU07UUFDcEUsT0FBTyxJQUFJZ3lCLFVBQVUsSUFBSSxDQUFDMTRCLElBQUksRUFBRSxJQUFJLENBQUM3RixNQUFNLEdBQUd1TSxNQUFNdk0sTUFBTSxFQUFFLElBQUksQ0FBQ3FCLEdBQUcsRUFBRSxJQUFJLENBQUNXLE1BQU0sR0FBR3VLLE1BQU12SyxNQUFNLEVBQUVrVztJQUN0RztBQUNKO0FBQ0EsSUFBSXVtQixZQUF5QixXQUFGLEdBQUcsU0FBVUEsU0FBUztJQUM3Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUNwQ0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztJQUN2Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHO0lBQ2hELE9BQU9BO0FBQVMsRUFBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlDLE1BQU1DLFVBQVU7QUFDaEIsTUFBTUM7SUFDRmw2QixZQUFZekUsTUFBTSxFQUNsQmdDLE1BQU0sRUFDTmdHLFFBQVEsRUFBRSxpQkFBaUIsR0FBbEIsQ0FBc0I7UUFDM0IsSUFBSSxDQUFDaEksTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ2dDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNnRyxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0EsSUFBSTQyQixXQUFXO1FBQUUsT0FBTyxDQUFDLElBQUksQ0FBQzUyQixLQUFLLEdBQUcsRUFBRSxpQkFBaUIsR0FBbkIsSUFBeUI7SUFBRztJQUNsRSxJQUFJNDJCLFNBQVNuckIsS0FBSyxFQUFFO1FBQUUsSUFBSSxDQUFDekwsS0FBSyxHQUFHLENBQUN5TCxRQUFRLEVBQUUsaUJBQWlCLE1BQUssS0FBTSxJQUFJLENBQUN6TCxLQUFLLEdBQUcsQ0FBQyxFQUFFLGlCQUFpQjtJQUFLO0lBQ2hINjJCLFVBQVVDLE1BQU0sRUFBRTk4QixNQUFNLEVBQUU7UUFDdEIsSUFBSSxJQUFJLENBQUNBLE1BQU0sSUFBSUEsUUFBUTtZQUN2QixJQUFJRyxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDSixNQUFNLEdBQUdBLFVBQVUwOEIsU0FDakNJLE9BQU8vYSxhQUFhLEdBQUc7WUFDM0IsSUFBSSxDQUFDL2hCLE1BQU0sR0FBR0E7UUFDbEI7SUFDSjtJQUNBLGtFQUFrRTtJQUNsRSwyREFBMkQ7SUFDM0Qsc0RBQXNEO0lBQ3REMkosUUFBUWdFLEtBQUssRUFBRUMsR0FBRyxFQUFFbXZCLEtBQUssRUFBRTtRQUN2QixPQUFPSixVQUFVam9CLEVBQUUsQ0FBQ3FvQjtJQUN4QjtJQUNBLDRFQUE0RTtJQUM1RUMsY0FBY3B2QixHQUFHLEVBQUVILE1BQU0sRUFBRTtRQUFFQSxPQUFPakssSUFBSSxDQUFDLElBQUk7SUFBRztJQUNoRHk1QixlQUFldHZCLEtBQUssRUFBRUYsTUFBTSxFQUFFO1FBQUVBLE9BQU9qSyxJQUFJLENBQUMsSUFBSTtJQUFHO0lBQ25EMDVCLGFBQWFybEIsV0FBVyxFQUFFc2xCLE1BQU0sRUFBRUwsTUFBTSxFQUFFbmYsT0FBTyxFQUFFO1FBQy9DLElBQUlxRCxLQUFLLElBQUksRUFBRTNqQixNQUFNeS9CLE9BQU96L0IsR0FBRztRQUMvQixJQUFLLElBQUlzRyxJQUFJZ2EsUUFBUTNmLE1BQU0sR0FBRyxHQUFHMkYsS0FBSyxHQUFHQSxJQUFLO1lBQzFDLElBQUksRUFBRWdkLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLEdBQUcsRUFBRSxHQUFHbkQsT0FBTyxDQUFDaGEsRUFBRTtZQUMzQyxJQUFJeEIsUUFBUTZlLEdBQUdwSyxNQUFNLENBQUMrSixPQUFPOGIsVUFBVVcsYUFBYSxFQUFFTixPQUFPbkIsTUFBTSxDQUFDd0IsU0FBUyxHQUFHO1lBQ2hGLElBQUlqMUIsTUFBTS9GLE1BQU0yQixFQUFFLElBQUk4YyxNQUFNemUsUUFBUTZlLEdBQUdwSyxNQUFNLENBQUNnSyxLQUFLNmIsVUFBVVcsYUFBYSxFQUFFTixRQUFRLEdBQUc7WUFDdkZoYyxPQUFPNVksSUFBSXBFLEVBQUUsR0FBRzhjO1lBQ2hCQSxNQUFNMVksSUFBSXBFLEVBQUU7WUFDWixNQUFPSCxJQUFJLEtBQUt4QixNQUFNMEIsSUFBSSxJQUFJOFosT0FBTyxDQUFDaGEsSUFBSSxFQUFFLENBQUNpZCxHQUFHLENBQUU7Z0JBQzlDRCxRQUFRaEQsT0FBTyxDQUFDaGEsSUFBSSxFQUFFLENBQUNnZCxLQUFLO2dCQUM1QkUsUUFBUWxELE9BQU8sQ0FBQ2hhLElBQUksRUFBRSxDQUFDa2QsS0FBSztnQkFDNUJsZDtnQkFDQSxJQUFJZ2QsUUFBUXhlLE1BQU0wQixJQUFJLEVBQ2xCMUIsUUFBUTZlLEdBQUdwSyxNQUFNLENBQUMrSixPQUFPOGIsVUFBVVcsYUFBYSxFQUFFTixRQUFRLEdBQUc7WUFDckU7WUFDQWpjLFNBQVMxZSxNQUFNMEIsSUFBSSxHQUFHOGM7WUFDdEJBLFFBQVF4ZSxNQUFNMEIsSUFBSTtZQUNsQixJQUFJazVCLFFBQVFNLFlBQVl6bEIsS0FBSyxDQUFDa2xCLE9BQU9uQixNQUFNLENBQUN0K0IsTUFBTXdhLGFBQWFnSixPQUFPQztZQUN0RUUsS0FBS0EsR0FBR3JYLE9BQU8sQ0FBQ2dYLE9BQU9DLEtBQUttYztRQUNoQztRQUNBLE9BQU8vYixHQUFHc2MsWUFBWSxDQUFDUixRQUFRO0lBQ25DO0lBQ0EsT0FBT2p0QixRQUFRO1FBQUUsT0FBTyxJQUFJMHRCLGNBQWMsR0FBRztJQUFJO0lBQ2pELGtFQUFrRTtJQUNsRSxtRUFBbUU7SUFDbkUsa0VBQWtFO0lBQ2xFLG9FQUFvRTtJQUNwRSxPQUFPN29CLEdBQUdxb0IsS0FBSyxFQUFFO1FBQ2IsSUFBSUEsTUFBTS8rQixNQUFNLElBQUksR0FDaEIsT0FBTysrQixLQUFLLENBQUMsRUFBRTtRQUNuQixJQUFJcDVCLElBQUksR0FBR3VNLElBQUk2c0IsTUFBTS8rQixNQUFNLEVBQUU0SCxTQUFTLEdBQUdDLFFBQVE7UUFDakQsT0FBUztZQUNMLElBQUlsQyxLQUFLdU0sR0FBRztnQkFDUixJQUFJdEssU0FBU0MsUUFBUSxHQUFHO29CQUNwQixJQUFJcUYsUUFBUTZ4QixLQUFLLENBQUNwNUIsSUFBSSxFQUFFO29CQUN4QixJQUFJdUgsTUFBTXN5QixLQUFLLEVBQ1hULE1BQU05ekIsTUFBTSxDQUFDLEVBQUV0RixHQUFHLEdBQUd1SCxNQUFNaE0sSUFBSSxFQUFFLE1BQU1nTSxNQUFNOUwsS0FBSzt5QkFFbEQyOUIsTUFBTTl6QixNQUFNLENBQUMsRUFBRXRGLEdBQUcsR0FBR3VILE1BQU1oTSxJQUFJLEVBQUVnTSxNQUFNOUwsS0FBSztvQkFDaEQ4USxLQUFLLElBQUloRixNQUFNc3lCLEtBQUs7b0JBQ3BCNTNCLFVBQVVzRixNQUFNdXlCLElBQUk7Z0JBQ3hCLE9BQ0ssSUFBSTUzQixRQUFRRCxTQUFTLEdBQUc7b0JBQ3pCLElBQUlzRixRQUFRNnhCLEtBQUssQ0FBQzdzQixFQUFFO29CQUNwQixJQUFJaEYsTUFBTXN5QixLQUFLLEVBQ1hULE1BQU05ekIsTUFBTSxDQUFDaUgsR0FBRyxHQUFHaEYsTUFBTWhNLElBQUksRUFBRSxNQUFNZ00sTUFBTTlMLEtBQUs7eUJBRWhEMjlCLE1BQU05ekIsTUFBTSxDQUFDaUgsR0FBRyxHQUFHaEYsTUFBTWhNLElBQUksRUFBRWdNLE1BQU05TCxLQUFLO29CQUM5QzhRLEtBQUssSUFBSWhGLE1BQU1zeUIsS0FBSztvQkFDcEIzM0IsU0FBU3FGLE1BQU11eUIsSUFBSTtnQkFDdkIsT0FDSztvQkFDRDtnQkFDSjtZQUNKLE9BQ0ssSUFBSTczQixTQUFTQyxPQUFPO2dCQUNyQixJQUFJaUIsT0FBT2kyQixLQUFLLENBQUNwNUIsSUFBSTtnQkFDckIsSUFBSW1ELE1BQ0FsQixVQUFVa0IsS0FBSzIyQixJQUFJO1lBQzNCLE9BQ0s7Z0JBQ0QsSUFBSTMyQixPQUFPaTJCLEtBQUssQ0FBQyxFQUFFN3NCLEVBQUU7Z0JBQ3JCLElBQUlwSixNQUNBakIsU0FBU2lCLEtBQUsyMkIsSUFBSTtZQUMxQjtRQUNKO1FBQ0EsSUFBSUMsTUFBTTtRQUNWLElBQUlYLEtBQUssQ0FBQ3A1QixJQUFJLEVBQUUsSUFBSSxNQUFNO1lBQ3RCKzVCLE1BQU07WUFDTi81QjtRQUNKLE9BQ0ssSUFBSW81QixLQUFLLENBQUNwNUIsRUFBRSxJQUFJLE1BQU07WUFDdkIrNUIsTUFBTTtZQUNOeHRCO1FBQ0o7UUFDQSxPQUFPLElBQUl5dEIsZ0JBQWdCaEIsVUFBVWpvQixFQUFFLENBQUNxb0IsTUFBTXZ2QixLQUFLLENBQUMsR0FBRzdKLEtBQUsrNUIsS0FBS2YsVUFBVWpvQixFQUFFLENBQUNxb0IsTUFBTXZ2QixLQUFLLENBQUMwQztJQUM5RjtBQUNKO0FBQ0F5c0IsVUFBVWx5QixTQUFTLENBQUNnekIsSUFBSSxHQUFHO0FBQzNCLE1BQU1HLHVCQUF1QmpCO0lBQ3pCbDZCLFlBQVl6RSxNQUFNLEVBQUVnQyxNQUFNLEVBQUVrUyxJQUFJLENBQUU7UUFDOUIsS0FBSyxDQUFDbFUsUUFBUWdDO1FBQ2QsSUFBSSxDQUFDa1MsSUFBSSxHQUFHQTtJQUNoQjtJQUNBMmIsUUFBUWdRLE9BQU8sRUFBRUMsT0FBTyxFQUFFeitCLEdBQUcsRUFBRWlHLE1BQU0sRUFBRTtRQUNuQyxPQUFPLElBQUlpM0IsVUFBVWozQixRQUFRLElBQUksQ0FBQ3RILE1BQU0sRUFBRXFCLEtBQUssSUFBSSxDQUFDVyxNQUFNLEVBQUUsSUFBSSxDQUFDa1MsSUFBSSxJQUFJO0lBQzdFO0lBQ0EwRSxPQUFPbW5CLE1BQU0sRUFBRUMsS0FBSyxFQUFFbEIsTUFBTSxFQUFFejlCLEdBQUcsRUFBRWlHLE1BQU0sRUFBRTtRQUN2QyxPQUFPLElBQUksQ0FBQ3VvQixPQUFPLENBQUMsR0FBR2lQLFFBQVF6OUIsS0FBS2lHO0lBQ3hDO0lBQ0EyNEIsWUFBWXA2QixJQUFJLEVBQUVDLEVBQUUsRUFBRWc1QixNQUFNLEVBQUV6OUIsR0FBRyxFQUFFaUcsTUFBTSxFQUFFMHFCLENBQUMsRUFBRTtRQUMxQyxJQUFJbnNCLFFBQVF5QixTQUFTLElBQUksQ0FBQ3RILE1BQU0sSUFBSThGLE1BQU13QixRQUN0QzBxQixFQUFFLElBQUksQ0FBQ25DLE9BQU8sQ0FBQyxHQUFHaVAsUUFBUXo5QixLQUFLaUc7SUFDdkM7SUFDQWc0QixhQUFhUixNQUFNLEVBQUV4M0IsU0FBUyxDQUFDLEVBQUU0NEIsU0FBUyxLQUFLLEVBQUVDLFFBQVEsRUFBRTtRQUN2RCxJQUFJQSxZQUFZQSxTQUFTdDZCLElBQUksSUFBSXlCLFVBQVU2NEIsU0FBUzdCLElBQUksRUFDcEQsSUFBSSxDQUFDTyxTQUFTLENBQUNDLFFBQVFxQixTQUFTOUIsT0FBTyxDQUFDOEIsU0FBUzMvQixLQUFLLEdBQUc7UUFDN0QsSUFBSSxDQUFDbytCLFFBQVEsR0FBRztRQUNoQixPQUFPLElBQUk7SUFDZjtJQUNBbHpCLFdBQVc7UUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQzFMLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFBRTtBQUNqRDtBQUNBLE1BQU11L0Isc0JBQXNCSztJQUN4Qm43QixZQUFZekUsTUFBTSxFQUFFZ0MsTUFBTSxDQUFFO1FBQ3hCLEtBQUssQ0FBQ2hDLFFBQVFnQyxRQUFRO1FBQ3RCLElBQUksQ0FBQ28rQixTQUFTLEdBQUcsR0FBRywwQ0FBMEM7UUFDOUQsSUFBSSxDQUFDQyxZQUFZLEdBQUcsR0FBRywrQkFBK0I7UUFDdEQsSUFBSSxDQUFDQyxNQUFNLEdBQUcsR0FBRyxzREFBc0Q7SUFDM0U7SUFDQXpRLFFBQVFnUSxPQUFPLEVBQUVDLE9BQU8sRUFBRXorQixHQUFHLEVBQUVpRyxNQUFNLEVBQUU7UUFDbkMsT0FBTyxJQUFJaTNCLFVBQVVqM0IsUUFBUSxJQUFJLENBQUN0SCxNQUFNLEVBQUVxQixLQUFLLElBQUksQ0FBQ1csTUFBTSxFQUFFLElBQUksQ0FBQ3MrQixNQUFNO0lBQzNFO0lBQ0EzMEIsUUFBUWdFLEtBQUssRUFBRUMsR0FBRyxFQUFFbXZCLEtBQUssRUFBRTtRQUN2QixJQUFJNy9CLE9BQU82L0IsS0FBSyxDQUFDLEVBQUU7UUFDbkIsSUFBSUEsTUFBTS8rQixNQUFNLElBQUksS0FBTWQsQ0FBQUEsZ0JBQWdCcWdDLGlCQUFpQnJnQyxnQkFBZ0JxaEMsZ0JBQWlCcmhDLEtBQUs4SSxLQUFLLEdBQUcsRUFBRSxtQkFBbUIsR0FBRSxLQUM1SDdGLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNwQyxNQUFNLEdBQUdkLEtBQUtjLE1BQU0sSUFBSSxJQUFJO1lBQzFDLElBQUlkLGdCQUFnQnFoQyxjQUNoQnJoQyxPQUFPLElBQUlxZ0MsY0FBY3JnQyxLQUFLYyxNQUFNLEVBQUUsSUFBSSxDQUFDZ0MsTUFBTTtpQkFFakQ5QyxLQUFLOEMsTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTTtZQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDNDhCLFFBQVEsRUFDZDEvQixLQUFLMC9CLFFBQVEsR0FBRztZQUNwQixPQUFPMS9CO1FBQ1gsT0FDSztZQUNELE9BQU95L0IsVUFBVWpvQixFQUFFLENBQUNxb0I7UUFDeEI7SUFDSjtJQUNBTyxhQUFhUixNQUFNLEVBQUV4M0IsU0FBUyxDQUFDLEVBQUV5Z0IsUUFBUSxLQUFLLEVBQUVvWSxRQUFRLEVBQUU7UUFDdEQsSUFBSUEsWUFBWUEsU0FBU3Q2QixJQUFJLElBQUl5QixVQUFVNjRCLFNBQVM3QixJQUFJLEVBQ3BELElBQUksQ0FBQ08sU0FBUyxDQUFDQyxRQUFRcUIsU0FBUzlCLE9BQU8sQ0FBQzhCLFNBQVMzL0IsS0FBSyxHQUFHO2FBQ3hELElBQUl1bkIsU0FBUyxJQUFJLENBQUM2VyxRQUFRLEVBQzNCLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxRQUFRMzhCLEtBQUtzRixHQUFHLENBQUMsSUFBSSxDQUFDNDRCLFlBQVksRUFBRXZCLE9BQU9wQixhQUFhLENBQUMsSUFBSSxDQUFDMTlCLE1BQU0sR0FBRyxJQUFJLENBQUNvZ0MsU0FBUyxLQUNoRyxJQUFJLENBQUNFLE1BQU0sR0FBR3hCLE9BQU8vcEIsVUFBVTtRQUN2QyxJQUFJLENBQUM2cEIsUUFBUSxHQUFHO1FBQ2hCLE9BQU8sSUFBSTtJQUNmO0lBQ0FsekIsV0FBVztRQUNQLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDMUwsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDb2dDLFNBQVMsR0FBRyxDQUFDLElBQUksQ0FBQ0EsU0FBUyxHQUFHLEdBQUcsRUFBRSxJQUFJLENBQUNDLFlBQVksR0FBRyxNQUFNLElBQUksQ0FBQ0EsWUFBWSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQzVIO0FBQ0o7QUFDQSxNQUFNRSxxQkFBcUI1QjtJQUN2Qmw2QixZQUFZekUsTUFBTSxDQUFFO1FBQUUsS0FBSyxDQUFDQSxRQUFRO0lBQUk7SUFDeEN3Z0MsY0FBYzFCLE1BQU0sRUFBRXgzQixNQUFNLEVBQUU7UUFDMUIsSUFBSW01QixZQUFZM0IsT0FBT3ovQixHQUFHLENBQUN1WixNQUFNLENBQUN0UixRQUFRbXBCLE1BQU0sRUFBRTBILFdBQVcyRyxPQUFPei9CLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQ3RSLFNBQVMsSUFBSSxDQUFDdEgsTUFBTSxFQUFFeXdCLE1BQU07UUFDM0csSUFBSXpLLFFBQVFtUyxXQUFXc0ksWUFBWTtRQUNuQyxJQUFJQyxTQUFTQyxVQUFVO1FBQ3ZCLElBQUk3QixPQUFPdFAsWUFBWSxFQUFFO1lBQ3JCLElBQUlvUixlQUFleitCLEtBQUsrQyxHQUFHLENBQUMsSUFBSSxDQUFDbEQsTUFBTSxFQUFFODhCLE9BQU8vcEIsVUFBVSxHQUFHaVI7WUFDN0QwYSxVQUFVRSxlQUFlNWE7WUFDekIsSUFBSSxJQUFJLENBQUNobUIsTUFBTSxHQUFHZ21CLFFBQVEsR0FDdEIyYSxVQUFVLENBQUMsSUFBSSxDQUFDMytCLE1BQU0sR0FBRzQrQixZQUFXLElBQU0sS0FBSSxDQUFDNWdDLE1BQU0sR0FBR2dtQixRQUFRO1FBQ3hFLE9BQ0s7WUFDRDBhLFVBQVUsSUFBSSxDQUFDMStCLE1BQU0sR0FBR2drQjtRQUM1QjtRQUNBLE9BQU87WUFBRXlhO1lBQVd0STtZQUFVdUk7WUFBU0M7UUFBUTtJQUNuRDtJQUNBOVEsUUFBUTd0QixNQUFNLEVBQUU4OEIsTUFBTSxFQUFFejlCLEdBQUcsRUFBRWlHLE1BQU0sRUFBRTtRQUNqQyxJQUFJLEVBQUVtNUIsU0FBUyxFQUFFdEksUUFBUSxFQUFFdUksT0FBTyxFQUFFQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUNILGFBQWEsQ0FBQzFCLFFBQVF4M0I7UUFDM0UsSUFBSXczQixPQUFPdFAsWUFBWSxFQUFFO1lBQ3JCLElBQUlxUixRQUFRdjVCLFNBQVNuRixLQUFLbXRCLEtBQUssQ0FBQ250QixLQUFLc0YsR0FBRyxDQUFDLEdBQUd0RixLQUFLK0MsR0FBRyxDQUFDLEdBQUcsQ0FBQ2xELFNBQVNYLEdBQUUsSUFBSyxJQUFJLENBQUNXLE1BQU0sS0FBSyxJQUFJLENBQUNoQyxNQUFNO1lBQ3BHLElBQUl3VyxPQUFPc29CLE9BQU96L0IsR0FBRyxDQUFDdVosTUFBTSxDQUFDaW9CLFFBQVE5ckIsYUFBYTJyQixVQUFVbHFCLEtBQUt4VyxNQUFNLEdBQUcyZ0M7WUFDMUUsSUFBSUcsVUFBVTMrQixLQUFLc0YsR0FBRyxDQUFDcEcsS0FBS1csU0FBUytTLGFBQWE7WUFDbEQsT0FBTyxJQUFJd3BCLFVBQVUvbkIsS0FBSzNRLElBQUksRUFBRTJRLEtBQUt4VyxNQUFNLEVBQUU4Z0MsU0FBUy9yQixZQUFZO1FBQ3RFLE9BQ0s7WUFDRCxJQUFJeUIsT0FBT3JVLEtBQUtzRixHQUFHLENBQUMsR0FBR3RGLEtBQUsrQyxHQUFHLENBQUNpekIsV0FBV3NJLFdBQVd0K0IsS0FBS3V0QixLQUFLLENBQUMsQ0FBQzF0QixTQUFTWCxHQUFFLElBQUtxL0I7WUFDbEYsSUFBSSxFQUFFNzZCLElBQUksRUFBRTdGLE1BQU0sRUFBRSxHQUFHOCtCLE9BQU96L0IsR0FBRyxDQUFDbVgsSUFBSSxDQUFDaXFCLFlBQVlqcUI7WUFDbkQsT0FBTyxJQUFJK25CLFVBQVUxNEIsTUFBTTdGLFFBQVFxQixNQUFNcS9CLFVBQVVscUIsTUFBTWtxQixTQUFTO1FBQ3RFO0lBQ0o7SUFDQTluQixPQUFPbkYsS0FBSyxFQUFFNEQsSUFBSSxFQUFFeW5CLE1BQU0sRUFBRXo5QixHQUFHLEVBQUVpRyxNQUFNLEVBQUU7UUFDckMsSUFBSStQLFFBQVFvbkIsVUFBVXNDLFFBQVEsRUFDMUIsT0FBTyxJQUFJLENBQUNsUixPQUFPLENBQUNwYyxPQUFPcXJCLFFBQVF6OUIsS0FBS2lHO1FBQzVDLElBQUkrUCxRQUFRb25CLFVBQVVXLGFBQWEsRUFBRTtZQUNqQyxJQUFJLEVBQUV2NUIsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBR2c1QixPQUFPei9CLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQ25GO1lBQ3JDLE9BQU8sSUFBSThxQixVQUFVMTRCLE1BQU1DLEtBQUtELE1BQU0sR0FBRyxHQUFHO1FBQ2hEO1FBQ0EsSUFBSSxFQUFFNDZCLFNBQVMsRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUNILGFBQWEsQ0FBQzFCLFFBQVF4M0I7UUFDakUsSUFBSWtQLE9BQU9zb0IsT0FBT3ovQixHQUFHLENBQUN1WixNQUFNLENBQUNuRixRQUFRc0IsYUFBYTJyQixVQUFVbHFCLEtBQUt4VyxNQUFNLEdBQUcyZ0M7UUFDMUUsSUFBSUssYUFBYXhxQixLQUFLaWEsTUFBTSxHQUFHZ1E7UUFDL0IsSUFBSUssVUFBVXovQixNQUFNcS9CLFVBQVVNLGFBQWFMLFVBQVducUIsQ0FBQUEsS0FBSzNRLElBQUksR0FBR3lCLFNBQVMwNUIsVUFBUztRQUNwRixPQUFPLElBQUl6QyxVQUFVL25CLEtBQUszUSxJQUFJLEVBQUUyUSxLQUFLeFcsTUFBTSxFQUFFbUMsS0FBS3NGLEdBQUcsQ0FBQ3BHLEtBQUtjLEtBQUsrQyxHQUFHLENBQUM0N0IsU0FBU3ovQixNQUFNLElBQUksQ0FBQ1csTUFBTSxHQUFHK1MsY0FBY0EsWUFBWTtJQUMvSDtJQUNBa3JCLFlBQVlwNkIsSUFBSSxFQUFFQyxFQUFFLEVBQUVnNUIsTUFBTSxFQUFFejlCLEdBQUcsRUFBRWlHLE1BQU0sRUFBRTBxQixDQUFDLEVBQUU7UUFDMUNuc0IsT0FBTzFELEtBQUtzRixHQUFHLENBQUM1QixNQUFNeUI7UUFDdEJ4QixLQUFLM0QsS0FBSytDLEdBQUcsQ0FBQ1ksSUFBSXdCLFNBQVMsSUFBSSxDQUFDdEgsTUFBTTtRQUN0QyxJQUFJLEVBQUV5Z0MsU0FBUyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQ0gsYUFBYSxDQUFDMUIsUUFBUXgzQjtRQUNqRSxJQUFLLElBQUlnQixNQUFNekMsTUFBTWk3QixVQUFVei9CLEtBQUtpSCxPQUFPeEMsSUFBSztZQUM1QyxJQUFJMFEsT0FBT3NvQixPQUFPei9CLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQ3RRO1lBQzdCLElBQUlBLE9BQU96QyxNQUFNO2dCQUNiLElBQUltN0IsYUFBYXhxQixLQUFLaWEsTUFBTSxHQUFHZ1E7Z0JBQy9CSyxXQUFXSixVQUFVTSxhQUFhTCxVQUFXOTZCLENBQUFBLE9BQU95QixTQUFTMDVCLFVBQVM7WUFDMUU7WUFDQSxJQUFJanNCLGFBQWEyckIsVUFBVUMsVUFBVW5xQixLQUFLeFcsTUFBTTtZQUNoRGd5QixFQUFFLElBQUl1TSxVQUFVL25CLEtBQUszUSxJQUFJLEVBQUUyUSxLQUFLeFcsTUFBTSxFQUFFOGdDLFNBQVMvckIsWUFBWTtZQUM3RCtyQixXQUFXL3JCO1lBQ1h6TSxNQUFNa08sS0FBSzFRLEVBQUUsR0FBRztRQUNwQjtJQUNKO0lBQ0E2RixRQUFROUYsSUFBSSxFQUFFQyxFQUFFLEVBQUVpNUIsS0FBSyxFQUFFO1FBQ3JCLElBQUlsM0IsUUFBUSxJQUFJLENBQUM3SCxNQUFNLEdBQUc4RjtRQUMxQixJQUFJK0IsUUFBUSxHQUFHO1lBQ1gsSUFBSW1GLE9BQU8reEIsS0FBSyxDQUFDQSxNQUFNLytCLE1BQU0sR0FBRyxFQUFFO1lBQ2xDLElBQUlnTixnQkFBZ0J1ekIsY0FDaEJ4QixLQUFLLENBQUNBLE1BQU0vK0IsTUFBTSxHQUFHLEVBQUUsR0FBRyxJQUFJdWdDLGFBQWF2ekIsS0FBS2hOLE1BQU0sR0FBRzZIO2lCQUV6RGszQixNQUFNdjVCLElBQUksQ0FBQyxNQUFNLElBQUkrNkIsYUFBYTE0QixRQUFRO1FBQ2xEO1FBQ0EsSUFBSWhDLE9BQU8sR0FBRztZQUNWLElBQUlvN0IsUUFBUWxDLEtBQUssQ0FBQyxFQUFFO1lBQ3BCLElBQUlrQyxpQkFBaUJWLGNBQ2pCeEIsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJd0IsYUFBYTE2QixPQUFPbzdCLE1BQU1qaEMsTUFBTTtpQkFFL0MrK0IsTUFBTW1DLE9BQU8sQ0FBQyxJQUFJWCxhQUFhMTZCLE9BQU8sSUFBSTtRQUNsRDtRQUNBLE9BQU84NEIsVUFBVWpvQixFQUFFLENBQUNxb0I7SUFDeEI7SUFDQUMsY0FBY2w1QixFQUFFLEVBQUUySixNQUFNLEVBQUU7UUFDdEJBLE9BQU9qSyxJQUFJLENBQUMsSUFBSSs2QixhQUFhejZCLEtBQUssSUFBSTtJQUMxQztJQUNBbTVCLGVBQWVwNUIsSUFBSSxFQUFFNEosTUFBTSxFQUFFO1FBQ3pCQSxPQUFPakssSUFBSSxDQUFDLE1BQU0sSUFBSSs2QixhQUFhLElBQUksQ0FBQ3ZnQyxNQUFNLEdBQUc2RixPQUFPO0lBQzVEO0lBQ0F5NUIsYUFBYVIsTUFBTSxFQUFFeDNCLFNBQVMsQ0FBQyxFQUFFeWdCLFFBQVEsS0FBSyxFQUFFb1ksUUFBUSxFQUFFO1FBQ3RELElBQUlqMkIsTUFBTTVDLFNBQVMsSUFBSSxDQUFDdEgsTUFBTTtRQUM5QixJQUFJbWdDLFlBQVlBLFNBQVN0NkIsSUFBSSxJQUFJeUIsU0FBUyxJQUFJLENBQUN0SCxNQUFNLElBQUltZ0MsU0FBUzdCLElBQUksRUFBRTtZQUNwRSw4REFBOEQ7WUFDOUQsK0RBQStEO1lBQy9ELDREQUE0RDtZQUM1RCw0QkFBNEI7WUFDNUIsSUFBSVMsUUFBUSxFQUFFLEVBQUV6MkIsTUFBTW5HLEtBQUtzRixHQUFHLENBQUNILFFBQVE2NEIsU0FBU3Q2QixJQUFJLEdBQUdzN0IsZUFBZSxDQUFDO1lBQ3ZFLElBQUloQixTQUFTdDZCLElBQUksR0FBR3lCLFFBQ2hCeTNCLE1BQU12NUIsSUFBSSxDQUFDLElBQUkrNkIsYUFBYUosU0FBU3Q2QixJQUFJLEdBQUd5QixTQUFTLEdBQUdnNEIsWUFBWSxDQUFDUixRQUFReDNCO1lBQ2pGLE1BQU9nQixPQUFPNEIsT0FBT2kyQixTQUFTN0IsSUFBSSxDQUFFO2dCQUNoQyxJQUFJNW9CLE1BQU1vcEIsT0FBT3ovQixHQUFHLENBQUN1WixNQUFNLENBQUN0USxLQUFLdEksTUFBTTtnQkFDdkMsSUFBSSsrQixNQUFNLytCLE1BQU0sRUFDWisrQixNQUFNdjVCLElBQUksQ0FBQztnQkFDZixJQUFJeEQsU0FBU20rQixTQUFTOUIsT0FBTyxDQUFDOEIsU0FBUzMvQixLQUFLLEdBQUc7Z0JBQy9DLElBQUkyZ0MsZ0JBQWdCLENBQUMsR0FDakJBLGVBQWVuL0I7cUJBQ2QsSUFBSUcsS0FBS0MsR0FBRyxDQUFDSixTQUFTbS9CLGlCQUFpQnpDLFNBQ3hDeUMsZUFBZSxDQUFDO2dCQUNwQixJQUFJM3FCLE9BQU8sSUFBSStvQixjQUFjN3BCLEtBQUsxVDtnQkFDbEN3VSxLQUFLb29CLFFBQVEsR0FBRztnQkFDaEJHLE1BQU12NUIsSUFBSSxDQUFDZ1I7Z0JBQ1hsTyxPQUFPb04sTUFBTTtZQUNqQjtZQUNBLElBQUlwTixPQUFPNEIsS0FDUDYwQixNQUFNdjVCLElBQUksQ0FBQyxNQUFNLElBQUkrNkIsYUFBYXIyQixNQUFNNUIsS0FBS2czQixZQUFZLENBQUNSLFFBQVF4MkI7WUFDdEUsSUFBSW1ILFNBQVNrdkIsVUFBVWpvQixFQUFFLENBQUNxb0I7WUFDMUIsSUFBSW9DLGVBQWUsS0FBS2gvQixLQUFLQyxHQUFHLENBQUNxTixPQUFPek4sTUFBTSxHQUFHLElBQUksQ0FBQ0EsTUFBTSxLQUFLMDhCLFdBQzdEdjhCLEtBQUtDLEdBQUcsQ0FBQysrQixlQUFlLElBQUksQ0FBQ1gsYUFBYSxDQUFDMUIsUUFBUXgzQixRQUFRbzVCLE9BQU8sS0FBS2hDLFNBQ3ZFSSxPQUFPL2EsYUFBYSxHQUFHO1lBQzNCLE9BQU90VTtRQUNYLE9BQ0ssSUFBSXNZLFNBQVMsSUFBSSxDQUFDNlcsUUFBUSxFQUFFO1lBQzdCLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxRQUFRQSxPQUFPdEIsWUFBWSxDQUFDbDJCLFFBQVFBLFNBQVMsSUFBSSxDQUFDdEgsTUFBTTtZQUN2RSxJQUFJLENBQUM0K0IsUUFBUSxHQUFHO1FBQ3BCO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQWx6QixXQUFXO1FBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMxTCxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQUU7QUFDL0M7QUFDQSxNQUFNMi9CLHdCQUF3QmhCO0lBQzFCbDZCLFlBQVl2RCxJQUFJLEVBQUV3K0IsR0FBRyxFQUFFdCtCLEtBQUssQ0FBRTtRQUMxQixLQUFLLENBQUNGLEtBQUtsQixNQUFNLEdBQUcwL0IsTUFBTXQrQixNQUFNcEIsTUFBTSxFQUFFa0IsS0FBS2MsTUFBTSxHQUFHWixNQUFNWSxNQUFNLEVBQUUwOUIsTUFBT3grQixDQUFBQSxLQUFLMDlCLFFBQVEsSUFBSXg5QixNQUFNdzlCLFFBQVEsR0FBRyxFQUFFLGlCQUFpQixNQUFLO1FBQ3JJLElBQUksQ0FBQzE5QixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDcStCLElBQUksR0FBR3YrQixLQUFLdStCLElBQUksR0FBR3IrQixNQUFNcStCLElBQUk7SUFDdEM7SUFDQSxJQUFJRCxRQUFRO1FBQUUsT0FBTyxJQUFJLENBQUN4M0IsS0FBSyxHQUFHLEVBQUUsY0FBYztJQUFJO0lBQ3RENm5CLFFBQVE3dEIsTUFBTSxFQUFFODhCLE1BQU0sRUFBRXo5QixHQUFHLEVBQUVpRyxNQUFNLEVBQUU7UUFDakMsSUFBSTg1QixNQUFNLy9CLE1BQU0sSUFBSSxDQUFDSCxJQUFJLENBQUNjLE1BQU07UUFDaEMsT0FBT0EsU0FBU28vQixNQUFNLElBQUksQ0FBQ2xnQyxJQUFJLENBQUMydUIsT0FBTyxDQUFDN3RCLFFBQVE4OEIsUUFBUXo5QixLQUFLaUcsVUFDdkQsSUFBSSxDQUFDbEcsS0FBSyxDQUFDeXVCLE9BQU8sQ0FBQzd0QixRQUFRODhCLFFBQVFzQyxLQUFLOTVCLFNBQVMsSUFBSSxDQUFDcEcsSUFBSSxDQUFDbEIsTUFBTSxHQUFHLElBQUksQ0FBQ3cvQixLQUFLO0lBQ3hGO0lBQ0E1bUIsT0FBT25GLEtBQUssRUFBRTRELElBQUksRUFBRXluQixNQUFNLEVBQUV6OUIsR0FBRyxFQUFFaUcsTUFBTSxFQUFFO1FBQ3JDLElBQUkrNUIsV0FBV2hnQyxNQUFNLElBQUksQ0FBQ0gsSUFBSSxDQUFDYyxNQUFNLEVBQUVzL0IsY0FBY2g2QixTQUFTLElBQUksQ0FBQ3BHLElBQUksQ0FBQ2xCLE1BQU0sR0FBRyxJQUFJLENBQUN3L0IsS0FBSztRQUMzRixJQUFJdCtCLE9BQU9tVyxRQUFRb25CLFVBQVVzQyxRQUFRLEdBQUd0dEIsUUFBUTR0QixXQUFXNXRCLFFBQVE2dEI7UUFDbkUsSUFBSTdpQyxPQUFPeUMsT0FBTyxJQUFJLENBQUNBLElBQUksQ0FBQzBYLE1BQU0sQ0FBQ25GLE9BQU80RCxNQUFNeW5CLFFBQVF6OUIsS0FBS2lHLFVBQ3ZELElBQUksQ0FBQ2xHLEtBQUssQ0FBQ3dYLE1BQU0sQ0FBQ25GLE9BQU80RCxNQUFNeW5CLFFBQVF1QyxVQUFVQztRQUN2RCxJQUFJLElBQUksQ0FBQzlCLEtBQUssSUFBS3QrQixDQUFBQSxPQUFPekMsS0FBS3FILEVBQUUsR0FBR3c3QixjQUFjN2lDLEtBQUtvSCxJQUFJLEdBQUd5N0IsV0FBVSxHQUNwRSxPQUFPN2lDO1FBQ1gsSUFBSThpQyxXQUFXbHFCLFFBQVFvbkIsVUFBVVcsYUFBYSxHQUFHWCxVQUFVVyxhQUFhLEdBQUdYLFVBQVUrQyxLQUFLO1FBQzFGLElBQUl0Z0MsTUFDQSxPQUFPekMsS0FBS21OLElBQUksQ0FBQyxJQUFJLENBQUN4SyxLQUFLLENBQUN3WCxNQUFNLENBQUMwb0IsYUFBYUMsVUFBVXpDLFFBQVF1QyxVQUFVQzthQUU1RSxPQUFPLElBQUksQ0FBQ3BnQyxJQUFJLENBQUMwWCxNQUFNLENBQUMwb0IsYUFBYUMsVUFBVXpDLFFBQVF6OUIsS0FBS2lHLFFBQVFzRSxJQUFJLENBQUNuTjtJQUNqRjtJQUNBd2hDLFlBQVlwNkIsSUFBSSxFQUFFQyxFQUFFLEVBQUVnNUIsTUFBTSxFQUFFejlCLEdBQUcsRUFBRWlHLE1BQU0sRUFBRTBxQixDQUFDLEVBQUU7UUFDMUMsSUFBSXFQLFdBQVdoZ0MsTUFBTSxJQUFJLENBQUNILElBQUksQ0FBQ2MsTUFBTSxFQUFFcy9CLGNBQWNoNkIsU0FBUyxJQUFJLENBQUNwRyxJQUFJLENBQUNsQixNQUFNLEdBQUcsSUFBSSxDQUFDdy9CLEtBQUs7UUFDM0YsSUFBSSxJQUFJLENBQUNBLEtBQUssRUFBRTtZQUNaLElBQUkzNUIsT0FBT3k3QixhQUNQLElBQUksQ0FBQ3BnQyxJQUFJLENBQUMrK0IsV0FBVyxDQUFDcDZCLE1BQU1DLElBQUlnNUIsUUFBUXo5QixLQUFLaUcsUUFBUTBxQjtZQUN6RCxJQUFJbHNCLE1BQU13N0IsYUFDTixJQUFJLENBQUNsZ0MsS0FBSyxDQUFDNitCLFdBQVcsQ0FBQ3A2QixNQUFNQyxJQUFJZzVCLFFBQVF1QyxVQUFVQyxhQUFhdFA7UUFDeEUsT0FDSztZQUNELElBQUlvUCxNQUFNLElBQUksQ0FBQ3hvQixNQUFNLENBQUMwb0IsYUFBYTdDLFVBQVUrQyxLQUFLLEVBQUUxQyxRQUFRejlCLEtBQUtpRztZQUNqRSxJQUFJekIsT0FBT3U3QixJQUFJdjdCLElBQUksRUFDZixJQUFJLENBQUMzRSxJQUFJLENBQUMrK0IsV0FBVyxDQUFDcDZCLE1BQU11N0IsSUFBSXY3QixJQUFJLEdBQUcsR0FBR2k1QixRQUFRejlCLEtBQUtpRyxRQUFRMHFCO1lBQ25FLElBQUlvUCxJQUFJdDdCLEVBQUUsSUFBSUQsUUFBUXU3QixJQUFJdjdCLElBQUksSUFBSUMsSUFDOUJrc0IsRUFBRW9QO1lBQ04sSUFBSXQ3QixLQUFLczdCLElBQUl0N0IsRUFBRSxFQUNYLElBQUksQ0FBQzFFLEtBQUssQ0FBQzYrQixXQUFXLENBQUNtQixJQUFJdDdCLEVBQUUsR0FBRyxHQUFHQSxJQUFJZzVCLFFBQVF1QyxVQUFVQyxhQUFhdFA7UUFDOUU7SUFDSjtJQUNBcm1CLFFBQVE5RixJQUFJLEVBQUVDLEVBQUUsRUFBRWk1QixLQUFLLEVBQUU7UUFDckIsSUFBSTBDLGFBQWEsSUFBSSxDQUFDdmdDLElBQUksQ0FBQ2xCLE1BQU0sR0FBRyxJQUFJLENBQUN3L0IsS0FBSztRQUM5QyxJQUFJMTVCLEtBQUsyN0IsWUFDTCxPQUFPLElBQUksQ0FBQ0MsUUFBUSxDQUFDLElBQUksQ0FBQ3hnQyxJQUFJLENBQUN5SyxPQUFPLENBQUM5RixNQUFNQyxJQUFJaTVCLFFBQVEsSUFBSSxDQUFDMzlCLEtBQUs7UUFDdkUsSUFBSXlFLE9BQU8sSUFBSSxDQUFDM0UsSUFBSSxDQUFDbEIsTUFBTSxFQUN2QixPQUFPLElBQUksQ0FBQzBoQyxRQUFRLENBQUMsSUFBSSxDQUFDeGdDLElBQUksRUFBRSxJQUFJLENBQUNFLEtBQUssQ0FBQ3VLLE9BQU8sQ0FBQzlGLE9BQU80N0IsWUFBWTM3QixLQUFLMjdCLFlBQVkxQztRQUMzRixJQUFJdHZCLFNBQVMsRUFBRTtRQUNmLElBQUk1SixPQUFPLEdBQ1AsSUFBSSxDQUFDbTVCLGFBQWEsQ0FBQ241QixNQUFNNEo7UUFDN0IsSUFBSXZPLE9BQU91TyxPQUFPelAsTUFBTTtRQUN4QixLQUFLLElBQUlkLFFBQVE2L0IsTUFDYnR2QixPQUFPakssSUFBSSxDQUFDdEc7UUFDaEIsSUFBSTJHLE9BQU8sR0FDUDg3QixVQUFVbHlCLFFBQVF2TyxPQUFPO1FBQzdCLElBQUk0RSxLQUFLLElBQUksQ0FBQzlGLE1BQU0sRUFBRTtZQUNsQixJQUFJb0IsUUFBUXFPLE9BQU96UCxNQUFNO1lBQ3pCLElBQUksQ0FBQ2kvQixjQUFjLENBQUNuNUIsSUFBSTJKO1lBQ3hCa3lCLFVBQVVseUIsUUFBUXJPO1FBQ3RCO1FBQ0EsT0FBT3U5QixVQUFVam9CLEVBQUUsQ0FBQ2pIO0lBQ3hCO0lBQ0F1dkIsY0FBY2w1QixFQUFFLEVBQUUySixNQUFNLEVBQUU7UUFDdEIsSUFBSXZPLE9BQU8sSUFBSSxDQUFDQSxJQUFJLENBQUNsQixNQUFNO1FBQzNCLElBQUk4RixNQUFNNUUsTUFDTixPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDODlCLGFBQWEsQ0FBQ2w1QixJQUFJMko7UUFDdkNBLE9BQU9qSyxJQUFJLENBQUMsSUFBSSxDQUFDdEUsSUFBSTtRQUNyQixJQUFJLElBQUksQ0FBQ3MrQixLQUFLLEVBQUU7WUFDWnQrQjtZQUNBLElBQUk0RSxNQUFNNUUsTUFDTnVPLE9BQU9qSyxJQUFJLENBQUM7UUFDcEI7UUFDQSxJQUFJTSxLQUFLNUUsTUFDTCxJQUFJLENBQUNFLEtBQUssQ0FBQzQ5QixhQUFhLENBQUNsNUIsS0FBSzVFLE1BQU11TztJQUM1QztJQUNBd3ZCLGVBQWVwNUIsSUFBSSxFQUFFNEosTUFBTSxFQUFFO1FBQ3pCLElBQUl2TyxPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDbEIsTUFBTSxFQUFFb0IsUUFBUUYsT0FBTyxJQUFJLENBQUNzK0IsS0FBSztRQUN0RCxJQUFJMzVCLFFBQVF6RSxPQUNSLE9BQU8sSUFBSSxDQUFDQSxLQUFLLENBQUM2OUIsY0FBYyxDQUFDcDVCLE9BQU96RSxPQUFPcU87UUFDbkQsSUFBSTVKLE9BQU8zRSxNQUNQLElBQUksQ0FBQ0EsSUFBSSxDQUFDKzlCLGNBQWMsQ0FBQ3A1QixNQUFNNEo7UUFDbkMsSUFBSSxJQUFJLENBQUMrdkIsS0FBSyxJQUFJMzVCLE9BQU96RSxPQUNyQnFPLE9BQU9qSyxJQUFJLENBQUM7UUFDaEJpSyxPQUFPakssSUFBSSxDQUFDLElBQUksQ0FBQ3BFLEtBQUs7SUFDMUI7SUFDQXNnQyxTQUFTeGdDLElBQUksRUFBRUUsS0FBSyxFQUFFO1FBQ2xCLElBQUlGLEtBQUt1K0IsSUFBSSxHQUFHLElBQUlyK0IsTUFBTXErQixJQUFJLElBQUlyK0IsTUFBTXErQixJQUFJLEdBQUcsSUFBSXYrQixLQUFLdStCLElBQUksRUFDeEQsT0FBT2QsVUFBVWpvQixFQUFFLENBQUMsSUFBSSxDQUFDOG9CLEtBQUssR0FBRztZQUFDdCtCO1lBQU07WUFBTUU7U0FBTSxHQUFHO1lBQUNGO1lBQU1FO1NBQU07UUFDeEUsSUFBSSxDQUFDRixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDWSxNQUFNLEdBQUdkLEtBQUtjLE1BQU0sR0FBR1osTUFBTVksTUFBTTtRQUN4QyxJQUFJLENBQUM0OEIsUUFBUSxHQUFHMTlCLEtBQUswOUIsUUFBUSxJQUFJeDlCLE1BQU13OUIsUUFBUTtRQUMvQyxJQUFJLENBQUNhLElBQUksR0FBR3YrQixLQUFLdStCLElBQUksR0FBR3IrQixNQUFNcStCLElBQUk7UUFDbEMsSUFBSSxDQUFDei9CLE1BQU0sR0FBR2tCLEtBQUtsQixNQUFNLEdBQUcsSUFBSSxDQUFDdy9CLEtBQUssR0FBR3ArQixNQUFNcEIsTUFBTTtRQUNyRCxPQUFPLElBQUk7SUFDZjtJQUNBcy9CLGFBQWFSLE1BQU0sRUFBRXgzQixTQUFTLENBQUMsRUFBRXlnQixRQUFRLEtBQUssRUFBRW9ZLFFBQVEsRUFBRTtRQUN0RCxJQUFJLEVBQUVqL0IsSUFBSSxFQUFFRSxLQUFLLEVBQUUsR0FBRyxJQUFJLEVBQUVxZ0MsYUFBYW42QixTQUFTcEcsS0FBS2xCLE1BQU0sR0FBRyxJQUFJLENBQUN3L0IsS0FBSyxFQUFFb0MsWUFBWTtRQUN4RixJQUFJekIsWUFBWUEsU0FBU3Q2QixJQUFJLElBQUl5QixTQUFTcEcsS0FBS2xCLE1BQU0sSUFBSW1nQyxTQUFTN0IsSUFBSSxFQUNsRXNELFlBQVkxZ0MsT0FBT0EsS0FBS28rQixZQUFZLENBQUNSLFFBQVF4M0IsUUFBUXlnQixPQUFPb1k7YUFFNURqL0IsS0FBS28rQixZQUFZLENBQUNSLFFBQVF4M0IsUUFBUXlnQjtRQUN0QyxJQUFJb1ksWUFBWUEsU0FBU3Q2QixJQUFJLElBQUk0N0IsYUFBYXJnQyxNQUFNcEIsTUFBTSxJQUFJbWdDLFNBQVM3QixJQUFJLEVBQ3ZFc0QsWUFBWXhnQyxRQUFRQSxNQUFNaytCLFlBQVksQ0FBQ1IsUUFBUTJDLFlBQVkxWixPQUFPb1k7YUFFbEUvK0IsTUFBTWsrQixZQUFZLENBQUNSLFFBQVEyQyxZQUFZMVo7UUFDM0MsSUFBSTZaLFdBQ0EsT0FBTyxJQUFJLENBQUNGLFFBQVEsQ0FBQ3hnQyxNQUFNRTtRQUMvQixJQUFJLENBQUNZLE1BQU0sR0FBRyxJQUFJLENBQUNkLElBQUksQ0FBQ2MsTUFBTSxHQUFHLElBQUksQ0FBQ1osS0FBSyxDQUFDWSxNQUFNO1FBQ2xELElBQUksQ0FBQzQ4QixRQUFRLEdBQUc7UUFDaEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQWx6QixXQUFXO1FBQUUsT0FBTyxJQUFJLENBQUN4SyxJQUFJLEdBQUksS0FBSSxDQUFDcytCLEtBQUssR0FBRyxNQUFNLEdBQUUsSUFBSyxJQUFJLENBQUNwK0IsS0FBSztJQUFFO0FBQzNFO0FBQ0EsU0FBU3VnQyxVQUFVNUMsS0FBSyxFQUFFOEMsTUFBTTtJQUM1QixJQUFJajZCLFFBQVFDO0lBQ1osSUFBSWszQixLQUFLLENBQUM4QyxPQUFPLElBQUksUUFDakIsQ0FBQ2o2QixTQUFTbTNCLEtBQUssQ0FBQzhDLFNBQVMsRUFBRSxhQUFhdEIsZ0JBQ3hDLENBQUMxNEIsUUFBUWszQixLQUFLLENBQUM4QyxTQUFTLEVBQUUsYUFBYXRCLGNBQ3ZDeEIsTUFBTTl6QixNQUFNLENBQUM0MkIsU0FBUyxHQUFHLEdBQUcsSUFBSXRCLGFBQWEzNEIsT0FBTzVILE1BQU0sR0FBRyxJQUFJNkgsTUFBTTdILE1BQU07QUFDckY7QUFDQSxNQUFNOGhDLHVCQUF1QjtBQUM3QixNQUFNekM7SUFDRjU2QixZQUFZNkQsR0FBRyxFQUFFdzJCLE1BQU0sQ0FBRTtRQUNyQixJQUFJLENBQUN4MkIsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ3cyQixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUksQ0FBQzNWLFNBQVMsR0FBRyxDQUFDO1FBQ2xCLElBQUksQ0FBQzJZLE9BQU8sR0FBRyxDQUFDO1FBQ2hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHMzVCO0lBQ3JCO0lBQ0EsSUFBSTQ1QixZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUNGLFFBQVEsSUFBSSxJQUFJLENBQUNqRCxLQUFLLENBQUMsSUFBSSxDQUFDQSxLQUFLLENBQUMvK0IsTUFBTSxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQUNnaUMsUUFBUTtJQUM5RTtJQUNBeG9CLEtBQUs3SixLQUFLLEVBQUU3SixFQUFFLEVBQUU7UUFDWixJQUFJLElBQUksQ0FBQ3NqQixTQUFTLEdBQUcsQ0FBQyxHQUFHO1lBQ3JCLElBQUlsZixNQUFNL0gsS0FBSytDLEdBQUcsQ0FBQ1ksSUFBSSxJQUFJLENBQUNpOEIsT0FBTyxHQUFHLzBCLE9BQU8sSUFBSSxDQUFDK3hCLEtBQUssQ0FBQyxJQUFJLENBQUNBLEtBQUssQ0FBQy8rQixNQUFNLEdBQUcsRUFBRTtZQUM5RSxJQUFJZ04sZ0JBQWdCdXlCLGVBQ2hCdnlCLEtBQUtoTixNQUFNLElBQUlrSyxNQUFNLElBQUksQ0FBQzVCLEdBQUc7aUJBQzVCLElBQUk0QixNQUFNLElBQUksQ0FBQzVCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQzQ1QixTQUFTLEVBQ3RDLElBQUksQ0FBQ25ELEtBQUssQ0FBQ3Y1QixJQUFJLENBQUMsSUFBSSs1QixjQUFjcjFCLE1BQU0sSUFBSSxDQUFDNUIsR0FBRyxFQUFFLENBQUM7WUFDdkQsSUFBSSxDQUFDMjVCLFNBQVMsR0FBRy8zQjtZQUNqQixJQUFJcEUsS0FBS29FLEtBQUs7Z0JBQ1YsSUFBSSxDQUFDNjBCLEtBQUssQ0FBQ3Y1QixJQUFJLENBQUM7Z0JBQ2hCLElBQUksQ0FBQ3k4QixTQUFTO2dCQUNkLElBQUksQ0FBQzdZLFNBQVMsR0FBRyxDQUFDO1lBQ3RCO1FBQ0o7UUFDQSxJQUFJLENBQUM5Z0IsR0FBRyxHQUFHeEM7SUFDZjtJQUNBaVIsTUFBTWxSLElBQUksRUFBRUMsRUFBRSxFQUFFb08sSUFBSSxFQUFFO1FBQ2xCLElBQUlyTyxPQUFPQyxNQUFNb08sS0FBS2dDLGNBQWMsRUFBRTtZQUNsQyxJQUFJbFUsU0FBU2tTLEtBQUs1QyxNQUFNLEdBQUc0QyxLQUFLNUMsTUFBTSxDQUFDd0UsZUFBZSxHQUFHO1lBQ3pELElBQUl3cUIsU0FBU3BzQixLQUFLNUMsTUFBTSxHQUFHNEMsS0FBSzVDLE1BQU0sQ0FBQ3lFLFVBQVUsR0FBRztZQUNwRCxJQUFJL1QsU0FBUyxHQUNUQSxTQUFTLElBQUksQ0FBQzg4QixNQUFNLENBQUMvcEIsVUFBVTtZQUNuQyxJQUFJVyxNQUFNNVAsS0FBS0Q7WUFDZixJQUFJcU8sS0FBS3FCLEtBQUssRUFBRTtnQkFDWixJQUFJLENBQUM0c0IsUUFBUSxDQUFDLElBQUl2QyxlQUFlbHFCLEtBQUsxVCxRQUFRa1M7WUFDbEQsT0FDSyxJQUFJd0IsT0FBTzRxQixVQUFVdCtCLFVBQVU4L0Isc0JBQXNCO2dCQUN0RCxJQUFJLENBQUM3dEIsV0FBVyxDQUFDalMsUUFBUXMrQixRQUFRNXFCO1lBQ3JDO1FBQ0osT0FDSyxJQUFJNVAsS0FBS0QsTUFBTTtZQUNoQixJQUFJLENBQUMyVCxJQUFJLENBQUMzVCxNQUFNQztRQUNwQjtRQUNBLElBQUksSUFBSSxDQUFDaThCLE9BQU8sR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDQSxPQUFPLEdBQUcsSUFBSSxDQUFDejVCLEdBQUcsRUFDNUMsSUFBSSxDQUFDeTVCLE9BQU8sR0FBRyxJQUFJLENBQUNqRCxNQUFNLENBQUN6L0IsR0FBRyxDQUFDdVosTUFBTSxDQUFDLElBQUksQ0FBQ3RRLEdBQUcsRUFBRXhDLEVBQUU7SUFDMUQ7SUFDQXM4QixZQUFZO1FBQ1IsSUFBSSxJQUFJLENBQUNoWixTQUFTLEdBQUcsQ0FBQyxHQUNsQjtRQUNKLElBQUksRUFBRXZqQixJQUFJLEVBQUVDLEVBQUUsRUFBRSxHQUFHLElBQUksQ0FBQ2c1QixNQUFNLENBQUN6L0IsR0FBRyxDQUFDdVosTUFBTSxDQUFDLElBQUksQ0FBQ3RRLEdBQUc7UUFDbEQsSUFBSSxDQUFDOGdCLFNBQVMsR0FBR3ZqQjtRQUNqQixJQUFJLENBQUNrOEIsT0FBTyxHQUFHajhCO1FBQ2YsSUFBSSxJQUFJLENBQUNtOEIsU0FBUyxHQUFHcDhCLE1BQU07WUFDdkIsSUFBSSxJQUFJLENBQUNvOEIsU0FBUyxHQUFHcDhCLE9BQU8sS0FBSyxJQUFJLENBQUNrNUIsS0FBSyxDQUFDLElBQUksQ0FBQ0EsS0FBSyxDQUFDLytCLE1BQU0sR0FBRyxFQUFFLElBQUksTUFDbEUsSUFBSSxDQUFDKytCLEtBQUssQ0FBQ3Y1QixJQUFJLENBQUMsSUFBSSxDQUFDNjhCLFlBQVksQ0FBQyxJQUFJLENBQUNKLFNBQVMsRUFBRXA4QixPQUFPO1lBQzdELElBQUksQ0FBQ2s1QixLQUFLLENBQUN2NUIsSUFBSSxDQUFDO1FBQ3BCO1FBQ0EsSUFBSSxJQUFJLENBQUM4QyxHQUFHLEdBQUd6QyxNQUNYLElBQUksQ0FBQ2s1QixLQUFLLENBQUN2NUIsSUFBSSxDQUFDLElBQUkrNUIsY0FBYyxJQUFJLENBQUNqM0IsR0FBRyxHQUFHekMsTUFBTSxDQUFDO1FBQ3hELElBQUksQ0FBQ284QixTQUFTLEdBQUcsSUFBSSxDQUFDMzVCLEdBQUc7SUFDN0I7SUFDQSs1QixhQUFheDhCLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQ25CLElBQUl3OEIsTUFBTSxJQUFJL0IsYUFBYXo2QixLQUFLRDtRQUNoQyxJQUFJLElBQUksQ0FBQ2k1QixNQUFNLENBQUN6L0IsR0FBRyxDQUFDdVosTUFBTSxDQUFDL1MsTUFBTUMsRUFBRSxJQUFJQSxJQUNuQ3c4QixJQUFJdDZCLEtBQUssSUFBSSxFQUFFLG1CQUFtQjtRQUN0QyxPQUFPczZCO0lBQ1g7SUFDQUMsYUFBYTtRQUNULElBQUksQ0FBQ0gsU0FBUztRQUNkLElBQUlwMUIsT0FBTyxJQUFJLENBQUMreEIsS0FBSyxDQUFDLytCLE1BQU0sR0FBRyxJQUFJLENBQUMrK0IsS0FBSyxDQUFDLElBQUksQ0FBQ0EsS0FBSyxDQUFDLytCLE1BQU0sR0FBRyxFQUFFLEdBQUc7UUFDbkUsSUFBSWdOLGdCQUFnQnV5QixlQUNoQixPQUFPdnlCO1FBQ1gsSUFBSXdKLE9BQU8sSUFBSStvQixjQUFjLEdBQUcsQ0FBQztRQUNqQyxJQUFJLENBQUNSLEtBQUssQ0FBQ3Y1QixJQUFJLENBQUNnUjtRQUNoQixPQUFPQTtJQUNYO0lBQ0EyckIsU0FBUzVzQixLQUFLLEVBQUU7UUFDWixJQUFJLENBQUM2c0IsU0FBUztRQUNkLElBQUlsdUIsT0FBT3FCLE1BQU1yQixJQUFJO1FBQ3JCLElBQUlBLFFBQVFBLEtBQUt5QixTQUFTLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQ3VzQixTQUFTLEVBQzdDLElBQUksQ0FBQ0ssVUFBVTtRQUNuQixJQUFJLENBQUN4RCxLQUFLLENBQUN2NUIsSUFBSSxDQUFDK1A7UUFDaEIsSUFBSSxDQUFDMHNCLFNBQVMsR0FBRyxJQUFJLENBQUMzNUIsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRyxHQUFHaU4sTUFBTXZWLE1BQU07UUFDbkQsSUFBSWtVLFFBQVFBLEtBQUswQixPQUFPLEdBQUcsR0FDdkIsSUFBSSxDQUFDb3NCLFFBQVEsR0FBR3pzQjtJQUN4QjtJQUNBdEIsWUFBWWpTLE1BQU0sRUFBRXMrQixNQUFNLEVBQUV0Z0MsTUFBTSxFQUFFO1FBQ2hDLElBQUl3VyxPQUFPLElBQUksQ0FBQytyQixVQUFVO1FBQzFCL3JCLEtBQUt4VyxNQUFNLElBQUlBO1FBQ2Z3VyxLQUFLNHBCLFNBQVMsSUFBSXBnQztRQUNsQndXLEtBQUs2cEIsWUFBWSxHQUFHbCtCLEtBQUtzRixHQUFHLENBQUMrTyxLQUFLNnBCLFlBQVksRUFBRXIrQjtRQUNoRHdVLEtBQUs4cEIsTUFBTSxJQUFJQTtRQUNmLElBQUksQ0FBQzJCLFNBQVMsR0FBRyxJQUFJLENBQUMzNUIsR0FBRyxHQUFHLElBQUksQ0FBQ0EsR0FBRyxHQUFHdEk7SUFDM0M7SUFDQWtaLE9BQU9yVCxJQUFJLEVBQUU7UUFDVCxJQUFJbUgsT0FBTyxJQUFJLENBQUMreEIsS0FBSyxDQUFDLytCLE1BQU0sSUFBSSxJQUFJLE9BQU8sSUFBSSxDQUFDKytCLEtBQUssQ0FBQyxJQUFJLENBQUNBLEtBQUssQ0FBQy8rQixNQUFNLEdBQUcsRUFBRTtRQUM1RSxJQUFJLElBQUksQ0FBQ29wQixTQUFTLEdBQUcsQ0FBQyxLQUFLLENBQUVwYyxDQUFBQSxnQkFBZ0J1eUIsYUFBWSxLQUFNLENBQUMsSUFBSSxDQUFDMkMsU0FBUyxFQUMxRSxJQUFJLENBQUNuRCxLQUFLLENBQUN2NUIsSUFBSSxDQUFDLElBQUkrNUIsY0FBYyxHQUFHLENBQUM7YUFDckMsSUFBSSxJQUFJLENBQUMwQyxTQUFTLEdBQUcsSUFBSSxDQUFDMzVCLEdBQUcsSUFBSTBFLFFBQVEsTUFDMUMsSUFBSSxDQUFDK3hCLEtBQUssQ0FBQ3Y1QixJQUFJLENBQUMsSUFBSSxDQUFDNjhCLFlBQVksQ0FBQyxJQUFJLENBQUNKLFNBQVMsRUFBRSxJQUFJLENBQUMzNUIsR0FBRztRQUM5RCxJQUFJQSxNQUFNekM7UUFDVixLQUFLLElBQUkzRyxRQUFRLElBQUksQ0FBQzYvQixLQUFLLENBQUU7WUFDekIsSUFBSTcvQixnQkFBZ0JxZ0MsZUFDaEJyZ0MsS0FBS29nQyxZQUFZLENBQUMsSUFBSSxDQUFDUixNQUFNLEVBQUV4MkI7WUFDbkNBLE9BQU9wSixPQUFPQSxLQUFLYyxNQUFNLEdBQUc7UUFDaEM7UUFDQSxPQUFPLElBQUksQ0FBQysrQixLQUFLO0lBQ3JCO0lBQ0Esa0VBQWtFO0lBQ2xFLDhDQUE4QztJQUM5QyxrRUFBa0U7SUFDbEUsbUVBQW1FO0lBQ25FLGlCQUFpQjtJQUNqQixPQUFPbmxCLE1BQU1rbEIsTUFBTSxFQUFFamxCLFdBQVcsRUFBRWhVLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQ3hDLElBQUlpVSxVQUFVLElBQUlzbEIsWUFBWXg1QixNQUFNaTVCO1FBQ3BDM2hDLHVEQUFRQSxDQUFDNmMsS0FBSyxDQUFDSCxhQUFhaFUsTUFBTUMsSUFBSWlVLFNBQVM7UUFDL0MsT0FBT0EsUUFBUWIsTUFBTSxDQUFDclQ7SUFDMUI7QUFDSjtBQUNBLFNBQVMyOEIsMEJBQTBCM3ZCLENBQUMsRUFBRUMsQ0FBQyxFQUFFb1EsSUFBSTtJQUN6QyxJQUFJaUosT0FBTyxJQUFJSDtJQUNmN3VCLHVEQUFRQSxDQUFDd1UsT0FBTyxDQUFDa0IsR0FBR0MsR0FBR29RLE1BQU1pSixNQUFNO0lBQ25DLE9BQU9BLEtBQUt4TSxPQUFPO0FBQ3ZCO0FBQ0EsTUFBTXFNO0lBQ0Z2bkIsYUFBYztRQUNWLElBQUksQ0FBQ2tiLE9BQU8sR0FBRyxFQUFFO0lBQ3JCO0lBQ0FzTSxlQUFlLENBQUU7SUFDakJDLGFBQWFybUIsSUFBSSxFQUFFQyxFQUFFLEVBQUUrTSxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUN6QixJQUFJak4sT0FBT0MsTUFBTStNLEtBQUtBLEVBQUVxRCxjQUFjLElBQUlwRCxLQUFLQSxFQUFFb0QsY0FBYyxFQUMzRDJCLFNBQVNoUyxNQUFNQyxJQUFJLElBQUksQ0FBQzZaLE9BQU8sRUFBRTtJQUN6QztBQUNKO0FBRUEsU0FBUzhpQixrQkFBa0J4akMsR0FBRyxFQUFFb3ZCLFVBQVU7SUFDdEMsSUFBSXB0QixPQUFPaEMsSUFBSXdFLHFCQUFxQjtJQUNwQyxJQUFJcEUsTUFBTUosSUFBSUYsYUFBYSxFQUFFeUMsTUFBTW5DLElBQUlzRCxXQUFXLElBQUlDO0lBQ3RELElBQUkxQixPQUFPaUIsS0FBS3NGLEdBQUcsQ0FBQyxHQUFHeEcsS0FBS0MsSUFBSSxHQUFHRSxRQUFRZSxLQUFLK0MsR0FBRyxDQUFDMUQsSUFBSUMsVUFBVSxFQUFFUixLQUFLRyxLQUFLO0lBQzlFLElBQUlDLE1BQU1jLEtBQUtzRixHQUFHLENBQUMsR0FBR3hHLEtBQUtJLEdBQUcsR0FBR0MsU0FBU2EsS0FBSytDLEdBQUcsQ0FBQzFELElBQUlFLFdBQVcsRUFBRVQsS0FBS0ssTUFBTTtJQUMvRSxJQUFLLElBQUlULFNBQVM1QixJQUFJRSxVQUFVLEVBQUUwQixVQUFVQSxVQUFVeEIsSUFBSTJELElBQUksRUFBRztRQUM3RCxJQUFJbkMsT0FBTy9CLFFBQVEsSUFBSSxHQUFHO1lBQ3RCLElBQUlRLE1BQU11QjtZQUNWLElBQUkrTSxRQUFRaEwsT0FBT00sZ0JBQWdCLENBQUM1RDtZQUNwQyxJQUFJLENBQUNBLElBQUk4RCxZQUFZLEdBQUc5RCxJQUFJK0QsWUFBWSxJQUFJL0QsSUFBSWdFLFdBQVcsR0FBR2hFLElBQUlpRSxXQUFXLEtBQ3pFcUssTUFBTTgwQixRQUFRLElBQUksV0FBVztnQkFDN0IsSUFBSUMsYUFBYXJqQyxJQUFJbUUscUJBQXFCO2dCQUMxQ3ZDLE9BQU9pQixLQUFLc0YsR0FBRyxDQUFDdkcsTUFBTXloQyxXQUFXemhDLElBQUk7Z0JBQ3JDRSxRQUFRZSxLQUFLK0MsR0FBRyxDQUFDOUQsT0FBT3VoQyxXQUFXdmhDLEtBQUs7Z0JBQ3hDQyxNQUFNYyxLQUFLc0YsR0FBRyxDQUFDcEcsS0FBS3NoQyxXQUFXdGhDLEdBQUc7Z0JBQ2xDQyxTQUFTVCxVQUFVNUIsSUFBSUUsVUFBVSxHQUFHd2pDLFdBQVdyaEMsTUFBTSxHQUFHYSxLQUFLK0MsR0FBRyxDQUFDNUQsUUFBUXFoQyxXQUFXcmhDLE1BQU07WUFDOUY7WUFDQVQsU0FBUytNLE1BQU16SyxRQUFRLElBQUksY0FBY3lLLE1BQU16SyxRQUFRLElBQUksVUFBVTdELElBQUlzakMsWUFBWSxHQUFHdGpDLElBQUlILFVBQVU7UUFDMUcsT0FDSyxJQUFJMEIsT0FBTy9CLFFBQVEsSUFBSSxJQUFJO1lBQzVCK0IsU0FBU0EsT0FBT3lELElBQUk7UUFDeEIsT0FDSztZQUNEO1FBQ0o7SUFDSjtJQUNBLE9BQU87UUFBRXBELE1BQU1BLE9BQU9ELEtBQUtDLElBQUk7UUFBRUUsT0FBT2UsS0FBS3NGLEdBQUcsQ0FBQ3ZHLE1BQU1FLFNBQVNILEtBQUtDLElBQUk7UUFDckVHLEtBQUtBLE1BQU9KLENBQUFBLEtBQUtJLEdBQUcsR0FBR2d0QixVQUFTO1FBQUkvc0IsUUFBUWEsS0FBS3NGLEdBQUcsQ0FBQ3BHLEtBQUtDLFVBQVdMLENBQUFBLEtBQUtJLEdBQUcsR0FBR2d0QixVQUFTO0lBQUc7QUFDcEc7QUFDQSxTQUFTd1UsZUFBZTVqQyxHQUFHLEVBQUVvdkIsVUFBVTtJQUNuQyxJQUFJcHRCLE9BQU9oQyxJQUFJd0UscUJBQXFCO0lBQ3BDLE9BQU87UUFBRXZDLE1BQU07UUFBR0UsT0FBT0gsS0FBS0csS0FBSyxHQUFHSCxLQUFLQyxJQUFJO1FBQzNDRyxLQUFLZ3RCO1FBQVkvc0IsUUFBUUwsS0FBS0ssTUFBTSxHQUFJTCxDQUFBQSxLQUFLSSxHQUFHLEdBQUdndEIsVUFBUztJQUFHO0FBQ3ZFO0FBQ0Esb0VBQW9FO0FBQ3BFLDREQUE0RDtBQUM1RCw4REFBOEQ7QUFDOUQsTUFBTXlVO0lBQ0ZyK0IsWUFBWW9CLElBQUksRUFBRUMsRUFBRSxFQUFFMjVCLElBQUksQ0FBRTtRQUN4QixJQUFJLENBQUM1NUIsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQzI1QixJQUFJLEdBQUdBO0lBQ2hCO0lBQ0EsT0FBT3NELEtBQUtsd0IsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDZCxJQUFJRCxFQUFFN1MsTUFBTSxJQUFJOFMsRUFBRTlTLE1BQU0sRUFDcEIsT0FBTztRQUNYLElBQUssSUFBSTJGLElBQUksR0FBR0EsSUFBSWtOLEVBQUU3UyxNQUFNLEVBQUUyRixJQUFLO1lBQy9CLElBQUlxOUIsS0FBS253QixDQUFDLENBQUNsTixFQUFFLEVBQUVzOUIsS0FBS253QixDQUFDLENBQUNuTixFQUFFO1lBQ3hCLElBQUlxOUIsR0FBR245QixJQUFJLElBQUlvOUIsR0FBR3A5QixJQUFJLElBQUltOUIsR0FBR2w5QixFQUFFLElBQUltOUIsR0FBR245QixFQUFFLElBQUlrOUIsR0FBR3ZELElBQUksSUFBSXdELEdBQUd4RCxJQUFJLEVBQzFELE9BQU87UUFDZjtRQUNBLE9BQU87SUFDWDtJQUNBeUQsS0FBS2h1QixTQUFTLEVBQUVpdUIsUUFBUSxFQUFFO1FBQ3RCLE9BQU9sdEIsV0FBV3RLLE9BQU8sQ0FBQztZQUN0QjJGLFFBQVEsSUFBSTh4QixjQUFjLElBQUksQ0FBQzNELElBQUksR0FBSTBELENBQUFBLFdBQVdqdUIsVUFBVW5ULE1BQU0sR0FBR21ULFVBQVV0VCxNQUFNLEdBQUd1aEM7UUFDNUYsR0FBR24rQixLQUFLLENBQUMsSUFBSSxDQUFDYSxJQUFJLEVBQUUsSUFBSSxDQUFDQyxFQUFFO0lBQy9CO0FBQ0o7QUFDQSxNQUFNczlCLHNCQUFzQnZ0QjtJQUN4QnBSLFlBQVlnN0IsSUFBSSxFQUFFNEQsUUFBUSxDQUFFO1FBQ3hCLEtBQUs7UUFDTCxJQUFJLENBQUM1RCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDNEQsUUFBUSxHQUFHQTtJQUNwQjtJQUNBeCtCLEdBQUcwSCxLQUFLLEVBQUU7UUFBRSxPQUFPQSxNQUFNa3pCLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUksSUFBSWx6QixNQUFNODJCLFFBQVEsSUFBSSxJQUFJLENBQUNBLFFBQVE7SUFBRTtJQUMvRTV4QixRQUFRO1FBQ0osSUFBSW5TLE1BQU15RyxTQUFTMEssYUFBYSxDQUFDO1FBQ2pDLElBQUksSUFBSSxDQUFDNHlCLFFBQVEsRUFBRTtZQUNmL2pDLElBQUlzTyxLQUFLLENBQUM1TCxNQUFNLEdBQUcsSUFBSSxDQUFDeTlCLElBQUksR0FBRztRQUNuQyxPQUNLO1lBQ0RuZ0MsSUFBSXNPLEtBQUssQ0FBQy9MLEtBQUssR0FBRyxJQUFJLENBQUM0OUIsSUFBSSxHQUFHO1lBQzlCbmdDLElBQUlzTyxLQUFLLENBQUM1TCxNQUFNLEdBQUc7WUFDbkIxQyxJQUFJc08sS0FBSyxDQUFDMDFCLE9BQU8sR0FBRztRQUN4QjtRQUNBLE9BQU9oa0M7SUFDWDtJQUNBLElBQUl3VyxrQkFBa0I7UUFBRSxPQUFPLElBQUksQ0FBQ3V0QixRQUFRLEdBQUcsSUFBSSxDQUFDNUQsSUFBSSxHQUFHLENBQUM7SUFBRztBQUNuRTtBQUNBLE1BQU04RDtJQUNGOStCLFlBQVlxTixLQUFLLENBQUU7UUFDZixJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYix5Q0FBeUM7UUFDekMsSUFBSSxDQUFDMHhCLGFBQWEsR0FBRztZQUFFdGlDLE1BQU07WUFBR0UsT0FBT3dCLE9BQU9uQixVQUFVO1lBQUVKLEtBQUs7WUFBR0MsUUFBUTtRQUFFO1FBQzVFLElBQUksQ0FBQ21pQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNwVixVQUFVLEdBQUcsR0FBRyxxQ0FBcUM7UUFDMUQsSUFBSSxDQUFDcVYsYUFBYSxHQUFHLEdBQUcscUNBQXFDO1FBQzdELElBQUksQ0FBQ0MsZUFBZSxHQUFHLEdBQUcsMkNBQTJDO1FBQ3JFLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsR0FBRyw0Q0FBNEM7UUFDdkUsSUFBSSxDQUFDQyxZQUFZLEdBQUcsR0FBRyxtQ0FBbUM7UUFDMUQsSUFBSSxDQUFDQyxXQUFXLEdBQUcsR0FBRyxrQ0FBa0M7UUFDeEQsSUFBSSxDQUFDMS9CLFNBQVMsR0FBRyxHQUFHLHdDQUF3QztRQUM1RCxJQUFJLENBQUMyL0IsZ0JBQWdCLEdBQUc7UUFDeEIsaUVBQWlFO1FBQ2pFLGlCQUFpQjtRQUNqQixJQUFJLENBQUNuaUMsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDRyxNQUFNLEdBQUc7UUFDZCxtRUFBbUU7UUFDbkUsK0RBQStEO1FBQy9ELElBQUksQ0FBQ2lpQyxlQUFlLEdBQUc7UUFDdkIsa0VBQWtFO1FBQ2xFLGdDQUFnQztRQUNoQyxJQUFJLENBQUNDLGtCQUFrQixHQUFHLENBQUM7UUFDM0Isc0JBQXNCO1FBQ3RCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQztRQUNkLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLGtFQUFrRTtRQUNsRSxJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQiw2REFBNkQ7UUFDN0QsOENBQThDO1FBQzlDLElBQUksQ0FBQ2hlLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ2llLG9CQUFvQixHQUFHbnFCLFVBQVVDLEdBQUc7UUFDekMsSUFBSSxDQUFDbXFCLGFBQWEsR0FBRyxFQUFFO1FBQ3ZCLGtFQUFrRTtRQUNsRSw4REFBOEQ7UUFDOUQsNkRBQTZEO1FBQzdELCtEQUErRDtRQUMvRCxpRUFBaUU7UUFDakUsb0VBQW9FO1FBQ3BFLGlFQUFpRTtRQUNqRSxtQkFBbUI7UUFDbkIsSUFBSSxDQUFDQyxzQkFBc0IsR0FBRztRQUM5QixJQUFJQyxnQkFBZ0IzeUIsTUFBTW9PLEtBQUssQ0FBQzBCLG1CQUFtQnBOLElBQUksQ0FBQzNKLENBQUFBLElBQUssT0FBT0EsS0FBSyxjQUFjQSxFQUFFc0YsS0FBSyxJQUFJO1FBQ2xHLElBQUksQ0FBQzhFLFlBQVksR0FBRyxJQUFJcW9CLGFBQWFtSDtRQUNyQyxJQUFJLENBQUNDLFNBQVMsR0FBRzV5QixNQUFNb08sS0FBSyxDQUFDckcsYUFBYWloQixNQUFNLENBQUNqUSxDQUFBQSxJQUFLLE9BQU9BLEtBQUs7UUFDbEUsSUFBSSxDQUFDOFosU0FBUyxHQUFHaEcsVUFBVTlzQixLQUFLLEdBQUdxdEIsWUFBWSxDQUFDLElBQUksQ0FBQ3dGLFNBQVMsRUFBRXhuQyxtREFBSUEsQ0FBQzJVLEtBQUssRUFBRSxJQUFJLENBQUNvRCxZQUFZLENBQUMwb0IsTUFBTSxDQUFDN3JCLE1BQU16UyxHQUFHLEdBQUc7WUFBQyxJQUFJcWpCLGFBQWEsR0FBRyxHQUFHLEdBQUc1USxNQUFNelMsR0FBRyxDQUFDVyxNQUFNO1NBQUU7UUFDOUosSUFBSSxDQUFDOG1CLFFBQVEsR0FBRyxJQUFJLENBQUM4ZCxXQUFXLENBQUMsR0FBRztRQUNwQyxJQUFJLENBQUNDLG1CQUFtQjtRQUN4QixJQUFJLENBQUNDLGlCQUFpQjtRQUN0QixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNDLGNBQWMsQ0FBQyxFQUFFO1FBQ3RDLElBQUksQ0FBQy9aLFdBQVcsR0FBR2hWLFdBQVdoUixHQUFHLENBQUMsSUFBSSxDQUFDOC9CLFFBQVEsQ0FBQ3JsQixHQUFHLENBQUM0aUIsQ0FBQUEsTUFBT0EsSUFBSVksSUFBSSxDQUFDLElBQUksRUFBRTtRQUMxRSxJQUFJLENBQUMrQixvQkFBb0I7SUFDN0I7SUFDQUgsb0JBQW9CO1FBQ2hCLElBQUlwYSxZQUFZO1lBQUMsSUFBSSxDQUFDNUQsUUFBUTtTQUFDLEVBQUUsRUFBRWxCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQzlULEtBQUssQ0FBQ3BTLFNBQVM7UUFDaEUsSUFBSyxJQUFJaUcsSUFBSSxHQUFHQSxLQUFLLEdBQUdBLElBQUs7WUFDekIsSUFBSTJDLE1BQU0zQyxJQUFJaWdCLEtBQUt4SCxJQUFJLEdBQUd3SCxLQUFLb0MsTUFBTTtZQUNyQyxJQUFJLENBQUMwQyxVQUFVbFcsSUFBSSxDQUFDLENBQUMsRUFBRTNPLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUt3QyxPQUFPekMsUUFBUXlDLE9BQU94QyxLQUFLO2dCQUM3RCxJQUFJLEVBQUVELElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUcsSUFBSSxDQUFDNmtCLFdBQVcsQ0FBQ3JpQjtnQkFDcENvaUIsVUFBVWxsQixJQUFJLENBQUMsSUFBSTAvQixTQUFTci9CLE1BQU1DO1lBQ3RDO1FBQ0o7UUFDQSxJQUFJLENBQUM0a0IsU0FBUyxHQUFHQSxVQUFVL1QsSUFBSSxDQUFDLENBQUM5RCxHQUFHQyxJQUFNRCxFQUFFaE4sSUFBSSxHQUFHaU4sRUFBRWpOLElBQUk7UUFDekQsSUFBSSxDQUFDcStCLE1BQU0sR0FBRyxJQUFJLENBQUNTLFNBQVMsQ0FBQzNpQyxNQUFNLElBQUksUUFBUSxtQkFBbUIsTUFBS21pQyxXQUNuRSxJQUFJZ0IsVUFBVSxJQUFJLENBQUNsd0IsWUFBWSxFQUFFLElBQUksQ0FBQzB2QixTQUFTLEVBQUUsSUFBSSxDQUFDamEsU0FBUztJQUN2RTtJQUNBbWEsc0JBQXNCO1FBQ2xCLElBQUksQ0FBQ08sYUFBYSxHQUFHLEVBQUU7UUFDdkIsSUFBSSxDQUFDVCxTQUFTLENBQUMxRSxXQUFXLENBQUMsSUFBSSxDQUFDblosUUFBUSxDQUFDamhCLElBQUksRUFBRSxJQUFJLENBQUNpaEIsUUFBUSxDQUFDaGhCLEVBQUUsRUFBRSxJQUFJLENBQUNtUCxZQUFZLENBQUMwb0IsTUFBTSxDQUFDLElBQUksQ0FBQzdyQixLQUFLLENBQUN6UyxHQUFHLEdBQUcsR0FBRyxHQUFHa1csQ0FBQUE7WUFDN0csSUFBSSxDQUFDNnZCLGFBQWEsQ0FBQzUvQixJQUFJLENBQUMsSUFBSSxDQUFDMCtCLE1BQU0sQ0FBQ21CLEtBQUssSUFBSSxJQUFJOXZCLFFBQVErdkIsV0FBVy92QixPQUFPLElBQUksQ0FBQzJ1QixNQUFNO1FBQzFGO0lBQ0o7SUFDQTFpQixPQUFPQSxNQUFNLEVBQUU0aUIsZUFBZSxJQUFJLEVBQUU7UUFDaEMsSUFBSSxDQUFDdHlCLEtBQUssR0FBRzBQLE9BQU8xUCxLQUFLO1FBQ3pCLElBQUltVSxXQUFXLElBQUksQ0FBQ3llLFNBQVM7UUFDN0IsSUFBSSxDQUFDQSxTQUFTLEdBQUcsSUFBSSxDQUFDNXlCLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ3JHLGFBQWFpaEIsTUFBTSxDQUFDalEsQ0FBQUEsSUFBSyxPQUFPQSxLQUFLO1FBQ3ZFLElBQUkwYSxpQkFBaUIvakIsT0FBT29DLGFBQWE7UUFDekMsSUFBSTRoQixnQkFBZ0I5aUIsYUFBYU8sZ0JBQWdCLENBQUNzaUIsZ0JBQWdCL0MsMEJBQTBCdmMsVUFBVSxJQUFJLENBQUN5ZSxTQUFTLEVBQUVsakIsU0FBU0EsT0FBTzdCLE9BQU8sR0FBR2ppQix3REFBU0EsQ0FBQ21VLEtBQUssQ0FBQyxJQUFJLENBQUNDLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ1csTUFBTTtRQUNyTCxJQUFJeWxDLGFBQWEsSUFBSSxDQUFDZCxTQUFTLENBQUMzaUMsTUFBTTtRQUN0QyxJQUFJMGpDLGVBQWUsSUFBSSxDQUFDM0IsZ0JBQWdCLEdBQUcsT0FBTyxJQUFJLENBQUM0QixjQUFjLENBQUMsSUFBSSxDQUFDdmhDLFNBQVM7UUFDcEYsSUFBSSxDQUFDdWdDLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVMsQ0FBQ3pGLFlBQVksQ0FBQyxJQUFJLENBQUN3RixTQUFTLEVBQUVsakIsT0FBT2lDLFVBQVUsQ0FBQ3BrQixHQUFHLEVBQUUsSUFBSSxDQUFDNFYsWUFBWSxDQUFDMG9CLE1BQU0sQ0FBQyxJQUFJLENBQUM3ckIsS0FBSyxDQUFDelMsR0FBRyxHQUFHbW1DO1FBQzlILElBQUksSUFBSSxDQUFDYixTQUFTLENBQUMzaUMsTUFBTSxJQUFJeWpDLFlBQ3pCamtCLE9BQU94WixLQUFLLElBQUksRUFBRSxxQkFBcUI7UUFDM0MsSUFBSTA5QixjQUFjO1lBQ2QsSUFBSSxDQUFDMUIsZUFBZSxHQUFHeGlCLE9BQU83QixPQUFPLENBQUMyRixNQUFNLENBQUNvZ0IsYUFBYTcvQixJQUFJLEVBQUUsQ0FBQztZQUNqRSxJQUFJLENBQUNvK0Isa0JBQWtCLEdBQUd5QixhQUFhcmtDLEdBQUc7UUFDOUMsT0FDSztZQUNELElBQUksQ0FBQzJpQyxlQUFlLEdBQUcsQ0FBQztZQUN4QixJQUFJLENBQUNDLGtCQUFrQixHQUFHLElBQUksQ0FBQ1UsU0FBUyxDQUFDM2lDLE1BQU07UUFDbkQ7UUFDQSxJQUFJOGtCLFdBQVcwZSxjQUFjeGxDLE1BQU0sR0FBRyxJQUFJLENBQUM0bEMsV0FBVyxDQUFDLElBQUksQ0FBQzllLFFBQVEsRUFBRXRGLE9BQU83QixPQUFPLElBQUksSUFBSSxDQUFDbUgsUUFBUTtRQUNyRyxJQUFJc2QsZ0JBQWlCQSxDQUFBQSxhQUFhcC9CLEtBQUssQ0FBQ29aLElBQUksR0FBRzBJLFNBQVNqaEIsSUFBSSxJQUFJdStCLGFBQWFwL0IsS0FBSyxDQUFDb1osSUFBSSxHQUFHMEksU0FBU2hoQixFQUFFLEtBQ2pHLENBQUMsSUFBSSxDQUFDKy9CLHFCQUFxQixDQUFDL2UsV0FDNUJBLFdBQVcsSUFBSSxDQUFDOGQsV0FBVyxDQUFDLEdBQUdSO1FBQ25DLElBQUkwQixjQUFjLENBQUN0a0IsT0FBTzdCLE9BQU8sQ0FBQzlOLEtBQUssSUFBSzJQLE9BQU94WixLQUFLLEdBQUcsRUFBRSxxQkFBcUIsT0FDOUU4ZSxTQUFTamhCLElBQUksSUFBSSxJQUFJLENBQUNpaEIsUUFBUSxDQUFDamhCLElBQUksSUFBSWloQixTQUFTaGhCLEVBQUUsSUFBSSxJQUFJLENBQUNnaEIsUUFBUSxDQUFDaGhCLEVBQUU7UUFDMUUsSUFBSSxDQUFDZ2hCLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDZ2UsaUJBQWlCO1FBQ3RCLElBQUlnQixhQUNBLElBQUksQ0FBQ2pCLG1CQUFtQjtRQUM1QixJQUFJLElBQUksQ0FBQ0UsUUFBUSxDQUFDL2tDLE1BQU0sSUFBSSxJQUFJLENBQUM4bUIsUUFBUSxDQUFDaGhCLEVBQUUsR0FBRyxJQUFJLENBQUNnaEIsUUFBUSxDQUFDamhCLElBQUksR0FBSSxLQUFLLGFBQWEsT0FBTSxHQUN6RixJQUFJLENBQUNrZ0MsY0FBYyxDQUFDLElBQUksQ0FBQ2YsY0FBYyxDQUFDLElBQUksQ0FBQ2dCLFdBQVcsQ0FBQyxJQUFJLENBQUNqQixRQUFRLEVBQUV2akIsT0FBTzdCLE9BQU87UUFDMUY2QixPQUFPeFosS0FBSyxJQUFJLElBQUksQ0FBQ2k5QixvQkFBb0I7UUFDekMsSUFBSWIsY0FDQSxJQUFJLENBQUNBLFlBQVksR0FBR0E7UUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQ0ksc0JBQXNCLElBQUloakIsT0FBTzJDLFlBQVksSUFBSTNDLE9BQU9uWixJQUFJLENBQUNtbkIsWUFBWSxJQUMvRWhPLE9BQU8xUCxLQUFLLENBQUNwUyxTQUFTLENBQUNrbUIsSUFBSSxDQUFDL1QsS0FBSyxJQUFJMlAsT0FBTzFQLEtBQUssQ0FBQ3BTLFNBQVMsQ0FBQ2ttQixJQUFJLENBQUN2SyxLQUFLLElBQ3RFLENBQUNtRyxPQUFPMVAsS0FBSyxDQUFDb08sS0FBSyxDQUFDWCx3QkFDcEIsSUFBSSxDQUFDaWxCLHNCQUFzQixHQUFHO0lBQ3RDO0lBQ0FuYSxRQUFRaGlCLElBQUksRUFBRTtRQUNWLElBQUlwSixNQUFNb0osS0FBSzZjLFVBQVUsRUFBRXRYLFFBQVFoTCxPQUFPTSxnQkFBZ0IsQ0FBQ2pFO1FBQzNELElBQUk2L0IsU0FBUyxJQUFJLENBQUM3cEIsWUFBWTtRQUM5QixJQUFJNG9CLGFBQWFqd0IsTUFBTWl3QixVQUFVO1FBQ2pDLElBQUksQ0FBQ3lHLG9CQUFvQixHQUFHMTJCLE1BQU04TixTQUFTLElBQUksUUFBUXZCLFVBQVVFLEdBQUcsR0FBR0YsVUFBVUMsR0FBRztRQUNwRixJQUFJOGpCLFVBQVUsSUFBSSxDQUFDanBCLFlBQVksQ0FBQzJvQixzQkFBc0IsQ0FBQ0M7UUFDdkQsSUFBSW9JLFVBQVVobkMsSUFBSXdFLHFCQUFxQjtRQUN2QyxJQUFJeWlDLGlCQUFpQmhJLFdBQVcsSUFBSSxDQUFDN1gsa0JBQWtCLElBQUksSUFBSSxDQUFDdWQsZ0JBQWdCLElBQUlxQyxRQUFRamtDLE1BQU07UUFDbEcsSUFBSSxDQUFDNGhDLGdCQUFnQixHQUFHcUMsUUFBUWprQyxNQUFNO1FBQ3RDLElBQUksQ0FBQ3FrQixrQkFBa0IsR0FBRztRQUMxQixJQUFJNVcsU0FBUyxHQUFHL0YsT0FBTztRQUN2QixJQUFJdThCLFFBQVFwa0MsS0FBSyxJQUFJb2tDLFFBQVFqa0MsTUFBTSxFQUFFO1lBQ2pDLElBQUksRUFBRUosTUFBTSxFQUFFRyxNQUFNLEVBQUUsR0FBR0osU0FBUzFDLEtBQUtnbkM7WUFDdkMsSUFBSSxJQUFJLENBQUNya0MsTUFBTSxJQUFJQSxVQUFVLElBQUksQ0FBQ0csTUFBTSxJQUFJQSxRQUFRO2dCQUNoRCxJQUFJLENBQUNILE1BQU0sR0FBR0E7Z0JBQ2QsSUFBSSxDQUFDRyxNQUFNLEdBQUdBO2dCQUNkME4sVUFBVSxFQUFFLHVCQUF1QjtnQkFDbkN5dUIsVUFBVWdJLGlCQUFpQjtZQUMvQjtRQUNKO1FBQ0EsbUJBQW1CO1FBQ25CLElBQUk3WCxhQUFhLENBQUM4WCxTQUFTdjRCLE1BQU15Z0IsVUFBVSxLQUFLLEtBQUssSUFBSSxDQUFDdHNCLE1BQU07UUFDaEUsSUFBSTJoQyxnQkFBZ0IsQ0FBQ3lDLFNBQVN2NEIsTUFBTTgxQixhQUFhLEtBQUssS0FBSyxJQUFJLENBQUMzaEMsTUFBTTtRQUN0RSxJQUFJLElBQUksQ0FBQ3NzQixVQUFVLElBQUlBLGNBQWMsSUFBSSxDQUFDcVYsYUFBYSxJQUFJQSxlQUFlO1lBQ3RFLElBQUksQ0FBQ3JWLFVBQVUsR0FBR0E7WUFDbEIsSUFBSSxDQUFDcVYsYUFBYSxHQUFHQTtZQUNyQmowQixVQUFVLEVBQUUsdUJBQXVCLE1BQUssRUFBRSxxQkFBcUI7UUFDbkU7UUFDQSxJQUFJLElBQUksQ0FBQ3EwQixXQUFXLElBQUl6N0IsS0FBSzJoQixTQUFTLENBQUN6bUIsV0FBVyxFQUFFO1lBQ2hELElBQUl1N0IsT0FBT3RQLFlBQVksRUFDbkIwVyxpQkFBaUI7WUFDckIsSUFBSSxDQUFDcEMsV0FBVyxHQUFHejdCLEtBQUsyaEIsU0FBUyxDQUFDem1CLFdBQVc7WUFDN0NrTSxVQUFVLEVBQUUsdUJBQXVCO1FBQ3ZDO1FBQ0EsSUFBSXJMLFlBQVlpRSxLQUFLMmhCLFNBQVMsQ0FBQzVsQixTQUFTLEdBQUcsSUFBSSxDQUFDckMsTUFBTTtRQUN0RCxJQUFJLElBQUksQ0FBQ3FDLFNBQVMsSUFBSUEsV0FBVztZQUM3QixJQUFJLENBQUM2L0Isa0JBQWtCLEdBQUcsQ0FBQztZQUMzQixJQUFJLENBQUM3L0IsU0FBUyxHQUFHQTtRQUNyQjtRQUNBLElBQUksQ0FBQzIvQixnQkFBZ0IsR0FBR3Y4QixtQkFBbUJhLEtBQUsyaEIsU0FBUztRQUN6RCxpQkFBaUI7UUFDakIsSUFBSXdaLGdCQUFnQixDQUFDLElBQUksQ0FBQ2EsUUFBUSxHQUFHeEIsaUJBQWlCSixpQkFBZ0IsRUFBR3hqQyxLQUFLLElBQUksQ0FBQ292QixVQUFVO1FBQzdGLElBQUkrWCxPQUFPNUMsY0FBY25pQyxHQUFHLEdBQUcsSUFBSSxDQUFDbWlDLGFBQWEsQ0FBQ25pQyxHQUFHLEVBQUVnbEMsVUFBVTdDLGNBQWNsaUMsTUFBTSxHQUFHLElBQUksQ0FBQ2tpQyxhQUFhLENBQUNsaUMsTUFBTTtRQUNqSCxJQUFJLENBQUNraUMsYUFBYSxHQUFHQTtRQUNyQixJQUFJQyxTQUFTLElBQUksQ0FBQ0QsYUFBYSxDQUFDbGlDLE1BQU0sR0FBRyxJQUFJLENBQUNraUMsYUFBYSxDQUFDbmlDLEdBQUcsSUFBSSxJQUFJLENBQUNtaUMsYUFBYSxDQUFDcGlDLEtBQUssR0FBRyxJQUFJLENBQUNvaUMsYUFBYSxDQUFDdGlDLElBQUk7UUFDckgsSUFBSXVpQyxVQUFVLElBQUksQ0FBQ0EsTUFBTSxFQUFFO1lBQ3ZCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtZQUNkLElBQUlBLFFBQ0F5QyxpQkFBaUI7UUFDekI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDekMsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDVyxZQUFZLEVBQ2xDLE9BQU87UUFDWCxJQUFJdGEsZUFBZW1jLFFBQVFwa0MsS0FBSztRQUNoQyxJQUFJLElBQUksQ0FBQzhoQyxlQUFlLElBQUk3WixnQkFBZ0IsSUFBSSxDQUFDK1osWUFBWSxJQUFJeDdCLEtBQUsyaEIsU0FBUyxDQUFDM21CLFlBQVksRUFBRTtZQUMxRixJQUFJLENBQUNzZ0MsZUFBZSxHQUFHc0MsUUFBUXBrQyxLQUFLO1lBQ3BDLElBQUksQ0FBQ2dpQyxZQUFZLEdBQUd4N0IsS0FBSzJoQixTQUFTLENBQUMzbUIsWUFBWTtZQUMvQ29NLFVBQVUsRUFBRSx1QkFBdUI7UUFDdkM7UUFDQSxJQUFJeTJCLGdCQUFnQjtZQUNoQixJQUFJbkksY0FBYzExQixLQUFLaU4sT0FBTyxDQUFDdVUseUJBQXlCLENBQUMsSUFBSSxDQUFDL0MsUUFBUTtZQUN0RSxJQUFJZ1ksT0FBT2hCLHFCQUFxQixDQUFDQyxjQUM3QkcsVUFBVTtZQUNkLElBQUlBLFdBQVdZLE9BQU90UCxZQUFZLElBQUlydEIsS0FBS0MsR0FBRyxDQUFDMG5CLGVBQWUsSUFBSSxDQUFDNlosZUFBZSxJQUFJN0UsT0FBTzlwQixTQUFTLEVBQUU7Z0JBQ3BHLElBQUksRUFBRUQsVUFBVSxFQUFFQyxTQUFTLEVBQUVGLFVBQVUsRUFBRSxHQUFHek0sS0FBS2lOLE9BQU8sQ0FBQ1YsZUFBZTtnQkFDeEVzcEIsVUFBVW5wQixhQUFhLEtBQUsrcEIsT0FBT1osT0FBTyxDQUFDTCxZQUFZOW9CLFlBQVlDLFdBQVdGLFlBQVlnVixlQUFlOVUsV0FBVytvQjtnQkFDcEgsSUFBSUcsU0FBUztvQkFDVDcxQixLQUFLaU4sT0FBTyxDQUFDbVAsUUFBUSxHQUFHO29CQUN4QmhWLFVBQVUsRUFBRSx1QkFBdUI7Z0JBQ3ZDO1lBQ0o7WUFDQSxJQUFJMjJCLE9BQU8sS0FBS0MsVUFBVSxHQUN0QjM4QixPQUFPdkgsS0FBS3NGLEdBQUcsQ0FBQzIrQixNQUFNQztpQkFDckIsSUFBSUQsT0FBTyxLQUFLQyxVQUFVLEdBQzNCMzhCLE9BQU92SCxLQUFLK0MsR0FBRyxDQUFDa2hDLE1BQU1DO1lBQzFCdkgsT0FBTy9hLGFBQWEsR0FBRztZQUN2QixLQUFLLElBQUl1aUIsTUFBTSxJQUFJLENBQUM1YixTQUFTLENBQUU7Z0JBQzNCLElBQUkyVCxVQUFVaUksR0FBR3pnQyxJQUFJLElBQUksSUFBSSxDQUFDaWhCLFFBQVEsQ0FBQ2poQixJQUFJLEdBQUdrNEIsY0FBYzExQixLQUFLaU4sT0FBTyxDQUFDdVUseUJBQXlCLENBQUN5YztnQkFDbkcsSUFBSSxDQUFDM0IsU0FBUyxHQUFHLENBQUN6RyxVQUFVUyxVQUFVOXNCLEtBQUssR0FBR3F0QixZQUFZLENBQUMsSUFBSSxDQUFDd0YsU0FBUyxFQUFFeG5DLG1EQUFJQSxDQUFDMlUsS0FBSyxFQUFFLElBQUksQ0FBQ29ELFlBQVksRUFBRTtvQkFBQyxJQUFJeU4sYUFBYSxHQUFHLEdBQUcsR0FBR3JhLEtBQUt5SixLQUFLLENBQUN6UyxHQUFHLENBQUNXLE1BQU07aUJBQUUsSUFBSSxJQUFJLENBQUMya0MsU0FBUyxFQUFFckYsWUFBWSxDQUFDUixRQUFRLEdBQUdaLFNBQVMsSUFBSUUsZ0JBQWdCa0ksR0FBR3pnQyxJQUFJLEVBQUV3NEI7WUFDbFA7WUFDQSxJQUFJUyxPQUFPL2EsYUFBYSxFQUNwQnRVLFVBQVUsRUFBRSxxQkFBcUI7UUFDekM7UUFDQSxJQUFJODJCLGlCQUFpQixDQUFDLElBQUksQ0FBQ1YscUJBQXFCLENBQUMsSUFBSSxDQUFDL2UsUUFBUSxFQUFFcGQsU0FDNUQsSUFBSSxDQUFDMDZCLFlBQVksSUFBSyxLQUFJLENBQUNBLFlBQVksQ0FBQ3AvQixLQUFLLENBQUNvWixJQUFJLEdBQUcsSUFBSSxDQUFDMEksUUFBUSxDQUFDamhCLElBQUksSUFDbkUsSUFBSSxDQUFDdStCLFlBQVksQ0FBQ3AvQixLQUFLLENBQUNvWixJQUFJLEdBQUcsSUFBSSxDQUFDMEksUUFBUSxDQUFDaGhCLEVBQUU7UUFDdkQsSUFBSXlnQyxnQkFDQSxJQUFJLENBQUN6ZixRQUFRLEdBQUcsSUFBSSxDQUFDOGQsV0FBVyxDQUFDbDdCLE1BQU0sSUFBSSxDQUFDMDZCLFlBQVk7UUFDNUQsSUFBSSxDQUFDVSxpQkFBaUI7UUFDdEIsSUFBSSxTQUFVLEVBQUUscUJBQXFCLE9BQU95QixnQkFDeEMsSUFBSSxDQUFDMUIsbUJBQW1CO1FBQzVCLElBQUksSUFBSSxDQUFDRSxRQUFRLENBQUMva0MsTUFBTSxJQUFJLElBQUksQ0FBQzhtQixRQUFRLENBQUNoaEIsRUFBRSxHQUFHLElBQUksQ0FBQ2doQixRQUFRLENBQUNqaEIsSUFBSSxHQUFJLEtBQUssYUFBYSxPQUFNLEdBQ3pGLElBQUksQ0FBQ2tnQyxjQUFjLENBQUMsSUFBSSxDQUFDZixjQUFjLENBQUM5RyxVQUFVLEVBQUUsR0FBRyxJQUFJLENBQUM2RyxRQUFRLEVBQUUxOEI7UUFDMUVvSCxVQUFVLElBQUksQ0FBQ3cxQixvQkFBb0I7UUFDbkMsSUFBSSxJQUFJLENBQUNULHNCQUFzQixFQUFFO1lBQzdCLElBQUksQ0FBQ0Esc0JBQXNCLEdBQUc7WUFDOUIsK0RBQStEO1lBQy9ELDJEQUEyRDtZQUMzRCw0REFBNEQ7WUFDNUQsV0FBVztZQUNYbjhCLEtBQUtpTixPQUFPLENBQUM0VCxrQkFBa0I7UUFDbkM7UUFDQSxPQUFPelo7SUFDWDtJQUNBLElBQUkrMkIsYUFBYTtRQUFFLE9BQU8sSUFBSSxDQUFDdEMsTUFBTSxDQUFDdUMsT0FBTyxDQUFDLElBQUksQ0FBQ2pELGFBQWEsQ0FBQ25pQyxHQUFHO0lBQUc7SUFDdkUsSUFBSXFsQyxnQkFBZ0I7UUFBRSxPQUFPLElBQUksQ0FBQ3hDLE1BQU0sQ0FBQ3VDLE9BQU8sQ0FBQyxJQUFJLENBQUNqRCxhQUFhLENBQUNsaUMsTUFBTTtJQUFHO0lBQzdFc2pDLFlBQVlsN0IsSUFBSSxFQUFFMDZCLFlBQVksRUFBRTtRQUM1QixxREFBcUQ7UUFDckQsaUVBQWlFO1FBQ2pFLDhEQUE4RDtRQUM5RCxJQUFJdUMsWUFBWSxNQUFNeGtDLEtBQUtzRixHQUFHLENBQUMsQ0FBQyxLQUFLdEYsS0FBSytDLEdBQUcsQ0FBQyxLQUFLd0UsT0FBTyxLQUFLLGFBQWEsTUFBSztRQUNqRixJQUFJZ1csTUFBTSxJQUFJLENBQUNpbEIsU0FBUyxFQUFFN0YsU0FBUyxJQUFJLENBQUM3cEIsWUFBWTtRQUNwRCxJQUFJLEVBQUV1eEIsVUFBVSxFQUFFRSxhQUFhLEVBQUUsR0FBRyxJQUFJO1FBQ3hDLElBQUk1ZixXQUFXLElBQUlvZSxTQUFTeGxCLElBQUk5RyxNQUFNLENBQUM0dEIsYUFBYUcsWUFBWSxLQUFLLGFBQWEsS0FBSWxJLFVBQVVzQyxRQUFRLEVBQUVqQyxRQUFRLEdBQUcsR0FBR2o1QixJQUFJLEVBQUU2WixJQUFJOUcsTUFBTSxDQUFDOHRCLGdCQUFnQixDQUFDLElBQUlDLFNBQVEsSUFBSyxLQUFLLGFBQWEsS0FBSWxJLFVBQVVzQyxRQUFRLEVBQUVqQyxRQUFRLEdBQUcsR0FBR2g1QixFQUFFO1FBQ3JPLDBFQUEwRTtRQUMxRSxJQUFJcytCLGNBQWM7WUFDZCxJQUFJLEVBQUVobUIsSUFBSSxFQUFFLEdBQUdnbUIsYUFBYXAvQixLQUFLO1lBQ2pDLElBQUlvWixPQUFPMEksU0FBU2poQixJQUFJLElBQUl1WSxPQUFPMEksU0FBU2hoQixFQUFFLEVBQUU7Z0JBQzVDLElBQUk4Z0MsYUFBYXprQyxLQUFLK0MsR0FBRyxDQUFDLElBQUksQ0FBQzIrQixZQUFZLEVBQUUsSUFBSSxDQUFDTCxhQUFhLENBQUNsaUMsTUFBTSxHQUFHLElBQUksQ0FBQ2tpQyxhQUFhLENBQUNuaUMsR0FBRztnQkFDL0YsSUFBSWtVLFFBQVFtSyxJQUFJOUcsTUFBTSxDQUFDd0YsTUFBTXFnQixVQUFVK0MsS0FBSyxFQUFFMUMsUUFBUSxHQUFHLElBQUkrSDtnQkFDN0QsSUFBSXpDLGFBQWE3aEMsQ0FBQyxJQUFJLFVBQ2xCc2tDLFNBQVMsQ0FBQ3R4QixNQUFNbFUsR0FBRyxHQUFHa1UsTUFBTWpVLE1BQU0sSUFBSSxJQUFJc2xDLGFBQWE7cUJBQ3RELElBQUl4QyxhQUFhN2hDLENBQUMsSUFBSSxXQUFXNmhDLGFBQWE3aEMsQ0FBQyxJQUFJLGFBQWE2YixPQUFPMEksU0FBU2poQixJQUFJLEVBQ3JGZ2hDLFNBQVN0eEIsTUFBTWxVLEdBQUc7cUJBRWxCd2xDLFNBQVN0eEIsTUFBTWpVLE1BQU0sR0FBR3NsQztnQkFDNUI5ZixXQUFXLElBQUlvZSxTQUFTeGxCLElBQUk5RyxNQUFNLENBQUNpdUIsU0FBUyxLQUFLLGFBQWEsTUFBSyxHQUFHcEksVUFBVXNDLFFBQVEsRUFBRWpDLFFBQVEsR0FBRyxHQUFHajVCLElBQUksRUFBRTZaLElBQUk5RyxNQUFNLENBQUNpdUIsU0FBU0QsYUFBYSxLQUFLLGFBQWEsTUFBSyxHQUFHbkksVUFBVXNDLFFBQVEsRUFBRWpDLFFBQVEsR0FBRyxHQUFHaDVCLEVBQUU7WUFDak47UUFDSjtRQUNBLE9BQU9naEI7SUFDWDtJQUNBOGUsWUFBWTllLFFBQVEsRUFBRW5ILE9BQU8sRUFBRTtRQUMzQixJQUFJOVosT0FBTzhaLFFBQVEyRixNQUFNLENBQUN3QixTQUFTamhCLElBQUksRUFBRSxDQUFDLElBQUlDLEtBQUs2WixRQUFRMkYsTUFBTSxDQUFDd0IsU0FBU2hoQixFQUFFLEVBQUU7UUFDL0UsT0FBTyxJQUFJby9CLFNBQVMsSUFBSSxDQUFDUCxTQUFTLENBQUMvckIsTUFBTSxDQUFDL1MsTUFBTTQ0QixVQUFVK0MsS0FBSyxFQUFFLElBQUksQ0FBQ3ZzQixZQUFZLEVBQUUsR0FBRyxHQUFHcFAsSUFBSSxFQUFFLElBQUksQ0FBQzgrQixTQUFTLENBQUMvckIsTUFBTSxDQUFDOVMsSUFBSTI0QixVQUFVK0MsS0FBSyxFQUFFLElBQUksQ0FBQ3ZzQixZQUFZLEVBQUUsR0FBRyxHQUFHblAsRUFBRTtJQUMxSztJQUNBLDREQUE0RDtJQUM1RCx5Q0FBeUM7SUFDekMrL0Isc0JBQXNCLEVBQUVoZ0MsSUFBSSxFQUFFQyxFQUFFLEVBQUUsRUFBRTRELE9BQU8sQ0FBQyxFQUFFO1FBQzFDLElBQUksQ0FBQyxJQUFJLENBQUMrNUIsTUFBTSxFQUNaLE9BQU87UUFDWCxJQUFJLEVBQUVwaUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDc2pDLFNBQVMsQ0FBQy9yQixNQUFNLENBQUMvUyxNQUFNNDRCLFVBQVUrQyxLQUFLLEVBQUUsSUFBSSxDQUFDdnNCLFlBQVksRUFBRSxHQUFHO1FBQ2pGLElBQUksRUFBRTNULE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQ3FqQyxTQUFTLENBQUMvckIsTUFBTSxDQUFDOVMsSUFBSTI0QixVQUFVK0MsS0FBSyxFQUFFLElBQUksQ0FBQ3ZzQixZQUFZLEVBQUUsR0FBRztRQUNsRixJQUFJLEVBQUV1eEIsVUFBVSxFQUFFRSxhQUFhLEVBQUUsR0FBRyxJQUFJO1FBQ3hDLE9BQU8sQ0FBQzdnQyxRQUFRLEtBQUt4RSxPQUFPbWxDLGFBQWFya0MsS0FBS3NGLEdBQUcsQ0FBQyxHQUFHLHFCQUFxQixLQUFJdEYsS0FBSytDLEdBQUcsQ0FBQyxDQUFDd0UsTUFBTSxJQUFJLHFCQUFxQixLQUFHLEtBQ3JINUQsQ0FBQUEsTUFBTSxJQUFJLENBQUNnTSxLQUFLLENBQUN6UyxHQUFHLENBQUNXLE1BQU0sSUFDeEJzQixVQUFVb2xDLGdCQUFnQnZrQyxLQUFLc0YsR0FBRyxDQUFDLEdBQUcscUJBQXFCLEtBQUl0RixLQUFLK0MsR0FBRyxDQUFDd0UsTUFBTSxJQUFJLHFCQUFxQixLQUFHLEtBQzdHckksTUFBTW1sQyxhQUFhLElBQUksS0FBSyxhQUFhLE9BQU1sbEMsU0FBU29sQyxnQkFBZ0IsSUFBSSxLQUFLLGFBQWE7SUFDdkc7SUFDQVYsWUFBWW5mLElBQUksRUFBRWxILE9BQU8sRUFBRTtRQUN2QixJQUFJLENBQUNrSCxLQUFLN21CLE1BQU0sSUFBSTJmLFFBQVE5TixLQUFLLEVBQzdCLE9BQU9nVjtRQUNYLElBQUlpZ0IsU0FBUyxFQUFFO1FBQ2YsS0FBSyxJQUFJeEUsT0FBT3piLEtBQ1osSUFBSSxDQUFDbEgsUUFBUW9uQixZQUFZLENBQUN6RSxJQUFJejhCLElBQUksRUFBRXk4QixJQUFJeDhCLEVBQUUsR0FDdENnaEMsT0FBT3RoQyxJQUFJLENBQUMsSUFBSXM5QixRQUFRbmpCLFFBQVEyRixNQUFNLENBQUNnZCxJQUFJejhCLElBQUksR0FBRzhaLFFBQVEyRixNQUFNLENBQUNnZCxJQUFJeDhCLEVBQUUsR0FBR3c4QixJQUFJN0MsSUFBSTtRQUMxRixPQUFPcUg7SUFDWDtJQUNBLGlFQUFpRTtJQUNqRSxpRUFBaUU7SUFDakUsNENBQTRDO0lBQzVDLGdFQUFnRTtJQUNoRSwyREFBMkQ7SUFDM0Qsa0VBQWtFO0lBQ2xFLGtEQUFrRDtJQUNsRDlCLGVBQWVnQyxPQUFPLEVBQUVDLFVBQVUsRUFBRTtRQUNoQyxJQUFJOUQsV0FBVyxJQUFJLENBQUNsdUIsWUFBWSxDQUFDdWEsWUFBWTtRQUM3QyxJQUFJelgsU0FBU29yQixXQUFXLE1BQU0saUJBQWlCLE1BQUssS0FBSyxhQUFhLEtBQUkrRCxhQUFhbnZCLFVBQVUsR0FBR292QixlQUFlcHZCLFVBQVU7UUFDN0gsZ0ZBQWdGO1FBQ2hGLElBQUksSUFBSSxDQUFDdXNCLG9CQUFvQixJQUFJbnFCLFVBQVVDLEdBQUcsSUFBSSxDQUFDK29CLFVBQy9DLE9BQU8sRUFBRTtRQUNiLElBQUl0YyxPQUFPLEVBQUU7UUFDYixJQUFJdWdCLFNBQVMsQ0FBQ3ZoQyxNQUFNQyxJQUFJMFEsTUFBTTZ3QjtZQUMxQixJQUFJdmhDLEtBQUtELE9BQU9xaEMsWUFDWjtZQUNKLElBQUlsZSxNQUFNLElBQUksQ0FBQ2xYLEtBQUssQ0FBQ3BTLFNBQVMsQ0FBQ2ttQixJQUFJLEVBQUUwaEIsUUFBUTtnQkFBQ3RlLElBQUluakIsSUFBSTthQUFDO1lBQ3ZELElBQUksQ0FBQ21qQixJQUFJblgsS0FBSyxFQUNWeTFCLE1BQU05aEMsSUFBSSxDQUFDd2pCLElBQUlsakIsRUFBRTtZQUNyQixLQUFLLElBQUl3QyxPQUFPZy9CLE1BQU87Z0JBQ25CLElBQUloL0IsTUFBTXpDLFFBQVF5QyxNQUFNeEMsSUFBSTtvQkFDeEJzaEMsT0FBT3ZoQyxNQUFNeUMsTUFBTSxHQUFHLHNCQUFzQixLQUFJa08sTUFBTTZ3QjtvQkFDdERELE9BQU85K0IsTUFBTSxHQUFHLHNCQUFzQixLQUFJeEMsSUFBSTBRLE1BQU02d0I7b0JBQ3BEO2dCQUNKO1lBQ0o7WUFDQSxJQUFJL0UsTUFBTXJ4QixLQUFLKzFCLFNBQVMxRSxDQUFBQSxNQUFPQSxJQUFJejhCLElBQUksSUFBSTJRLEtBQUszUSxJQUFJLElBQUl5OEIsSUFBSXg4QixFQUFFLElBQUkwUSxLQUFLMVEsRUFBRSxJQUNyRTNELEtBQUtDLEdBQUcsQ0FBQ2tnQyxJQUFJejhCLElBQUksR0FBR0EsUUFBUXFoQyxjQUFjL2tDLEtBQUtDLEdBQUcsQ0FBQ2tnQyxJQUFJeDhCLEVBQUUsR0FBR0EsTUFBTW9oQyxjQUNsRSxDQUFDSSxNQUFNOXlCLElBQUksQ0FBQ2xNLENBQUFBLE1BQU9nNkIsSUFBSXo4QixJQUFJLEdBQUd5QyxPQUFPZzZCLElBQUl4OEIsRUFBRSxHQUFHd0M7WUFDbEQsSUFBSSxDQUFDZzZCLEtBQUs7Z0JBQ04sZ0ZBQWdGO2dCQUNoRixJQUFJeDhCLEtBQUswUSxLQUFLMVEsRUFBRSxJQUFJbWhDLGNBQWM5RCxZQUM5QjhELFdBQVcxQyxhQUFhLENBQUMvdkIsSUFBSSxDQUFDckQsQ0FBQUEsSUFBS0EsRUFBRXRMLElBQUksSUFBSUMsTUFBTXFMLEVBQUVyTCxFQUFFLElBQUlBLEtBQUs7b0JBQ2hFLElBQUlzakIsWUFBWTZkLFdBQVdsWCxrQkFBa0IsQ0FBQ3h5Qiw4REFBZUEsQ0FBQ2liLE1BQU0sQ0FBQzFTLEtBQUssT0FBTyxNQUFNc1ksSUFBSTtvQkFDM0YsSUFBSWdMLFlBQVl2akIsTUFDWkMsS0FBS3NqQjtnQkFDYjtnQkFDQWtaLE1BQU0sSUFBSVEsUUFBUWo5QixNQUFNQyxJQUFJLElBQUksQ0FBQ3loQyxPQUFPLENBQUMvd0IsTUFBTTNRLE1BQU1DLElBQUl1aEM7WUFDN0Q7WUFDQXhnQixLQUFLcmhCLElBQUksQ0FBQzg4QjtRQUNkO1FBQ0EsS0FBSyxJQUFJOXJCLFFBQVEsSUFBSSxDQUFDNHVCLGFBQWEsQ0FBRTtZQUNqQyxJQUFJNXVCLEtBQUt4VyxNQUFNLEdBQUdtbkMsY0FDZDtZQUNKLElBQUlFLFlBQVlHLGNBQWNoeEIsS0FBSzNRLElBQUksRUFBRTJRLEtBQUsxUSxFQUFFLEVBQUUsSUFBSSxDQUFDNCtCLFNBQVM7WUFDaEUsSUFBSTJDLFVBQVVJLEtBQUssR0FBR04sY0FDbEI7WUFDSixJQUFJdG9DLFNBQVMsSUFBSSxDQUFDdWxDLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVksQ0FBQ3AvQixLQUFLLENBQUNvWixJQUFJLEdBQUc7WUFDaEUsSUFBSXNwQixVQUFVQztZQUNkLElBQUl4RSxVQUFVO2dCQUNWLElBQUl5RSxlQUFlLFNBQVUsSUFBSSxDQUFDM3lCLFlBQVksQ0FBQzBhLFVBQVUsR0FBSSxJQUFJLENBQUMxYSxZQUFZLENBQUNGLFVBQVU7Z0JBQ3pGLElBQUkxVCxLQUFLd21DO2dCQUNULElBQUlocEMsVUFBVSxNQUFNO29CQUNoQixJQUFJaXBDLGFBQWFDLGFBQWFWLFdBQVd4b0M7b0JBQ3pDLElBQUltcEMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDdEIsYUFBYSxHQUFHLElBQUksQ0FBQ0YsVUFBVSxJQUFJLElBQUlvQixZQUFXLElBQUtweEIsS0FBS3hVLE1BQU07b0JBQ3pGWCxNQUFNeW1DLGFBQWFFO29CQUNuQkgsTUFBTUMsYUFBYUU7Z0JBQ3ZCLE9BQ0s7b0JBQ0QzbUMsTUFBTSxDQUFDLElBQUksQ0FBQ21sQyxVQUFVLEdBQUdod0IsS0FBS25WLEdBQUcsR0FBR3VtQyxZQUFXLElBQUtweEIsS0FBS3hVLE1BQU07b0JBQy9ENmxDLE1BQU0sQ0FBQyxJQUFJLENBQUNuQixhQUFhLEdBQUdsd0IsS0FBS25WLEdBQUcsR0FBR3VtQyxZQUFXLElBQUtweEIsS0FBS3hVLE1BQU07Z0JBQ3RFO2dCQUNBMGxDLFdBQVdPLGFBQWFaLFdBQVdobUM7Z0JBQ25Dc21DLFNBQVNNLGFBQWFaLFdBQVdRO1lBQ3JDLE9BQ0s7Z0JBQ0QsSUFBSWh6QixhQUFhd3lCLFVBQVVJLEtBQUssR0FBRyxJQUFJLENBQUN4eUIsWUFBWSxDQUFDRCxTQUFTO2dCQUM5RCxJQUFJa3pCLGNBQWNud0IsU0FBUyxJQUFJLENBQUM5QyxZQUFZLENBQUNELFNBQVM7Z0JBQ3RELElBQUk5VCxNQUFNRTtnQkFDVixJQUFJdkMsVUFBVSxNQUFNO29CQUNoQixJQUFJaXBDLGFBQWFDLGFBQWFWLFdBQVd4b0M7b0JBQ3pDLElBQUltcEMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDeEUsYUFBYSxDQUFDcGlDLEtBQUssR0FBRyxJQUFJLENBQUNvaUMsYUFBYSxDQUFDdGlDLElBQUksSUFBSSxJQUFJZ25DLFdBQVUsSUFBS3J6QjtvQkFDM0YzVCxPQUFPNG1DLGFBQWFFO29CQUNwQjVtQyxRQUFRMG1DLGFBQWFFO2dCQUN6QixPQUNLO29CQUNEOW1DLE9BQU8sQ0FBQyxJQUFJLENBQUNzaUMsYUFBYSxDQUFDdGlDLElBQUksR0FBR2duQyxXQUFVLElBQUtyekI7b0JBQ2pEelQsUUFBUSxDQUFDLElBQUksQ0FBQ29pQyxhQUFhLENBQUNwaUMsS0FBSyxHQUFHOG1DLFdBQVUsSUFBS3J6QjtnQkFDdkQ7Z0JBQ0E2eUIsV0FBV08sYUFBYVosV0FBV25tQztnQkFDbkN5bUMsU0FBU00sYUFBYVosV0FBV2ptQztZQUNyQztZQUNBLElBQUlzbUMsV0FBV2x4QixLQUFLM1EsSUFBSSxFQUNwQnVoQyxPQUFPNXdCLEtBQUszUSxJQUFJLEVBQUU2aEMsVUFBVWx4QixNQUFNNndCO1lBQ3RDLElBQUlNLFNBQVNueEIsS0FBSzFRLEVBQUUsRUFDaEJzaEMsT0FBT08sUUFBUW54QixLQUFLMVEsRUFBRSxFQUFFMFEsTUFBTTZ3QjtRQUN0QztRQUNBLE9BQU94Z0I7SUFDWDtJQUNBMGdCLFFBQVEvd0IsSUFBSSxFQUFFM1EsSUFBSSxFQUFFQyxFQUFFLEVBQUV1aEMsU0FBUyxFQUFFO1FBQy9CLElBQUljLFdBQVdKLGFBQWFWLFdBQVd2aEMsTUFBTWlpQyxhQUFhVixXQUFXeGhDO1FBQ3JFLElBQUksSUFBSSxDQUFDb1AsWUFBWSxDQUFDdWEsWUFBWSxFQUFFO1lBQ2hDLE9BQU9oWixLQUFLeFUsTUFBTSxHQUFHbW1DO1FBQ3pCLE9BQ0s7WUFDRCxPQUFPZCxVQUFVSSxLQUFLLEdBQUcsSUFBSSxDQUFDeHlCLFlBQVksQ0FBQ0QsU0FBUyxHQUFHbXpCO1FBQzNEO0lBQ0o7SUFDQXBDLGVBQWVsZixJQUFJLEVBQUU7UUFDakIsSUFBSSxDQUFDaWMsUUFBUUMsSUFBSSxDQUFDbGMsTUFBTSxJQUFJLENBQUNrZSxRQUFRLEdBQUc7WUFDcEMsSUFBSSxDQUFDQSxRQUFRLEdBQUdsZTtZQUNoQixJQUFJLENBQUNvRSxXQUFXLEdBQUdoVixXQUFXaFIsR0FBRyxDQUFDNGhCLEtBQUtuSCxHQUFHLENBQUM0aUIsQ0FBQUEsTUFBT0EsSUFBSVksSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUNqdUIsWUFBWSxDQUFDdWEsWUFBWTtRQUNuRztJQUNKO0lBQ0F5Vix1QkFBdUI7UUFDbkIsSUFBSS93QixPQUFPLElBQUksQ0FBQ3d3QixTQUFTO1FBQ3pCLElBQUksSUFBSSxDQUFDSyxRQUFRLENBQUMva0MsTUFBTSxFQUNwQmtVLE9BQU9BLEtBQUtpVCxNQUFNLENBQUMsSUFBSSxDQUFDOEQsV0FBVztRQUN2QyxJQUFJblQsU0FBUyxFQUFFO1FBQ2YzYSx1REFBUUEsQ0FBQzZjLEtBQUssQ0FBQzlGLE1BQU0sSUFBSSxDQUFDNFMsUUFBUSxDQUFDamhCLElBQUksRUFBRSxJQUFJLENBQUNpaEIsUUFBUSxDQUFDaGhCLEVBQUUsRUFBRTtZQUN2RDBULE1BQUszVCxJQUFJLEVBQUVDLEVBQUU7Z0JBQUlnUyxPQUFPdFMsSUFBSSxDQUFDO29CQUFFSztvQkFBTUM7Z0JBQUc7WUFBSTtZQUM1Q2lSLFVBQVU7UUFDZCxHQUFHO1FBQ0gsSUFBSTNELFVBQVUwRSxPQUFPOVgsTUFBTSxJQUFJLElBQUksQ0FBQ3VrQyxhQUFhLENBQUN2a0MsTUFBTSxJQUNwRCxJQUFJLENBQUN1a0MsYUFBYSxDQUFDL3ZCLElBQUksQ0FBQyxDQUFDckQsR0FBR3hMLElBQU13TCxFQUFFdEwsSUFBSSxJQUFJaVMsTUFBTSxDQUFDblMsRUFBRSxDQUFDRSxJQUFJLElBQUlzTCxFQUFFckwsRUFBRSxJQUFJZ1MsTUFBTSxDQUFDblMsRUFBRSxDQUFDRyxFQUFFO1FBQ3RGLElBQUksQ0FBQ3krQixhQUFhLEdBQUd6c0I7UUFDckIsT0FBTzFFLFVBQVUsRUFBRSx1QkFBdUIsTUFBSztJQUNuRDtJQUNBdVgsWUFBWXJpQixHQUFHLEVBQUU7UUFDYixPQUFPLE9BQVEsSUFBSSxDQUFDd2UsUUFBUSxDQUFDamhCLElBQUksSUFBSXlDLE9BQU8sSUFBSSxDQUFDd2UsUUFBUSxDQUFDaGhCLEVBQUUsSUFBSSxJQUFJLENBQUNzL0IsYUFBYSxDQUFDbjBCLElBQUksQ0FBQzZCLENBQUFBLElBQUtBLEVBQUVqTixJQUFJLElBQUl5QyxPQUFPd0ssRUFBRWhOLEVBQUUsSUFBSXdDLFFBQ2xIZzlCLFdBQVcsSUFBSSxDQUFDWCxTQUFTLENBQUMvckIsTUFBTSxDQUFDdFEsS0FBS20yQixVQUFVK0MsS0FBSyxFQUFFLElBQUksQ0FBQ3ZzQixZQUFZLEVBQUUsR0FBRyxJQUFJLElBQUksQ0FBQ2l2QixNQUFNO0lBQ3BHO0lBQ0FrRSxrQkFBa0JwbUMsTUFBTSxFQUFFO1FBQ3RCLE9BQU9zakMsV0FBVyxJQUFJLENBQUNYLFNBQVMsQ0FBQy9yQixNQUFNLENBQUMsSUFBSSxDQUFDc3JCLE1BQU0sQ0FBQ3VDLE9BQU8sQ0FBQ3prQyxTQUFTeThCLFVBQVVzQyxRQUFRLEVBQUUsSUFBSSxDQUFDOXJCLFlBQVksRUFBRSxHQUFHLElBQUksSUFBSSxDQUFDaXZCLE1BQU07SUFDbEk7SUFDQXlCLGVBQWV2aEMsU0FBUyxFQUFFO1FBQ3RCLElBQUltUixRQUFRLElBQUksQ0FBQzZ5QixpQkFBaUIsQ0FBQ2hrQyxZQUFZO1FBQy9DLE9BQU9tUixNQUFNMVAsSUFBSSxJQUFJLElBQUksQ0FBQ2loQixRQUFRLENBQUNqaEIsSUFBSSxJQUFJLElBQUksQ0FBQ3UvQixhQUFhLENBQUMsRUFBRSxDQUFDL2pDLEdBQUcsR0FBRytDLFlBQVksTUFBTW1SLFFBQVEsSUFBSSxDQUFDNnZCLGFBQWEsQ0FBQyxFQUFFO0lBQzFIO0lBQ0ExVyxnQkFBZ0Ixc0IsTUFBTSxFQUFFO1FBQ3BCLE9BQU9zakMsV0FBVyxJQUFJLENBQUNYLFNBQVMsQ0FBQzlVLE9BQU8sQ0FBQyxJQUFJLENBQUNxVSxNQUFNLENBQUN1QyxPQUFPLENBQUN6a0MsU0FBUyxJQUFJLENBQUNpVCxZQUFZLEVBQUUsR0FBRyxJQUFJLElBQUksQ0FBQ2l2QixNQUFNO0lBQy9HO0lBQ0EsSUFBSTVWLFlBQVk7UUFDWixPQUFPLElBQUksQ0FBQzRWLE1BQU0sQ0FBQ3p5QixLQUFLLENBQUMsSUFBSSxDQUFDa3pCLFNBQVMsQ0FBQzNpQyxNQUFNO0lBQ2xEO0lBQ0EsSUFBSXdrQixnQkFBZ0I7UUFDaEIsT0FBTyxJQUFJLENBQUM4SCxTQUFTLEdBQUcsSUFBSSxDQUFDRCxVQUFVLEdBQUcsSUFBSSxDQUFDcVYsYUFBYTtJQUNoRTtBQUNKO0FBQ0EsTUFBTXdCO0lBQ0Z6Z0MsWUFBWW9CLElBQUksRUFBRUMsRUFBRSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsRUFBRSxHQUFHQTtJQUNkO0FBQ0o7QUFDQSxTQUFTMGhDLGNBQWMzaEMsSUFBSSxFQUFFQyxFQUFFLEVBQUU0K0IsU0FBUztJQUN0QyxJQUFJNXNCLFNBQVMsRUFBRSxFQUFFeFAsTUFBTXpDLE1BQU00aEMsUUFBUTtJQUNyQ3RxQyx1REFBUUEsQ0FBQzZjLEtBQUssQ0FBQzBxQixXQUFXNytCLE1BQU1DLElBQUk7UUFDaEMwVCxTQUFTO1FBQ1R6QyxPQUFNbFIsSUFBSSxFQUFFQyxFQUFFO1lBQ1YsSUFBSUQsT0FBT3lDLEtBQUs7Z0JBQ1p3UCxPQUFPdFMsSUFBSSxDQUFDO29CQUFFSyxNQUFNeUM7b0JBQUt4QyxJQUFJRDtnQkFBSztnQkFDbEM0aEMsU0FBUzVoQyxPQUFPeUM7WUFDcEI7WUFDQUEsTUFBTXhDO1FBQ1Y7SUFDSixHQUFHLEtBQUssa0VBQWtFO0lBQzFFLElBQUl3QyxNQUFNeEMsSUFBSTtRQUNWZ1MsT0FBT3RTLElBQUksQ0FBQztZQUFFSyxNQUFNeUM7WUFBS3hDO1FBQUc7UUFDNUIyaEMsU0FBUzNoQyxLQUFLd0M7SUFDbEI7SUFDQSxPQUFPO1FBQUVtL0I7UUFBTzN2QjtJQUFPO0FBQzNCO0FBQ0EsU0FBU213QixhQUFhLEVBQUVSLEtBQUssRUFBRTN2QixNQUFNLEVBQUUsRUFBRXV3QixLQUFLO0lBQzFDLElBQUlBLFNBQVMsR0FDVCxPQUFPdndCLE1BQU0sQ0FBQyxFQUFFLENBQUNqUyxJQUFJO0lBQ3pCLElBQUl3aUMsU0FBUyxHQUNULE9BQU92d0IsTUFBTSxDQUFDQSxPQUFPOVgsTUFBTSxHQUFHLEVBQUUsQ0FBQzhGLEVBQUU7SUFDdkMsSUFBSXFQLE9BQU9oVCxLQUFLdXRCLEtBQUssQ0FBQytYLFFBQVFZO0lBQzlCLElBQUssSUFBSTFpQyxJQUFJLElBQUlBLElBQUs7UUFDbEIsSUFBSSxFQUFFRSxJQUFJLEVBQUVDLEVBQUUsRUFBRSxHQUFHZ1MsTUFBTSxDQUFDblMsRUFBRSxFQUFFODVCLE9BQU8zNUIsS0FBS0Q7UUFDMUMsSUFBSXNQLFFBQVFzcUIsTUFDUixPQUFPNTVCLE9BQU9zUDtRQUNsQkEsUUFBUXNxQjtJQUNaO0FBQ0o7QUFDQSxTQUFTc0ksYUFBYVYsU0FBUyxFQUFFLytCLEdBQUc7SUFDaEMsSUFBSWdnQyxVQUFVO0lBQ2QsS0FBSyxJQUFJLEVBQUV6aUMsSUFBSSxFQUFFQyxFQUFFLEVBQUUsSUFBSXVoQyxVQUFVdnZCLE1BQU0sQ0FBRTtRQUN2QyxJQUFJeFAsT0FBT3hDLElBQUk7WUFDWHdpQyxXQUFXaGdDLE1BQU16QztZQUNqQjtRQUNKO1FBQ0F5aUMsV0FBV3hpQyxLQUFLRDtJQUNwQjtJQUNBLE9BQU95aUMsVUFBVWpCLFVBQVVJLEtBQUs7QUFDcEM7QUFDQSxTQUFTeDJCLEtBQUtzM0IsS0FBSyxFQUFFdlcsQ0FBQztJQUNsQixLQUFLLElBQUl3VyxPQUFPRCxNQUNaLElBQUl2VyxFQUFFd1csTUFDRixPQUFPQTtJQUNmLE9BQU85aUM7QUFDWDtBQUNBLG1FQUFtRTtBQUNuRSxzQkFBc0I7QUFDdEIsTUFBTXkrQixXQUFXO0lBQ2IxeUIsT0FBTWczQixDQUFDO1FBQUksT0FBT0E7SUFBRztJQUNyQmhDLFNBQVFnQyxDQUFDO1FBQUksT0FBT0E7SUFBRztJQUN2QnBELE9BQU87QUFDWDtBQUNBLGlFQUFpRTtBQUNqRSw0REFBNEQ7QUFDNUQsbUJBQW1CO0FBQ25CLE1BQU1GO0lBQ0YxZ0MsWUFBWXE2QixNQUFNLEVBQUU2RixTQUFTLEVBQUVqYSxTQUFTLENBQUU7UUFDdEMsSUFBSWdlLFdBQVcsR0FBR2pxQyxPQUFPLEdBQUdrcUMsVUFBVTtRQUN0QyxJQUFJLENBQUNqZSxTQUFTLEdBQUdBLFVBQVVoTCxHQUFHLENBQUMsQ0FBQyxFQUFFN1osSUFBSSxFQUFFQyxFQUFFLEVBQUU7WUFDeEMsSUFBSXpFLE1BQU1zakMsVUFBVS9yQixNQUFNLENBQUMvUyxNQUFNNDRCLFVBQVUrQyxLQUFLLEVBQUUxQyxRQUFRLEdBQUcsR0FBR3o5QixHQUFHO1lBQ25FLElBQUlDLFNBQVNxakMsVUFBVS9yQixNQUFNLENBQUM5UyxJQUFJMjRCLFVBQVUrQyxLQUFLLEVBQUUxQyxRQUFRLEdBQUcsR0FBR3g5QixNQUFNO1lBQ3ZFb25DLFlBQVlwbkMsU0FBU0Q7WUFDckIsT0FBTztnQkFBRXdFO2dCQUFNQztnQkFBSXpFO2dCQUFLQztnQkFBUXNuQyxRQUFRO2dCQUFHQyxXQUFXO1lBQUU7UUFDNUQ7UUFDQSxJQUFJLENBQUN4RCxLQUFLLEdBQUcsQ0FBQyxRQUFRLG1CQUFtQixNQUFLcUQsUUFBTyxJQUFNL0QsQ0FBQUEsVUFBVTNpQyxNQUFNLEdBQUcwbUMsUUFBTztRQUNyRixLQUFLLElBQUlJLE9BQU8sSUFBSSxDQUFDcGUsU0FBUyxDQUFFO1lBQzVCb2UsSUFBSUYsTUFBTSxHQUFHRCxVQUFVLENBQUNHLElBQUl6bkMsR0FBRyxHQUFHNUMsSUFBRyxJQUFLLElBQUksQ0FBQzRtQyxLQUFLO1lBQ3BEc0QsVUFBVUcsSUFBSUQsU0FBUyxHQUFHQyxJQUFJRixNQUFNLEdBQUlFLENBQUFBLElBQUl4bkMsTUFBTSxHQUFHd25DLElBQUl6bkMsR0FBRztZQUM1RDVDLE9BQU9xcUMsSUFBSXhuQyxNQUFNO1FBQ3JCO0lBQ0o7SUFDQW1RLE1BQU1nM0IsQ0FBQyxFQUFFO1FBQ0wsSUFBSyxJQUFJOWlDLElBQUksR0FBR2xILE9BQU8sR0FBR2txQyxVQUFVLElBQUloakMsSUFBSztZQUN6QyxJQUFJMmdDLEtBQUszZ0MsSUFBSSxJQUFJLENBQUMra0IsU0FBUyxDQUFDMXFCLE1BQU0sR0FBRyxJQUFJLENBQUMwcUIsU0FBUyxDQUFDL2tCLEVBQUUsR0FBRztZQUN6RCxJQUFJLENBQUMyZ0MsTUFBTW1DLElBQUluQyxHQUFHamxDLEdBQUcsRUFDakIsT0FBT3NuQyxVQUFVLENBQUNGLElBQUlocUMsSUFBRyxJQUFLLElBQUksQ0FBQzRtQyxLQUFLO1lBQzVDLElBQUlvRCxLQUFLbkMsR0FBR2hsQyxNQUFNLEVBQ2QsT0FBT2dsQyxHQUFHc0MsTUFBTSxHQUFJSCxDQUFBQSxJQUFJbkMsR0FBR2psQyxHQUFHO1lBQ2xDNUMsT0FBTzZuQyxHQUFHaGxDLE1BQU07WUFDaEJxbkMsVUFBVXJDLEdBQUd1QyxTQUFTO1FBQzFCO0lBQ0o7SUFDQXBDLFFBQVFnQyxDQUFDLEVBQUU7UUFDUCxJQUFLLElBQUk5aUMsSUFBSSxHQUFHbEgsT0FBTyxHQUFHa3FDLFVBQVUsSUFBSWhqQyxJQUFLO1lBQ3pDLElBQUkyZ0MsS0FBSzNnQyxJQUFJLElBQUksQ0FBQytrQixTQUFTLENBQUMxcUIsTUFBTSxHQUFHLElBQUksQ0FBQzBxQixTQUFTLENBQUMva0IsRUFBRSxHQUFHO1lBQ3pELElBQUksQ0FBQzJnQyxNQUFNbUMsSUFBSW5DLEdBQUdzQyxNQUFNLEVBQ3BCLE9BQU9ucUMsT0FBTyxDQUFDZ3FDLElBQUlFLE9BQU0sSUFBSyxJQUFJLENBQUN0RCxLQUFLO1lBQzVDLElBQUlvRCxLQUFLbkMsR0FBR3VDLFNBQVMsRUFDakIsT0FBT3ZDLEdBQUdqbEMsR0FBRyxHQUFJb25DLENBQUFBLElBQUluQyxHQUFHc0MsTUFBTTtZQUNsQ25xQyxPQUFPNm5DLEdBQUdobEMsTUFBTTtZQUNoQnFuQyxVQUFVckMsR0FBR3VDLFNBQVM7UUFDMUI7SUFDSjtBQUNKO0FBQ0EsU0FBU3ZELFdBQVcvdkIsS0FBSyxFQUFFMnVCLE1BQU07SUFDN0IsSUFBSUEsT0FBT21CLEtBQUssSUFBSSxHQUNoQixPQUFPOXZCO0lBQ1gsSUFBSXd6QixPQUFPN0UsT0FBT3p5QixLQUFLLENBQUM4RCxNQUFNbFUsR0FBRyxHQUFHMm5DLFVBQVU5RSxPQUFPenlCLEtBQUssQ0FBQzhELE1BQU1qVSxNQUFNO0lBQ3ZFLE9BQU8sSUFBSWk5QixVQUFVaHBCLE1BQU0xUCxJQUFJLEVBQUUwUCxNQUFNdlYsTUFBTSxFQUFFK29DLE1BQU1DLFVBQVVELE1BQU0vM0IsTUFBTThlLE9BQU8sQ0FBQ3ZhLE1BQU1pcEIsUUFBUSxJQUFJanBCLE1BQU1pcEIsUUFBUSxDQUFDOWUsR0FBRyxDQUFDNU0sQ0FBQUEsSUFBS3d5QixXQUFXeHlCLEdBQUdveEIsV0FBVzN1QixNQUFNaXBCLFFBQVE7QUFDeEs7QUFFQSxNQUFNeUssUUFBUSxXQUFXLEdBQUV6ckMsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQUVRLFNBQVM2cEIsQ0FBQUEsT0FBUUEsS0FBS3Q5QixJQUFJLENBQUM7QUFBSztBQUMxRSxNQUFNdTlCLFlBQVksV0FBVyxHQUFFM3JDLG9EQUFLQSxDQUFDcWhCLE1BQU0sQ0FBQztJQUFFUSxTQUFTQyxDQUFBQSxTQUFVQSxPQUFPdlUsT0FBTyxDQUFDLFFBQVEsQ0FBQztBQUFFO0FBQzNGLE1BQU1xK0IsY0FBYyxXQUFXLEdBQUU3cUMsa0RBQVdBLENBQUM4cUMsT0FBTyxJQUFJQyxjQUFjLFdBQVcsR0FBRS9xQyxrREFBV0EsQ0FBQzhxQyxPQUFPLElBQUlFLGFBQWEsV0FBVyxHQUFFaHJDLGtEQUFXQSxDQUFDOHFDLE9BQU87QUFDdkosTUFBTUcsZUFBZTtJQUFFLFVBQVUsTUFBTUY7SUFBYSxTQUFTLE1BQU1DO0FBQVc7QUFDOUUsU0FBU0UsV0FBVzdqQixJQUFJLEVBQUV6UixJQUFJLEVBQUV1MUIsTUFBTTtJQUNsQyxPQUFPLElBQUluckMsa0RBQVdBLENBQUM0VixNQUFNO1FBQ3pCK0UsUUFBTzhQLEdBQUc7WUFDTixPQUFPLElBQUkvbEIsSUFBSSxDQUFDK2xCLE9BQU9BLElBQUlyZCxPQUFPLENBQUMsUUFBUTZXLENBQUFBO2dCQUN2QyxJQUFJQSxLQUFLLEtBQ0wsT0FBT29EO2dCQUNYLElBQUksQ0FBQzhqQixVQUFVLENBQUNBLE1BQU0sQ0FBQ2xuQixFQUFFLEVBQ3JCLE1BQU0sSUFBSTlaLFdBQVcsQ0FBQyxzQkFBc0IsRUFBRThaLEVBQUUsQ0FBQztnQkFDckQsT0FBT2tuQixNQUFNLENBQUNsbkIsRUFBRTtZQUNwQixLQUFLb0QsT0FBTyxNQUFNb0Q7UUFDdEI7SUFDSjtBQUNKO0FBQ0EsTUFBTTJnQixjQUFjLFdBQVcsR0FBRUYsV0FBVyxNQUFNTCxhQUFhO0lBQzNELEtBQUs7UUFDRGptQyxVQUFVO1FBQ1Z5bUMsV0FBVztRQUNYLGdCQUFnQjtZQUNaLDBEQUEwRDtZQUMxRCxnRUFBZ0U7WUFDaEUsMkRBQTJEO1lBQzNELDBEQUEwRDtZQUMxRCw0REFBNEQ7WUFDNUQsZ0VBQWdFO1lBQ2hFLDZEQUE2RDtZQUM3RCxzQkFBc0I7WUFDdEJDLFNBQVM7UUFDYjtRQUNBdkcsU0FBUztRQUNUd0csZUFBZTtJQUNuQjtJQUNBLGdCQUFnQjtRQUNaeEcsU0FBUztRQUNUeUcsWUFBWTtRQUNaQyxZQUFZO1FBQ1pqMUIsWUFBWTtRQUNaL1MsUUFBUTtRQUNSaW9DLFdBQVc7UUFDWDltQyxVQUFVO1FBQ1YrbUMsUUFBUTtJQUNaO0lBQ0EsZUFBZTtRQUNYbnlCLFFBQVE7UUFDUm95QixVQUFVO1FBQ1ZDLFlBQVk7UUFDWjlHLFNBQVM7UUFDVHpGLFlBQVk7UUFDWndNLFVBQVU7UUFDVlQsV0FBVztRQUNYVSxXQUFXO1FBQ1hDLFNBQVM7UUFDVFYsU0FBUztRQUNULDJCQUEyQjtZQUN2Qlcsa0JBQWtCO1FBQ3RCO0lBQ0o7SUFDQSxvQkFBb0I7UUFDaEJDLHFCQUFxQjtRQUNyQjVNLFlBQVk7UUFDWjZNLFdBQVc7UUFDWEMsY0FBYztRQUNkUCxZQUFZO0lBQ2hCO0lBQ0Esc0JBQXNCO1FBQUVRLFlBQVk7SUFBUTtJQUM1QyxxQkFBcUI7UUFBRUEsWUFBWTtJQUFRO0lBQzNDLFlBQVk7UUFDUnRILFNBQVM7UUFDVGlILFNBQVM7SUFDYjtJQUNBLGFBQWE7UUFDVHBuQyxVQUFVO1FBQ1ZqQyxNQUFNO1FBQ05HLEtBQUs7UUFDTHdwQyxTQUFTO1FBQ1QsU0FBUztZQUNMMW5DLFVBQVU7UUFDZDtJQUNKO0lBQ0Esa0NBQWtDO1FBQzlCMm5DLFlBQVk7SUFDaEI7SUFDQSxpQ0FBaUM7UUFDN0JBLFlBQVk7SUFDaEI7SUFDQSxpRkFBaUY7UUFDN0VBLFlBQVk7SUFDaEI7SUFDQSxnRkFBZ0Y7UUFDNUVBLFlBQVk7SUFDaEI7SUFDQSxtQkFBbUI7UUFDZkMsZUFBZTtJQUNuQjtJQUNBLGlEQUFpRDtRQUM3Q0MsV0FBVztJQUNmO0lBQ0EsK0RBQStEO0lBQy9ELHNEQUFzRDtJQUN0RCxpQkFBaUI7SUFDakIsdUJBQXVCO1FBQUUsTUFBTSxDQUFDO1FBQUcsT0FBTztZQUFFQyxTQUFTO1FBQUU7UUFBRyxRQUFRLENBQUM7SUFBRTtJQUNyRSx3QkFBd0I7UUFBRSxNQUFNLENBQUM7UUFBRyxPQUFPO1lBQUVBLFNBQVM7UUFBRTtRQUFHLFFBQVEsQ0FBQztJQUFFO0lBQ3RFLDhCQUE4QjtRQUMxQkMsWUFBWTtRQUNaQyxZQUFZO1FBQ1pKLGVBQWU7SUFDbkI7SUFDQSxjQUFjO1FBQ1Z6SCxTQUFTO0lBQ2I7SUFDQSxvQkFBb0I7UUFDaEI4SCxpQkFBaUI7SUFDckI7SUFDQSxrQkFBa0I7UUFDZGpvQyxVQUFVO0lBQ2Q7SUFDQSw0REFBNEQ7UUFDeERtZ0MsU0FBUztJQUNiO0lBQ0EsV0FBVztRQUNQK0gsYUFBYTtJQUNqQjtJQUNBLGlCQUFpQjtRQUNibG9DLFVBQVU7UUFDVjlCLEtBQUs7SUFDVDtJQUNBLGdCQUFnQjtRQUNaLGlCQUFpQjtZQUFFaWlDLFNBQVM7UUFBTztJQUN2QztJQUNBLHlCQUF5QjtRQUFFZ0ksaUJBQWlCO0lBQVk7SUFDeEQsd0JBQXdCO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ3ZELDBCQUEwQjtRQUFFQyxPQUFPO0lBQU07SUFDekMseUJBQXlCO1FBQUVBLE9BQU87SUFBTztJQUN6QyxlQUFlO1FBQ1huQixZQUFZO1FBQ1o5RyxTQUFTO1FBQ1R0aEMsUUFBUTtRQUNSNG5DLFdBQVc7UUFDWDRCLGtCQUFrQjtRQUNsQnRCLFFBQVE7SUFDWjtJQUNBLHNCQUFzQjtRQUNsQm9CLGlCQUFpQjtRQUNqQkMsT0FBTztRQUNQRSxhQUFhO0lBQ2pCO0lBQ0EscUJBQXFCO1FBQ2pCSCxpQkFBaUI7UUFDakJDLE9BQU87SUFDWDtJQUNBLGNBQWM7UUFDVmpJLFNBQVM7UUFDVHdHLGVBQWU7UUFDZk0sWUFBWTtRQUNaUixXQUFXO1FBQ1hVLFdBQVc7UUFDWDVILFVBQVU7SUFDZDtJQUNBLHFCQUFxQjtRQUNqQmtILFdBQVc7SUFDZjtJQUNBLHFDQUFxQztRQUNqQ1csU0FBUztRQUNUOWxCLFVBQVU7UUFDVmluQixXQUFXO1FBQ1g3TixZQUFZO0lBQ2hCO0lBQ0EsK0JBQStCO1FBQzNCeU4saUJBQWlCO0lBQ3JCO0lBQ0EsOEJBQThCO1FBQzFCQSxpQkFBaUI7SUFDckI7SUFDQSxjQUFjO1FBQ1YxQixXQUFXO1FBQ1h6bUMsVUFBVTtRQUNWakMsTUFBTTtRQUNORSxPQUFPO0lBQ1g7SUFDQSxxQkFBcUI7UUFDakJrcUMsaUJBQWlCO1FBQ2pCQyxPQUFPO0lBQ1g7SUFDQSx5QkFBeUI7UUFDckJJLGNBQWM7SUFDbEI7SUFDQSw0QkFBNEI7UUFDeEJDLFdBQVc7SUFDZjtJQUNBLG9CQUFvQjtRQUNoQk4saUJBQWlCO1FBQ2pCQyxPQUFPO0lBQ1g7SUFDQSxXQUFXO1FBQ1BqSSxTQUFTO1FBQ1RaLFVBQVU7UUFDVm1KLGVBQWU7SUFDbkI7SUFDQSxvQkFBb0I7UUFDaEJBLGVBQWU7UUFDZjdwQyxRQUFRO1FBQ1JILE9BQU87UUFDUHloQyxTQUFTO0lBQ2I7SUFDQSxtQkFBbUI7UUFDZmlJLE9BQU87UUFDUGpJLFNBQVM7UUFDVHVJLGVBQWU7SUFDbkI7SUFDQSw2QkFBNkI7UUFDekIzekIsU0FBUztRQUNUL1UsVUFBVTtRQUNWNG5DLGVBQWU7UUFDZlEsT0FBTztJQUNYO0lBQ0Esb0JBQW9CO1FBQ2hCTyxpQkFBaUIsQ0FBQyxtTUFBbU0sQ0FBQztRQUN0TkMsZ0JBQWdCO1FBQ2hCQyxvQkFBb0I7UUFDcEJDLGtCQUFrQjtJQUN0QjtJQUNBLHFCQUFxQjtRQUNqQlgsaUJBQWlCO0lBQ3JCO0lBQ0EsY0FBYztRQUNWTyxlQUFlO1FBQ2ZOLE9BQU87UUFDUFcsVUFBVTtRQUNWM0IsU0FBUztRQUNUNEIsY0FBYztJQUNsQjtJQUNBLHFCQUFxQjtRQUNqQkwsaUJBQWlCO1FBQ2pCTSxRQUFRO1FBQ1IsWUFBWTtZQUNSTixpQkFBaUI7UUFDckI7SUFDSjtJQUNBLG9CQUFvQjtRQUNoQkEsaUJBQWlCO1FBQ2pCTSxRQUFRO1FBQ1IsWUFBWTtZQUNSTixpQkFBaUI7UUFDckI7SUFDSjtJQUNBLGlCQUFpQjtRQUNiRCxlQUFlO1FBQ2ZOLE9BQU87UUFDUFcsVUFBVTtRQUNWRSxRQUFRO1FBQ1I3QixTQUFTO0lBQ2I7SUFDQSx3QkFBd0I7UUFDcEJlLGlCQUFpQjtJQUNyQjtJQUNBLHVCQUF1QjtRQUNuQmMsUUFBUTtRQUNSZCxpQkFBaUI7SUFDckI7QUFDSixHQUFHOUI7QUFFSCxNQUFNNkMsdUJBQXVCO0FBQzdCLE1BQU1DO0lBQ0Y3bkMsWUFBWThuQyxNQUFNLEVBQUV6NkIsS0FBSyxDQUFFO1FBQ3ZCLElBQUksQ0FBQ3k2QixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDMWdDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQzJnQyxhQUFhLEdBQUcxNkIsTUFBTW9PLEtBQUssQ0FBQ3BpQiwwREFBV0EsQ0FBQzB1QyxhQUFhO0lBQzlEO0lBQ0F4NEIsT0FBT25JLElBQUksRUFBRTtRQUNULElBQUksQ0FBQ0EsSUFBSSxJQUFJQTtJQUNqQjtJQUNBdU4sWUFBWTtRQUNSLElBQUksQ0FBQ3ZOLElBQUksSUFBSXdnQztJQUNqQjtJQUNBSSxVQUFVdG9DLEtBQUssRUFBRStGLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUMvRixPQUNELE9BQU8sSUFBSTtRQUNmLElBQUl0RCxTQUFTc0QsTUFBTWhGLFVBQVU7UUFDN0IsSUFBSyxJQUFJMEQsTUFBTXNCLFFBQVM7WUFDcEIsSUFBSSxDQUFDdW9DLGVBQWUsQ0FBQzdyQyxRQUFRZ0M7WUFDN0IsSUFBSThwQyxTQUFTLElBQUksQ0FBQzlnQyxJQUFJLENBQUM3TCxNQUFNO1lBQzdCLElBQUksQ0FBQzRzQyxRQUFRLENBQUMvcEM7WUFDZCxJQUFJaUcsT0FBT2pHLElBQUlrRyxXQUFXO1lBQzFCLElBQUlELFFBQVFvQixLQUNSO1lBQ0osSUFBSTdCLE9BQU9OLFlBQVltQixHQUFHLENBQUNyRyxNQUFNZ3FDLFdBQVc5a0MsWUFBWW1CLEdBQUcsQ0FBQ0o7WUFDNUQsSUFBSVQsUUFBUXdrQyxXQUFXeGtDLEtBQUtJLFVBQVUsR0FDbEMsQ0FBQ0osT0FBT0EsS0FBS0ksVUFBVSxHQUFHcWtDLGVBQWVqcUMsSUFBRyxLQUN2Q2lxQyxlQUFlaGtDLFNBQVVqRyxDQUFBQSxJQUFJakMsUUFBUSxJQUFJLFFBQVFpQyxJQUFJNlIsUUFBUSxLQUFLLElBQUksQ0FBQzdJLElBQUksQ0FBQzdMLE1BQU0sR0FBRzJzQyxRQUMxRixJQUFJLENBQUN2ekIsU0FBUztZQUNsQnZXLE1BQU1pRztRQUNWO1FBQ0EsSUFBSSxDQUFDNGpDLGVBQWUsQ0FBQzdyQyxRQUFRcUo7UUFDN0IsT0FBTyxJQUFJO0lBQ2Y7SUFDQTZpQyxhQUFhN3RDLElBQUksRUFBRTtRQUNmLElBQUkyTSxPQUFPM00sS0FBS2EsU0FBUztRQUN6QixLQUFLLElBQUlnWCxTQUFTLElBQUksQ0FBQ3cxQixNQUFNLENBQ3pCLElBQUl4MUIsTUFBTTdYLElBQUksSUFBSUEsTUFDZDZYLE1BQU16TyxHQUFHLEdBQUcsSUFBSSxDQUFDdUQsSUFBSSxDQUFDN0wsTUFBTSxHQUFHbUMsS0FBSytDLEdBQUcsQ0FBQzZSLE1BQU16UCxNQUFNLEVBQUV1RSxLQUFLN0wsTUFBTTtRQUN6RSxJQUFLLElBQUlHLE1BQU0sR0FBRzZzQyxLQUFLLElBQUksQ0FBQ1IsYUFBYSxHQUFHLE9BQU8sY0FBZTtZQUM5RCxJQUFJUyxZQUFZLENBQUMsR0FBR0MsWUFBWSxHQUFHMXFCO1lBQ25DLElBQUksSUFBSSxDQUFDZ3FCLGFBQWEsRUFBRTtnQkFDcEJTLFlBQVlwaEMsS0FBS2QsT0FBTyxDQUFDLElBQUksQ0FBQ3loQyxhQUFhLEVBQUVyc0M7Z0JBQzdDK3NDLFlBQVksSUFBSSxDQUFDVixhQUFhLENBQUN4c0MsTUFBTTtZQUN6QyxPQUNLLElBQUl3aUIsSUFBSXdxQixHQUFHbC9CLElBQUksQ0FBQ2pDLE9BQU87Z0JBQ3hCb2hDLFlBQVl6cUIsRUFBRWhpQixLQUFLO2dCQUNuQjBzQyxZQUFZMXFCLENBQUMsQ0FBQyxFQUFFLENBQUN4aUIsTUFBTTtZQUMzQjtZQUNBLElBQUksQ0FBQ2dVLE1BQU0sQ0FBQ25JLEtBQUsyRCxLQUFLLENBQUNyUCxLQUFLOHNDLFlBQVksSUFBSXBoQyxLQUFLN0wsTUFBTSxHQUFHaXRDO1lBQzFELElBQUlBLFlBQVksR0FDWjtZQUNKLElBQUksQ0FBQzd6QixTQUFTO1lBQ2QsSUFBSTh6QixZQUFZLEdBQ1o7Z0JBQUEsS0FBSyxJQUFJbjJCLFNBQVMsSUFBSSxDQUFDdzFCLE1BQU0sQ0FDekIsSUFBSXgxQixNQUFNN1gsSUFBSSxJQUFJQSxRQUFRNlgsTUFBTXpPLEdBQUcsR0FBRyxJQUFJLENBQUN1RCxJQUFJLENBQUM3TCxNQUFNLEVBQ2xEK1csTUFBTXpPLEdBQUcsSUFBSTRrQyxZQUFZO1lBQUM7WUFDdEMvc0MsTUFBTThzQyxZQUFZQztRQUN0QjtJQUNKO0lBQ0FOLFNBQVMxdEMsSUFBSSxFQUFFO1FBQ1gsSUFBSUEsS0FBS3dWLFFBQVEsRUFDYjtRQUNKLElBQUlyTSxPQUFPTixZQUFZbUIsR0FBRyxDQUFDaEs7UUFDM0IsSUFBSWl1QyxXQUFXOWtDLFFBQVFBLEtBQUtKLGVBQWU7UUFDM0MsSUFBSWtsQyxZQUFZLE1BQU07WUFDbEIsSUFBSSxDQUFDQyxlQUFlLENBQUNsdUMsTUFBTWl1QyxTQUFTbnRDLE1BQU07WUFDMUMsSUFBSyxJQUFJMkYsSUFBSXduQyxTQUFTMTBCLElBQUksSUFBSSxDQUFDOVMsRUFBRW1ELElBQUksR0FBR3VRLElBQUksRUFBRztnQkFDM0MsSUFBSTFULEVBQUV5VCxTQUFTLEVBQ1gsSUFBSSxDQUFDQSxTQUFTO3FCQUVkLElBQUksQ0FBQ3BGLE1BQU0sQ0FBQ3JPLEVBQUU4TixLQUFLO1lBQzNCO1FBQ0osT0FDSyxJQUFJdlUsS0FBS0osUUFBUSxJQUFJLEdBQUc7WUFDekIsSUFBSSxDQUFDaXVDLFlBQVksQ0FBQzd0QztRQUN0QixPQUNLLElBQUlBLEtBQUswQixRQUFRLElBQUksTUFBTTtZQUM1QixJQUFJMUIsS0FBSzZKLFdBQVcsRUFDaEIsSUFBSSxDQUFDcVEsU0FBUztRQUN0QixPQUNLLElBQUlsYSxLQUFLSixRQUFRLElBQUksR0FBRztZQUN6QixJQUFJLENBQUMydEMsU0FBUyxDQUFDdnRDLEtBQUs4SixVQUFVLEVBQUU7UUFDcEM7SUFDSjtJQUNBMGpDLGdCQUFnQnh0QyxJQUFJLEVBQUU0SixJQUFJLEVBQUU7UUFDeEIsS0FBSyxJQUFJaU8sU0FBUyxJQUFJLENBQUN3MUIsTUFBTSxDQUN6QixJQUFJeDFCLE1BQU03WCxJQUFJLElBQUlBLFFBQVFBLEtBQUs0QixVQUFVLENBQUNpVyxNQUFNelAsTUFBTSxDQUFDLElBQUl3QixNQUN2RGlPLE1BQU16TyxHQUFHLEdBQUcsSUFBSSxDQUFDdUQsSUFBSSxDQUFDN0wsTUFBTTtJQUN4QztJQUNBb3RDLGdCQUFnQmx1QyxJQUFJLEVBQUVjLE1BQU0sRUFBRTtRQUMxQixLQUFLLElBQUkrVyxTQUFTLElBQUksQ0FBQ3cxQixNQUFNLENBQ3pCLElBQUlydEMsS0FBS0osUUFBUSxJQUFJLElBQUlpWSxNQUFNN1gsSUFBSSxJQUFJQSxPQUFPQSxLQUFLRixRQUFRLENBQUMrWCxNQUFNN1gsSUFBSSxHQUNsRTZYLE1BQU16TyxHQUFHLEdBQUcsSUFBSSxDQUFDdUQsSUFBSSxDQUFDN0wsTUFBTSxHQUFJcXRDLENBQUFBLFFBQVFudUMsTUFBTTZYLE1BQU03WCxJQUFJLEVBQUU2WCxNQUFNelAsTUFBTSxJQUFJdEgsU0FBUztJQUMvRjtBQUNKO0FBQ0EsU0FBU3F0QyxRQUFReHNDLE1BQU0sRUFBRTNCLElBQUksRUFBRW9JLE1BQU07SUFDakMsT0FBUztRQUNMLElBQUksQ0FBQ3BJLFFBQVFvSSxTQUFTM0csVUFBVXpCLE9BQzVCLE9BQU87UUFDWCxJQUFJQSxRQUFRMkIsUUFDUixPQUFPO1FBQ1h5RyxTQUFTL0csU0FBU3JCLFFBQVE7UUFDMUJBLE9BQU9BLEtBQUtDLFVBQVU7SUFDMUI7QUFDSjtBQUNBLFNBQVMydEMsZUFBZTV0QyxJQUFJO0lBQ3hCLE9BQU9BLEtBQUtKLFFBQVEsSUFBSSxLQUFLLHNEQUFzRG1FLElBQUksQ0FBQy9ELEtBQUswQixRQUFRO0FBQ3pHO0FBQ0EsTUFBTTBzQztJQUNGN29DLFlBQVl2RixJQUFJLEVBQUVvSSxNQUFNLENBQUU7UUFDdEIsSUFBSSxDQUFDcEksSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ29JLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNnQixHQUFHLEdBQUcsQ0FBQztJQUNoQjtBQUNKO0FBRUEsTUFBTWlsQztJQUNGOW9DLFlBQVk0RCxJQUFJLEVBQUVsRSxLQUFLLEVBQUUrRixHQUFHLEVBQUVzakMsUUFBUSxDQUFFO1FBQ3BDLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQzVoQyxJQUFJLEdBQUc7UUFDWixJQUFJLEVBQUVnWixlQUFlNm9CLEtBQUssRUFBRTlvQixpQkFBaUIrb0IsT0FBTyxFQUFFLEdBQUd0bEMsS0FBS2lOLE9BQU87UUFDckUsSUFBSWpOLEtBQUt5SixLQUFLLENBQUM0b0IsUUFBUSxJQUFJdjJCLFFBQVEsQ0FBQyxHQUFHO1lBQ25DLDhDQUE4QztZQUM5QyxJQUFJLENBQUN1aEIsTUFBTSxHQUFHO1FBQ2xCLE9BQ0ssSUFBSXZoQixRQUFRLENBQUMsS0FBTSxLQUFJLENBQUNzcEMsTUFBTSxHQUFHcGxDLEtBQUtpTixPQUFPLENBQUMxTCxlQUFlLENBQUN6RixPQUFPK0YsS0FBSyxFQUFDLEdBQUk7WUFDaEYsSUFBSTBqQyxZQUFZRixTQUFTQyxVQUFVLEVBQUUsR0FBR0UsZ0JBQWdCeGxDO1lBQ3hELElBQUkyeUIsU0FBUyxJQUFJc1IsVUFBVXNCLFdBQVd2bEMsS0FBS3lKLEtBQUs7WUFDaERrcEIsT0FBT3lSLFNBQVMsQ0FBQyxJQUFJLENBQUNnQixNQUFNLENBQUN0akMsUUFBUSxFQUFFLElBQUksQ0FBQ3NqQyxNQUFNLENBQUNyakMsTUFBTTtZQUN6RCxJQUFJLENBQUN5QixJQUFJLEdBQUdtdkIsT0FBT252QixJQUFJO1lBQ3ZCLElBQUksQ0FBQzZaLE1BQU0sR0FBR29vQixvQkFBb0JGLFdBQVcsSUFBSSxDQUFDSCxNQUFNLENBQUM1bkMsSUFBSTtRQUNqRSxPQUNLO1lBQ0QsSUFBSWYsU0FBU3VELEtBQUtrZSxRQUFRLENBQUNHLGNBQWM7WUFDekMsSUFBSXRJLE9BQU9zdkIsU0FBU0EsTUFBTXh1QyxJQUFJLElBQUk0RixPQUFPSCxTQUFTLElBQUkrb0MsTUFBTXBtQyxNQUFNLElBQUl4QyxPQUFPRixXQUFXLElBQ3BGLENBQUM1RixTQUFTcUosS0FBSzZjLFVBQVUsRUFBRXBnQixPQUFPSCxTQUFTLElBQ3pDMEQsS0FBS3lKLEtBQUssQ0FBQ3BTLFNBQVMsQ0FBQ2ttQixJQUFJLENBQUN4SCxJQUFJLEdBQzlCL1YsS0FBS2lOLE9BQU8sQ0FBQzJULFVBQVUsQ0FBQ25rQixPQUFPSCxTQUFTLEVBQUVHLE9BQU9GLFdBQVc7WUFDbEUsSUFBSW9qQixTQUFTMmxCLFdBQVdBLFFBQVF6dUMsSUFBSSxJQUFJNEYsT0FBT25GLFVBQVUsSUFBSWd1QyxRQUFRcm1DLE1BQU0sSUFBSXhDLE9BQU9KLFlBQVksSUFDOUYsQ0FBQzFGLFNBQVNxSixLQUFLNmMsVUFBVSxFQUFFcGdCLE9BQU9uRixVQUFVLElBQzFDMEksS0FBS3lKLEtBQUssQ0FBQ3BTLFNBQVMsQ0FBQ2ttQixJQUFJLENBQUNvQyxNQUFNLEdBQ2hDM2YsS0FBS2lOLE9BQU8sQ0FBQzJULFVBQVUsQ0FBQ25rQixPQUFPbkYsVUFBVSxFQUFFbUYsT0FBT0osWUFBWTtZQUNwRSxzREFBc0Q7WUFDdEQsY0FBYztZQUNkLHlEQUF5RDtZQUN6RCxhQUFhO1lBQ2IsSUFBSTRoQyxLQUFLaitCLEtBQUt5ZSxRQUFRO1lBQ3RCLElBQUksQ0FBQ3RZLFFBQVFGLEdBQUcsSUFBSUUsUUFBUUwsTUFBTSxLQUFLOUYsS0FBS3lKLEtBQUssQ0FBQ3BTLFNBQVMsQ0FBQ2ttQixJQUFJLENBQUMvVCxLQUFLLElBQUl1TSxRQUFRNEosVUFDN0VzZSxDQUFBQSxHQUFHemdDLElBQUksR0FBRyxLQUFLeWdDLEdBQUd4Z0MsRUFBRSxHQUFHdUMsS0FBS3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ1csTUFBTSxHQUFHO2dCQUNoRCxJQUFJNkYsT0FBTzFELEtBQUsrQyxHQUFHLENBQUNrWixNQUFNNEosU0FBU2xpQixLQUFLM0QsS0FBS3NGLEdBQUcsQ0FBQzJXLE1BQU00SjtnQkFDdkQsSUFBSStsQixVQUFVekgsR0FBR3pnQyxJQUFJLEdBQUdBLE1BQU1tb0MsUUFBUTFILEdBQUd4Z0MsRUFBRSxHQUFHQTtnQkFDOUMsSUFBSSxDQUFDaW9DLFdBQVcsS0FBS0EsV0FBVyxLQUFLbG9DLFFBQVEsTUFBT21vQyxDQUFBQSxTQUFTLEtBQUtBLFNBQVMsQ0FBQyxLQUFLbG9DLE1BQU11QyxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDVyxNQUFNLEdBQUc7b0JBQzNHb2UsT0FBTztvQkFDUDRKLFNBQVMzZixLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDVyxNQUFNO2dCQUNsQztZQUNKO1lBQ0EsSUFBSSxDQUFDMGxCLE1BQU0sR0FBR25vQiw4REFBZUEsQ0FBQzB3QyxNQUFNLENBQUNqbUIsUUFBUTVKO1FBQ2pEO0lBQ0o7QUFDSjtBQUNBLFNBQVM4dkIsZUFBZTdsQyxJQUFJLEVBQUU4bEMsU0FBUztJQUNuQyxJQUFJQztJQUNKLElBQUksRUFBRTFvQixNQUFNLEVBQUUsR0FBR3lvQixXQUFXbmxCLE1BQU0zZ0IsS0FBS3lKLEtBQUssQ0FBQ3BTLFNBQVMsQ0FBQ2ttQixJQUFJO0lBQzNELElBQUl5b0IsVUFBVWhtQyxLQUFLbWQsVUFBVSxDQUFDK00sV0FBVyxHQUFHdk4sS0FBS0MsR0FBRyxLQUFLLE1BQU01YyxLQUFLbWQsVUFBVSxDQUFDOE0sV0FBVyxHQUFHLENBQUM7SUFDOUYsSUFBSTZiLFVBQVVWLE1BQU0sRUFBRTtRQUNsQixJQUFJLEVBQUU1bkMsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBR3FvQyxVQUFVVixNQUFNO1FBQ25DLElBQUlhLGVBQWV0bEIsSUFBSW5qQixJQUFJLEVBQUUwb0MsZ0JBQWdCO1FBQzdDLDREQUE0RDtRQUM1RCx1Q0FBdUM7UUFDdkMsSUFBSUYsWUFBWSxLQUFLNy9CLFFBQVFRLE9BQU8sSUFBSW0vQixVQUFVdGlDLElBQUksQ0FBQzdMLE1BQU0sR0FBRzhGLEtBQUtELE1BQU07WUFDdkV5b0MsZUFBZXRsQixJQUFJbGpCLEVBQUU7WUFDckJ5b0MsZ0JBQWdCO1FBQ3BCO1FBQ0EsSUFBSXJyQixPQUFPc3JCLFNBQVNubUMsS0FBS3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ29zQixXQUFXLENBQUM1bEIsTUFBTUMsSUFBSXVtQyx1QkFBdUI4QixVQUFVdGlDLElBQUksRUFBRXlpQyxlQUFlem9DLE1BQU0wb0M7UUFDckgsSUFBSXJyQixNQUFNO1lBQ04sK0RBQStEO1lBQy9ELCtDQUErQztZQUMvQyxJQUFJMVUsUUFBUUwsTUFBTSxJQUFJa2dDLFdBQVcsTUFDN0JuckIsS0FBS0osR0FBRyxJQUFJSSxLQUFLcmQsSUFBSSxHQUFHLEtBQUtzb0MsVUFBVXRpQyxJQUFJLENBQUMyRCxLQUFLLENBQUMwVCxLQUFLcmQsSUFBSSxFQUFFcWQsS0FBS0osR0FBRyxLQUFLdXBCLHVCQUF1QkEsc0JBQ2pHbnBCLEtBQUtKLEdBQUc7WUFDWnNyQixTQUFTO2dCQUFFdm9DLE1BQU1BLE9BQU9xZCxLQUFLcmQsSUFBSTtnQkFBRUMsSUFBSUQsT0FBT3FkLEtBQUtOLEdBQUc7Z0JBQ2xEOVYsUUFBUTVQLG1EQUFJQSxDQUFDd1osRUFBRSxDQUFDeTNCLFVBQVV0aUMsSUFBSSxDQUFDMkQsS0FBSyxDQUFDMFQsS0FBS3JkLElBQUksRUFBRXFkLEtBQUtKLEdBQUcsRUFBRTVWLEtBQUssQ0FBQ20vQjtZQUF1QjtRQUMvRjtJQUNKLE9BQ0ssSUFBSTNtQixVQUFXLEVBQUNyZCxLQUFLcXJCLFFBQVEsSUFBSXJyQixLQUFLeUosS0FBSyxDQUFDb08sS0FBSyxDQUFDeE8sYUFBYWdVLE9BQU9FLElBQUksQ0FBQy9nQixFQUFFLENBQUNta0IsSUFBRyxHQUFJO1FBQ3RGdEQsU0FBUztJQUNiO0lBQ0EsSUFBSSxDQUFDMG9CLFVBQVUsQ0FBQzFvQixRQUNaLE9BQU87SUFDWCxJQUFJLENBQUMwb0IsVUFBVUQsVUFBVVgsUUFBUSxJQUFJLENBQUN4a0IsSUFBSW5YLEtBQUssSUFBSTZULFVBQVVBLE9BQU9FLElBQUksQ0FBQy9ULEtBQUssRUFBRTtRQUM1RSx1REFBdUQ7UUFDdkR1OEIsU0FBUztZQUFFdm9DLE1BQU1takIsSUFBSW5qQixJQUFJO1lBQUVDLElBQUlrakIsSUFBSWxqQixFQUFFO1lBQUVnSCxRQUFRekUsS0FBS3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ21RLEtBQUssQ0FBQ3daLElBQUluakIsSUFBSSxFQUFFbWpCLElBQUlsakIsRUFBRTtRQUFFO0lBQzFGLE9BQ0ssSUFBSXNvQyxVQUFVQSxPQUFPdm9DLElBQUksSUFBSW1qQixJQUFJbmpCLElBQUksSUFBSXVvQyxPQUFPdG9DLEVBQUUsSUFBSWtqQixJQUFJbGpCLEVBQUUsSUFDNURzb0MsQ0FBQUEsT0FBT3ZvQyxJQUFJLElBQUltakIsSUFBSW5qQixJQUFJLElBQUl1b0MsT0FBT3RvQyxFQUFFLElBQUlrakIsSUFBSWxqQixFQUFFLEtBQy9DLElBQUtBLEVBQUUsR0FBR2tqQixJQUFJbmpCLElBQUksR0FBS3VvQyxDQUFBQSxPQUFPdG9DLEVBQUUsR0FBR3NvQyxPQUFPdm9DLElBQUksS0FBSyxHQUFHO1FBQ3RELCtEQUErRDtRQUMvRCxpRUFBaUU7UUFDakUsMENBQTBDO1FBQzFDdW9DLFNBQVM7WUFDTHZvQyxNQUFNbWpCLElBQUluakIsSUFBSTtZQUFFQyxJQUFJa2pCLElBQUlsakIsRUFBRTtZQUMxQmdILFFBQVF6RSxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDbVEsS0FBSyxDQUFDd1osSUFBSW5qQixJQUFJLEVBQUV1b0MsT0FBT3ZvQyxJQUFJLEVBQUVtTyxNQUFNLENBQUNvNkIsT0FBT3RoQyxNQUFNLEVBQUVrSCxNQUFNLENBQUMzTCxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDbVEsS0FBSyxDQUFDNCtCLE9BQU90b0MsRUFBRSxFQUFFa2pCLElBQUlsakIsRUFBRTtRQUMzSDtJQUNKLE9BQ0ssSUFBSSxDQUFDMEksUUFBUUMsR0FBRyxJQUFJRCxRQUFRUSxPQUFPLEtBQUtvL0IsVUFBVUEsT0FBT3ZvQyxJQUFJLElBQUl1b0MsT0FBT3RvQyxFQUFFLElBQUlzb0MsT0FBT3ZvQyxJQUFJLElBQUltakIsSUFBSTVLLElBQUksR0FBRyxLQUN6RyxTQUFTbmIsSUFBSSxDQUFDbXJDLE9BQU90aEMsTUFBTSxDQUFDcEIsUUFBUSxPQUFPckQsS0FBSzZjLFVBQVUsQ0FBQ3VwQixZQUFZLENBQUMsa0JBQWtCLE9BQU87UUFDakcsaUVBQWlFO1FBQ2pFLGdEQUFnRDtRQUNoRCxJQUFJL29CLFVBQVUwb0IsT0FBT3RoQyxNQUFNLENBQUM5TSxNQUFNLElBQUksR0FDbEMwbEIsU0FBU25vQiw4REFBZUEsQ0FBQzB3QyxNQUFNLENBQUN2b0IsT0FBT0UsSUFBSSxDQUFDb0MsTUFBTSxHQUFHLEdBQUd0QyxPQUFPRSxJQUFJLENBQUN4SCxJQUFJLEdBQUc7UUFDL0Vnd0IsU0FBUztZQUFFdm9DLE1BQU1takIsSUFBSW5qQixJQUFJO1lBQUVDLElBQUlrakIsSUFBSWxqQixFQUFFO1lBQUVnSCxRQUFRNVAsbURBQUlBLENBQUN3WixFQUFFLENBQUM7Z0JBQUM7YUFBSTtRQUFFO0lBQ2xFLE9BQ0ssSUFBSWxJLFFBQVFMLE1BQU0sSUFBSWlnQyxVQUFVQSxPQUFPdm9DLElBQUksSUFBSXVvQyxPQUFPdG9DLEVBQUUsSUFBSXNvQyxPQUFPdm9DLElBQUksSUFBSW1qQixJQUFJNUssSUFBSSxJQUNwRmd3QixPQUFPdGhDLE1BQU0sQ0FBQ3BCLFFBQVEsTUFBTSxTQUFTckQsS0FBS21uQixZQUFZLEVBQUU7UUFDeEQsNkRBQTZEO1FBQzdELGlFQUFpRTtRQUNqRSxvREFBb0Q7UUFDcEQsSUFBSTlKLFFBQ0FBLFNBQVNub0IsOERBQWVBLENBQUMwd0MsTUFBTSxDQUFDdm9CLE9BQU9FLElBQUksQ0FBQ29DLE1BQU0sR0FBRyxHQUFHdEMsT0FBT0UsSUFBSSxDQUFDeEgsSUFBSSxHQUFHO1FBQy9FZ3dCLFNBQVM7WUFBRXZvQyxNQUFNbWpCLElBQUluakIsSUFBSTtZQUFFQyxJQUFJa2pCLElBQUlsakIsRUFBRTtZQUFFZ0gsUUFBUTVQLG1EQUFJQSxDQUFDd1osRUFBRSxDQUFDO2dCQUFDO2FBQUk7UUFBRTtJQUNsRTtJQUNBLElBQUkwM0IsUUFBUTtRQUNSLElBQUk1L0IsUUFBUUYsR0FBRyxJQUFJakcsS0FBS21kLFVBQVUsQ0FBQzJQLFdBQVcsSUFDMUMsT0FBTztRQUNYLCtEQUErRDtRQUMvRCwrREFBK0Q7UUFDL0QsNkRBQTZEO1FBQzdELDhEQUE4RDtRQUM5RCw2REFBNkQ7UUFDN0QsK0JBQStCO1FBQy9CLElBQUkzbUIsUUFBUVEsT0FBTyxJQUNkLFFBQVFuSixJQUFJLElBQUltakIsSUFBSW5qQixJQUFJLElBQUl1b0MsT0FBT3RvQyxFQUFFLElBQUlrakIsSUFBSWxqQixFQUFFLElBQzVDc29DLE9BQU90aEMsTUFBTSxDQUFDOU0sTUFBTSxJQUFJLEtBQUtvdUMsT0FBT3RoQyxNQUFNLENBQUNrWixLQUFLLElBQUksS0FDcEQ3ZixZQUFZa0MsS0FBSzZjLFVBQVUsRUFBRSxTQUFTLE9BQ3JDLENBQUNrcEIsT0FBT3ZvQyxJQUFJLElBQUltakIsSUFBSW5qQixJQUFJLEdBQUcsS0FBS3VvQyxPQUFPdG9DLEVBQUUsSUFBSWtqQixJQUFJbGpCLEVBQUUsSUFBSXNvQyxPQUFPdGhDLE1BQU0sQ0FBQzlNLE1BQU0sSUFBSSxLQUM1RXF1QyxXQUFXLEtBQUtELE9BQU90aEMsTUFBTSxDQUFDOU0sTUFBTSxHQUFHb3VDLE9BQU90b0MsRUFBRSxHQUFHc29DLE9BQU92b0MsSUFBSSxJQUFJdW9DLE9BQU90b0MsRUFBRSxHQUFHa2pCLElBQUk1SyxJQUFJLEtBQ3RGalksWUFBWWtDLEtBQUs2YyxVQUFVLEVBQUUsYUFBYSxNQUM3Q2twQixPQUFPdm9DLElBQUksSUFBSW1qQixJQUFJbmpCLElBQUksSUFBSXVvQyxPQUFPdG9DLEVBQUUsSUFBSWtqQixJQUFJbGpCLEVBQUUsR0FBRyxLQUFLc29DLE9BQU90aEMsTUFBTSxDQUFDOU0sTUFBTSxJQUFJLEtBQzNFbUcsWUFBWWtDLEtBQUs2YyxVQUFVLEVBQUUsVUFBVSxHQUFHLEdBQ2xELE9BQU87UUFDWCxJQUFJclosT0FBT3VpQyxPQUFPdGhDLE1BQU0sQ0FBQ3BCLFFBQVE7UUFDakMsSUFBSXJELEtBQUttZCxVQUFVLENBQUNDLFNBQVMsSUFBSSxHQUM3QnBkLEtBQUttZCxVQUFVLENBQUNDLFNBQVM7UUFDN0IsSUFBSWlwQjtRQUNKLElBQUlDLGdCQUFnQixJQUFNRCxhQUFjQSxDQUFBQSxZQUFZRSxtQkFBbUJ2bUMsTUFBTStsQyxRQUFRMW9CLE9BQU07UUFDM0YsSUFBSSxDQUFDcmQsS0FBS3lKLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ2hCLGNBQWMxSyxJQUFJLENBQUN5cEIsQ0FBQUEsSUFBS0EsRUFBRTUxQixNQUFNK2xDLE9BQU92b0MsSUFBSSxFQUFFdW9DLE9BQU90b0MsRUFBRSxFQUFFK0YsTUFBTThpQyxpQkFDaEZ0bUMsS0FBS2d2QixRQUFRLENBQUNzWDtRQUNsQixPQUFPO0lBQ1gsT0FDSyxJQUFJanBCLFVBQVUsQ0FBQ0EsT0FBT0UsSUFBSSxDQUFDL2dCLEVBQUUsQ0FBQ21rQixNQUFNO1FBQ3JDLElBQUluSixpQkFBaUIsT0FBT3lYLFlBQVk7UUFDeEMsSUFBSWp2QixLQUFLbWQsVUFBVSxDQUFDNk0saUJBQWlCLEdBQUdyTixLQUFLQyxHQUFHLEtBQUssSUFBSTtZQUNyRCxJQUFJNWMsS0FBS21kLFVBQVUsQ0FBQzRNLG1CQUFtQixJQUFJLFVBQ3ZDdlMsaUJBQWlCO1lBQ3JCeVgsWUFBWWp2QixLQUFLbWQsVUFBVSxDQUFDNE0sbUJBQW1CO1FBQ25EO1FBQ0EvcEIsS0FBS2d2QixRQUFRLENBQUM7WUFBRTMzQixXQUFXZ21CO1lBQVE3RjtZQUFnQnlYO1FBQVU7UUFDN0QsT0FBTztJQUNYLE9BQ0s7UUFDRCxPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNzWCxtQkFBbUJ2bUMsSUFBSSxFQUFFK2xDLE1BQU0sRUFBRTFvQixNQUFNO0lBQzVDLElBQUloQyxJQUFJRCxhQUFhcGIsS0FBS3lKLEtBQUssRUFBRWtYLE1BQU12RixXQUFXL2pCLFNBQVMsQ0FBQ2ttQixJQUFJO0lBQ2hFLElBQUl3b0IsT0FBT3ZvQyxJQUFJLElBQUltakIsSUFBSW5qQixJQUFJLElBQUl1b0MsT0FBT3RvQyxFQUFFLElBQUlrakIsSUFBSWxqQixFQUFFLElBQUlzb0MsT0FBT3RvQyxFQUFFLEdBQUdzb0MsT0FBT3ZvQyxJQUFJLElBQUksQ0FBQ21qQixJQUFJbGpCLEVBQUUsR0FBR2tqQixJQUFJbmpCLElBQUksSUFBSSxLQUNsRyxFQUFDNmYsVUFBVUEsT0FBT0UsSUFBSSxDQUFDL1QsS0FBSyxJQUFJNlQsT0FBT0UsSUFBSSxDQUFDL2YsSUFBSSxJQUFJdW9DLE9BQU92b0MsSUFBSSxHQUFHdW9DLE9BQU90aEMsTUFBTSxDQUFDOU0sTUFBTSxLQUN2RnFJLEtBQUttZCxVQUFVLENBQUNDLFNBQVMsR0FBRyxHQUFHO1FBQy9CLElBQUk3ZCxTQUFTb2hCLElBQUluakIsSUFBSSxHQUFHdW9DLE9BQU92b0MsSUFBSSxHQUFHNGQsV0FBV21NLFFBQVEsQ0FBQzVHLElBQUluakIsSUFBSSxFQUFFdW9DLE9BQU92b0MsSUFBSSxJQUFJO1FBQ25GLElBQUlnQyxRQUFRbWhCLElBQUlsakIsRUFBRSxHQUFHc29DLE9BQU90b0MsRUFBRSxHQUFHMmQsV0FBV21NLFFBQVEsQ0FBQ3dlLE9BQU90b0MsRUFBRSxFQUFFa2pCLElBQUlsakIsRUFBRSxJQUFJO1FBQzFFNGQsS0FBS0QsV0FBVzRVLGdCQUFnQixDQUFDaHdCLEtBQUt5SixLQUFLLENBQUNpbUIsTUFBTSxDQUFDbndCLFNBQVN3bUMsT0FBT3RoQyxNQUFNLENBQUMyZSxXQUFXLENBQUMsR0FBRy9sQixXQUFXMkMsS0FBS3lKLEtBQUssQ0FBQ3NILFNBQVMsSUFBSXZSO0lBQ2hJLE9BQ0s7UUFDRCxJQUFJOFgsVUFBVThELFdBQVc5RCxPQUFPLENBQUN5dUI7UUFDakMsSUFBSVMsVUFBVW5wQixVQUFVQSxPQUFPRSxJQUFJLENBQUM5ZixFQUFFLElBQUk2WixRQUFRbXZCLFNBQVMsR0FBR3BwQixPQUFPRSxJQUFJLEdBQUdsZ0I7UUFDNUUsbURBQW1EO1FBQ25ELElBQUkrZCxXQUFXL2pCLFNBQVMsQ0FBQ29ZLE1BQU0sQ0FBQzlYLE1BQU0sR0FBRyxLQUFLcUksS0FBS21kLFVBQVUsQ0FBQ0MsU0FBUyxJQUFJLEtBQ3ZFMm9CLE9BQU90b0MsRUFBRSxJQUFJa2pCLElBQUlsakIsRUFBRSxJQUFJc29DLE9BQU90b0MsRUFBRSxJQUFJa2pCLElBQUlsakIsRUFBRSxHQUFHLElBQUk7WUFDakQsSUFBSWlwQyxXQUFXMW1DLEtBQUt5SixLQUFLLENBQUM4ZCxRQUFRLENBQUN3ZSxPQUFPdm9DLElBQUksRUFBRXVvQyxPQUFPdG9DLEVBQUU7WUFDekQsSUFBSWtwQyxrQkFBa0JucEIsY0FBY0gsVUFBVTJGLG9CQUFvQmhqQixNQUFNcWQsT0FBT0UsSUFBSSxDQUFDeEgsSUFBSTtZQUN4RixJQUFJeUgsYUFBYTtnQkFDYixJQUFJeFksT0FBTytnQyxPQUFPdGhDLE1BQU0sQ0FBQzlNLE1BQU0sR0FBSW91QyxDQUFBQSxPQUFPdG9DLEVBQUUsR0FBR3NvQyxPQUFPdm9DLElBQUk7Z0JBQzFEbXBDLG1CQUFtQjtvQkFBRW5wQyxNQUFNZ2dCLFlBQVloZ0IsSUFBSTtvQkFBRUMsSUFBSStmLFlBQVkvZixFQUFFLEdBQUd1SDtnQkFBSztZQUMzRSxPQUNLO2dCQUNEMmhDLG1CQUFtQjNtQyxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDdVosTUFBTSxDQUFDb1EsSUFBSTVLLElBQUk7WUFDckQ7WUFDQSxJQUFJOVcsU0FBUzBoQixJQUFJbGpCLEVBQUUsR0FBR3NvQyxPQUFPdG9DLEVBQUUsRUFBRTI1QixPQUFPelcsSUFBSWxqQixFQUFFLEdBQUdrakIsSUFBSW5qQixJQUFJO1lBQ3pENmQsS0FBS0QsV0FBVzJVLGFBQWEsQ0FBQ3B6QixDQUFBQTtnQkFDMUIsSUFBSUEsTUFBTWEsSUFBSSxJQUFJbWpCLElBQUluakIsSUFBSSxJQUFJYixNQUFNYyxFQUFFLElBQUlrakIsSUFBSWxqQixFQUFFLEVBQzVDLE9BQU87b0JBQUU2WjtvQkFBUzNhLE9BQU82cEMsV0FBVzdwQyxNQUFNMGEsR0FBRyxDQUFDQztnQkFBUztnQkFDM0QsSUFBSTdaLEtBQUtkLE1BQU1jLEVBQUUsR0FBR3dCLFFBQVF6QixPQUFPQyxLQUFLaXBDLFNBQVMvdUMsTUFBTTtnQkFDdkQsSUFBSWdGLE1BQU1jLEVBQUUsR0FBR2QsTUFBTWEsSUFBSSxJQUFJNDVCLFFBQVFwM0IsS0FBS3lKLEtBQUssQ0FBQzhkLFFBQVEsQ0FBQy9wQixNQUFNQyxPQUFPaXBDLFlBQ2xFLGlEQUFpRDtnQkFDakQsaURBQWlEO2dCQUNqRCx1REFBdUQ7Z0JBQ3ZELFdBQVc7Z0JBQ1gvcEMsTUFBTWMsRUFBRSxJQUFJa3BDLGlCQUFpQm5wQyxJQUFJLElBQUliLE1BQU1hLElBQUksSUFBSW1wQyxpQkFBaUJscEMsRUFBRSxFQUN0RSxPQUFPO29CQUFFZDtnQkFBTTtnQkFDbkIsSUFBSWlxQyxlQUFleHJCLFdBQVc5RCxPQUFPLENBQUM7b0JBQUU5WjtvQkFBTUM7b0JBQUlnSCxRQUFRc2hDLE9BQU90aEMsTUFBTTtnQkFBQyxJQUFJb2lDLFNBQVNscUMsTUFBTWMsRUFBRSxHQUFHa2pCLElBQUlsakIsRUFBRTtnQkFDdEcsT0FBTztvQkFDSDZaLFNBQVNzdkI7b0JBQ1RqcUMsT0FBTyxDQUFDNnBDLFVBQVU3cEMsTUFBTTBhLEdBQUcsQ0FBQ3V2QixnQkFDeEIxeEMsOERBQWVBLENBQUN5SCxLQUFLLENBQUM3QyxLQUFLc0YsR0FBRyxDQUFDLEdBQUdvbkMsUUFBUTdtQixNQUFNLEdBQUdrbkIsU0FBUy9zQyxLQUFLc0YsR0FBRyxDQUFDLEdBQUdvbkMsUUFBUXp3QixJQUFJLEdBQUc4d0I7Z0JBQy9GO1lBQ0o7UUFDSixPQUNLO1lBQ0R4ckIsS0FBSztnQkFDRC9EO2dCQUNBamdCLFdBQVdtdkMsV0FBV3ByQixXQUFXL2pCLFNBQVMsQ0FBQ2lOLFlBQVksQ0FBQ2tpQztZQUM1RDtRQUNKO0lBQ0o7SUFDQSxJQUFJdlgsWUFBWTtJQUNoQixJQUFJanZCLEtBQUtvZCxTQUFTLElBQ2RwZCxLQUFLbWQsVUFBVSxDQUFDNE4sd0JBQXdCLElBQUkvcUIsS0FBS21kLFVBQVUsQ0FBQzBOLGtCQUFrQixHQUFHbE8sS0FBS0MsR0FBRyxLQUFLLElBQUk7UUFDbEc1YyxLQUFLbWQsVUFBVSxDQUFDNE4sd0JBQXdCLEdBQUc7UUFDM0NrRSxhQUFhO1FBQ2IsSUFBSWp2QixLQUFLbWQsVUFBVSxDQUFDeU4sc0JBQXNCLEVBQUU7WUFDeENxRSxhQUFhO1lBQ2JqdkIsS0FBS21kLFVBQVUsQ0FBQ3lOLHNCQUFzQixHQUFHO1FBQzdDO0lBQ0o7SUFDQSxPQUFPeFAsV0FBV2pDLE1BQU0sQ0FBQ2tDLElBQUk7UUFBRTRUO1FBQVd6WCxnQkFBZ0I7SUFBSztBQUNuRTtBQUNBLFNBQVMydUIsU0FBUzM3QixDQUFDLEVBQUVDLENBQUMsRUFBRXc3QixZQUFZLEVBQUVDLGFBQWE7SUFDL0MsSUFBSVksU0FBU2h0QyxLQUFLK0MsR0FBRyxDQUFDMk4sRUFBRTdTLE1BQU0sRUFBRThTLEVBQUU5UyxNQUFNO0lBQ3hDLElBQUk2RixPQUFPO0lBQ1gsTUFBT0EsT0FBT3NwQyxVQUFVdDhCLEVBQUVpSSxVQUFVLENBQUNqVixTQUFTaU4sRUFBRWdJLFVBQVUsQ0FBQ2pWLE1BQ3ZEQTtJQUNKLElBQUlBLFFBQVFzcEMsVUFBVXQ4QixFQUFFN1MsTUFBTSxJQUFJOFMsRUFBRTlTLE1BQU0sRUFDdEMsT0FBTztJQUNYLElBQUk0aUIsTUFBTS9QLEVBQUU3UyxNQUFNLEVBQUU4aUIsTUFBTWhRLEVBQUU5UyxNQUFNO0lBQ2xDLE1BQU80aUIsTUFBTSxLQUFLRSxNQUFNLEtBQUtqUSxFQUFFaUksVUFBVSxDQUFDOEgsTUFBTSxNQUFNOVAsRUFBRWdJLFVBQVUsQ0FBQ2dJLE1BQU0sR0FBSTtRQUN6RUY7UUFDQUU7SUFDSjtJQUNBLElBQUl5ckIsaUJBQWlCLE9BQU87UUFDeEIsSUFBSWEsU0FBU2p0QyxLQUFLc0YsR0FBRyxDQUFDLEdBQUc1QixPQUFPMUQsS0FBSytDLEdBQUcsQ0FBQzBkLEtBQUtFO1FBQzlDd3JCLGdCQUFnQjFyQixNQUFNd3NCLFNBQVN2cEM7SUFDbkM7SUFDQSxJQUFJK2MsTUFBTS9jLFFBQVFnTixFQUFFN1MsTUFBTSxHQUFHOFMsRUFBRTlTLE1BQU0sRUFBRTtRQUNuQyxJQUFJbzJCLE9BQU9rWSxnQkFBZ0J6b0MsUUFBUXlvQyxnQkFBZ0IxckIsTUFBTS9jLE9BQU95b0MsZUFBZTtRQUMvRXpvQyxRQUFRdXdCO1FBQ1J0VCxNQUFNamQsT0FBUWlkLENBQUFBLE1BQU1GLEdBQUU7UUFDdEJBLE1BQU0vYztJQUNWLE9BQ0ssSUFBSWlkLE1BQU1qZCxNQUFNO1FBQ2pCLElBQUl1d0IsT0FBT2tZLGdCQUFnQnpvQyxRQUFReW9DLGdCQUFnQnhyQixNQUFNamQsT0FBT3lvQyxlQUFlO1FBQy9Fem9DLFFBQVF1d0I7UUFDUnhULE1BQU0vYyxPQUFRK2MsQ0FBQUEsTUFBTUUsR0FBRTtRQUN0QkEsTUFBTWpkO0lBQ1Y7SUFDQSxPQUFPO1FBQUVBO1FBQU0rYztRQUFLRTtJQUFJO0FBQzVCO0FBQ0EsU0FBUytxQixnQkFBZ0J4bEMsSUFBSTtJQUN6QixJQUFJb0gsU0FBUyxFQUFFO0lBQ2YsSUFBSXBILEtBQUt6SixJQUFJLENBQUNXLGFBQWEsSUFBSThJLEtBQUs2YyxVQUFVLEVBQzFDLE9BQU96VjtJQUNYLElBQUksRUFBRTlQLFVBQVUsRUFBRStFLFlBQVksRUFBRUMsU0FBUyxFQUFFQyxXQUFXLEVBQUUsR0FBR3lELEtBQUtrZSxRQUFRLENBQUNHLGNBQWM7SUFDdkYsSUFBSS9tQixZQUFZO1FBQ1o4UCxPQUFPakssSUFBSSxDQUFDLElBQUk4bkMsU0FBUzN0QyxZQUFZK0U7UUFDckMsSUFBSUMsYUFBYWhGLGNBQWNpRixlQUFlRixjQUMxQytLLE9BQU9qSyxJQUFJLENBQUMsSUFBSThuQyxTQUFTM29DLFdBQVdDO0lBQzVDO0lBQ0EsT0FBTzZLO0FBQ1g7QUFDQSxTQUFTcStCLG9CQUFvQnZCLE1BQU0sRUFBRTl0QyxJQUFJO0lBQ3JDLElBQUk4dEMsT0FBT3ZzQyxNQUFNLElBQUksR0FDakIsT0FBTztJQUNYLElBQUlnb0IsU0FBU3VrQixNQUFNLENBQUMsRUFBRSxDQUFDamtDLEdBQUcsRUFBRThWLE9BQU9tdUIsT0FBT3ZzQyxNQUFNLElBQUksSUFBSXVzQyxNQUFNLENBQUMsRUFBRSxDQUFDamtDLEdBQUcsR0FBRzBmO0lBQ3hFLE9BQU9BLFNBQVMsQ0FBQyxLQUFLNUosT0FBTyxDQUFDLElBQUk3Z0IsOERBQWVBLENBQUMwd0MsTUFBTSxDQUFDam1CLFNBQVN2cEIsTUFBTTJmLE9BQU8zZixRQUFRO0FBQzNGO0FBRUEsTUFBTTR3QyxpQkFBaUI7SUFDbkI3a0MsV0FBVztJQUNYOGtDLGVBQWU7SUFDZkMsU0FBUztJQUNUcG9DLFlBQVk7SUFDWnFvQyx1QkFBdUI7QUFDM0I7QUFDQSxnRUFBZ0U7QUFDaEUsaUNBQWlDO0FBQ2pDLE1BQU1DLGNBQWNqaEMsUUFBUVAsRUFBRSxJQUFJTyxRQUFRSSxVQUFVLElBQUk7QUFDeEQsTUFBTThnQztJQUNGanJDLFlBQVk0RCxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUNBLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUMwUSxNQUFNLEdBQUc7UUFDZCxrRUFBa0U7UUFDbEUsNENBQTRDO1FBQzVDLDZEQUE2RDtRQUM3RCxvREFBb0Q7UUFDcEQsK0RBQStEO1FBQy9ELHNDQUFzQztRQUN0QyxJQUFJLENBQUMyTixjQUFjLEdBQUcsSUFBSWxpQjtRQUMxQiw0REFBNEQ7UUFDNUQsSUFBSSxDQUFDbXJDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLENBQUM7UUFDckIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQztRQUN0QixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLGtCQUFrQixHQUFHLENBQUM7UUFDM0IsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRTtRQUN2QixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUN6cEIsSUFBSSxHQUFHLEVBQUU7UUFDZCx3RUFBd0U7UUFDeEUsSUFBSSxDQUFDMHBCLFdBQVcsR0FBRyxDQUFDO1FBQ3BCLElBQUksQ0FBQ3R4QyxHQUFHLEdBQUdvSixLQUFLNmMsVUFBVTtRQUMxQixJQUFJLENBQUNxQixRQUFRLEdBQUcsSUFBSWlxQixpQkFBaUJDLENBQUFBO1lBQ2pDLEtBQUssSUFBSUMsT0FBT0QsVUFDWixJQUFJLENBQUNYLEtBQUssQ0FBQ3RxQyxJQUFJLENBQUNrckM7WUFDcEIscURBQXFEO1lBQ3JELHlEQUF5RDtZQUN6RCxzREFBc0Q7WUFDdEQsRUFBRTtZQUNGLDJEQUEyRDtZQUMzRCw0REFBNEQ7WUFDNUQsMkRBQTJEO1lBQzNELHdEQUF3RDtZQUN4RCx3QkFBd0I7WUFDeEIsSUFBSSxDQUFDbGlDLFFBQVFQLEVBQUUsSUFBSU8sUUFBUUksVUFBVSxJQUFJLE1BQU1KLFFBQVFGLEdBQUcsSUFBSWpHLEtBQUtvZCxTQUFTLEtBQ3hFZ3JCLFVBQVVqOEIsSUFBSSxDQUFDZ08sQ0FBQUEsSUFBS0EsRUFBRW5MLElBQUksSUFBSSxlQUFlbUwsRUFBRW11QixZQUFZLENBQUMzd0MsTUFBTSxJQUM5RHdpQixFQUFFbkwsSUFBSSxJQUFJLG1CQUFtQm1MLEVBQUVvdUIsUUFBUSxDQUFDNXdDLE1BQU0sR0FBR3dpQixFQUFFM2pCLE1BQU0sQ0FBQ2tCLFNBQVMsQ0FBQ0MsTUFBTSxHQUM5RSxJQUFJLENBQUMyOEIsU0FBUztpQkFFZCxJQUFJLENBQUNsRSxLQUFLO1FBQ2xCO1FBQ0EsSUFBSWdYLGFBQ0EsSUFBSSxDQUFDb0IsVUFBVSxHQUFHLENBQUNqL0I7WUFDZixJQUFJLENBQUNrK0IsS0FBSyxDQUFDdHFDLElBQUksQ0FBQztnQkFBRTNHLFFBQVErUyxNQUFNL1MsTUFBTTtnQkFDbEN3WSxNQUFNO2dCQUNOdTVCLFVBQVVoL0IsTUFBTWsvQixTQUFTO1lBQUM7WUFDOUIsSUFBSSxDQUFDblUsU0FBUztRQUNsQjtRQUNKLElBQUksQ0FBQ29VLGlCQUFpQixHQUFHLElBQUksQ0FBQ0EsaUJBQWlCLENBQUN2ZCxJQUFJLENBQUMsSUFBSTtRQUN6RCxJQUFJLENBQUN3ZCxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLENBQUN4ZCxJQUFJLENBQUMsSUFBSTtRQUN2QyxJQUFJLENBQUN5ZCxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUN6ZCxJQUFJLENBQUMsSUFBSTtRQUNyQyxJQUFJLENBQUMwZCxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRLENBQUMxZCxJQUFJLENBQUMsSUFBSTtRQUN2QyxJQUFJLE9BQU8yZCxrQkFBa0IsWUFBWTtZQUNyQyxJQUFJLENBQUNmLFlBQVksR0FBRyxJQUFJZSxlQUFlO2dCQUNuQyxJQUFJOThCO2dCQUNKLElBQUksQ0FBQyxDQUFDQSxLQUFLLElBQUksQ0FBQ2hNLElBQUksQ0FBQ2lOLE9BQU8sTUFBTSxRQUFRakIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMFEsVUFBVSxJQUFJQyxLQUFLQyxHQUFHLEtBQUssSUFDN0YsSUFBSSxDQUFDK3JCLFFBQVE7WUFDckI7WUFDQSxJQUFJLENBQUNaLFlBQVksQ0FBQ2dCLE9BQU8sQ0FBQy9vQyxLQUFLMmhCLFNBQVM7UUFDNUM7UUFDQSxJQUFJLENBQUNxbkIsa0JBQWtCLENBQUMsSUFBSSxDQUFDN3ZDLEdBQUcsR0FBRzZHLEtBQUs3RyxHQUFHO1FBQzNDLElBQUksQ0FBQzJDLEtBQUs7UUFDVixJQUFJLE9BQU9tdEMsd0JBQXdCLFlBQVk7WUFDM0MsSUFBSSxDQUFDbkIsWUFBWSxHQUFHLElBQUltQixxQkFBcUJDLENBQUFBO2dCQUN6QyxJQUFJLElBQUksQ0FBQ2hCLFdBQVcsR0FBRyxHQUNuQixJQUFJLENBQUNBLFdBQVcsR0FBR3JiLFdBQVcsSUFBSSxDQUFDc2MsZUFBZSxDQUFDaGUsSUFBSSxDQUFDLElBQUksR0FBRztnQkFDbkUsSUFBSStkLFFBQVF2eEMsTUFBTSxHQUFHLEtBQUssT0FBUSxDQUFDdXhDLFFBQVF2eEMsTUFBTSxHQUFHLEVBQUUsQ0FBQ3l4QyxpQkFBaUIsR0FBRyxLQUFNLElBQUksQ0FBQ3BCLFlBQVksRUFBRTtvQkFDaEcsSUFBSSxDQUFDQSxZQUFZLEdBQUcsQ0FBQyxJQUFJLENBQUNBLFlBQVk7b0JBQ3RDLElBQUksSUFBSSxDQUFDQSxZQUFZLElBQUksSUFBSSxDQUFDaG9DLElBQUksQ0FBQ283QixNQUFNLEVBQ3JDLElBQUksQ0FBQ2lPLGVBQWUsQ0FBQzNyQyxTQUFTNHJDLFdBQVcsQ0FBQztnQkFDbEQ7WUFDSixHQUFHO2dCQUFFQyxXQUFXO29CQUFDO29CQUFHO2lCQUFLO1lBQUM7WUFDMUIsSUFBSSxDQUFDekIsWUFBWSxDQUFDaUIsT0FBTyxDQUFDLElBQUksQ0FBQ255QyxHQUFHO1lBQ2xDLElBQUksQ0FBQ3F4QyxlQUFlLEdBQUcsSUFBSWdCLHFCQUFxQkMsQ0FBQUE7Z0JBQzVDLElBQUlBLFFBQVF2eEMsTUFBTSxHQUFHLEtBQUt1eEMsT0FBTyxDQUFDQSxRQUFRdnhDLE1BQU0sR0FBRyxFQUFFLENBQUN5eEMsaUJBQWlCLEdBQUcsR0FDdEUsSUFBSSxDQUFDQyxlQUFlLENBQUMzckMsU0FBUzRyQyxXQUFXLENBQUM7WUFDbEQsR0FBRyxDQUFDO1FBQ1I7UUFDQSxJQUFJLENBQUNILGVBQWU7UUFDcEIsSUFBSSxDQUFDN3BCLGtCQUFrQjtJQUMzQjtJQUNBK3BCLGdCQUFnQmp3QixDQUFDLEVBQUU7UUFDZixJQUFJLENBQUNwWixJQUFJLENBQUNtZCxVQUFVLENBQUN3TyxXQUFXLENBQUMsVUFBVXZTO1FBQzNDLElBQUksSUFBSSxDQUFDNHVCLFlBQVksRUFDakIsSUFBSSxDQUFDaG9DLElBQUksQ0FBQ2dpQixPQUFPO0lBQ3pCO0lBQ0E2bUIsU0FBU3p2QixDQUFDLEVBQUU7UUFDUixJQUFJLElBQUksQ0FBQzR1QixZQUFZLEVBQ2pCLElBQUksQ0FBQzVYLEtBQUssQ0FBQztRQUNmLElBQUksQ0FBQ2laLGVBQWUsQ0FBQ2p3QjtJQUN6QjtJQUNBdXZCLFdBQVc7UUFDUCxJQUFJLElBQUksQ0FBQ25CLGFBQWEsR0FBRyxHQUNyQixJQUFJLENBQUNBLGFBQWEsR0FBRzNhLFdBQVc7WUFDNUIsSUFBSSxDQUFDMmEsYUFBYSxHQUFHLENBQUM7WUFDdEIsSUFBSSxDQUFDeG5DLElBQUksQ0FBQ3dwQyxjQUFjO1FBQzVCLEdBQUc7SUFDWDtJQUNBWixVQUFVO1FBQ04sSUFBSSxDQUFDNW9DLElBQUksQ0FBQzZNLFNBQVMsQ0FBQ212QixRQUFRLEdBQUc7UUFDL0IsSUFBSSxDQUFDaDhCLElBQUksQ0FBQ2dpQixPQUFPO1FBQ2pCNkssV0FBVztZQUNQLElBQUksQ0FBQzdzQixJQUFJLENBQUM2TSxTQUFTLENBQUNtdkIsUUFBUSxHQUFHO1lBQy9CLElBQUksQ0FBQ2g4QixJQUFJLENBQUN3cEMsY0FBYztRQUM1QixHQUFHO0lBQ1A7SUFDQTdxQixXQUFXSCxJQUFJLEVBQUU7UUFDYixJQUFJLElBQUksQ0FBQ3lwQixlQUFlLElBQUt6cEIsQ0FBQUEsS0FBSzdtQixNQUFNLElBQUksSUFBSSxDQUFDNm1CLElBQUksQ0FBQzdtQixNQUFNLElBQUksSUFBSSxDQUFDNm1CLElBQUksQ0FBQ3JTLElBQUksQ0FBQyxDQUFDczlCLEdBQUduc0MsSUFBTW1zQyxLQUFLanJCLElBQUksQ0FBQ2xoQixFQUFFLElBQUk7WUFDckcsSUFBSSxDQUFDMnFDLGVBQWUsQ0FBQ3lCLFVBQVU7WUFDL0IsS0FBSyxJQUFJelAsT0FBT3piLEtBQ1osSUFBSSxDQUFDeXBCLGVBQWUsQ0FBQ2MsT0FBTyxDQUFDOU87WUFDakMsSUFBSSxDQUFDemIsSUFBSSxHQUFHQTtRQUNoQjtJQUNKO0lBQ0FrcUIsa0JBQWtCbi9CLEtBQUssRUFBRTtRQUNyQixJQUFJb2dDLGFBQWEsSUFBSSxDQUFDckMsZ0JBQWdCO1FBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUNob0Isa0JBQWtCLE1BQU0sSUFBSSxDQUFDb29CLGlCQUFpQixFQUNwRDtRQUNKLElBQUksRUFBRTFuQyxJQUFJLEVBQUUsR0FBRyxJQUFJLEVBQUUyZ0IsTUFBTSxJQUFJLENBQUN0QyxjQUFjO1FBQzlDLElBQUlyZSxLQUFLeUosS0FBSyxDQUFDb08sS0FBSyxDQUFDeE8sWUFBWXJKLEtBQUt6SixJQUFJLENBQUNXLGFBQWEsSUFBSSxJQUFJLENBQUNOLEdBQUcsR0FBRyxDQUFDUSxhQUFhNEksS0FBS3BKLEdBQUcsRUFBRStwQixNQUMzRjtRQUNKLElBQUl4TSxVQUFVd00sSUFBSXJwQixVQUFVLElBQUkwSSxLQUFLaU4sT0FBTyxDQUFDaVUsT0FBTyxDQUFDUCxJQUFJcnBCLFVBQVU7UUFDbkUsSUFBSTZjLFdBQVdBLFFBQVFwUixXQUFXLENBQUN3RyxRQUFRO1lBQ3ZDLElBQUksQ0FBQ29nQyxZQUNELElBQUksQ0FBQ3JDLGdCQUFnQixHQUFHO1lBQzVCO1FBQ0o7UUFDQSxpRUFBaUU7UUFDakUseURBQXlEO1FBQ3pELFlBQVk7UUFDWiw0REFBNEQ7UUFDNUQsb0JBQW9CO1FBQ3BCLElBQUksQ0FBQ25oQyxRQUFRUCxFQUFFLElBQUlPLFFBQVFJLFVBQVUsSUFBSSxNQUFNSixRQUFRUSxPQUFPLElBQUlSLFFBQVFMLE1BQU0sS0FBSyxDQUFDOUYsS0FBS3lKLEtBQUssQ0FBQ3BTLFNBQVMsQ0FBQ2ttQixJQUFJLENBQUMvVCxLQUFLLElBQ2pILCtDQUErQztRQUMvQ21YLElBQUlya0IsU0FBUyxJQUFJekUscUJBQXFCOG9CLElBQUlya0IsU0FBUyxFQUFFcWtCLElBQUlwa0IsV0FBVyxFQUFFb2tCLElBQUlycEIsVUFBVSxFQUFFcXBCLElBQUl0a0IsWUFBWSxHQUN0RyxJQUFJLENBQUNpNEIsU0FBUzthQUVkLElBQUksQ0FBQ2xFLEtBQUssQ0FBQztJQUNuQjtJQUNBOVEscUJBQXFCO1FBQ2pCLElBQUksRUFBRXRmLElBQUksRUFBRSxHQUFHLElBQUk7UUFDbkIsZ0VBQWdFO1FBQ2hFLCtDQUErQztRQUMvQyxJQUFJckQsUUFBUXdKLFFBQVFILE1BQU0sSUFBSWhHLEtBQUt6SixJQUFJLENBQUNFLFFBQVEsSUFBSSxNQUNoRE0sa0JBQWtCLElBQUksQ0FBQ0gsR0FBRyxDQUFDRixhQUFhLEtBQUssSUFBSSxDQUFDRSxHQUFHLElBQ3JEZ3pDLHlCQUF5QixJQUFJLENBQUM1cEMsSUFBSSxLQUFLMUosYUFBYTBKLEtBQUt6SixJQUFJO1FBQ2pFLElBQUksQ0FBQ29HLFNBQVMsSUFBSSxDQUFDMGhCLGNBQWMsQ0FBQzdoQixFQUFFLENBQUNHLFFBQ2pDLE9BQU87UUFDWCxJQUFJa3RDLFFBQVF6eUMsYUFBYSxJQUFJLENBQUNSLEdBQUcsRUFBRStGO1FBQ25DLGtFQUFrRTtRQUNsRSxpRUFBaUU7UUFDakUsa0NBQWtDO1FBQ2xDLElBQUlrdEMsU0FBUyxDQUFDLElBQUksQ0FBQ3ZDLGdCQUFnQixJQUMvQnRuQyxLQUFLbWQsVUFBVSxDQUFDaU4sYUFBYSxHQUFHek4sS0FBS0MsR0FBRyxLQUFLLE9BQzdDNWMsS0FBS21kLFVBQVUsQ0FBQ2dOLGFBQWEsR0FBR3hOLEtBQUtDLEdBQUcsS0FBSyxPQUM3QzVkLGVBQWUsSUFBSSxDQUFDcEksR0FBRyxFQUFFK0YsUUFBUTtZQUNqQyxJQUFJLENBQUNxRCxJQUFJLENBQUNtZCxVQUFVLENBQUNpTixhQUFhLEdBQUc7WUFDckNwcUIsS0FBS2lOLE9BQU8sQ0FBQ2tTLGVBQWU7WUFDNUIsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFDZCxjQUFjLENBQUMzaEIsUUFBUSxDQUFDQztRQUM3QixJQUFJa3RDLE9BQ0EsSUFBSSxDQUFDdkMsZ0JBQWdCLEdBQUc7UUFDNUIsT0FBTztJQUNYO0lBQ0E1bUIsa0JBQWtCZixNQUFNLEVBQUU1SixJQUFJLEVBQUU7UUFDNUIsSUFBSSxDQUFDc0ksY0FBYyxDQUFDemhCLEdBQUcsQ0FBQytpQixPQUFPOW9CLElBQUksRUFBRThvQixPQUFPMWdCLE1BQU0sRUFBRThXLEtBQUtsZixJQUFJLEVBQUVrZixLQUFLOVcsTUFBTTtRQUMxRSxJQUFJLENBQUNxb0MsZ0JBQWdCLEdBQUc7SUFDNUI7SUFDQXJULHNCQUFzQjtRQUNsQixJQUFJLENBQUM1VixjQUFjLENBQUN6aEIsR0FBRyxDQUFDLE1BQU0sR0FBRyxNQUFNO0lBQzNDO0lBQ0F1c0Msa0JBQWtCO1FBQ2QsSUFBSSxDQUFDakIsV0FBVyxHQUFHLENBQUM7UUFDcEIsSUFBSTVxQyxJQUFJLEdBQUd5TixVQUFVO1FBQ3JCLElBQUssSUFBSW5VLE1BQU0sSUFBSSxDQUFDQSxHQUFHLEVBQUVBLEtBQU07WUFDM0IsSUFBSUEsSUFBSUgsUUFBUSxJQUFJLEdBQUc7Z0JBQ25CLElBQUksQ0FBQ3NVLFdBQVd6TixJQUFJLElBQUksQ0FBQ3VxQyxhQUFhLENBQUNsd0MsTUFBTSxJQUFJLElBQUksQ0FBQ2t3QyxhQUFhLENBQUN2cUMsRUFBRSxJQUFJMUcsS0FDdEUwRztxQkFDQyxJQUFJLENBQUN5TixTQUNOQSxVQUFVLElBQUksQ0FBQzg4QixhQUFhLENBQUMxZ0MsS0FBSyxDQUFDLEdBQUc3SjtnQkFDMUMsSUFBSXlOLFNBQ0FBLFFBQVE1TixJQUFJLENBQUN2RztnQkFDakJBLE1BQU1BLElBQUl1RSxZQUFZLElBQUl2RSxJQUFJRSxVQUFVO1lBQzVDLE9BQ0ssSUFBSUYsSUFBSUgsUUFBUSxJQUFJLElBQUk7Z0JBQ3pCRyxNQUFNQSxJQUFJcUYsSUFBSTtZQUNsQixPQUNLO2dCQUNEO1lBQ0o7UUFDSjtRQUNBLElBQUlxQixJQUFJLElBQUksQ0FBQ3VxQyxhQUFhLENBQUNsd0MsTUFBTSxJQUFJLENBQUNvVCxTQUNsQ0EsVUFBVSxJQUFJLENBQUM4OEIsYUFBYSxDQUFDMWdDLEtBQUssQ0FBQyxHQUFHN0o7UUFDMUMsSUFBSXlOLFNBQVM7WUFDVCxLQUFLLElBQUluVSxPQUFPLElBQUksQ0FBQ2l4QyxhQUFhLENBQzlCanhDLElBQUl1MUIsbUJBQW1CLENBQUMsVUFBVSxJQUFJLENBQUMwYyxRQUFRO1lBQ25ELEtBQUssSUFBSWp5QyxPQUFPLElBQUksQ0FBQ2l4QyxhQUFhLEdBQUc5OEIsUUFDakNuVSxJQUFJMDBCLGdCQUFnQixDQUFDLFVBQVUsSUFBSSxDQUFDdWQsUUFBUTtRQUNwRDtJQUNKO0lBQ0FuK0IsT0FBT2lmLENBQUMsRUFBRTtRQUNOLElBQUksQ0FBQyxJQUFJLENBQUNqWixNQUFNLEVBQ1osT0FBT2laO1FBQ1gsSUFBSTtZQUNBLElBQUksQ0FBQ2x2QixJQUFJO1lBQ1QsT0FBT2t2QjtRQUNYLFNBQ1E7WUFDSixJQUFJLENBQUM3dEIsS0FBSztZQUNWLElBQUksQ0FBQzRoQixLQUFLO1FBQ2Q7SUFDSjtJQUNBNWhCLFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQzRVLE1BQU0sRUFDWDtRQUNKLElBQUksQ0FBQ3dOLFFBQVEsQ0FBQzZxQixPQUFPLENBQUMsSUFBSSxDQUFDbnlDLEdBQUcsRUFBRW93QztRQUNoQyxJQUFJSSxhQUNBLElBQUksQ0FBQ3h3QyxHQUFHLENBQUMwMEIsZ0JBQWdCLENBQUMsNEJBQTRCLElBQUksQ0FBQ2tkLFVBQVU7UUFDekUsSUFBSSxDQUFDOTNCLE1BQU0sR0FBRztJQUNsQjtJQUNBalcsT0FBTztRQUNILElBQUksQ0FBQyxJQUFJLENBQUNpVyxNQUFNLEVBQ1o7UUFDSixJQUFJLENBQUNBLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ3dOLFFBQVEsQ0FBQ3dyQixVQUFVO1FBQ3hCLElBQUl0QyxhQUNBLElBQUksQ0FBQ3h3QyxHQUFHLENBQUN1MUIsbUJBQW1CLENBQUMsNEJBQTRCLElBQUksQ0FBQ3FjLFVBQVU7SUFDaEY7SUFDQSxpQ0FBaUM7SUFDakM5cUIsUUFBUTtRQUNKLElBQUksQ0FBQ29zQixjQUFjO1FBQ25CLElBQUksQ0FBQ3JDLEtBQUssQ0FBQzl2QyxNQUFNLEdBQUc7UUFDcEIsSUFBSSxDQUFDMnZDLGdCQUFnQixHQUFHO0lBQzVCO0lBQ0Esa0VBQWtFO0lBQ2xFLDJEQUEyRDtJQUMzRCw2REFBNkQ7SUFDN0Qsb0VBQW9FO0lBQ3BFLG9FQUFvRTtJQUNwRSw0REFBNEQ7SUFDNUQsaUVBQWlFO0lBQ2pFLDREQUE0RDtJQUM1RGpiLGdCQUFnQm51QixHQUFHLEVBQUVDLE9BQU8sRUFBRTtRQUMxQixJQUFJNk47UUFDSixJQUFJLENBQUMsSUFBSSxDQUFDMDdCLGlCQUFpQixFQUFFO1lBQ3pCLElBQUl0WCxRQUFRO2dCQUNSLElBQUlseUIsTUFBTSxJQUFJLENBQUN3cEMsaUJBQWlCO2dCQUNoQyxJQUFJeHBDLEtBQUs7b0JBQ0wsSUFBSSxDQUFDNnJDLHNCQUFzQjtvQkFDM0IsSUFBSSxDQUFDL3BDLElBQUksQ0FBQ21kLFVBQVUsQ0FBQzhNLFdBQVcsR0FBRy9yQixJQUFJQyxPQUFPO29CQUM5QyxJQUFJLENBQUM2QixJQUFJLENBQUNtZCxVQUFVLENBQUMrTSxXQUFXLEdBQUd2TixLQUFLQyxHQUFHO29CQUMzQyxJQUFJb3RCLFVBQVUsSUFBSSxDQUFDNVosS0FBSztvQkFDeEIsSUFBSSxDQUFDNFosV0FBVzlyQyxJQUFJd2hCLEtBQUssRUFDckI1aEIsWUFBWSxJQUFJLENBQUNsSCxHQUFHLEVBQUVzSCxJQUFJQSxHQUFHLEVBQUVBLElBQUlDLE9BQU87Z0JBQ2xEO1lBQ0o7WUFDQSxJQUFJLENBQUN3cEMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDM25DLElBQUksQ0FBQzdHLEdBQUcsQ0FBQzh3QyxxQkFBcUIsQ0FBQzdaO1FBQ2xFO1FBQ0EsaUVBQWlFO1FBQ2pFLGlDQUFpQztRQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDc1gsaUJBQWlCLElBQUl4cEMsT0FBTyxTQUNsQyxJQUFJLENBQUN3cEMsaUJBQWlCLEdBQUc7WUFDckJ4cEM7WUFBS0M7WUFDTCwyREFBMkQ7WUFDM0QsOERBQThEO1lBQzlELDhEQUE4RDtZQUM5RCwwREFBMEQ7WUFDMUR1aEIsT0FBTyxJQUFJLENBQUNrb0IsVUFBVSxHQUFHanJCLEtBQUtDLEdBQUcsS0FBSyxNQUFNLENBQUMsQ0FBRSxFQUFDNVEsS0FBSyxJQUFJLENBQUMwN0IsaUJBQWlCLE1BQU0sUUFBUTE3QixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcwVCxLQUFLO1FBQzlIO0lBQ1I7SUFDQXFxQix5QkFBeUI7UUFDckIsSUFBSSxDQUFDNXdDLEdBQUcsQ0FBQyt3QyxvQkFBb0IsQ0FBQyxJQUFJLENBQUN2QyxrQkFBa0I7UUFDckQsSUFBSSxDQUFDRCxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLGtCQUFrQixHQUFHLENBQUM7SUFDL0I7SUFDQXJULFlBQVk7UUFDUixJQUFJLElBQUksQ0FBQ2lULFlBQVksR0FBRyxHQUNwQixJQUFJLENBQUNBLFlBQVksR0FBRyxJQUFJLENBQUN2bkMsSUFBSSxDQUFDN0csR0FBRyxDQUFDOHdDLHFCQUFxQixDQUFDO1lBQVEsSUFBSSxDQUFDMUMsWUFBWSxHQUFHLENBQUM7WUFBRyxJQUFJLENBQUNuWCxLQUFLO1FBQUk7SUFDOUc7SUFDQXJELGFBQWE7UUFDVCxJQUFJLElBQUksQ0FBQ3dhLFlBQVksSUFBSSxHQUFHO1lBQ3hCLElBQUksQ0FBQ3ZuQyxJQUFJLENBQUM3RyxHQUFHLENBQUMrd0Msb0JBQW9CLENBQUMsSUFBSSxDQUFDM0MsWUFBWTtZQUNwRCxJQUFJLENBQUNBLFlBQVksR0FBRyxDQUFDO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDblgsS0FBSztJQUNkO0lBQ0FpRSxpQkFBaUI7UUFDYixLQUFLLElBQUlnVSxPQUFPLElBQUksQ0FBQ25xQixRQUFRLENBQUNpc0IsV0FBVyxHQUNyQyxJQUFJLENBQUMxQyxLQUFLLENBQUN0cUMsSUFBSSxDQUFDa3JDO1FBQ3BCLE9BQU8sSUFBSSxDQUFDWixLQUFLO0lBQ3JCO0lBQ0FxQyxpQkFBaUI7UUFDYixJQUFJTSxVQUFVLElBQUksQ0FBQy9WLGNBQWM7UUFDakMsSUFBSStWLFFBQVF6eUMsTUFBTSxFQUNkLElBQUksQ0FBQzh2QyxLQUFLLEdBQUcsRUFBRTtRQUNuQixJQUFJanFDLE9BQU8sQ0FBQyxHQUFHQyxLQUFLLENBQUMsR0FBRzBuQyxXQUFXO1FBQ25DLEtBQUssSUFBSWpZLFVBQVVrZCxRQUFTO1lBQ3hCLElBQUl6dEMsUUFBUSxJQUFJLENBQUMwdEMsWUFBWSxDQUFDbmQ7WUFDOUIsSUFBSSxDQUFDdndCLE9BQ0Q7WUFDSixJQUFJQSxNQUFNd29DLFFBQVEsRUFDZEEsV0FBVztZQUNmLElBQUkzbkMsUUFBUSxDQUFDLEdBQUc7Z0JBQ1gsR0FBRUEsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBR2QsS0FBSTtZQUN4QixPQUNLO2dCQUNEYSxPQUFPMUQsS0FBSytDLEdBQUcsQ0FBQ0YsTUFBTWEsSUFBSSxFQUFFQTtnQkFDNUJDLEtBQUszRCxLQUFLc0YsR0FBRyxDQUFDekMsTUFBTWMsRUFBRSxFQUFFQTtZQUM1QjtRQUNKO1FBQ0EsT0FBTztZQUFFRDtZQUFNQztZQUFJMG5DO1FBQVM7SUFDaEM7SUFDQW1GLGFBQWE7UUFDVCxJQUFJLEVBQUU5c0MsSUFBSSxFQUFFQyxFQUFFLEVBQUUwbkMsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDMkUsY0FBYztRQUNoRCxJQUFJenNCLFNBQVMsSUFBSSxDQUFDaXFCLGdCQUFnQixJQUFJbHdDLGFBQWEsSUFBSSxDQUFDUixHQUFHLEVBQUUsSUFBSSxDQUFDeW5CLGNBQWM7UUFDaEYsSUFBSTdnQixPQUFPLEtBQUssQ0FBQzZmLFFBQ2IsT0FBTztRQUNYLElBQUk3ZixPQUFPLENBQUMsR0FDUixJQUFJLENBQUNvcUMsVUFBVSxHQUFHanJCLEtBQUtDLEdBQUc7UUFDOUIsSUFBSSxDQUFDNWMsSUFBSSxDQUFDbWQsVUFBVSxDQUFDaU4sYUFBYSxHQUFHO1FBQ3JDLElBQUksQ0FBQ2tkLGdCQUFnQixHQUFHO1FBQ3hCLElBQUl2QixTQUFTLElBQUliLFVBQVUsSUFBSSxDQUFDbGxDLElBQUksRUFBRXhDLE1BQU1DLElBQUkwbkM7UUFDaEQsSUFBSSxDQUFDbmxDLElBQUksQ0FBQ2lOLE9BQU8sQ0FBQytPLFVBQVUsR0FBRztZQUFFcUIsUUFBUTBvQixPQUFPMW9CLE1BQU0sR0FBRzBvQixPQUFPMW9CLE1BQU0sQ0FBQ0UsSUFBSSxHQUFHO1FBQUs7UUFDbkYsT0FBT3dvQjtJQUNYO0lBQ0EsZ0NBQWdDO0lBQ2hDM1YsTUFBTW1hLGdCQUFnQixJQUFJLEVBQUU7UUFDeEIsa0VBQWtFO1FBQ2xFLGlFQUFpRTtRQUNqRSwrQkFBK0I7UUFDL0IsSUFBSSxJQUFJLENBQUNoRCxZQUFZLElBQUksS0FBSyxJQUFJLENBQUNHLGlCQUFpQixFQUNoRCxPQUFPO1FBQ1gsSUFBSTZDLGVBQ0EsSUFBSSxDQUFDanJCLGtCQUFrQjtRQUMzQixJQUFJd21CLFlBQVksSUFBSSxDQUFDd0UsVUFBVTtRQUMvQixJQUFJLENBQUN4RSxXQUFXO1lBQ1osSUFBSSxDQUFDOWxDLElBQUksQ0FBQ3dwQyxjQUFjO1lBQ3hCLE9BQU87UUFDWDtRQUNBLElBQUlwdUIsYUFBYSxJQUFJLENBQUNwYixJQUFJLENBQUN5SixLQUFLO1FBQ2hDLElBQUkrZ0MsVUFBVTNFLGVBQWUsSUFBSSxDQUFDN2xDLElBQUksRUFBRThsQztRQUN4QywwQkFBMEI7UUFDMUIsSUFBSSxJQUFJLENBQUM5bEMsSUFBSSxDQUFDeUosS0FBSyxJQUFJMlIsWUFDbkIsSUFBSSxDQUFDcGIsSUFBSSxDQUFDbVosTUFBTSxDQUFDLEVBQUU7UUFDdkIsT0FBT3F4QjtJQUNYO0lBQ0FILGFBQWFJLEdBQUcsRUFBRTtRQUNkLElBQUlsc0IsUUFBUSxJQUFJLENBQUN2ZSxJQUFJLENBQUNpTixPQUFPLENBQUNpVSxPQUFPLENBQUN1cEIsSUFBSWowQyxNQUFNO1FBQ2hELElBQUksQ0FBQytuQixTQUFTQSxNQUFNMWIsY0FBYyxDQUFDNG5DLE1BQy9CLE9BQU87UUFDWGxzQixNQUFNdmMsU0FBUyxDQUFDeW9DLElBQUl6N0IsSUFBSSxJQUFJO1FBQzVCLElBQUl5N0IsSUFBSXo3QixJQUFJLElBQUksY0FDWnVQLE1BQU01ZSxLQUFLLElBQUksRUFBRSx1QkFBdUI7UUFDNUMsSUFBSThxQyxJQUFJejdCLElBQUksSUFBSSxhQUFhO1lBQ3pCLElBQUkwN0IsY0FBY0MsVUFBVXBzQixPQUFPa3NCLElBQUlyeUMsZUFBZSxJQUFJcXlDLElBQUlqMEMsTUFBTSxDQUFDNEIsZUFBZSxFQUFFLENBQUM7WUFDdkYsSUFBSXd5QyxhQUFhRCxVQUFVcHNCLE9BQU9rc0IsSUFBSS9wQyxXQUFXLElBQUkrcEMsSUFBSWowQyxNQUFNLENBQUNrSyxXQUFXLEVBQUU7WUFDN0UsT0FBTztnQkFBRWxELE1BQU1rdEMsY0FBY25zQixNQUFNamUsUUFBUSxDQUFDb3FDLGVBQWVuc0IsTUFBTTFlLFVBQVU7Z0JBQ3ZFcEMsSUFBSW10QyxhQUFhcnNCLE1BQU16ZSxTQUFTLENBQUM4cUMsY0FBY3JzQixNQUFNeGUsUUFBUTtnQkFBRW9sQyxVQUFVO1lBQU07UUFDdkYsT0FDSyxJQUFJc0YsSUFBSXo3QixJQUFJLElBQUksaUJBQWlCO1lBQ2xDLE9BQU87Z0JBQUV4UixNQUFNK2dCLE1BQU0xZSxVQUFVO2dCQUFFcEMsSUFBSThnQixNQUFNeGUsUUFBUTtnQkFBRW9sQyxVQUFVc0YsSUFBSWowQyxNQUFNLENBQUNrQixTQUFTLElBQUkreUMsSUFBSWxDLFFBQVE7WUFBQztRQUN4RyxPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7SUFDQXNDLFVBQVUxeEMsR0FBRyxFQUFFO1FBQ1gsSUFBSUEsT0FBTyxJQUFJLENBQUNBLEdBQUcsRUFBRTtZQUNqQixJQUFJLENBQUMyeEMscUJBQXFCLENBQUMsSUFBSSxDQUFDM3hDLEdBQUc7WUFDbkMsSUFBSSxDQUFDQSxHQUFHLEdBQUdBO1lBQ1gsSUFBSSxDQUFDNnZDLGtCQUFrQixDQUFDLElBQUksQ0FBQzd2QyxHQUFHO1FBQ3BDO0lBQ0o7SUFDQTZ2QyxtQkFBbUI3dkMsR0FBRyxFQUFFO1FBQ3BCQSxJQUFJbXlCLGdCQUFnQixDQUFDLFVBQVUsSUFBSSxDQUFDcWQsUUFBUTtRQUM1Q3h2QyxJQUFJbXlCLGdCQUFnQixDQUFDLGVBQWUsSUFBSSxDQUFDc2QsT0FBTztRQUNoRHp2QyxJQUFJbXlCLGdCQUFnQixDQUFDLFVBQVUsSUFBSSxDQUFDdWQsUUFBUTtRQUM1QzF2QyxJQUFJdUUsUUFBUSxDQUFDNHRCLGdCQUFnQixDQUFDLG1CQUFtQixJQUFJLENBQUNvZCxpQkFBaUI7SUFDM0U7SUFDQW9DLHNCQUFzQjN4QyxHQUFHLEVBQUU7UUFDdkJBLElBQUlnekIsbUJBQW1CLENBQUMsVUFBVSxJQUFJLENBQUMwYyxRQUFRO1FBQy9DMXZDLElBQUlnekIsbUJBQW1CLENBQUMsVUFBVSxJQUFJLENBQUN3YyxRQUFRO1FBQy9DeHZDLElBQUlnekIsbUJBQW1CLENBQUMsZUFBZSxJQUFJLENBQUN5YyxPQUFPO1FBQ25EenZDLElBQUl1RSxRQUFRLENBQUN5dUIsbUJBQW1CLENBQUMsbUJBQW1CLElBQUksQ0FBQ3VjLGlCQUFpQjtJQUM5RTtJQUNBL2xDLFVBQVU7UUFDTixJQUFJcUosSUFBSXlDLElBQUlzOEI7UUFDWixJQUFJLENBQUN0d0MsSUFBSTtRQUNSdVIsQ0FBQUEsS0FBSyxJQUFJLENBQUM4N0IsWUFBWSxNQUFNLFFBQVE5N0IsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMDlCLFVBQVU7UUFDMUVqN0IsQ0FBQUEsS0FBSyxJQUFJLENBQUN3NUIsZUFBZSxNQUFNLFFBQVF4NUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaTdCLFVBQVU7UUFDN0VxQixDQUFBQSxLQUFLLElBQUksQ0FBQ2hELFlBQVksTUFBTSxRQUFRZ0QsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHckIsVUFBVTtRQUMzRSxLQUFLLElBQUk5eUMsT0FBTyxJQUFJLENBQUNpeEMsYUFBYSxDQUM5Qmp4QyxJQUFJdTFCLG1CQUFtQixDQUFDLFVBQVUsSUFBSSxDQUFDMGMsUUFBUTtRQUNuRCxJQUFJLENBQUNpQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMzeEMsR0FBRztRQUNuQzZ4QyxhQUFhLElBQUksQ0FBQzlDLFdBQVc7UUFDN0I4QyxhQUFhLElBQUksQ0FBQ3hELGFBQWE7UUFDL0IsSUFBSSxDQUFDcnVDLEdBQUcsQ0FBQyt3QyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMzQyxZQUFZO1FBQy9DLElBQUksQ0FBQ3B1QyxHQUFHLENBQUMrd0Msb0JBQW9CLENBQUMsSUFBSSxDQUFDdkMsa0JBQWtCO0lBQ3pEO0FBQ0o7QUFDQSxTQUFTZ0QsVUFBVXBzQixLQUFLLEVBQUUzbkIsR0FBRyxFQUFFeUIsR0FBRztJQUM5QixNQUFPekIsSUFBSztRQUNSLElBQUlxMEMsVUFBVXZyQyxZQUFZbUIsR0FBRyxDQUFDaks7UUFDOUIsSUFBSXEwQyxXQUFXQSxRQUFRenlDLE1BQU0sSUFBSStsQixPQUM3QixPQUFPMHNCO1FBQ1gsSUFBSXp5QyxTQUFTNUIsSUFBSUUsVUFBVTtRQUMzQkYsTUFBTTRCLFVBQVUrbEIsTUFBTTNuQixHQUFHLEdBQUc0QixTQUFTSCxNQUFNLElBQUl6QixJQUFJOEosV0FBVyxHQUFHOUosSUFBSXdCLGVBQWU7SUFDeEY7SUFDQSxPQUFPO0FBQ1g7QUFDQSwrREFBK0Q7QUFDL0QsU0FBU3d4Qyx5QkFBeUI1cEMsSUFBSTtJQUNsQyxJQUFJbWpCLFFBQVE7SUFDWixpRUFBaUU7SUFDakUsb0VBQW9FO0lBQ3BFLGdFQUFnRTtJQUNoRSxvRUFBb0U7SUFDcEUsU0FBUztJQUNULFNBQVNvUCxLQUFLaHBCLEtBQUs7UUFDZkEsTUFBTXNpQixjQUFjO1FBQ3BCdGlCLE1BQU0yaEMsd0JBQXdCO1FBQzlCL25CLFFBQVE1WixNQUFNNGhDLGVBQWUsRUFBRSxDQUFDLEVBQUU7SUFDdEM7SUFDQW5yQyxLQUFLNmMsVUFBVSxDQUFDeU8sZ0JBQWdCLENBQUMsZUFBZWlILE1BQU07SUFDdER2eUIsS0FBS3BKLEdBQUcsQ0FBQ0YsYUFBYSxDQUFDMDBDLFdBQVcsQ0FBQztJQUNuQ3ByQyxLQUFLNmMsVUFBVSxDQUFDc1AsbUJBQW1CLENBQUMsZUFBZW9HLE1BQU07SUFDekQsSUFBSSxDQUFDcFAsT0FDRCxPQUFPO0lBQ1gsSUFBSTdyQixhQUFhNnJCLE1BQU15RCxjQUFjLEVBQUV2cUIsZUFBZThtQixNQUFNTSxXQUFXO0lBQ3ZFLElBQUlubkIsWUFBWTZtQixNQUFNa29CLFlBQVksRUFBRTl1QyxjQUFjNG1CLE1BQU1tb0IsU0FBUztJQUNqRSxJQUFJQyxZQUFZdnJDLEtBQUtpTixPQUFPLENBQUM1RixRQUFRLENBQUNySCxLQUFLeUosS0FBSyxDQUFDcFMsU0FBUyxDQUFDa21CLElBQUksQ0FBQ29DLE1BQU07SUFDdEUsa0VBQWtFO0lBQ2xFLDhEQUE4RDtJQUM5RCxrQkFBa0I7SUFDbEIsSUFBSTluQixxQkFBcUIwekMsVUFBVTEwQyxJQUFJLEVBQUUwMEMsVUFBVXRzQyxNQUFNLEVBQUUzQyxXQUFXQyxjQUNsRSxDQUFDakYsWUFBWStFLGNBQWNDLFdBQVdDLFlBQVksR0FBRztRQUFDRDtRQUFXQztRQUFhakY7UUFBWStFO0tBQWE7SUFDM0csT0FBTztRQUFFL0U7UUFBWStFO1FBQWNDO1FBQVdDO0lBQVk7QUFDOUQ7QUFFQSwrREFBK0Q7QUFDL0QsRUFBRTtBQUNGLDREQUE0RDtBQUM1RCxtREFBbUQ7QUFDbkQsNkRBQTZEO0FBQzdELEVBQUU7QUFDRiwrREFBK0Q7QUFDL0Qsc0VBQXNFO0FBQ3RFLG1FQUFtRTtBQUNuRSxxRUFBcUU7QUFDckUsb0VBQW9FO0FBQ3BFLG9FQUFvRTtBQUNwRSw0Q0FBNEM7QUFDNUM7Ozs7O0FBS0EsR0FDQSxNQUFNaXZDO0lBQ0Y7O0lBRUEsR0FDQSxJQUFJL2hDLFFBQVE7UUFBRSxPQUFPLElBQUksQ0FBQ29ELFNBQVMsQ0FBQ3BELEtBQUs7SUFBRTtJQUMzQzs7Ozs7O0lBTUEsR0FDQSxJQUFJZ1YsV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFDNVIsU0FBUyxDQUFDNFIsUUFBUTtJQUFFO0lBQ2pEOzs7Ozs7O0lBT0EsR0FDQSxJQUFJeWQsZ0JBQWdCO1FBQUUsT0FBTyxJQUFJLENBQUNydkIsU0FBUyxDQUFDcXZCLGFBQWE7SUFBRTtJQUMzRDs7O0lBR0EsR0FDQSxJQUFJZCxTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUN2dUIsU0FBUyxDQUFDdXVCLE1BQU07SUFBRTtJQUM3Qzs7OztJQUlBLEdBQ0EsSUFBSWhlLFlBQVk7UUFBRSxPQUFPLElBQUksQ0FBQ0QsVUFBVSxDQUFDQyxTQUFTLEdBQUc7SUFBRztJQUN4RDs7Ozs7SUFLQSxHQUNBLElBQUlxdUIscUJBQXFCO1FBQUUsT0FBTyxJQUFJLENBQUN0dUIsVUFBVSxDQUFDQyxTQUFTLElBQUk7SUFBRztJQUNsRTs7SUFFQSxHQUNBLElBQUk3bUIsT0FBTztRQUFFLE9BQU8sSUFBSSxDQUFDbTFDLEtBQUs7SUFBRTtJQUNoQzs7SUFFQSxHQUNBLElBQUl2eUMsTUFBTTtRQUFFLE9BQU8sSUFBSSxDQUFDdkMsR0FBRyxDQUFDRixhQUFhLENBQUM0RCxXQUFXLElBQUlDO0lBQVE7SUFDakU7Ozs7SUFJQSxHQUNBNkIsWUFBWXV2QyxTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ3JCLElBQUksQ0FBQzVmLE9BQU8sR0FBRyxFQUFFO1FBQ2pCLElBQUksQ0FBQzZmLFNBQVMsR0FBRyxJQUFJQztRQUNyQixJQUFJLENBQUNDLFdBQVcsR0FBRyxDQUFDO1FBQ3BCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLENBQUM7UUFDckIsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQjs7UUFFQSxHQUNBLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEVBQUUsd0JBQXdCO1FBQzdDOztRQUVBLEdBQ0EsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxDQUFDO1FBQ3pCOztRQUVBLEdBQ0EsSUFBSSxDQUFDQyxlQUFlLEdBQUcsRUFBRTtRQUN6QixJQUFJLENBQUN2dkIsVUFBVSxHQUFHbmYsU0FBUzBLLGFBQWEsQ0FBQztRQUN6QyxJQUFJLENBQUN1WixTQUFTLEdBQUdqa0IsU0FBUzBLLGFBQWEsQ0FBQztRQUN4QyxJQUFJLENBQUN1WixTQUFTLENBQUMwcUIsUUFBUSxHQUFHLENBQUM7UUFDM0IsSUFBSSxDQUFDMXFCLFNBQVMsQ0FBQzVaLFNBQVMsR0FBRztRQUMzQixJQUFJLENBQUM0WixTQUFTLENBQUNyVixXQUFXLENBQUMsSUFBSSxDQUFDdVEsVUFBVTtRQUMxQyxJQUFJLENBQUN5dkIsV0FBVyxHQUFHNXVDLFNBQVMwSyxhQUFhLENBQUM7UUFDMUMsSUFBSSxDQUFDa2tDLFdBQVcsQ0FBQ3ZrQyxTQUFTLEdBQUc7UUFDN0IsSUFBSSxDQUFDdWtDLFdBQVcsQ0FBQ3JrQyxZQUFZLENBQUMsYUFBYTtRQUMzQyxJQUFJLENBQUNyUixHQUFHLEdBQUc4RyxTQUFTMEssYUFBYSxDQUFDO1FBQ2xDLElBQUksQ0FBQ3hSLEdBQUcsQ0FBQzBWLFdBQVcsQ0FBQyxJQUFJLENBQUNnZ0MsV0FBVztRQUNyQyxJQUFJLENBQUMxMUMsR0FBRyxDQUFDMFYsV0FBVyxDQUFDLElBQUksQ0FBQ3FWLFNBQVM7UUFDbkMsSUFBSWdxQixPQUFPbnpDLE1BQU0sRUFDYm16QyxPQUFPbnpDLE1BQU0sQ0FBQzhULFdBQVcsQ0FBQyxJQUFJLENBQUMxVixHQUFHO1FBQ3RDLElBQUksRUFBRW80QixRQUFRLEVBQUUsR0FBRzJjO1FBQ25CLElBQUksQ0FBQ1ksb0JBQW9CLEdBQUdaLE9BQU9ZLG9CQUFvQixJQUNsRHZkLFlBQWEsRUFBQ3dkLE1BQVFBLElBQUlsdUIsT0FBTyxDQUFDakQsQ0FBQUEsS0FBTTJULFNBQVMzVCxJQUFJLElBQUksRUFBQyxLQUMxRCxFQUFDbXhCLE1BQVEsSUFBSSxDQUFDcnpCLE1BQU0sQ0FBQ3F6QixJQUFHO1FBQzdCLElBQUksQ0FBQ3hkLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVEsQ0FBQzdELElBQUksQ0FBQyxJQUFJO1FBQ3ZDLElBQUksQ0FBQ3VnQixLQUFLLEdBQUlDLE9BQU9wMUMsSUFBSSxJQUFJcUksUUFBUStzQyxPQUFPbnpDLE1BQU0sS0FBS2tGO1FBQ3ZELElBQUksQ0FBQ21QLFNBQVMsR0FBRyxJQUFJcXVCLFVBQVV5USxPQUFPbGlDLEtBQUssSUFBSWhVLDBEQUFXQSxDQUFDdVQsTUFBTSxDQUFDMmlDO1FBQ2xFLElBQUlBLE9BQU9jLFFBQVEsSUFBSWQsT0FBT2MsUUFBUSxDQUFDQyxFQUFFLENBQUNsMUIsaUJBQ3RDLElBQUksQ0FBQzNLLFNBQVMsQ0FBQ2t2QixZQUFZLEdBQUc0UCxPQUFPYyxRQUFRLENBQUNyaEMsS0FBSyxDQUFDbU0sSUFBSSxDQUFDLElBQUksQ0FBQzFLLFNBQVMsQ0FBQ3BELEtBQUs7UUFDakYsSUFBSSxDQUFDc2lCLE9BQU8sR0FBRyxJQUFJLENBQUN0aUIsS0FBSyxDQUFDb08sS0FBSyxDQUFDTSxZQUFZZCxHQUFHLENBQUN2TCxDQUFBQSxPQUFRLElBQUltTixlQUFlbk47UUFDM0UsS0FBSyxJQUFJK00sVUFBVSxJQUFJLENBQUNrVCxPQUFPLENBQzNCbFQsT0FBT00sTUFBTSxDQUFDLElBQUk7UUFDdEIsSUFBSSxDQUFDK0UsUUFBUSxHQUFHLElBQUltcEIsWUFBWSxJQUFJO1FBQ3BDLElBQUksQ0FBQ2xxQixVQUFVLEdBQUcsSUFBSXlNLFdBQVcsSUFBSTtRQUNyQyxJQUFJLENBQUN6TSxVQUFVLENBQUMyTyxjQUFjLENBQUMsSUFBSSxDQUFDQyxPQUFPO1FBQzNDLElBQUksQ0FBQzllLE9BQU8sR0FBRyxJQUFJOE8sUUFBUSxJQUFJO1FBQy9CLElBQUksQ0FBQzR3QixXQUFXO1FBQ2hCLElBQUksQ0FBQzdoQyxXQUFXO1FBQ2hCLElBQUksQ0FBQ29oQyxXQUFXLEdBQUcsRUFBRSxvQkFBb0I7UUFDekMsSUFBSSxDQUFDMUMsY0FBYztJQUN2QjtJQUNBeGEsU0FBUyxHQUFHUyxLQUFLLEVBQUU7UUFDZixJQUFJK2MsTUFBTS9jLE1BQU05M0IsTUFBTSxJQUFJLEtBQUs4M0IsS0FBSyxDQUFDLEVBQUUsWUFBWS81QiwwREFBV0EsR0FBRys1QixRQUMzREEsTUFBTTkzQixNQUFNLElBQUksS0FBS2dSLE1BQU04ZSxPQUFPLENBQUNnSSxLQUFLLENBQUMsRUFBRSxJQUFJQSxLQUFLLENBQUMsRUFBRSxHQUNuRDtZQUFDLElBQUksQ0FBQ2htQixLQUFLLENBQUMwUCxNQUFNLElBQUlzVztTQUFPO1FBQ3ZDLElBQUksQ0FBQzhjLG9CQUFvQixDQUFDQyxLQUFLLElBQUk7SUFDdkM7SUFDQTs7Ozs7OztJQU9BLEdBQ0FyekIsT0FBT2dDLFlBQVksRUFBRTtRQUNqQixJQUFJLElBQUksQ0FBQyt3QixXQUFXLElBQUksRUFBRSxvQkFBb0IsS0FDMUMsTUFBTSxJQUFJajdCLE1BQU07UUFDcEIsSUFBSTI3QixVQUFVLE9BQU9DLGVBQWUsT0FBTzF6QjtRQUMzQyxJQUFJMVAsUUFBUSxJQUFJLENBQUNBLEtBQUs7UUFDdEIsS0FBSyxJQUFJNFIsTUFBTUYsYUFBYztZQUN6QixJQUFJRSxHQUFHRCxVQUFVLElBQUkzUixPQUNqQixNQUFNLElBQUlwSixXQUFXO1lBQ3pCb0osUUFBUTRSLEdBQUc1UixLQUFLO1FBQ3BCO1FBQ0EsSUFBSSxJQUFJLENBQUN3aUMsU0FBUyxFQUFFO1lBQ2hCLElBQUksQ0FBQ3AvQixTQUFTLENBQUNwRCxLQUFLLEdBQUdBO1lBQ3ZCO1FBQ0o7UUFDQSxJQUFJeE0sUUFBUSxJQUFJLENBQUNvdUIsUUFBUSxFQUFFeWhCLFlBQVksR0FBR0MsZ0JBQWdCO1FBQzFELElBQUk1eEIsYUFBYWhQLElBQUksQ0FBQ2tQLENBQUFBLEtBQU1BLEdBQUcyeEIsVUFBVSxDQUFDdFosaUJBQWlCO1lBQ3ZELElBQUksQ0FBQ3ZXLFVBQVUsQ0FBQ2lPLGVBQWUsR0FBR251QjtZQUNsQywyRUFBMkU7WUFDM0U2dkMsWUFBWSxFQUFFLG9CQUFvQjtRQUN0QyxPQUNLLElBQUk3dkMsU0FBUyxJQUFJLENBQUNrZ0IsVUFBVSxDQUFDaU8sZUFBZSxFQUFFO1lBQy9DLElBQUksQ0FBQ2pPLFVBQVUsQ0FBQ2lPLGVBQWUsR0FBR251QjtZQUNsQyxnRUFBZ0U7WUFDaEUsNEJBQTRCO1lBQzVCOHZDLGdCQUFnQnBaLHVCQUF1QmxxQixPQUFPeE07WUFDOUMsSUFBSSxDQUFDOHZDLGVBQ0RELFlBQVksRUFBRSxvQkFBb0I7UUFDMUM7UUFDQSxnRUFBZ0U7UUFDaEUseUNBQXlDO1FBQ3pDLElBQUlHLGFBQWEsSUFBSSxDQUFDL3VCLFFBQVEsQ0FBQ3dwQixpQkFBaUIsRUFBRTVCLFlBQVk7UUFDOUQsSUFBSW1ILFlBQVk7WUFDWixJQUFJLENBQUMvdUIsUUFBUSxDQUFDNnJCLHNCQUFzQjtZQUNwQ2pFLFlBQVksSUFBSSxDQUFDNW5CLFFBQVEsQ0FBQ29zQixVQUFVO1lBQ3BDLDJEQUEyRDtZQUMzRCwrQkFBK0I7WUFDL0IsSUFBSXhFLGFBQWEsQ0FBQyxJQUFJLENBQUNyOEIsS0FBSyxDQUFDelMsR0FBRyxDQUFDd0YsRUFBRSxDQUFDaU4sTUFBTXpTLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQ3lTLEtBQUssQ0FBQ3BTLFNBQVMsQ0FBQ21GLEVBQUUsQ0FBQ2lOLE1BQU1wUyxTQUFTLEdBQ3RGeXVDLFlBQVk7UUFDcEIsT0FDSztZQUNELElBQUksQ0FBQzVuQixRQUFRLENBQUNSLEtBQUs7UUFDdkI7UUFDQSw2Q0FBNkM7UUFDN0MsSUFBSWpVLE1BQU1vTyxLQUFLLENBQUNwaUIsMERBQVdBLENBQUN5M0MsT0FBTyxLQUFLLElBQUksQ0FBQ3pqQyxLQUFLLENBQUNvTyxLQUFLLENBQUNwaUIsMERBQVdBLENBQUN5M0MsT0FBTyxHQUN4RSxPQUFPLElBQUksQ0FBQ0MsUUFBUSxDQUFDMWpDO1FBQ3pCMFAsU0FBUytCLFdBQVdsUyxNQUFNLENBQUMsSUFBSSxFQUFFUyxPQUFPMFI7UUFDeENoQyxPQUFPeFosS0FBSyxJQUFJbXRDO1FBQ2hCLElBQUkvUSxlQUFlLElBQUksQ0FBQ2x2QixTQUFTLENBQUNrdkIsWUFBWTtRQUM5QyxJQUFJO1lBQ0EsSUFBSSxDQUFDbVEsV0FBVyxHQUFHLEVBQUUsd0JBQXdCO1lBQzdDLEtBQUssSUFBSTd3QixNQUFNRixhQUFjO2dCQUN6QixJQUFJNGdCLGNBQ0FBLGVBQWVBLGFBQWExa0IsR0FBRyxDQUFDZ0UsR0FBRy9ELE9BQU87Z0JBQzlDLElBQUkrRCxHQUFHN0QsY0FBYyxFQUFFO29CQUNuQixJQUFJLEVBQUUrRixJQUFJLEVBQUUsR0FBR2xDLEdBQUc1UixLQUFLLENBQUNwUyxTQUFTO29CQUNqQzBrQyxlQUFlLElBQUk1a0IsYUFBYW9HLEtBQUsvVCxLQUFLLEdBQUcrVCxPQUFPcm9CLDhEQUFlQSxDQUFDaWIsTUFBTSxDQUFDb04sS0FBS3hILElBQUksRUFBRXdILEtBQUt4SCxJQUFJLEdBQUd3SCxLQUFLb0MsTUFBTSxHQUFHLENBQUMsSUFBSTtnQkFDekg7Z0JBQ0EsS0FBSyxJQUFJdkcsS0FBS2lDLEdBQUd1WSxPQUFPLENBQ3BCLElBQUl4YSxFQUFFc3pCLEVBQUUsQ0FBQ2wxQixpQkFDTHVrQixlQUFlM2lCLEVBQUVoTyxLQUFLLENBQUNtTSxJQUFJLENBQUMsSUFBSSxDQUFDOU4sS0FBSztZQUNsRDtZQUNBLElBQUksQ0FBQ29ELFNBQVMsQ0FBQ3NNLE1BQU0sQ0FBQ0EsUUFBUTRpQjtZQUM5QixJQUFJLENBQUNpUSxTQUFTLEdBQUdvQixZQUFZajBCLE1BQU0sQ0FBQyxJQUFJLENBQUM2eUIsU0FBUyxFQUFFN3lCLE9BQU83QixPQUFPO1lBQ2xFLElBQUksQ0FBQzZCLE9BQU8zUCxLQUFLLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDNmpDLGFBQWEsQ0FBQ2wwQjtnQkFDbkIsSUFBSSxDQUFDZ0UsVUFBVSxDQUFDaEUsTUFBTSxDQUFDQTtZQUMzQjtZQUNBeXpCLFVBQVUsSUFBSSxDQUFDMy9CLE9BQU8sQ0FBQ2tNLE1BQU0sQ0FBQ0E7WUFDOUIsSUFBSSxJQUFJLENBQUMxUCxLQUFLLENBQUNvTyxLQUFLLENBQUN1QyxnQkFBZ0IsSUFBSSxDQUFDa3pCLFlBQVksRUFDbEQsSUFBSSxDQUFDWCxXQUFXO1lBQ3BCRSxlQUFlLElBQUksQ0FBQy9oQyxXQUFXO1lBQy9CLElBQUksQ0FBQ3lpQyxpQkFBaUIsQ0FBQ3B5QjtZQUN2QixJQUFJLENBQUNsTyxPQUFPLENBQUNrUyxlQUFlLENBQUN5dEIsU0FBU3p4QixhQUFhaFAsSUFBSSxDQUFDa1AsQ0FBQUEsS0FBTUEsR0FBR215QixXQUFXLENBQUM7UUFDakYsU0FDUTtZQUNKLElBQUksQ0FBQ3RCLFdBQVcsR0FBRyxFQUFFLG9CQUFvQjtRQUM3QztRQUNBLElBQUkveUIsT0FBT2lDLFVBQVUsQ0FBQ3ZELEtBQUssQ0FBQytvQixVQUFVem5CLE9BQU8xUCxLQUFLLENBQUNvTyxLQUFLLENBQUMrb0IsUUFDckQsSUFBSSxDQUFDL3pCLFNBQVMsQ0FBQ21SLGtCQUFrQixHQUFHO1FBQ3hDLElBQUk0dUIsV0FBV0MsZ0JBQWdCOVEsZ0JBQWdCLElBQUksQ0FBQ2x2QixTQUFTLENBQUNzdkIsc0JBQXNCLElBQUksSUFBSSxDQUFDdHZCLFNBQVMsQ0FBQ21SLGtCQUFrQixFQUNySCxJQUFJLENBQUN3ckIsY0FBYztRQUN2QixJQUFJLENBQUNyd0IsT0FBTzNQLEtBQUssRUFDYixLQUFLLElBQUlpa0MsWUFBWSxJQUFJLENBQUNoa0MsS0FBSyxDQUFDb08sS0FBSyxDQUFDakIsZ0JBQWlCO1lBQ25ELElBQUk7Z0JBQ0E2MkIsU0FBU3QwQjtZQUNiLEVBQ0EsT0FBT0MsR0FBRztnQkFDTjFCLGFBQWEsSUFBSSxDQUFDak8sS0FBSyxFQUFFMlAsR0FBRztZQUNoQztRQUNKO1FBQ0osSUFBSTJ6QixpQkFBaUJqSCxXQUNqQnZSLFFBQVFDLE9BQU8sR0FBR0MsSUFBSSxDQUFDO1lBQ25CLElBQUlzWSxpQkFBaUIsSUFBSSxDQUFDdGpDLEtBQUssSUFBSXNqQyxjQUFjM3hCLFVBQVUsRUFDdkQsSUFBSSxDQUFDNFQsUUFBUSxDQUFDK2Q7WUFDbEIsSUFBSWpILFdBQVc7Z0JBQ1gsSUFBSSxDQUFDRCxlQUFlLElBQUksRUFBRUMsY0FBY21ILFdBQVd2dEIsS0FBSyxFQUNwRDVoQixZQUFZLElBQUksQ0FBQytlLFVBQVUsRUFBRW93QixXQUFXL3VDLEdBQUcsRUFBRSt1QyxXQUFXOXVDLE9BQU87WUFDdkU7UUFDSjtJQUNSO0lBQ0E7Ozs7OztJQU1BLEdBQ0FndkMsU0FBU08sUUFBUSxFQUFFO1FBQ2YsSUFBSSxJQUFJLENBQUN4QixXQUFXLElBQUksRUFBRSxvQkFBb0IsS0FDMUMsTUFBTSxJQUFJajdCLE1BQU07UUFDcEIsSUFBSSxJQUFJLENBQUNnN0IsU0FBUyxFQUFFO1lBQ2hCLElBQUksQ0FBQ3AvQixTQUFTLENBQUNwRCxLQUFLLEdBQUdpa0M7WUFDdkI7UUFDSjtRQUNBLElBQUksQ0FBQ3hCLFdBQVcsR0FBRyxFQUFFLHdCQUF3QjtRQUM3QyxJQUFJeUIsV0FBVyxJQUFJLENBQUN0aUIsUUFBUTtRQUM1QixJQUFJO1lBQ0EsS0FBSyxJQUFJeFMsVUFBVSxJQUFJLENBQUNrVCxPQUFPLENBQzNCbFQsT0FBT2xXLE9BQU8sQ0FBQyxJQUFJO1lBQ3ZCLElBQUksQ0FBQ2tLLFNBQVMsR0FBRyxJQUFJcXVCLFVBQVV3UztZQUMvQixJQUFJLENBQUMzaEIsT0FBTyxHQUFHMmhCLFNBQVM3MUIsS0FBSyxDQUFDTSxZQUFZZCxHQUFHLENBQUN2TCxDQUFBQSxPQUFRLElBQUltTixlQUFlbk47WUFDekUsSUFBSSxDQUFDOC9CLFNBQVMsQ0FBQ2x1QixLQUFLO1lBQ3BCLEtBQUssSUFBSTdFLFVBQVUsSUFBSSxDQUFDa1QsT0FBTyxDQUMzQmxULE9BQU9NLE1BQU0sQ0FBQyxJQUFJO1lBQ3RCLElBQUksQ0FBQ2xNLE9BQU8sQ0FBQ3RLLE9BQU87WUFDcEIsSUFBSSxDQUFDc0ssT0FBTyxHQUFHLElBQUk4TyxRQUFRLElBQUk7WUFDL0IsSUFBSSxDQUFDb0IsVUFBVSxDQUFDMk8sY0FBYyxDQUFDLElBQUksQ0FBQ0MsT0FBTztZQUMzQyxJQUFJLENBQUM0Z0IsV0FBVztZQUNoQixJQUFJLENBQUM3aEMsV0FBVztZQUNoQixJQUFJLENBQUNraEMsU0FBUyxHQUFHLEVBQUU7UUFDdkIsU0FDUTtZQUNKLElBQUksQ0FBQ0UsV0FBVyxHQUFHLEVBQUUsb0JBQW9CO1FBQzdDO1FBQ0EsSUFBSXlCLFVBQ0EsSUFBSSxDQUFDMXdDLEtBQUs7UUFDZCxJQUFJLENBQUN1c0MsY0FBYztJQUN2QjtJQUNBNkQsY0FBY2wwQixNQUFNLEVBQUU7UUFDbEIsSUFBSXkwQixZQUFZejBCLE9BQU9pQyxVQUFVLENBQUN2RCxLQUFLLENBQUNNLGFBQWEwMUIsUUFBUTEwQixPQUFPMVAsS0FBSyxDQUFDb08sS0FBSyxDQUFDTTtRQUNoRixJQUFJeTFCLGFBQWFDLE9BQU87WUFDcEIsSUFBSUMsYUFBYSxFQUFFO1lBQ25CLEtBQUssSUFBSWhpQyxRQUFRK2hDLE1BQU87Z0JBQ3BCLElBQUkxcUIsUUFBUXlxQixVQUFVbHJDLE9BQU8sQ0FBQ29KO2dCQUM5QixJQUFJcVgsUUFBUSxHQUFHO29CQUNYMnFCLFdBQVczd0MsSUFBSSxDQUFDLElBQUk4YixlQUFlbk47Z0JBQ3ZDLE9BQ0s7b0JBQ0QsSUFBSStNLFNBQVMsSUFBSSxDQUFDa1QsT0FBTyxDQUFDNUksTUFBTTtvQkFDaEN0SyxPQUFPSyxVQUFVLEdBQUdDO29CQUNwQjIwQixXQUFXM3dDLElBQUksQ0FBQzBiO2dCQUNwQjtZQUNKO1lBQ0EsS0FBSyxJQUFJQSxVQUFVLElBQUksQ0FBQ2tULE9BQU8sQ0FDM0IsSUFBSWxULE9BQU9LLFVBQVUsSUFBSUMsUUFDckJOLE9BQU9sVyxPQUFPLENBQUMsSUFBSTtZQUMzQixJQUFJLENBQUNvcEIsT0FBTyxHQUFHK2hCO1lBQ2YsSUFBSSxDQUFDbEMsU0FBUyxDQUFDbHVCLEtBQUs7UUFDeEIsT0FDSztZQUNELEtBQUssSUFBSW5MLEtBQUssSUFBSSxDQUFDd1osT0FBTyxDQUN0QnhaLEVBQUUyRyxVQUFVLEdBQUdDO1FBQ3ZCO1FBQ0EsSUFBSyxJQUFJN2IsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ3l1QixPQUFPLENBQUNwMEIsTUFBTSxFQUFFMkYsSUFDckMsSUFBSSxDQUFDeXVCLE9BQU8sQ0FBQ3p1QixFQUFFLENBQUM2YixNQUFNLENBQUMsSUFBSTtRQUMvQixJQUFJeTBCLGFBQWFDLE9BQ2IsSUFBSSxDQUFDMXdCLFVBQVUsQ0FBQzJPLGNBQWMsQ0FBQyxJQUFJLENBQUNDLE9BQU87SUFDbkQ7SUFDQTs7SUFFQSxHQUNBL0osUUFBUW9PLFFBQVEsSUFBSSxFQUFFO1FBQ2xCLElBQUksSUFBSSxDQUFDNmIsU0FBUyxFQUNkO1FBQ0osSUFBSSxJQUFJLENBQUNFLGdCQUFnQixHQUFHLENBQUMsR0FDekIsSUFBSSxDQUFDaHpDLEdBQUcsQ0FBQyt3QyxvQkFBb0IsQ0FBQyxJQUFJLENBQUNpQyxnQkFBZ0I7UUFDdkQsSUFBSSxJQUFJLENBQUNqdUIsUUFBUSxDQUFDd3BCLGlCQUFpQixFQUFFO1lBQ2pDLElBQUksQ0FBQ3lFLGdCQUFnQixHQUFHLENBQUM7WUFDekIsSUFBSSxDQUFDM0MsY0FBYztZQUNuQjtRQUNKO1FBQ0EsSUFBSSxDQUFDMkMsZ0JBQWdCLEdBQUcsR0FBRyx1RUFBdUU7UUFDbEcsSUFBSS9iLE9BQ0EsSUFBSSxDQUFDbFMsUUFBUSxDQUFDNk8sVUFBVTtRQUM1QixJQUFJK0IsVUFBVTtRQUNkLElBQUlpZixPQUFPLElBQUksQ0FBQ3BzQixTQUFTLEVBQUU1bEIsWUFBWWd5QyxLQUFLaHlDLFNBQVMsR0FBRyxJQUFJLENBQUNyQyxNQUFNO1FBQ25FLElBQUksRUFBRWlpQyxlQUFlLEVBQUVDLGtCQUFrQixFQUFFLEdBQUcsSUFBSSxDQUFDL3VCLFNBQVM7UUFDNUQsSUFBSS9TLEtBQUtDLEdBQUcsQ0FBQ2dDLFlBQVksSUFBSSxDQUFDOFEsU0FBUyxDQUFDOVEsU0FBUyxJQUFJLEdBQ2pENi9CLHFCQUFxQixDQUFDO1FBQzFCLElBQUksQ0FBQy91QixTQUFTLENBQUMrdUIsa0JBQWtCLEdBQUcsQ0FBQztRQUNyQyxJQUFJO1lBQ0EsSUFBSyxJQUFJdCtCLElBQUksSUFBSUEsSUFBSztnQkFDbEIsSUFBSXMrQixxQkFBcUIsR0FBRztvQkFDeEIsSUFBSXo4QixtQkFBbUI0dUMsT0FBTzt3QkFDMUJwUyxrQkFBa0IsQ0FBQzt3QkFDbkJDLHFCQUFxQixJQUFJLENBQUMvdUIsU0FBUyxDQUFDeXZCLFNBQVMsQ0FBQzNpQyxNQUFNO29CQUN4RCxPQUNLO3dCQUNELElBQUl1VCxRQUFRLElBQUksQ0FBQ0wsU0FBUyxDQUFDeXdCLGNBQWMsQ0FBQ3ZoQzt3QkFDMUM0L0Isa0JBQWtCenVCLE1BQU0xUCxJQUFJO3dCQUM1Qm8rQixxQkFBcUIxdUIsTUFBTWxVLEdBQUc7b0JBQ2xDO2dCQUNKO2dCQUNBLElBQUksQ0FBQ2t6QyxXQUFXLEdBQUcsRUFBRSx5QkFBeUI7Z0JBQzlDLElBQUluaEMsVUFBVSxJQUFJLENBQUM4QixTQUFTLENBQUNtVixPQUFPLENBQUMsSUFBSTtnQkFDekMsSUFBSSxDQUFDalgsV0FBVyxDQUFDLElBQUksQ0FBQ3FoQyxlQUFlLENBQUN6MEMsTUFBTSxJQUFJLElBQUksQ0FBQ2tWLFNBQVMsQ0FBQ2t2QixZQUFZLElBQUksTUFDM0U7Z0JBQ0osSUFBSXorQixJQUFJLEdBQUc7b0JBQ1AwYSxRQUFRZzJCLElBQUksQ0FBQyxJQUFJLENBQUM1QixlQUFlLENBQUN6MEMsTUFBTSxHQUNsQyw2Q0FDQTtvQkFDTjtnQkFDSjtnQkFDQSxJQUFJczJDLFlBQVksRUFBRTtnQkFDbEIsMEVBQTBFO2dCQUMxRSxJQUFJLENBQUVsakMsQ0FBQUEsVUFBVSxFQUFFLHVCQUF1QixHQUF6QixHQUNaLENBQUMsSUFBSSxDQUFDcWhDLGVBQWUsRUFBRTZCLFVBQVUsR0FBRztvQkFBQ0E7b0JBQVcsSUFBSSxDQUFDN0IsZUFBZTtpQkFBQztnQkFDekUsSUFBSXRVLFdBQVdtVyxVQUFVNTJCLEdBQUcsQ0FBQzhDLENBQUFBO29CQUN6QixJQUFJO3dCQUNBLE9BQU9BLEVBQUVvWSxJQUFJLENBQUMsSUFBSTtvQkFDdEIsRUFDQSxPQUFPblosR0FBRzt3QkFDTjFCLGFBQWEsSUFBSSxDQUFDak8sS0FBSyxFQUFFMlA7d0JBQ3pCLE9BQU84MEI7b0JBQ1g7Z0JBQ0o7Z0JBQ0EsSUFBSS8wQixTQUFTK0IsV0FBV2xTLE1BQU0sQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDUyxLQUFLLEVBQUUsRUFBRSxHQUFHbWpDLFVBQVU7Z0JBQ2hFenpCLE9BQU94WixLQUFLLElBQUlvTDtnQkFDaEIsSUFBSSxDQUFDK2pCLFNBQ0RBLFVBQVUzVjtxQkFFVjJWLFFBQVFudkIsS0FBSyxJQUFJb0w7Z0JBQ3JCLElBQUksQ0FBQ21oQyxXQUFXLEdBQUcsRUFBRSx3QkFBd0I7Z0JBQzdDLElBQUksQ0FBQy95QixPQUFPM1AsS0FBSyxFQUFFO29CQUNmLElBQUksQ0FBQzZqQyxhQUFhLENBQUNsMEI7b0JBQ25CLElBQUksQ0FBQ2dFLFVBQVUsQ0FBQ2hFLE1BQU0sQ0FBQ0E7b0JBQ3ZCLElBQUksQ0FBQ3JPLFdBQVc7b0JBQ2hCOGhDLFVBQVUsSUFBSSxDQUFDMy9CLE9BQU8sQ0FBQ2tNLE1BQU0sQ0FBQ0E7Z0JBQ2xDO2dCQUNBLElBQUssSUFBSTdiLElBQUksR0FBR0EsSUFBSTJ3QyxVQUFVdDJDLE1BQU0sRUFBRTJGLElBQ2xDLElBQUl3NkIsUUFBUSxDQUFDeDZCLEVBQUUsSUFBSTR3QyxZQUFZO29CQUMzQixJQUFJO3dCQUNBLElBQUkvekIsSUFBSTh6QixTQUFTLENBQUMzd0MsRUFBRTt3QkFDcEIsSUFBSTZjLEVBQUVnMEIsS0FBSyxFQUNQaDBCLEVBQUVnMEIsS0FBSyxDQUFDclcsUUFBUSxDQUFDeDZCLEVBQUUsRUFBRSxJQUFJO29CQUNqQyxFQUNBLE9BQU84YixHQUFHO3dCQUNOMUIsYUFBYSxJQUFJLENBQUNqTyxLQUFLLEVBQUUyUDtvQkFDN0I7Z0JBQ0o7Z0JBQ0osSUFBSXd6QixTQUNBLElBQUksQ0FBQzMvQixPQUFPLENBQUNrUyxlQUFlLENBQUM7Z0JBQ2pDLElBQUksQ0FBQ2hHLE9BQU9zQyxlQUFlLElBQUksSUFBSSxDQUFDMndCLGVBQWUsQ0FBQ3owQyxNQUFNLElBQUksR0FBRztvQkFDN0QsSUFBSSxJQUFJLENBQUNrVixTQUFTLENBQUMydUIsWUFBWSxFQUFFO3dCQUM3QixJQUFJLElBQUksQ0FBQzN1QixTQUFTLENBQUNrdkIsWUFBWSxFQUFFOzRCQUM3QixJQUFJLENBQUM5dUIsT0FBTyxDQUFDdUssY0FBYyxDQUFDLElBQUksQ0FBQzNLLFNBQVMsQ0FBQ2t2QixZQUFZOzRCQUN2RCxJQUFJLENBQUNsdkIsU0FBUyxDQUFDa3ZCLFlBQVksR0FBRzs0QkFDOUJILHFCQUFxQixDQUFDOzRCQUN0Qjt3QkFDSixPQUNLOzRCQUNELElBQUl3UyxrQkFBa0J6UyxrQkFBa0IsSUFBSSxJQUFJLENBQUM5dUIsU0FBUyxDQUFDeXZCLFNBQVMsQ0FBQzNpQyxNQUFNLEdBQ3ZFLElBQUksQ0FBQ2tULFNBQVMsQ0FBQ3lWLFdBQVcsQ0FBQ3FaLGlCQUFpQjNpQyxHQUFHOzRCQUNuRCxJQUFJNmhCLE9BQU91ekIsa0JBQWtCeFM7NEJBQzdCLElBQUkvZ0IsT0FBTyxLQUFLQSxPQUFPLENBQUMsR0FBRztnQ0FDdkI5ZSxZQUFZQSxZQUFZOGU7Z0NBQ3hCa3pCLEtBQUtoeUMsU0FBUyxHQUFHQSxZQUFZLElBQUksQ0FBQ3JDLE1BQU07Z0NBQ3hDa2lDLHFCQUFxQixDQUFDO2dDQUN0Qjs0QkFDSjt3QkFDSjtvQkFDSjtvQkFDQTtnQkFDSjtZQUNKO1FBQ0osU0FDUTtZQUNKLElBQUksQ0FBQ3NRLFdBQVcsR0FBRyxFQUFFLG9CQUFvQjtZQUN6QyxJQUFJLENBQUNDLGdCQUFnQixHQUFHLENBQUM7UUFDN0I7UUFDQSxJQUFJcmQsV0FBVyxDQUFDQSxRQUFRdGxCLEtBQUssRUFDekIsS0FBSyxJQUFJaWtDLFlBQVksSUFBSSxDQUFDaGtDLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ2pCLGdCQUNsQzYyQixTQUFTM2U7SUFDckI7SUFDQTs7SUFFQSxHQUNBLElBQUl1ZixlQUFlO1FBQ2YsT0FBT3ROLGNBQWMsTUFDaEIsS0FBSSxDQUFDdDNCLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ2lwQixhQUFhSSxhQUFhRCxXQUFVLElBQUssTUFDM0QsSUFBSSxDQUFDeDNCLEtBQUssQ0FBQ29PLEtBQUssQ0FBQytvQjtJQUN6QjtJQUNBOTFCLGNBQWM7UUFDVixJQUFJZ2hDLGNBQWN3QyxlQUFlLElBQUksRUFBRWgxQixrQkFBa0I7WUFDckR4UixPQUFPLGNBQWUsS0FBSSxDQUFDdWpCLFFBQVEsR0FBRyxpQkFBaUIsR0FBRSxJQUFLLElBQUksQ0FBQ2dqQixZQUFZO1FBQ25GO1FBQ0EsSUFBSXRDLGVBQWU7WUFDZndDLFlBQVk7WUFDWkMsYUFBYTtZQUNiQyxnQkFBZ0I7WUFDaEJDLFdBQVc7WUFDWEMsaUJBQWlCLENBQUMsSUFBSSxDQUFDbGxDLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ3hPLFlBQVksVUFBVTtZQUN6RHZCLE9BQU87WUFDUHZDLE9BQU8sQ0FBQyxFQUFFWSxRQUFRVSxPQUFPLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQzRDLEtBQUssQ0FBQzVDLE9BQU8sQ0FBQyxDQUFDO1lBQ2xEK25DLE1BQU07WUFDTixrQkFBa0I7UUFDdEI7UUFDQSxJQUFJLElBQUksQ0FBQ25sQyxLQUFLLENBQUM0b0IsUUFBUSxFQUNuQjBaLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRztRQUNwQ3VDLGVBQWUsSUFBSSxFQUFFLzBCLG1CQUFtQnd5QjtRQUN4QyxJQUFJaGhDLFVBQVUsSUFBSSxDQUFDbVQsUUFBUSxDQUFDeFQsTUFBTSxDQUFDO1lBQy9CLElBQUlta0MsaUJBQWlCL2pDLFlBQVksSUFBSSxDQUFDK1IsVUFBVSxFQUFFLElBQUksQ0FBQ2t2QixZQUFZLEVBQUVBO1lBQ3JFLElBQUkrQyxnQkFBZ0Joa0MsWUFBWSxJQUFJLENBQUNsVSxHQUFHLEVBQUUsSUFBSSxDQUFDazFDLFdBQVcsRUFBRUE7WUFDNUQsT0FBTytDLGtCQUFrQkM7UUFDN0I7UUFDQSxJQUFJLENBQUNoRCxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsWUFBWSxHQUFHQTtRQUNwQixPQUFPaGhDO0lBQ1g7SUFDQXdpQyxrQkFBa0JmLEdBQUcsRUFBRTtRQUNuQixJQUFJNVQsUUFBUTtRQUNaLEtBQUssSUFBSXZkLE1BQU1teEIsSUFDWCxLQUFLLElBQUkxWSxVQUFVelksR0FBR3VZLE9BQU8sQ0FDekIsSUFBSUUsT0FBTzRZLEVBQUUsQ0FBQ2xCLFdBQVd1RCxRQUFRLEdBQUc7WUFDaEMsSUFBSW5XLE9BQ0EsSUFBSSxDQUFDMFQsV0FBVyxDQUFDcnFCLFdBQVcsR0FBRztZQUNuQzJXLFFBQVE7WUFDUixJQUFJb1csTUFBTSxJQUFJLENBQUMxQyxXQUFXLENBQUNoZ0MsV0FBVyxDQUFDNU8sU0FBUzBLLGFBQWEsQ0FBQztZQUM5RDRtQyxJQUFJL3NCLFdBQVcsR0FBRzZSLE9BQU8xb0IsS0FBSztRQUNsQztJQUNaO0lBQ0F1aEMsY0FBYztRQUNWLElBQUksQ0FBQ1csWUFBWSxHQUFHLElBQUksQ0FBQzdqQyxLQUFLLENBQUNvTyxLQUFLLENBQUN1QztRQUNyQyxJQUFJNjBCLFFBQVEsSUFBSSxDQUFDeGxDLEtBQUssQ0FBQ29PLEtBQUssQ0FBQzJ6QixXQUFXMEQsUUFBUTtRQUNoRGg1QyxrREFBV0EsQ0FBQ2k1QyxLQUFLLENBQUMsSUFBSSxDQUFDNTRDLElBQUksRUFBRSxJQUFJLENBQUMrMkMsWUFBWSxDQUFDeHVCLE1BQU0sQ0FBQ3dpQixhQUFhOE4sT0FBTyxJQUFJSCxRQUFRO1lBQUVBO1FBQU0sSUFBSTV4QztJQUN0RztJQUNBZ3lDLGVBQWU7UUFDWCxJQUFJLElBQUksQ0FBQ25ELFdBQVcsSUFBSSxFQUFFLHdCQUF3QixLQUM5QyxNQUFNLElBQUlqN0IsTUFBTTtRQUNwQixJQUFJLElBQUksQ0FBQ2k3QixXQUFXLElBQUksRUFBRSxvQkFBb0IsT0FBTSxJQUFJLENBQUNDLGdCQUFnQixHQUFHLENBQUMsR0FDekUsSUFBSSxDQUFDbnFCLE9BQU8sQ0FBQztJQUNyQjtJQUNBOzs7Ozs7O0lBT0EsR0FDQXduQixlQUFlOEYsT0FBTyxFQUFFO1FBQ3BCLElBQUksSUFBSSxDQUFDbkQsZ0JBQWdCLEdBQUcsR0FDeEIsSUFBSSxDQUFDQSxnQkFBZ0IsR0FBRyxJQUFJLENBQUNoekMsR0FBRyxDQUFDOHdDLHFCQUFxQixDQUFDLElBQU0sSUFBSSxDQUFDam9CLE9BQU87UUFDN0UsSUFBSXN0QixTQUFTO1lBQ1QsSUFBSSxJQUFJLENBQUNsRCxlQUFlLENBQUMxcEMsT0FBTyxDQUFDNHNDLFdBQVcsQ0FBQyxHQUN6QztZQUNKLElBQUlBLFFBQVFweEMsR0FBRyxJQUFJLE1BQ2YsSUFBSyxJQUFJWixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDOHVDLGVBQWUsQ0FBQ3owQyxNQUFNLEVBQUUyRixJQUFLO2dCQUNsRCxJQUFJLElBQUksQ0FBQzh1QyxlQUFlLENBQUM5dUMsRUFBRSxDQUFDWSxHQUFHLEtBQUtveEMsUUFBUXB4QyxHQUFHLEVBQUU7b0JBQzdDLElBQUksQ0FBQ2t1QyxlQUFlLENBQUM5dUMsRUFBRSxHQUFHZ3lDO29CQUMxQjtnQkFDSjtZQUNKO1lBQ0osSUFBSSxDQUFDbEQsZUFBZSxDQUFDanZDLElBQUksQ0FBQ215QztRQUM5QjtJQUNKO0lBQ0E7Ozs7O0lBS0EsR0FDQXoyQixPQUFPQSxNQUFNLEVBQUU7UUFDWCxJQUFJMDJCLFFBQVEsSUFBSSxDQUFDM0QsU0FBUyxDQUFDL3FDLEdBQUcsQ0FBQ2dZO1FBQy9CLElBQUkwMkIsVUFBVWx5QyxhQUFha3lDLFNBQVNBLE1BQU16akMsSUFBSSxJQUFJK00sUUFDOUMsSUFBSSxDQUFDK3lCLFNBQVMsQ0FBQ2h2QyxHQUFHLENBQUNpYyxRQUFRMDJCLFFBQVEsSUFBSSxDQUFDeGpCLE9BQU8sQ0FBQ25qQixJQUFJLENBQUMySixDQUFBQSxJQUFLQSxFQUFFekcsSUFBSSxJQUFJK00sV0FBVztRQUNuRixPQUFPMDJCLFNBQVNBLE1BQU1wMkIsTUFBTSxDQUFDLElBQUksRUFBRS9OLEtBQUs7SUFDNUM7SUFDQTs7OztJQUlBLEdBQ0EsSUFBSTRkLGNBQWM7UUFDZCxPQUFPLElBQUksQ0FBQ25NLFVBQVUsQ0FBQ3poQixxQkFBcUIsR0FBR3BDLEdBQUcsR0FBRyxJQUFJLENBQUM2VCxTQUFTLENBQUNtWixVQUFVO0lBQ2xGO0lBQ0E7O0lBRUEsR0FDQSxJQUFJd3BCLGtCQUFrQjtRQUNsQixPQUFPO1lBQUV4MkMsS0FBSyxJQUFJLENBQUM2VCxTQUFTLENBQUNtWixVQUFVO1lBQUUvc0IsUUFBUSxJQUFJLENBQUM0VCxTQUFTLENBQUN3dUIsYUFBYTtRQUFDO0lBQ2xGO0lBQ0E7Ozs7SUFJQSxHQUNBLElBQUk5aEMsU0FBUztRQUFFLE9BQU8sSUFBSSxDQUFDc1QsU0FBUyxDQUFDdFQsTUFBTTtJQUFFO0lBQzdDOztJQUVBLEdBQ0EsSUFBSUcsU0FBUztRQUFFLE9BQU8sSUFBSSxDQUFDbVQsU0FBUyxDQUFDblQsTUFBTTtJQUFFO0lBQzdDOzs7O0lBSUEsR0FDQTJzQixnQkFBZ0Ixc0IsTUFBTSxFQUFFO1FBQ3BCLElBQUksQ0FBQzAxQyxZQUFZO1FBQ2pCLE9BQU8sSUFBSSxDQUFDeGlDLFNBQVMsQ0FBQ3daLGVBQWUsQ0FBQzFzQjtJQUMxQztJQUNBOzs7OztJQUtBLEdBQ0FvbUMsa0JBQWtCcG1DLE1BQU0sRUFBRTtRQUN0QixJQUFJLENBQUMwMUMsWUFBWTtRQUNqQixPQUFPLElBQUksQ0FBQ3hpQyxTQUFTLENBQUNrekIsaUJBQWlCLENBQUNwbUM7SUFDNUM7SUFDQTs7Ozs7SUFLQSxHQUNBLElBQUk4MUMscUJBQXFCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDNWlDLFNBQVMsQ0FBQ2t3QixhQUFhO0lBQ3ZDO0lBQ0E7Ozs7Ozs7SUFPQSxHQUNBemEsWUFBWXJpQixHQUFHLEVBQUU7UUFDYixPQUFPLElBQUksQ0FBQzRNLFNBQVMsQ0FBQ3lWLFdBQVcsQ0FBQ3JpQjtJQUN0QztJQUNBOztJQUVBLEdBQ0EsSUFBSWtlLGdCQUFnQjtRQUNoQixPQUFPLElBQUksQ0FBQ3RSLFNBQVMsQ0FBQ3NSLGFBQWE7SUFDdkM7SUFDQTs7Ozs7Ozs7Ozs7Ozs7O0lBZUEsR0FDQTRKLFdBQVdqc0IsS0FBSyxFQUFFZ1gsT0FBTyxFQUFFa1YsRUFBRSxFQUFFO1FBQzNCLE9BQU95QixVQUFVLElBQUksRUFBRTN0QixPQUFPaXNCLFdBQVcsSUFBSSxFQUFFanNCLE9BQU9nWCxTQUFTa1Y7SUFDbkU7SUFDQTs7OztJQUlBLEdBQ0EwbkIsWUFBWTV6QyxLQUFLLEVBQUVnWCxPQUFPLEVBQUU7UUFDeEIsT0FBTzJXLFVBQVUsSUFBSSxFQUFFM3RCLE9BQU9pc0IsV0FBVyxJQUFJLEVBQUVqc0IsT0FBT2dYLFNBQVM2OEIsQ0FBQUEsVUFBV3JuQixRQUFRLElBQUksRUFBRXhzQixNQUFNaWEsSUFBSSxFQUFFNDVCO0lBQ3hHO0lBQ0E7Ozs7O0lBS0EsR0FDQXRuQixlQUFlbGEsSUFBSSxFQUFFdE0sR0FBRyxFQUFFO1FBQ3RCLElBQUlrUixRQUFRLElBQUksQ0FBQ2tWLFNBQVMsQ0FBQzlaLE9BQU85VixNQUFNLElBQUksQ0FBQzBwQixlQUFlLENBQUM1VCxLQUFLM1EsSUFBSTtRQUN0RSxJQUFJMlQsT0FBTzRCLEtBQUssQ0FBQ2xSLE1BQU1rUixNQUFNcGIsTUFBTSxHQUFHLElBQUksRUFBRTtRQUM1QyxPQUFPekMsOERBQWVBLENBQUNpYixNQUFNLENBQUNnQixLQUFLbFgsSUFBSSxDQUFDNEgsS0FBS3hKLE9BQU84VixLQUFLM1EsSUFBSSxFQUFFMlQsS0FBSzJCLE9BQU8sQ0FBQyxDQUFDalIsS0FBS3hKLE9BQU8sSUFBSSxDQUFDO0lBQ2xHO0lBQ0E7Ozs7OztJQU1BLEdBQ0FxdkIsbUJBQW1CNXJCLEtBQUssRUFBRWdYLE9BQU8sRUFBRTZVLGNBQWMsSUFBSSxFQUFFO1FBQ25ELE9BQU9ELG1CQUFtQixJQUFJLEVBQUU1ckIsT0FBT2dYLFNBQVM2VTtJQUNwRDtJQUNBOzs7Ozs7Ozs7Ozs7SUFZQSxHQUNBYyxlQUFlM3NCLEtBQUssRUFBRWdYLE9BQU8sRUFBRTRWLFFBQVEsRUFBRTtRQUNyQyxPQUFPZSxVQUFVLElBQUksRUFBRTN0QixPQUFPMnNCLGVBQWUsSUFBSSxFQUFFM3NCLE9BQU9nWCxTQUFTNFY7SUFDdkU7SUFDQTs7Ozs7Ozs7O0lBU0EsR0FDQXJoQixTQUFTcEgsR0FBRyxFQUFFO1FBQ1YsT0FBTyxJQUFJLENBQUNnTixPQUFPLENBQUM1RixRQUFRLENBQUNwSDtJQUNqQztJQUNBOzs7O0lBSUEsR0FDQTJ2QyxTQUFTLzRDLElBQUksRUFBRW9JLFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDZ08sT0FBTyxDQUFDMlQsVUFBVSxDQUFDL3BCLE1BQU1vSTtJQUN6QztJQUNBNG1CLFlBQVlDLE1BQU0sRUFBRXhtQixVQUFVLElBQUksRUFBRTtRQUNoQyxJQUFJLENBQUMrdkMsWUFBWTtRQUNqQixPQUFPeHBCLFlBQVksSUFBSSxFQUFFQyxRQUFReG1CO0lBQ3JDO0lBQ0E7Ozs7OztJQU1BLEdBQ0F1b0IsWUFBWTVuQixHQUFHLEVBQUVoRyxPQUFPLENBQUMsRUFBRTtRQUN2QixJQUFJLENBQUNvMUMsWUFBWTtRQUNqQixJQUFJejJDLE9BQU8sSUFBSSxDQUFDcVUsT0FBTyxDQUFDekYsUUFBUSxDQUFDdkgsS0FBS2hHO1FBQ3RDLElBQUksQ0FBQ3JCLFFBQVFBLEtBQUtDLElBQUksSUFBSUQsS0FBS0csS0FBSyxFQUNoQyxPQUFPSDtRQUNYLElBQUl1VixPQUFPLElBQUksQ0FBQzFFLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQ3RRLE1BQU04UyxRQUFRLElBQUksQ0FBQ2tWLFNBQVMsQ0FBQzlaO1FBQzlELElBQUlnRCxPQUFPNEIsS0FBSyxDQUFDSCxTQUFTaEssSUFBSSxDQUFDbUssT0FBTzlTLE1BQU1rTyxLQUFLM1EsSUFBSSxFQUFFLENBQUMsR0FBR3ZELE1BQU07UUFDakUsT0FBT3RCLFlBQVlDLE1BQU0sS0FBTVAsR0FBRyxJQUFJeVosVUFBVUMsR0FBRyxJQUFNOVgsT0FBTztJQUNwRTtJQUNBOzs7Ozs7SUFNQSxHQUNBcW5CLGNBQWNyaEIsR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDb3ZDLFlBQVk7UUFDakIsT0FBTyxJQUFJLENBQUNwaUMsT0FBTyxDQUFDcVUsYUFBYSxDQUFDcmhCO0lBQ3RDO0lBQ0E7Ozs7SUFJQSxHQUNBLElBQUlpbkIsd0JBQXdCO1FBQUUsT0FBTyxJQUFJLENBQUNyYSxTQUFTLENBQUNELFlBQVksQ0FBQ0QsU0FBUztJQUFFO0lBQzVFOzs7SUFHQSxHQUNBLElBQUl5YSxvQkFBb0I7UUFBRSxPQUFPLElBQUksQ0FBQ3ZhLFNBQVMsQ0FBQ0QsWUFBWSxDQUFDRixVQUFVO0lBQUU7SUFDekU7Ozs7SUFJQSxHQUNBLElBQUltVixnQkFBZ0I7UUFBRSxPQUFPLElBQUksQ0FBQ2hWLFNBQVMsQ0FBQ292QixvQkFBb0I7SUFBRTtJQUNsRTs7Ozs7Ozs7SUFRQSxHQUNBbGEsZ0JBQWdCOWhCLEdBQUcsRUFBRTtRQUNqQixJQUFJbzRCLFVBQVUsSUFBSSxDQUFDNXVCLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ2Q7UUFDL0IsSUFBSSxDQUFDc2hCLFdBQVdwNEIsTUFBTSxJQUFJLENBQUN3ZSxRQUFRLENBQUNqaEIsSUFBSSxJQUFJeUMsTUFBTSxJQUFJLENBQUN3ZSxRQUFRLENBQUNoaEIsRUFBRSxFQUM5RCxPQUFPLElBQUksQ0FBQ29rQixhQUFhO1FBQzdCLElBQUksQ0FBQ3d0QixZQUFZO1FBQ2pCLE9BQU8sSUFBSSxDQUFDcGlDLE9BQU8sQ0FBQzhVLGVBQWUsQ0FBQzloQjtJQUN4QztJQUNBOzs7OztJQUtBLEdBQ0EsSUFBSWtuQixlQUFlO1FBQUUsT0FBTyxJQUFJLENBQUN0YSxTQUFTLENBQUNELFlBQVksQ0FBQ3VhLFlBQVk7SUFBRTtJQUN0RTs7Ozs7OztJQU9BLEdBQ0FjLFVBQVU5WixJQUFJLEVBQUU7UUFDWixJQUFJQSxLQUFLeFcsTUFBTSxHQUFHazRDLGFBQ2QsT0FBT2w2QixhQUFheEgsS0FBS3hXLE1BQU07UUFDbkMsSUFBSVUsTUFBTSxJQUFJLENBQUMwcEIsZUFBZSxDQUFDNVQsS0FBSzNRLElBQUksR0FBR21XO1FBQzNDLEtBQUssSUFBSW04QixTQUFTLElBQUksQ0FBQzlELFNBQVMsQ0FBRTtZQUM5QixJQUFJOEQsTUFBTXR5QyxJQUFJLElBQUkyUSxLQUFLM1EsSUFBSSxJQUFJc3lDLE1BQU16M0MsR0FBRyxJQUFJQSxPQUN2Q3kzQyxDQUFBQSxNQUFNQyxLQUFLLElBQUk3OEIsV0FBVzQ4QixNQUFNbjhCLFFBQVEsRUFBRUEsV0FBV2dHLGtCQUFrQixJQUFJLEVBQUV4TCxNQUFLLEdBQ25GLE9BQU8yaEMsTUFBTS84QixLQUFLO1FBQzFCO1FBQ0EsSUFBSSxDQUFDWSxVQUNEQSxXQUFXZ0csa0JBQWtCLElBQUksRUFBRXhMO1FBQ3ZDLElBQUk0RSxRQUFRMkMsYUFBYXZILEtBQUszSyxJQUFJLEVBQUVuTCxLQUFLc2I7UUFDekMsSUFBSSxDQUFDcTRCLFNBQVMsQ0FBQzd1QyxJQUFJLENBQUMsSUFBSWl3QyxZQUFZai9CLEtBQUszUSxJQUFJLEVBQUUyUSxLQUFLMVEsRUFBRSxFQUFFcEYsS0FBS3NiLFVBQVUsTUFBTVo7UUFDN0UsT0FBT0E7SUFDWDtJQUNBOztJQUVBLEdBQ0EsSUFBSXNZLFdBQVc7UUFDWCxJQUFJcmY7UUFDSixpRUFBaUU7UUFDakUsa0VBQWtFO1FBQ2xFLCtEQUErRDtRQUMvRCw0QkFBNEI7UUFDNUIsT0FBTyxDQUFDLElBQUksQ0FBQ3BWLEdBQUcsQ0FBQ0YsYUFBYSxDQUFDMjBCLFFBQVEsTUFBTWxsQixRQUFRSCxNQUFNLElBQUksQ0FBQyxDQUFDZ0csS0FBSyxJQUFJLENBQUNtUixVQUFVLE1BQU0sUUFBUW5SLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3llLGVBQWUsSUFBSTlOLEtBQUtDLEdBQUcsS0FBSyxHQUFFLEtBQzdKLElBQUksQ0FBQ3JtQixJQUFJLENBQUNXLGFBQWEsSUFBSSxJQUFJLENBQUMybEIsVUFBVTtJQUNsRDtJQUNBOztJQUVBLEdBQ0E1ZixRQUFRO1FBQ0osSUFBSSxDQUFDaWhCLFFBQVEsQ0FBQ3hULE1BQU0sQ0FBQztZQUNqQjNOLG1CQUFtQixJQUFJLENBQUM4ZixVQUFVO1lBQ2xDLElBQUksQ0FBQzVQLE9BQU8sQ0FBQ2tTLGVBQWU7UUFDaEM7SUFDSjtJQUNBOzs7SUFHQSxHQUNBNndCLFFBQVF6NUMsSUFBSSxFQUFFO1FBQ1YsSUFBSSxJQUFJLENBQUNtMUMsS0FBSyxJQUFJbjFDLE1BQU07WUFDcEIsSUFBSSxDQUFDbTFDLEtBQUssR0FBR24xQztZQUNiLElBQUksQ0FBQzJuQixRQUFRLENBQUMyc0IsU0FBUyxDQUFDLENBQUN0MEMsS0FBS0UsUUFBUSxJQUFJLElBQUlGLE9BQU9BLEtBQUtHLGFBQWEsRUFBRTRELFdBQVcsSUFBSUM7WUFDeEYsSUFBSSxDQUFDb3lDLFdBQVc7UUFDcEI7SUFDSjtJQUNBOzs7OztJQUtBLEdBQ0FocUMsVUFBVTtRQUNOLEtBQUssSUFBSWtXLFVBQVUsSUFBSSxDQUFDa1QsT0FBTyxDQUMzQmxULE9BQU9sVyxPQUFPLENBQUMsSUFBSTtRQUN2QixJQUFJLENBQUNvcEIsT0FBTyxHQUFHLEVBQUU7UUFDakIsSUFBSSxDQUFDNU8sVUFBVSxDQUFDeGEsT0FBTztRQUN2QixJQUFJLENBQUNzSyxPQUFPLENBQUN0SyxPQUFPO1FBQ3BCLElBQUksQ0FBQy9MLEdBQUcsQ0FBQ3NyQixNQUFNO1FBQ2YsSUFBSSxDQUFDaEUsUUFBUSxDQUFDdmIsT0FBTztRQUNyQixJQUFJLElBQUksQ0FBQ3dwQyxnQkFBZ0IsR0FBRyxDQUFDLEdBQ3pCLElBQUksQ0FBQ2h6QyxHQUFHLENBQUMrd0Msb0JBQW9CLENBQUMsSUFBSSxDQUFDaUMsZ0JBQWdCO1FBQ3ZELElBQUksQ0FBQ0YsU0FBUyxHQUFHO0lBQ3JCO0lBQ0E7Ozs7SUFJQSxHQUNBLE9BQU96MEIsZUFBZXZYLEdBQUcsRUFBRWhDLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDckMsT0FBT3VaLGVBQWVuSixFQUFFLENBQUMsSUFBSThJLGFBQWEsT0FBT2xYLE9BQU8sV0FBVy9LLDhEQUFlQSxDQUFDaWIsTUFBTSxDQUFDbFEsT0FBT0EsS0FBS2hDLFFBQVEvRCxDQUFDLEVBQUUrRCxRQUFRbkYsQ0FBQyxFQUFFbUYsUUFBUTdELE9BQU8sRUFBRTZELFFBQVE5RCxPQUFPO0lBQ2hLO0lBQ0E7Ozs7Ozs7Ozs7O0lBV0EsR0FDQTgxQyxpQkFBaUI7UUFDYixJQUFJLEVBQUVsMEMsU0FBUyxFQUFFQyxVQUFVLEVBQUUsR0FBRyxJQUFJLENBQUMybEIsU0FBUztRQUM5QyxJQUFJa0IsTUFBTSxJQUFJLENBQUNoVyxTQUFTLENBQUN5d0IsY0FBYyxDQUFDdmhDO1FBQ3hDLE9BQU95YixlQUFlbkosRUFBRSxDQUFDLElBQUk4SSxhQUFhamlCLDhEQUFlQSxDQUFDaWIsTUFBTSxDQUFDMFMsSUFBSXJsQixJQUFJLEdBQUcsU0FBUyxTQUFTcWxCLElBQUk3cEIsR0FBRyxHQUFHK0MsV0FBV0MsWUFBWTtJQUNuSTtJQUNBOzs7Ozs7Ozs7OztJQVdBLEdBQ0EsT0FBT3NjLGlCQUFpQnFTLFFBQVEsRUFBRTtRQUM5QixPQUFPdlMsV0FBVzVCLE1BQU0sQ0FBQyxJQUFPLEVBQUMsSUFBSTtZQUFFa0MsZUFBZWlTO1FBQVM7SUFDbkU7SUFDQTs7Ozs7OztJQU9BLEdBQ0EsT0FBT3BTLGtCQUFrQnFULFNBQVMsRUFBRTtRQUNoQyxPQUFPeFQsV0FBVzVCLE1BQU0sQ0FBQyxJQUFPLEVBQUMsSUFBSTtZQUFFbUMsZ0JBQWdCaVQ7UUFBVTtJQUNyRTtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztJQWlCQSxHQUNBLE9BQU9nVixNQUFNOTBCLElBQUksRUFBRTdOLE9BQU8sRUFBRTtRQUN4QixJQUFJaXlDLFNBQVNoNkMsa0RBQVdBLENBQUM4cUMsT0FBTztRQUNoQyxJQUFJNTVCLFNBQVM7WUFBQ3c1QixNQUFNdnlCLEVBQUUsQ0FBQzZoQztZQUFTOTFCLFlBQVkvTCxFQUFFLENBQUMreUIsV0FBVyxDQUFDLENBQUMsRUFBRThPLE9BQU8sQ0FBQyxFQUFFcGtDO1NBQU87UUFDL0UsSUFBSTdOLFdBQVdBLFFBQVFreUMsSUFBSSxFQUN2Qi9vQyxPQUFPakssSUFBSSxDQUFDMmpDLFVBQVV6eUIsRUFBRSxDQUFDO1FBQzdCLE9BQU9qSDtJQUNYO0lBQ0E7Ozs7OztJQU1BLEdBQ0EsT0FBT2dwQyxVQUFVdGtDLElBQUksRUFBRTtRQUNuQixPQUFPblcsbURBQUlBLENBQUMwNkMsTUFBTSxDQUFDajJCLFlBQVkvTCxFQUFFLENBQUMreUIsV0FBVyxNQUFNTCxhQUFhajFCLE1BQU1xMUI7SUFDMUU7SUFDQTs7O0lBR0EsR0FDQSxPQUFPbVAsWUFBWTE1QyxHQUFHLEVBQUU7UUFDcEIsSUFBSW9WO1FBQ0osSUFBSTZELFVBQVVqWixJQUFJMjVDLGFBQWEsQ0FBQztRQUNoQyxJQUFJaHlCLFFBQVExTyxXQUFXblEsWUFBWW1CLEdBQUcsQ0FBQ2dQLFlBQVluUSxZQUFZbUIsR0FBRyxDQUFDaks7UUFDbkUsT0FBTyxDQUFDLENBQUNvVixLQUFLdVMsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1oYyxRQUFRLE1BQU0sUUFBUXlKLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2hNLElBQUksS0FBSztJQUNqSTtBQUNKO0FBQ0E7Ozs7OztBQU1BLEdBQ0F3ckMsV0FBV3B4QixXQUFXLEdBQUdBO0FBQ3pCOzs7Ozs7Ozs7O0FBVUEsR0FDQW94QixXQUFXMzBCLFlBQVksR0FBR0E7QUFDMUI7OztBQUdBLEdBQ0EyMEIsV0FBVzEwQixpQkFBaUIsR0FBR0E7QUFDL0I7Ozs7O0FBS0EsR0FDQTAwQixXQUFXejBCLG9CQUFvQixHQUFHQTtBQUNsQzs7Ozs7O0FBTUEsR0FDQXkwQixXQUFXNzBCLGFBQWEsR0FBR0E7QUFDM0I7OztBQUdBLEdBQ0E2MEIsV0FBVzUwQixjQUFjLEdBQUdBO0FBQzVCOzs7Ozs7O0FBT0EsR0FDQTQwQixXQUFXbmlDLFFBQVEsR0FBR0E7QUFDdEI7Ozs7O0FBS0EsR0FDQW1pQyxXQUFXOTBCLG1CQUFtQixHQUFHQTtBQUNqQzs7Ozs7QUFLQSxHQUNBODBCLFdBQVd0YyxrQkFBa0IsR0FBR3pZO0FBQ2hDOzs7OztBQUtBLEdBQ0ErMEIsV0FBV2oxQix1QkFBdUIsR0FBR0E7QUFDckM7Ozs7Ozs7Ozs7Ozs7OztBQWVBLEdBQ0FpMUIsV0FBV2g2QixXQUFXLEdBQUdBO0FBQ3pCOzs7Ozs7OztBQVFBLEdBQ0FnNkIsV0FBV2h5QixnQkFBZ0IsR0FBR0E7QUFDOUI7Ozs7Ozs7Ozs7QUFVQSxHQUNBZ3lCLFdBQVcveEIsWUFBWSxHQUFHQTtBQUMxQjs7Ozs7Ozs7QUFRQSxHQUNBK3hCLFdBQVc5eEIsa0JBQWtCLEdBQUdBO0FBQ2hDOzs7Ozs7QUFNQSxHQUNBOHhCLFdBQVd2eEIsYUFBYSxHQUFHQTtBQUMzQjs7Ozs7QUFLQSxHQUNBdXhCLFdBQVcxSyxTQUFTLEdBQUdBO0FBQ3ZCOzs7O0FBSUEsR0FDQTBLLFdBQVcwRCxRQUFRLEdBQUcsV0FBVyxHQUFFLzVDLG9EQUFLQSxDQUFDcWhCLE1BQU0sQ0FBQztJQUFFUSxTQUFTQyxDQUFBQSxTQUFVQSxPQUFPdGYsTUFBTSxHQUFHc2YsTUFBTSxDQUFDLEVBQUUsR0FBRztBQUFHO0FBQ3BHOzs7QUFHQSxHQUNBdTBCLFdBQVdqeUIsaUJBQWlCLEdBQUdBO0FBQy9COzs7QUFHQSxHQUNBaXlCLFdBQVdseUIsZ0JBQWdCLEdBQUdBO0FBQzlCOzs7QUFHQSxHQUNBa3lCLFdBQVdya0IsWUFBWSxHQUFHLFdBQVcsR0FBRXFrQixXQUFXanlCLGlCQUFpQixDQUFDbEwsRUFBRSxDQUFDO0lBQUUsU0FBUztBQUFrQjtBQUNwRzs7Ozs7OztBQU9BLEdBQ0FtOUIsV0FBV3VELFFBQVEsR0FBRyxXQUFXLEdBQUUzNUMsMERBQVdBLENBQUNvaEIsTUFBTTtBQUNyRCw4REFBOEQ7QUFDOUQsTUFBTXE1QixjQUFjO0FBQ3BCLE1BQU0zQixhQUFhLENBQUM7QUFDcEIsTUFBTWQ7SUFDRmh4QyxZQUFZb0IsSUFBSSxFQUFFQyxFQUFFLEVBQUVwRixHQUFHLEVBQUVzYixRQUFRLEVBQUVvOEIsS0FBSyxFQUFFaDlCLEtBQUssQ0FBRTtRQUMvQyxJQUFJLENBQUN2VixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDcEYsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ3NiLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDbzhCLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNoOUIsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE9BQU9vRyxPQUFPcTNCLEtBQUssRUFBRWw1QixPQUFPLEVBQUU7UUFDMUIsSUFBSUEsUUFBUTlOLEtBQUssSUFBSSxDQUFDZ25DLE1BQU1ya0MsSUFBSSxDQUFDK1MsQ0FBQUEsSUFBS0EsRUFBRTZ3QixLQUFLLEdBQ3pDLE9BQU9TO1FBQ1gsSUFBSXBwQyxTQUFTLEVBQUUsRUFBRXFwQyxVQUFVRCxNQUFNNzRDLE1BQU0sR0FBRzY0QyxLQUFLLENBQUNBLE1BQU03NEMsTUFBTSxHQUFHLEVBQUUsQ0FBQ1UsR0FBRyxHQUFHeVosVUFBVUMsR0FBRztRQUNyRixJQUFLLElBQUl6VSxJQUFJeEQsS0FBS3NGLEdBQUcsQ0FBQyxHQUFHb3hDLE1BQU03NEMsTUFBTSxHQUFHLEtBQUsyRixJQUFJa3pDLE1BQU03NEMsTUFBTSxFQUFFMkYsSUFBSztZQUNoRSxJQUFJd3lDLFFBQVFVLEtBQUssQ0FBQ2x6QyxFQUFFO1lBQ3BCLElBQUl3eUMsTUFBTXozQyxHQUFHLElBQUlvNEMsV0FBVyxDQUFDbjVCLFFBQVFvbkIsWUFBWSxDQUFDb1IsTUFBTXR5QyxJQUFJLEVBQUVzeUMsTUFBTXJ5QyxFQUFFLEdBQ2xFMkosT0FBT2pLLElBQUksQ0FBQyxJQUFJaXdDLFlBQVk5MUIsUUFBUTJGLE1BQU0sQ0FBQzZ5QixNQUFNdHlDLElBQUksRUFBRSxJQUFJOFosUUFBUTJGLE1BQU0sQ0FBQzZ5QixNQUFNcnlDLEVBQUUsRUFBRSxDQUFDLElBQUlxeUMsTUFBTXozQyxHQUFHLEVBQUV5M0MsTUFBTW44QixRQUFRLEVBQUUsT0FBT204QixNQUFNLzhCLEtBQUs7UUFDOUk7UUFDQSxPQUFPM0w7SUFDWDtBQUNKO0FBQ0EsU0FBU2tuQyxlQUFldHVDLElBQUksRUFBRTZYLEtBQUssRUFBRXpoQixJQUFJO0lBQ3JDLElBQUssSUFBSXM2QyxVQUFVMXdDLEtBQUt5SixLQUFLLENBQUNvTyxLQUFLLENBQUNBLFFBQVF2YSxJQUFJb3pDLFFBQVEvNEMsTUFBTSxHQUFHLEdBQUcyRixLQUFLLEdBQUdBLElBQUs7UUFDN0UsSUFBSXVHLFNBQVM2c0MsT0FBTyxDQUFDcHpDLEVBQUUsRUFBRThOLFFBQVEsT0FBT3ZILFVBQVUsYUFBYUEsT0FBTzdELFFBQVE2RDtRQUM5RSxJQUFJdUgsT0FDQWhCLGFBQWFnQixPQUFPaFY7SUFDNUI7SUFDQSxPQUFPQTtBQUNYO0FBRUEsTUFBTXU2QyxrQkFBa0J4cUMsUUFBUUMsR0FBRyxHQUFHLFFBQVFELFFBQVFFLE9BQU8sR0FBRyxRQUFRRixRQUFRRyxLQUFLLEdBQUcsVUFBVTtBQUNsRyxTQUFTc3FDLGlCQUFpQjd5QyxJQUFJLEVBQUVzSCxRQUFRO0lBQ3BDLE1BQU13ckMsUUFBUTl5QyxLQUFLOEcsS0FBSyxDQUFDO0lBQ3pCLElBQUl1QyxTQUFTeXBDLEtBQUssQ0FBQ0EsTUFBTWw1QyxNQUFNLEdBQUcsRUFBRTtJQUNwQyxJQUFJeVAsVUFBVSxTQUNWQSxTQUFTO0lBQ2IsSUFBSTBwQyxLQUFLQyxNQUFNMTZDLE9BQU8yNkM7SUFDdEIsSUFBSyxJQUFJMXpDLElBQUksR0FBR0EsSUFBSXV6QyxNQUFNbDVDLE1BQU0sR0FBRyxHQUFHLEVBQUUyRixFQUFHO1FBQ3ZDLE1BQU0yekMsTUFBTUosS0FBSyxDQUFDdnpDLEVBQUU7UUFDcEIsSUFBSSxrQkFBa0IxQyxJQUFJLENBQUNxMkMsTUFDdkJELE9BQU87YUFDTixJQUFJLFlBQVlwMkMsSUFBSSxDQUFDcTJDLE1BQ3RCSCxNQUFNO2FBQ0wsSUFBSSxzQkFBc0JsMkMsSUFBSSxDQUFDcTJDLE1BQ2hDRixPQUFPO2FBQ04sSUFBSSxjQUFjbjJDLElBQUksQ0FBQ3EyQyxNQUN4QjU2QyxRQUFRO2FBQ1AsSUFBSSxTQUFTdUUsSUFBSSxDQUFDcTJDLE1BQU07WUFDekIsSUFBSTVyQyxZQUFZLE9BQ1oyckMsT0FBTztpQkFFUEQsT0FBTztRQUNmLE9BRUksTUFBTSxJQUFJOS9CLE1BQU0saUNBQWlDZ2dDO0lBQ3pEO0lBQ0EsSUFBSUgsS0FDQTFwQyxTQUFTLFNBQVNBO0lBQ3RCLElBQUkycEMsTUFDQTNwQyxTQUFTLFVBQVVBO0lBQ3ZCLElBQUk0cEMsTUFDQTVwQyxTQUFTLFVBQVVBO0lBQ3ZCLElBQUkvUSxPQUNBK1EsU0FBUyxXQUFXQTtJQUN4QixPQUFPQTtBQUNYO0FBQ0EsU0FBUzhwQyxVQUFVbnpDLElBQUksRUFBRXdMLEtBQUssRUFBRWxULEtBQUs7SUFDakMsSUFBSWtULE1BQU1nakIsTUFBTSxFQUNaeHVCLE9BQU8sU0FBU0E7SUFDcEIsSUFBSXdMLE1BQU1takIsT0FBTyxFQUNiM3VCLE9BQU8sVUFBVUE7SUFDckIsSUFBSXdMLE1BQU1pakIsT0FBTyxFQUNienVCLE9BQU8sVUFBVUE7SUFDckIsSUFBSTFILFVBQVUsU0FBU2tULE1BQU1xakIsUUFBUSxFQUNqQzd1QixPQUFPLFdBQVdBO0lBQ3RCLE9BQU9BO0FBQ1g7QUFDQSxNQUFNb3pDLGtCQUFrQixXQUFXLEdBQUV4N0MsbURBQUlBLENBQUN5N0MsT0FBTyxDQUFDLFdBQVcsR0FBRTVGLFdBQVdsekIsZ0JBQWdCLENBQUM7SUFDdkZvVCxTQUFRbmlCLEtBQUssRUFBRXZKLElBQUk7UUFDZixPQUFPMnJCLFlBQVkwbEIsVUFBVXJ4QyxLQUFLeUosS0FBSyxHQUFHRixPQUFPdkosTUFBTTtJQUMzRDtBQUNKO0FBQ0E7Ozs7Ozs7QUFPQSxHQUNBLE1BQU1zeEMsU0FBUyxXQUFXLEdBQUVuOEMsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQUUrNkIsU0FBU0o7QUFBZ0I7QUFDcEUsTUFBTUssVUFBVSxXQUFXLEdBQUUsSUFBSUM7QUFDakMsc0VBQXNFO0FBQ3RFLGdFQUFnRTtBQUNoRSxTQUFTSixVQUFVNW5DLEtBQUs7SUFDcEIsSUFBSWlvQyxXQUFXam9DLE1BQU1vTyxLQUFLLENBQUN5NUI7SUFDM0IsSUFBSWo2QixNQUFNbTZCLFFBQVEzd0MsR0FBRyxDQUFDNndDO0lBQ3RCLElBQUksQ0FBQ3I2QixLQUNEbTZCLFFBQVE1MEMsR0FBRyxDQUFDODBDLFVBQVVyNkIsTUFBTXM2QixZQUFZRCxTQUFTRSxNQUFNLENBQUMsQ0FBQ3BuQyxHQUFHQyxJQUFNRCxFQUFFc1UsTUFBTSxDQUFDclUsSUFBSSxFQUFFO0lBQ3JGLE9BQU80TTtBQUNYO0FBQ0E7Ozs7QUFJQSxHQUNBLFNBQVN3NkIsaUJBQWlCN3hDLElBQUksRUFBRXVKLEtBQUssRUFBRXVvQyxLQUFLO0lBQ3hDLE9BQU9ubUIsWUFBWTBsQixVQUFVcnhDLEtBQUt5SixLQUFLLEdBQUdGLE9BQU92SixNQUFNOHhDO0FBQzNEO0FBQ0EsSUFBSUMsZUFBZTtBQUNuQixNQUFNQyxnQkFBZ0I7QUFDdEIsU0FBU0wsWUFBWUQsUUFBUSxFQUFFcnNDLFdBQVdzckMsZUFBZTtJQUNyRCxJQUFJc0IsUUFBUTNuQyxPQUFPdEIsTUFBTSxDQUFDO0lBQzFCLElBQUlrcEMsV0FBVzVuQyxPQUFPdEIsTUFBTSxDQUFDO0lBQzdCLElBQUltcEMsY0FBYyxDQUFDcDBDLE1BQU0ydUM7UUFDckIsSUFBSS9OLFVBQVV1VCxRQUFRLENBQUNuMEMsS0FBSztRQUM1QixJQUFJNGdDLFdBQVcsTUFDWHVULFFBQVEsQ0FBQ24wQyxLQUFLLEdBQUcydUM7YUFDaEIsSUFBSS9OLFdBQVcrTixJQUNoQixNQUFNLElBQUl6N0IsTUFBTSxpQkFBaUJsVCxPQUFPO0lBQ2hEO0lBQ0EsSUFBSW1PLE1BQU0sQ0FBQzRsQyxPQUFPNXpDLEtBQUtrMEMsU0FBU3ZtQixnQkFBZ0J3bUI7UUFDNUMsSUFBSXJtQyxJQUFJeUM7UUFDUixJQUFJNmpDLFdBQVdMLEtBQUssQ0FBQ0gsTUFBTSxJQUFLRyxDQUFBQSxLQUFLLENBQUNILE1BQU0sR0FBR3huQyxPQUFPdEIsTUFBTSxDQUFDLEtBQUk7UUFDakUsSUFBSTZuQyxRQUFRM3lDLElBQUkyRyxLQUFLLENBQUMsVUFBVXdTLEdBQUcsQ0FBQ2s3QixDQUFBQSxJQUFLM0IsaUJBQWlCMkIsR0FBR2x0QztRQUM3RCxJQUFLLElBQUkvSCxJQUFJLEdBQUdBLElBQUl1ekMsTUFBTWw1QyxNQUFNLEVBQUUyRixJQUFLO1lBQ25DLElBQUk0eUMsU0FBU1csTUFBTTFwQyxLQUFLLENBQUMsR0FBRzdKLEdBQUdpRyxJQUFJLENBQUM7WUFDcEM0dUMsWUFBWWpDLFFBQVE7WUFDcEIsSUFBSSxDQUFDb0MsUUFBUSxDQUFDcEMsT0FBTyxFQUNqQm9DLFFBQVEsQ0FBQ3BDLE9BQU8sR0FBRztnQkFDZnJrQixnQkFBZ0I7Z0JBQ2hCd21CLGlCQUFpQjtnQkFDakJoOUIsS0FBSztvQkFBQyxDQUFDclY7d0JBQ0MsSUFBSXd5QyxTQUFTVCxlQUFlOzRCQUFFL3hDOzRCQUFNa3dDOzRCQUFRNEI7d0JBQU07d0JBQ2xEamxCLFdBQVc7NEJBQVEsSUFBSWtsQixnQkFBZ0JTLFFBQ25DVCxlQUFlO3dCQUFNLEdBQUdDO3dCQUM1QixPQUFPO29CQUNYO2lCQUFFO1lBQ1Y7UUFDUjtRQUNBLElBQUlTLE9BQU81QixNQUFNdHRDLElBQUksQ0FBQztRQUN0QjR1QyxZQUFZTSxNQUFNO1FBQ2xCLElBQUlDLFVBQVVKLFFBQVEsQ0FBQ0csS0FBSyxJQUFLSCxDQUFBQSxRQUFRLENBQUNHLEtBQUssR0FBRztZQUM5QzVtQixnQkFBZ0I7WUFDaEJ3bUIsaUJBQWlCO1lBQ2pCaDlCLEtBQUssQ0FBQyxDQUFDNUcsS0FBSyxDQUFDekMsS0FBS3NtQyxTQUFTSyxJQUFJLE1BQU0sUUFBUTNtQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdxSixHQUFHLE1BQU0sUUFBUTVHLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3RILEtBQUssRUFBQyxLQUFNLEVBQUU7UUFDeEk7UUFDQSxJQUFJaXJDLFNBQ0FNLFFBQVFyOUIsR0FBRyxDQUFDbFksSUFBSSxDQUFDaTFDO1FBQ3JCLElBQUl2bUIsZ0JBQ0E2bUIsUUFBUTdtQixjQUFjLEdBQUc7UUFDN0IsSUFBSXdtQixpQkFDQUssUUFBUUwsZUFBZSxHQUFHO0lBQ2xDO0lBQ0EsS0FBSyxJQUFJNW5DLEtBQUtpbkMsU0FBVTtRQUNwQixJQUFJclEsU0FBUzUyQixFQUFFcW5DLEtBQUssR0FBR3JuQyxFQUFFcW5DLEtBQUssQ0FBQ2p0QyxLQUFLLENBQUMsT0FBTztZQUFDO1NBQVM7UUFDdEQsSUFBSTRGLEVBQUVtb0MsR0FBRyxFQUNMLEtBQUssSUFBSWQsU0FBU3pRLE9BQVE7WUFDdEIsSUFBSWlSLFdBQVdMLEtBQUssQ0FBQ0gsTUFBTSxJQUFLRyxDQUFBQSxLQUFLLENBQUNILE1BQU0sR0FBR3huQyxPQUFPdEIsTUFBTSxDQUFDLEtBQUk7WUFDakUsSUFBSSxDQUFDc3BDLFNBQVNLLElBQUksRUFDZEwsU0FBU0ssSUFBSSxHQUFHO2dCQUFFOW1CLGdCQUFnQjtnQkFBT3dtQixpQkFBaUI7Z0JBQU9oOUIsS0FBSyxFQUFFO1lBQUM7WUFDN0UsSUFBSyxJQUFJblgsT0FBT28wQyxTQUNaQSxRQUFRLENBQUNwMEMsSUFBSSxDQUFDbVgsR0FBRyxDQUFDbFksSUFBSSxDQUFDc04sRUFBRW1vQyxHQUFHO1FBQ3BDO1FBQ0osSUFBSTcwQyxPQUFPME0sQ0FBQyxDQUFDcEYsU0FBUyxJQUFJb0YsRUFBRXZNLEdBQUc7UUFDL0IsSUFBSSxDQUFDSCxNQUNEO1FBQ0osS0FBSyxJQUFJK3pDLFNBQVN6USxPQUFRO1lBQ3RCbjFCLElBQUk0bEMsT0FBTy96QyxNQUFNME0sRUFBRTRLLEdBQUcsRUFBRTVLLEVBQUVvaEIsY0FBYyxFQUFFcGhCLEVBQUU0bkMsZUFBZTtZQUMzRCxJQUFJNW5DLEVBQUVwVSxLQUFLLEVBQ1A2VixJQUFJNGxDLE9BQU8sV0FBVy96QyxNQUFNME0sRUFBRXBVLEtBQUssRUFBRW9VLEVBQUVvaEIsY0FBYyxFQUFFcGhCLEVBQUU0bkMsZUFBZTtRQUNoRjtJQUNKO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLFNBQVN0bUIsWUFBWXRVLEdBQUcsRUFBRTlOLEtBQUssRUFBRXZKLElBQUksRUFBRTh4QyxLQUFLO0lBQ3hDLElBQUkvekMsT0FBTzVILG9EQUFPQSxDQUFDb1Q7SUFDbkIsSUFBSXNwQyxXQUFXajlDLDhEQUFXQSxDQUFDbUksTUFBTSxJQUFJKzBDLFNBQVNqOUMsZ0VBQWFBLENBQUNnOUMsYUFBYTkwQyxLQUFLcEcsTUFBTSxJQUFJb0csUUFBUTtJQUNoRyxJQUFJbXlDLFNBQVMsSUFBSTFGLFVBQVUsT0FBT3VJLFlBQVksT0FBT1Ysa0JBQWtCO0lBQ3ZFLElBQUlOLGdCQUFnQkEsYUFBYS94QyxJQUFJLElBQUlBLFFBQVEreEMsYUFBYUQsS0FBSyxJQUFJQSxPQUFPO1FBQzFFNUIsU0FBUzZCLGFBQWE3QixNQUFNLEdBQUc7UUFDL0IsSUFBSTlqQixjQUFjMXBCLE9BQU8sQ0FBQzZHLE1BQU1wTCxPQUFPLElBQUksR0FBRztZQUMxQzQwQyxZQUFZO1lBQ1poQixlQUFlO1FBQ25CO0lBQ0o7SUFDQSxJQUFJaUIsTUFBTSxJQUFJNzJCO0lBQ2QsSUFBSTgyQixTQUFTLENBQUNQO1FBQ1YsSUFBSUEsU0FBUztZQUNULEtBQUssSUFBSVEsT0FBT1IsUUFBUXI5QixHQUFHLENBQ3ZCLElBQUksQ0FBQzI5QixJQUFJamUsR0FBRyxDQUFDbWUsTUFBTTtnQkFDZkYsSUFBSTltQyxHQUFHLENBQUNnbkM7Z0JBQ1IsSUFBSUEsSUFBSWx6QyxNQUFNdUosUUFBUTtvQkFDbEIsSUFBSW1wQyxRQUFRTCxlQUFlLEVBQ3ZCQSxrQkFBa0I7b0JBQ3RCLE9BQU87Z0JBQ1g7WUFDSjtZQUNKLElBQUlLLFFBQVE3bUIsY0FBYyxFQUFFO2dCQUN4QixJQUFJNm1CLFFBQVFMLGVBQWUsRUFDdkJBLGtCQUFrQjtnQkFDdEJVLFlBQVk7WUFDaEI7UUFDSjtRQUNBLE9BQU87SUFDWDtJQUNBLElBQUlULFdBQVdqN0IsR0FBRyxDQUFDeTZCLE1BQU0sRUFBRXFCLFVBQVVDO0lBQ3JDLElBQUlkLFVBQVU7UUFDVixJQUFJVyxPQUFPWCxRQUFRLENBQUNwQyxTQUFTZ0IsVUFBVW56QyxNQUFNd0wsT0FBTyxDQUFDdXBDLFFBQVEsR0FBRztZQUM1RHRJLFVBQVU7UUFDZCxPQUNLLElBQUlzSSxVQUFXdnBDLENBQUFBLE1BQU1nakIsTUFBTSxJQUFJaGpCLE1BQU1pakIsT0FBTyxJQUFJampCLE1BQU1takIsT0FBTyxLQUM5RCw0Q0FBNEM7UUFDNUMsQ0FBRXZtQixDQUFBQSxRQUFRRSxPQUFPLElBQUlrRCxNQUFNbWpCLE9BQU8sSUFBSW5qQixNQUFNZ2pCLE1BQU0sS0FDakQ0bUIsQ0FBQUEsV0FBVy84Qyw2Q0FBSSxDQUFDbVQsTUFBTXBMLE9BQU8sQ0FBQyxLQUFLZzFDLFlBQVlwMUMsTUFBTTtZQUN0RCxJQUFJazFDLE9BQU9YLFFBQVEsQ0FBQ3BDLFNBQVNnQixVQUFVaUMsVUFBVTVwQyxPQUFPLE1BQU0sR0FBRztnQkFDN0RpaEMsVUFBVTtZQUNkLE9BQ0ssSUFBSWpoQyxNQUFNcWpCLFFBQVEsSUFBSSxDQUFDd21CLFlBQVkvOEMsOENBQUssQ0FBQ2tULE1BQU1wTCxPQUFPLENBQUMsS0FBS0osUUFBUXExQyxhQUFhRCxZQUNsRkYsT0FBT1gsUUFBUSxDQUFDcEMsU0FBU2dCLFVBQVVrQyxXQUFXN3BDLE9BQU8sT0FBTyxHQUFHO2dCQUMvRGloQyxVQUFVO1lBQ2Q7UUFDSixPQUNLLElBQUlzSSxVQUFVdnBDLE1BQU1xakIsUUFBUSxJQUM3QnFtQixPQUFPWCxRQUFRLENBQUNwQyxTQUFTZ0IsVUFBVW56QyxNQUFNd0wsT0FBTyxNQUFNLEdBQUc7WUFDekRpaEMsVUFBVTtRQUNkO1FBQ0EsSUFBSSxDQUFDQSxXQUFXeUksT0FBT1gsU0FBU0ssSUFBSSxHQUNoQ25JLFVBQVU7SUFDbEI7SUFDQSxJQUFJdUksV0FDQXZJLFVBQVU7SUFDZCxJQUFJQSxXQUFXNkgsaUJBQ1g5b0MsTUFBTThvQyxlQUFlO0lBQ3pCLE9BQU83SDtBQUNYO0FBRUE7OztBQUdBLEdBQ0EsTUFBTTZJO0lBQ0Y7OztJQUdBLEdBQ0FqM0MsWUFBWTJMLFNBQVMsRUFDckI7O0lBRUEsR0FDQWxQLElBQUksRUFDSjs7SUFFQSxHQUNBRyxHQUFHLEVBQ0g7O0lBRUEsR0FDQVEsS0FBSyxFQUNMOztJQUVBLEdBQ0FHLE1BQU0sQ0FBRTtRQUNKLElBQUksQ0FBQ29PLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDbFAsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0csR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ1EsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0csTUFBTSxHQUFHQTtJQUNsQjtJQUNBa2hDLE9BQU87UUFDSCxJQUFJNWpDLE1BQU15RyxTQUFTMEssYUFBYSxDQUFDO1FBQ2pDblIsSUFBSThRLFNBQVMsR0FBRyxJQUFJLENBQUNBLFNBQVM7UUFDOUIsSUFBSSxDQUFDZy9CLE1BQU0sQ0FBQzl2QztRQUNaLE9BQU9BO0lBQ1g7SUFDQWtpQixPQUFPbGlCLEdBQUcsRUFBRWlJLElBQUksRUFBRTtRQUNkLElBQUlBLEtBQUs2SSxTQUFTLElBQUksSUFBSSxDQUFDQSxTQUFTLEVBQ2hDLE9BQU87UUFDWCxJQUFJLENBQUNnL0IsTUFBTSxDQUFDOXZDO1FBQ1osT0FBTztJQUNYO0lBQ0E4dkMsT0FBTzl2QyxHQUFHLEVBQUU7UUFDUkEsSUFBSXNPLEtBQUssQ0FBQzFNLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksR0FBRztRQUM3QjVCLElBQUlzTyxLQUFLLENBQUN2TSxHQUFHLEdBQUcsSUFBSSxDQUFDQSxHQUFHLEdBQUc7UUFDM0IsSUFBSSxJQUFJLENBQUNRLEtBQUssSUFBSSxNQUNkdkMsSUFBSXNPLEtBQUssQ0FBQy9MLEtBQUssR0FBRyxJQUFJLENBQUNBLEtBQUssR0FBRztRQUNuQ3ZDLElBQUlzTyxLQUFLLENBQUM1TCxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLEdBQUc7SUFDckM7SUFDQTZDLEdBQUcrVixDQUFDLEVBQUU7UUFDRixPQUFPLElBQUksQ0FBQzFaLElBQUksSUFBSTBaLEVBQUUxWixJQUFJLElBQUksSUFBSSxDQUFDRyxHQUFHLElBQUl1WixFQUFFdlosR0FBRyxJQUFJLElBQUksQ0FBQ1EsS0FBSyxJQUFJK1ksRUFBRS9ZLEtBQUssSUFBSSxJQUFJLENBQUNHLE1BQU0sSUFBSTRZLEVBQUU1WSxNQUFNLElBQy9GLElBQUksQ0FBQ29PLFNBQVMsSUFBSXdLLEVBQUV4SyxTQUFTO0lBQ3JDO0lBQ0E7Ozs7OztJQU1BLEdBQ0EsT0FBT3VyQyxTQUFTdHpDLElBQUksRUFBRStILFNBQVMsRUFBRXBMLEtBQUssRUFBRTtRQUNwQyxJQUFJQSxNQUFNNk0sS0FBSyxFQUFFO1lBQ2IsSUFBSXZKLE1BQU1ELEtBQUs2bkIsV0FBVyxDQUFDbHJCLE1BQU1vWixJQUFJLEVBQUVwWixNQUFNcVcsS0FBSyxJQUFJO1lBQ3RELElBQUksQ0FBQy9TLEtBQ0QsT0FBTyxFQUFFO1lBQ2IsSUFBSTdKLE9BQU9tOUMsUUFBUXZ6QztZQUNuQixPQUFPO2dCQUFDLElBQUlxekMsZ0JBQWdCdHJDLFdBQVc5SCxJQUFJcEgsSUFBSSxHQUFHekMsS0FBS3lDLElBQUksRUFBRW9ILElBQUlqSCxHQUFHLEdBQUc1QyxLQUFLNEMsR0FBRyxFQUFFLE1BQU1pSCxJQUFJaEgsTUFBTSxHQUFHZ0gsSUFBSWpILEdBQUc7YUFBRTtRQUNqSCxPQUNLO1lBQ0QsT0FBT3c2QyxtQkFBbUJ4ekMsTUFBTStILFdBQVdwTDtRQUMvQztJQUNKO0FBQ0o7QUFDQSxTQUFTNDJDLFFBQVF2ekMsSUFBSTtJQUNqQixJQUFJcEgsT0FBT29ILEtBQUsyaEIsU0FBUyxDQUFDdm1CLHFCQUFxQjtJQUMvQyxJQUFJdkMsT0FBT21ILEtBQUs2aEIsYUFBYSxJQUFJL1AsVUFBVUMsR0FBRyxHQUFHblosS0FBS0MsSUFBSSxHQUFHRCxLQUFLRyxLQUFLLEdBQUdpSCxLQUFLMmhCLFNBQVMsQ0FBQ3ptQixXQUFXLEdBQUc4RSxLQUFLekcsTUFBTTtJQUNsSCxPQUFPO1FBQUVWLE1BQU1BLE9BQU9tSCxLQUFLMmhCLFNBQVMsQ0FBQzNsQixVQUFVLEdBQUdnRSxLQUFLekcsTUFBTTtRQUFFUCxLQUFLSixLQUFLSSxHQUFHLEdBQUdnSCxLQUFLMmhCLFNBQVMsQ0FBQzVsQixTQUFTLEdBQUdpRSxLQUFLdEcsTUFBTTtJQUFDO0FBQzFIO0FBQ0EsU0FBUys1QyxZQUFZenpDLElBQUksRUFBRUMsR0FBRyxFQUFFOGpCLE1BQU07SUFDbEMsSUFBSXBuQixRQUFRekgsOERBQWVBLENBQUNpYixNQUFNLENBQUNsUTtJQUNuQyxPQUFPO1FBQUV6QyxNQUFNMUQsS0FBS3NGLEdBQUcsQ0FBQzJrQixPQUFPdm1CLElBQUksRUFBRXdDLEtBQUswbkIsa0JBQWtCLENBQUMvcUIsT0FBTyxPQUFPLE1BQU1hLElBQUk7UUFDakZDLElBQUkzRCxLQUFLK0MsR0FBRyxDQUFDa25CLE9BQU90bUIsRUFBRSxFQUFFdUMsS0FBSzBuQixrQkFBa0IsQ0FBQy9xQixPQUFPLE1BQU0sTUFBTWEsSUFBSTtRQUN2RXdSLE1BQU1yQixVQUFVOVksSUFBSTtJQUFDO0FBQzdCO0FBQ0EsU0FBUzIrQyxtQkFBbUJ4ekMsSUFBSSxFQUFFK0gsU0FBUyxFQUFFcEwsS0FBSztJQUM5QyxJQUFJQSxNQUFNYyxFQUFFLElBQUl1QyxLQUFLeWUsUUFBUSxDQUFDamhCLElBQUksSUFBSWIsTUFBTWEsSUFBSSxJQUFJd0MsS0FBS3llLFFBQVEsQ0FBQ2hoQixFQUFFLEVBQ2hFLE9BQU8sRUFBRTtJQUNiLElBQUlELE9BQU8xRCxLQUFLc0YsR0FBRyxDQUFDekMsTUFBTWEsSUFBSSxFQUFFd0MsS0FBS3llLFFBQVEsQ0FBQ2poQixJQUFJLEdBQUdDLEtBQUszRCxLQUFLK0MsR0FBRyxDQUFDRixNQUFNYyxFQUFFLEVBQUV1QyxLQUFLeWUsUUFBUSxDQUFDaGhCLEVBQUU7SUFDN0YsSUFBSXBELE1BQU0yRixLQUFLNmhCLGFBQWEsSUFBSS9QLFVBQVVDLEdBQUc7SUFDN0MsSUFBSWxDLFVBQVU3UCxLQUFLNmMsVUFBVSxFQUFFa0ssY0FBY2xYLFFBQVF6VSxxQkFBcUIsSUFBSWhGLE9BQU9tOUMsUUFBUXZ6QztJQUM3RixJQUFJMHpDLFVBQVU3akMsUUFBUTBnQyxhQUFhLENBQUMsYUFBYW9ELFlBQVlELFdBQVduNUMsT0FBT00sZ0JBQWdCLENBQUM2NEM7SUFDaEcsSUFBSUUsV0FBVzdzQixZQUFZbHVCLElBQUksR0FDMUI4NkMsQ0FBQUEsWUFBWTdWLFNBQVM2VixVQUFVRSxXQUFXLElBQUkvNUMsS0FBSytDLEdBQUcsQ0FBQyxHQUFHaWhDLFNBQVM2VixVQUFVRyxVQUFVLEtBQUs7SUFDakcsSUFBSUMsWUFBWWh0QixZQUFZaHVCLEtBQUssR0FBSTQ2QyxDQUFBQSxZQUFZN1YsU0FBUzZWLFVBQVVLLFlBQVksSUFBSTtJQUNwRixJQUFJQyxhQUFhenNCLFFBQVF4bkIsTUFBTXhDLE9BQU8wMkMsV0FBVzFzQixRQUFReG5CLE1BQU12QztJQUMvRCxJQUFJMDJDLGNBQWNGLFdBQVdqbEMsSUFBSSxJQUFJckIsVUFBVTlZLElBQUksR0FBR28vQyxhQUFhO0lBQ25FLElBQUlHLFlBQVlGLFNBQVNsbEMsSUFBSSxJQUFJckIsVUFBVTlZLElBQUksR0FBR3EvQyxXQUFXO0lBQzdELElBQUlDLGVBQWdCbjBDLENBQUFBLEtBQUttbkIsWUFBWSxJQUFJOHNCLFdBQVdyc0IsZ0JBQWdCLEdBQ2hFdXNCLGNBQWNWLFlBQVl6ekMsTUFBTXhDLE1BQU0yMkM7SUFDMUMsSUFBSUMsYUFBY3AwQyxDQUFBQSxLQUFLbW5CLFlBQVksSUFBSStzQixTQUFTdHNCLGdCQUFnQixHQUM1RHdzQixZQUFZWCxZQUFZenpDLE1BQU12QyxJQUFJMjJDO0lBQ3RDLElBQUlELGVBQWVDLGFBQWFELFlBQVkzMkMsSUFBSSxJQUFJNDJDLFVBQVU1MkMsSUFBSSxFQUFFO1FBQ2hFLE9BQU82MkMsT0FBT0MsWUFBWTMzQyxNQUFNYSxJQUFJLEVBQUViLE1BQU1jLEVBQUUsRUFBRTAyQztJQUNwRCxPQUNLO1FBQ0QsSUFBSW43QyxNQUFNbTdDLGNBQWNHLFlBQVkzM0MsTUFBTWEsSUFBSSxFQUFFLE1BQU0yMkMsZUFBZUksY0FBY04sWUFBWTtRQUMvRixJQUFJaDdDLFNBQVNtN0MsWUFBWUUsWUFBWSxNQUFNMzNDLE1BQU1jLEVBQUUsRUFBRTIyQyxhQUFhRyxjQUFjTCxVQUFVO1FBQzFGLElBQUkxcUIsVUFBVSxFQUFFO1FBQ2hCLElBQUksQ0FBQzJxQixlQUFlRixVQUFTLEVBQUd4MkMsRUFBRSxHQUFHLENBQUMyMkMsYUFBYUYsUUFBTyxFQUFHMTJDLElBQUksR0FBSTIyQyxDQUFBQSxlQUFlQyxZQUFZLElBQUksTUFDaEdILFdBQVdyc0IsZ0JBQWdCLEdBQUcsS0FBSzV1QixJQUFJQyxNQUFNLEdBQUcrRyxLQUFLb25CLGlCQUFpQixHQUFHLElBQUludUIsT0FBT0QsR0FBRyxFQUN2Rnd3QixRQUFRcnNCLElBQUksQ0FBQ3EzQyxNQUFNWixVQUFVNTZDLElBQUlDLE1BQU0sRUFBRTg2QyxXQUFXOTZDLE9BQU9ELEdBQUc7YUFDN0QsSUFBSUEsSUFBSUMsTUFBTSxHQUFHQSxPQUFPRCxHQUFHLElBQUlnSCxLQUFLcW1CLGVBQWUsQ0FBQyxDQUFDcnRCLElBQUlDLE1BQU0sR0FBR0EsT0FBT0QsR0FBRyxJQUFJLEdBQUdnVyxJQUFJLElBQUlyQixVQUFVOVksSUFBSSxFQUMxR21FLElBQUlDLE1BQU0sR0FBR0EsT0FBT0QsR0FBRyxHQUFHLENBQUNBLElBQUlDLE1BQU0sR0FBR0EsT0FBT0QsR0FBRyxJQUFJO1FBQzFELE9BQU9xN0MsT0FBT3I3QyxLQUFLOGxCLE1BQU0sQ0FBQzBLLFNBQVMxSyxNQUFNLENBQUN1MUIsT0FBT3A3QztJQUNyRDtJQUNBLFNBQVN1N0MsTUFBTTM3QyxJQUFJLEVBQUVHLEdBQUcsRUFBRUQsS0FBSyxFQUFFRSxNQUFNO1FBQ25DLE9BQU8sSUFBSW82QyxnQkFBZ0J0ckMsV0FBV2xQLE9BQU96QyxLQUFLeUMsSUFBSSxFQUFFRyxNQUFNNUMsS0FBSzRDLEdBQUcsR0FBRyxLQUFLLGFBQWEsS0FBSUQsUUFBUUYsTUFBTUksU0FBU0QsTUFBTSxLQUFLLGFBQWE7SUFDbEo7SUFDQSxTQUFTcTdDLE9BQU8sRUFBRXI3QyxHQUFHLEVBQUVDLE1BQU0sRUFBRXc3QyxVQUFVLEVBQUU7UUFDdkMsSUFBSUosU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJLzJDLElBQUksR0FBR0EsSUFBSW0zQyxXQUFXOThDLE1BQU0sRUFBRTJGLEtBQUssRUFDeEMrMkMsT0FBT2wzQyxJQUFJLENBQUNxM0MsTUFBTUMsVUFBVSxDQUFDbjNDLEVBQUUsRUFBRXRFLEtBQUt5N0MsVUFBVSxDQUFDbjNDLElBQUksRUFBRSxFQUFFckU7UUFDN0QsT0FBT283QztJQUNYO0lBQ0EsOENBQThDO0lBQzlDLFNBQVNDLFlBQVk5MkMsSUFBSSxFQUFFQyxFQUFFLEVBQUUwUSxJQUFJO1FBQy9CLElBQUluVixNQUFNLEtBQUtDLFNBQVMsQ0FBQyxLQUFLdzdDLGFBQWEsRUFBRTtRQUM3QyxTQUFTQyxRQUFRbDNDLElBQUksRUFBRW0zQyxRQUFRLEVBQUVsM0MsRUFBRSxFQUFFbTNDLE1BQU0sRUFBRXY4QyxHQUFHO1lBQzVDLHVEQUF1RDtZQUN2RCx5REFBeUQ7WUFDekQsMERBQTBEO1lBQzFELHNEQUFzRDtZQUN0RCxJQUFJdzhDLGFBQWE3MEMsS0FBSzZuQixXQUFXLENBQUNycUIsTUFBT0EsUUFBUTJRLEtBQUsxUSxFQUFFLEdBQUcsQ0FBQyxJQUFJO1lBQ2hFLElBQUlxM0MsV0FBVzkwQyxLQUFLNm5CLFdBQVcsQ0FBQ3BxQixJQUFLQSxNQUFNMFEsS0FBSzNRLElBQUksR0FBRyxJQUFJLENBQUM7WUFDNUQsSUFBSSxDQUFDcTNDLGNBQWMsQ0FBQ0MsVUFDaEI7WUFDSjk3QyxNQUFNYyxLQUFLK0MsR0FBRyxDQUFDZzRDLFdBQVc3N0MsR0FBRyxFQUFFODdDLFNBQVM5N0MsR0FBRyxFQUFFQTtZQUM3Q0MsU0FBU2EsS0FBS3NGLEdBQUcsQ0FBQ3kxQyxXQUFXNTdDLE1BQU0sRUFBRTY3QyxTQUFTNzdDLE1BQU0sRUFBRUE7WUFDdEQsSUFBSVosT0FBT3laLFVBQVVDLEdBQUcsRUFDcEIwaUMsV0FBV3QzQyxJQUFJLENBQUM5QyxPQUFPczZDLFdBQVdmLFdBQVdpQixXQUFXaDhDLElBQUksRUFBRXdCLE9BQU91NkMsU0FBU2IsWUFBWWUsU0FBUy83QyxLQUFLO2lCQUV4RzA3QyxXQUFXdDNDLElBQUksQ0FBQyxDQUFDOUMsT0FBT3U2QyxTQUFTaEIsV0FBV2tCLFNBQVNqOEMsSUFBSSxFQUFFLENBQUN3QixPQUFPczZDLFdBQVdaLFlBQVljLFdBQVc5N0MsS0FBSztRQUNsSDtRQUNBLElBQUkrQyxRQUFRMEIsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSUEsT0FBTzJRLEtBQUszUSxJQUFJLEVBQUVxRSxNQUFNcEUsT0FBTyxRQUFRQSxPQUFPLEtBQUssSUFBSUEsS0FBSzBRLEtBQUsxUSxFQUFFO1FBQ2xILHFEQUFxRDtRQUNyRCxLQUFLLElBQUlxTCxLQUFLOUksS0FBS2s4QixhQUFhLENBQzVCLElBQUlwekIsRUFBRXJMLEVBQUUsR0FBRzNCLFNBQVNnTixFQUFFdEwsSUFBSSxHQUFHcUUsS0FBSztZQUM5QixJQUFLLElBQUk1QixNQUFNbkcsS0FBS3NGLEdBQUcsQ0FBQzBKLEVBQUV0TCxJQUFJLEVBQUUxQixRQUFRaTVDLFNBQVNqN0MsS0FBSytDLEdBQUcsQ0FBQ2lNLEVBQUVyTCxFQUFFLEVBQUVvRSxPQUFRO2dCQUNwRSxJQUFJbXpDLFVBQVVoMUMsS0FBS3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQ3RRO2dCQUNwQyxLQUFLLElBQUlrUixRQUFRblIsS0FBS2lvQixTQUFTLENBQUMrc0IsU0FBVTtvQkFDdEMsSUFBSUMsV0FBVzlqQyxLQUFLM1QsSUFBSSxHQUFHdzNDLFFBQVF4M0MsSUFBSSxFQUFFMDNDLFNBQVMvakMsS0FBSzFULEVBQUUsR0FBR3UzQyxRQUFReDNDLElBQUk7b0JBQ3hFLElBQUl5M0MsWUFBWUYsUUFDWjtvQkFDSixJQUFJRyxTQUFTajFDLEtBQ1R5MEMsUUFBUTU2QyxLQUFLc0YsR0FBRyxDQUFDNjFDLFVBQVVoMUMsTUFBTXpDLFFBQVEsUUFBUXkzQyxZQUFZbjVDLE9BQU9oQyxLQUFLK0MsR0FBRyxDQUFDcTRDLFFBQVFILFNBQVN0M0MsTUFBTSxRQUFReTNDLFVBQVVyekMsS0FBS3NQLEtBQUs5WSxHQUFHO2dCQUMzSTtnQkFDQTRILE1BQU0rMEMsUUFBUXYzQyxFQUFFLEdBQUc7Z0JBQ25CLElBQUl3QyxPQUFPODBDLFFBQ1A7WUFDUjtRQUNKO1FBQ0osSUFBSU4sV0FBVzk4QyxNQUFNLElBQUksR0FDckIrOEMsUUFBUTU0QyxPQUFPMEIsUUFBUSxNQUFNcUUsS0FBS3BFLE1BQU0sTUFBTXVDLEtBQUs2aEIsYUFBYTtRQUNwRSxPQUFPO1lBQUU3b0I7WUFBS0M7WUFBUXc3QztRQUFXO0lBQ3JDO0lBQ0EsU0FBU0YsY0FBY3JuQyxLQUFLLEVBQUVsVSxHQUFHO1FBQzdCLElBQUlrQixJQUFJNnNCLFlBQVkvdEIsR0FBRyxHQUFJQSxDQUFBQSxNQUFNa1UsTUFBTWxVLEdBQUcsR0FBR2tVLE1BQU1qVSxNQUFNO1FBQ3pELE9BQU87WUFBRUQsS0FBS2tCO1lBQUdqQixRQUFRaUI7WUFBR3U2QyxZQUFZLEVBQUU7UUFBQztJQUMvQztBQUNKO0FBQ0EsU0FBU1UsV0FBVzNxQyxDQUFDLEVBQUVDLENBQUM7SUFDcEIsT0FBT0QsRUFBRXBPLFdBQVcsSUFBSXFPLEVBQUVyTyxXQUFXLElBQUlvTyxFQUFFaE8sRUFBRSxDQUFDaU87QUFDbEQ7QUFDQSxNQUFNMnFDO0lBQ0ZoNUMsWUFBWTRELElBQUksRUFBRXExQyxLQUFLLENBQUU7UUFDckIsSUFBSSxDQUFDcjFDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNxMUMsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUMvN0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDRyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUM2N0MsVUFBVSxHQUFHO1lBQUVoakIsTUFBTSxJQUFJLENBQUN2USxPQUFPLENBQUNtSixJQUFJLENBQUMsSUFBSTtZQUFHZ2pCLE9BQU8sSUFBSSxDQUFDdFQsSUFBSSxDQUFDMVAsSUFBSSxDQUFDLElBQUk7UUFBRTtRQUMvRSxJQUFJLENBQUN2MEIsR0FBRyxHQUFHb0osS0FBSzJoQixTQUFTLENBQUNyVixXQUFXLENBQUM1TyxTQUFTMEssYUFBYSxDQUFDO1FBQzdELElBQUksQ0FBQ3hSLEdBQUcsQ0FBQ3FWLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3ZCLElBQUltcEMsTUFBTXB3QixLQUFLLEVBQ1gsSUFBSSxDQUFDcnVCLEdBQUcsQ0FBQ3FWLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQzNCLElBQUltcEMsTUFBTXZ0QyxLQUFLLEVBQ1gsSUFBSSxDQUFDbFIsR0FBRyxDQUFDcVYsU0FBUyxDQUFDQyxHQUFHLENBQUNtcEMsTUFBTXZ0QyxLQUFLO1FBQ3RDLElBQUksQ0FBQ2sxQixLQUFLO1FBQ1YsSUFBSSxDQUFDcG1DLEdBQUcsQ0FBQ3FSLFlBQVksQ0FBQyxlQUFlO1FBQ3JDLElBQUksQ0FBQ3V0QyxRQUFRLENBQUN4MUMsS0FBS3lKLEtBQUs7UUFDeEJ6SixLQUFLd3BDLGNBQWMsQ0FBQyxJQUFJLENBQUMrTCxVQUFVO1FBQ25DLElBQUlGLE1BQU1sRyxLQUFLLEVBQ1hrRyxNQUFNbEcsS0FBSyxDQUFDLElBQUksQ0FBQ3Y0QyxHQUFHLEVBQUVvSjtJQUM5QjtJQUNBbVosT0FBT0EsTUFBTSxFQUFFO1FBQ1gsSUFBSUEsT0FBT2lDLFVBQVUsQ0FBQ3ZELEtBQUssQ0FBQzQ5QixlQUFldDhCLE9BQU8xUCxLQUFLLENBQUNvTyxLQUFLLENBQUM0OUIsYUFDMUQsSUFBSSxDQUFDRCxRQUFRLENBQUNyOEIsT0FBTzFQLEtBQUs7UUFDOUIsSUFBSSxJQUFJLENBQUM0ckMsS0FBSyxDQUFDbDhCLE1BQU0sQ0FBQ0EsUUFBUSxJQUFJLENBQUN2aUIsR0FBRyxLQUFLdWlCLE9BQU93QyxlQUFlLEVBQUU7WUFDL0QsSUFBSSxDQUFDcWhCLEtBQUs7WUFDVjdqQixPQUFPblosSUFBSSxDQUFDd3BDLGNBQWMsQ0FBQyxJQUFJLENBQUMrTCxVQUFVO1FBQzlDO0lBQ0o7SUFDQUMsU0FBUy9yQyxLQUFLLEVBQUU7UUFDWixJQUFJeEosTUFBTSxHQUFHOFMsUUFBUXRKLE1BQU1vTyxLQUFLLENBQUM0OUI7UUFDakMsTUFBT3gxQyxNQUFNOFMsTUFBTXBiLE1BQU0sSUFBSW9iLEtBQUssQ0FBQzlTLElBQUksSUFBSSxJQUFJLENBQUNvMUMsS0FBSyxDQUNqRHAxQztRQUNKLElBQUksQ0FBQ3JKLEdBQUcsQ0FBQzJPLEtBQUssQ0FBQ3M4QixNQUFNLEdBQUc5cEIsT0FBTyxDQUFDLElBQUksQ0FBQ3M5QixLQUFLLENBQUNwd0IsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLaGxCO0lBQ25FO0lBQ0EraEIsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDcXpCLEtBQUssQ0FBQ0ssT0FBTyxDQUFDLElBQUksQ0FBQzExQyxJQUFJO0lBQ3ZDO0lBQ0FnOUIsUUFBUTtRQUNKLElBQUksRUFBRXpqQyxNQUFNLEVBQUVHLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQ3NHLElBQUk7UUFDbEMsSUFBSXpHLFVBQVUsSUFBSSxDQUFDQSxNQUFNLElBQUlHLFVBQVUsSUFBSSxDQUFDQSxNQUFNLEVBQUU7WUFDaEQsSUFBSSxDQUFDSCxNQUFNLEdBQUdBO1lBQ2QsSUFBSSxDQUFDRyxNQUFNLEdBQUdBO1lBQ2QsSUFBSSxDQUFDOUMsR0FBRyxDQUFDMk8sS0FBSyxDQUFDb3dDLFNBQVMsR0FBRyxDQUFDLE1BQU0sRUFBRSxJQUFJcDhDLE9BQU8sRUFBRSxFQUFFLElBQUlHLE9BQU8sQ0FBQyxDQUFDO1FBQ3BFO0lBQ0o7SUFDQW1oQyxLQUFLNmEsT0FBTyxFQUFFO1FBQ1YsSUFBSUEsUUFBUS85QyxNQUFNLElBQUksSUFBSSxDQUFDMjlDLEtBQUssQ0FBQzM5QyxNQUFNLElBQUkrOUMsUUFBUXZwQyxJQUFJLENBQUMsQ0FBQ29HLEdBQUdqVixJQUFNLENBQUM2M0MsV0FBVzVpQyxHQUFHLElBQUksQ0FBQytpQyxLQUFLLENBQUNoNEMsRUFBRSxJQUFJO1lBQzlGLElBQUlzNEMsTUFBTSxJQUFJLENBQUNoL0MsR0FBRyxDQUFDK0osVUFBVSxFQUFFazFDLE9BQU87WUFDdEMsS0FBSyxJQUFJQyxVQUFVSixRQUFTO2dCQUN4QixJQUFJSSxPQUFPMzhCLE1BQU0sSUFBSXk4QixPQUFPRSxPQUFPMTVDLFdBQVcsSUFBSSxJQUFJLENBQUNrNUMsS0FBSyxDQUFDTyxLQUFLLENBQUN6NUMsV0FBVyxJQUMxRTA1QyxPQUFPMzhCLE1BQU0sQ0FBQ3k4QixLQUFLLElBQUksQ0FBQ04sS0FBSyxDQUFDTyxLQUFLLEdBQUc7b0JBQ3RDRCxNQUFNQSxJQUFJbDFDLFdBQVc7b0JBQ3JCbTFDO2dCQUNKLE9BQ0s7b0JBQ0QsSUFBSSxDQUFDai9DLEdBQUcsQ0FBQ3NLLFlBQVksQ0FBQzQwQyxPQUFPamIsSUFBSSxJQUFJK2E7Z0JBQ3pDO1lBQ0o7WUFDQSxNQUFPQSxJQUFLO2dCQUNSLElBQUluMUMsT0FBT20xQyxJQUFJbDFDLFdBQVc7Z0JBQzFCazFDLElBQUkxekIsTUFBTTtnQkFDVjB6QixNQUFNbjFDO1lBQ1Y7WUFDQSxJQUFJLENBQUM2MEMsS0FBSyxHQUFHSTtRQUNqQjtJQUNKO0lBQ0EveUMsVUFBVTtRQUNOLElBQUksSUFBSSxDQUFDMHlDLEtBQUssQ0FBQzF5QyxPQUFPLEVBQ2xCLElBQUksQ0FBQzB5QyxLQUFLLENBQUMxeUMsT0FBTyxDQUFDLElBQUksQ0FBQy9MLEdBQUcsRUFBRSxJQUFJLENBQUNvSixJQUFJO1FBQzFDLElBQUksQ0FBQ3BKLEdBQUcsQ0FBQ3NyQixNQUFNO0lBQ25CO0FBQ0o7QUFDQSxNQUFNdXpCLGFBQWEsV0FBVyxHQUFFdGdELG9EQUFLQSxDQUFDcWhCLE1BQU07QUFDNUM7O0FBRUEsR0FDQSxTQUFTNitCLE1BQU0xSixNQUFNO0lBQ2pCLE9BQU87UUFDSHZ6QixXQUFXNUIsTUFBTSxDQUFDaFUsQ0FBQUEsSUFBSyxJQUFJNHlDLFVBQVU1eUMsR0FBR21wQztRQUN4QzhKLFdBQVdwbkMsRUFBRSxDQUFDczlCO0tBQ2pCO0FBQ0w7QUFFQSxNQUFNb0ssaUJBQWlCLENBQUM1dkMsUUFBUUYsR0FBRyxFQUFFLGdCQUFnQjtBQUNyRCxNQUFNK3ZDLGtCQUFrQixXQUFXLEdBQUU3Z0Qsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQzlDUSxTQUFRaS9CLE9BQU87UUFDWCxPQUFPbmdELGdFQUFhQSxDQUFDbWdELFNBQVM7WUFDMUJDLGlCQUFpQjtZQUNqQkMsaUJBQWlCO1FBQ3JCLEdBQUc7WUFDQ0QsaUJBQWlCLENBQUMxckMsR0FBR0MsSUFBTTNRLEtBQUsrQyxHQUFHLENBQUMyTixHQUFHQztZQUN2QzByQyxpQkFBaUIsQ0FBQzNyQyxHQUFHQyxJQUFNRCxLQUFLQztRQUNwQztJQUNKO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsR0FDQSxTQUFTMnJDLGNBQWN6SyxTQUFTLENBQUMsQ0FBQztJQUM5QixPQUFPO1FBQ0hxSyxnQkFBZ0IzbkMsRUFBRSxDQUFDczlCO1FBQ25CMEs7UUFDQUM7UUFDQUM7UUFDQXIvQixzQkFBc0I3SSxFQUFFLENBQUM7S0FDNUI7QUFDTDtBQUNBOzs7O0FBSUEsR0FDQSxTQUFTbW9DLHVCQUF1Qi9zQyxLQUFLO0lBQ2pDLE9BQU9BLE1BQU1vTyxLQUFLLENBQUNtK0I7QUFDdkI7QUFDQSxTQUFTUyxjQUFjdDlCLE1BQU07SUFDekIsT0FBT0EsT0FBT2lDLFVBQVUsQ0FBQ3ZELEtBQUssQ0FBQ20rQixvQkFBb0I3OEIsT0FBTzFQLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ20rQjtBQUMxRTtBQUNBLE1BQU1LLGNBQWMsV0FBVyxHQUFFaEIsTUFBTTtJQUNuQ3B3QixPQUFPO0lBQ1B5d0IsU0FBUTExQyxJQUFJO1FBQ1IsSUFBSSxFQUFFeUosS0FBSyxFQUFFLEdBQUd6SixNQUFNMDJDLE9BQU9qdEMsTUFBTW9PLEtBQUssQ0FBQ20rQjtRQUN6QyxJQUFJVyxVQUFVLEVBQUU7UUFDaEIsS0FBSyxJQUFJN3RDLEtBQUtXLE1BQU1wUyxTQUFTLENBQUNvWSxNQUFNLENBQUU7WUFDbEMsSUFBSW1uQyxPQUFPOXRDLEtBQUtXLE1BQU1wUyxTQUFTLENBQUNrbUIsSUFBSTtZQUNwQyxJQUFJelUsRUFBRVUsS0FBSyxHQUFHLENBQUNvdEMsUUFBUWIsaUJBQWlCVyxLQUFLUCxlQUFlLEVBQUU7Z0JBQzFELElBQUlwdUMsWUFBWTZ1QyxPQUFPLGdDQUFnQztnQkFDdkQsSUFBSXptQyxTQUFTckgsRUFBRVUsS0FBSyxHQUFHVixJQUFJNVQsOERBQWVBLENBQUNpYixNQUFNLENBQUNySCxFQUFFaU4sSUFBSSxFQUFFak4sRUFBRWlOLElBQUksR0FBR2pOLEVBQUU2VyxNQUFNLEdBQUcsQ0FBQyxJQUFJO2dCQUNuRixLQUFLLElBQUk2MEIsU0FBU25CLGdCQUFnQkMsUUFBUSxDQUFDdHpDLE1BQU0rSCxXQUFXb0ksUUFDeER3bUMsUUFBUXg1QyxJQUFJLENBQUNxM0M7WUFDckI7UUFDSjtRQUNBLE9BQU9tQztJQUNYO0lBQ0F4OUIsUUFBT0EsTUFBTSxFQUFFdmlCLEdBQUc7UUFDZCxJQUFJdWlCLE9BQU9nQyxZQUFZLENBQUNoUCxJQUFJLENBQUNrUCxDQUFBQSxLQUFNQSxHQUFHaGtCLFNBQVMsR0FDM0NULElBQUkyTyxLQUFLLENBQUNzeEMsYUFBYSxHQUFHamdELElBQUkyTyxLQUFLLENBQUNzeEMsYUFBYSxJQUFJLGFBQWEsY0FBYztRQUNwRixJQUFJQyxhQUFhTCxjQUFjdDlCO1FBQy9CLElBQUkyOUIsWUFDQUMsYUFBYTU5QixPQUFPMVAsS0FBSyxFQUFFN1M7UUFDL0IsT0FBT3VpQixPQUFPeUMsVUFBVSxJQUFJekMsT0FBTzJDLFlBQVksSUFBSWc3QjtJQUN2RDtJQUNBM0gsT0FBTXY0QyxHQUFHLEVBQUVvSixJQUFJO1FBQ1grMkMsYUFBYS8yQyxLQUFLeUosS0FBSyxFQUFFN1M7SUFDN0I7SUFDQWtSLE9BQU87QUFDWDtBQUNBLFNBQVNpdkMsYUFBYXR0QyxLQUFLLEVBQUU3UyxHQUFHO0lBQzVCQSxJQUFJMk8sS0FBSyxDQUFDeXhDLGlCQUFpQixHQUFHdnRDLE1BQU1vTyxLQUFLLENBQUNtK0IsaUJBQWlCRSxlQUFlLEdBQUc7QUFDakY7QUFDQSxNQUFNSSxpQkFBaUIsV0FBVyxHQUFFakIsTUFBTTtJQUN0Q3B3QixPQUFPO0lBQ1B5d0IsU0FBUTExQyxJQUFJO1FBQ1IsT0FBT0EsS0FBS3lKLEtBQUssQ0FBQ3BTLFNBQVMsQ0FBQ29ZLE1BQU0sQ0FBQzRILEdBQUcsQ0FBQ3ZPLENBQUFBLElBQUtBLEVBQUVVLEtBQUssR0FBRyxFQUFFLEdBQUc2cEMsZ0JBQWdCQyxRQUFRLENBQUN0ekMsTUFBTSwwQkFBMEI4SSxJQUMvRzhvQyxNQUFNLENBQUMsQ0FBQ3BuQyxHQUFHQyxJQUFNRCxFQUFFc1UsTUFBTSxDQUFDclU7SUFDbkM7SUFDQTBPLFFBQU9BLE1BQU0sRUFBRXZpQixHQUFHO1FBQ2QsT0FBT3VpQixPQUFPeUMsVUFBVSxJQUFJekMsT0FBTzJDLFlBQVksSUFBSTNDLE9BQU9zQyxlQUFlLElBQUlnN0IsY0FBY3Q5QjtJQUMvRjtJQUNBclIsT0FBTztBQUNYO0FBQ0EsTUFBTW12QyxZQUFZO0lBQ2QsWUFBWTtRQUNSLGlCQUFpQjtZQUFFaFUsaUJBQWlCO1FBQXlCO1FBQzdELGdCQUFnQjtZQUFFQSxpQkFBaUI7UUFBeUI7SUFDaEU7QUFDSjtBQUNBLElBQUk4UyxnQkFBZ0I7SUFDaEJrQixTQUFTLENBQUMsV0FBVyxDQUFDMVUsVUFBVSxHQUFHO0lBQ25DMFUsU0FBUyxDQUFDLGNBQWMsR0FBRztRQUFFMVUsWUFBWTtJQUF5QjtBQUN0RTtBQUNBLE1BQU1nVSxzQkFBc0IsV0FBVyxHQUFFNWdELG1EQUFJQSxDQUFDdWhELE9BQU8sQ0FBQyxXQUFXLEdBQUUxTCxXQUFXNUssS0FBSyxDQUFDcVc7QUFFcEYsTUFBTUUsbUJBQW1CLFdBQVcsR0FBRS9oRCwwREFBV0EsQ0FBQ29oQixNQUFNLENBQUM7SUFDckRhLEtBQUlwWCxHQUFHLEVBQUVtM0MsT0FBTztRQUFJLE9BQU9uM0MsT0FBTyxPQUFPLE9BQU9tM0MsUUFBUW42QixNQUFNLENBQUNoZDtJQUFNO0FBQ3pFO0FBQ0EsTUFBTW8zQyxnQkFBZ0IsV0FBVyxHQUFFdGhELHlEQUFVQSxDQUFDeWdCLE1BQU0sQ0FBQztJQUNqRHhOO1FBQVcsT0FBTztJQUFNO0lBQ3hCbVEsUUFBT2xaLEdBQUcsRUFBRW9iLEVBQUU7UUFDVixJQUFJcGIsT0FBTyxNQUNQQSxNQUFNb2IsR0FBRy9ELE9BQU8sQ0FBQzJGLE1BQU0sQ0FBQ2hkO1FBQzVCLE9BQU9vYixHQUFHdVksT0FBTyxDQUFDZ2UsTUFBTSxDQUFDLENBQUMzeEMsS0FBS21aLElBQU1BLEVBQUVzekIsRUFBRSxDQUFDeUssb0JBQW9CLzlCLEVBQUVoTyxLQUFLLEdBQUduTCxLQUFLQTtJQUNqRjtBQUNKO0FBQ0EsTUFBTXEzQyxpQkFBaUIsV0FBVyxHQUFFbC9CLFdBQVdZLFNBQVMsQ0FBQztJQUNyRDVjLFlBQVk0RCxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUNBLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNtUSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNvbEMsVUFBVSxHQUFHO1lBQUVoakIsTUFBTSxJQUFJLENBQUNnbEIsT0FBTyxDQUFDcHNCLElBQUksQ0FBQyxJQUFJO1lBQUdnakIsT0FBTyxJQUFJLENBQUNxSixVQUFVLENBQUNyc0IsSUFBSSxDQUFDLElBQUk7UUFBRTtJQUN6RjtJQUNBaFMsT0FBT0EsTUFBTSxFQUFFO1FBQ1gsSUFBSW5OO1FBQ0osSUFBSXlyQyxZQUFZdCtCLE9BQU8xUCxLQUFLLENBQUNpdUMsS0FBSyxDQUFDTDtRQUNuQyxJQUFJSSxhQUFhLE1BQU07WUFDbkIsSUFBSSxJQUFJLENBQUN0bkMsTUFBTSxJQUFJLE1BQU07Z0JBQ3BCbkUsQ0FBQUEsS0FBSyxJQUFJLENBQUNtRSxNQUFNLE1BQU0sUUFBUW5FLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tXLE1BQU07Z0JBQ2pFLElBQUksQ0FBQy9SLE1BQU0sR0FBRztZQUNsQjtRQUNKLE9BQ0s7WUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDQSxNQUFNLEVBQUU7Z0JBQ2QsSUFBSSxDQUFDQSxNQUFNLEdBQUcsSUFBSSxDQUFDblEsSUFBSSxDQUFDMmhCLFNBQVMsQ0FBQ3JWLFdBQVcsQ0FBQzVPLFNBQVMwSyxhQUFhLENBQUM7Z0JBQ3JFLElBQUksQ0FBQytILE1BQU0sQ0FBQ3BJLFNBQVMsR0FBRztZQUM1QjtZQUNBLElBQUlvUixPQUFPaUMsVUFBVSxDQUFDczhCLEtBQUssQ0FBQ0wsa0JBQWtCSSxhQUFhdCtCLE9BQU95QyxVQUFVLElBQUl6QyxPQUFPd0MsZUFBZSxFQUNsRyxJQUFJLENBQUMzYixJQUFJLENBQUN3cEMsY0FBYyxDQUFDLElBQUksQ0FBQytMLFVBQVU7UUFDaEQ7SUFDSjtJQUNBZ0MsVUFBVTtRQUNOLElBQUksRUFBRXYzQyxJQUFJLEVBQUUsR0FBRyxJQUFJO1FBQ25CLElBQUlDLE1BQU1ELEtBQUt5SixLQUFLLENBQUNpdUMsS0FBSyxDQUFDTDtRQUMzQixJQUFJeitDLE9BQU9xSCxPQUFPLFFBQVFELEtBQUs2bkIsV0FBVyxDQUFDNW5CO1FBQzNDLElBQUksQ0FBQ3JILE1BQ0QsT0FBTztRQUNYLElBQUkrK0MsUUFBUTMzQyxLQUFLMmhCLFNBQVMsQ0FBQ3ZtQixxQkFBcUI7UUFDaEQsT0FBTztZQUNIdkMsTUFBTUQsS0FBS0MsSUFBSSxHQUFHOCtDLE1BQU05K0MsSUFBSSxHQUFHbUgsS0FBSzJoQixTQUFTLENBQUMzbEIsVUFBVSxHQUFHZ0UsS0FBS3pHLE1BQU07WUFDdEVQLEtBQUtKLEtBQUtJLEdBQUcsR0FBRzIrQyxNQUFNMytDLEdBQUcsR0FBR2dILEtBQUsyaEIsU0FBUyxDQUFDNWxCLFNBQVMsR0FBR2lFLEtBQUt0RyxNQUFNO1lBQ2xFQyxRQUFRZixLQUFLSyxNQUFNLEdBQUdMLEtBQUtJLEdBQUc7UUFDbEM7SUFDSjtJQUNBdytDLFdBQVd2M0MsR0FBRyxFQUFFO1FBQ1osSUFBSSxJQUFJLENBQUNrUSxNQUFNLEVBQUU7WUFDYixJQUFJLEVBQUU1VyxNQUFNLEVBQUVHLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQ3NHLElBQUk7WUFDbEMsSUFBSUMsS0FBSztnQkFDTCxJQUFJLENBQUNrUSxNQUFNLENBQUM1SyxLQUFLLENBQUMxTSxJQUFJLEdBQUdvSCxJQUFJcEgsSUFBSSxHQUFHVSxTQUFTO2dCQUM3QyxJQUFJLENBQUM0VyxNQUFNLENBQUM1SyxLQUFLLENBQUN2TSxHQUFHLEdBQUdpSCxJQUFJakgsR0FBRyxHQUFHVSxTQUFTO2dCQUMzQyxJQUFJLENBQUN5VyxNQUFNLENBQUM1SyxLQUFLLENBQUM1TCxNQUFNLEdBQUdzRyxJQUFJdEcsTUFBTSxHQUFHRCxTQUFTO1lBQ3JELE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDeVcsTUFBTSxDQUFDNUssS0FBSyxDQUFDMU0sSUFBSSxHQUFHO1lBQzdCO1FBQ0o7SUFDSjtJQUNBOEosVUFBVTtRQUNOLElBQUksSUFBSSxDQUFDd04sTUFBTSxFQUNYLElBQUksQ0FBQ0EsTUFBTSxDQUFDK1IsTUFBTTtJQUMxQjtJQUNBMDFCLFdBQVczM0MsR0FBRyxFQUFFO1FBQ1osSUFBSSxJQUFJLENBQUNELElBQUksQ0FBQ3lKLEtBQUssQ0FBQ2l1QyxLQUFLLENBQUNMLGtCQUFrQnAzQyxLQUN4QyxJQUFJLENBQUNELElBQUksQ0FBQ2d2QixRQUFRLENBQUM7WUFBRTRFLFNBQVN1akIsaUJBQWlCOW9DLEVBQUUsQ0FBQ3BPO1FBQUs7SUFDL0Q7QUFDSixHQUFHO0lBQ0MwWSxnQkFBZ0I7UUFDWmsvQixVQUFTdHVDLEtBQUs7WUFDVixJQUFJLENBQUNxdUMsVUFBVSxDQUFDLElBQUksQ0FBQzUzQyxJQUFJLENBQUM2bEIsV0FBVyxDQUFDO2dCQUFFL3NCLEdBQUd5USxNQUFNK2pCLE9BQU87Z0JBQUVwekIsR0FBR3FQLE1BQU1na0IsT0FBTztZQUFDO1FBQy9FO1FBQ0F1cUIsV0FBVXZ1QyxLQUFLO1lBQ1gsSUFBSUEsTUFBTS9TLE1BQU0sSUFBSSxJQUFJLENBQUN3SixJQUFJLENBQUM2YyxVQUFVLElBQUksQ0FBQyxJQUFJLENBQUM3YyxJQUFJLENBQUM2YyxVQUFVLENBQUNsbUIsUUFBUSxDQUFDNFMsTUFBTXd1QyxhQUFhLEdBQzFGLElBQUksQ0FBQ0gsVUFBVSxDQUFDO1FBQ3hCO1FBQ0E5bEI7WUFDSSxJQUFJLENBQUM4bEIsVUFBVSxDQUFDO1FBQ3BCO1FBQ0F4bEI7WUFDSSxJQUFJLENBQUN3bEIsVUFBVSxDQUFDO1FBQ3BCO0lBQ0o7QUFDSjtBQUNBOzs7QUFHQSxHQUNBLFNBQVNJO0lBQ0wsT0FBTztRQUFDWDtRQUFlQztLQUFlO0FBQzFDO0FBRUEsU0FBU1csWUFBWWpoRCxHQUFHLEVBQUUydEMsRUFBRSxFQUFFbm5DLElBQUksRUFBRUMsRUFBRSxFQUFFa3NCLENBQUM7SUFDckNnYixHQUFHdVQsU0FBUyxHQUFHO0lBQ2YsSUFBSyxJQUFJL25DLFNBQVNuWixJQUFJbWhELFNBQVMsQ0FBQzM2QyxNQUFNQyxLQUFLd0MsTUFBTXpDLE1BQU0yYyxHQUFHLENBQUNoSyxPQUFPMVAsSUFBSSxHQUFHdVEsSUFBSSxFQUFFL1EsT0FBT2tRLE9BQU8vRSxLQUFLLENBQUN6VCxNQUFNLENBQUU7UUFDdkcsSUFBSSxDQUFDd1ksT0FBT1ksU0FBUyxFQUNqQixNQUFPb0osSUFBSXdxQixHQUFHbC9CLElBQUksQ0FBQzBLLE9BQU8vRSxLQUFLLEVBQzNCdWUsRUFBRTFwQixNQUFNa2EsRUFBRWhpQixLQUFLLEVBQUVnaUI7SUFDN0I7QUFDSjtBQUNBLFNBQVNpK0IsWUFBWXA0QyxJQUFJLEVBQUVxNEMsU0FBUztJQUNoQyxJQUFJQyxVQUFVdDRDLEtBQUtrOEIsYUFBYTtJQUNoQyxJQUFJb2MsUUFBUTNnRCxNQUFNLElBQUksS0FBSzJnRCxPQUFPLENBQUMsRUFBRSxDQUFDOTZDLElBQUksSUFBSXdDLEtBQUt5ZSxRQUFRLENBQUNqaEIsSUFBSSxJQUM1RDg2QyxPQUFPLENBQUMsRUFBRSxDQUFDNzZDLEVBQUUsSUFBSXVDLEtBQUt5ZSxRQUFRLENBQUNoaEIsRUFBRSxFQUNqQyxPQUFPNjZDO0lBQ1gsSUFBSWx4QyxTQUFTLEVBQUU7SUFDZixLQUFLLElBQUksRUFBRTVKLElBQUksRUFBRUMsRUFBRSxFQUFFLElBQUk2NkMsUUFBUztRQUM5Qjk2QyxPQUFPMUQsS0FBS3NGLEdBQUcsQ0FBQ1ksS0FBS3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQy9TLE1BQU1BLElBQUksRUFBRUEsT0FBTzY2QztRQUN6RDU2QyxLQUFLM0QsS0FBSytDLEdBQUcsQ0FBQ21ELEtBQUt5SixLQUFLLENBQUN6UyxHQUFHLENBQUN1WixNQUFNLENBQUM5UyxJQUFJQSxFQUFFLEVBQUVBLEtBQUs0NkM7UUFDakQsSUFBSWp4QyxPQUFPelAsTUFBTSxJQUFJeVAsTUFBTSxDQUFDQSxPQUFPelAsTUFBTSxHQUFHLEVBQUUsQ0FBQzhGLEVBQUUsSUFBSUQsTUFDakQ0SixNQUFNLENBQUNBLE9BQU96UCxNQUFNLEdBQUcsRUFBRSxDQUFDOEYsRUFBRSxHQUFHQTthQUUvQjJKLE9BQU9qSyxJQUFJLENBQUM7WUFBRUs7WUFBTUM7UUFBRztJQUMvQjtJQUNBLE9BQU8ySjtBQUNYO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNbXhDO0lBQ0Y7O0lBRUEsR0FDQW44QyxZQUFZdXZDLE1BQU0sQ0FBRTtRQUNoQixNQUFNLEVBQUU2TSxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVOLFlBQVksSUFBSSxFQUFFLEdBQUcxTTtRQUNyRSxJQUFJLENBQUM2TSxPQUFPSSxNQUFNLEVBQ2QsTUFBTSxJQUFJdjRDLFdBQVc7UUFDekIsSUFBSSxDQUFDbTRDLE1BQU0sR0FBR0E7UUFDZCxJQUFJRSxVQUFVO1lBQ1YsSUFBSSxDQUFDRyxRQUFRLEdBQUcsQ0FBQ0MsT0FBTzk0QyxNQUFNeEMsTUFBTTBPLE1BQVF3c0MsU0FBU3hzQyxLQUFLMU8sTUFBTUEsT0FBT3M3QyxLQUFLLENBQUMsRUFBRSxDQUFDbmhELE1BQU0sRUFBRW1oRCxPQUFPOTRDO1FBQ25HLE9BQ0ssSUFBSSxPQUFPeTRDLGNBQWMsWUFBWTtZQUN0QyxJQUFJLENBQUNJLFFBQVEsR0FBRyxDQUFDQyxPQUFPOTRDLE1BQU14QyxNQUFNME87Z0JBQ2hDLElBQUlMLE9BQU80c0MsV0FBV0ssT0FBTzk0QyxNQUFNeEM7Z0JBQ25DLElBQUlxTyxNQUNBSyxJQUFJMU8sTUFBTUEsT0FBT3M3QyxLQUFLLENBQUMsRUFBRSxDQUFDbmhELE1BQU0sRUFBRWtVO1lBQzFDO1FBQ0osT0FDSyxJQUFJNHNDLFlBQVk7WUFDakIsSUFBSSxDQUFDSSxRQUFRLEdBQUcsQ0FBQ0MsT0FBT0MsT0FBT3Y3QyxNQUFNME8sTUFBUUEsSUFBSTFPLE1BQU1BLE9BQU9zN0MsS0FBSyxDQUFDLEVBQUUsQ0FBQ25oRCxNQUFNLEVBQUU4Z0Q7UUFDbkYsT0FDSztZQUNELE1BQU0sSUFBSXA0QyxXQUFXO1FBQ3pCO1FBQ0EsSUFBSSxDQUFDczRDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDTixTQUFTLEdBQUdBO0lBQ3JCO0lBQ0E7Ozs7SUFJQSxHQUNBVyxXQUFXaDVDLElBQUksRUFBRTtRQUNiLElBQUl1UixRQUFRLElBQUl2Yiw4REFBZUEsSUFBSWtXLE1BQU1xRixNQUFNckYsR0FBRyxDQUFDaWYsSUFBSSxDQUFDNVo7UUFDeEQsS0FBSyxJQUFJLEVBQUUvVCxJQUFJLEVBQUVDLEVBQUUsRUFBRSxJQUFJMjZDLFlBQVlwNEMsTUFBTSxJQUFJLENBQUNxNEMsU0FBUyxFQUNyREosWUFBWWo0QyxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxFQUFFLElBQUksQ0FBQ3doRCxNQUFNLEVBQUVoN0MsTUFBTUMsSUFBSSxDQUFDRCxNQUFNMmMsSUFBTSxJQUFJLENBQUMwK0IsUUFBUSxDQUFDMStCLEdBQUduYSxNQUFNeEMsTUFBTTBPO1FBQ2pHLE9BQU9xRixNQUFNVixNQUFNO0lBQ3ZCO0lBQ0E7Ozs7SUFJQSxHQUNBaU0sV0FBVzNELE1BQU0sRUFBRXROLElBQUksRUFBRTtRQUNyQixJQUFJb3RDLGFBQWEsS0FBS0MsV0FBVyxDQUFDO1FBQ2xDLElBQUkvL0IsT0FBT3lDLFVBQVUsRUFDakJ6QyxPQUFPN0IsT0FBTyxDQUFDNmhDLFdBQVcsQ0FBQyxDQUFDQyxJQUFJQyxJQUFJNzdDLE1BQU1DO1lBQ3RDLElBQUlBLEtBQUswYixPQUFPblosSUFBSSxDQUFDeWUsUUFBUSxDQUFDamhCLElBQUksSUFBSUEsT0FBTzJiLE9BQU9uWixJQUFJLENBQUN5ZSxRQUFRLENBQUNoaEIsRUFBRSxFQUFFO2dCQUNsRXc3QyxhQUFhbi9DLEtBQUsrQyxHQUFHLENBQUNXLE1BQU15N0M7Z0JBQzVCQyxXQUFXcC9DLEtBQUtzRixHQUFHLENBQUMzQixJQUFJeTdDO1lBQzVCO1FBQ0o7UUFDSixJQUFJLy9CLE9BQU9zQyxlQUFlLElBQUl5OUIsV0FBV0QsYUFBYSxNQUNsRCxPQUFPLElBQUksQ0FBQ0QsVUFBVSxDQUFDNy9CLE9BQU9uWixJQUFJO1FBQ3RDLElBQUlrNUMsV0FBVyxDQUFDLEdBQ1osT0FBTyxJQUFJLENBQUNJLFdBQVcsQ0FBQ25nQyxPQUFPblosSUFBSSxFQUFFNkwsS0FBS3dMLEdBQUcsQ0FBQzhCLE9BQU83QixPQUFPLEdBQUcyaEMsWUFBWUM7UUFDL0UsT0FBT3J0QztJQUNYO0lBQ0F5dEMsWUFBWXQ1QyxJQUFJLEVBQUU2TCxJQUFJLEVBQUUwdEMsVUFBVSxFQUFFQyxRQUFRLEVBQUU7UUFDMUMsS0FBSyxJQUFJMXdDLEtBQUs5SSxLQUFLazhCLGFBQWEsQ0FBRTtZQUM5QixJQUFJMStCLE9BQU8xRCxLQUFLc0YsR0FBRyxDQUFDMEosRUFBRXRMLElBQUksRUFBRSs3QyxhQUFhOTdDLEtBQUszRCxLQUFLK0MsR0FBRyxDQUFDaU0sRUFBRXJMLEVBQUUsRUFBRSs3QztZQUM3RCxJQUFJLzdDLEtBQUtELE1BQU07Z0JBQ1gsSUFBSWk4QyxXQUFXejVDLEtBQUt5SixLQUFLLENBQUN6UyxHQUFHLENBQUN1WixNQUFNLENBQUMvUyxPQUFPazhDLFNBQVNELFNBQVNoOEMsRUFBRSxHQUFHQSxLQUFLdUMsS0FBS3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQzlTLE1BQU1nOEM7Z0JBQ3BHLElBQUkzOUMsUUFBUWhDLEtBQUtzRixHQUFHLENBQUMwSixFQUFFdEwsSUFBSSxFQUFFaThDLFNBQVNqOEMsSUFBSSxHQUFHcUUsTUFBTS9ILEtBQUsrQyxHQUFHLENBQUNpTSxFQUFFckwsRUFBRSxFQUFFaThDLE9BQU9qOEMsRUFBRTtnQkFDM0UsSUFBSSxJQUFJLENBQUNrN0MsUUFBUSxFQUFFO29CQUNmLE1BQU9uN0MsT0FBT2k4QyxTQUFTajhDLElBQUksRUFBRUEsT0FDekIsSUFBSSxJQUFJLENBQUNtN0MsUUFBUSxDQUFDLzlDLElBQUksQ0FBQzYrQyxTQUFTajJDLElBQUksQ0FBQ2hHLE9BQU8sSUFBSWk4QyxTQUFTajhDLElBQUksQ0FBQyxHQUFHO3dCQUM3RDFCLFFBQVEwQjt3QkFDUjtvQkFDSjtvQkFDSixNQUFPQyxLQUFLaThDLE9BQU9qOEMsRUFBRSxFQUFFQSxLQUNuQixJQUFJLElBQUksQ0FBQ2s3QyxRQUFRLENBQUMvOUMsSUFBSSxDQUFDOCtDLE9BQU9sMkMsSUFBSSxDQUFDL0YsS0FBS2k4QyxPQUFPbDhDLElBQUksQ0FBQyxHQUFHO3dCQUNuRHFFLE1BQU1wRTt3QkFDTjtvQkFDSjtnQkFDUjtnQkFDQSxJQUFJZ1MsU0FBUyxFQUFFLEVBQUUwSztnQkFDakIsSUFBSWpPLE1BQU0sQ0FBQzFPLE1BQU1DLElBQUlvTyxPQUFTNEQsT0FBT3RTLElBQUksQ0FBQzBPLEtBQUtsUCxLQUFLLENBQUNhLE1BQU1DO2dCQUMzRCxJQUFJZzhDLFlBQVlDLFFBQVE7b0JBQ3BCLElBQUksQ0FBQ2xCLE1BQU0sQ0FBQ04sU0FBUyxHQUFHcDhDLFFBQVEyOUMsU0FBU2o4QyxJQUFJO29CQUM3QyxNQUFPLENBQUMyYyxJQUFJLElBQUksQ0FBQ3ErQixNQUFNLENBQUMveUMsSUFBSSxDQUFDZzBDLFNBQVNqMkMsSUFBSSxNQUFNMlcsRUFBRWhpQixLQUFLLEdBQUcwSixNQUFNNDNDLFNBQVNqOEMsSUFBSSxDQUN6RSxJQUFJLENBQUNxN0MsUUFBUSxDQUFDMStCLEdBQUduYSxNQUFNbWEsRUFBRWhpQixLQUFLLEdBQUdzaEQsU0FBU2o4QyxJQUFJLEVBQUUwTztnQkFDeEQsT0FDSztvQkFDRCtyQyxZQUFZajRDLEtBQUt5SixLQUFLLENBQUN6UyxHQUFHLEVBQUUsSUFBSSxDQUFDd2hELE1BQU0sRUFBRTE4QyxPQUFPK0YsS0FBSyxDQUFDckUsTUFBTTJjLElBQU0sSUFBSSxDQUFDMCtCLFFBQVEsQ0FBQzErQixHQUFHbmEsTUFBTXhDLE1BQU0wTztnQkFDbkc7Z0JBQ0FMLE9BQU9BLEtBQUtzTixNQUFNLENBQUM7b0JBQUV3Z0MsWUFBWTc5QztvQkFBTzg5QyxVQUFVLzNDO29CQUFLNHdCLFFBQVEsQ0FBQ2oxQixNQUFNQyxLQUFPRCxPQUFPMUIsU0FBUzJCLEtBQUtvRTtvQkFBS3FLLEtBQUt1RDtnQkFBTztZQUN2SDtRQUNKO1FBQ0EsT0FBTzVEO0lBQ1g7QUFDSjtBQUVBLE1BQU1ndUMsdUJBQXVCLElBQUlDLE9BQU8sSUFBSSxPQUFPLE9BQU87QUFDMUQsTUFBTUMsV0FBVyxXQUFXLEdBQUUsSUFBSUMsT0FBTywrREFBd0lIO0FBQ2pMLE1BQU1JLFFBQVE7SUFDVixHQUFHO0lBQ0gsR0FBRztJQUNILEdBQUc7SUFDSCxJQUFJO0lBQ0osSUFBSTtJQUNKLElBQUk7SUFDSixJQUFJO0lBQ0osTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sT0FBTztJQUNQLE9BQU87QUFDWDtBQUNBLElBQUlDLG1CQUFtQjtBQUN2QixTQUFTQztJQUNMLElBQUludUM7SUFDSixJQUFJa3VDLG9CQUFvQixRQUFRLE9BQU94OEMsWUFBWSxlQUFlQSxTQUFTL0MsSUFBSSxFQUFFO1FBQzdFLElBQUl5L0MsU0FBUzE4QyxTQUFTL0MsSUFBSSxDQUFDNEssS0FBSztRQUNoQzIwQyxtQkFBbUIsQ0FBQyxDQUFDbHVDLEtBQUtvdUMsT0FBT3Z6QyxPQUFPLE1BQU0sUUFBUW1GLE9BQU8sS0FBSyxJQUFJQSxLQUFLb3VDLE9BQU9DLFVBQVUsS0FBSztJQUNyRztJQUNBLE9BQU9ILG9CQUFvQjtBQUMvQjtBQUNBLE1BQU1JLG9CQUFvQixXQUFXLEdBQUVubEQsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQ2hEUSxTQUFRaS9CLE9BQU87UUFDWCxJQUFJdEssU0FBUzcxQyxnRUFBYUEsQ0FBQ21nRCxTQUFTO1lBQ2hDc0UsUUFBUTtZQUNSQyxjQUFjVDtZQUNkVSxpQkFBaUI7UUFDckI7UUFDQSxJQUFJOU8sT0FBTytPLFdBQVcsR0FBRyxDQUFDUCxtQkFDdEJ4TyxPQUFPNk8sWUFBWSxHQUFHLElBQUlSLE9BQU8sT0FBUXJPLE9BQU82TyxZQUFZLENBQUMzMkMsTUFBTSxFQUFFZzJDO1FBQ3pFLElBQUlsTyxPQUFPOE8sZUFBZSxFQUN0QjlPLE9BQU82TyxZQUFZLEdBQUcsSUFBSVIsT0FBT3JPLE9BQU82TyxZQUFZLENBQUMzMkMsTUFBTSxHQUFHLE1BQU04bkMsT0FBTzhPLGVBQWUsQ0FBQzUyQyxNQUFNLEVBQUVnMkM7UUFDdkcsT0FBT2xPO0lBQ1g7QUFDSjtBQUNBOzs7QUFHQSxHQUNBLFNBQVNnUCxzQkFDVDs7QUFFQSxHQUNBaFAsU0FBUyxDQUFDLENBQUM7SUFDUCxPQUFPO1FBQUMyTyxrQkFBa0Jqc0MsRUFBRSxDQUFDczlCO1FBQVNpUDtLQUFvQjtBQUM5RDtBQUNBLElBQUlDLFVBQVU7QUFDZCxTQUFTRDtJQUNMLE9BQU9DLFdBQVlBLENBQUFBLFVBQVV6aUMsV0FBV1ksU0FBUyxDQUFDO1FBQzlDNWMsWUFBWTRELElBQUksQ0FBRTtZQUNkLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtZQUNaLElBQUksQ0FBQ3dSLFdBQVcsR0FBRzVELFdBQVdZLElBQUk7WUFDbEMsSUFBSSxDQUFDc3NDLGVBQWUsR0FBR3h3QyxPQUFPdEIsTUFBTSxDQUFDO1lBQ3JDLElBQUksQ0FBQyt4QyxTQUFTLEdBQUcsSUFBSSxDQUFDQyxhQUFhLENBQUNoN0MsS0FBS3lKLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ3lpQztZQUNyRCxJQUFJLENBQUM5b0MsV0FBVyxHQUFHLElBQUksQ0FBQ3VwQyxTQUFTLENBQUMvQixVQUFVLENBQUNoNUM7UUFDakQ7UUFDQWc3QyxjQUFjdEUsSUFBSSxFQUFFO1lBQ2hCLE9BQU8sSUFBSTZCLGVBQWU7Z0JBQ3RCQyxRQUFROUIsS0FBSzhELFlBQVk7Z0JBQ3pCL0IsWUFBWSxDQUFDdCtCLEdBQUduYSxNQUFNQztvQkFDbEIsSUFBSSxFQUFFakosR0FBRyxFQUFFLEdBQUdnSixLQUFLeUosS0FBSztvQkFDeEIsSUFBSXpMLE9BQU9wSSw4REFBV0EsQ0FBQ3VrQixDQUFDLENBQUMsRUFBRSxFQUFFO29CQUM3QixJQUFJbmMsUUFBUSxHQUFHO3dCQUNYLElBQUltUSxPQUFPblgsSUFBSXVaLE1BQU0sQ0FBQ3RRO3dCQUN0QixJQUFJbTNCLE9BQU9wM0IsS0FBS3lKLEtBQUssQ0FBQzVDLE9BQU8sRUFBRW8wQyxNQUFNaGxELDhEQUFXQSxDQUFDa1ksS0FBSzNLLElBQUksRUFBRTR6QixNQUFNbjNCLE1BQU1rTyxLQUFLM1EsSUFBSTt3QkFDakYsT0FBT29RLFdBQVd0SyxPQUFPLENBQUM7NEJBQ3RCMkYsUUFBUSxJQUFJaXlDLFVBQVUsQ0FBQzlqQixPQUFRNmpCLE1BQU03akIsSUFBSSxJQUFLLElBQUksQ0FBQ3AzQixJQUFJLENBQUNrbkIscUJBQXFCLEdBQUcsSUFBSSxDQUFDbG5CLElBQUksQ0FBQ3pHLE1BQU07d0JBQ3BHO29CQUNKO29CQUNBLE9BQU8sSUFBSSxDQUFDdWhELGVBQWUsQ0FBQzk4QyxLQUFLLElBQzVCLEtBQUksQ0FBQzg4QyxlQUFlLENBQUM5OEMsS0FBSyxHQUFHNFAsV0FBV3RLLE9BQU8sQ0FBQzt3QkFBRTJGLFFBQVEsSUFBSWt5QyxrQkFBa0J6RSxNQUFNMTRDO29CQUFNLEVBQUM7Z0JBQ3RHO2dCQUNBMjZDLFVBQVVqQyxLQUFLZ0UsV0FBVyxHQUFHcjlDLFlBQVk7WUFDN0M7UUFDSjtRQUNBOGIsT0FBT0EsTUFBTSxFQUFFO1lBQ1gsSUFBSXU5QixPQUFPdjlCLE9BQU8xUCxLQUFLLENBQUNvTyxLQUFLLENBQUN5aUM7WUFDOUIsSUFBSW5oQyxPQUFPaUMsVUFBVSxDQUFDdkQsS0FBSyxDQUFDeWlDLHNCQUFzQjVELE1BQU07Z0JBQ3BELElBQUksQ0FBQ3FFLFNBQVMsR0FBRyxJQUFJLENBQUNDLGFBQWEsQ0FBQ3RFO2dCQUNwQyxJQUFJLENBQUNsbEMsV0FBVyxHQUFHLElBQUksQ0FBQ3VwQyxTQUFTLENBQUMvQixVQUFVLENBQUM3L0IsT0FBT25aLElBQUk7WUFDNUQsT0FDSztnQkFDRCxJQUFJLENBQUN3UixXQUFXLEdBQUcsSUFBSSxDQUFDdXBDLFNBQVMsQ0FBQ2orQixVQUFVLENBQUMzRCxRQUFRLElBQUksQ0FBQzNILFdBQVc7WUFDekU7UUFDSjtJQUNKLEdBQUc7UUFDQ0EsYUFBYWhQLENBQUFBLElBQUtBLEVBQUVnUCxXQUFXO0lBQ25DLEVBQUM7QUFDTDtBQUNBLE1BQU00cEMscUJBQXFCO0FBQzNCLG9FQUFvRTtBQUNwRSwyQkFBMkI7QUFDM0IsU0FBU0MsY0FBY3I5QyxJQUFJO0lBQ3ZCLElBQUlBLFFBQVEsSUFDUixPQUFPbzlDO0lBQ1gsSUFBSXA5QyxRQUFRLElBQ1IsT0FBTztJQUNYLE9BQU8rWixPQUFPdWpDLFlBQVksQ0FBQyxPQUFPdDlDO0FBQ3RDO0FBQ0EsTUFBTW05QywwQkFBMEIzdEM7SUFDNUJwUixZQUFZNkIsT0FBTyxFQUFFRCxJQUFJLENBQUU7UUFDdkIsS0FBSztRQUNMLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtJQUNoQjtJQUNBeEIsR0FBRzBILEtBQUssRUFBRTtRQUFFLE9BQU9BLE1BQU1sRyxJQUFJLElBQUksSUFBSSxDQUFDQSxJQUFJO0lBQUU7SUFDNUNvTCxNQUFNcEosSUFBSSxFQUFFO1FBQ1IsSUFBSXU3QyxLQUFLRixjQUFjLElBQUksQ0FBQ3I5QyxJQUFJO1FBQ2hDLElBQUl3OUMsT0FBT3g3QyxLQUFLeUosS0FBSyxDQUFDZ3lDLE1BQU0sQ0FBQyx1QkFBdUIsTUFBT3hCLENBQUFBLEtBQUssQ0FBQyxJQUFJLENBQUNqOEMsSUFBSSxDQUFDLElBQUksT0FBTyxJQUFJLENBQUNBLElBQUksQ0FBQ3FGLFFBQVEsQ0FBQyxHQUFFO1FBQzNHLElBQUlxRyxTQUFTLElBQUksQ0FBQ3pMLE9BQU8sQ0FBQ3M4QyxNQUFNLElBQUksSUFBSSxDQUFDdDhDLE9BQU8sQ0FBQ3M4QyxNQUFNLENBQUMsSUFBSSxDQUFDdjhDLElBQUksRUFBRXc5QyxNQUFNRDtRQUN6RSxJQUFJN3hDLFFBQ0EsT0FBT0E7UUFDWCxJQUFJeUgsT0FBT3pULFNBQVMwSyxhQUFhLENBQUM7UUFDbEMrSSxLQUFLOFEsV0FBVyxHQUFHczVCO1FBQ25CcHFDLEtBQUt1cUMsS0FBSyxHQUFHRjtRQUNicnFDLEtBQUtsSixZQUFZLENBQUMsY0FBY3V6QztRQUNoQ3JxQyxLQUFLcEosU0FBUyxHQUFHO1FBQ2pCLE9BQU9vSjtJQUNYO0lBQ0FwTyxjQUFjO1FBQUUsT0FBTztJQUFPO0FBQ2xDO0FBQ0EsTUFBTW00QyxrQkFBa0IxdEM7SUFDcEJwUixZQUFZNUMsS0FBSyxDQUFFO1FBQ2YsS0FBSztRQUNMLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtJQUNBZ0QsR0FBRzBILEtBQUssRUFBRTtRQUFFLE9BQU9BLE1BQU0xSyxLQUFLLElBQUksSUFBSSxDQUFDQSxLQUFLO0lBQUU7SUFDOUM0UCxRQUFRO1FBQ0osSUFBSStILE9BQU96VCxTQUFTMEssYUFBYSxDQUFDO1FBQ2xDK0ksS0FBSzhRLFdBQVcsR0FBRztRQUNuQjlRLEtBQUtwSixTQUFTLEdBQUc7UUFDakJvSixLQUFLNUwsS0FBSyxDQUFDL0wsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxHQUFHO1FBQ2hDLE9BQU8yWDtJQUNYO0lBQ0FwTyxjQUFjO1FBQUUsT0FBTztJQUFPO0FBQ2xDO0FBRUEsTUFBTThWLFNBQVMsV0FBVyxHQUFFVCxXQUFXWSxTQUFTLENBQUM7SUFDN0M1YyxhQUFjO1FBQ1YsSUFBSSxDQUFDekMsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDcU8sS0FBSyxHQUFHO1lBQUV6QyxPQUFPO1FBQXlCO0lBQ25EO0lBQ0E0VCxPQUFPQSxNQUFNLEVBQUU7UUFDWCxJQUFJLEVBQUVuWixJQUFJLEVBQUUsR0FBR21aO1FBQ2YsSUFBSXhmLFNBQVNxRyxLQUFLNk0sU0FBUyxDQUFDMnVCLFlBQVksR0FBR3g3QixLQUFLdEcsTUFBTSxHQUNsRHNHLEtBQUtvbkIsaUJBQWlCLEdBQUdwbkIsS0FBS3d2QyxlQUFlLENBQUN4MkMsR0FBRyxHQUFHO1FBQ3hELElBQUlXLFVBQVUsS0FBS0EsVUFBVSxJQUFJLENBQUNBLE1BQU0sRUFBRTtZQUN0QyxJQUFJLENBQUNBLE1BQU0sR0FBR0E7WUFDZCxJQUFJLENBQUNxTyxLQUFLLEdBQUc7Z0JBQUV6QyxPQUFPLENBQUMsZ0JBQWdCLEVBQUU1TCxPQUFPLEVBQUUsQ0FBQztZQUFDO1FBQ3hEO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7OztBQVFBLEdBQ0EsU0FBU2dpRDtJQUNMLE9BQU87UUFBQzlpQztRQUFRVSxrQkFBa0JsTCxFQUFFLENBQUNyTyxDQUFBQTtZQUFVLElBQUlnTTtZQUFJLE9BQU8sQ0FBQyxDQUFDQSxLQUFLaE0sS0FBSzZZLE1BQU0sQ0FBQ0EsT0FBTSxNQUFPLFFBQVE3TSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdoRSxLQUFLLEtBQUs7UUFBTTtLQUFHO0FBQ3pKO0FBRUE7OztBQUdBLEdBQ0EsU0FBUzR6QztJQUNMLE9BQU9DO0FBQ1g7QUFDQSxNQUFNQyxXQUFXLFdBQVcsR0FBRWx1QyxXQUFXTyxJQUFJLENBQUM7SUFBRXJHLE9BQU87QUFBZ0I7QUFDdkUsTUFBTSt6Qyx3QkFBd0IsV0FBVyxHQUFFempDLFdBQVdZLFNBQVMsQ0FBQztJQUM1RDVjLFlBQVk0RCxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUN3UixXQUFXLEdBQUcsSUFBSSxDQUFDdXFDLE9BQU8sQ0FBQy83QztJQUNwQztJQUNBbVosT0FBT0EsTUFBTSxFQUFFO1FBQ1gsSUFBSUEsT0FBT3lDLFVBQVUsSUFBSXpDLE9BQU8yQyxZQUFZLEVBQ3hDLElBQUksQ0FBQ3RLLFdBQVcsR0FBRyxJQUFJLENBQUN1cUMsT0FBTyxDQUFDNWlDLE9BQU9uWixJQUFJO0lBQ25EO0lBQ0ErN0MsUUFBUS83QyxJQUFJLEVBQUU7UUFDVixJQUFJZzhDLGdCQUFnQixDQUFDLEdBQUdud0MsT0FBTyxFQUFFO1FBQ2pDLEtBQUssSUFBSS9DLEtBQUs5SSxLQUFLeUosS0FBSyxDQUFDcFMsU0FBUyxDQUFDb1ksTUFBTSxDQUFFO1lBQ3ZDLElBQUl0QixPQUFPbk8sS0FBS3NpQixXQUFXLENBQUN4WixFQUFFaU4sSUFBSTtZQUNsQyxJQUFJNUgsS0FBSzNRLElBQUksR0FBR3crQyxlQUFlO2dCQUMzQm53QyxLQUFLMU8sSUFBSSxDQUFDMitDLFNBQVNuL0MsS0FBSyxDQUFDd1IsS0FBSzNRLElBQUk7Z0JBQ2xDdytDLGdCQUFnQjd0QyxLQUFLM1EsSUFBSTtZQUM3QjtRQUNKO1FBQ0EsT0FBT29RLFdBQVdoUixHQUFHLENBQUNpUDtJQUMxQjtBQUNKLEdBQUc7SUFDQzJGLGFBQWFoUCxDQUFBQSxJQUFLQSxFQUFFZ1AsV0FBVztBQUNuQztBQUVBLE1BQU15cUMsb0JBQW9CenVDO0lBQ3RCcFIsWUFBWXlULE9BQU8sQ0FBRTtRQUNqQixLQUFLO1FBQ0wsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0F6RyxRQUFRO1FBQ0osSUFBSTh5QyxPQUFPeCtDLFNBQVMwSyxhQUFhLENBQUM7UUFDbEM4ekMsS0FBS24wQyxTQUFTLEdBQUc7UUFDakJtMEMsS0FBSzMyQyxLQUFLLENBQUNtOUIsYUFBYSxHQUFHO1FBQzNCd1osS0FBSzV2QyxXQUFXLENBQUMsT0FBTyxJQUFJLENBQUN1RCxPQUFPLElBQUksV0FBV25TLFNBQVN3SixjQUFjLENBQUMsSUFBSSxDQUFDMkksT0FBTyxJQUFJLElBQUksQ0FBQ0EsT0FBTztRQUN2RyxJQUFJLE9BQU8sSUFBSSxDQUFDQSxPQUFPLElBQUksVUFDdkJxc0MsS0FBS2owQyxZQUFZLENBQUMsY0FBYyxpQkFBaUIsSUFBSSxDQUFDNEgsT0FBTzthQUU3RHFzQyxLQUFLajBDLFlBQVksQ0FBQyxlQUFlO1FBQ3JDLE9BQU9pMEM7SUFDWDtJQUNBMTBDLFNBQVM1USxHQUFHLEVBQUU7UUFDVixJQUFJOFIsUUFBUTlSLElBQUkrSixVQUFVLEdBQUduSixlQUFlWixJQUFJK0osVUFBVSxJQUFJLEVBQUU7UUFDaEUsSUFBSSxDQUFDK0gsTUFBTS9RLE1BQU0sRUFDYixPQUFPO1FBQ1gsSUFBSTROLFFBQVFoTCxPQUFPTSxnQkFBZ0IsQ0FBQ2pFLElBQUlFLFVBQVU7UUFDbEQsSUFBSThCLE9BQU9ELFlBQVkrUCxLQUFLLENBQUMsRUFBRSxFQUFFbkQsTUFBTThOLFNBQVMsSUFBSTtRQUNwRCxJQUFJM0csYUFBYW94QixTQUFTdjRCLE1BQU1tSCxVQUFVO1FBQzFDLElBQUk5VCxLQUFLSyxNQUFNLEdBQUdMLEtBQUtJLEdBQUcsR0FBRzBULGFBQWEsS0FDdEMsT0FBTztZQUFFN1QsTUFBTUQsS0FBS0MsSUFBSTtZQUFFRSxPQUFPSCxLQUFLRyxLQUFLO1lBQUVDLEtBQUtKLEtBQUtJLEdBQUc7WUFBRUMsUUFBUUwsS0FBS0ksR0FBRyxHQUFHMFQ7UUFBVztRQUM5RixPQUFPOVQ7SUFDWDtJQUNBbUssY0FBYztRQUFFLE9BQU87SUFBTztBQUNsQztBQUNBOzs7QUFHQSxHQUNBLFNBQVNvNUMsWUFBWXRzQyxPQUFPO0lBQ3hCLE9BQU91SSxXQUFXWSxTQUFTLENBQUM7UUFDeEI1YyxZQUFZNEQsSUFBSSxDQUFFO1lBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1lBQ1osSUFBSSxDQUFDbThDLFdBQVcsR0FBR3RzQyxVQUNiakMsV0FBV2hSLEdBQUcsQ0FBQztnQkFBQ2dSLFdBQVczRSxNQUFNLENBQUM7b0JBQUVBLFFBQVEsSUFBSWd6QyxZQUFZcHNDO29CQUFVNVYsTUFBTTtnQkFBRSxHQUFHMEMsS0FBSyxDQUFDO2FBQUcsSUFDMUZpUixXQUFXWSxJQUFJO1FBQ3pCO1FBQ0EsSUFBSWdELGNBQWM7WUFBRSxPQUFPLElBQUksQ0FBQ3hSLElBQUksQ0FBQ3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ1csTUFBTSxHQUFHaVcsV0FBV1ksSUFBSSxHQUFHLElBQUksQ0FBQzJ0QyxXQUFXO1FBQUU7SUFDaEcsR0FBRztRQUFFM3FDLGFBQWFoUCxDQUFBQSxJQUFLQSxFQUFFZ1AsV0FBVztJQUFDO0FBQ3pDO0FBRUEscUVBQXFFO0FBQ3JFLGtFQUFrRTtBQUNsRSxNQUFNNHFDLFNBQVM7QUFDZixTQUFTQyxhQUFhNXlDLEtBQUssRUFBRWUsQ0FBQyxFQUFFQyxDQUFDO0lBQzdCLElBQUk2eEMsWUFBWXhpRCxLQUFLK0MsR0FBRyxDQUFDMk4sRUFBRTJELElBQUksRUFBRTFELEVBQUUwRCxJQUFJLEdBQUdvdUMsVUFBVXppRCxLQUFLc0YsR0FBRyxDQUFDb0wsRUFBRTJELElBQUksRUFBRTFELEVBQUUwRCxJQUFJO0lBQzNFLElBQUlzQixTQUFTLEVBQUU7SUFDZixJQUFJakYsRUFBRTFTLEdBQUcsR0FBR3NrRCxVQUFVM3hDLEVBQUUzUyxHQUFHLEdBQUdza0QsVUFBVTV4QyxFQUFFeXdDLEdBQUcsR0FBRyxLQUFLeHdDLEVBQUV3d0MsR0FBRyxHQUFHLEdBQUc7UUFDNUQsSUFBSXVCLFdBQVcxaUQsS0FBSytDLEdBQUcsQ0FBQzJOLEVBQUUxUyxHQUFHLEVBQUUyUyxFQUFFM1MsR0FBRyxHQUFHMmtELFNBQVMzaUQsS0FBS3NGLEdBQUcsQ0FBQ29MLEVBQUUxUyxHQUFHLEVBQUUyUyxFQUFFM1MsR0FBRztRQUNyRSxJQUFLLElBQUl3RixJQUFJZy9DLFdBQVdoL0MsS0FBS2kvQyxTQUFTai9DLElBQUs7WUFDdkMsSUFBSTZRLE9BQU8xRSxNQUFNelMsR0FBRyxDQUFDbVgsSUFBSSxDQUFDN1E7WUFDMUIsSUFBSTZRLEtBQUt4VyxNQUFNLElBQUk4a0QsUUFDZmh0QyxPQUFPdFMsSUFBSSxDQUFDakksOERBQWVBLENBQUN5SCxLQUFLLENBQUN3UixLQUFLM1EsSUFBSSxHQUFHZy9DLFVBQVVydUMsS0FBSzFRLEVBQUUsR0FBR2cvQztRQUMxRTtJQUNKLE9BQ0s7UUFDRCxJQUFJQyxXQUFXNWlELEtBQUsrQyxHQUFHLENBQUMyTixFQUFFeXdDLEdBQUcsRUFBRXh3QyxFQUFFd3dDLEdBQUcsR0FBRzBCLFNBQVM3aUQsS0FBS3NGLEdBQUcsQ0FBQ29MLEVBQUV5d0MsR0FBRyxFQUFFeHdDLEVBQUV3d0MsR0FBRztRQUNyRSxJQUFLLElBQUkzOUMsSUFBSWcvQyxXQUFXaC9DLEtBQUtpL0MsU0FBU2ovQyxJQUFLO1lBQ3ZDLElBQUk2USxPQUFPMUUsTUFBTXpTLEdBQUcsQ0FBQ21YLElBQUksQ0FBQzdRO1lBQzFCLElBQUl4QixRQUFReEcsNkRBQVVBLENBQUM2WSxLQUFLM0ssSUFBSSxFQUFFazVDLFVBQVVqekMsTUFBTTVDLE9BQU8sRUFBRTtZQUMzRCxJQUFJL0ssUUFBUSxHQUFHO2dCQUNYMlQsT0FBT3RTLElBQUksQ0FBQ2pJLDhEQUFlQSxDQUFDaWIsTUFBTSxDQUFDaEMsS0FBSzFRLEVBQUU7WUFDOUMsT0FDSztnQkFDRCxJQUFJb0UsTUFBTXZNLDZEQUFVQSxDQUFDNlksS0FBSzNLLElBQUksRUFBRW01QyxRQUFRbHpDLE1BQU01QyxPQUFPO2dCQUNyRDRJLE9BQU90UyxJQUFJLENBQUNqSSw4REFBZUEsQ0FBQ3lILEtBQUssQ0FBQ3dSLEtBQUszUSxJQUFJLEdBQUcxQixPQUFPcVMsS0FBSzNRLElBQUksR0FBR3FFO1lBQ3JFO1FBQ0o7SUFDSjtJQUNBLE9BQU80TjtBQUNYO0FBQ0EsU0FBU210QyxlQUFlNThDLElBQUksRUFBRWxILENBQUM7SUFDM0IsSUFBSStwQixNQUFNN2lCLEtBQUs2bkIsV0FBVyxDQUFDN25CLEtBQUt5ZSxRQUFRLENBQUNqaEIsSUFBSTtJQUM3QyxPQUFPcWxCLE1BQU0vb0IsS0FBS210QixLQUFLLENBQUNudEIsS0FBS0MsR0FBRyxDQUFDLENBQUM4b0IsSUFBSWhxQixJQUFJLEdBQUdDLENBQUFBLElBQUtrSCxLQUFLa25CLHFCQUFxQixLQUFLLENBQUM7QUFDdEY7QUFDQSxTQUFTMjFCLE9BQU83OEMsSUFBSSxFQUFFdUosS0FBSztJQUN2QixJQUFJdEssU0FBU2UsS0FBSzZsQixXQUFXLENBQUM7UUFBRS9zQixHQUFHeVEsTUFBTStqQixPQUFPO1FBQUVwekIsR0FBR3FQLE1BQU1na0IsT0FBTztJQUFDLEdBQUc7SUFDdEUsSUFBSXBmLE9BQU9uTyxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDdVosTUFBTSxDQUFDdFIsU0FBU25ILE1BQU1tSCxTQUFTa1AsS0FBSzNRLElBQUk7SUFDbEUsSUFBSXk5QyxNQUFNbmpELE1BQU1za0QsU0FBUyxDQUFDLElBQ3BCdGtELE9BQU9xVyxLQUFLeFcsTUFBTSxHQUFHaWxELGVBQWU1OEMsTUFBTXVKLE1BQU0rakIsT0FBTyxJQUNuRHIzQiw4REFBV0EsQ0FBQ2tZLEtBQUszSyxJQUFJLEVBQUV4RCxLQUFLeUosS0FBSyxDQUFDNUMsT0FBTyxFQUFFNUgsU0FBU2tQLEtBQUszUSxJQUFJO0lBQ3ZFLE9BQU87UUFBRTJRLE1BQU1BLEtBQUtpYSxNQUFNO1FBQUU2eUI7UUFBS25qRDtJQUFJO0FBQ3pDO0FBQ0EsU0FBU2dsRCx3QkFBd0I5OEMsSUFBSSxFQUFFdUosS0FBSztJQUN4QyxJQUFJek4sUUFBUStnRCxPQUFPNzhDLE1BQU11SixRQUFROG5CLFdBQVdyeEIsS0FBS3lKLEtBQUssQ0FBQ3BTLFNBQVM7SUFDaEUsSUFBSSxDQUFDeUUsT0FDRCxPQUFPO0lBQ1gsT0FBTztRQUNIcWQsUUFBT0EsTUFBTTtZQUNULElBQUlBLE9BQU95QyxVQUFVLEVBQUU7Z0JBQ25CLElBQUltaEMsV0FBVzVqQyxPQUFPN0IsT0FBTyxDQUFDMkYsTUFBTSxDQUFDOUQsT0FBT2lDLFVBQVUsQ0FBQ3BrQixHQUFHLENBQUNtWCxJQUFJLENBQUNyUyxNQUFNcVMsSUFBSSxFQUFFM1EsSUFBSTtnQkFDaEYsSUFBSXcvQyxVQUFVN2pDLE9BQU8xUCxLQUFLLENBQUN6UyxHQUFHLENBQUN1WixNQUFNLENBQUN3c0M7Z0JBQ3RDamhELFFBQVE7b0JBQUVxUyxNQUFNNnVDLFFBQVE1MEIsTUFBTTtvQkFBRTZ5QixLQUFLbi9DLE1BQU1tL0MsR0FBRztvQkFBRW5qRCxLQUFLZ0MsS0FBSytDLEdBQUcsQ0FBQ2YsTUFBTWhFLEdBQUcsRUFBRWtsRCxRQUFRcmxELE1BQU07Z0JBQUU7Z0JBQ3pGMDVCLFdBQVdBLFNBQVNoYSxHQUFHLENBQUM4QixPQUFPN0IsT0FBTztZQUMxQztRQUNKO1FBQ0F6VyxLQUFJMEksS0FBSyxFQUFFMHpDLE9BQU8sRUFBRWp2QixRQUFRO1lBQ3hCLElBQUl4ekIsTUFBTXFpRCxPQUFPNzhDLE1BQU11SjtZQUN2QixJQUFJLENBQUMvTyxLQUNELE9BQU82MkI7WUFDWCxJQUFJNWhCLFNBQVM0c0MsYUFBYXI4QyxLQUFLeUosS0FBSyxFQUFFM04sT0FBT3RCO1lBQzdDLElBQUksQ0FBQ2lWLE9BQU85WCxNQUFNLEVBQ2QsT0FBTzA1QjtZQUNYLElBQUlyRCxVQUNBLE9BQU85NEIsOERBQWVBLENBQUM4VCxNQUFNLENBQUN5RyxPQUFPcVAsTUFBTSxDQUFDdVMsU0FBUzVoQixNQUFNO2lCQUUzRCxPQUFPdmEsOERBQWVBLENBQUM4VCxNQUFNLENBQUN5RztRQUN0QztJQUNKO0FBQ0o7QUFDQTs7Ozs7O0FBTUEsR0FDQSxTQUFTeXRDLHFCQUFxQmovQyxPQUFPO0lBQ2pDLElBQUl3MEIsU0FBUyxDQUFDeDBCLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRay9DLFdBQVcsS0FBTS9qQyxDQUFBQSxDQUFBQSxJQUFLQSxFQUFFbVQsTUFBTSxJQUFJblQsRUFBRWtYLE1BQU0sSUFBSTtJQUN0SCxPQUFPa2IsV0FBVzkwQixtQkFBbUIsQ0FBQ3JJLEVBQUUsQ0FBQyxDQUFDck8sTUFBTXVKLFFBQVVrcEIsT0FBT2xwQixTQUFTdXpDLHdCQUF3Qjk4QyxNQUFNdUosU0FBUztBQUNySDtBQUNBLE1BQU1xQixPQUFPO0lBQ1R3eUMsS0FBSztRQUFDO1FBQUloa0MsQ0FBQUEsSUFBSyxDQUFDLENBQUNBLEVBQUVtVCxNQUFNO0tBQUM7SUFDMUI4d0IsU0FBUztRQUFDO1FBQUlqa0MsQ0FBQUEsSUFBSyxDQUFDLENBQUNBLEVBQUVzVCxPQUFPO0tBQUM7SUFDL0I0d0IsT0FBTztRQUFDO1FBQUlsa0MsQ0FBQUEsSUFBSyxDQUFDLENBQUNBLEVBQUV3VCxRQUFRO0tBQUM7SUFDOUIyd0IsTUFBTTtRQUFDO1FBQUlua0MsQ0FBQUEsSUFBSyxDQUFDLENBQUNBLEVBQUVvVCxPQUFPO0tBQUM7QUFDaEM7QUFDQSxNQUFNZ3hCLGdCQUFnQjtJQUFFajRDLE9BQU87QUFBb0I7QUFDbkQ7Ozs7OztBQU1BLEdBQ0EsU0FBU2s0QyxnQkFBZ0J4L0MsVUFBVSxDQUFDLENBQUM7SUFDakMsSUFBSSxDQUFDRCxNQUFNMC9DLE9BQU8sR0FBRzl5QyxJQUFJLENBQUMzTSxRQUFRQyxHQUFHLElBQUksTUFBTTtJQUMvQyxJQUFJMmEsU0FBU1QsV0FBV1ksU0FBUyxDQUFDO1FBQzlCNWMsWUFBWTRELElBQUksQ0FBRTtZQUNkLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtZQUNaLElBQUksQ0FBQzI5QyxNQUFNLEdBQUc7UUFDbEI7UUFDQS9nRCxJQUFJK2dELE1BQU0sRUFBRTtZQUNSLElBQUksSUFBSSxDQUFDQSxNQUFNLElBQUlBLFFBQVE7Z0JBQ3ZCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtnQkFDZCxJQUFJLENBQUMzOUMsSUFBSSxDQUFDbVosTUFBTSxDQUFDLEVBQUU7WUFDdkI7UUFDSjtJQUNKLEdBQUc7UUFDQ1IsZ0JBQWdCO1lBQ1orUyxTQUFRdFMsQ0FBQztnQkFDTCxJQUFJLENBQUN4YyxHQUFHLENBQUN3YyxFQUFFamIsT0FBTyxJQUFJSCxRQUFRMC9DLE9BQU90a0M7WUFDekM7WUFDQXdrQyxPQUFNeGtDLENBQUM7Z0JBQ0gsSUFBSUEsRUFBRWpiLE9BQU8sSUFBSUgsUUFBUSxDQUFDMC9DLE9BQU90a0MsSUFDN0IsSUFBSSxDQUFDeGMsR0FBRyxDQUFDO1lBQ2pCO1lBQ0FpaEQsV0FBVXprQyxDQUFDO2dCQUNQLElBQUksQ0FBQ3hjLEdBQUcsQ0FBQzhnRCxPQUFPdGtDO1lBQ3BCO1FBQ0o7SUFDSjtJQUNBLE9BQU87UUFDSFA7UUFDQTJ5QixXQUFXanlCLGlCQUFpQixDQUFDbEwsRUFBRSxDQUFDck8sQ0FBQUE7WUFBVSxJQUFJZ007WUFBSSxPQUFPLENBQUMsQ0FBQ0EsS0FBS2hNLEtBQUs2WSxNQUFNLENBQUNBLE9BQU0sTUFBTyxRQUFRN00sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMnhDLE1BQU0sSUFBSUgsZ0JBQWdCO1FBQU07S0FDaEs7QUFDTDtBQUVBLE1BQU1NLFVBQVU7QUFDaEIsTUFBTUM7SUFDRjNoRCxZQUFZNEQsSUFBSSxFQUFFNlgsS0FBSyxFQUFFbW1DLGlCQUFpQixFQUFFQyxpQkFBaUIsQ0FBRTtRQUMzRCxJQUFJLENBQUNwbUMsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ21tQyxpQkFBaUIsR0FBR0E7UUFDekIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0E7UUFDekIsSUFBSSxDQUFDeHVCLEtBQUssR0FBR3p2QixLQUFLeUosS0FBSyxDQUFDb08sS0FBSyxDQUFDQTtRQUM5QixJQUFJLENBQUNxbUMsUUFBUSxHQUFHLElBQUksQ0FBQ3p1QixLQUFLLENBQUNnRCxNQUFNLENBQUNoYixDQUFBQSxJQUFLQTtRQUN2QyxJQUFJdlksT0FBTztRQUNYLElBQUksQ0FBQ2kvQyxZQUFZLEdBQUcsSUFBSSxDQUFDRCxRQUFRLENBQUM3bUMsR0FBRyxDQUFDSSxDQUFBQSxJQUFLdlksT0FBTzgrQyxrQkFBa0J2bUMsR0FBR3ZZO0lBQzNFO0lBQ0FpYSxPQUFPQSxNQUFNLEVBQUU4TCxLQUFLLEVBQUU7UUFDbEIsSUFBSWpaO1FBQ0osSUFBSXlqQixRQUFRdFcsT0FBTzFQLEtBQUssQ0FBQ29PLEtBQUssQ0FBQyxJQUFJLENBQUNBLEtBQUs7UUFDekMsSUFBSXFtQyxXQUFXenVCLE1BQU1nRCxNQUFNLENBQUMzNUIsQ0FBQUEsSUFBS0E7UUFDakMsSUFBSTIyQixVQUFVLElBQUksQ0FBQ0EsS0FBSyxFQUFFO1lBQ3RCLEtBQUssSUFBSWhZLEtBQUssSUFBSSxDQUFDMG1DLFlBQVksQ0FDM0IsSUFBSTFtQyxFQUFFMEIsTUFBTSxFQUNSMUIsRUFBRTBCLE1BQU0sQ0FBQ0E7WUFDakIsT0FBTztRQUNYO1FBQ0EsSUFBSWdsQyxlQUFlLEVBQUUsRUFBRUMsV0FBV241QixRQUFRLEVBQUUsR0FBRztRQUMvQyxJQUFLLElBQUkzbkIsSUFBSSxHQUFHQSxJQUFJNGdELFNBQVN2bUQsTUFBTSxFQUFFMkYsSUFBSztZQUN0QyxJQUFJK2dELE1BQU1ILFFBQVEsQ0FBQzVnRCxFQUFFLEVBQUVpeUMsUUFBUSxDQUFDO1lBQ2hDLElBQUksQ0FBQzhPLEtBQ0Q7WUFDSixJQUFLLElBQUkvZ0QsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQzRnRCxRQUFRLENBQUN2bUQsTUFBTSxFQUFFMkYsSUFBSztnQkFDM0MsSUFBSTRHLFFBQVEsSUFBSSxDQUFDZzZDLFFBQVEsQ0FBQzVnRCxFQUFFO2dCQUM1QixJQUFJNEcsU0FBU0EsTUFBTThFLE1BQU0sSUFBSXExQyxJQUFJcjFDLE1BQU0sRUFDbkN1bUMsUUFBUWp5QztZQUNoQjtZQUNBLElBQUlpeUMsUUFBUSxHQUFHO2dCQUNYNE8sWUFBWSxDQUFDN2dELEVBQUUsR0FBRyxJQUFJLENBQUMwZ0QsaUJBQWlCLENBQUNLLEtBQUsvZ0QsSUFBSTZnRCxZQUFZLENBQUM3Z0QsSUFBSSxFQUFFLEdBQUc7Z0JBQ3hFLElBQUk4Z0QsVUFDQUEsUUFBUSxDQUFDOWdELEVBQUUsR0FBRyxDQUFDLENBQUMrZ0QsSUFBSXA1QixLQUFLO1lBQ2pDLE9BQ0s7Z0JBQ0QsSUFBSXE1QixjQUFjSCxZQUFZLENBQUM3Z0QsRUFBRSxHQUFHLElBQUksQ0FBQzZnRCxZQUFZLENBQUM1TyxNQUFNO2dCQUM1RCxJQUFJNk8sVUFDQUEsUUFBUSxDQUFDOWdELEVBQUUsR0FBRzJuQixLQUFLLENBQUNzcUIsTUFBTTtnQkFDOUIsSUFBSStPLFlBQVlubEMsTUFBTSxFQUNsQm1sQyxZQUFZbmxDLE1BQU0sQ0FBQ0E7WUFDM0I7UUFDSjtRQUNBLEtBQUssSUFBSTFCLEtBQUssSUFBSSxDQUFDMG1DLFlBQVksQ0FDM0IsSUFBSUEsYUFBYXo3QyxPQUFPLENBQUMrVSxLQUFLLEdBQUc7WUFDN0IsSUFBSSxDQUFDd21DLGlCQUFpQixDQUFDeG1DO1lBQ3RCekwsQ0FBQUEsS0FBS3lMLEVBQUU5VSxPQUFPLE1BQU0sUUFBUXFKLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR25ELElBQUksQ0FBQzRPO1FBQ2xFO1FBQ0osSUFBSXdOLE9BQU87WUFDUG01QixTQUFTOS9CLE9BQU8sQ0FBQyxDQUFDNmhCLEtBQUs3aUMsSUFBTTJuQixLQUFLLENBQUMzbkIsRUFBRSxHQUFHNmlDO1lBQ3hDbGIsTUFBTXR0QixNQUFNLEdBQUd5bUQsU0FBU3ptRCxNQUFNO1FBQ2xDO1FBQ0EsSUFBSSxDQUFDODNCLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN5dUIsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFlBQVksR0FBR0E7UUFDcEIsT0FBTztJQUNYO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLFNBQVNELFNBQVN2UyxTQUFTLENBQUMsQ0FBQztJQUN6QixPQUFPNFMsY0FBY2x3QyxFQUFFLENBQUNzOUI7QUFDNUI7QUFDQSxTQUFTNlMsWUFBWXgrQyxJQUFJO0lBQ3JCLElBQUksRUFBRTdHLEdBQUcsRUFBRSxHQUFHNkc7SUFDZCxPQUFPO1FBQUVoSCxLQUFLO1FBQUdILE1BQU07UUFBR0ksUUFBUUUsSUFBSUUsV0FBVztRQUFFTixPQUFPSSxJQUFJQyxVQUFVO0lBQUM7QUFDN0U7QUFDQSxNQUFNbWxELGdCQUFnQixXQUFXLEdBQUVwcEQsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQzVDUSxTQUFTQyxDQUFBQTtRQUNMLElBQUlqTCxJQUFJeUMsSUFBSXM4QjtRQUNaLE9BQVE7WUFDSmp3QyxVQUFVcUwsUUFBUUYsR0FBRyxHQUFHLGFBQWEsQ0FBQyxDQUFDK0YsS0FBS2lMLE9BQU9yTyxJQUFJLENBQUM4dEMsQ0FBQUEsT0FBUUEsS0FBSzU3QyxRQUFRLE9BQU8sUUFBUWtSLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2xSLFFBQVEsS0FBSztZQUNySXRDLFFBQVEsQ0FBQyxDQUFDaVcsS0FBS3dJLE9BQU9yTyxJQUFJLENBQUM4dEMsQ0FBQUEsT0FBUUEsS0FBS2wrQyxNQUFNLE9BQU8sUUFBUWlXLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pXLE1BQU0sS0FBSztZQUNwR2ltRCxjQUFjLENBQUMsQ0FBQzFULEtBQUs5ekIsT0FBT3JPLElBQUksQ0FBQzh0QyxDQUFBQSxPQUFRQSxLQUFLK0gsWUFBWSxPQUFPLFFBQVExVCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcwVCxZQUFZLEtBQUtEO1FBQzFIO0lBQ0o7QUFDSjtBQUNBLE1BQU1FLGNBQWMsV0FBVyxHQUFFLElBQUlqTjtBQUNyQyxNQUFNa04sZ0JBQWdCLFdBQVcsR0FBRXZtQyxXQUFXWSxTQUFTLENBQUM7SUFDcEQ1YyxZQUFZNEQsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDaWxCLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDbVcsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDd2pCLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLGVBQWUsR0FBRztRQUN2QixJQUFJLENBQUNDLGNBQWMsR0FBRyxDQUFDO1FBQ3ZCLElBQUluVCxTQUFTM3JDLEtBQUt5SixLQUFLLENBQUNvTyxLQUFLLENBQUMwbUM7UUFDOUIsSUFBSSxDQUFDempELFFBQVEsR0FBRzZ3QyxPQUFPN3dDLFFBQVE7UUFDL0IsSUFBSSxDQUFDdEMsTUFBTSxHQUFHbXpDLE9BQU9uekMsTUFBTTtRQUMzQixJQUFJLENBQUN1bUQsT0FBTyxHQUFHLytDLEtBQUtxdUMsWUFBWTtRQUNoQyxJQUFJLENBQUMyUSxlQUFlO1FBQ3BCLElBQUksQ0FBQ3pKLFVBQVUsR0FBRztZQUFFaGpCLE1BQU0sSUFBSSxDQUFDMHNCLFdBQVcsQ0FBQzl6QixJQUFJLENBQUMsSUFBSTtZQUFHZ2pCLE9BQU8sSUFBSSxDQUFDK1EsWUFBWSxDQUFDL3pCLElBQUksQ0FBQyxJQUFJO1lBQUdqdEIsS0FBSyxJQUFJO1FBQUM7UUFDdEcsSUFBSSxDQUFDaWhELGNBQWMsR0FBRyxPQUFPclcsa0JBQWtCLGFBQWEsSUFBSUEsZUFBZSxJQUFNLElBQUksQ0FBQ3NXLFdBQVcsTUFBTTtRQUMzRyxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJdEIsbUJBQW1CLzlDLE1BQU1zL0MsYUFBYSxDQUFDN25DLEdBQUdsRixJQUFNLElBQUksQ0FBQ2d0QyxhQUFhLENBQUM5bkMsR0FBR2xGLElBQUlrRixDQUFBQTtZQUN6RixJQUFJLElBQUksQ0FBQzBuQyxjQUFjLEVBQ25CLElBQUksQ0FBQ0EsY0FBYyxDQUFDSyxTQUFTLENBQUMvbkMsRUFBRTdnQixHQUFHO1lBQ3ZDNmdCLEVBQUU3Z0IsR0FBRyxDQUFDc3JCLE1BQU07UUFDaEI7UUFDQSxJQUFJLENBQUMrQyxLQUFLLEdBQUcsSUFBSSxDQUFDbzZCLE9BQU8sQ0FBQ25CLFFBQVEsQ0FBQzdtQyxHQUFHLENBQUNJLENBQUFBLElBQUssQ0FBQyxDQUFDQSxFQUFFd04sS0FBSztRQUNyRCxJQUFJLENBQUN3NkIsb0JBQW9CLEdBQUcsT0FBT3hXLHdCQUF3QixhQUFhLElBQUlBLHFCQUFxQkMsQ0FBQUE7WUFDN0YsSUFBSXZzQixLQUFLQyxHQUFHLEtBQUssSUFBSSxDQUFDaWlDLGVBQWUsR0FBRyxNQUNwQzNWLFFBQVF2eEMsTUFBTSxHQUFHLEtBQUt1eEMsT0FBTyxDQUFDQSxRQUFRdnhDLE1BQU0sR0FBRyxFQUFFLENBQUN5eEMsaUJBQWlCLEdBQUcsR0FDdEUsSUFBSSxDQUFDZ1csV0FBVztRQUN4QixHQUFHO1lBQUU3VixXQUFXO2dCQUFDO2FBQUU7UUFBQyxLQUFLO1FBQ3pCLElBQUksQ0FBQ21XLG1CQUFtQjtRQUN4QjEvQyxLQUFLN0csR0FBRyxDQUFDbXlCLGdCQUFnQixDQUFDLFVBQVUsSUFBSSxDQUFDOHpCLFdBQVcsR0FBRyxJQUFJLENBQUNBLFdBQVcsQ0FBQ2owQixJQUFJLENBQUMsSUFBSTtRQUNqRixJQUFJLENBQUN3MEIsWUFBWTtJQUNyQjtJQUNBWCxrQkFBa0I7UUFDZCxJQUFJLElBQUksQ0FBQ3htRCxNQUFNLEVBQUU7WUFDYixJQUFJLENBQUNvbkQsU0FBUyxHQUFHbGlELFNBQVMwSyxhQUFhLENBQUM7WUFDeEMsSUFBSSxDQUFDdzNDLFNBQVMsQ0FBQ3I2QyxLQUFLLENBQUN6SyxRQUFRLEdBQUc7WUFDaEMsSUFBSSxDQUFDOGtELFNBQVMsQ0FBQzczQyxTQUFTLEdBQUcsSUFBSSxDQUFDL0gsSUFBSSxDQUFDcXVDLFlBQVk7WUFDakQsSUFBSSxDQUFDNzFDLE1BQU0sQ0FBQzhULFdBQVcsQ0FBQyxJQUFJLENBQUNzekMsU0FBUztRQUMxQyxPQUNLO1lBQ0QsSUFBSSxDQUFDQSxTQUFTLEdBQUcsSUFBSSxDQUFDNS9DLElBQUksQ0FBQ3BKLEdBQUc7UUFDbEM7SUFDSjtJQUNBOG9ELHNCQUFzQjtRQUNsQixJQUFJLElBQUksQ0FBQ0Qsb0JBQW9CLEVBQUU7WUFDM0IsSUFBSSxDQUFDQSxvQkFBb0IsQ0FBQy9WLFVBQVU7WUFDcEMsS0FBSyxJQUFJbVcsV0FBVyxJQUFJLENBQUNSLE9BQU8sQ0FBQ2xCLFlBQVksQ0FDekMsSUFBSSxDQUFDc0Isb0JBQW9CLENBQUMxVyxPQUFPLENBQUM4VyxRQUFRanBELEdBQUc7UUFDckQ7SUFDSjtJQUNBd29ELGNBQWM7UUFDVixJQUFJLElBQUksQ0FBQ04sY0FBYyxHQUFHLEdBQ3RCLElBQUksQ0FBQ0EsY0FBYyxHQUFHanlCLFdBQVc7WUFDN0IsSUFBSSxDQUFDaXlCLGNBQWMsR0FBRyxDQUFDO1lBQ3ZCLElBQUksQ0FBQ2EsWUFBWTtRQUNyQixHQUFHO0lBQ1g7SUFDQXhtQyxPQUFPQSxNQUFNLEVBQUU7UUFDWCxJQUFJQSxPQUFPZ0MsWUFBWSxDQUFDeGpCLE1BQU0sRUFDMUIsSUFBSSxDQUFDa25ELGVBQWUsR0FBR2xpQyxLQUFLQyxHQUFHO1FBQ25DLElBQUlrUyxVQUFVLElBQUksQ0FBQ3V3QixPQUFPLENBQUNsbUMsTUFBTSxDQUFDQSxRQUFRLElBQUksQ0FBQzhMLEtBQUs7UUFDcEQsSUFBSTZKLFNBQ0EsSUFBSSxDQUFDNHdCLG1CQUFtQjtRQUM1QixJQUFJSSxnQkFBZ0JoeEIsV0FBVzNWLE9BQU93QyxlQUFlO1FBQ3JELElBQUlva0MsWUFBWTVtQyxPQUFPMVAsS0FBSyxDQUFDb08sS0FBSyxDQUFDMG1DO1FBQ25DLElBQUl3QixVQUFVamxELFFBQVEsSUFBSSxJQUFJLENBQUNBLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQzhqRCxZQUFZLEVBQUU7WUFDM0QsSUFBSSxDQUFDOWpELFFBQVEsR0FBR2lsRCxVQUFVamxELFFBQVE7WUFDbEMsS0FBSyxJQUFJMmMsS0FBSyxJQUFJLENBQUM0bkMsT0FBTyxDQUFDbEIsWUFBWSxDQUNuQzFtQyxFQUFFN2dCLEdBQUcsQ0FBQzJPLEtBQUssQ0FBQ3pLLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7WUFDeENnbEQsZ0JBQWdCO1FBQ3BCO1FBQ0EsSUFBSUMsVUFBVXZuRCxNQUFNLElBQUksSUFBSSxDQUFDQSxNQUFNLEVBQUU7WUFDakMsSUFBSSxJQUFJLENBQUNBLE1BQU0sRUFDWCxJQUFJLENBQUNvbkQsU0FBUyxDQUFDMTlCLE1BQU07WUFDekIsSUFBSSxDQUFDMXBCLE1BQU0sR0FBR3VuRCxVQUFVdm5ELE1BQU07WUFDOUIsSUFBSSxDQUFDd21ELGVBQWU7WUFDcEIsS0FBSyxJQUFJdm5DLEtBQUssSUFBSSxDQUFDNG5DLE9BQU8sQ0FBQ2xCLFlBQVksQ0FDbkMsSUFBSSxDQUFDeUIsU0FBUyxDQUFDdHpDLFdBQVcsQ0FBQ21MLEVBQUU3Z0IsR0FBRztZQUNwQ2twRCxnQkFBZ0I7UUFDcEIsT0FDSyxJQUFJLElBQUksQ0FBQ3RuRCxNQUFNLElBQUksSUFBSSxDQUFDd0gsSUFBSSxDQUFDcXVDLFlBQVksSUFBSSxJQUFJLENBQUMwUSxPQUFPLEVBQUU7WUFDNUQsSUFBSSxDQUFDQSxPQUFPLEdBQUcsSUFBSSxDQUFDYSxTQUFTLENBQUM3M0MsU0FBUyxHQUFHLElBQUksQ0FBQy9ILElBQUksQ0FBQ3F1QyxZQUFZO1FBQ3BFO1FBQ0EsSUFBSXlSLGVBQ0EsSUFBSSxDQUFDSCxZQUFZO0lBQ3pCO0lBQ0FKLGNBQWNNLE9BQU8sRUFBRTNnRCxJQUFJLEVBQUU7UUFDekIsSUFBSW8vQyxjQUFjdUIsUUFBUTcyQyxNQUFNLENBQUMsSUFBSSxDQUFDaEosSUFBSTtRQUMxQyxJQUFJVCxTQUFTTCxPQUFPQSxLQUFLdEksR0FBRyxHQUFHO1FBQy9CMG5ELFlBQVkxbkQsR0FBRyxDQUFDcVYsU0FBUyxDQUFDQyxHQUFHLENBQUM7UUFDOUIsSUFBSTJ6QyxRQUFRRyxLQUFLLElBQUksQ0FBQzFCLFlBQVkxbkQsR0FBRyxDQUFDMjVDLGFBQWEsQ0FBQyxvQ0FBb0M7WUFDcEYsSUFBSXlQLFFBQVF0aUQsU0FBUzBLLGFBQWEsQ0FBQztZQUNuQzQzQyxNQUFNajRDLFNBQVMsR0FBRztZQUNsQnUyQyxZQUFZMW5ELEdBQUcsQ0FBQ3NLLFlBQVksQ0FBQzgrQyxPQUFPemdEO1FBQ3hDO1FBQ0ErK0MsWUFBWTFuRCxHQUFHLENBQUMyTyxLQUFLLENBQUN6SyxRQUFRLEdBQUcsSUFBSSxDQUFDQSxRQUFRO1FBQzlDd2pELFlBQVkxbkQsR0FBRyxDQUFDMk8sS0FBSyxDQUFDdk0sR0FBRyxHQUFHOGtEO1FBQzVCUSxZQUFZMW5ELEdBQUcsQ0FBQzJPLEtBQUssQ0FBQzFNLElBQUksR0FBRztRQUM3QixJQUFJLENBQUMrbUQsU0FBUyxDQUFDMStDLFlBQVksQ0FBQ285QyxZQUFZMW5ELEdBQUcsRUFBRTJJO1FBQzdDLElBQUkrK0MsWUFBWW5QLEtBQUssRUFDakJtUCxZQUFZblAsS0FBSyxDQUFDLElBQUksQ0FBQ252QyxJQUFJO1FBQy9CLElBQUksSUFBSSxDQUFDbS9DLGNBQWMsRUFDbkIsSUFBSSxDQUFDQSxjQUFjLENBQUNwVyxPQUFPLENBQUN1VixZQUFZMW5ELEdBQUc7UUFDL0MsT0FBTzBuRDtJQUNYO0lBQ0EzN0MsVUFBVTtRQUNOLElBQUlxSixJQUFJeUMsSUFBSXM4QjtRQUNaLElBQUksQ0FBQy9xQyxJQUFJLENBQUM3RyxHQUFHLENBQUNnekIsbUJBQW1CLENBQUMsVUFBVSxJQUFJLENBQUNpekIsV0FBVztRQUM1RCxLQUFLLElBQUlkLGVBQWUsSUFBSSxDQUFDZSxPQUFPLENBQUNsQixZQUFZLENBQUU7WUFDL0NHLFlBQVkxbkQsR0FBRyxDQUFDc3JCLE1BQU07WUFDckJsVyxDQUFBQSxLQUFLc3lDLFlBQVkzN0MsT0FBTyxNQUFNLFFBQVFxSixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUduRCxJQUFJLENBQUN5MUM7UUFDNUU7UUFDQSxJQUFJLElBQUksQ0FBQzlsRCxNQUFNLEVBQ1gsSUFBSSxDQUFDb25ELFNBQVMsQ0FBQzE5QixNQUFNO1FBQ3hCelQsQ0FBQUEsS0FBSyxJQUFJLENBQUMwd0MsY0FBYyxNQUFNLFFBQVExd0MsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaTdCLFVBQVU7UUFDNUVxQixDQUFBQSxLQUFLLElBQUksQ0FBQzBVLG9CQUFvQixNQUFNLFFBQVExVSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdyQixVQUFVO1FBQ25Gc0IsYUFBYSxJQUFJLENBQUM4VCxjQUFjO0lBQ3BDO0lBQ0FHLGNBQWM7UUFDVixJQUFJZ0IsU0FBUyxJQUFJLENBQUNqZ0QsSUFBSSxDQUFDcEosR0FBRyxDQUFDd0UscUJBQXFCO1FBQ2hELElBQUk3QixTQUFTLEdBQUdHLFNBQVMsR0FBR3dtRCxlQUFlO1FBQzNDLElBQUksSUFBSSxDQUFDcGxELFFBQVEsSUFBSSxXQUFXLElBQUksQ0FBQ3VrRCxPQUFPLENBQUNsQixZQUFZLENBQUN4bUQsTUFBTSxFQUFFO1lBQzlELElBQUksRUFBRWYsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDeW9ELE9BQU8sQ0FBQ2xCLFlBQVksQ0FBQyxFQUFFO1lBQzFDLElBQUloNEMsUUFBUU4sS0FBSyxFQUFFO2dCQUNmLG1EQUFtRDtnQkFDbkQsNkRBQTZEO2dCQUM3RCxlQUFlO2dCQUNmcTZDLGVBQWV0cEQsSUFBSTJqQyxZQUFZLElBQUksSUFBSSxDQUFDcWxCLFNBQVMsQ0FBQ2xwRCxhQUFhLENBQUNpRSxJQUFJO1lBQ3hFLE9BQ0ssSUFBSS9ELElBQUkyTyxLQUFLLENBQUN2TSxHQUFHLElBQUk4a0QsV0FBV2xuRCxJQUFJMk8sS0FBSyxDQUFDMU0sSUFBSSxJQUFJLE9BQU87Z0JBQzFELDREQUE0RDtnQkFDNUQscUNBQXFDO2dCQUNyQyxJQUFJRCxPQUFPaEMsSUFBSXdFLHFCQUFxQjtnQkFDcEM4a0QsZUFBZXBtRCxLQUFLQyxHQUFHLENBQUNuQixLQUFLSSxHQUFHLEdBQUcsU0FBUyxLQUFLYyxLQUFLQyxHQUFHLENBQUNuQixLQUFLQyxJQUFJLElBQUk7WUFDM0U7UUFDSjtRQUNBLElBQUlxbkQsZ0JBQWdCLElBQUksQ0FBQ3BsRCxRQUFRLElBQUksWUFBWTtZQUM3QyxJQUFJLElBQUksQ0FBQ3RDLE1BQU0sRUFBRTtnQkFDYixJQUFJSSxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDNEMscUJBQXFCO2dCQUM1QyxJQUFJeEMsS0FBS1ksS0FBSyxJQUFJWixLQUFLZSxNQUFNLEVBQUU7b0JBQzNCSixTQUFTWCxLQUFLWSxLQUFLLEdBQUcsSUFBSSxDQUFDaEIsTUFBTSxDQUFDaUIsV0FBVztvQkFDN0NDLFNBQVNkLEtBQUtlLE1BQU0sR0FBRyxJQUFJLENBQUNuQixNQUFNLENBQUNvQixZQUFZO2dCQUNuRDtZQUNKLE9BQ0s7Z0JBQ0EsR0FBRUwsTUFBTSxFQUFFRyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUNzRyxJQUFJLENBQUM2TSxTQUFTO1lBQzdDO1FBQ0o7UUFDQSxPQUFPO1lBQ0hvekM7WUFDQXpuRCxRQUFRLElBQUksQ0FBQ0EsTUFBTSxHQUFHLElBQUksQ0FBQ29uRCxTQUFTLENBQUN4a0QscUJBQXFCLEtBQUs2a0Q7WUFDL0RoZ0QsS0FBSyxJQUFJLENBQUNvL0MsT0FBTyxDQUFDbkIsUUFBUSxDQUFDN21DLEdBQUcsQ0FBQyxDQUFDSSxHQUFHbmE7Z0JBQy9CLElBQUk2aUQsS0FBSyxJQUFJLENBQUNkLE9BQU8sQ0FBQ2xCLFlBQVksQ0FBQzdnRCxFQUFFO2dCQUNyQyxPQUFPNmlELEdBQUdDLFNBQVMsR0FBR0QsR0FBR0MsU0FBUyxDQUFDM29DLEVBQUV4WCxHQUFHLElBQUksSUFBSSxDQUFDRCxJQUFJLENBQUM2bkIsV0FBVyxDQUFDcFEsRUFBRXhYLEdBQUc7WUFDM0U7WUFDQW0zQixNQUFNLElBQUksQ0FBQ2lvQixPQUFPLENBQUNsQixZQUFZLENBQUM5bUMsR0FBRyxDQUFDLENBQUMsRUFBRXpnQixHQUFHLEVBQUUsR0FBS0EsSUFBSXdFLHFCQUFxQjtZQUMxRWlsRCxPQUFPLElBQUksQ0FBQ3JnRCxJQUFJLENBQUN5SixLQUFLLENBQUNvTyxLQUFLLENBQUMwbUMsZUFBZUUsWUFBWSxDQUFDLElBQUksQ0FBQ3orQyxJQUFJO1lBQ2xFekc7WUFBUUc7WUFBUXdtRDtRQUNwQjtJQUNKO0lBQ0FoQixhQUFhcG5CLFFBQVEsRUFBRTtRQUNuQixJQUFJOXJCO1FBQ0osSUFBSThyQixTQUFTb29CLFlBQVksRUFBRTtZQUN2QixJQUFJLENBQUN0QixZQUFZLEdBQUc7WUFDcEIsSUFBSSxDQUFDOWpELFFBQVEsR0FBRztZQUNoQixLQUFLLElBQUkyYyxLQUFLLElBQUksQ0FBQzRuQyxPQUFPLENBQUNsQixZQUFZLENBQ25DMW1DLEVBQUU3Z0IsR0FBRyxDQUFDMk8sS0FBSyxDQUFDekssUUFBUSxHQUFHO1FBQy9CO1FBQ0EsSUFBSSxFQUFFbWxELE1BQU0sRUFBRUksS0FBSyxFQUFFOW1ELE1BQU0sRUFBRUcsTUFBTSxFQUFFLEdBQUdvK0I7UUFDeEMsSUFBSXdvQixTQUFTLEVBQUU7UUFDZixJQUFLLElBQUloakQsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQytoRCxPQUFPLENBQUNuQixRQUFRLENBQUN2bUQsTUFBTSxFQUFFMkYsSUFBSztZQUNuRCxJQUFJdWlELFVBQVUsSUFBSSxDQUFDUixPQUFPLENBQUNuQixRQUFRLENBQUM1Z0QsRUFBRSxFQUFFaWpELFFBQVEsSUFBSSxDQUFDbEIsT0FBTyxDQUFDbEIsWUFBWSxDQUFDN2dELEVBQUUsRUFBRSxFQUFFMUcsR0FBRyxFQUFFLEdBQUcycEQ7WUFDeEYsSUFBSXRnRCxNQUFNNjNCLFNBQVM3M0IsR0FBRyxDQUFDM0MsRUFBRSxFQUFFODVCLE9BQU9VLFNBQVNWLElBQUksQ0FBQzk1QixFQUFFO1lBQ2xELGdEQUFnRDtZQUNoRCxJQUFJLENBQUMyQyxPQUFPQSxJQUFJaEgsTUFBTSxJQUFJYSxLQUFLc0YsR0FBRyxDQUFDNmdELE9BQU9qbkQsR0FBRyxFQUFFcW5ELE1BQU1ybkQsR0FBRyxLQUNwRGlILElBQUlqSCxHQUFHLElBQUljLEtBQUsrQyxHQUFHLENBQUNvakQsT0FBT2huRCxNQUFNLEVBQUVvbkQsTUFBTXBuRCxNQUFNLEtBQy9DZ0gsSUFBSWxILEtBQUssR0FBR2UsS0FBS3NGLEdBQUcsQ0FBQzZnRCxPQUFPcG5ELElBQUksRUFBRXduRCxNQUFNeG5ELElBQUksSUFBSSxNQUNoRG9ILElBQUlwSCxJQUFJLEdBQUdpQixLQUFLK0MsR0FBRyxDQUFDb2pELE9BQU9sbkQsS0FBSyxFQUFFc25ELE1BQU10bkQsS0FBSyxJQUFJLElBQUk7Z0JBQ3JEbkMsSUFBSTJPLEtBQUssQ0FBQ3ZNLEdBQUcsR0FBRzhrRDtnQkFDaEI7WUFDSjtZQUNBLElBQUlrQyxRQUFRSCxRQUFRRyxLQUFLLEdBQUdPLE1BQU0zcEQsR0FBRyxDQUFDMjVDLGFBQWEsQ0FBQyx1QkFBdUI7WUFDM0UsSUFBSWlRLGNBQWNSLFFBQVEsRUFBRSxjQUFjLE1BQUs7WUFDL0MsSUFBSXhtRCxRQUFRNDlCLEtBQUtyK0IsS0FBSyxHQUFHcStCLEtBQUt2K0IsSUFBSSxFQUFFYyxTQUFTLENBQUNxUyxLQUFLMHlDLFlBQVk3OUMsR0FBRyxDQUFDMC9DLE1BQUssTUFBTyxRQUFRdjBDLE9BQU8sS0FBSyxJQUFJQSxLQUFLb3JCLEtBQUtuK0IsTUFBTSxHQUFHbStCLEtBQUtwK0IsR0FBRztZQUNsSSxJQUFJaUcsU0FBU3NoRCxNQUFNdGhELE1BQU0sSUFBSXdoRCxVQUFVcG1ELE1BQU0sSUFBSSxDQUFDMkYsSUFBSSxDQUFDNmhCLGFBQWEsSUFBSS9QLFVBQVVDLEdBQUc7WUFDckYsSUFBSWxaLE9BQU91K0IsS0FBSzU5QixLQUFLLEdBQUc2bUQsTUFBTXRuRCxLQUFLLEdBQUdzbkQsTUFBTXhuRCxJQUFJLEdBQUl3QixNQUFNZ21ELE1BQU14bkQsSUFBSSxHQUFHd25ELE1BQU10bkQsS0FBSyxHQUFHcStCLEtBQUs1OUIsS0FBSyxHQUN6RmEsTUFBTVAsS0FBSytDLEdBQUcsQ0FBQ29ELElBQUlwSCxJQUFJLEdBQUltbkQsQ0FBQUEsUUFBUSxHQUFHLGdCQUFnQixNQUFLLEtBQUsvZ0QsT0FBT25HLENBQUMsRUFBRXVuRCxNQUFNdG5ELEtBQUssR0FBR1MsU0FDcEZNLEtBQUtzRixHQUFHLENBQUNpaEQsTUFBTXhuRCxJQUFJLEVBQUVvSCxJQUFJcEgsSUFBSSxHQUFHVyxRQUFTd21ELENBQUFBLFFBQVEsR0FBRyxnQkFBZ0IsTUFBSyxLQUFLL2dELE9BQU9uRyxDQUFDO1lBQ2hHLElBQUltc0IsUUFBUSxJQUFJLENBQUNBLEtBQUssQ0FBQzNuQixFQUFFO1lBQ3pCLElBQUksQ0FBQ3VpRCxRQUFRYSxVQUFVLElBQUt6N0IsQ0FBQUEsUUFDdEJobEIsSUFBSWpILEdBQUcsR0FBSW8rQixDQUFBQSxLQUFLbitCLE1BQU0sR0FBR20rQixLQUFLcCtCLEdBQUcsSUFBSWlHLE9BQU8vRSxDQUFDLEdBQUdtbUQsTUFBTXJuRCxHQUFHLEdBQ3pEaUgsSUFBSWhILE1BQU0sR0FBSW0rQixDQUFBQSxLQUFLbitCLE1BQU0sR0FBR20rQixLQUFLcCtCLEdBQUcsSUFBSWlHLE9BQU8vRSxDQUFDLEdBQUdtbUQsTUFBTXBuRCxNQUFNLEtBQ2pFZ3NCLFNBQVVvN0IsTUFBTXBuRCxNQUFNLEdBQUdnSCxJQUFJaEgsTUFBTSxHQUFHZ0gsSUFBSWpILEdBQUcsR0FBR3FuRCxNQUFNcm5ELEdBQUcsRUFDekRpc0IsUUFBUSxJQUFJLENBQUNBLEtBQUssQ0FBQzNuQixFQUFFLEdBQUcsQ0FBQzJuQjtZQUM3QixJQUFJMDdCLFlBQVksQ0FBQzE3QixRQUFRaGxCLElBQUlqSCxHQUFHLEdBQUdxbkQsTUFBTXJuRCxHQUFHLEdBQUdxbkQsTUFBTXBuRCxNQUFNLEdBQUdnSCxJQUFJaEgsTUFBTSxJQUFJdW5EO1lBQzVFLElBQUlHLFlBQVlobkQsVUFBVTRtRCxNQUFNSyxNQUFNLEtBQUssT0FBTztnQkFDOUMsSUFBSUQsWUFBWSxJQUFJLENBQUMzZ0QsSUFBSSxDQUFDb25CLGlCQUFpQixFQUFFO29CQUN6Q3h3QixJQUFJMk8sS0FBSyxDQUFDdk0sR0FBRyxHQUFHOGtEO29CQUNoQjtnQkFDSjtnQkFDQVksWUFBWTloRCxHQUFHLENBQUMyakQsT0FBTzVtRDtnQkFDdkIvQyxJQUFJMk8sS0FBSyxDQUFDNUwsTUFBTSxHQUFHLENBQUNBLFNBQVNnbkQsU0FBUSxJQUFLam5ELFNBQVM7WUFDdkQsT0FDSyxJQUFJOUMsSUFBSTJPLEtBQUssQ0FBQzVMLE1BQU0sRUFBRTtnQkFDdkIvQyxJQUFJMk8sS0FBSyxDQUFDNUwsTUFBTSxHQUFHO1lBQ3ZCO1lBQ0EsSUFBSVgsTUFBTWlzQixRQUFRaGxCLElBQUlqSCxHQUFHLEdBQUdXLFNBQVM2bUQsY0FBY3ZoRCxPQUFPL0UsQ0FBQyxHQUFHK0YsSUFBSWhILE1BQU0sR0FBR3VuRCxjQUFjdmhELE9BQU8vRSxDQUFDO1lBQ2pHLElBQUluQixRQUFRRixPQUFPVztZQUNuQixJQUFJK21ELE1BQU1NLE9BQU8sS0FBSyxNQUNsQjtnQkFBQSxLQUFLLElBQUkvM0MsS0FBS3czQyxPQUNWLElBQUl4M0MsRUFBRWpRLElBQUksR0FBR0UsU0FBUytQLEVBQUUvUCxLQUFLLEdBQUdGLFFBQVFpUSxFQUFFOVAsR0FBRyxHQUFHQSxNQUFNVyxVQUFVbVAsRUFBRTdQLE1BQU0sR0FBR0QsS0FDdkVBLE1BQU1pc0IsUUFBUW5jLEVBQUU5UCxHQUFHLEdBQUdXLFNBQVMsSUFBSTZtRCxjQUFjMTNDLEVBQUU3UCxNQUFNLEdBQUd1bkQsY0FBYztZQUFDO1lBQ3ZGLElBQUksSUFBSSxDQUFDMWxELFFBQVEsSUFBSSxZQUFZO2dCQUM3QmxFLElBQUkyTyxLQUFLLENBQUN2TSxHQUFHLEdBQUcsQ0FBQ0EsTUFBTTgrQixTQUFTdC9CLE1BQU0sQ0FBQ1EsR0FBRyxJQUFJVSxTQUFTO2dCQUN2RDlDLElBQUkyTyxLQUFLLENBQUMxTSxJQUFJLEdBQUcsQ0FBQ0EsT0FBT2kvQixTQUFTdC9CLE1BQU0sQ0FBQ0ssSUFBSSxJQUFJVSxTQUFTO1lBQzlELE9BQ0s7Z0JBQ0QzQyxJQUFJMk8sS0FBSyxDQUFDdk0sR0FBRyxHQUFHQSxNQUFNVSxTQUFTO2dCQUMvQjlDLElBQUkyTyxLQUFLLENBQUMxTSxJQUFJLEdBQUdBLE9BQU9VLFNBQVM7WUFDckM7WUFDQSxJQUFJeW1ELE9BQU87Z0JBQ1AsSUFBSWMsWUFBWTdnRCxJQUFJcEgsSUFBSSxHQUFJd0IsQ0FBQUEsTUFBTTRFLE9BQU9uRyxDQUFDLEdBQUcsQ0FBQ21HLE9BQU9uRyxDQUFDLElBQUtELENBQUFBLE9BQU8sR0FBRyxnQkFBZ0IsTUFBSyxFQUFFLGNBQWMsR0FBaEI7Z0JBQzFGbW5ELE1BQU16NkMsS0FBSyxDQUFDMU0sSUFBSSxHQUFHaW9ELFlBQVl2bkQsU0FBUztZQUM1QztZQUNBLElBQUlnbkQsTUFBTU0sT0FBTyxLQUFLLE1BQ2xCUCxPQUFPbmpELElBQUksQ0FBQztnQkFBRXRFO2dCQUFNRztnQkFBS0Q7Z0JBQU9FLFFBQVFELE1BQU1XO1lBQU87WUFDekQvQyxJQUFJcVYsU0FBUyxDQUFDODBDLE1BQU0sQ0FBQyxvQkFBb0I5N0I7WUFDekNydUIsSUFBSXFWLFNBQVMsQ0FBQzgwQyxNQUFNLENBQUMsb0JBQW9CLENBQUM5N0I7WUFDMUMsSUFBSXM3QixNQUFNUyxVQUFVLEVBQ2hCVCxNQUFNUyxVQUFVLENBQUNscEIsU0FBU3VvQixLQUFLO1FBQ3ZDO0lBQ0o7SUFDQVYsZUFBZTtRQUNYLElBQUksSUFBSSxDQUFDTixPQUFPLENBQUNuQixRQUFRLENBQUN2bUQsTUFBTSxFQUFFO1lBQzlCLElBQUksSUFBSSxDQUFDcUksSUFBSSxDQUFDbzdCLE1BQU0sRUFDaEIsSUFBSSxDQUFDcDdCLElBQUksQ0FBQ3dwQyxjQUFjLENBQUMsSUFBSSxDQUFDK0wsVUFBVTtZQUM1QyxJQUFJLElBQUksQ0FBQ25hLE1BQU0sSUFBSSxJQUFJLENBQUNwN0IsSUFBSSxDQUFDbzdCLE1BQU0sRUFBRTtnQkFDakMsSUFBSSxDQUFDQSxNQUFNLEdBQUcsSUFBSSxDQUFDcDdCLElBQUksQ0FBQ283QixNQUFNO2dCQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDQSxNQUFNLEVBQ1osS0FBSyxJQUFJK2tCLE1BQU0sSUFBSSxDQUFDZCxPQUFPLENBQUNsQixZQUFZLENBQ3BDZ0MsR0FBR3ZwRCxHQUFHLENBQUMyTyxLQUFLLENBQUN2TSxHQUFHLEdBQUc4a0Q7WUFDL0I7UUFDSjtJQUNKO0FBQ0osR0FBRztJQUNDbmxDLGdCQUFnQjtRQUNaaVc7WUFBVyxJQUFJLENBQUMrd0IsWUFBWTtRQUFJO0lBQ3BDO0FBQ0o7QUFDQSxNQUFNdlAsWUFBWSxXQUFXLEdBQUU1RSxXQUFXNEUsU0FBUyxDQUFDO0lBQ2hELGVBQWU7UUFDWHZPLFFBQVE7UUFDUk4sV0FBVztJQUNmO0lBQ0Esc0JBQXNCO1FBQ2xCd0MsUUFBUTtRQUNSZCxpQkFBaUI7SUFDckI7SUFDQSxnREFBZ0Q7UUFDNUNNLFdBQVc7SUFDZjtJQUNBLHFCQUFxQjtRQUNqQk4saUJBQWlCO1FBQ2pCQyxPQUFPO0lBQ1g7SUFDQSxxQkFBcUI7UUFDakJ2cEMsUUFBUSxDQUFDLEVBQUUsRUFBRSxjQUFjLElBQUcsRUFBRSxDQUFDO1FBQ2pDSCxPQUFPLENBQUMsRUFBRSxFQUFFLGNBQWMsTUFBSyxFQUFFLEVBQUUsQ0FBQztRQUNwQ3NCLFVBQVU7UUFDVittQyxRQUFRLENBQUM7UUFDVHhILFVBQVU7UUFDVixxQkFBcUI7WUFDakJ4cUIsU0FBUztZQUNUL1UsVUFBVTtZQUNWdEIsT0FBTztZQUNQRyxRQUFRO1lBQ1JrcEMsWUFBWSxDQUFDLEVBQUUsRUFBRSxjQUFjLElBQUcsb0JBQW9CLENBQUM7WUFDdkRPLGFBQWEsQ0FBQyxFQUFFLEVBQUUsY0FBYyxJQUFHLG9CQUFvQixDQUFDO1FBQzVEO1FBQ0EsdUJBQXVCO1lBQ25CbnFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxjQUFjLElBQUcsRUFBRSxDQUFDO1lBQ2xDLFlBQVk7Z0JBQ1JzcUMsV0FBVyxDQUFDLEVBQUUsRUFBRSxjQUFjLElBQUcsYUFBYSxDQUFDO1lBQ25EO1lBQ0EsV0FBVztnQkFDUEEsV0FBVyxDQUFDLEVBQUUsRUFBRSxjQUFjLElBQUcsZ0JBQWdCLENBQUM7Z0JBQ2xEdHFDLFFBQVE7WUFDWjtRQUNKO1FBQ0EsdUJBQXVCO1lBQ25CRCxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsY0FBYyxJQUFHLEVBQUUsQ0FBQztZQUMvQixZQUFZO2dCQUNSc3FDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsY0FBYyxJQUFHLGFBQWEsQ0FBQztZQUN0RDtZQUNBLFdBQVc7Z0JBQ1BBLGNBQWMsQ0FBQyxFQUFFLEVBQUUsY0FBYyxJQUFHLGdCQUFnQixDQUFDO2dCQUNyRHRxQyxLQUFLO1lBQ1Q7UUFDSjtJQUNKO0lBQ0EsdUNBQXVDO1FBQ25DLFlBQVk7WUFDUmlvRCxnQkFBZ0I7WUFDaEJDLG1CQUFtQjtRQUN2QjtRQUNBLFdBQVc7WUFDUEQsZ0JBQWdCO1lBQ2hCQyxtQkFBbUI7UUFDdkI7SUFDSjtBQUNKO0FBQ0EsTUFBTVQsV0FBVztJQUFFM25ELEdBQUc7SUFBR29CLEdBQUc7QUFBRTtBQUM5Qjs7QUFFQSxHQUNBLE1BQU1vbEQsY0FBYyxXQUFXLEdBQUVucUQsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQzFDKzZCLFNBQVM7UUFBQ29OO1FBQWV2TztLQUFVO0FBQ3ZDO0FBQ0EsTUFBTStRLG1CQUFtQixXQUFXLEdBQUVoc0Qsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQy9DUSxTQUFTb3FDLENBQUFBLFNBQVVBLE9BQU94UCxNQUFNLENBQUMsQ0FBQ3BuQyxHQUFHbE4sSUFBTWtOLEVBQUVzVSxNQUFNLENBQUN4aEIsSUFBSSxFQUFFO0FBQzlEO0FBQ0EsTUFBTStqRDtJQUNGLGlFQUFpRTtJQUNqRSxPQUFPcjRDLE9BQU9oSixJQUFJLEVBQUU7UUFDaEIsT0FBTyxJQUFJcWhELGlCQUFpQnJoRDtJQUNoQztJQUNBNUQsWUFBWTRELElBQUksQ0FBRTtRQUNkLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ3NoRCxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUMxcUQsR0FBRyxHQUFHOEcsU0FBUzBLLGFBQWEsQ0FBQztRQUNsQyxJQUFJLENBQUN4UixHQUFHLENBQUNxVixTQUFTLENBQUNDLEdBQUcsQ0FBQztRQUN2QixJQUFJLENBQUNtekMsT0FBTyxHQUFHLElBQUl0QixtQkFBbUIvOUMsTUFBTW1oRCxrQkFBa0IsQ0FBQzFwQyxHQUFHbEYsSUFBTSxJQUFJLENBQUNndkMsZ0JBQWdCLENBQUM5cEMsR0FBR2xGLElBQUlrRixDQUFBQSxJQUFLQSxFQUFFN2dCLEdBQUcsQ0FBQ3NyQixNQUFNO0lBQzFIO0lBQ0FxL0IsaUJBQWlCMUIsT0FBTyxFQUFFM2dELElBQUksRUFBRTtRQUM1QixJQUFJc2lELGFBQWEzQixRQUFRNzJDLE1BQU0sQ0FBQyxJQUFJLENBQUNoSixJQUFJO1FBQ3pDd2hELFdBQVc1cUQsR0FBRyxDQUFDcVYsU0FBUyxDQUFDQyxHQUFHLENBQUM7UUFDN0IsSUFBSSxDQUFDdFYsR0FBRyxDQUFDc0ssWUFBWSxDQUFDc2dELFdBQVc1cUQsR0FBRyxFQUFFc0ksT0FBT0EsS0FBS3RJLEdBQUcsQ0FBQzhKLFdBQVcsR0FBRyxJQUFJLENBQUM5SixHQUFHLENBQUMrSixVQUFVO1FBQ3ZGLElBQUksSUFBSSxDQUFDMmdELE9BQU8sSUFBSUUsV0FBV3JTLEtBQUssRUFDaENxUyxXQUFXclMsS0FBSyxDQUFDLElBQUksQ0FBQ252QyxJQUFJO1FBQzlCLE9BQU93aEQ7SUFDWDtJQUNBclMsTUFBTW52QyxJQUFJLEVBQUU7UUFDUixLQUFLLElBQUl3aEQsY0FBYyxJQUFJLENBQUNuQyxPQUFPLENBQUNsQixZQUFZLENBQUU7WUFDOUMsSUFBSXFELFdBQVdyUyxLQUFLLEVBQ2hCcVMsV0FBV3JTLEtBQUssQ0FBQ252QztRQUN6QjtRQUNBLElBQUksQ0FBQ3NoRCxPQUFPLEdBQUc7SUFDbkI7SUFDQU4sV0FBV1gsS0FBSyxFQUFFO1FBQ2QsS0FBSyxJQUFJbUIsY0FBYyxJQUFJLENBQUNuQyxPQUFPLENBQUNsQixZQUFZLENBQUU7WUFDOUMsSUFBSXFELFdBQVdSLFVBQVUsRUFDckJRLFdBQVdSLFVBQVUsQ0FBQ1g7UUFDOUI7SUFDSjtJQUNBbG5DLE9BQU9BLE1BQU0sRUFBRTtRQUNYLElBQUksQ0FBQ2ttQyxPQUFPLENBQUNsbUMsTUFBTSxDQUFDQTtJQUN4QjtJQUNBeFcsVUFBVTtRQUNOLElBQUlxSjtRQUNKLEtBQUssSUFBSXlMLEtBQUssSUFBSSxDQUFDNG5DLE9BQU8sQ0FBQ2xCLFlBQVksQ0FDbkMsQ0FBQ255QyxLQUFLeUwsRUFBRTlVLE9BQU8sTUFBTSxRQUFRcUosT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbkQsSUFBSSxDQUFDNE87SUFDdEU7SUFDQWdxQyxTQUFTMWpELElBQUksRUFBRTtRQUNYLElBQUlxTixRQUFRL047UUFDWixLQUFLLElBQUkyQyxRQUFRLElBQUksQ0FBQ3EvQyxPQUFPLENBQUNsQixZQUFZLENBQUU7WUFDeEMsSUFBSXVELFFBQVExaEQsSUFBSSxDQUFDakMsS0FBSztZQUN0QixJQUFJMmpELFVBQVVya0QsV0FBVztnQkFDckIsSUFBSStOLFVBQVUvTixXQUNWK04sUUFBUXMyQztxQkFDUCxJQUFJdDJDLFVBQVVzMkMsT0FDZixPQUFPcmtEO1lBQ2Y7UUFDSjtRQUNBLE9BQU8rTjtJQUNYO0lBQ0EsSUFBSW5NLFNBQVM7UUFBRSxPQUFPLElBQUksQ0FBQ3dpRCxRQUFRLENBQUM7SUFBVztJQUMvQyxJQUFJckIsWUFBWTtRQUFFLE9BQU8sSUFBSSxDQUFDcUIsUUFBUSxDQUFDO0lBQWM7SUFDckQsSUFBSVosVUFBVTtRQUFFLE9BQU8sSUFBSSxDQUFDWSxRQUFRLENBQUM7SUFBWTtJQUNqRCxJQUFJYixTQUFTO1FBQUUsT0FBTyxJQUFJLENBQUNhLFFBQVEsQ0FBQztJQUFXO0FBQ25EO0FBQ0EsTUFBTUUsdUJBQXVCLFdBQVcsR0FBRXJDLFlBQVlzQyxPQUFPLENBQUM7SUFBQ1Q7Q0FBaUIsRUFBRTEzQyxDQUFBQTtJQUM5RSxJQUFJeTBDLFdBQVd6MEMsTUFBTW9PLEtBQUssQ0FBQ3NwQztJQUMzQixJQUFJakQsU0FBU3ZtRCxNQUFNLEtBQUssR0FDcEIsT0FBTztJQUNYLE9BQU87UUFDSHNJLEtBQUtuRyxLQUFLK0MsR0FBRyxJQUFJcWhELFNBQVM3bUMsR0FBRyxDQUFDSSxDQUFBQSxJQUFLQSxFQUFFeFgsR0FBRztRQUN4QzRCLEtBQUsvSCxLQUFLc0YsR0FBRyxJQUFJOCtDLFNBQVM3bUMsR0FBRyxDQUFDSSxDQUFBQTtZQUFPLElBQUl6TDtZQUFJLE9BQU8sQ0FBQ0EsS0FBS3lMLEVBQUU1VixHQUFHLE1BQU0sUUFBUW1LLE9BQU8sS0FBSyxJQUFJQSxLQUFLeUwsRUFBRXhYLEdBQUc7UUFBRTtRQUN6RytJLFFBQVFxNEMsaUJBQWlCcjRDLE1BQU07UUFDL0JpYyxPQUFPaTVCLFFBQVEsQ0FBQyxFQUFFLENBQUNqNUIsS0FBSztRQUN4Qis2QixPQUFPOUIsU0FBUy94QyxJQUFJLENBQUNzTCxDQUFBQSxJQUFLQSxFQUFFdW9DLEtBQUs7SUFDckM7QUFDSjtBQUNBLE1BQU02QjtJQUNGemxELFlBQVk0RCxJQUFJLEVBQUU2RCxNQUFNLEVBQUU2ekMsS0FBSyxFQUFFb0ssUUFBUSxFQUFFQyxTQUFTLENBQUU7UUFDbEQsSUFBSSxDQUFDL2hELElBQUksR0FBR0E7UUFDWixJQUFJLENBQUM2RCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDNnpDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNvSyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFlBQVksR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLENBQUM7UUFDdkIsSUFBSSxDQUFDMzFCLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQzQxQixRQUFRLEdBQUc7WUFBRXBwRCxHQUFHO1lBQUdvQixHQUFHO1lBQUcxRCxRQUFRd0osS0FBS3BKLEdBQUc7WUFBRXVyRCxNQUFNO1FBQUU7UUFDeEQsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVLENBQUNqM0IsSUFBSSxDQUFDLElBQUk7UUFDM0NuckIsS0FBS3BKLEdBQUcsQ0FBQzAwQixnQkFBZ0IsQ0FBQyxjQUFjLElBQUksQ0FBQysyQixVQUFVLEdBQUcsSUFBSSxDQUFDQSxVQUFVLENBQUNsM0IsSUFBSSxDQUFDLElBQUk7UUFDbkZuckIsS0FBS3BKLEdBQUcsQ0FBQzAwQixnQkFBZ0IsQ0FBQyxhQUFhLElBQUksQ0FBQ3V5QixTQUFTLEdBQUcsSUFBSSxDQUFDQSxTQUFTLENBQUMxeUIsSUFBSSxDQUFDLElBQUk7SUFDcEY7SUFDQWhTLFNBQVM7UUFDTCxJQUFJLElBQUksQ0FBQ21ULE9BQU8sRUFBRTtZQUNkLElBQUksQ0FBQ0EsT0FBTyxHQUFHO1lBQ2YwZSxhQUFhLElBQUksQ0FBQ2lYLGNBQWM7WUFDaEMsSUFBSSxDQUFDQSxjQUFjLEdBQUdwMUIsV0FBVyxJQUFNLElBQUksQ0FBQ3kxQixVQUFVLElBQUk7UUFDOUQ7SUFDSjtJQUNBLElBQUk1eEMsU0FBUztRQUNULE9BQU8sSUFBSSxDQUFDMVEsSUFBSSxDQUFDeUosS0FBSyxDQUFDaXVDLEtBQUssQ0FBQyxJQUFJLENBQUNBLEtBQUs7SUFDM0M7SUFDQTBLLGFBQWE7UUFDVCxJQUFJLENBQUNKLFlBQVksR0FBRyxDQUFDO1FBQ3JCLElBQUksSUFBSSxDQUFDdHhDLE1BQU0sQ0FBQy9ZLE1BQU0sRUFDbEI7UUFDSixJQUFJNHFELFVBQVU1bEMsS0FBS0MsR0FBRyxLQUFLLElBQUksQ0FBQ3NsQyxRQUFRLENBQUNDLElBQUk7UUFDN0MsSUFBSUksVUFBVSxJQUFJLENBQUNSLFNBQVMsRUFDeEIsSUFBSSxDQUFDQyxZQUFZLEdBQUduMUIsV0FBVyxJQUFJLENBQUN1MUIsVUFBVSxFQUFFLElBQUksQ0FBQ0wsU0FBUyxHQUFHUTthQUVqRSxJQUFJLENBQUNELFVBQVU7SUFDdkI7SUFDQUEsYUFBYTtRQUNUdFgsYUFBYSxJQUFJLENBQUNpWCxjQUFjO1FBQ2hDLElBQUksRUFBRWppRCxJQUFJLEVBQUVraUQsUUFBUSxFQUFFLEdBQUcsSUFBSTtRQUM3QixJQUFJMUcsT0FBT3g3QyxLQUFLaU4sT0FBTyxDQUFDaVUsT0FBTyxDQUFDZ2hDLFNBQVMxckQsTUFBTTtRQUMvQyxJQUFJLENBQUNnbEQsTUFDRDtRQUNKLElBQUl2N0MsS0FBS2hHLE9BQU87UUFDaEIsSUFBSXVoRCxnQkFBZ0J6eUMsWUFBWTtZQUM1QjlJLE1BQU11N0MsS0FBSzM3QyxVQUFVO1FBQ3pCLE9BQ0s7WUFDREksTUFBTUQsS0FBSzZsQixXQUFXLENBQUNxOEI7WUFDdkIsSUFBSWppRCxPQUFPLE1BQ1A7WUFDSixJQUFJdWlELFlBQVl4aUQsS0FBSzZuQixXQUFXLENBQUM1bkI7WUFDakMsSUFBSSxDQUFDdWlELGFBQ0ROLFNBQVNob0QsQ0FBQyxHQUFHc29ELFVBQVV4cEQsR0FBRyxJQUFJa3BELFNBQVNob0QsQ0FBQyxHQUFHc29ELFVBQVV2cEQsTUFBTSxJQUMzRGlwRCxTQUFTcHBELENBQUMsR0FBRzBwRCxVQUFVM3BELElBQUksR0FBR21ILEtBQUtrbkIscUJBQXFCLElBQ3hEZzdCLFNBQVNwcEQsQ0FBQyxHQUFHMHBELFVBQVV6cEQsS0FBSyxHQUFHaUgsS0FBS2tuQixxQkFBcUIsRUFDekQ7WUFDSixJQUFJdTdCLE9BQU96aUQsS0FBS2lvQixTQUFTLENBQUNqb0IsS0FBS3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQ3RRLE1BQU0ySSxJQUFJLENBQUM4cEIsQ0FBQUEsSUFBS0EsRUFBRWwxQixJQUFJLElBQUl5QyxPQUFPeXlCLEVBQUVqMUIsRUFBRSxJQUFJd0M7WUFDekYsSUFBSXlpRCxNQUFNRCxRQUFRQSxLQUFLcHFELEdBQUcsSUFBSXlaLFVBQVVFLEdBQUcsR0FBRyxDQUFDLElBQUk7WUFDbkQvWCxPQUFRaW9ELFNBQVNwcEQsQ0FBQyxHQUFHMHBELFVBQVUzcEQsSUFBSSxHQUFHLENBQUM2cEQsTUFBTUE7UUFDakQ7UUFDQSxJQUFJMzRDLE9BQU8sSUFBSSxDQUFDbEcsTUFBTSxDQUFDN0QsTUFBTUMsS0FBS2hHO1FBQ2xDLElBQUk4UCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBSzBxQixJQUFJLEVBQUU7WUFDdkQsSUFBSW5JLFVBQVUsSUFBSSxDQUFDQSxPQUFPLEdBQUc7Z0JBQUVyc0I7WUFBSTtZQUNuQzhKLEtBQUswcUIsSUFBSSxDQUFDcnRCLENBQUFBO2dCQUNOLElBQUksSUFBSSxDQUFDa2xCLE9BQU8sSUFBSUEsU0FBUztvQkFDekIsSUFBSSxDQUFDQSxPQUFPLEdBQUc7b0JBQ2YsSUFBSWxsQixVQUFVLENBQUV1QixDQUFBQSxNQUFNOGUsT0FBTyxDQUFDcmdCLFdBQVcsQ0FBQ0EsT0FBT3pQLE1BQU0sR0FDbkRxSSxLQUFLZ3ZCLFFBQVEsQ0FBQzt3QkFBRTRFLFNBQVMsSUFBSSxDQUFDa3VCLFFBQVEsQ0FBQ3p6QyxFQUFFLENBQUMxRixNQUFNOGUsT0FBTyxDQUFDcmdCLFVBQVVBLFNBQVM7NEJBQUNBO3lCQUFPO29CQUFFO2dCQUM3RjtZQUNKLEdBQUdnUyxDQUFBQSxJQUFLMUIsYUFBYTFYLEtBQUt5SixLQUFLLEVBQUUyUCxHQUFHO1FBQ3hDLE9BQ0ssSUFBSXJQLFFBQVEsQ0FBRXBCLENBQUFBLE1BQU04ZSxPQUFPLENBQUMxZCxTQUFTLENBQUNBLEtBQUtwUyxNQUFNLEdBQUc7WUFDckRxSSxLQUFLZ3ZCLFFBQVEsQ0FBQztnQkFBRTRFLFNBQVMsSUFBSSxDQUFDa3VCLFFBQVEsQ0FBQ3p6QyxFQUFFLENBQUMxRixNQUFNOGUsT0FBTyxDQUFDMWQsUUFBUUEsT0FBTztvQkFBQ0E7aUJBQUs7WUFBRTtRQUNuRjtJQUNKO0lBQ0EsSUFBSTgxQyxVQUFVO1FBQ1YsSUFBSWhuQyxTQUFTLElBQUksQ0FBQzdZLElBQUksQ0FBQzZZLE1BQU0sQ0FBQzhsQztRQUM5QixJQUFJeG1ELFFBQVEwZ0IsU0FBU0EsT0FBT3dtQyxPQUFPLENBQUNuQixRQUFRLENBQUN5RSxTQUFTLENBQUNsckMsQ0FBQUEsSUFBS0EsRUFBRXpPLE1BQU0sSUFBSXE0QyxpQkFBaUJyNEMsTUFBTSxJQUFJLENBQUM7UUFDcEcsT0FBTzdRLFFBQVEsQ0FBQyxJQUFJMGdCLE9BQU93bUMsT0FBTyxDQUFDbEIsWUFBWSxDQUFDaG1ELE1BQU0sR0FBRztJQUM3RDtJQUNBMGxELFVBQVV0MEMsS0FBSyxFQUFFO1FBQ2IsSUFBSXlDLElBQUl5QztRQUNSLElBQUksQ0FBQ3l6QyxRQUFRLEdBQUc7WUFBRXBwRCxHQUFHeVEsTUFBTStqQixPQUFPO1lBQUVwekIsR0FBR3FQLE1BQU1na0IsT0FBTztZQUFFLzJCLFFBQVErUyxNQUFNL1MsTUFBTTtZQUFFMnJELE1BQU14bEMsS0FBS0MsR0FBRztRQUFHO1FBQzdGLElBQUksSUFBSSxDQUFDb2xDLFlBQVksR0FBRyxHQUNwQixJQUFJLENBQUNBLFlBQVksR0FBR24xQixXQUFXLElBQUksQ0FBQ3UxQixVQUFVLEVBQUUsSUFBSSxDQUFDTCxTQUFTO1FBQ2xFLElBQUksRUFBRXJ4QyxNQUFNLEVBQUVtdkMsT0FBTyxFQUFFLEdBQUcsSUFBSTtRQUM5QixJQUFJbnZDLE9BQU8vWSxNQUFNLElBQUlrb0QsV0FBVyxDQUFDK0MsWUFBWS9DLFFBQVFqcEQsR0FBRyxFQUFFMlMsVUFBVSxJQUFJLENBQUMraUIsT0FBTyxFQUFFO1lBQzlFLElBQUksRUFBRXJzQixHQUFHLEVBQUUsR0FBR3lRLE1BQU0sQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDNGIsT0FBTyxFQUFFenFCLE1BQU0sQ0FBQzRNLEtBQUssQ0FBQ3pDLEtBQUswRSxNQUFNLENBQUMsRUFBRSxNQUFNLFFBQVExRSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUduSyxHQUFHLE1BQU0sUUFBUTRNLE9BQU8sS0FBSyxJQUFJQSxLQUFLeE87WUFDcEosSUFBS0EsT0FBTzRCLE1BQU0sSUFBSSxDQUFDN0IsSUFBSSxDQUFDNmxCLFdBQVcsQ0FBQyxJQUFJLENBQUNxOEIsUUFBUSxLQUFLamlELE1BQ3BELENBQUM0aUQsWUFBWSxJQUFJLENBQUM3aUQsSUFBSSxFQUFFQyxLQUFLNEIsS0FBSzBILE1BQU0rakIsT0FBTyxFQUFFL2pCLE1BQU1na0IsT0FBTyxHQUFJO2dCQUNwRSxJQUFJLENBQUN2dEIsSUFBSSxDQUFDZ3ZCLFFBQVEsQ0FBQztvQkFBRTRFLFNBQVMsSUFBSSxDQUFDa3VCLFFBQVEsQ0FBQ3p6QyxFQUFFLENBQUMsRUFBRTtnQkFBRTtnQkFDbkQsSUFBSSxDQUFDaWUsT0FBTyxHQUFHO1lBQ25CO1FBQ0o7SUFDSjtJQUNBKzFCLFdBQVc5NEMsS0FBSyxFQUFFO1FBQ2R5aEMsYUFBYSxJQUFJLENBQUNnWCxZQUFZO1FBQzlCLElBQUksQ0FBQ0EsWUFBWSxHQUFHLENBQUM7UUFDckIsSUFBSSxFQUFFdHhDLE1BQU0sRUFBRSxHQUFHLElBQUk7UUFDckIsSUFBSUEsT0FBTy9ZLE1BQU0sRUFBRTtZQUNmLElBQUksRUFBRWtvRCxPQUFPLEVBQUUsR0FBRyxJQUFJO1lBQ3RCLElBQUlpRCxZQUFZakQsV0FBV0EsUUFBUWpwRCxHQUFHLENBQUNELFFBQVEsQ0FBQzRTLE1BQU13dUMsYUFBYTtZQUNuRSxJQUFJLENBQUMrSyxXQUNELElBQUksQ0FBQzlpRCxJQUFJLENBQUNndkIsUUFBUSxDQUFDO2dCQUFFNEUsU0FBUyxJQUFJLENBQUNrdUIsUUFBUSxDQUFDenpDLEVBQUUsQ0FBQyxFQUFFO1lBQUU7aUJBRW5ELElBQUksQ0FBQzAwQyxpQkFBaUIsQ0FBQ2xELFFBQVFqcEQsR0FBRztRQUMxQztJQUNKO0lBQ0Ftc0Qsa0JBQWtCbEQsT0FBTyxFQUFFO1FBQ3ZCLElBQUltRCxRQUFRLENBQUN6NUM7WUFDVHMyQyxRQUFRMXpCLG1CQUFtQixDQUFDLGNBQWM2MkI7WUFDMUMsSUFBSSxJQUFJLENBQUN0eUMsTUFBTSxDQUFDL1ksTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDcUksSUFBSSxDQUFDcEosR0FBRyxDQUFDRCxRQUFRLENBQUM0UyxNQUFNd3VDLGFBQWEsR0FDakUsSUFBSSxDQUFDLzNDLElBQUksQ0FBQ2d2QixRQUFRLENBQUM7Z0JBQUU0RSxTQUFTLElBQUksQ0FBQ2t1QixRQUFRLENBQUN6ekMsRUFBRSxDQUFDLEVBQUU7WUFBRTtRQUMzRDtRQUNBd3hDLFFBQVF2MEIsZ0JBQWdCLENBQUMsY0FBYzAzQjtJQUMzQztJQUNBcmdELFVBQVU7UUFDTnFvQyxhQUFhLElBQUksQ0FBQ2dYLFlBQVk7UUFDOUIsSUFBSSxDQUFDaGlELElBQUksQ0FBQ3BKLEdBQUcsQ0FBQ3UxQixtQkFBbUIsQ0FBQyxjQUFjLElBQUksQ0FBQ2syQixVQUFVO1FBQy9ELElBQUksQ0FBQ3JpRCxJQUFJLENBQUNwSixHQUFHLENBQUN1MUIsbUJBQW1CLENBQUMsYUFBYSxJQUFJLENBQUMweEIsU0FBUztJQUNqRTtBQUNKO0FBQ0EsTUFBTW9GLGdCQUFnQjtBQUN0QixTQUFTTCxZQUFZL0MsT0FBTyxFQUFFdDJDLEtBQUs7SUFDL0IsSUFBSTNRLE9BQU9pbkQsUUFBUXprRCxxQkFBcUI7SUFDeEMsT0FBT21PLE1BQU0rakIsT0FBTyxJQUFJMTBCLEtBQUtDLElBQUksR0FBR29xRCxpQkFBaUIxNUMsTUFBTStqQixPQUFPLElBQUkxMEIsS0FBS0csS0FBSyxHQUFHa3FELGlCQUMvRTE1QyxNQUFNZ2tCLE9BQU8sSUFBSTMwQixLQUFLSSxHQUFHLEdBQUdpcUQsaUJBQWlCMTVDLE1BQU1na0IsT0FBTyxJQUFJMzBCLEtBQUtLLE1BQU0sR0FBR2dxRDtBQUNwRjtBQUNBLFNBQVNKLFlBQVk3aUQsSUFBSSxFQUFFeEMsSUFBSSxFQUFFQyxFQUFFLEVBQUUzRSxDQUFDLEVBQUVvQixDQUFDLEVBQUV3VixNQUFNO0lBQzdDLElBQUk5VyxPQUFPb0gsS0FBSzJoQixTQUFTLENBQUN2bUIscUJBQXFCO0lBQy9DLElBQUk4bkQsWUFBWWxqRCxLQUFLZ3BCLFdBQVcsR0FBR2hwQixLQUFLd3ZDLGVBQWUsQ0FBQ3gyQyxHQUFHLEdBQUdnSCxLQUFLbWUsYUFBYTtJQUNoRixJQUFJdmxCLEtBQUtDLElBQUksR0FBR0MsS0FBS0YsS0FBS0csS0FBSyxHQUFHRCxLQUFLRixLQUFLSSxHQUFHLEdBQUdrQixLQUFLSixLQUFLK0MsR0FBRyxDQUFDakUsS0FBS0ssTUFBTSxFQUFFaXFELGFBQWFocEQsR0FDdEYsT0FBTztJQUNYLElBQUkrRixNQUFNRCxLQUFLNmxCLFdBQVcsQ0FBQztRQUFFL3NCO1FBQUdvQjtJQUFFLEdBQUc7SUFDckMsT0FBTytGLE9BQU96QyxRQUFReUMsT0FBT3hDO0FBQ2pDO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBLEdBQ0EsU0FBUzBsRCxhQUFhdC9DLE1BQU0sRUFBRTVGLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLElBQUk2akQsV0FBVzFzRCwwREFBV0EsQ0FBQ29oQixNQUFNO0lBQ2pDLElBQUk0c0MsYUFBYXJ0RCx5REFBVUEsQ0FBQ3lnQixNQUFNLENBQUM7UUFDL0J4TjtZQUFXLE9BQU8sRUFBRTtRQUFFO1FBQ3RCbVEsUUFBTy9OLEtBQUssRUFBRWlRLEVBQUU7WUFDWixJQUFJalEsTUFBTXpULE1BQU0sRUFBRTtnQkFDZCxJQUFJc0csUUFBUW9sRCxZQUFZLElBQUtob0MsQ0FBQUEsR0FBR08sVUFBVSxJQUFJUCxHQUFHaGtCLFNBQVMsR0FDdEQrVCxRQUFRLEVBQUU7cUJBQ1QsSUFBSW5OLFFBQVFxbEQsTUFBTSxFQUNuQmw0QyxRQUFRQSxNQUFNcW5CLE1BQU0sQ0FBQ2p3QixDQUFBQSxJQUFLLENBQUN2RSxRQUFRcWxELE1BQU0sQ0FBQ2pvQyxJQUFJN1k7Z0JBQ2xELElBQUk2WSxHQUFHTyxVQUFVLEVBQUU7b0JBQ2YsS0FBSyxJQUFJaWtDLFdBQVd6MEMsTUFBTzt3QkFDdkIsSUFBSTZWLFNBQVM1RixHQUFHL0QsT0FBTyxDQUFDMkYsTUFBTSxDQUFDNGlDLFFBQVE1L0MsR0FBRyxFQUFFLENBQUMsR0FBR2xMLHNEQUFPQSxDQUFDK1osUUFBUTt3QkFDaEUsSUFBSW1TLFVBQVUsTUFBTTs0QkFDaEIsSUFBSXNTLE9BQU9qcEIsT0FBT2k1QyxNQUFNLENBQUNqNUMsT0FBT3RCLE1BQU0sQ0FBQyxPQUFPNjJDOzRCQUM5Q3RzQixLQUFLdHpCLEdBQUcsR0FBR2doQjs0QkFDWCxJQUFJc1MsS0FBSzF4QixHQUFHLElBQUksTUFDWjB4QixLQUFLMXhCLEdBQUcsR0FBR3daLEdBQUcvRCxPQUFPLENBQUMyRixNQUFNLENBQUNzVyxLQUFLMXhCLEdBQUc7d0JBQzdDO29CQUNKO2dCQUNKO1lBQ0o7WUFDQSxLQUFLLElBQUlpeUIsVUFBVXpZLEdBQUd1WSxPQUFPLENBQUU7Z0JBQzNCLElBQUlFLE9BQU80WSxFQUFFLENBQUNvVixXQUNWMTJDLFFBQVEwb0IsT0FBTzFvQixLQUFLO2dCQUN4QixJQUFJMG9CLE9BQU80WSxFQUFFLENBQUM4VywwQkFDVnA0QyxRQUFRLEVBQUU7WUFDbEI7WUFDQSxPQUFPQTtRQUNYO1FBQ0F3TixTQUFTK1EsQ0FBQUEsSUFBS3czQixpQkFBaUIzakQsSUFBSSxDQUFDbXNCO0lBQ3hDO0lBQ0EsT0FBTztRQUNIeTVCO1FBQ0FockMsV0FBVzVCLE1BQU0sQ0FBQ3hXLENBQUFBLE9BQVEsSUFBSTZoRCxZQUFZN2hELE1BQU02RCxRQUFRdS9DLFlBQVl0QixVQUFVN2pELFFBQVE4akQsU0FBUyxJQUFJLElBQUksY0FBYztRQUNySEo7S0FDSDtBQUNMO0FBQ0E7O0FBRUEsR0FDQSxTQUFTOEIsV0FBV3pqRCxJQUFJLEVBQUU2L0MsT0FBTztJQUM3QixJQUFJaG5DLFNBQVM3WSxLQUFLNlksTUFBTSxDQUFDOGxDO0lBQ3pCLElBQUksQ0FBQzlsQyxRQUNELE9BQU87SUFDWCxJQUFJc0ssUUFBUXRLLE9BQU93bUMsT0FBTyxDQUFDbkIsUUFBUSxDQUFDeDdDLE9BQU8sQ0FBQ205QztJQUM1QyxPQUFPMThCLFFBQVEsSUFBSSxPQUFPdEssT0FBT3dtQyxPQUFPLENBQUNsQixZQUFZLENBQUNoN0IsTUFBTTtBQUNoRTtBQUNBOztBQUVBLEdBQ0EsU0FBU3VnQyxpQkFBaUJqNkMsS0FBSztJQUMzQixPQUFPQSxNQUFNb08sS0FBSyxDQUFDc3BDLGtCQUFrQmgxQyxJQUFJLENBQUNyVCxDQUFBQSxJQUFLQTtBQUNuRDtBQUNBLE1BQU0wcUQsMEJBQTBCLFdBQVcsR0FBRXB1RCwwREFBV0EsQ0FBQ29oQixNQUFNO0FBQy9EOztBQUVBLEdBQ0EsTUFBTW10QyxxQkFBcUIsV0FBVyxHQUFFSCx3QkFBd0JuMUMsRUFBRSxDQUFDO0FBQ25FOzs7OztBQUtBLEdBQ0EsU0FBU3UxQyxtQkFBbUI1akQsSUFBSTtJQUM1QixJQUFJNlksU0FBUzdZLEtBQUs2WSxNQUFNLENBQUM4bEM7SUFDekIsSUFBSTlsQyxRQUNBQSxPQUFPOG1DLFlBQVk7QUFDM0I7QUFFQSxNQUFNa0UsY0FBYyxXQUFXLEdBQUUxdUQsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQzFDUSxTQUFRaS9CLE9BQU87UUFDWCxJQUFJNk4sY0FBY0M7UUFDbEIsS0FBSyxJQUFJN2tDLEtBQUsrMkIsUUFBUztZQUNuQjZOLGVBQWVBLGdCQUFnQjVrQyxFQUFFNGtDLFlBQVk7WUFDN0NDLGtCQUFrQkEsbUJBQW1CN2tDLEVBQUU2a0MsZUFBZTtRQUMxRDtRQUNBLE9BQU87WUFBRUQ7WUFBY0M7UUFBZ0I7SUFDM0M7QUFDSjtBQUNBOztBQUVBLEdBQ0EsU0FBU0MsT0FBT3JZLE1BQU07SUFDbEIsT0FBT0EsU0FBUztRQUFDa1ksWUFBWXgxQyxFQUFFLENBQUNzOUI7S0FBUSxHQUFHLEVBQUU7QUFDakQ7QUFDQTs7OztBQUlBLEdBQ0EsU0FBU3NZLFNBQVNqa0QsSUFBSSxFQUFFa2tELEtBQUs7SUFDekIsSUFBSXJyQyxTQUFTN1ksS0FBSzZZLE1BQU0sQ0FBQ3NyQztJQUN6QixJQUFJaHNELFFBQVEwZ0IsU0FBU0EsT0FBT2cxQixLQUFLLENBQUNuckMsT0FBTyxDQUFDd2hELFNBQVMsQ0FBQztJQUNwRCxPQUFPL3JELFFBQVEsQ0FBQyxJQUFJMGdCLE9BQU9tckMsTUFBTSxDQUFDN3JELE1BQU0sR0FBRztBQUMvQztBQUNBLE1BQU1nc0QsY0FBYyxXQUFXLEdBQUUvckMsV0FBV1ksU0FBUyxDQUFDO0lBQ2xENWMsWUFBWTRELElBQUksQ0FBRTtRQUNkLElBQUksQ0FBQ3l2QixLQUFLLEdBQUd6dkIsS0FBS3lKLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ3VzQztRQUM5QixJQUFJLENBQUN2VyxLQUFLLEdBQUcsSUFBSSxDQUFDcGUsS0FBSyxDQUFDZ0QsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQTtRQUNwQyxJQUFJLENBQUNzeEIsTUFBTSxHQUFHLElBQUksQ0FBQ25XLEtBQUssQ0FBQ3gyQixHQUFHLENBQUN2TCxDQUFBQSxPQUFRQSxLQUFLOUw7UUFDMUMsSUFBSTAyQyxPQUFPMTJDLEtBQUt5SixLQUFLLENBQUNvTyxLQUFLLENBQUNnc0M7UUFDNUIsSUFBSSxDQUFDN3FELEdBQUcsR0FBRyxJQUFJcXJELFdBQVdya0QsTUFBTSxNQUFNMDJDLEtBQUtvTixZQUFZO1FBQ3ZELElBQUksQ0FBQzdxRCxNQUFNLEdBQUcsSUFBSW9yRCxXQUFXcmtELE1BQU0sT0FBTzAyQyxLQUFLcU4sZUFBZTtRQUM5RCxJQUFJLENBQUMvcUQsR0FBRyxDQUFDdUgsSUFBSSxDQUFDLElBQUksQ0FBQ3lqRCxNQUFNLENBQUN2eEIsTUFBTSxDQUFDbGdCLENBQUFBLElBQUtBLEVBQUV2WixHQUFHO1FBQzNDLElBQUksQ0FBQ0MsTUFBTSxDQUFDc0gsSUFBSSxDQUFDLElBQUksQ0FBQ3lqRCxNQUFNLENBQUN2eEIsTUFBTSxDQUFDbGdCLENBQUFBLElBQUssQ0FBQ0EsRUFBRXZaLEdBQUc7UUFDL0MsS0FBSyxJQUFJdVosS0FBSyxJQUFJLENBQUN5eEMsTUFBTSxDQUFFO1lBQ3ZCenhDLEVBQUUzYixHQUFHLENBQUNxVixTQUFTLENBQUNDLEdBQUcsQ0FBQztZQUNwQixJQUFJcUcsRUFBRTQ4QixLQUFLLEVBQ1A1OEIsRUFBRTQ4QixLQUFLO1FBQ2Y7SUFDSjtJQUNBaDJCLE9BQU9BLE1BQU0sRUFBRTtRQUNYLElBQUl1OUIsT0FBT3Y5QixPQUFPMVAsS0FBSyxDQUFDb08sS0FBSyxDQUFDZ3NDO1FBQzlCLElBQUksSUFBSSxDQUFDN3FELEdBQUcsQ0FBQzRtRCxTQUFTLElBQUlsSixLQUFLb04sWUFBWSxFQUFFO1lBQ3pDLElBQUksQ0FBQzlxRCxHQUFHLENBQUN1SCxJQUFJLENBQUMsRUFBRTtZQUNoQixJQUFJLENBQUN2SCxHQUFHLEdBQUcsSUFBSXFyRCxXQUFXbHJDLE9BQU9uWixJQUFJLEVBQUUsTUFBTTAyQyxLQUFLb04sWUFBWTtRQUNsRTtRQUNBLElBQUksSUFBSSxDQUFDN3FELE1BQU0sQ0FBQzJtRCxTQUFTLElBQUlsSixLQUFLcU4sZUFBZSxFQUFFO1lBQy9DLElBQUksQ0FBQzlxRCxNQUFNLENBQUNzSCxJQUFJLENBQUMsRUFBRTtZQUNuQixJQUFJLENBQUN0SCxNQUFNLEdBQUcsSUFBSW9yRCxXQUFXbHJDLE9BQU9uWixJQUFJLEVBQUUsT0FBTzAyQyxLQUFLcU4sZUFBZTtRQUN6RTtRQUNBLElBQUksQ0FBQy9xRCxHQUFHLENBQUNzckQsV0FBVztRQUNwQixJQUFJLENBQUNyckQsTUFBTSxDQUFDcXJELFdBQVc7UUFDdkIsSUFBSTcwQixRQUFRdFcsT0FBTzFQLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ3VzQztRQUMvQixJQUFJMzBCLFNBQVMsSUFBSSxDQUFDQSxLQUFLLEVBQUU7WUFDckIsSUFBSW9lLFFBQVFwZSxNQUFNZ0QsTUFBTSxDQUFDMzVCLENBQUFBLElBQUtBO1lBQzlCLElBQUlrckQsU0FBUyxFQUFFLEVBQUVockQsTUFBTSxFQUFFLEVBQUVDLFNBQVMsRUFBRSxFQUFFazJDLFFBQVEsRUFBRTtZQUNsRCxLQUFLLElBQUlyakMsUUFBUStoQyxNQUFPO2dCQUNwQixJQUFJMEIsUUFBUSxJQUFJLENBQUMxQixLQUFLLENBQUNuckMsT0FBTyxDQUFDb0osT0FBT280QztnQkFDdEMsSUFBSTNVLFFBQVEsR0FBRztvQkFDWDJVLFFBQVFwNEMsS0FBS3FOLE9BQU9uWixJQUFJO29CQUN4Qm12QyxNQUFNaHlDLElBQUksQ0FBQyttRDtnQkFDZixPQUNLO29CQUNEQSxRQUFRLElBQUksQ0FBQ0YsTUFBTSxDQUFDelUsTUFBTTtvQkFDMUIsSUFBSTJVLE1BQU0vcUMsTUFBTSxFQUNaK3FDLE1BQU0vcUMsTUFBTSxDQUFDQTtnQkFDckI7Z0JBQ0E2cUMsT0FBTzdtRCxJQUFJLENBQUMrbUQ7Z0JBQ1hBLENBQUFBLE1BQU1sckQsR0FBRyxHQUFHQSxNQUFNQyxNQUFLLEVBQUdrRSxJQUFJLENBQUMrbUQ7WUFDcEM7WUFDQSxJQUFJLENBQUNyVyxLQUFLLEdBQUdBO1lBQ2IsSUFBSSxDQUFDbVcsTUFBTSxHQUFHQTtZQUNkLElBQUksQ0FBQ2hyRCxHQUFHLENBQUN1SCxJQUFJLENBQUN2SDtZQUNkLElBQUksQ0FBQ0MsTUFBTSxDQUFDc0gsSUFBSSxDQUFDdEg7WUFDakIsS0FBSyxJQUFJc1osS0FBSzQ4QixNQUFPO2dCQUNqQjU4QixFQUFFM2IsR0FBRyxDQUFDcVYsU0FBUyxDQUFDQyxHQUFHLENBQUM7Z0JBQ3BCLElBQUlxRyxFQUFFNDhCLEtBQUssRUFDUDU4QixFQUFFNDhCLEtBQUs7WUFDZjtRQUNKLE9BQ0s7WUFDRCxLQUFLLElBQUk1OEIsS0FBSyxJQUFJLENBQUN5eEMsTUFBTSxDQUNyQixJQUFJenhDLEVBQUU0RyxNQUFNLEVBQ1I1RyxFQUFFNEcsTUFBTSxDQUFDQTtRQUNyQjtJQUNKO0lBQ0F4VyxVQUFVO1FBQ04sSUFBSSxDQUFDM0osR0FBRyxDQUFDdUgsSUFBSSxDQUFDLEVBQUU7UUFDaEIsSUFBSSxDQUFDdEgsTUFBTSxDQUFDc0gsSUFBSSxDQUFDLEVBQUU7SUFDdkI7QUFDSixHQUFHO0lBQ0NxWSxTQUFTQyxDQUFBQSxTQUFVMnlCLFdBQVd2eEIsYUFBYSxDQUFDNUwsRUFBRSxDQUFDck8sQ0FBQUE7WUFDM0MsSUFBSW9MLFFBQVFwTCxLQUFLNlksTUFBTSxDQUFDQTtZQUN4QixPQUFPek4sU0FBUztnQkFBRXBTLEtBQUtvUyxNQUFNcFMsR0FBRyxDQUFDdXJELFlBQVk7Z0JBQUl0ckQsUUFBUW1TLE1BQU1uUyxNQUFNLENBQUNzckQsWUFBWTtZQUFHO1FBQ3pGO0FBQ0o7QUFDQSxNQUFNRjtJQUNGam9ELFlBQVk0RCxJQUFJLEVBQUVoSCxHQUFHLEVBQUU0bUQsU0FBUyxDQUFFO1FBQzlCLElBQUksQ0FBQzUvQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDaEgsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQzRtRCxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ2hwRCxHQUFHLEdBQUd5RztRQUNYLElBQUksQ0FBQzBoRCxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNpRixNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUNNLFdBQVc7SUFDcEI7SUFDQS9qRCxLQUFLeWpELE1BQU0sRUFBRTtRQUNULEtBQUssSUFBSXp4QyxLQUFLLElBQUksQ0FBQ3l4QyxNQUFNLENBQ3JCLElBQUl6eEMsRUFBRTVQLE9BQU8sSUFBSXFoRCxPQUFPdGhELE9BQU8sQ0FBQzZQLEtBQUssR0FDakNBLEVBQUU1UCxPQUFPO1FBQ2pCLElBQUksQ0FBQ3FoRCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUSxPQUFPO0lBQ2hCO0lBQ0FBLFVBQVU7UUFDTixJQUFJLElBQUksQ0FBQ1IsTUFBTSxDQUFDcnNELE1BQU0sSUFBSSxHQUFHO1lBQ3pCLElBQUksSUFBSSxDQUFDZixHQUFHLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDQSxHQUFHLENBQUNzckIsTUFBTTtnQkFDZixJQUFJLENBQUN0ckIsR0FBRyxHQUFHeUc7WUFDZjtZQUNBO1FBQ0o7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDekcsR0FBRyxFQUFFO1lBQ1gsSUFBSSxDQUFDQSxHQUFHLEdBQUc4RyxTQUFTMEssYUFBYSxDQUFDO1lBQ2xDLElBQUksQ0FBQ3hSLEdBQUcsQ0FBQ21SLFNBQVMsR0FBRyxJQUFJLENBQUMvTyxHQUFHLEdBQUcsNEJBQTRCO1lBQzVELElBQUksQ0FBQ3BDLEdBQUcsQ0FBQzJPLEtBQUssQ0FBQyxJQUFJLENBQUN2TSxHQUFHLEdBQUcsUUFBUSxTQUFTLEdBQUc7WUFDOUMsSUFBSVIsU0FBUyxJQUFJLENBQUNvbkQsU0FBUyxJQUFJLElBQUksQ0FBQzUvQyxJQUFJLENBQUNwSixHQUFHO1lBQzVDNEIsT0FBTzBJLFlBQVksQ0FBQyxJQUFJLENBQUN0SyxHQUFHLEVBQUUsSUFBSSxDQUFDb0MsR0FBRyxHQUFHUixPQUFPbUksVUFBVSxHQUFHO1FBQ2pFO1FBQ0EsSUFBSThqRCxTQUFTLElBQUksQ0FBQzd0RCxHQUFHLENBQUMrSixVQUFVO1FBQ2hDLEtBQUssSUFBSXVqRCxTQUFTLElBQUksQ0FBQ0YsTUFBTSxDQUFFO1lBQzNCLElBQUlFLE1BQU10dEQsR0FBRyxDQUFDRSxVQUFVLElBQUksSUFBSSxDQUFDRixHQUFHLEVBQUU7Z0JBQ2xDLE1BQU82dEQsVUFBVVAsTUFBTXR0RCxHQUFHLENBQ3RCNnRELFNBQVNDLEdBQUdEO2dCQUNoQkEsU0FBU0EsT0FBTy9qRCxXQUFXO1lBQy9CLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDOUosR0FBRyxDQUFDc0ssWUFBWSxDQUFDZ2pELE1BQU10dEQsR0FBRyxFQUFFNnREO1lBQ3JDO1FBQ0o7UUFDQSxNQUFPQSxPQUNIQSxTQUFTQyxHQUFHRDtJQUNwQjtJQUNBRixlQUFlO1FBQ1gsT0FBTyxDQUFDLElBQUksQ0FBQzN0RCxHQUFHLElBQUksSUFBSSxDQUFDZ3BELFNBQVMsR0FBRyxJQUMvQjlsRCxLQUFLc0YsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDcEcsR0FBRyxHQUNsQixJQUFJLENBQUNwQyxHQUFHLENBQUN3RSxxQkFBcUIsR0FBR25DLE1BQU0sR0FBR2EsS0FBS3NGLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQ1ksSUFBSSxDQUFDMmhCLFNBQVMsQ0FBQ3ZtQixxQkFBcUIsR0FBR3BDLEdBQUcsSUFDckdjLEtBQUsrQyxHQUFHLENBQUN4RCxhQUFhLElBQUksQ0FBQzJHLElBQUksQ0FBQzJoQixTQUFTLENBQUN2bUIscUJBQXFCLEdBQUduQyxNQUFNLElBQUksSUFBSSxDQUFDckMsR0FBRyxDQUFDd0UscUJBQXFCLEdBQUdwQyxHQUFHO0lBQzVIO0lBQ0FzckQsY0FBYztRQUNWLElBQUksQ0FBQyxJQUFJLENBQUMxRSxTQUFTLElBQUksSUFBSSxDQUFDYixPQUFPLElBQUksSUFBSSxDQUFDLytDLElBQUksQ0FBQ3F1QyxZQUFZLEVBQ3pEO1FBQ0osS0FBSyxJQUFJdGlDLE9BQU8sSUFBSSxDQUFDZ3pDLE9BQU8sQ0FBQ2w2QyxLQUFLLENBQUMsS0FDL0IsSUFBSWtILEtBQ0EsSUFBSSxDQUFDNnpDLFNBQVMsQ0FBQzN6QyxTQUFTLENBQUNpVyxNQUFNLENBQUNuVztRQUN4QyxLQUFLLElBQUlBLE9BQU8sQ0FBQyxJQUFJLENBQUNnekMsT0FBTyxHQUFHLElBQUksQ0FBQy8rQyxJQUFJLENBQUNxdUMsWUFBWSxFQUFFeHBDLEtBQUssQ0FBQyxLQUMxRCxJQUFJa0gsS0FDQSxJQUFJLENBQUM2ekMsU0FBUyxDQUFDM3pDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDSDtJQUN6QztBQUNKO0FBQ0EsU0FBUzI0QyxHQUFHN3RELElBQUk7SUFDWixJQUFJNEosT0FBTzVKLEtBQUs2SixXQUFXO0lBQzNCN0osS0FBS3FyQixNQUFNO0lBQ1gsT0FBT3poQjtBQUNYO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU0yakQsWUFBWSxXQUFXLEdBQUVqdkQsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQ3hDKzZCLFNBQVM0UztBQUNiO0FBRUE7Ozs7QUFJQSxHQUNBLE1BQU1RLHFCQUFxQjN2RCx5REFBVUE7SUFDakM7O0lBRUEsR0FDQXNVLFFBQVFwRixLQUFLLEVBQUU7UUFDWCxPQUFPLElBQUksSUFBSUEsU0FBUyxJQUFJLENBQUM5SCxXQUFXLElBQUk4SCxNQUFNOUgsV0FBVyxJQUFJLElBQUksQ0FBQ0ksRUFBRSxDQUFDMEg7SUFDN0U7SUFDQTs7SUFFQSxHQUNBMUgsR0FBRzBILEtBQUssRUFBRTtRQUFFLE9BQU87SUFBTztJQUMxQjs7O0lBR0EsR0FDQXZCLFFBQVEvTCxHQUFHLEVBQUUsQ0FBRTtBQUNuQjtBQUNBK3RELGFBQWF2Z0QsU0FBUyxDQUFDd2dELFlBQVksR0FBRztBQUN0Q0QsYUFBYXZnRCxTQUFTLENBQUNnRixLQUFLLEdBQUcvTDtBQUMvQnNuRCxhQUFhdmdELFNBQVMsQ0FBQ3VLLE9BQU8sR0FBRzVaLHNEQUFPQSxDQUFDNlosV0FBVztBQUNwRCsxQyxhQUFhdmdELFNBQVMsQ0FBQ2tKLFNBQVMsR0FBR3EzQyxhQUFhdmdELFNBQVMsQ0FBQ21KLE9BQU8sR0FBRyxDQUFDO0FBQ3JFbzNDLGFBQWF2Z0QsU0FBUyxDQUFDc0ssS0FBSyxHQUFHO0FBQy9COzs7Ozs7QUFNQSxHQUNBLE1BQU1tMkMsa0JBQWtCLFdBQVcsR0FBRTF2RCxvREFBS0EsQ0FBQ3FoQixNQUFNO0FBQ2pELE1BQU1zdUMsV0FBVztJQUNiaDlDLE9BQU87SUFDUGk5QyxxQkFBcUI7SUFDckJDLGNBQWM7SUFDZHRQLFNBQVMsSUFBTTVnRCx1REFBUUEsQ0FBQzBVLEtBQUs7SUFDN0J5N0MsWUFBWSxJQUFNO0lBQ2xCQyxjQUFjLElBQU07SUFDcEJDLGtCQUFrQjtJQUNsQkMsZUFBZTtJQUNmQyxjQUFjO0lBQ2Qvc0Msa0JBQWtCLENBQUM7QUFDdkI7QUFDQSxNQUFNZ3RDLGdCQUFnQixXQUFXLEdBQUVud0Qsb0RBQUtBLENBQUNxaEIsTUFBTTtBQUMvQzs7O0FBR0EsR0FDQSxTQUFTK3VDLE9BQU81WixNQUFNO0lBQ2xCLE9BQU87UUFBQzZaO1FBQVdGLGNBQWNqM0MsRUFBRSxDQUFDL0QsT0FBT2k1QyxNQUFNLENBQUNqNUMsT0FBT2k1QyxNQUFNLENBQUMsQ0FBQyxHQUFHdUIsV0FBV25aO0tBQVM7QUFDNUY7QUFDQSxNQUFNOFosZUFBZSxXQUFXLEdBQUV0d0Qsb0RBQUtBLENBQUNxaEIsTUFBTSxDQUFDO0lBQzNDUSxTQUFTQyxDQUFBQSxTQUFVQSxPQUFPOUssSUFBSSxDQUFDclQsQ0FBQUEsSUFBS0E7QUFDeEM7QUFDQTs7Ozs7Ozs7O0FBU0EsR0FDQSxTQUFTMHNELFFBQVE3WixNQUFNO0lBQ25CLElBQUl2a0MsU0FBUztRQUNUcytDO0tBQ0g7SUFDRCxJQUFJL1osVUFBVUEsT0FBT2dhLEtBQUssS0FBSyxPQUMzQnYrQyxPQUFPakssSUFBSSxDQUFDc29ELGFBQWFwM0MsRUFBRSxDQUFDO0lBQ2hDLE9BQU9qSDtBQUNYO0FBQ0EsTUFBTXMrQyxhQUFhLFdBQVcsR0FBRXR0QyxXQUFXWSxTQUFTLENBQUM7SUFDakQ1YyxZQUFZNEQsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDNGxELFlBQVksR0FBRzVsRCxLQUFLeWUsUUFBUTtRQUNqQyxJQUFJLENBQUM3bkIsR0FBRyxHQUFHOEcsU0FBUzBLLGFBQWEsQ0FBQztRQUNsQyxJQUFJLENBQUN4UixHQUFHLENBQUNtUixTQUFTLEdBQUc7UUFDckIsSUFBSSxDQUFDblIsR0FBRyxDQUFDcVIsWUFBWSxDQUFDLGVBQWU7UUFDckMsSUFBSSxDQUFDclIsR0FBRyxDQUFDMk8sS0FBSyxDQUFDMDhCLFNBQVMsR0FBRyxJQUFLLENBQUNqaUMsSUFBSSxDQUFDbWUsYUFBYSxHQUFHLElBQUksQ0FBQ25lLElBQUksQ0FBQ3RHLE1BQU0sR0FBSTtRQUMxRSxJQUFJLENBQUM4ckQsT0FBTyxHQUFHeGxELEtBQUt5SixLQUFLLENBQUNvTyxLQUFLLENBQUN5dEMsZUFBZWp1QyxHQUFHLENBQUNxL0IsQ0FBQUEsT0FBUSxJQUFJbVAsaUJBQWlCN2xELE1BQU0wMkM7UUFDdEYsS0FBSyxJQUFJNk8sVUFBVSxJQUFJLENBQUNDLE9BQU8sQ0FDM0IsSUFBSSxDQUFDNXVELEdBQUcsQ0FBQzBWLFdBQVcsQ0FBQ2k1QyxPQUFPM3VELEdBQUc7UUFDbkMsSUFBSSxDQUFDK3VELEtBQUssR0FBRyxDQUFDM2xELEtBQUt5SixLQUFLLENBQUNvTyxLQUFLLENBQUM0dEM7UUFDL0IsSUFBSSxJQUFJLENBQUNFLEtBQUssRUFBRTtZQUNaLCtEQUErRDtZQUMvRCxnRUFBZ0U7WUFDaEUsOENBQThDO1lBQzlDLElBQUksQ0FBQy91RCxHQUFHLENBQUMyTyxLQUFLLENBQUN6SyxRQUFRLEdBQUc7UUFDOUI7UUFDQSxJQUFJLENBQUNnckQsV0FBVyxDQUFDO1FBQ2pCOWxELEtBQUsyaEIsU0FBUyxDQUFDemdCLFlBQVksQ0FBQyxJQUFJLENBQUN0SyxHQUFHLEVBQUVvSixLQUFLNmMsVUFBVTtJQUN6RDtJQUNBMUQsT0FBT0EsTUFBTSxFQUFFO1FBQ1gsSUFBSSxJQUFJLENBQUM0c0MsYUFBYSxDQUFDNXNDLFNBQVM7WUFDNUIsNkRBQTZEO1lBQzdELDhEQUE4RDtZQUM5RCxVQUFVO1lBQ1YsSUFBSTZzQyxNQUFNLElBQUksQ0FBQ0osWUFBWSxFQUFFSyxNQUFNOXNDLE9BQU9uWixJQUFJLENBQUN5ZSxRQUFRO1lBQ3ZELElBQUl5bkMsWUFBWXBzRCxLQUFLK0MsR0FBRyxDQUFDbXBELElBQUl2b0QsRUFBRSxFQUFFd29ELElBQUl4b0QsRUFBRSxJQUFJM0QsS0FBS3NGLEdBQUcsQ0FBQzRtRCxJQUFJeG9ELElBQUksRUFBRXlvRCxJQUFJem9ELElBQUk7WUFDdEUsSUFBSSxDQUFDc29ELFdBQVcsQ0FBQ0ksWUFBWSxDQUFDRCxJQUFJeG9ELEVBQUUsR0FBR3dvRCxJQUFJem9ELElBQUksSUFBSTtRQUN2RDtRQUNBLElBQUkyYixPQUFPd0MsZUFBZSxFQUN0QixJQUFJLENBQUMva0IsR0FBRyxDQUFDMk8sS0FBSyxDQUFDMDhCLFNBQVMsR0FBRyxJQUFJLENBQUNqaUMsSUFBSSxDQUFDbWUsYUFBYSxHQUFHO1FBQ3pELElBQUksSUFBSSxDQUFDbmUsSUFBSSxDQUFDeUosS0FBSyxDQUFDb08sS0FBSyxDQUFDNHRDLGlCQUFpQixDQUFDLElBQUksQ0FBQ0UsS0FBSyxFQUFFO1lBQ3BELElBQUksQ0FBQ0EsS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDQSxLQUFLO1lBQ3hCLElBQUksQ0FBQy91RCxHQUFHLENBQUMyTyxLQUFLLENBQUN6SyxRQUFRLEdBQUcsSUFBSSxDQUFDNnFELEtBQUssR0FBRyxXQUFXO1FBQ3REO1FBQ0EsSUFBSSxDQUFDQyxZQUFZLEdBQUd6c0MsT0FBT25aLElBQUksQ0FBQ3llLFFBQVE7SUFDNUM7SUFDQXFuQyxZQUFZSyxNQUFNLEVBQUU7UUFDaEIsSUFBSTNtRCxRQUFRLElBQUksQ0FBQzVJLEdBQUcsQ0FBQzhKLFdBQVc7UUFDaEMsSUFBSXlsRCxRQUNBLElBQUksQ0FBQ3Z2RCxHQUFHLENBQUNzckIsTUFBTTtRQUNuQixJQUFJa2tDLGNBQWN0eEQsdURBQVFBLENBQUNzYixJQUFJLENBQUMsSUFBSSxDQUFDcFEsSUFBSSxDQUFDeUosS0FBSyxDQUFDb08sS0FBSyxDQUFDZ3RDLGtCQUFrQixJQUFJLENBQUM3a0QsSUFBSSxDQUFDeWUsUUFBUSxDQUFDamhCLElBQUk7UUFDL0YsSUFBSTZvRCxXQUFXLEVBQUU7UUFDakIsSUFBSUMsV0FBVyxJQUFJLENBQUNkLE9BQU8sQ0FBQ251QyxHQUFHLENBQUNrdUMsQ0FBQUEsU0FBVSxJQUFJZ0IsY0FBY2hCLFFBQVEsSUFBSSxDQUFDdmxELElBQUksQ0FBQ3llLFFBQVEsRUFBRSxDQUFDLElBQUksQ0FBQ3plLElBQUksQ0FBQ3d2QyxlQUFlLENBQUN4MkMsR0FBRztRQUN0SCxLQUFLLElBQUltVixRQUFRLElBQUksQ0FBQ25PLElBQUksQ0FBQ3l2QyxrQkFBa0IsQ0FBRTtZQUMzQyxJQUFJNFcsU0FBUzF1RCxNQUFNLEVBQ2YwdUQsV0FBVyxFQUFFO1lBQ2pCLElBQUkxOUMsTUFBTThlLE9BQU8sQ0FBQ3RaLEtBQUthLElBQUksR0FBRztnQkFDMUIsSUFBSTRwQixRQUFRO2dCQUNaLEtBQUssSUFBSW51QixLQUFLMEQsS0FBS2EsSUFBSSxDQUFFO29CQUNyQixJQUFJdkUsRUFBRXVFLElBQUksSUFBSXJCLFVBQVU5WSxJQUFJLElBQUkrakMsT0FBTzt3QkFDbkM0dEIsY0FBY0osYUFBYUMsVUFBVTU3QyxFQUFFak4sSUFBSTt3QkFDM0MsS0FBSyxJQUFJaXBELE1BQU1ILFNBQ1hHLEdBQUd0NEMsSUFBSSxDQUFDLElBQUksQ0FBQ25PLElBQUksRUFBRXlLLEdBQUc0N0M7d0JBQzFCenRCLFFBQVE7b0JBQ1osT0FDSyxJQUFJbnVCLEVBQUV4QixNQUFNLEVBQUU7d0JBQ2YsS0FBSyxJQUFJdzlDLE1BQU1ILFNBQ1hHLEdBQUd4OUMsTUFBTSxDQUFDLElBQUksQ0FBQ2pKLElBQUksRUFBRXlLO29CQUM3QjtnQkFDSjtZQUNKLE9BQ0ssSUFBSTBELEtBQUthLElBQUksSUFBSXJCLFVBQVU5WSxJQUFJLEVBQUU7Z0JBQ2xDMnhELGNBQWNKLGFBQWFDLFVBQVVsNEMsS0FBSzNRLElBQUk7Z0JBQzlDLEtBQUssSUFBSWlwRCxNQUFNSCxTQUNYRyxHQUFHdDRDLElBQUksQ0FBQyxJQUFJLENBQUNuTyxJQUFJLEVBQUVtTyxNQUFNazRDO1lBQ2pDLE9BQ0ssSUFBSWw0QyxLQUFLbEYsTUFBTSxFQUFFO2dCQUNsQixLQUFLLElBQUl3OUMsTUFBTUgsU0FDWEcsR0FBR3g5QyxNQUFNLENBQUMsSUFBSSxDQUFDakosSUFBSSxFQUFFbU87WUFDN0I7UUFDSjtRQUNBLEtBQUssSUFBSXM0QyxNQUFNSCxTQUNYRyxHQUFHNTFDLE1BQU07UUFDYixJQUFJczFDLFFBQ0EsSUFBSSxDQUFDbm1ELElBQUksQ0FBQzJoQixTQUFTLENBQUN6Z0IsWUFBWSxDQUFDLElBQUksQ0FBQ3RLLEdBQUcsRUFBRTRJO0lBQ25EO0lBQ0F1bUQsY0FBYzVzQyxNQUFNLEVBQUU7UUFDbEIsSUFBSWphLE9BQU9pYSxPQUFPaUMsVUFBVSxDQUFDdkQsS0FBSyxDQUFDeXRDLGdCQUFnQjlxRCxNQUFNMmUsT0FBTzFQLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ3l0QztRQUM1RSxJQUFJdmYsU0FBUzVzQixPQUFPeUMsVUFBVSxJQUFJekMsT0FBT3VDLGFBQWEsSUFBSXZDLE9BQU9zQyxlQUFlLElBQzVFLENBQUMzbUIsdURBQVFBLENBQUMwSCxFQUFFLENBQUMyYyxPQUFPaUMsVUFBVSxDQUFDdkQsS0FBSyxDQUFDZ3RDLGtCQUFrQjFyQyxPQUFPMVAsS0FBSyxDQUFDb08sS0FBSyxDQUFDZ3RDLGtCQUFrQjFyQyxPQUFPblosSUFBSSxDQUFDeWUsUUFBUSxDQUFDamhCLElBQUksRUFBRTJiLE9BQU9uWixJQUFJLENBQUN5ZSxRQUFRLENBQUNoaEIsRUFBRTtRQUNsSixJQUFJeUIsUUFBUTFFLEtBQUs7WUFDYixLQUFLLElBQUkrcUQsVUFBVSxJQUFJLENBQUNDLE9BQU8sQ0FDM0IsSUFBSUQsT0FBT3BzQyxNQUFNLENBQUNBLFNBQ2Q0c0IsU0FBUztRQUNyQixPQUNLO1lBQ0RBLFNBQVM7WUFDVCxJQUFJeWYsVUFBVSxFQUFFO1lBQ2hCLEtBQUssSUFBSTlPLFFBQVFsOEMsSUFBSztnQkFDbEIsSUFBSSswQyxRQUFRcndDLEtBQUt3RCxPQUFPLENBQUNnMEM7Z0JBQ3pCLElBQUluSCxRQUFRLEdBQUc7b0JBQ1hpVyxRQUFRcm9ELElBQUksQ0FBQyxJQUFJMG9ELGlCQUFpQixJQUFJLENBQUM3bEQsSUFBSSxFQUFFMDJDO2dCQUNqRCxPQUNLO29CQUNELElBQUksQ0FBQzhPLE9BQU8sQ0FBQ2pXLE1BQU0sQ0FBQ3AyQixNQUFNLENBQUNBO29CQUMzQnFzQyxRQUFRcm9ELElBQUksQ0FBQyxJQUFJLENBQUNxb0QsT0FBTyxDQUFDalcsTUFBTTtnQkFDcEM7WUFDSjtZQUNBLEtBQUssSUFBSTlGLEtBQUssSUFBSSxDQUFDK2IsT0FBTyxDQUFFO2dCQUN4Qi9iLEVBQUU3eUMsR0FBRyxDQUFDc3JCLE1BQU07Z0JBQ1osSUFBSXNqQyxRQUFROWlELE9BQU8sQ0FBQyttQyxLQUFLLEdBQ3JCQSxFQUFFOW1DLE9BQU87WUFDakI7WUFDQSxLQUFLLElBQUk4bUMsS0FBSytiLFFBQ1YsSUFBSSxDQUFDNXVELEdBQUcsQ0FBQzBWLFdBQVcsQ0FBQ205QixFQUFFN3lDLEdBQUc7WUFDOUIsSUFBSSxDQUFDNHVELE9BQU8sR0FBR0E7UUFDbkI7UUFDQSxPQUFPemY7SUFDWDtJQUNBcGpDLFVBQVU7UUFDTixLQUFLLElBQUkzQyxRQUFRLElBQUksQ0FBQ3dsRCxPQUFPLENBQ3pCeGxELEtBQUsyQyxPQUFPO1FBQ2hCLElBQUksQ0FBQy9MLEdBQUcsQ0FBQ3NyQixNQUFNO0lBQ25CO0FBQ0osR0FBRztJQUNDdEosU0FBU0MsQ0FBQUEsU0FBVTJ5QixXQUFXdnhCLGFBQWEsQ0FBQzVMLEVBQUUsQ0FBQ3JPLENBQUFBO1lBQzNDLElBQUlvTCxRQUFRcEwsS0FBSzZZLE1BQU0sQ0FBQ0E7WUFDeEIsSUFBSSxDQUFDek4sU0FBU0EsTUFBTW82QyxPQUFPLENBQUM3dEQsTUFBTSxJQUFJLEtBQUssQ0FBQ3lULE1BQU11NkMsS0FBSyxFQUNuRCxPQUFPO1lBQ1gsT0FBTzNsRCxLQUFLNmhCLGFBQWEsSUFBSS9QLFVBQVVDLEdBQUcsR0FDcEM7Z0JBQUVsWixNQUFNdVMsTUFBTXhVLEdBQUcsQ0FBQzZDLFdBQVcsR0FBR3VHLEtBQUt6RyxNQUFNO1lBQUMsSUFDNUM7Z0JBQUVSLE9BQU9xUyxNQUFNeFUsR0FBRyxDQUFDNkMsV0FBVyxHQUFHdUcsS0FBS3pHLE1BQU07WUFBQztRQUN2RDtBQUNKO0FBQ0EsU0FBU210RCxRQUFRdm1CLEdBQUc7SUFBSSxPQUFReDNCLE1BQU04ZSxPQUFPLENBQUMwWSxPQUFPQSxNQUFNO1FBQUNBO0tBQUk7QUFBRztBQUNuRSxTQUFTcW1CLGNBQWNyMkMsTUFBTSxFQUFFdzJDLE9BQU8sRUFBRTFtRCxHQUFHO0lBQ3ZDLE1BQU9rUSxPQUFPL0UsS0FBSyxJQUFJK0UsT0FBTzNTLElBQUksSUFBSXlDLElBQUs7UUFDdkMsSUFBSWtRLE9BQU8zUyxJQUFJLElBQUl5QyxLQUNmMG1ELFFBQVF4cEQsSUFBSSxDQUFDZ1QsT0FBTy9FLEtBQUs7UUFDN0IrRSxPQUFPMVAsSUFBSTtJQUNmO0FBQ0o7QUFDQSxNQUFNOGxEO0lBQ0ZucUQsWUFBWW1wRCxNQUFNLEVBQUU5bUMsUUFBUSxFQUFFOWtCLE1BQU0sQ0FBRTtRQUNsQyxJQUFJLENBQUM0ckQsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzVyRCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDMkQsQ0FBQyxHQUFHO1FBQ1QsSUFBSSxDQUFDNlMsTUFBTSxHQUFHcmIsdURBQVFBLENBQUNzYixJQUFJLENBQUNtMUMsT0FBTzdQLE9BQU8sRUFBRWozQixTQUFTamhCLElBQUk7SUFDN0Q7SUFDQW9wRCxXQUFXNW1ELElBQUksRUFBRWtOLEtBQUssRUFBRXdvQyxPQUFPLEVBQUU7UUFDN0IsSUFBSSxFQUFFNlAsTUFBTSxFQUFFLEdBQUcsSUFBSSxFQUFFdGdDLFFBQVEsQ0FBQy9YLE1BQU1sVSxHQUFHLEdBQUcsSUFBSSxDQUFDVyxNQUFNLElBQUlxRyxLQUFLdEcsTUFBTSxFQUFFQyxTQUFTdVQsTUFBTXZULE1BQU0sR0FBR3FHLEtBQUt0RyxNQUFNO1FBQzNHLElBQUksSUFBSSxDQUFDNEQsQ0FBQyxJQUFJaW9ELE9BQU9zQixRQUFRLENBQUNsdkQsTUFBTSxFQUFFO1lBQ2xDLElBQUltdkQsU0FBUyxJQUFJQyxjQUFjL21ELE1BQU1yRyxRQUFRc3JCLE9BQU95d0I7WUFDcEQ2UCxPQUFPc0IsUUFBUSxDQUFDMXBELElBQUksQ0FBQzJwRDtZQUNyQnZCLE9BQU8zdUQsR0FBRyxDQUFDMFYsV0FBVyxDQUFDdzZDLE9BQU9sd0QsR0FBRztRQUNyQyxPQUNLO1lBQ0QydUQsT0FBT3NCLFFBQVEsQ0FBQyxJQUFJLENBQUN2cEQsQ0FBQyxDQUFDLENBQUM2YixNQUFNLENBQUNuWixNQUFNckcsUUFBUXNyQixPQUFPeXdCO1FBQ3hEO1FBQ0EsSUFBSSxDQUFDLzdDLE1BQU0sR0FBR3VULE1BQU1qVSxNQUFNO1FBQzFCLElBQUksQ0FBQ3FFLENBQUM7SUFDVjtJQUNBNlEsS0FBS25PLElBQUksRUFBRW1PLElBQUksRUFBRTY0QyxZQUFZLEVBQUU7UUFDM0IsSUFBSUMsZUFBZSxFQUFFO1FBQ3JCVCxjQUFjLElBQUksQ0FBQ3IyQyxNQUFNLEVBQUU4MkMsY0FBYzk0QyxLQUFLM1EsSUFBSTtRQUNsRCxJQUFJd3BELGFBQWFydkQsTUFBTSxFQUNuQnN2RCxlQUFlQSxhQUFhbm9DLE1BQU0sQ0FBQ2tvQztRQUN2QyxJQUFJRSxVQUFVLElBQUksQ0FBQzNCLE1BQU0sQ0FBQzVaLE1BQU0sQ0FBQ3NaLFVBQVUsQ0FBQ2psRCxNQUFNbU8sTUFBTTg0QztRQUN4RCxJQUFJQyxTQUNBRCxhQUFhcHVCLE9BQU8sQ0FBQ3F1QjtRQUN6QixJQUFJM0IsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFDeEIsSUFBSTBCLGFBQWF0dkQsTUFBTSxJQUFJLEtBQUssQ0FBQzR0RCxPQUFPNVosTUFBTSxDQUFDb1osbUJBQW1CLEVBQzlEO1FBQ0osSUFBSSxDQUFDNkIsVUFBVSxDQUFDNW1ELE1BQU1tTyxNQUFNODRDO0lBQ2hDO0lBQ0FoK0MsT0FBT2pKLElBQUksRUFBRWtOLEtBQUssRUFBRTtRQUNoQixJQUFJNG9DLFNBQVMsSUFBSSxDQUFDeVAsTUFBTSxDQUFDNVosTUFBTSxDQUFDdVosWUFBWSxDQUFDbGxELE1BQU1rTixNQUFNakUsTUFBTSxFQUFFaUU7UUFDakUsSUFBSTRvQyxRQUNBLElBQUksQ0FBQzhRLFVBQVUsQ0FBQzVtRCxNQUFNa04sT0FBTztZQUFDNG9DO1NBQU87SUFDN0M7SUFDQWpsQyxTQUFTO1FBQ0wsSUFBSTAwQyxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUN4QixNQUFPQSxPQUFPc0IsUUFBUSxDQUFDbHZELE1BQU0sR0FBRyxJQUFJLENBQUMyRixDQUFDLENBQUU7WUFDcEMsSUFBSXFILE9BQU80Z0QsT0FBT3NCLFFBQVEsQ0FBQy9oRCxHQUFHO1lBQzlCeWdELE9BQU8zdUQsR0FBRyxDQUFDeU4sV0FBVyxDQUFDTSxLQUFLL04sR0FBRztZQUMvQitOLEtBQUtoQyxPQUFPO1FBQ2hCO0lBQ0o7QUFDSjtBQUNBLE1BQU1rakQ7SUFDRnpwRCxZQUFZNEQsSUFBSSxFQUFFMnJDLE1BQU0sQ0FBRTtRQUN0QixJQUFJLENBQUMzckMsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQzJyQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDa2IsUUFBUSxHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDTSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUN2d0QsR0FBRyxHQUFHOEcsU0FBUzBLLGFBQWEsQ0FBQztRQUNsQyxJQUFJLENBQUN4UixHQUFHLENBQUNtUixTQUFTLEdBQUcsY0FBZSxLQUFJLENBQUM0akMsTUFBTSxDQUFDN2pDLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQzZqQyxNQUFNLENBQUM3akMsS0FBSyxHQUFHLEVBQUM7UUFDbkYsSUFBSyxJQUFJcy9DLFFBQVF6YixPQUFPcnpCLGdCQUFnQixDQUFFO1lBQ3RDLElBQUksQ0FBQzFoQixHQUFHLENBQUMwMEIsZ0JBQWdCLENBQUM4N0IsTUFBTSxDQUFDNzlDO2dCQUM3QixJQUFJL1MsU0FBUytTLE1BQU0vUyxNQUFNLEVBQUUwRDtnQkFDM0IsSUFBSTFELFVBQVUsSUFBSSxDQUFDSSxHQUFHLElBQUksSUFBSSxDQUFDQSxHQUFHLENBQUNELFFBQVEsQ0FBQ0gsU0FBUztvQkFDakQsTUFBT0EsT0FBT00sVUFBVSxJQUFJLElBQUksQ0FBQ0YsR0FBRyxDQUNoQ0osU0FBU0EsT0FBT00sVUFBVTtvQkFDOUIsSUFBSThCLE9BQU9wQyxPQUFPNEUscUJBQXFCO29CQUN2Q2xCLElBQUksQ0FBQ3RCLEtBQUtJLEdBQUcsR0FBR0osS0FBS0ssTUFBTSxJQUFJO2dCQUNuQyxPQUNLO29CQUNEaUIsSUFBSXFQLE1BQU1na0IsT0FBTztnQkFDckI7Z0JBQ0EsSUFBSXBmLE9BQU9uTyxLQUFLKy9CLGlCQUFpQixDQUFDN2xDLElBQUk4RixLQUFLZ3BCLFdBQVc7Z0JBQ3RELElBQUkyaUIsT0FBT3J6QixnQkFBZ0IsQ0FBQzh1QyxLQUFLLENBQUNwbkQsTUFBTW1PLE1BQU01RSxRQUMxQ0EsTUFBTXNpQixjQUFjO1lBQzVCO1FBQ0o7UUFDQSxJQUFJLENBQUM2cEIsT0FBTyxHQUFHZ1IsUUFBUS9hLE9BQU8rSixPQUFPLENBQUMxMUM7UUFDdEMsSUFBSTJyQyxPQUFPeVosYUFBYSxFQUFFO1lBQ3RCLElBQUksQ0FBQytCLE1BQU0sR0FBRyxJQUFJSixjQUFjL21ELE1BQU0sR0FBRyxHQUFHO2dCQUFDMnJDLE9BQU95WixhQUFhLENBQUNwbEQ7YUFBTTtZQUN4RSxJQUFJLENBQUNwSixHQUFHLENBQUMwVixXQUFXLENBQUMsSUFBSSxDQUFDNjZDLE1BQU0sQ0FBQ3Z3RCxHQUFHO1lBQ3BDLElBQUksQ0FBQ3V3RCxNQUFNLENBQUN2d0QsR0FBRyxDQUFDMk8sS0FBSyxDQUFDeUYsT0FBTyxJQUFJO1FBQ3JDO0lBQ0o7SUFDQW1PLE9BQU9BLE1BQU0sRUFBRTtRQUNYLElBQUlrdUMsY0FBYyxJQUFJLENBQUMzUixPQUFPO1FBQzlCLElBQUksQ0FBQ0EsT0FBTyxHQUFHZ1IsUUFBUSxJQUFJLENBQUMvYSxNQUFNLENBQUMrSixPQUFPLENBQUN2OEIsT0FBT25aLElBQUk7UUFDdEQsSUFBSSxJQUFJLENBQUNtbkQsTUFBTSxJQUFJLElBQUksQ0FBQ3hiLE1BQU0sQ0FBQzBaLFlBQVksRUFBRTtZQUN6QyxJQUFJdjJCLFVBQVUsSUFBSSxDQUFDNmMsTUFBTSxDQUFDMFosWUFBWSxDQUFDLElBQUksQ0FBQzhCLE1BQU0sQ0FBQ3pSLE9BQU8sQ0FBQyxFQUFFLEVBQUV2OEI7WUFDL0QsSUFBSTJWLFdBQVcsSUFBSSxDQUFDcTRCLE1BQU0sQ0FBQ3pSLE9BQU8sQ0FBQyxFQUFFLEVBQ2pDLElBQUksQ0FBQ3lSLE1BQU0sQ0FBQ2h1QyxNQUFNLENBQUNBLE9BQU9uWixJQUFJLEVBQUUsR0FBRyxHQUFHO2dCQUFDOHVCO2FBQVE7UUFDdkQ7UUFDQSxJQUFJbVAsS0FBSzlrQixPQUFPblosSUFBSSxDQUFDeWUsUUFBUTtRQUM3QixPQUFPLENBQUMzcEIsdURBQVFBLENBQUMwSCxFQUFFLENBQUMsSUFBSSxDQUFDazVDLE9BQU8sRUFBRTJSLGFBQWFwcEIsR0FBR3pnQyxJQUFJLEVBQUV5Z0MsR0FBR3hnQyxFQUFFLEtBQ3hELEtBQUksQ0FBQ2t1QyxNQUFNLENBQUN3WixnQkFBZ0IsR0FBRyxJQUFJLENBQUN4WixNQUFNLENBQUN3WixnQkFBZ0IsQ0FBQ2hzQyxVQUFVLEtBQUk7SUFDbkY7SUFDQXhXLFVBQVU7UUFDTixLQUFLLElBQUkxTCxPQUFPLElBQUksQ0FBQzR2RCxRQUFRLENBQ3pCNXZELElBQUkwTCxPQUFPO0lBQ25CO0FBQ0o7QUFDQSxNQUFNb2tEO0lBQ0YzcUQsWUFBWTRELElBQUksRUFBRXJHLE1BQU0sRUFBRXNyQixLQUFLLEVBQUV5d0IsT0FBTyxDQUFFO1FBQ3RDLElBQUksQ0FBQy83QyxNQUFNLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQ3NyQixLQUFLLEdBQUc7UUFDYixJQUFJLENBQUN5d0IsT0FBTyxHQUFHLEVBQUU7UUFDakIsSUFBSSxDQUFDOStDLEdBQUcsR0FBRzhHLFNBQVMwSyxhQUFhLENBQUM7UUFDbEMsSUFBSSxDQUFDeFIsR0FBRyxDQUFDbVIsU0FBUyxHQUFHO1FBQ3JCLElBQUksQ0FBQ29SLE1BQU0sQ0FBQ25aLE1BQU1yRyxRQUFRc3JCLE9BQU95d0I7SUFDckM7SUFDQXY4QixPQUFPblosSUFBSSxFQUFFckcsTUFBTSxFQUFFc3JCLEtBQUssRUFBRXl3QixPQUFPLEVBQUU7UUFDakMsSUFBSSxJQUFJLENBQUMvN0MsTUFBTSxJQUFJQSxRQUFRO1lBQ3ZCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtZQUNkLElBQUksQ0FBQy9DLEdBQUcsQ0FBQzJPLEtBQUssQ0FBQzVMLE1BQU0sR0FBR0EsU0FBUztRQUNyQztRQUNBLElBQUksSUFBSSxDQUFDc3JCLEtBQUssSUFBSUEsT0FDZCxJQUFJLENBQUNydUIsR0FBRyxDQUFDMk8sS0FBSyxDQUFDKzRCLFNBQVMsR0FBRyxDQUFDLElBQUksQ0FBQ3JaLEtBQUssR0FBR0EsS0FBSSxJQUFLQSxRQUFRLE9BQU87UUFDckUsSUFBSSxDQUFDcWlDLFlBQVksSUFBSSxDQUFDNVIsT0FBTyxFQUFFQSxVQUMzQixJQUFJLENBQUM2UixVQUFVLENBQUN2bkQsTUFBTTAxQztJQUM5QjtJQUNBNlIsV0FBV3ZuRCxJQUFJLEVBQUUwMUMsT0FBTyxFQUFFO1FBQ3RCLElBQUkzcEMsTUFBTSxvQkFBb0J5N0MsU0FBUyxJQUFJLENBQUM1d0QsR0FBRyxDQUFDK0osVUFBVTtRQUMxRCxJQUFLLElBQUk4bUQsT0FBTyxHQUFHQyxPQUFPLElBQUs7WUFDM0IsSUFBSUMsU0FBU0QsTUFBTTVSLFNBQVMyUixPQUFPL1IsUUFBUS85QyxNQUFNLEdBQUcrOUMsT0FBTyxDQUFDK1IsT0FBTyxHQUFHLE1BQU1HLFVBQVU7WUFDdEYsSUFBSTlSLFFBQVE7Z0JBQ1IsSUFBSTUyQixJQUFJNDJCLE9BQU84TyxZQUFZO2dCQUMzQixJQUFJMWxDLEdBQ0FuVCxPQUFPLE1BQU1tVDtnQkFDakIsSUFBSyxJQUFJNWhCLElBQUlvcUQsTUFBTXBxRCxJQUFJLElBQUksQ0FBQ280QyxPQUFPLENBQUMvOUMsTUFBTSxFQUFFMkYsSUFDeEMsSUFBSSxJQUFJLENBQUNvNEMsT0FBTyxDQUFDcDRDLEVBQUUsQ0FBQ2dNLE9BQU8sQ0FBQ3dzQyxTQUFTO29CQUNqQzZSLFNBQVNycUQ7b0JBQ1RzcUQsVUFBVTtvQkFDVjtnQkFDSjtZQUNSLE9BQ0s7Z0JBQ0RELFNBQVMsSUFBSSxDQUFDalMsT0FBTyxDQUFDLzlDLE1BQU07WUFDaEM7WUFDQSxNQUFPK3ZELE9BQU9DLE9BQVE7Z0JBQ2xCLElBQUlsbkQsT0FBTyxJQUFJLENBQUNpMUMsT0FBTyxDQUFDZ1MsT0FBTztnQkFDL0IsSUFBSWpuRCxLQUFLMkksS0FBSyxFQUFFO29CQUNaM0ksS0FBS2tDLE9BQU8sQ0FBQzZrRDtvQkFDYixJQUFJaG9ELFFBQVFnb0QsT0FBTzltRCxXQUFXO29CQUM5QjhtRCxPQUFPdGxDLE1BQU07b0JBQ2JzbEMsU0FBU2hvRDtnQkFDYjtZQUNKO1lBQ0EsSUFBSSxDQUFDczJDLFFBQ0Q7WUFDSixJQUFJQSxPQUFPMXNDLEtBQUssRUFBRTtnQkFDZCxJQUFJdytDLFNBQ0FKLFNBQVNBLE9BQU85bUQsV0FBVztxQkFFM0IsSUFBSSxDQUFDOUosR0FBRyxDQUFDc0ssWUFBWSxDQUFDNDBDLE9BQU8xc0MsS0FBSyxDQUFDcEosT0FBT3duRDtZQUNsRDtZQUNBLElBQUlJLFNBQ0FGO1FBQ1I7UUFDQSxJQUFJLENBQUM5d0QsR0FBRyxDQUFDbVIsU0FBUyxHQUFHZ0U7UUFDckIsSUFBSSxDQUFDMnBDLE9BQU8sR0FBR0E7SUFDbkI7SUFDQS95QyxVQUFVO1FBQ04sSUFBSSxDQUFDNGtELFVBQVUsQ0FBQyxNQUFNLEVBQUUsR0FBRyxrREFBa0Q7SUFDakY7QUFDSjtBQUNBLFNBQVNELFlBQVk5OEMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3JCLElBQUlELEVBQUU3UyxNQUFNLElBQUk4UyxFQUFFOVMsTUFBTSxFQUNwQixPQUFPO0lBQ1gsSUFBSyxJQUFJMkYsSUFBSSxHQUFHQSxJQUFJa04sRUFBRTdTLE1BQU0sRUFBRTJGLElBQzFCLElBQUksQ0FBQ2tOLENBQUMsQ0FBQ2xOLEVBQUUsQ0FBQ2dNLE9BQU8sQ0FBQ21CLENBQUMsQ0FBQ25OLEVBQUUsR0FDbEIsT0FBTztJQUNmLE9BQU87QUFDWDtBQUNBOztBQUVBLEdBQ0EsTUFBTXVxRCxvQkFBb0IsV0FBVyxHQUFFMXlELG9EQUFLQSxDQUFDcWhCLE1BQU07QUFDbkQsTUFBTXN4QyxtQkFBbUIsV0FBVyxHQUFFM3lELG9EQUFLQSxDQUFDcWhCLE1BQU0sQ0FBQztJQUMvQ1EsU0FBUUMsTUFBTTtRQUNWLE9BQU9uaEIsZ0VBQWFBLENBQUNtaEIsUUFBUTtZQUFFOHdDLGNBQWNod0M7WUFBUU8sa0JBQWtCLENBQUM7UUFBRSxHQUFHO1lBQ3pFQSxrQkFBaUI5TixDQUFDLEVBQUVDLENBQUM7Z0JBQ2pCLElBQUlyRCxTQUFTa0QsT0FBT2k1QyxNQUFNLENBQUMsQ0FBQyxHQUFHLzRDO2dCQUMvQixJQUFLLElBQUlqQixTQUFTa0IsRUFBRztvQkFDakIsSUFBSXloQixTQUFTOWtCLE1BQU0sQ0FBQ21DLE1BQU0sRUFBRTJDLE1BQU16QixDQUFDLENBQUNsQixNQUFNO29CQUMxQ25DLE1BQU0sQ0FBQ21DLE1BQU0sR0FBRzJpQixTQUFTLENBQUNsc0IsTUFBTW1PLE1BQU01RSxRQUFVMmlCLE9BQU9sc0IsTUFBTW1PLE1BQU01RSxVQUFVMkMsSUFBSWxNLE1BQU1tTyxNQUFNNUUsU0FBUzJDO2dCQUMxRztnQkFDQSxPQUFPOUU7WUFDWDtRQUNKO0lBQ0o7QUFDSjtBQUNBLE1BQU00Z0QscUJBQXFCckQ7SUFDdkJ2b0QsWUFBWWdzQixNQUFNLENBQUU7UUFDaEIsS0FBSztRQUNMLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtJQUNsQjtJQUNBNXJCLEdBQUcwSCxLQUFLLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQ2trQixNQUFNLElBQUlsa0IsTUFBTWtrQixNQUFNO0lBQUU7SUFDaERoZixRQUFRO1FBQUUsT0FBTzFMLFNBQVN3SixjQUFjLENBQUMsSUFBSSxDQUFDa2hCLE1BQU07SUFBRztBQUMzRDtBQUNBLFNBQVMyL0IsYUFBYS9uRCxJQUFJLEVBQUVvb0IsTUFBTTtJQUM5QixPQUFPcG9CLEtBQUt5SixLQUFLLENBQUNvTyxLQUFLLENBQUNpd0Msa0JBQWtCQyxZQUFZLENBQUMzL0IsUUFBUXBvQixLQUFLeUosS0FBSztBQUM3RTtBQUNBLE1BQU13K0MsbUJBQW1CLFdBQVcsR0FBRTNDLGNBQWMxRCxPQUFPLENBQUM7SUFBQ2tHO0NBQWlCLEVBQUVyK0MsQ0FBQUEsUUFBVTtRQUN0RjNCLE9BQU87UUFDUGk5QyxxQkFBcUI7UUFDckJyUCxTQUFRMTFDLElBQUk7WUFBSSxPQUFPQSxLQUFLeUosS0FBSyxDQUFDb08sS0FBSyxDQUFDZ3dDO1FBQW9CO1FBQzVENUMsWUFBV2psRCxJQUFJLEVBQUVtTyxJQUFJLEVBQUVteUMsTUFBTTtZQUN6QixJQUFJQSxPQUFPbjBDLElBQUksQ0FBQ2dPLENBQUFBLElBQUtBLEVBQUUvUSxLQUFLLEdBQ3hCLE9BQU87WUFDWCxPQUFPLElBQUk0K0MsYUFBYUQsYUFBYS9uRCxNQUFNQSxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDdVosTUFBTSxDQUFDcEMsS0FBSzNRLElBQUksRUFBRTRxQixNQUFNO1FBQ3RGO1FBQ0E4OEIsY0FBYyxJQUFNO1FBQ3BCQyxrQkFBa0Joc0MsQ0FBQUEsU0FBVUEsT0FBT2lDLFVBQVUsQ0FBQ3ZELEtBQUssQ0FBQ2l3QyxxQkFBcUIzdUMsT0FBTzFQLEtBQUssQ0FBQ29PLEtBQUssQ0FBQ2l3QztRQUM1RjFDLGVBQWNwbEQsSUFBSTtZQUNkLE9BQU8sSUFBSWdvRCxhQUFhRCxhQUFhL25ELE1BQU1rb0QsY0FBY2xvRCxLQUFLeUosS0FBSyxDQUFDelMsR0FBRyxDQUFDMm1CLEtBQUs7UUFDakY7UUFDQTBuQyxjQUFhOEIsTUFBTSxFQUFFaHVDLE1BQU07WUFDdkIsSUFBSS9aLE1BQU0yb0QsYUFBYTV1QyxPQUFPblosSUFBSSxFQUFFa29ELGNBQWMvdUMsT0FBT25aLElBQUksQ0FBQ3lKLEtBQUssQ0FBQ3pTLEdBQUcsQ0FBQzJtQixLQUFLO1lBQzdFLE9BQU92ZSxPQUFPK25ELE9BQU8vK0IsTUFBTSxHQUFHKytCLFNBQVMsSUFBSWEsYUFBYTVvRDtRQUM1RDtRQUNBa1osa0JBQWtCN08sTUFBTW9PLEtBQUssQ0FBQ2l3QyxrQkFBa0J4dkMsZ0JBQWdCO0lBQ3BFO0FBQ0E7O0FBRUEsR0FDQSxTQUFTNnZDLFlBQVl4YyxTQUFTLENBQUMsQ0FBQztJQUM1QixPQUFPO1FBQ0htYyxpQkFBaUJ6NUMsRUFBRSxDQUFDczlCO1FBQ3BCNlo7UUFDQXlDO0tBQ0g7QUFDTDtBQUNBLFNBQVNDLGNBQWN2cUMsS0FBSztJQUN4QixJQUFJaFosT0FBTztJQUNYLE1BQU9BLE9BQU9nWixNQUNWaFosT0FBT0EsT0FBTyxLQUFLO0lBQ3ZCLE9BQU9BO0FBQ1g7QUFDQSxNQUFNeWpELHlCQUF5QixXQUFXLEdBQUUsSUFBSSxjQUFjekQ7SUFDMUR2b0QsYUFBYztRQUNWLEtBQUssSUFBSWtQO1FBQ1QsSUFBSSxDQUFDczVDLFlBQVksR0FBRztJQUN4QjtBQUNKO0FBQ0EsTUFBTXlELDhCQUE4QixXQUFXLEdBQUV4RCxnQkFBZ0JqRCxPQUFPLENBQUM7SUFBQztDQUFZLEVBQUVuNEMsQ0FBQUE7SUFDcEYsSUFBSXVWLFFBQVEsRUFBRSxFQUFFcmEsT0FBTyxDQUFDO0lBQ3hCLEtBQUssSUFBSWhJLFNBQVM4TSxNQUFNcFMsU0FBUyxDQUFDb1ksTUFBTSxDQUFFO1FBQ3RDLElBQUkyVSxVQUFVM2EsTUFBTXpTLEdBQUcsQ0FBQ3VaLE1BQU0sQ0FBQzVULE1BQU1vWixJQUFJLEVBQUV2WSxJQUFJO1FBQy9DLElBQUk0bUIsVUFBVXpmLE1BQU07WUFDaEJBLE9BQU95ZjtZQUNQcEYsTUFBTTdoQixJQUFJLENBQUNpckQsdUJBQXVCenJELEtBQUssQ0FBQ3luQjtRQUM1QztJQUNKO0lBQ0EsT0FBT3R2Qix1REFBUUEsQ0FBQ3VaLEVBQUUsQ0FBQzJRO0FBQ3ZCO0FBQ0E7Ozs7QUFJQSxHQUNBLFNBQVNzcEM7SUFDTCxPQUFPRDtBQUNYO0FBRUEsTUFBTUUsaUJBQWlCLFdBQVcsR0FBRSxJQUFJMWM7QUFDeEMsU0FBUzJjLGtCQUFrQm5JLEtBQUs7SUFDNUIsSUFBSXgwQyxPQUFPMDhDLGVBQWUxbkQsR0FBRyxDQUFDdy9DO0lBQzlCLElBQUksQ0FBQ3gwQyxNQUNEMDhDLGVBQWUzckQsR0FBRyxDQUFDeWpELE9BQU94MEMsT0FBTytCLFdBQVdqRyxJQUFJLENBQUM7UUFDN0M3SSxZQUFZdWhELFVBQVUsTUFBTztZQUN6QnY0QyxPQUFPO1FBQ1gsSUFBSTtZQUNBQSxPQUFPO1lBQ1AsZ0JBQWdCdTRDLE1BQU0vOEMsT0FBTyxDQUFDLE1BQU07UUFDeEM7SUFDSjtJQUNKLE9BQU91STtBQUNYO0FBQ0EsU0FBUzQ4QyxRQUFRMU4sU0FBUztJQUN0QixPQUFPM2lDLFdBQVc1QixNQUFNLENBQUN4VyxDQUFBQSxPQUFTO1lBQzlCd1IsYUFBYXVwQyxVQUFVL0IsVUFBVSxDQUFDaDVDO1lBQ2xDbVosUUFBT3V2QyxDQUFDO2dCQUNKLElBQUksQ0FBQ2wzQyxXQUFXLEdBQUd1cEMsVUFBVWorQixVQUFVLENBQUM0ckMsR0FBRyxJQUFJLENBQUNsM0MsV0FBVztZQUMvRDtRQUNKLElBQUk7UUFDQUEsYUFBYWhQLENBQUFBLElBQUtBLEVBQUVnUCxXQUFXO0lBQ25DO0FBQ0o7QUFDQSxNQUFNbTNDLHdCQUF3QixXQUFXLEdBQUVGLFFBQVEsV0FBVyxHQUFFLElBQUlsUSxlQUFlO0lBQy9FQyxRQUFRO0lBQ1JDLFlBQVlLLENBQUFBLFFBQVMwUCxrQkFBa0IxUCxLQUFLLENBQUMsRUFBRTtJQUMvQ0gsVUFBVTtBQUNkO0FBQ0E7Ozs7O0FBS0EsR0FDQSxTQUFTaVE7SUFDTCxPQUFPRDtBQUNYO0FBQ0EsTUFBTUUsc0JBQXNCLFdBQVcsR0FBRUosUUFBUSxXQUFXLEdBQUUsSUFBSWxRLGVBQWU7SUFDN0VDLFFBQVE7SUFDUkMsWUFBWSxXQUFXLEdBQUU3cUMsV0FBV2pHLElBQUksQ0FBQztRQUFFRyxPQUFPO0lBQW1CO0lBQ3JFNndDLFVBQVU7QUFDZDtBQUNBOzs7QUFHQSxHQUNBLFNBQVNtUTtJQUNMLE9BQU9EO0FBQ1g7QUFFQTs7QUFFQSxHQUNBLE1BQU1FLFNBQVM7SUFBRXp5QjtJQUFXckI7SUFBY2M7SUFBaUJLO0lBQVcvYjtJQUFjM0U7SUFBY0c7QUFBYTtBQUVpaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci92aWV3L2Rpc3QvaW5kZXguanM/ODdjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0LCBSYW5nZVNldCwgTWFwTW9kZSwgUmFuZ2VWYWx1ZSwgZmluZENsdXN0ZXJCcmVhaywgRWRpdG9yU2VsZWN0aW9uLCBGYWNldCwgU3RhdGVFZmZlY3QsIENoYW5nZVNldCwgZmluZENvbHVtbiwgQ2hhckNhdGVnb3J5LCBBbm5vdGF0aW9uLCBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24sIFByZWMsIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBSYW5nZVNldEJ1aWxkZXIsIGNvdW50Q29sdW1uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuaW1wb3J0IHsga2V5TmFtZSwgYmFzZSwgc2hpZnQgfSBmcm9tICd3M2Mta2V5bmFtZSc7XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihyb290KSB7XG4gICAgbGV0IHRhcmdldDtcbiAgICAvLyBCcm93c2VycyBkaWZmZXIgb24gd2hldGhlciBzaGFkb3cgcm9vdHMgaGF2ZSBhIGdldFNlbGVjdGlvblxuICAgIC8vIG1ldGhvZC4gSWYgaXQgZXhpc3RzLCB1c2UgdGhhdCwgb3RoZXJ3aXNlLCBjYWxsIGl0IG9uIHRoZVxuICAgIC8vIGRvY3VtZW50LlxuICAgIGlmIChyb290Lm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgIHRhcmdldCA9IHJvb3QuZ2V0U2VsZWN0aW9uID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQuZ2V0U2VsZWN0aW9uKCk7XG59XG5mdW5jdGlvbiBjb250YWlucyhkb20sIG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSA/IGRvbSA9PSBub2RlIHx8IGRvbS5jb250YWlucyhub2RlLm5vZGVUeXBlICE9IDEgPyBub2RlLnBhcmVudE5vZGUgOiBub2RlKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZGVlcEFjdGl2ZUVsZW1lbnQoZG9jKSB7XG4gICAgbGV0IGVsdCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIHdoaWxlIChlbHQgJiYgZWx0LnNoYWRvd1Jvb3QpXG4gICAgICAgIGVsdCA9IGVsdC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbihkb20sIHNlbGVjdGlvbikge1xuICAgIGlmICghc2VsZWN0aW9uLmFuY2hvck5vZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGRvbSwgc2VsZWN0aW9uLmFuY2hvck5vZGUpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xpZW50UmVjdHNGb3IoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gdGV4dFJhbmdlKGRvbSwgMCwgZG9tLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgIHJldHVybiBkb20uZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBbXTtcbn1cbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmZ1bmN0aW9uIGlzRXF1aXZhbGVudFBvc2l0aW9uKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgPyAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8XG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZG9tSW5kZXgobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSB0YXJnZXROb2RlICYmIG9mZiA9PSB0YXJnZXRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9mZiA9PSAoZGlyIDwgMCA/IDAgOiBtYXhPZmZzZXQobm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkRJVlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBtYXhPZmZzZXQobm9kZSkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWF4T2Zmc2V0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5SZWN0KHJlY3QsIGxlZnQpIHtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IGxlZnQ6IHgsIHJpZ2h0OiB4LCB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tIH07XG59XG5mdW5jdGlvbiB3aW5kb3dSZWN0KHdpbikge1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xufVxuZnVuY3Rpb24gZ2V0U2NhbGUoZWx0LCByZWN0KSB7XG4gICAgbGV0IHNjYWxlWCA9IHJlY3Qud2lkdGggLyBlbHQub2Zmc2V0V2lkdGg7XG4gICAgbGV0IHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gZWx0Lm9mZnNldEhlaWdodDtcbiAgICBpZiAoc2NhbGVYID4gMC45OTUgJiYgc2NhbGVYIDwgMS4wMDUgfHwgIWlzRmluaXRlKHNjYWxlWCkgfHwgTWF0aC5hYnMocmVjdC53aWR0aCAtIGVsdC5vZmZzZXRXaWR0aCkgPCAxKVxuICAgICAgICBzY2FsZVggPSAxO1xuICAgIGlmIChzY2FsZVkgPiAwLjk5NSAmJiBzY2FsZVkgPCAxLjAwNSB8fCAhaXNGaW5pdGUoc2NhbGVZKSB8fCBNYXRoLmFicyhyZWN0LmhlaWdodCAtIGVsdC5vZmZzZXRIZWlnaHQpIDwgMSlcbiAgICAgICAgc2NhbGVZID0gMTtcbiAgICByZXR1cm4geyBzY2FsZVgsIHNjYWxlWSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KGRvbSwgcmVjdCwgc2lkZSwgeCwgeSwgeE1hcmdpbiwgeU1hcmdpbiwgbHRyKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbSwgc3RvcCA9IGZhbHNlOyBjdXIgJiYgIXN0b3A7KSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSkgeyAvLyBFbGVtZW50XG4gICAgICAgICAgICBsZXQgYm91bmRpbmcsIHRvcCA9IGN1ciA9PSBkb2MuYm9keTtcbiAgICAgICAgICAgIGxldCBzY2FsZVggPSAxLCBzY2FsZVkgPSAxO1xuICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0gd2luZG93UmVjdCh3aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eKGZpeGVkfHN0aWNreSkkLy50ZXN0KGdldENvbXB1dGVkU3R5bGUoY3VyKS5wb3NpdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0IDw9IGN1ci5jbGllbnRIZWlnaHQgJiYgY3VyLnNjcm9sbFdpZHRoIDw9IGN1ci5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBjdXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgKHsgc2NhbGVYLCBzY2FsZVkgfSA9IGdldFNjYWxlKGN1ciwgcmVjdCkpO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBjdXIuY2xpZW50V2lkdGggKiBzY2FsZVgsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBjdXIuY2xpZW50SGVpZ2h0ICogc2NhbGVZIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgICAgICBpZiAoeSA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tICsgbW92ZVkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgbW92ZVkgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIChyZWN0LnRvcCAtIG1vdmVZKSA8IGJvdW5kaW5nLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgKyBtb3ZlWSAtIHJlY3QudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RIZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wLCBib3VuZGluZ0hlaWdodCA9IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0VG9wID0geSA9PSBcImNlbnRlclwiICYmIHJlY3RIZWlnaHQgPD0gYm91bmRpbmdIZWlnaHQgPyByZWN0LnRvcCArIHJlY3RIZWlnaHQgLyAyIC0gYm91bmRpbmdIZWlnaHQgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgeSA9PSBcInN0YXJ0XCIgfHwgeSA9PSBcImNlbnRlclwiICYmIHNpZGUgPCAwID8gcmVjdC50b3AgLSB5TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QuYm90dG9tIC0gYm91bmRpbmdIZWlnaHQgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVZID0gdGFyZ2V0VG9wIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0ICsgbW92ZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIG1vdmVYICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0ICsgbW92ZVggLSByZWN0LmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0TGVmdCA9IHggPT0gXCJjZW50ZXJcIiA/IHJlY3QubGVmdCArIChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDIgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSAvIDIgOlxuICAgICAgICAgICAgICAgICAgICAoeCA9PSBcInN0YXJ0XCIpID09IGx0ciA/IHJlY3QubGVmdCAtIHhNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5yaWdodCAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWCA9IHRhcmdldExlZnQgLSBib3VuZGluZy5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3ZlZFggPSAwLCBtb3ZlZFkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsVG9wICs9IG1vdmVZIC8gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRZID0gKGN1ci5zY3JvbGxUb3AgLSBzdGFydCkgKiBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxMZWZ0ICs9IG1vdmVYIC8gc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRYID0gKGN1ci5zY3JvbGxMZWZ0IC0gc3RhcnQpICogc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIG1vdmVkWCwgdG9wOiByZWN0LnRvcCAtIG1vdmVkWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC0gbW92ZWRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gbW92ZWRZIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFggJiYgTWF0aC5hYnMobW92ZWRYIC0gbW92ZVgpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkWSAmJiBNYXRoLmFicyhtb3ZlZFkgLSBtb3ZlWSkgPCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IFwibmVhcmVzdFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkgeyAvLyBBIHNoYWRvdyByb290XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nyb2xsYWJsZVBhcmVudChkb20pIHtcbiAgICBsZXQgZG9jID0gZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tLnBhcmVudE5vZGU7IGN1cjspIHtcbiAgICAgICAgaWYgKGN1ciA9PSBkb2MuYm9keSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0ID4gY3VyLmNsaWVudEhlaWdodCB8fCBjdXIuc2Nyb2xsV2lkdGggPiBjdXIuY2xpZW50V2lkdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY2xhc3MgRE9NU2VsZWN0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFuY2hvck9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIGVxKGRvbVNlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JOb2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIHRoaXMuYW5jaG9yT2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHRoaXMuZm9jdXNOb2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgdGhpcy5mb2N1c09mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIHNldFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGFuY2hvck5vZGUsIGZvY3VzTm9kZSB9ID0gcmFuZ2U7XG4gICAgICAgIC8vIENsaXAgb2Zmc2V0cyB0byBub2RlIHNpemUgdG8gYXZvaWQgY3Jhc2hlcyB3aGVuIFNhZmFyaSByZXBvcnRzIGJvZ3VzIG9mZnNldHMgKCMxMTUyKVxuICAgICAgICB0aGlzLnNldChhbmNob3JOb2RlLCBNYXRoLm1pbihyYW5nZS5hbmNob3JPZmZzZXQsIGFuY2hvck5vZGUgPyBtYXhPZmZzZXQoYW5jaG9yTm9kZSkgOiAwKSwgZm9jdXNOb2RlLCBNYXRoLm1pbihyYW5nZS5mb2N1c09mZnNldCwgZm9jdXNOb2RlID8gbWF4T2Zmc2V0KGZvY3VzTm9kZSkgOiAwKSk7XG4gICAgfVxuICAgIHNldChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBhbmNob3JPZmZzZXQ7XG4gICAgICAgIHRoaXMuZm9jdXNOb2RlID0gZm9jdXNOb2RlO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xuLy8gRmVhdHVyZS1kZXRlY3RzIHN1cHBvcnQgZm9yIC5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pLCBhbmQgdXNlc1xuLy8gYSBmYWxsYmFjayBrbHVkZ2Ugd2hlbiBub3Qgc3VwcG9ydGVkLlxuZnVuY3Rpb24gZm9jdXNQcmV2ZW50U2Nyb2xsKGRvbSkge1xuICAgIGlmIChkb20uc2V0QWN0aXZlKVxuICAgICAgICByZXR1cm4gZG9tLnNldEFjdGl2ZSgpOyAvLyBpbiBJRVxuICAgIGlmIChwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpO1xuICAgIGxldCBzdGFjayA9IFtdO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBzdGFjay5wdXNoKGN1ciwgY3VyLnNjcm9sbFRvcCwgY3VyLnNjcm9sbExlZnQpO1xuICAgICAgICBpZiAoY3VyID09IGN1ci5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID09IG51bGwgPyB7XG4gICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IDogdW5kZWZpbmVkKTtcbiAgICBpZiAoIXByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBlbHQgPSBzdGFja1tpKytdLCB0b3AgPSBzdGFja1tpKytdLCBsZWZ0ID0gc3RhY2tbaSsrXTtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsVG9wICE9IHRvcClcbiAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgICAgICAgaWYgKGVsdC5zY3JvbGxMZWZ0ICE9IGxlZnQpXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgICAgICB9XG4gICAgfVxufVxubGV0IHNjcmF0Y2hSYW5nZTtcbmZ1bmN0aW9uIHRleHRSYW5nZShub2RlLCBmcm9tLCB0byA9IGZyb20pIHtcbiAgICBsZXQgcmFuZ2UgPSBzY3JhdGNoUmFuZ2UgfHwgKHNjcmF0Y2hSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgZnJvbSk7XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hLZXkoZWx0LCBuYW1lLCBjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7IGtleTogbmFtZSwgY29kZTogbmFtZSwga2V5Q29kZTogY29kZSwgd2hpY2g6IGNvZGUsIGNhbmNlbGFibGU6IHRydWUgfTtcbiAgICBsZXQgZG93biA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCBvcHRpb25zKTtcbiAgICBkb3duLnN5bnRoZXRpYyA9IHRydWU7XG4gICAgZWx0LmRpc3BhdGNoRXZlbnQoZG93bik7XG4gICAgbGV0IHVwID0gbmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCBvcHRpb25zKTtcbiAgICB1cC5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KHVwKTtcbiAgICByZXR1cm4gZG93bi5kZWZhdWx0UHJldmVudGVkIHx8IHVwLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PSA5IHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgJiYgbm9kZS5ob3N0KSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsZWFyQXR0cmlidXRlcyhub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuYXR0cmlidXRlcy5sZW5ndGgpXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlTm9kZShub2RlLmF0dHJpYnV0ZXNbMF0pO1xufVxuZnVuY3Rpb24gYXRFbGVtZW50U3RhcnQoZG9jLCBzZWxlY3Rpb24pIHtcbiAgICBsZXQgbm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsIG9mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ICE9IG9mZnNldClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIFNhZmFyaSBjYW4gcmVwb3J0IGJvZ3VzIG9mZnNldHMgKCMxMTUyKVxuICAgIG9mZnNldCA9IE1hdGgubWluKG9mZnNldCwgbWF4T2Zmc2V0KG5vZGUpKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAocHJldi5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgPT0gZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2Nyb2xsZWRUb0JvdHRvbShlbHQpIHtcbiAgICByZXR1cm4gZWx0LnNjcm9sbFRvcCA+IE1hdGgubWF4KDEsIGVsdC5zY3JvbGxIZWlnaHQgLSBlbHQuY2xpZW50SGVpZ2h0IC0gNCk7XG59XG5cbmNsYXNzIERPTVBvcyB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0LCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wcmVjaXNlID0gcHJlY2lzZTtcbiAgICB9XG4gICAgc3RhdGljIGJlZm9yZShkb20sIHByZWNpc2UpIHsgcmV0dXJuIG5ldyBET01Qb3MoZG9tLnBhcmVudE5vZGUsIGRvbUluZGV4KGRvbSksIHByZWNpc2UpOyB9XG4gICAgc3RhdGljIGFmdGVyKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSArIDEsIHByZWNpc2UpOyB9XG59XG5jb25zdCBub0NoaWxkcmVuID0gW107XG5jbGFzcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgICAgICB0aGlzLmZsYWdzID0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZSh0aGlzKSA6IDA7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3NCZWZvcmUodmlldykge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gdmlldylcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNoaWxkIGluIHBvc0JlZm9yZVwiKTtcbiAgICB9XG4gICAgcG9zQWZ0ZXIodmlldykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUodmlldykgKyB2aWV3Lmxlbmd0aDtcbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICBpZiAodGhpcy5mbGFncyAmIDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5kb207XG4gICAgICAgICAgICBsZXQgcHJldiA9IG51bGwsIG5leHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmZsYWdzICYgNyAvKiBWaWV3RmxhZy5EaXJ0eSAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLmRvbSAmJiAobmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFZpZXcgPSBDb250ZW50Vmlldy5nZXQobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRWaWV3IHx8ICFjb250ZW50Vmlldy5wYXJlbnQgJiYgY29udGVudFZpZXcuY2FuUmV1c2VET00oY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJldXNlRE9NKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IHByZXYgPyBwcmV2Lm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrICYmICF0cmFjay53cml0dGVuICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQgIT0gY2hpbGQuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLmRvbSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXYgPSBjaGlsZC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQpXG4gICAgICAgICAgICAgICAgbmV4dCA9IHJtJDEobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5mbGFncyAmPSB+NyAvKiBWaWV3RmxhZy5EaXJ0eSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oX2RvbSkgeyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgYWZ0ZXI7XG4gICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMuZG9tLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gbWF4T2Zmc2V0KG5vZGUpID09IDAgPyAwIDogb2Zmc2V0ID09IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoYmlhcyA9PSAwICYmIHBhcmVudC5maXJzdENoaWxkICE9IHBhcmVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyID09IHRoaXMuZG9tLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgd2hpbGUgKGFmdGVyICYmICFDb250ZW50Vmlldy5nZXQoYWZ0ZXIpKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQuZG9tID09IGFmdGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGZyb21JID0gLTEsIGZyb21TdGFydCA9IC0xLCB0b0kgPSAtMSwgdG9FbmQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IG9mZnNldCwgcHJldkVuZCA9IG9mZnNldDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tICYmIGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5kb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIHBvcyk7XG4gICAgICAgICAgICBpZiAoZW5kID49IGZyb20gJiYgZnJvbUkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmcm9tSSA9IGk7XG4gICAgICAgICAgICAgICAgZnJvbVN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA+IHRvICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdG9JID0gaTtcbiAgICAgICAgICAgICAgICB0b0VuZCA9IHByZXZFbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RW5kID0gZW5kO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tU3RhcnQsIHRvOiB0b0VuZCA8IDAgPyBvZmZzZXQgKyB0aGlzLmxlbmd0aCA6IHRvRW5kLFxuICAgICAgICAgICAgc3RhcnRET006IChmcm9tSSA/IHRoaXMuY2hpbGRyZW5bZnJvbUkgLSAxXS5kb20ubmV4dFNpYmxpbmcgOiBudWxsKSB8fCB0aGlzLmRvbS5maXJzdENoaWxkLFxuICAgICAgICAgICAgZW5kRE9NOiB0b0kgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiB0b0kgPj0gMCA/IHRoaXMuY2hpbGRyZW5bdG9JXS5kb20gOiBudWxsIH07XG4gICAgfVxuICAgIG1hcmtEaXJ0eShhbmRQYXJlbnQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZsYWdzIHw9IDIgLyogVmlld0ZsYWcuTm9kZURpcnR5ICovO1xuICAgICAgICB0aGlzLm1hcmtQYXJlbnRzRGlydHkoYW5kUGFyZW50KTtcbiAgICB9XG4gICAgbWFya1BhcmVudHNEaXJ0eShjaGlsZExpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7IHBhcmVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkTGlzdClcbiAgICAgICAgICAgICAgICBwYXJlbnQuZmxhZ3MgfD0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgICAgICAgICBpZiAocGFyZW50LmZsYWdzICYgMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBhcmVudC5mbGFncyB8PSAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi87XG4gICAgICAgICAgICBjaGlsZExpc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAhPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRET00oZG9tKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNtVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICBkb20uY21WaWV3ID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IHJvb3RWaWV3KCkge1xuICAgICAgICBmb3IgKGxldCB2ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdi5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIHYgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZUNoaWxkcmVuKGZyb20sIHRvLCBjaGlsZHJlbiA9IG5vQ2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PSB0aGlzICYmIGNoaWxkcmVuLmluZGV4T2YoY2hpbGQpIDwgMClcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoZnJvbSwgdG8gLSBmcm9tLCAuLi5jaGlsZHJlbik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjaGlsZHJlbltpXS5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKF9yZWMpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWdub3JlRXZlbnQoX2V2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNoaWxkQ3Vyc29yKHBvcyA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRDdXJzb3IodGhpcy5jaGlsZHJlbiwgcG9zLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIGNoaWxkUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRDdXJzb3IoKS5maW5kUG9zKHBvcywgYmlhcyk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZS5yZXBsYWNlKFwiVmlld1wiLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyAodGhpcy5jaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIHRoaXMuY2hpbGRyZW4uam9pbigpICsgXCIpXCIgOlxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPyBcIltcIiArIChuYW1lID09IFwiVGV4dFwiID8gdGhpcy50ZXh0IDogdGhpcy5sZW5ndGgpICsgXCJdXCIgOiBcIlwiKSArXG4gICAgICAgICAgICAodGhpcy5icmVha0FmdGVyID8gXCIjXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldChub2RlKSB7IHJldHVybiBub2RlLmNtVmlldzsgfVxuICAgIGdldCBpc0VkaXRhYmxlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpc1dpZGdldCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBoYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNhblJldXNlRE9NKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5jb25zdHJ1Y3RvciA9PSB0aGlzLmNvbnN0cnVjdG9yICYmICEoKHRoaXMuZmxhZ3MgfCBvdGhlci5mbGFncykgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKTtcbiAgICB9XG4gICAgLy8gV2hlbiB0aGlzIGlzIGEgemVyby1sZW5ndGggdmlldyB3aXRoIGEgc2lkZSwgdGhpcyBzaG91bGQgcmV0dXJuIGFcbiAgICAvLyBudW1iZXIgPD0gMCB0byBpbmRpY2F0ZSBpdCBpcyBiZWZvcmUgaXRzIHBvc2l0aW9uLCBvciBhXG4gICAgLy8gbnVtYmVyID4gMCB3aGVuIGFmdGVyIGl0cyBwb3NpdGlvbi5cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gMDsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09IHRoaXMpXG4gICAgICAgICAgICAgICAgY2hpbGQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgfVxufVxuQ29udGVudFZpZXcucHJvdG90eXBlLmJyZWFrQWZ0ZXIgPSAwO1xuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0kMShkb20pIHtcbiAgICBsZXQgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICAgIHJldHVybiBuZXh0O1xufVxuY2xhc3MgQ2hpbGRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBwb3MsIGkpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5pID0gaTtcbiAgICAgICAgdGhpcy5vZmYgPSAwO1xuICAgIH1cbiAgICBmaW5kUG9zKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHBvcyA+IHRoaXMucG9zIHx8IHBvcyA9PSB0aGlzLnBvcyAmJlxuICAgICAgICAgICAgICAgIChiaWFzID4gMCB8fCB0aGlzLmkgPT0gMCB8fCB0aGlzLmNoaWxkcmVuW3RoaXMuaSAtIDFdLmJyZWFrQWZ0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYgPSBwb3MgLSB0aGlzLnBvcztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5jaGlsZHJlblstLXRoaXMuaV07XG4gICAgICAgICAgICB0aGlzLnBvcyAtPSBuZXh0Lmxlbmd0aCArIG5leHQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZShwYXJlbnQsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBpbnNlcnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IHBhcmVudDtcbiAgICBsZXQgYmVmb3JlID0gY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW5bZnJvbUldIDogbnVsbDtcbiAgICBsZXQgbGFzdCA9IGluc2VydC5sZW5ndGggPyBpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICBsZXQgYnJlYWtBdEVuZCA9IGxhc3QgPyBsYXN0LmJyZWFrQWZ0ZXIgOiBicmVha0F0U3RhcnQ7XG4gICAgLy8gQ2hhbmdlIHdpdGhpbiBhIHNpbmdsZSBjaGlsZFxuICAgIGlmIChmcm9tSSA9PSB0b0kgJiYgYmVmb3JlICYmICFicmVha0F0U3RhcnQgJiYgIWJyZWFrQXRFbmQgJiYgaW5zZXJ0Lmxlbmd0aCA8IDIgJiZcbiAgICAgICAgYmVmb3JlLm1lcmdlKGZyb21PZmYsIHRvT2ZmLCBpbnNlcnQubGVuZ3RoID8gbGFzdCA6IG51bGwsIGZyb21PZmYgPT0gMCwgb3BlblN0YXJ0LCBvcGVuRW5kKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0b0kgPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gY2hpbGRyZW5bdG9JXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBlbmQgb2YgdGhlIGNoaWxkIGFmdGVyIHRoZSB1cGRhdGUgaXMgcHJlc2VydmVkIGluIGBhZnRlcmBcbiAgICAgICAgaWYgKGFmdGVyICYmICh0b09mZiA8IGFmdGVyLmxlbmd0aCB8fCBhZnRlci5icmVha0FmdGVyICYmIChsYXN0ID09PSBudWxsIHx8IGxhc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3QuYnJlYWtBZnRlcikpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBzcGxpdHRpbmcgYSBjaGlsZCwgc2VwYXJhdGUgcGFydCBvZiBpdCB0byBhdm9pZCB0aGF0XG4gICAgICAgICAgICAvLyBiZWluZyBtYW5nbGVkIHdoZW4gdXBkYXRpbmcgdGhlIGNoaWxkIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICAgICAgICAgaWYgKGZyb21JID09IHRvSSkge1xuICAgICAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIuc3BsaXQodG9PZmYpO1xuICAgICAgICAgICAgICAgIHRvT2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGFmdGVyIHRoZSByZXBsYWNlbWVudCBzaG91bGQgYmUgbWVyZ2VkIHdpdGhcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IHJlcGxhY2luZyBlbGVtZW50LCB1cGRhdGUgYGNvbnRlbnRgXG4gICAgICAgICAgICBpZiAoIWJyZWFrQXRFbmQgJiYgbGFzdCAmJiBhZnRlci5tZXJnZSgwLCB0b09mZiwgbGFzdCwgdHJ1ZSwgMCwgb3BlbkVuZCkpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdID0gYWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHN0YXJ0IG9mIHRoZSBhZnRlciBlbGVtZW50LCBpZiBuZWNlc3NhcnksIGFuZFxuICAgICAgICAgICAgICAgIC8vIGFkZCBpdCB0byBgY29udGVudGAuXG4gICAgICAgICAgICAgICAgaWYgKHRvT2ZmIHx8IGFmdGVyLmNoaWxkcmVuLmxlbmd0aCAmJiAhYWZ0ZXIuY2hpbGRyZW5bMF0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBhZnRlci5tZXJnZSgwLCB0b09mZiwgbnVsbCwgZmFsc2UsIDAsIG9wZW5FbmQpO1xuICAgICAgICAgICAgICAgIGluc2VydC5wdXNoKGFmdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhZnRlciA9PT0gbnVsbCB8fCBhZnRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWZ0ZXIuYnJlYWtBZnRlcikge1xuICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgYXQgYHRvSWAgaXMgZW50aXJlbHkgY292ZXJlZCBieSB0aGlzIHJhbmdlLlxuICAgICAgICAgICAgLy8gUHJlc2VydmUgaXRzIGxpbmUgYnJlYWssIGlmIGFueS5cbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIGxhc3QuYnJlYWtBZnRlciA9IDE7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWtBdFN0YXJ0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSB3ZSd2ZSBoYW5kbGVkIHRoZSBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgY3VycmVudCBlbGVtZW50c1xuICAgICAgICAvLyBub3csIG1ha2Ugc3VyZSBgdG9JYCBwb2ludHMgYWZ0ZXIgdGhhdC5cbiAgICAgICAgdG9JKys7XG4gICAgfVxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBicmVha0F0U3RhcnQ7XG4gICAgICAgIGlmIChmcm9tT2ZmID4gMCkge1xuICAgICAgICAgICAgaWYgKCFicmVha0F0U3RhcnQgJiYgaW5zZXJ0Lmxlbmd0aCAmJiBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgYmVmb3JlLmxlbmd0aCwgaW5zZXJ0WzBdLCBmYWxzZSwgb3BlblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgIGJlZm9yZS5icmVha0FmdGVyID0gaW5zZXJ0LnNoaWZ0KCkuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21PZmYgPCBiZWZvcmUubGVuZ3RoIHx8IGJlZm9yZS5jaGlsZHJlbi5sZW5ndGggJiYgYmVmb3JlLmNoaWxkcmVuW2JlZm9yZS5jaGlsZHJlbi5sZW5ndGggLSAxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBudWxsLCBmYWxzZSwgb3BlblN0YXJ0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21JKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIG1lcmdlIHdpZGdldHMgb24gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgd2hpbGUgKGZyb21JIDwgdG9JICYmIGluc2VydC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW3RvSSAtIDFdLmJlY29tZShpbnNlcnRbaW5zZXJ0Lmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgdG9JLS07XG4gICAgICAgICAgICBpbnNlcnQucG9wKCk7XG4gICAgICAgICAgICBvcGVuRW5kID0gaW5zZXJ0Lmxlbmd0aCA/IDAgOiBvcGVuU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGRyZW5bZnJvbUldLmJlY29tZShpbnNlcnRbMF0pKSB7XG4gICAgICAgICAgICBmcm9tSSsrO1xuICAgICAgICAgICAgaW5zZXJ0LnNoaWZ0KCk7XG4gICAgICAgICAgICBvcGVuU3RhcnQgPSBpbnNlcnQubGVuZ3RoID8gMCA6IG9wZW5FbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWluc2VydC5sZW5ndGggJiYgZnJvbUkgJiYgdG9JIDwgY2hpbGRyZW4ubGVuZ3RoICYmICFjaGlsZHJlbltmcm9tSSAtIDFdLmJyZWFrQWZ0ZXIgJiZcbiAgICAgICAgY2hpbGRyZW5bdG9JXS5tZXJnZSgwLCAwLCBjaGlsZHJlbltmcm9tSSAtIDFdLCBmYWxzZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSlcbiAgICAgICAgZnJvbUktLTtcbiAgICBpZiAoZnJvbUkgPCB0b0kgfHwgaW5zZXJ0Lmxlbmd0aClcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZHJlbihmcm9tSSwgdG9JLCBpbnNlcnQpO1xufVxuZnVuY3Rpb24gbWVyZ2VDaGlsZHJlbkludG8ocGFyZW50LCBmcm9tLCB0bywgaW5zZXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBsZXQgY3VyID0gcGFyZW50LmNoaWxkQ3Vyc29yKCk7XG4gICAgbGV0IHsgaTogdG9JLCBvZmY6IHRvT2ZmIH0gPSBjdXIuZmluZFBvcyh0bywgMSk7XG4gICAgbGV0IHsgaTogZnJvbUksIG9mZjogZnJvbU9mZiB9ID0gY3VyLmZpbmRQb3MoZnJvbSwgLTEpO1xuICAgIGxldCBkTGVuID0gZnJvbSAtIHRvO1xuICAgIGZvciAobGV0IHZpZXcgb2YgaW5zZXJ0KVxuICAgICAgICBkTGVuICs9IHZpZXcubGVuZ3RoO1xuICAgIHBhcmVudC5sZW5ndGggKz0gZExlbjtcbiAgICByZXBsYWNlUmFuZ2UocGFyZW50LCBmcm9tSSwgZnJvbU9mZiwgdG9JLCB0b09mZiwgaW5zZXJ0LCAwLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xufVxuXG5sZXQgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogeyB1c2VyQWdlbnQ6IFwiXCIsIHZlbmRvcjogXCJcIiwgcGxhdGZvcm06IFwiXCIgfTtcbmxldCBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT0gXCJ1bmRlZmluZWRcIiA/IGRvY3VtZW50IDogeyBkb2N1bWVudEVsZW1lbnQ6IHsgc3R5bGU6IHt9IH0gfTtcbmNvbnN0IGllX2VkZ2UgPSAvKkBfX1BVUkVfXyovL0VkZ2VcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZV91cHRvMTAgPSAvKkBfX1BVUkVfXyovL01TSUUgXFxkLy50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfMTF1cCA9IC8qQF9fUFVSRV9fKi8vVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgLypAX19QVVJFX18qLy9nZWNrb1xcLyhcXGQrKS9pLnRlc3QobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBjaHJvbWUgPSAhaWUgJiYgLypAX19QVVJFX18qLy9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCB3ZWJraXQgPSBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuY29uc3Qgc2FmYXJpID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG5jb25zdCBpb3MgPSBzYWZhcmkgJiYgKC8qQF9fUFVSRV9fKi8vTW9iaWxlXFwvXFx3Ky8udGVzdChuYXYudXNlckFnZW50KSB8fCBuYXYubWF4VG91Y2hQb2ludHMgPiAyKTtcbnZhciBicm93c2VyID0ge1xuICAgIG1hYzogaW9zIHx8IC8qQF9fUFVSRV9fKi8vTWFjLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgd2luZG93czogLypAX19QVVJFX18qLy9XaW4vLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICBsaW51eDogLypAX19QVVJFX18qLy9MaW51eHxYMTEvLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICBpZSxcbiAgICBpZV92ZXJzaW9uOiBpZV91cHRvMTAgPyBkb2MuZG9jdW1lbnRNb2RlIHx8IDYgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiAwLFxuICAgIGdlY2tvLFxuICAgIGdlY2tvX3ZlcnNpb246IGdlY2tvID8gKygvKkBfX1BVUkVfXyovL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgY2hyb21lOiAhIWNocm9tZSxcbiAgICBjaHJvbWVfdmVyc2lvbjogY2hyb21lID8gK2Nocm9tZVsxXSA6IDAsXG4gICAgaW9zLFxuICAgIGFuZHJvaWQ6IC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXYudXNlckFnZW50KSxcbiAgICB3ZWJraXQsXG4gICAgc2FmYXJpLFxuICAgIHdlYmtpdF92ZXJzaW9uOiB3ZWJraXQgPyArKC8qQF9fUFVSRV9fKi8vXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgdGFiU2l6ZTogZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS50YWJTaXplICE9IG51bGwgPyBcInRhYi1zaXplXCIgOiBcIi1tb3otdGFiLXNpemVcIlxufTtcblxuY29uc3QgTWF4Sm9pbkxlbiA9IDI1NjtcbmNsYXNzIFRleHRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBjcmVhdGVET00odGV4dERPTSkge1xuICAgICAgICB0aGlzLnNldERPTSh0ZXh0RE9NIHx8IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCkpO1xuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTSgpO1xuICAgICAgICBpZiAodGhpcy5kb20ubm9kZVZhbHVlICE9IHRoaXMudGV4dCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5ub2RlVmFsdWUgPSB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRE9NKGRvbSk7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKCh0aGlzLmZsYWdzICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLykgfHxcbiAgICAgICAgICAgIHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBUZXh0VmlldykgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgc291cmNlLmxlbmd0aCA+IE1heEpvaW5MZW4gfHxcbiAgICAgICAgICAgICAgICAoc291cmNlLmZsYWdzICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLykpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgZnJvbSkgKyAoc291cmNlID8gc291cmNlLnRleHQgOiBcIlwiKSArIHRoaXMudGV4dC5zbGljZSh0byk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgVGV4dFZpZXcodGhpcy50ZXh0LnNsaWNlKGZyb20pKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGZyb20pO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXN1bHQuZmxhZ3MgfD0gdGhpcy5mbGFncyAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi87XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT0gdGhpcy5kb20gPyBvZmZzZXQgOiBvZmZzZXQgPyB0aGlzLnRleHQubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiBuZXcgRE9NUG9zKHRoaXMuZG9tLCBwb3MpOyB9XG4gICAgZG9tQm91bmRzQXJvdW5kKF9mcm9tLCBfdG8sIG9mZnNldCkge1xuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmZzZXQsIHRvOiBvZmZzZXQgKyB0aGlzLmxlbmd0aCwgc3RhcnRET006IHRoaXMuZG9tLCBlbmRET006IHRoaXMuZG9tLm5leHRTaWJsaW5nIH07XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gdGV4dENvb3Jkcyh0aGlzLmRvbSwgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5jbGFzcyBNYXJrVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihtYXJrLCBjaGlsZHJlbiA9IFtdLCBsZW5ndGggPSAwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgY2guc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cbiAgICBzZXRBdHRycyhkb20pIHtcbiAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKGRvbSk7XG4gICAgICAgIGlmICh0aGlzLm1hcmsuY2xhc3MpXG4gICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gdGhpcy5tYXJrLmNsYXNzO1xuICAgICAgICBpZiAodGhpcy5tYXJrLmF0dHJzKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLm1hcmsuYXR0cnMpXG4gICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCB0aGlzLm1hcmsuYXR0cnNbbmFtZV0pO1xuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cbiAgICBjYW5SZXVzZURPTShvdGhlcikge1xuICAgICAgICByZXR1cm4gc3VwZXIuY2FuUmV1c2VET00ob3RoZXIpICYmICEoKHRoaXMuZmxhZ3MgfCBvdGhlci5mbGFncykgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKTtcbiAgICB9XG4gICAgcmV1c2VET00obm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSB0aGlzLm1hcmsudGFnTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gNCAvKiBWaWV3RmxhZy5BdHRyc0RpcnR5ICovIHwgMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy5zZXRBdHRycyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubWFyay50YWdOYW1lKSkpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmZsYWdzICYgNCAvKiBWaWV3RmxhZy5BdHRyc0RpcnR5ICovKVxuICAgICAgICAgICAgdGhpcy5zZXRBdHRycyh0aGlzLmRvbSk7XG4gICAgICAgIHN1cGVyLnN5bmModmlldywgdHJhY2spO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBfaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIHNvdXJjZS5tYXJrLmVxKHRoaXMubWFyaykpIHx8XG4gICAgICAgICAgICAoZnJvbSAmJiBvcGVuU3RhcnQgPD0gMCkgfHwgKHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIG1lcmdlQ2hpbGRyZW5JbnRvKHRoaXMsIGZyb20sIHRvLCBzb3VyY2UgPyBzb3VyY2UuY2hpbGRyZW4uc2xpY2UoKSA6IFtdLCBvcGVuU3RhcnQgLSAxLCBvcGVuRW5kIC0gMSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgb2ZmID0gMCwgZGV0YWNoRnJvbSA9IC0xLCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgZWx0IG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBvZmYgKyBlbHQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2ZmIDwgZnJvbSA/IGVsdC5zcGxpdChmcm9tIC0gb2ZmKSA6IGVsdCk7XG4gICAgICAgICAgICBpZiAoZGV0YWNoRnJvbSA8IDAgJiYgb2ZmID49IGZyb20pXG4gICAgICAgICAgICAgICAgZGV0YWNoRnJvbSA9IGk7XG4gICAgICAgICAgICBvZmYgPSBlbmQ7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMubGVuZ3RoIC0gZnJvbTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tO1xuICAgICAgICBpZiAoZGV0YWNoRnJvbSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IGRldGFjaEZyb207XG4gICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWFya1ZpZXcodGhpcy5tYXJrLCByZXN1bHQsIGxlbmd0aCk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gaW5saW5lRE9NQXRQb3ModGhpcywgcG9zKTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dENvb3Jkcyh0ZXh0LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgbGVuZ3RoID0gdGV4dC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGlmIChwb3MgPiBsZW5ndGgpXG4gICAgICAgIHBvcyA9IGxlbmd0aDtcbiAgICBsZXQgZnJvbSA9IHBvcywgdG8gPSBwb3MsIGZsYXR0ZW4gPSAwO1xuICAgIGlmIChwb3MgPT0gMCAmJiBzaWRlIDwgMCB8fCBwb3MgPT0gbGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICBpZiAoIShicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSkgeyAvLyBUaGVzZSBicm93c2VycyByZWxpYWJseSByZXR1cm4gdmFsaWQgcmVjdGFuZ2xlcyBmb3IgZW1wdHkgcmFuZ2VzXG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAxO1xuICAgICAgICAgICAgfSAvLyBGSVhNRSB0aGlzIGlzIHdyb25nIGluIFJUTCB0ZXh0XG4gICAgICAgICAgICBlbHNlIGlmICh0byA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2lkZSA8IDApXG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKVxuICAgICAgICAgICAgdG8rKztcbiAgICB9XG4gICAgbGV0IHJlY3RzID0gdGV4dFJhbmdlKHRleHQsIGZyb20sIHRvKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcmVjdCA9IHJlY3RzWyhmbGF0dGVuID8gZmxhdHRlbiA8IDAgOiBzaWRlID49IDApID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiAhZmxhdHRlbiAmJiByZWN0LndpZHRoID09IDApXG4gICAgICAgIHJlY3QgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCByID0+IHIud2lkdGgpIHx8IHJlY3Q7XG4gICAgcmV0dXJuIGZsYXR0ZW4gPyBmbGF0dGVuUmVjdChyZWN0LCBmbGF0dGVuIDwgMCkgOiByZWN0IHx8IG51bGw7XG59XG4vLyBBbHNvIHVzZWQgZm9yIGNvbGxhcHNlZCByYW5nZXMgdGhhdCBkb24ndCBoYXZlIGEgcGxhY2Vob2xkZXIgd2lkZ2V0IVxuY2xhc3MgV2lkZ2V0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBzdGF0aWMgY3JlYXRlKHdpZGdldCwgbGVuZ3RoLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2lkZ2V0Vmlldyh3aWRnZXQsIGxlbmd0aCwgc2lkZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCBzaWRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gV2lkZ2V0Vmlldy5jcmVhdGUodGhpcy53aWRnZXQsIHRoaXMubGVuZ3RoIC0gZnJvbSwgdGhpcy5zaWRlKTtcbiAgICAgICAgdGhpcy5sZW5ndGggLT0gZnJvbTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3luYyh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy5kb20gfHwgIXRoaXMud2lkZ2V0LnVwZGF0ZURPTSh0aGlzLmRvbSwgdmlldykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSAmJiB0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKHRoaXMud2lkZ2V0LnRvRE9NKHZpZXcpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy53aWRnZXQuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNpZGUoKSB7IHJldHVybiB0aGlzLnNpZGU7IH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBoYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgV2lkZ2V0VmlldykgfHwgIXRoaXMud2lkZ2V0LmNvbXBhcmUoc291cmNlLndpZGdldCkgfHxcbiAgICAgICAgICAgIGZyb20gPiAwICYmIG9wZW5TdGFydCA8PSAwIHx8IHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tICsgKHNvdXJjZSA/IHNvdXJjZS5sZW5ndGggOiAwKSArICh0aGlzLmxlbmd0aCAtIHRvKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRWaWV3ICYmIG90aGVyLnNpZGUgPT0gdGhpcy5zaWRlICYmXG4gICAgICAgICAgICB0aGlzLndpZGdldC5jb25zdHJ1Y3RvciA9PSBvdGhlci53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy53aWRnZXQuY29tcGFyZShvdGhlci53aWRnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmICF0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdGhpcy53aWRnZXQuaWdub3JlRXZlbnQoZXZlbnQpOyB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh0b3AucGFyZW50KVxuICAgICAgICAgICAgdG9wID0gdG9wLnBhcmVudDtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdG9wLCB0ZXh0ID0gdmlldyAmJiB2aWV3LnN0YXRlLmRvYywgc3RhcnQgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIHJldHVybiB0ZXh0ID8gdGV4dC5zbGljZShzdGFydCwgc3RhcnQgKyB0aGlzLmxlbmd0aCkgOiBUZXh0LmVtcHR5O1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxlbmd0aCA/IHBvcyA9PSAwIDogdGhpcy5zaWRlID4gMClcbiAgICAgICAgICAgID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSlcbiAgICAgICAgICAgIDogRE9NUG9zLmFmdGVyKHRoaXMuZG9tLCBwb3MgPT0gdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLndpZGdldC5jb29yZHNBdCh0aGlzLmRvbSwgcG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKGN1c3RvbSlcbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIGxldCByZWN0cyA9IHRoaXMuZG9tLmdldENsaWVudFJlY3RzKCksIHJlY3QgPSBudWxsO1xuICAgICAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZnJvbUJhY2sgPSB0aGlzLnNpZGUgPyB0aGlzLnNpZGUgPCAwIDogcG9zID4gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb21CYWNrID8gcmVjdHMubGVuZ3RoIC0gMSA6IDA7OyBpICs9IChmcm9tQmFjayA/IC0xIDogMSkpIHtcbiAgICAgICAgICAgIHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChwb3MgPiAwID8gaSA9PSAwIDogaSA9PSByZWN0cy5sZW5ndGggLSAxIHx8IHJlY3QudG9wIDwgcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsICFmcm9tQmFjayk7XG4gICAgfVxuICAgIGdldCBpc0VkaXRhYmxlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNXaWRnZXQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdGhpcy53aWRnZXQuaXNIaWRkZW47IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgIH1cbn1cbi8vIFRoZXNlIGFyZSBkcmF3biBhcm91bmQgdW5lZGl0YWJsZSB3aWRnZXRzIHRvIGF2b2lkIGEgbnVtYmVyIG9mXG4vLyBicm93c2VyIGJ1Z3MgdGhhdCBzaG93IHVwIHdoZW4gdGhlIGN1cnNvciBpcyBkaXJlY3RseSBuZXh0IHRvXG4vLyB1bmVkaXRhYmxlIGlubGluZSBjb250ZW50LlxuY2xhc3MgV2lkZ2V0QnVmZmVyVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzaWRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiAwOyB9XG4gICAgbWVyZ2UoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRCdWZmZXJWaWV3ICYmIG90aGVyLnNpZGUgPT0gdGhpcy5zaWRlO1xuICAgIH1cbiAgICBzcGxpdCgpIHsgcmV0dXJuIG5ldyBXaWRnZXRCdWZmZXJWaWV3KHRoaXMuc2lkZSk7IH1cbiAgICBzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcImNtLXdpZGdldEJ1ZmZlclwiO1xuICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIHRoaXMuc2lkZTsgfVxuICAgIGRvbUF0UG9zKHBvcykgeyByZXR1cm4gdGhpcy5zaWRlID4gMCA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pIDogRE9NUG9zLmFmdGVyKHRoaXMuZG9tKTsgfVxuICAgIGxvY2FsUG9zRnJvbURPTSgpIHsgcmV0dXJuIDA7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29vcmRzQXQocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRydWU7IH1cbn1cblRleHRWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IFdpZGdldFZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gV2lkZ2V0QnVmZmVyVmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBub0NoaWxkcmVuO1xuZnVuY3Rpb24gaW5saW5lRE9NQXRQb3MocGFyZW50LCBwb3MpIHtcbiAgICBsZXQgZG9tID0gcGFyZW50LmRvbSwgeyBjaGlsZHJlbiB9ID0gcGFyZW50LCBpID0gMDtcbiAgICBmb3IgKGxldCBvZmYgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA9PSBvZmYgJiYgY2hpbGQuZ2V0U2lkZSgpIDw9IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHBvcyA+IG9mZiAmJiBwb3MgPCBlbmQgJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUF0UG9zKHBvcyAtIG9mZik7XG4gICAgICAgIGlmIChwb3MgPD0gb2ZmKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG9mZiA9IGVuZDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgbGV0IHByZXYgPSBjaGlsZHJlbltqIC0gMV07XG4gICAgICAgIGlmIChwcmV2LmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBwcmV2LmRvbUF0UG9zKHByZXYubGVuZ3RoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2pdO1xuICAgICAgICBpZiAobmV4dC5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gbmV4dC5kb21BdFBvcygwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBET01Qb3MoZG9tLCAwKTtcbn1cbi8vIEFzc3VtZXMgYHZpZXdgLCBpZiBhIG1hcmsgdmlldywgaGFzIHByZWNpc2VseSAxIGNoaWxkLlxuZnVuY3Rpb24gam9pbklubGluZUludG8ocGFyZW50LCB2aWV3LCBvcGVuKSB7XG4gICAgbGV0IGxhc3QsIHsgY2hpbGRyZW4gfSA9IHBhcmVudDtcbiAgICBpZiAob3BlbiA+IDAgJiYgdmlldyBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIGNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICAobGFzdCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIE1hcmtWaWV3ICYmIGxhc3QubWFyay5lcSh2aWV3Lm1hcmspKSB7XG4gICAgICAgIGpvaW5JbmxpbmVJbnRvKGxhc3QsIHZpZXcuY2hpbGRyZW5bMF0sIG9wZW4gLSAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2godmlldyk7XG4gICAgICAgIHZpZXcuc2V0UGFyZW50KHBhcmVudCk7XG4gICAgfVxuICAgIHBhcmVudC5sZW5ndGggKz0gdmlldy5sZW5ndGg7XG59XG5mdW5jdGlvbiBjb29yZHNJbkNoaWxkcmVuKHZpZXcsIHBvcywgc2lkZSkge1xuICAgIGxldCBiZWZvcmUgPSBudWxsLCBiZWZvcmVQb3MgPSAtMSwgYWZ0ZXIgPSBudWxsLCBhZnRlclBvcyA9IC0xO1xuICAgIGZ1bmN0aW9uIHNjYW4odmlldywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgdmlldy5jaGlsZHJlbi5sZW5ndGggJiYgb2ZmIDw9IHBvczsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB2aWV3LmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbihjaGlsZCwgcG9zIC0gb2ZmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKCFhZnRlciB8fCBhZnRlci5pc0hpZGRlbiAmJiBzaWRlID4gMCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGVuZCA+IHBvcyB8fCBvZmYgPT0gZW5kICYmIGNoaWxkLmdldFNpZGUoKSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyUG9zID0gcG9zIC0gb2ZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmYgPCBwb3MgfHwgKG9mZiA9PSBlbmQgJiYgY2hpbGQuZ2V0U2lkZSgpIDwgMCkgJiYgIWNoaWxkLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVQb3MgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW4odmlldywgcG9zKTtcbiAgICBsZXQgdGFyZ2V0ID0gKHNpZGUgPCAwID8gYmVmb3JlIDogYWZ0ZXIpIHx8IGJlZm9yZSB8fCBhZnRlcjtcbiAgICBpZiAodGFyZ2V0KVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmNvb3Jkc0F0KE1hdGgubWF4KDAsIHRhcmdldCA9PSBiZWZvcmUgPyBiZWZvcmVQb3MgOiBhZnRlclBvcyksIHNpZGUpO1xuICAgIHJldHVybiBmYWxsYmFja1JlY3Qodmlldyk7XG59XG5mdW5jdGlvbiBmYWxsYmFja1JlY3Qodmlldykge1xuICAgIGxldCBsYXN0ID0gdmlldy5kb20ubGFzdENoaWxkO1xuICAgIGlmICghbGFzdClcbiAgICAgICAgcmV0dXJuIHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGxhc3QpO1xuICAgIHJldHVybiByZWN0c1tyZWN0cy5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lQXR0cnMoc291cmNlLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIgJiYgdGFyZ2V0LmNsYXNzKVxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzICs9IFwiIFwiICsgc291cmNlLmNsYXNzO1xuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIiAmJiB0YXJnZXQuc3R5bGUpXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUgKz0gXCI7XCIgKyBzb3VyY2Uuc3R5bGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHNvdXJjZVtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmNvbnN0IG5vQXR0cnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGF0dHJzRXEoYSwgYiwgaWdub3JlKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCFhKVxuICAgICAgICBhID0gbm9BdHRycztcbiAgICBpZiAoIWIpXG4gICAgICAgIGIgPSBub0F0dHJzO1xuICAgIGxldCBrZXlzQSA9IE9iamVjdC5rZXlzKGEpLCBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChrZXlzQS5sZW5ndGggLSAoaWdub3JlICYmIGtleXNBLmluZGV4T2YoaWdub3JlKSA+IC0xID8gMSA6IDApICE9XG4gICAgICAgIGtleXNCLmxlbmd0aCAtIChpZ25vcmUgJiYga2V5c0IuaW5kZXhPZihpZ25vcmUpID4gLTEgPyAxIDogMCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5c0EpIHtcbiAgICAgICAgaWYgKGtleSAhPSBpZ25vcmUgJiYgKGtleXNCLmluZGV4T2Yoa2V5KSA9PSAtMSB8fCBhW2tleV0gIT09IGJba2V5XSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdXBkYXRlQXR0cnMoZG9tLCBwcmV2LCBhdHRycykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgaWYgKHByZXYpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgICAgIGlmICghKGF0dHJzICYmIG5hbWUgaW4gYXR0cnMpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgIGlmIChhdHRycylcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgIGlmICghKHByZXYgJiYgcHJldltuYW1lXSA9PSBhdHRyc1tuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcInN0eWxlXCIpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gYXR0cnNbbmFtZV07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGdldEF0dHJzKGRvbSkge1xuICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkb20uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXR0ciA9IGRvbS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICBhdHRyc1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuXG5jbGFzcyBMaW5lVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmF0dHJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICB9XG4gICAgLy8gQ29uc3VtZXMgc291cmNlXG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBMaW5lVmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICBzb3VyY2UudHJhbnNmZXJET00odGhpcyk7IC8vIFJldXNlIHNvdXJjZS5kb20gd2hlbiBhcHByb3ByaWF0ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTdGFydClcbiAgICAgICAgICAgIHRoaXMuc2V0RGVjbyhzb3VyY2UgPyBzb3VyY2UuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgbWVyZ2VDaGlsZHJlbkludG8odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbi5zbGljZSgpIDogW10sIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzcGxpdChhdCkge1xuICAgICAgICBsZXQgZW5kID0gbmV3IExpbmVWaWV3O1xuICAgICAgICBlbmQuYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlcjtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gZW5kO1xuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRQb3MoYXQpO1xuICAgICAgICBpZiAob2ZmKSB7XG4gICAgICAgICAgICBlbmQuYXBwZW5kKHRoaXMuY2hpbGRyZW5baV0uc3BsaXQob2ZmKSwgMCk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLm1lcmdlKG9mZiwgdGhpcy5jaGlsZHJlbltpXS5sZW5ndGgsIG51bGwsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICBlbmQuYXBwZW5kKHRoaXMuY2hpbGRyZW5bal0sIDApO1xuICAgICAgICB3aGlsZSAoaSA+IDAgJiYgdGhpcy5jaGlsZHJlbltpIC0gMV0ubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuWy0taV0uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IGk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXQ7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuICAgIHRyYW5zZmVyRE9NKG90aGVyKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIG90aGVyLnNldERPTSh0aGlzLmRvbSk7XG4gICAgICAgIG90aGVyLnByZXZBdHRycyA9IHRoaXMucHJldkF0dHJzID09PSB1bmRlZmluZWQgPyB0aGlzLmF0dHJzIDogdGhpcy5wcmV2QXR0cnM7XG4gICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgfVxuICAgIHNldERlY28oYXR0cnMpIHtcbiAgICAgICAgaWYgKCFhdHRyc0VxKHRoaXMuYXR0cnMsIGF0dHJzKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kKGNoaWxkLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgam9pbklubGluZUludG8odGhpcywgY2hpbGQsIG9wZW5TdGFydCk7XG4gICAgfVxuICAgIC8vIE9ubHkgY2FsbGVkIHdoZW4gYnVpbGRpbmcgYSBsaW5lIHZpZXcgaW4gQ29udGVudEJ1aWxkZXJcbiAgICBhZGRMaW5lRGVjbyhkZWNvKSB7XG4gICAgICAgIGxldCBhdHRycyA9IGRlY28uc3BlYy5hdHRyaWJ1dGVzLCBjbHMgPSBkZWNvLnNwZWMuY2xhc3M7XG4gICAgICAgIGlmIChhdHRycylcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBjb21iaW5lQXR0cnMoYXR0cnMsIHRoaXMuYXR0cnMgfHwge30pO1xuICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyh7IGNsYXNzOiBjbHMgfSwgdGhpcy5hdHRycyB8fCB7fSk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gaW5saW5lRE9NQXRQb3ModGhpcywgcG9zKTtcbiAgICB9XG4gICAgcmV1c2VET00obm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkRJVlwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShub2RlKTtcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gNCAvKiBWaWV3RmxhZy5BdHRyc0RpcnR5ICovIHwgMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luYyh2aWV3LCB0cmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnMgPyBudWxsIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmxhZ3MgJiA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8pIHtcbiAgICAgICAgICAgIGNsZWFyQXR0cmlidXRlcyh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycyA/IG51bGwgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldkF0dHJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUF0dHJzKHRoaXMuZG9tLCB0aGlzLnByZXZBdHRycywgdGhpcy5hdHRycyk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGluZVwiKTtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnN5bmModmlldywgdHJhY2spO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZG9tLmxhc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGxhc3QgJiYgQ29udGVudFZpZXcuZ2V0KGxhc3QpIGluc3RhbmNlb2YgTWFya1ZpZXcpXG4gICAgICAgICAgICBsYXN0ID0gbGFzdC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghbGFzdCB8fCAhdGhpcy5sZW5ndGggfHxcbiAgICAgICAgICAgIGxhc3Qubm9kZU5hbWUgIT0gXCJCUlwiICYmICgoX2EgPSBDb250ZW50Vmlldy5nZXQobGFzdCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0VkaXRhYmxlKSA9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICghYnJvd3Nlci5pb3MgfHwgIXRoaXMuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRleHRWaWV3KSkpIHtcbiAgICAgICAgICAgIGxldCBoYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkJSXCIpO1xuICAgICAgICAgICAgaGFjay5jbUlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChoYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlVGV4dFNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwIHx8IHRoaXMubGVuZ3RoID4gMjApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvdGFsV2lkdGggPSAwLCB0ZXh0SGVpZ2h0O1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3KSB8fCAvW14gLX5dLy50ZXN0KGNoaWxkLnRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IoY2hpbGQuZG9tKTtcbiAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGggIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRvdGFsV2lkdGggKz0gcmVjdHNbMF0ud2lkdGg7XG4gICAgICAgICAgICB0ZXh0SGVpZ2h0ID0gcmVjdHNbMF0uaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdG90YWxXaWR0aCA/IG51bGwgOiB7XG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsXG4gICAgICAgICAgICBjaGFyV2lkdGg6IHRvdGFsV2lkdGggLyB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgIHRleHRIZWlnaHRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCByZWN0ID0gY29vcmRzSW5DaGlsZHJlbih0aGlzLCBwb3MsIHNpZGUpO1xuICAgICAgICAvLyBDb3JyZWN0IHJlY3RhbmdsZSBoZWlnaHQgZm9yIGVtcHR5IGxpbmVzIHdoZW4gdGhlIHJldHVybmVkXG4gICAgICAgIC8vIGhlaWdodCBpcyBsYXJnZXIgdGhhbiB0aGUgdGV4dCBoZWlnaHQuXG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbi5sZW5ndGggJiYgcmVjdCAmJiB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgbGV0IHsgaGVpZ2h0T3JhY2xlIH0gPSB0aGlzLnBhcmVudC52aWV3LnZpZXdTdGF0ZSwgaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhoZWlnaHQgLSBoZWlnaHRPcmFjbGUubGluZUhlaWdodCkgPCAyICYmIGhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3QgPSAoaGVpZ2h0IC0gaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b3A6IHJlY3QudG9wICsgZGlzdCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIGRpc3QsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBiZWNvbWUoX290aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGNvdmVycygpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBzdGF0aWMgZmluZChkb2NWaWV3LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCBkb2NWaWV3LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSBkb2NWaWV3LmNoaWxkcmVuW2ldLCBlbmQgPSBvZmYgKyBibG9jay5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChibG9jayBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBlbmQgKyBibG9jay5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNsYXNzIEJsb2NrV2lkZ2V0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQsIGxlbmd0aCwgZGVjbykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuZGVjbyA9IGRlY287XG4gICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IDA7XG4gICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIF90YWtlRGVjbywgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3KSB8fCAhdGhpcy53aWRnZXQuY29tcGFyZShzb3VyY2Uud2lkZ2V0KSB8fFxuICAgICAgICAgICAgZnJvbSA+IDAgJiYgb3BlblN0YXJ0IDw9IDAgfHwgdG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb20gKyAoc291cmNlID8gc291cmNlLmxlbmd0aCA6IDApICsgKHRoaXMubGVuZ3RoIC0gdG8pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBwb3MgPT0gMCA/IERPTVBvcy5iZWZvcmUodGhpcy5kb20pIDogRE9NUG9zLmFmdGVyKHRoaXMuZG9tLCBwb3MgPT0gdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBzcGxpdChhdCkge1xuICAgICAgICBsZXQgbGVuID0gdGhpcy5sZW5ndGggLSBhdDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhdDtcbiAgICAgICAgbGV0IGVuZCA9IG5ldyBCbG9ja1dpZGdldFZpZXcodGhpcy53aWRnZXQsIGxlbiwgdGhpcy5kZWNvKTtcbiAgICAgICAgZW5kLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXI7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIG5vQ2hpbGRyZW47IH1cbiAgICBzeW5jKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tLCB2aWV3KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmIHRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00odmlldykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLndpZGdldC5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmlldy5zdGF0ZS5kb2Muc2xpY2UodGhpcy5wb3NBdFN0YXJ0LCB0aGlzLnBvc0F0RW5kKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmXG4gICAgICAgICAgICBvdGhlci53aWRnZXQuY29uc3RydWN0b3IgPT0gdGhpcy53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghb3RoZXIud2lkZ2V0LmNvbXBhcmUodGhpcy53aWRnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmICF0aGlzLnByZXZXaWRnZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gdGhpcy53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLndpZGdldCA9IG90aGVyLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvID0gb3RoZXIuZGVjbztcbiAgICAgICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IG90aGVyLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXQuY29vcmRzQXQodGhpcy5kb20sIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxuICAgIGNvdmVycyhzaWRlKSB7XG4gICAgICAgIGxldCB7IHN0YXJ0U2lkZSwgZW5kU2lkZSB9ID0gdGhpcy5kZWNvO1xuICAgICAgICByZXR1cm4gc3RhcnRTaWRlID09IGVuZFNpZGUgPyBmYWxzZSA6IHNpZGUgPCAwID8gc3RhcnRTaWRlIDwgMCA6IGVuZFNpZGUgPiAwO1xuICAgIH1cbn1cblxuLyoqXG5XaWRnZXRzIGFkZGVkIHRvIHRoZSBjb250ZW50IGFyZSBkZXNjcmliZWQgYnkgc3ViY2xhc3NlcyBvZiB0aGlzXG5jbGFzcy4gVXNpbmcgYSBkZXNjcmlwdGlvbiBvYmplY3QgbGlrZSB0aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvXG5kZWxheSBjcmVhdGluZyBvZiB0aGUgRE9NIHN0cnVjdHVyZSBmb3IgYSB3aWRnZXQgdW50aWwgaXQgaXNcbm5lZWRlZCwgYW5kIHRvIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIGV2ZW4gaWYgdGhlIGRlY29yYXRpb25zXG50aGF0IGRlZmluZSB0aGVtIGFyZSByZWNyZWF0ZWQuXG4qL1xuY2xhc3MgV2lkZ2V0VHlwZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGluc3RhbmNlIHRvIGFub3RoZXIgaW5zdGFuY2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAoVHlwZVNjcmlwdCBjYW4ndCBleHByZXNzIHRoaXMsIGJ1dCBvbmx5IGluc3RhbmNlcyBvZiB0aGUgc2FtZVxuICAgIHNwZWNpZmljIGNsYXNzIHdpbGwgYmUgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLikgVGhpcyBpcyB1c2VkIHRvXG4gICAgYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgd2hlbiB0aGV5IGFyZSByZXBsYWNlZCBieSBhIG5ld1xuICAgIGRlY29yYXRpb24gb2YgdGhlIHNhbWUgdHlwZS4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24ganVzdFxuICAgIHJldHVybnMgYGZhbHNlYCwgd2hpY2ggd2lsbCBjYXVzZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB3aWRnZXQgdG9cbiAgICBhbHdheXMgYmUgcmVkcmF3bi5cbiAgICAqL1xuICAgIGVxKHdpZGdldCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBET00gZWxlbWVudCBjcmVhdGVkIGJ5IGEgd2lkZ2V0IG9mIHRoZSBzYW1lIHR5cGUgKGJ1dFxuICAgIGRpZmZlcmVudCwgbm9uLWBlcWAgY29udGVudCkgdG8gcmVmbGVjdCB0aGlzIHdpZGdldC4gTWF5IHJldHVyblxuICAgIHRydWUgdG8gaW5kaWNhdGUgdGhhdCBpdCBjb3VsZCB1cGRhdGUsIGZhbHNlIHRvIGluZGljYXRlIGl0XG4gICAgY291bGRuJ3QgKGluIHdoaWNoIGNhc2UgdGhlIHdpZGdldCB3aWxsIGJlIHJlZHJhd24pLiBUaGUgZGVmYXVsdFxuICAgIGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJucyBmYWxzZS5cbiAgICAqL1xuICAgIHVwZGF0ZURPTShkb20sIHZpZXcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlc3RpbWF0ZWQgaGVpZ2h0IHRoaXMgd2lkZ2V0IHdpbGwgaGF2ZSwgdG8gYmUgdXNlZCB3aGVuXG4gICAgZXN0aW1hdGluZyB0aGUgaGVpZ2h0IG9mIGNvbnRlbnQgdGhhdCBoYXNuJ3QgYmVlbiBkcmF3bi4gTWF5XG4gICAgcmV0dXJuIC0xIHRvIGluZGljYXRlIHlvdSBkb24ndCBrbm93LiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybnMgLTEuXG4gICAgKi9cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gLTE7IH1cbiAgICAvKipcbiAgICBGb3IgaW5saW5lIHdpZGdldHMgdGhhdCBhcmUgZGlzcGxheWVkIGlubGluZSAoYXMgb3Bwb3NlZCB0b1xuICAgIGBpbmxpbmUtYmxvY2tgKSBhbmQgaW50cm9kdWNlIGxpbmUgYnJlYWtzICh0aHJvdWdoIGA8YnI+YCB0YWdzXG4gICAgb3IgdGV4dHVhbCBuZXdsaW5lcyksIHRoaXMgbXVzdCBpbmRpY2F0ZSB0aGUgYW1vdW50IG9mIGxpbmVcbiAgICBicmVha3MgdGhleSBpbnRyb2R1Y2UuIERlZmF1bHRzIHRvIDAuXG4gICAgKi9cbiAgICBnZXQgbGluZUJyZWFrcygpIHsgcmV0dXJuIDA7IH1cbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBjb25maWd1cmUgd2hpY2gga2luZHMgb2YgZXZlbnRzIGluc2lkZSB0aGUgd2lkZ2V0XG4gICAgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGVkaXRvci4gVGhlIGRlZmF1bHQgaXMgdG8gaWdub3JlIGFsbFxuICAgIGV2ZW50cy5cbiAgICAqL1xuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0cnVlOyB9XG4gICAgLyoqXG4gICAgT3ZlcnJpZGUgdGhlIHdheSBzY3JlZW4gY29vcmRpbmF0ZXMgZm9yIHBvc2l0aW9ucyBhdC9pbiB0aGVcbiAgICB3aWRnZXQgYXJlIGZvdW5kLiBgcG9zYCB3aWxsIGJlIHRoZSBvZmZzZXQgaW50byB0aGUgd2lkZ2V0LCBhbmRcbiAgICBgc2lkZWAgdGhlIHNpZGUgb2YgdGhlIHBvc2l0aW9uIHRoYXQgaXMgYmVpbmcgcXVlcmllZOKAlGxlc3MgdGhhblxuICAgIHplcm8gZm9yIGJlZm9yZSwgZ3JlYXRlciB0aGFuIHplcm8gZm9yIGFmdGVyLCBhbmQgemVybyBmb3JcbiAgICBkaXJlY3RseSBhdCB0aGF0IHBvc2l0aW9uLlxuICAgICovXG4gICAgY29vcmRzQXQoZG9tLCBwb3MsIHNpZGUpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGFuIGluc3RhbmNlIG9mIHRoZSB3aWRnZXQgaXMgcmVtb3ZlZFxuICAgIGZyb20gdGhlIGVkaXRvciB2aWV3LlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuLyoqXG5UaGUgZGlmZmVyZW50IHR5cGVzIG9mIGJsb2NrcyB0aGF0IGNhbiBvY2N1ciBpbiBhbiBlZGl0b3Igdmlldy5cbiovXG52YXIgQmxvY2tUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmxvY2tUeXBlKSB7XG4gICAgLyoqXG4gICAgQSBsaW5lIG9mIHRleHQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBhZnRlciBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRCZWZvcmVcIl0gPSAxXSA9IFwiV2lkZ2V0QmVmb3JlXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBiZWZvcmUgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QWZ0ZXJcIl0gPSAyXSA9IFwiV2lkZ2V0QWZ0ZXJcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBbcmVwbGFjaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBhIHJhbmdlIG9mIGNvbnRlbnQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0UmFuZ2VcIl0gPSAzXSA9IFwiV2lkZ2V0UmFuZ2VcIjtcbnJldHVybiBCbG9ja1R5cGV9KShCbG9ja1R5cGUgfHwgKEJsb2NrVHlwZSA9IHt9KSk7XG4vKipcbkEgZGVjb3JhdGlvbiBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZHJhdyBvciBzdHlsZSBhIHBpZWNlXG5vZiBjb250ZW50LiBZb3UnbGwgdXN1YWxseSB1c2UgaXQgd3JhcHBlZCBpbiBhXG5bYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSksIHdoaWNoIGFkZHMgYSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uLlxuQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgRGVjb3JhdGlvbiBleHRlbmRzIFJhbmdlVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhcnRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVuZFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd2lkZ2V0LCBcbiAgICAvKipcbiAgICBUaGUgY29uZmlnIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGlzIGRlY29yYXRpb24uIFlvdSBjYW5cbiAgICBpbmNsdWRlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbiB0aGVyZSB0byBzdG9yZSBtZXRhZGF0YSBhYm91dFxuICAgIHlvdXIgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFNpZGUgPSBzdGFydFNpZGU7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IGVuZFNpZGU7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBkZWNvcmF0aW9uLCB3aGljaCBpbmZsdWVuY2VzIHRoZSBzdHlsaW5nIG9mIHRoZVxuICAgIGNvbnRlbnQgaW4gaXRzIHJhbmdlLiBOZXN0ZWQgbWFyayBkZWNvcmF0aW9ucyB3aWxsIGNhdXNlIG5lc3RlZFxuICAgIERPTSBlbGVtZW50cyB0byBiZSBjcmVhdGVkLiBOZXN0aW5nIG9yZGVyIGlzIGRldGVybWluZWQgYnlcbiAgICBwcmVjZWRlbmNlIG9mIHRoZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgd2l0aFxuICAgIHRoZSBoaWdoZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucyBjcmVhdGluZyB0aGUgaW5uZXIgRE9NIG5vZGVzLlxuICAgIFN1Y2ggZWxlbWVudHMgYXJlIHNwbGl0IG9uIGxpbmUgYm91bmRhcmllcyBhbmQgb24gdGhlIGJvdW5kYXJpZXNcbiAgICBvZiBsb3dlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIG1hcmsoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggZGlzcGxheXMgYSBET00gZWxlbWVudCBhdCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQoc3BlYykge1xuICAgICAgICBsZXQgc2lkZSA9IE1hdGgubWF4KC0xMDAwMCwgTWF0aC5taW4oMTAwMDAsIHNwZWMuc2lkZSB8fCAwKSksIGJsb2NrID0gISFzcGVjLmJsb2NrO1xuICAgICAgICBzaWRlICs9IChibG9jayAmJiAhc3BlYy5pbmxpbmVPcmRlcilcbiAgICAgICAgICAgID8gKHNpZGUgPiAwID8gMzAwMDAwMDAwIC8qIFNpZGUuQmxvY2tBZnRlciAqLyA6IC00MDAwMDAwMDAgLyogU2lkZS5CbG9ja0JlZm9yZSAqLylcbiAgICAgICAgICAgIDogKHNpZGUgPiAwID8gMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQWZ0ZXIgKi8gOiAtMTAwMDAwMDAwIC8qIFNpZGUuSW5saW5lQmVmb3JlICovKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc2lkZSwgc2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZSBkZWNvcmF0aW9uIHdoaWNoIHJlcGxhY2VzIHRoZSBnaXZlbiByYW5nZSB3aXRoXG4gICAgYSB3aWRnZXQsIG9yIHNpbXBseSBoaWRlcyBpdC5cbiAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlKHNwZWMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gISFzcGVjLmJsb2NrLCBzdGFydFNpZGUsIGVuZFNpZGU7XG4gICAgICAgIGlmIChzcGVjLmlzQmxvY2tHYXApIHtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IC01MDAwMDAwMDAgLyogU2lkZS5HYXBTdGFydCAqLztcbiAgICAgICAgICAgIGVuZFNpZGUgPSA0MDAwMDAwMDAgLyogU2lkZS5HYXBFbmQgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2spO1xuICAgICAgICAgICAgc3RhcnRTaWRlID0gKHN0YXJ0ID8gKGJsb2NrID8gLTMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jU3RhcnQgKi8gOiAtMSAvKiBTaWRlLklubGluZUluY1N0YXJ0ICovKSA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovKSAtIDE7XG4gICAgICAgICAgICBlbmRTaWRlID0gKGVuZCA/IChibG9jayA/IDIwMDAwMDAwMCAvKiBTaWRlLkJsb2NrSW5jRW5kICovIDogMSAvKiBTaWRlLklubGluZUluY0VuZCAqLykgOiAtNjAwMDAwMDAwIC8qIFNpZGUuTm9uSW5jRW5kICovKSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgc3BlYy53aWRnZXQgfHwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxpbmUgZGVjb3JhdGlvbiwgd2hpY2ggY2FuIGFkZCBET00gYXR0cmlidXRlcyB0byB0aGVcbiAgICBsaW5lIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBsaW5lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSBbYERlY29yYXRpb25TZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkgZnJvbSB0aGUgZ2l2ZW5cbiAgICBkZWNvcmF0ZWQgcmFuZ2Ugb3IgcmFuZ2VzLiBJZiB0aGUgcmFuZ2VzIGFyZW4ndCBhbHJlYWR5IHNvcnRlZCxcbiAgICBwYXNzIGB0cnVlYCBmb3IgYHNvcnRgIHRvIG1ha2UgdGhlIGxpYnJhcnkgc29ydCB0aGVtIGZvciB5b3UuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0KG9mLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0Lm9mKG9mLCBzb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBoYXNIZWlnaHQoKSB7IHJldHVybiB0aGlzLndpZGdldCA/IHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+IC0xIDogZmFsc2U7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBkZWNvcmF0aW9ucy5cbiovXG5EZWNvcmF0aW9uLm5vbmUgPSBSYW5nZVNldC5lbXB0eTtcbmNsYXNzIE1hcmtEZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYyk7XG4gICAgICAgIHN1cGVyKHN0YXJ0ID8gLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLyA6IDUwMDAwMDAwMCAvKiBTaWRlLk5vbkluY1N0YXJ0ICovLCBlbmQgPyAxIC8qIFNpZGUuSW5saW5lSW5jRW5kICovIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLywgbnVsbCwgc3BlYyk7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHNwZWMudGFnTmFtZSB8fCBcInNwYW5cIjtcbiAgICAgICAgdGhpcy5jbGFzcyA9IHNwZWMuY2xhc3MgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5hdHRycyA9IHNwZWMuYXR0cmlidXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgb3RoZXIgaW5zdGFuY2VvZiBNYXJrRGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9PSBvdGhlci50YWdOYW1lICYmXG4gICAgICAgICAgICAgICAgKHRoaXMuY2xhc3MgfHwgKChfYSA9IHRoaXMuYXR0cnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzcykpID09IChvdGhlci5jbGFzcyB8fCAoKF9iID0gb3RoZXIuYXR0cnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGFzcykpICYmXG4gICAgICAgICAgICAgICAgYXR0cnNFcSh0aGlzLmF0dHJzLCBvdGhlci5hdHRycywgXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tID49IHRvKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXJrIGRlY29yYXRpb25zIG1heSBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTWFya0RlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XG5jbGFzcyBMaW5lRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgc3VwZXIoLTIwMDAwMDAwMCAvKiBTaWRlLkxpbmUgKi8sIC0yMDAwMDAwMDAgLyogU2lkZS5MaW5lICovLCBudWxsLCBzcGVjKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTGluZURlY29yYXRpb24gJiZcbiAgICAgICAgICAgIHRoaXMuc3BlYy5jbGFzcyA9PSBvdGhlci5zcGVjLmNsYXNzICYmXG4gICAgICAgICAgICBhdHRyc0VxKHRoaXMuc3BlYy5hdHRyaWJ1dGVzLCBvdGhlci5zcGVjLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRvICE9IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkxpbmUgZGVjb3JhdGlvbiByYW5nZXMgbXVzdCBiZSB6ZXJvLWxlbmd0aFwiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5MaW5lRGVjb3JhdGlvbi5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tCZWZvcmU7XG5MaW5lRGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuY2xhc3MgUG9pbnREZWNvcmF0aW9uIGV4dGVuZHMgRGVjb3JhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3BlYywgc3RhcnRTaWRlLCBlbmRTaWRlLCBibG9jaywgd2lkZ2V0LCBpc1JlcGxhY2UpIHtcbiAgICAgICAgc3VwZXIoc3RhcnRTaWRlLCBlbmRTaWRlLCB3aWRnZXQsIHNwZWMpO1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIHRoaXMuaXNSZXBsYWNlID0gaXNSZXBsYWNlO1xuICAgICAgICB0aGlzLm1hcE1vZGUgPSAhYmxvY2sgPyBNYXBNb2RlLlRyYWNrRGVsIDogc3RhcnRTaWRlIDw9IDAgPyBNYXBNb2RlLlRyYWNrQmVmb3JlIDogTWFwTW9kZS5UcmFja0FmdGVyO1xuICAgIH1cbiAgICAvLyBPbmx5IHJlbGV2YW50IHdoZW4gdGhpcy5ibG9jayA9PSB0cnVlXG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2lkZSAhPSB0aGlzLmVuZFNpZGUgPyBCbG9ja1R5cGUuV2lkZ2V0UmFuZ2VcbiAgICAgICAgICAgIDogdGhpcy5zdGFydFNpZGUgPD0gMCA/IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgOiBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXI7XG4gICAgfVxuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgfHwgISF0aGlzLndpZGdldCAmJiAodGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID49IDUgfHwgdGhpcy53aWRnZXQubGluZUJyZWFrcyA+IDApO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24gJiZcbiAgICAgICAgICAgIHdpZGdldHNFcSh0aGlzLndpZGdldCwgb3RoZXIud2lkZ2V0KSAmJlxuICAgICAgICAgICAgdGhpcy5ibG9jayA9PSBvdGhlci5ibG9jayAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydFNpZGUgPT0gb3RoZXIuc3RhcnRTaWRlICYmIHRoaXMuZW5kU2lkZSA9PSBvdGhlci5lbmRTaWRlO1xuICAgIH1cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXBsYWNlICYmIChmcm9tID4gdG8gfHwgKGZyb20gPT0gdG8gJiYgdGhpcy5zdGFydFNpZGUgPiAwICYmIHRoaXMuZW5kU2lkZSA8PSAwKSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcmFuZ2UgZm9yIHJlcGxhY2VtZW50IGRlY29yYXRpb25cIik7XG4gICAgICAgIGlmICghdGhpcy5pc1JlcGxhY2UgJiYgdG8gIT0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV2lkZ2V0IGRlY29yYXRpb25zIGNhbiBvbmx5IGhhdmUgemVyby1sZW5ndGggcmFuZ2VzXCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cblBvaW50RGVjb3JhdGlvbi5wcm90b3R5cGUucG9pbnQgPSB0cnVlO1xuZnVuY3Rpb24gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrID0gZmFsc2UpIHtcbiAgICBsZXQgeyBpbmNsdXNpdmVTdGFydDogc3RhcnQsIGluY2x1c2l2ZUVuZDogZW5kIH0gPSBzcGVjO1xuICAgIGlmIChzdGFydCA9PSBudWxsKVxuICAgICAgICBzdGFydCA9IHNwZWMuaW5jbHVzaXZlO1xuICAgIGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0ICE9PSBudWxsICYmIHN0YXJ0ICE9PSB2b2lkIDAgPyBzdGFydCA6IGJsb2NrLCBlbmQ6IGVuZCAhPT0gbnVsbCAmJiBlbmQgIT09IHZvaWQgMCA/IGVuZCA6IGJsb2NrIH07XG59XG5mdW5jdGlvbiB3aWRnZXRzRXEoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgISEoYSAmJiBiICYmIGEuY29tcGFyZShiKSk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZShmcm9tLCB0bywgcmFuZ2VzLCBtYXJnaW4gPSAwKSB7XG4gICAgbGV0IGxhc3QgPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XSArIG1hcmdpbiA+PSBmcm9tKVxuICAgICAgICByYW5nZXNbbGFzdF0gPSBNYXRoLm1heChyYW5nZXNbbGFzdF0sIHRvKTtcbiAgICBlbHNlXG4gICAgICAgIHJhbmdlcy5wdXNoKGZyb20sIHRvKTtcbn1cblxuY2xhc3MgQ29udGVudEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvYywgcG9zLCBlbmQsIGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMuZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IgPSBkaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvcjtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIHRoaXMuYnVmZmVyTWFya3MgPSBbXTtcbiAgICAgICAgLy8gU2V0IHRvIGZhbHNlIGRpcmVjdGx5IGFmdGVyIGEgd2lkZ2V0IHRoYXQgY292ZXJzIHRoZSBwb3NpdGlvbiBhZnRlciBpdFxuICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gLTE7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jLml0ZXIoKTtcbiAgICAgICAgdGhpcy5za2lwID0gcG9zO1xuICAgIH1cbiAgICBwb3NDb3ZlcmVkKCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmJyZWFrQXRTdGFydCAmJiB0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gIT0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuICEobGFzdC5icmVha0FmdGVyIHx8IGxhc3QgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgbGFzdC5kZWNvLmVuZFNpZGUgPCAwKTtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1ckxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKHRoaXMuY3VyTGluZSA9IG5ldyBMaW5lVmlldyk7XG4gICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJMaW5lO1xuICAgIH1cbiAgICBmbHVzaEJ1ZmZlcihhY3RpdmUgPSB0aGlzLmJ1ZmZlck1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZS5hcHBlbmQod3JhcE1hcmtzKG5ldyBXaWRnZXRCdWZmZXJWaWV3KC0xKSwgYWN0aXZlKSwgYWN0aXZlLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRCbG9ja1dpZGdldCh2aWV3KSB7XG4gICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50LnB1c2godmlldyk7XG4gICAgfVxuICAgIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIgJiYgb3BlbkVuZCA8PSB0aGlzLmJ1ZmZlck1hcmtzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBCdWYuTm8gKi87XG4gICAgICAgIGlmICghdGhpcy5wb3NDb3ZlcmVkKCkgJiZcbiAgICAgICAgICAgICEob3BlbkVuZCAmJiB0aGlzLmNvbnRlbnQubGVuZ3RoICYmIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcpKVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgfVxuICAgIGJ1aWxkVGV4dChsZW5ndGgsIGFjdGl2ZSwgb3BlblN0YXJ0KSB7XG4gICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmID09IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB2YWx1ZSwgbGluZUJyZWFrLCBkb25lIH0gPSB0aGlzLmN1cnNvci5uZXh0KHRoaXMuc2tpcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuIG91dCBvZiB0ZXh0IGNvbnRlbnQgd2hlbiBkcmF3aW5nIGlubGluZSB2aWV3c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZUJyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJyZWFrQXRTdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0YWtlID0gTWF0aC5taW4odGhpcy50ZXh0Lmxlbmd0aCAtIHRoaXMudGV4dE9mZiwgbGVuZ3RoLCA1MTIgLyogVC5DaHVuayAqLyk7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKGFjdGl2ZS5zbGljZShhY3RpdmUubGVuZ3RoIC0gb3BlblN0YXJ0KSk7XG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKS5hcHBlbmQod3JhcE1hcmtzKG5ldyBUZXh0Vmlldyh0aGlzLnRleHQuc2xpY2UodGhpcy50ZXh0T2ZmLCB0aGlzLnRleHRPZmYgKyB0YWtlKSksIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudGV4dE9mZiArPSB0YWtlO1xuICAgICAgICAgICAgbGVuZ3RoIC09IHRha2U7XG4gICAgICAgICAgICBvcGVuU3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNwYW4oZnJvbSwgdG8sIGFjdGl2ZSwgb3BlblN0YXJ0KSB7XG4gICAgICAgIHRoaXMuYnVpbGRUZXh0KHRvIC0gZnJvbSwgYWN0aXZlLCBvcGVuU3RhcnQpO1xuICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgfVxuICAgIHBvaW50KGZyb20sIHRvLCBkZWNvLCBhY3RpdmUsIG9wZW5TdGFydCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3JbaW5kZXhdICYmIGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQmxvY2sgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgICAgICAgICBpZiAodG8gPiB0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGVjb3JhdGlvbnMgdGhhdCByZXBsYWNlIGxpbmUgYnJlYWtzIG1heSBub3QgYmUgc3BlY2lmaWVkIHZpYSBwbHVnaW5zXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgIGlmIChkZWNvIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIGlmIChkZWNvLnN0YXJ0U2lkZSA+IDAgJiYgIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJsb2NrV2lkZ2V0KG5ldyBCbG9ja1dpZGdldFZpZXcoZGVjby53aWRnZXQgfHwgbmV3IE51bGxXaWRnZXQoXCJkaXZcIiksIGxlbiwgZGVjbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXcgPSBXaWRnZXRWaWV3LmNyZWF0ZShkZWNvLndpZGdldCB8fCBuZXcgTnVsbFdpZGdldChcInNwYW5cIiksIGxlbiwgbGVuID8gMCA6IGRlY28uc3RhcnRTaWRlKTtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQmVmb3JlID0gdGhpcy5hdEN1cnNvclBvcyAmJiAhdmlldy5pc0VkaXRhYmxlICYmIG9wZW5TdGFydCA8PSBhY3RpdmUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChmcm9tIDwgdG8gfHwgZGVjby5zdGFydFNpZGUgPiAwKTtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQWZ0ZXIgPSAhdmlldy5pc0VkaXRhYmxlICYmIChmcm9tIDwgdG8gfHwgb3BlblN0YXJ0ID4gYWN0aXZlLmxlbmd0aCB8fCBkZWNvLnN0YXJ0U2lkZSA8PSAwKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIgPT0gMiAvKiBCdWYuSWZDdXJzb3IgKi8gJiYgIWN1cnNvckJlZm9yZSAmJiAhdmlldy5pc0VkaXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvckJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoMSksIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5TdGFydCA9IGFjdGl2ZS5sZW5ndGggKyBNYXRoLm1heCgwLCBvcGVuU3RhcnQgLSBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZS5hcHBlbmQod3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IGN1cnNvckFmdGVyO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9ICFjdXJzb3JBZnRlciA/IDAgLyogQnVmLk5vICovIDogZnJvbSA8IHRvIHx8IG9wZW5TdGFydCA+IGFjdGl2ZS5sZW5ndGggPyAxIC8qIEJ1Zi5ZZXMgKi8gOiAyIC8qIEJ1Zi5JZkN1cnNvciAqLztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlck1hcmtzID0gYWN0aXZlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tID09IHRoaXMucG9zKSB7IC8vIExpbmUgZGVjb3JhdGlvblxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYWRkTGluZURlY28oZGVjbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgaXRlcmF0b3IgcGFzdCB0aGUgcmVwbGFjZWQgY29udGVudFxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiArIGxlbiA8PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCArPSBsZW4gLSAodGhpcy50ZXh0Lmxlbmd0aCAtIHRoaXMudGV4dE9mZik7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZCh0ZXh0LCBmcm9tLCB0bywgZGVjb3JhdGlvbnMsIGR5bmFtaWNEZWNvcmF0aW9uTWFwKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IENvbnRlbnRCdWlsZGVyKHRleHQsIGZyb20sIHRvLCBkeW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgIGJ1aWxkZXIub3BlbkVuZCA9IFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlcik7XG4gICAgICAgIGlmIChidWlsZGVyLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICBidWlsZGVyLm9wZW5TdGFydCA9IGJ1aWxkZXIub3BlbkVuZDtcbiAgICAgICAgYnVpbGRlci5maW5pc2goYnVpbGRlci5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSkge1xuICAgIGZvciAobGV0IG1hcmsgb2YgYWN0aXZlKVxuICAgICAgICB2aWV3ID0gbmV3IE1hcmtWaWV3KG1hcmssIFt2aWV3XSwgdmlldy5sZW5ndGgpO1xuICAgIHJldHVybiB2aWV3O1xufVxuY2xhc3MgTnVsbFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnRhZyA9PSB0aGlzLnRhZzsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZyk7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7IHJldHVybiBlbHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSB0aGlzLnRhZzsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRydWU7IH1cbn1cblxuLyoqXG5Vc2VkIHRvIGluZGljYXRlIFt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuXG4qL1xudmFyIERpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIC8vIChUaGVzZSBhcmUgY2hvc2VuIHRvIG1hdGNoIHRoZSBiYXNlIGxldmVscywgaW4gYmlkaSBhbGdvcml0aG1cbiAgICAvLyB0ZXJtcywgb2Ygc3BhbnMgaW4gdGhhdCBkaXJlY3Rpb24uKVxuICAgIC8qKlxuICAgIExlZnQtdG8tcmlnaHQuXG4gICAgKi9cbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiTFRSXCJdID0gMF0gPSBcIkxUUlwiO1xuICAgIC8qKlxuICAgIFJpZ2h0LXRvLWxlZnQuXG4gICAgKi9cbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiUlRMXCJdID0gMV0gPSBcIlJUTFwiO1xucmV0dXJuIERpcmVjdGlvbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcbmNvbnN0IExUUiA9IERpcmVjdGlvbi5MVFIsIFJUTCA9IERpcmVjdGlvbi5SVEw7XG4vLyBEZWNvZGUgYSBzdHJpbmcgd2l0aCBlYWNoIHR5cGUgZW5jb2RlZCBhcyBsb2cyKHR5cGUpXG5mdW5jdGlvbiBkZWMoc3RyKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXN1bHQucHVzaCgxIDw8ICtzdHJbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGY4XG5jb25zdCBMb3dUeXBlcyA9IC8qQF9fUFVSRV9fKi9kZWMoXCI4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODY2Njg4ODg4ODc4NzgzMzMzMzMzMzMzNzg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4Nzg2NjY2ODg4ODA4ODg4ODY2MzM4MDg4ODMwODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwOFwiKTtcbi8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmOVxuY29uc3QgQXJhYmljVHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiNDQ0NDQ0ODgyNjYyNzI4ODk5OTk5OTk5OTk5MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTk5OTk5OTk5OTk5OTk5NDQ0NDQ0NDQ0NDY0NDIyMjgyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk0OTk5OTk5OTIyOTk4OTk5OTIyMzMzMzMzMzMzM1wiKTtcbmNvbnN0IEJyYWNrZXRzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCksIEJyYWNrZXRTdGFjayA9IFtdO1xuLy8gVGhlcmUncyBhIGxvdCBtb3JlIGluXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvQmlkaUJyYWNrZXRzLnR4dCxcbi8vIHdoaWNoIGFyZSBsZWZ0IG91dCB0byBrZWVwIGNvZGUgc2l6ZSBkb3duLlxuZm9yIChsZXQgcCBvZiBbXCIoKVwiLCBcIltdXCIsIFwie31cIl0pIHtcbiAgICBsZXQgbCA9IC8qQF9fUFVSRV9fKi9wLmNoYXJDb2RlQXQoMCksIHIgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDEpO1xuICAgIEJyYWNrZXRzW2xdID0gcjtcbiAgICBCcmFja2V0c1tyXSA9IC1sO1xufVxuZnVuY3Rpb24gY2hhclR5cGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPD0gMHhmNyA/IExvd1R5cGVzW2NoXSA6XG4gICAgICAgIDB4NTkwIDw9IGNoICYmIGNoIDw9IDB4NWY0ID8gMiAvKiBULlIgKi8gOlxuICAgICAgICAgICAgMHg2MDAgPD0gY2ggJiYgY2ggPD0gMHg2ZjkgPyBBcmFiaWNUeXBlc1tjaCAtIDB4NjAwXSA6XG4gICAgICAgICAgICAgICAgMHg2ZWUgPD0gY2ggJiYgY2ggPD0gMHg4YWMgPyA0IC8qIFQuQUwgKi8gOlxuICAgICAgICAgICAgICAgICAgICAweDIwMDAgPD0gY2ggJiYgY2ggPD0gMHgyMDBjID8gMjU2IC8qIFQuTkkgKi8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgMHhmYjUwIDw9IGNoICYmIGNoIDw9IDB4ZmRmZiA/IDQgLyogVC5BTCAqLyA6IDEgLyogVC5MICovO1xufVxuY29uc3QgQmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNcXHVmYjUwLVxcdWZkZmZdLztcbi8qKlxuUmVwcmVzZW50cyBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgdGV4dCB0aGF0IGhhcyBhIHNpbmdsZSBkaXJlY3Rpb25cbihhcyBpbiBsZWZ0LXRvLXJpZ2h0IG9yIHJpZ2h0LXRvLWxlZnQpLlxuKi9cbmNsYXNzIEJpZGlTcGFuIHtcbiAgICAvKipcbiAgICBUaGUgZGlyZWN0aW9uIG9mIHRoaXMgc3Bhbi5cbiAgICAqL1xuICAgIGdldCBkaXIoKSB7IHJldHVybiB0aGlzLmxldmVsICUgMiA/IFJUTCA6IExUUjsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBzcGFuIChyZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGxpbmUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgc3Bhbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgW1wiYmlkaVxuICAgIGxldmVsXCJdKGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvI0Jhc2ljX0Rpc3BsYXlfQWxnb3JpdGhtKVxuICAgIG9mIHRoZSBzcGFuIChpbiB0aGlzIGNvbnRleHQsIDAgbWVhbnNcbiAgICBsZWZ0LXRvLXJpZ2h0LCAxIG1lYW5zIHJpZ2h0LXRvLWxlZnQsIDIgbWVhbnMgbGVmdC10by1yaWdodFxuICAgIG51bWJlciBpbnNpZGUgcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiAgICAqL1xuICAgIGxldmVsKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNpZGUoZW5kLCBkaXIpIHsgcmV0dXJuICh0aGlzLmRpciA9PSBkaXIpID09IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcndhcmQoZm9yd2FyZCwgZGlyKSB7IHJldHVybiBmb3J3YXJkID09ICh0aGlzLmRpciA9PSBkaXIpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZChvcmRlciwgaW5kZXgsIGxldmVsLCBhc3NvYykge1xuICAgICAgICBsZXQgbWF5YmUgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltpXTtcbiAgICAgICAgICAgIGlmIChzcGFuLmZyb20gPD0gaW5kZXggJiYgc3Bhbi50byA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGFuLmxldmVsID09IGxldmVsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIG11bHRpcGxlIHNwYW5zIG1hdGNoLCBpZiBhc3NvYyAhPSAwLCB0YWtlIHRoZSBvbmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGNvdmVycyB0aGF0IHNpZGUsIG90aGVyd2lzZSB0YWtlIHRoZSBvbmUgd2l0aCB0aGUgbWluaW11bVxuICAgICAgICAgICAgICAgIC8vIGxldmVsLlxuICAgICAgICAgICAgICAgIGlmIChtYXliZSA8IDAgfHwgKGFzc29jICE9IDAgPyAoYXNzb2MgPCAwID8gc3Bhbi5mcm9tIDwgaW5kZXggOiBzcGFuLnRvID4gaW5kZXgpIDogb3JkZXJbbWF5YmVdLmxldmVsID4gc3Bhbi5sZXZlbCkpXG4gICAgICAgICAgICAgICAgICAgIG1heWJlID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF5YmUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBtYXliZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc29sYXRlc0VxKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGlBID0gYVtpXSwgaUIgPSBiW2ldO1xuICAgICAgICBpZiAoaUEuZnJvbSAhPSBpQi5mcm9tIHx8IGlBLnRvICE9IGlCLnRvIHx8IGlBLmRpcmVjdGlvbiAhPSBpQi5kaXJlY3Rpb24gfHwgIWlzb2xhdGVzRXEoaUEuaW5uZXIsIGlCLmlubmVyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBSZXVzZWQgYXJyYXkgb2YgY2hhcmFjdGVyIHR5cGVzXG5jb25zdCB0eXBlcyA9IFtdO1xuLy8gRmlsbCBpbiB0aGUgY2hhcmFjdGVyIHR5cGVzIChpbiBgdHlwZXNgKSBmcm9tIGBmcm9tYCB0byBgdG9gIGFuZFxuLy8gYXBwbHkgVyBub3JtYWxpemF0aW9uIHJ1bGVzLlxuZnVuY3Rpb24gY29tcHV0ZUNoYXJUeXBlcyhsaW5lLCByRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgZm9yIChsZXQgaUkgPSAwOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICBsZXQgcHJldlR5cGUgPSBpSSA/IDI1NiAvKiBULk5JICovIDogb3V0ZXJUeXBlO1xuICAgICAgICAvLyBXMS4gRXhhbWluZSBlYWNoIG5vbi1zcGFjaW5nIG1hcmsgKE5TTSkgaW4gdGhlIGxldmVsIHJ1biwgYW5kXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAgICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHNvci5cbiAgICAgICAgLy8gVzIuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcbiAgICAgICAgLy8gbnVtYmVyLlxuICAgICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAgICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4sIEFOLCBFVCwgQ1MsIE5JKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbSwgcHJldiA9IHByZXZUeXBlLCBwcmV2U3Ryb25nID0gcHJldlR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGNoYXJUeXBlKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSA1MTIgLyogVC5OU00gKi8pXG4gICAgICAgICAgICAgICAgdHlwZSA9IHByZXY7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgICAgICB0eXBlID0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZSA9PSA0IC8qIFQuQUwgKi8gPyAyIC8qIFQuUiAqLyA6IHR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZSAmIDcgLyogVC5TdHJvbmcgKi8pXG4gICAgICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgICAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxuICAgICAgICAvLyBOZXV0cmFsLlxuICAgICAgICAvLyBXNy4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcbiAgICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXG4gICAgICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOLCBOSSlcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIHByZXYgPSBwcmV2VHlwZSwgcHJldlN0cm9uZyA9IHByZXZUeXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDEyOCAvKiBULkNTICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCB0byAtIDEgJiYgcHJldiA9PSB0eXBlc1tpICsgMV0gJiYgKHByZXYgJiAyNCAvKiBULk51bSAqLykpXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlc1tpXSA9IHByZXY7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IDI1NiAvKiBULk5JICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA2NCAvKiBULkVUICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbmQgPCB0byAmJiB0eXBlc1tlbmRdID09IDY0IC8qIFQuRVQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlID0gKGkgJiYgcHJldiA9PSA4IC8qIFQuRU4gKi8pIHx8IChlbmQgPCByVG8gJiYgdHlwZXNbZW5kXSA9PSA4IC8qIFQuRU4gKi8pID8gKHByZXZTdHJvbmcgPT0gMSAvKiBULkwgKi8gPyAxIC8qIFQuTCAqLyA6IDggLyogVC5FTiAqLykgOiAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICAgICAgaSA9IGVuZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogVC5FTiAqLyAmJiBwcmV2U3Ryb25nID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gUHJvY2VzcyBicmFja2V0cyB0aHJvdWdob3V0IGEgcnVuIHNlcXVlbmNlLlxuZnVuY3Rpb24gcHJvY2Vzc0JyYWNrZXRQYWlycyhsaW5lLCByRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgbGV0IG9wcG9zaXRlVHlwZSA9IG91dGVyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgZm9yIChsZXQgaUkgPSAwLCBzSSA9IDAsIGNvbnRleHQgPSAwOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAvLyBOMC4gUHJvY2VzcyBicmFja2V0IHBhaXJzIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2VcbiAgICAgICAgLy8gc2VxdWVudGlhbGx5IGluIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSB0ZXh0IHBvc2l0aW9ucyBvZiB0aGVcbiAgICAgICAgLy8gb3BlbmluZyBwYWlyZWQgYnJhY2tldHMgdXNpbmcgdGhlIGxvZ2ljIGdpdmVuIGJlbG93LiBXaXRoaW4gdGhpc1xuICAgICAgICAvLyBzY29wZSwgYmlkaXJlY3Rpb25hbCB0eXBlcyBFTiBhbmQgQU4gYXJlIHRyZWF0ZWQgYXMgUi5cbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIGNoLCBiciwgdHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEtlZXBzIFtzdGFydEluZGV4LCB0eXBlLCBzdHJvbmdTZWVuXSB0cmlwbGVzIGZvciBlYWNoIG9wZW5cbiAgICAgICAgICAgIC8vIGJyYWNrZXQgb24gQnJhY2tldFN0YWNrLlxuICAgICAgICAgICAgaWYgKGJyID0gQnJhY2tldHNbY2ggPSBsaW5lLmNoYXJDb2RlQXQoaSldKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyIDwgMCkgeyAvLyBDbG9zaW5nIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChCcmFja2V0U3RhY2tbc0ogKyAxXSA9PSAtYnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IChmbGFncyAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKSA/IG91dGVyVHlwZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoZmxhZ3MgJiA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLykgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbGFncyAmIDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovKSA/IG9wcG9zaXRlVHlwZSA6IG91dGVyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSB0eXBlc1tCcmFja2V0U3RhY2tbc0pdXSA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc0kgPSBzSjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChCcmFja2V0U3RhY2subGVuZ3RoID09IDE4OSAvKiBCcmFja2V0ZWQuTWF4RGVwdGggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBpO1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHlwZSA9IHR5cGVzW2ldKSA9PSAyIC8qIFQuUiAqLyB8fCB0eXBlID09IDEgLyogVC5MICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVtYmVkID0gdHlwZSA9PSBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGVtYmVkID8gMCA6IDEgLyogQnJhY2tldGVkLk9wcG9zaXRlQmVmb3JlICovO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXIgPSBCcmFja2V0U3RhY2tbc0ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gMiAvKiBCcmFja2V0ZWQuRW1iZWRJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSA0IC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUluc2lkZSAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NOZXV0cmFscyhyRnJvbSwgclRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKSB7XG4gICAgZm9yIChsZXQgaUkgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlOyBpSSA8PSBpc29sYXRlcy5sZW5ndGg7IGlJKyspIHtcbiAgICAgICAgbGV0IGZyb20gPSBpSSA/IGlzb2xhdGVzW2lJIC0gMV0udG8gOiByRnJvbSwgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgICAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgICAgICAvLyBkaXJlY3Rpb24uIEV1cm9wZWFuIGFuZCBBcmFiaWMgbnVtYmVycyBhY3QgYXMgaWYgdGhleSB3ZXJlIFIgaW5cbiAgICAgICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcbiAgICAgICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgICAgIC8vIE4yLiBBbnkgcmVtYWluaW5nIG5ldXRyYWxzIHRha2UgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOK0FOKVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA9PSB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlJID09IGlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlzb2xhdGVzW2lJKytdLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSBpSSA8IGlzb2xhdGVzLmxlbmd0aCA/IGlzb2xhdGVzW2lJXS5mcm9tIDogclRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW2VuZF0gPT0gMjU2IC8qIFQuTkkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZUwgPSBwcmV2ID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgICAgIGxldCBhZnRlckwgPSAoZW5kIDwgclRvID8gdHlwZXNbZW5kXSA6IG91dGVyVHlwZSkgPT0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSBiZWZvcmVMID09IGFmdGVyTCA/IChiZWZvcmVMID8gMSAvKiBULkwgKi8gOiAyIC8qIFQuUiAqLykgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGVuZCwgakkgPSBpSSwgZnJvbUogPSBqSSA/IGlzb2xhdGVzW2pJIC0gMV0udG8gOiByRnJvbTsgaiA+IGk7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IGZyb21KKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gaXNvbGF0ZXNbLS1qSV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21KID0gakkgPyBpc29sYXRlc1tqSSAtIDFdLnRvIDogckZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbLS1qXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBGaW5kIHRoZSBjb250aWd1b3VzIHJhbmdlcyBvZiBjaGFyYWN0ZXIgdHlwZXMgaW4gYSBnaXZlbiByYW5nZSwgYW5kXG4vLyBlbWl0IHNwYW5zIGZvciB0aGVtLiBGbGlwIHRoZSBvcmRlciBvZiB0aGUgc3BhbnMgYXMgYXBwcm9wcmlhdGVcbi8vIGJhc2VkIG9uIHRoZSBsZXZlbCwgYW5kIGNhbGwgdGhyb3VnaCB0byBjb21wdXRlIHRoZSBzcGFucyBmb3Jcbi8vIGlzb2xhdGVzIGF0IHRoZSBwcm9wZXIgcG9pbnQuXG5mdW5jdGlvbiBlbWl0U3BhbnMobGluZSwgZnJvbSwgdG8sIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBvcmRlcikge1xuICAgIGxldCBvdXJUeXBlID0gbGV2ZWwgJSAyID8gMiAvKiBULlIgKi8gOiAxIC8qIFQuTCAqLztcbiAgICBpZiAoKGxldmVsICUgMikgPT0gKGJhc2VMZXZlbCAlIDIpKSB7IC8vIFNhbWUgZGlyIGFzIGJhc2UgZGlyZWN0aW9uLCBkb24ndCBmbGlwXG4gICAgICAgIGZvciAobGV0IGlDaCA9IGZyb20sIGlJID0gMDsgaUNoIDwgdG87KSB7XG4gICAgICAgICAgICAvLyBTY2FuIGEgc2VjdGlvbiBvZiBjaGFyYWN0ZXJzIGluIGRpcmVjdGlvbiBvdXJUeXBlLCB1bmxlc3NcbiAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW5vdGhlciB0eXBlIG9mIGNoYXIgcmlnaHQgYWZ0ZXIgaUNoLCBpbiB3aGljaCBjYXNlXG4gICAgICAgICAgICAvLyB3ZSBzY2FuIGEgc2VjdGlvbiBvZiBvdGhlciBjaGFyYWN0ZXJzICh3aGljaCwgaWYgb3VyVHlwZSA9PVxuICAgICAgICAgICAgLy8gVC5MLCBtYXkgY29udGFpbiBib3RoIFQuUiBhbmQgVC5BTiBjaGFycykuXG4gICAgICAgICAgICBsZXQgc2FtZURpciA9IHRydWUsIGlzTnVtID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaUkgPT0gaXNvbGF0ZXMubGVuZ3RoIHx8IGlDaCA8IGlzb2xhdGVzW2lJXS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlc1tpQ2hdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IG91clR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZURpciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpc051bSA9IG5leHQgPT0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIb2xkcyBhbiBhcnJheSBvZiBpc29sYXRlcyB0byBwYXNzIHRvIGEgcmVjdXJzaXZlIGNhbGwgaWYgd2VcbiAgICAgICAgICAgIC8vIG11c3QgcmVjdXJzZSAodG8gZGlzdGluZ3Vpc2ggVC5BTiBpbnNpZGUgYW4gUlRMIHNlY3Rpb24gaW5cbiAgICAgICAgICAgIC8vIExUUiB0ZXh0KSwgbnVsbCBpZiB3ZSBjYW4gZW1pdCBkaXJlY3RseVxuICAgICAgICAgICAgbGV0IHJlY3Vyc2UgPSAhc2FtZURpciAmJiBvdXJUeXBlID09IDEgLyogVC5MICovID8gW10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGxvY2FsTGV2ZWwgPSBzYW1lRGlyID8gbGV2ZWwgOiBsZXZlbCArIDE7XG4gICAgICAgICAgICBsZXQgaVNjYW4gPSBpQ2g7XG4gICAgICAgICAgICBydW46IGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaUkgPCBpc29sYXRlcy5sZW5ndGggJiYgaVNjYW4gPT0gaXNvbGF0ZXNbaUldLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNvID0gaXNvbGF0ZXNbaUldO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FuIGFoZWFkIHRvIHZlcmlmeSB0aGF0IHRoZXJlIGlzIGFub3RoZXIgY2hhciBpbiB0aGlzIGRpciBhZnRlciB0aGUgaXNvbGF0ZShzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1cHRvID0gaXNvLnRvLCBqSSA9IGlJICsgMTs7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwdG8gPT0gdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoakkgPCBpc29sYXRlcy5sZW5ndGggJiYgaXNvbGF0ZXNbakldLmZyb20gPT0gdXB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0byA9IGlzb2xhdGVzW2pJKytdLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVzW3VwdG9dID09IG91clR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpSSsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZS5wdXNoKGlzbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvLmZyb20gPiBpQ2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaUNoLCBpc28uZnJvbSwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpclN3YXAgPSAoaXNvLmRpcmVjdGlvbiA9PSBMVFIpICE9ICEobG9jYWxMZXZlbCAlIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBkaXJTd2FwID8gbGV2ZWwgKyAxIDogbGV2ZWwsIGJhc2VMZXZlbCwgaXNvLmlubmVyLCBpc28uZnJvbSwgaXNvLnRvLCBvcmRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpQ2ggPSBpc28udG87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaVNjYW4gPSBpc28udG87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuID09IHRvIHx8IChzYW1lRGlyID8gdHlwZXNbaVNjYW5dICE9IG91clR5cGUgOiB0eXBlc1tpU2Nhbl0gPT0gb3VyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpU2NhbisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1cnNlKVxuICAgICAgICAgICAgICAgIGVtaXRTcGFucyhsaW5lLCBpQ2gsIGlTY2FuLCBsZXZlbCArIDEsIGJhc2VMZXZlbCwgcmVjdXJzZSwgb3JkZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaUNoIDwgaVNjYW4pXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaUNoLCBpU2NhbiwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgaUNoID0gaVNjYW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEl0ZXJhdGUgaW4gcmV2ZXJzZSB0byBmbGlwIHRoZSBzcGFuIG9yZGVyLiBTYW1lIGNvZGUgYWdhaW4sIGJ1dFxuICAgICAgICAvLyBnb2luZyBmcm9tIHRoZSBiYWNrIG9mIHRoZSBzZWN0aW9uIHRvIHRoZSBmcm9udFxuICAgICAgICBmb3IgKGxldCBpQ2ggPSB0bywgaUkgPSBpc29sYXRlcy5sZW5ndGg7IGlDaCA+IGZyb207KSB7XG4gICAgICAgICAgICBsZXQgc2FtZURpciA9IHRydWUsIGlzTnVtID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlJIHx8IGlDaCA+IGlzb2xhdGVzW2lJIC0gMV0udG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHR5cGVzW2lDaCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IG91clR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtZURpciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpc051bSA9IG5leHQgPT0gMTYgLyogVC5BTiAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVjdXJzZSA9ICFzYW1lRGlyICYmIG91clR5cGUgPT0gMSAvKiBULkwgKi8gPyBbXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbG9jYWxMZXZlbCA9IHNhbWVEaXIgPyBsZXZlbCA6IGxldmVsICsgMTtcbiAgICAgICAgICAgIGxldCBpU2NhbiA9IGlDaDtcbiAgICAgICAgICAgIHJ1bjogZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChpSSAmJiBpU2NhbiA9PSBpc29sYXRlc1tpSSAtIDFdLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzbyA9IGlzb2xhdGVzWy0taUldO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY2FuIGFoZWFkIHRvIHZlcmlmeSB0aGF0IHRoZXJlIGlzIGFub3RoZXIgY2hhciBpbiB0aGlzIGRpciBhZnRlciB0aGUgaXNvbGF0ZShzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEaXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1cHRvID0gaXNvLmZyb20sIGpJID0gaUk7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHRvID09IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoakkgJiYgaXNvbGF0ZXNbakkgLSAxXS50byA9PSB1cHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHRvID0gaXNvbGF0ZXNbLS1qSV0uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1t1cHRvIC0gMV0gPT0gb3VyVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcnVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN1cnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNlLnB1c2goaXNvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc28udG8gPCBpQ2gpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaXNvLnRvLCBpQ2gsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXJTd2FwID0gKGlzby5kaXJlY3Rpb24gPT0gTFRSKSAhPSAhKGxvY2FsTGV2ZWwgJSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgZGlyU3dhcCA/IGxldmVsICsgMSA6IGxldmVsLCBiYXNlTGV2ZWwsIGlzby5pbm5lciwgaXNvLmZyb20sIGlzby50bywgb3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaUNoID0gaXNvLmZyb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaVNjYW4gPSBpc28uZnJvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPT0gZnJvbSB8fCAoc2FtZURpciA/IHR5cGVzW2lTY2FuIC0gMV0gIT0gb3VyVHlwZSA6IHR5cGVzW2lTY2FuIC0gMV0gPT0gb3VyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpU2Nhbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1cnNlKVxuICAgICAgICAgICAgICAgIGVtaXRTcGFucyhsaW5lLCBpU2NhbiwgaUNoLCBsZXZlbCArIDEsIGJhc2VMZXZlbCwgcmVjdXJzZSwgb3JkZXIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoaVNjYW4gPCBpQ2gpXG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oaVNjYW4sIGlDaCwgbG9jYWxMZXZlbCkpO1xuICAgICAgICAgICAgaUNoID0gaVNjYW47XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGxldmVsLCBiYXNlTGV2ZWwsIGlzb2xhdGVzLCBmcm9tLCB0bywgb3JkZXIpIHtcbiAgICBsZXQgb3V0ZXJUeXBlID0gKGxldmVsICUgMiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi8pO1xuICAgIGNvbXB1dGVDaGFyVHlwZXMobGluZSwgZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIHByb2Nlc3NCcmFja2V0UGFpcnMobGluZSwgZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIHByb2Nlc3NOZXV0cmFscyhmcm9tLCB0bywgaXNvbGF0ZXMsIG91dGVyVHlwZSk7XG4gICAgZW1pdFNwYW5zKGxpbmUsIGZyb20sIHRvLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgb3JkZXIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZU9yZGVyKGxpbmUsIGRpcmVjdGlvbiwgaXNvbGF0ZXMpIHtcbiAgICBpZiAoIWxpbmUpXG4gICAgICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIDAsIGRpcmVjdGlvbiA9PSBSVEwgPyAxIDogMCldO1xuICAgIGlmIChkaXJlY3Rpb24gPT0gTFRSICYmICFpc29sYXRlcy5sZW5ndGggJiYgIUJpZGlSRS50ZXN0KGxpbmUpKVxuICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICBpZiAoaXNvbGF0ZXMubGVuZ3RoKVxuICAgICAgICB3aGlsZSAobGluZS5sZW5ndGggPiB0eXBlcy5sZW5ndGgpXG4gICAgICAgICAgICB0eXBlc1t0eXBlcy5sZW5ndGhdID0gMjU2IC8qIFQuTkkgKi87IC8vIE1ha2Ugc3VyZSB0eXBlcyBhcnJheSBoYXMgbm8gZ2Fwc1xuICAgIGxldCBvcmRlciA9IFtdLCBsZXZlbCA9IGRpcmVjdGlvbiA9PSBMVFIgPyAwIDogMTtcbiAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGxldmVsLCBsZXZlbCwgaXNvbGF0ZXMsIDAsIGxpbmUubGVuZ3RoLCBvcmRlcik7XG4gICAgcmV0dXJuIG9yZGVyO1xufVxuZnVuY3Rpb24gdHJpdmlhbE9yZGVyKGxlbmd0aCkge1xuICAgIHJldHVybiBbbmV3IEJpZGlTcGFuKDAsIGxlbmd0aCwgMCldO1xufVxubGV0IG1vdmVkT3ZlciA9IFwiXCI7XG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIG1vdmVzIHN0cmljdGx5IHZpc3VhbGx5LCB3aXRob3V0IGNvbmNlcm4gZm9yIGFcbi8vIHRyYXZlcnNhbCB2aXNpdGluZyBldmVyeSBsb2dpY2FsIHBvc2l0aW9uIGluIHRoZSBzdHJpbmcuIEl0IHdpbGxcbi8vIHN0aWxsIGRvIHNvIGZvciBzaW1wbGUgaW5wdXQsIGJ1dCBzaXR1YXRpb25zIGxpa2UgbXVsdGlwbGUgaXNvbGF0ZXNcbi8vIHdpdGggdGhlIHNhbWUgbGV2ZWwgbmV4dCB0byBlYWNoIG90aGVyLCBvciB0ZXh0IGdvaW5nIGFnYWluc3QgdGhlXG4vLyBtYWluIGRpciBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLCB3aWxsIG1ha2Ugc29tZSBwb3NpdGlvbnNcbi8vIHVucmVhY2hhYmxlIHdpdGggdGhpcyBtb3Rpb24uIEVhY2ggdmlzaWJsZSBjdXJzb3IgcG9zaXRpb24gd2lsbFxuLy8gY29ycmVzcG9uZCB0byB0aGUgbG93ZXItbGV2ZWwgYmlkaSBzcGFuIHRoYXQgdG91Y2hlcyBpdC5cbi8vXG4vLyBUaGUgYWx0ZXJuYXRpdmUgd291bGQgYmUgdG8gc29sdmUgYW4gb3JkZXIgZ2xvYmFsbHkgZm9yIGEgZ2l2ZW5cbi8vIGxpbmUsIG1ha2luZyBzdXJlIHRoYXQgaXQgaW5jbHVkZXMgZXZlcnkgcG9zaXRpb24sIGJ1dCB0aGF0IHdvdWxkXG4vLyByZXF1aXJlIGFzc29jaWF0aW5nIG5vbi1jYW5vbmljYWwgKGhpZ2hlciBiaWRpIHNwYW4gbGV2ZWwpXG4vLyBwb3NpdGlvbnMgd2l0aCBhIGdpdmVuIHZpc3VhbCBwb3NpdGlvbiwgd2hpY2ggaXMgbGlrZWx5IHRvIGNvbmZ1c2Vcbi8vIHBlb3BsZS4gKEFuZCB3b3VsZCBnZW5lcmFsbHkgYmUgYSBsb3QgbW9yZSBjb21wbGljYXRlZC4pXG5mdW5jdGlvbiBtb3ZlVmlzdWFsbHkobGluZSwgb3JkZXIsIGRpciwgc3RhcnQsIGZvcndhcmQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5oZWFkIC0gbGluZS5mcm9tO1xuICAgIGxldCBzcGFuSSA9IEJpZGlTcGFuLmZpbmQob3JkZXIsIHN0YXJ0SW5kZXgsIChfYSA9IHN0YXJ0LmJpZGlMZXZlbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTEsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgc3BhbiA9IG9yZGVyW3NwYW5JXSwgc3BhbkVuZCA9IHNwYW4uc2lkZShmb3J3YXJkLCBkaXIpO1xuICAgIC8vIEVuZCBvZiBzcGFuXG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gc3BhbkVuZCkge1xuICAgICAgICBsZXQgbmV4dEkgPSBzcGFuSSArPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgICAgICBpZiAobmV4dEkgPCAwIHx8IG5leHRJID49IG9yZGVyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBzcGFuID0gb3JkZXJbc3BhbkkgPSBuZXh0SV07XG4gICAgICAgIHN0YXJ0SW5kZXggPSBzcGFuLnNpZGUoIWZvcndhcmQsIGRpcik7XG4gICAgICAgIHNwYW5FbmQgPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKTtcbiAgICB9XG4gICAgbGV0IG5leHRJbmRleCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBzdGFydEluZGV4LCBzcGFuLmZvcndhcmQoZm9yd2FyZCwgZGlyKSk7XG4gICAgaWYgKG5leHRJbmRleCA8IHNwYW4uZnJvbSB8fCBuZXh0SW5kZXggPiBzcGFuLnRvKVxuICAgICAgICBuZXh0SW5kZXggPSBzcGFuRW5kO1xuICAgIG1vdmVkT3ZlciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihzdGFydEluZGV4LCBuZXh0SW5kZXgpLCBNYXRoLm1heChzdGFydEluZGV4LCBuZXh0SW5kZXgpKTtcbiAgICBsZXQgbmV4dFNwYW4gPSBzcGFuSSA9PSAoZm9yd2FyZCA/IG9yZGVyLmxlbmd0aCAtIDEgOiAwKSA/IG51bGwgOiBvcmRlcltzcGFuSSArIChmb3J3YXJkID8gMSA6IC0xKV07XG4gICAgaWYgKG5leHRTcGFuICYmIG5leHRJbmRleCA9PSBzcGFuRW5kICYmIG5leHRTcGFuLmxldmVsICsgKGZvcndhcmQgPyAwIDogMSkgPCBzcGFuLmxldmVsKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0U3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpICsgbGluZS5mcm9tLCBuZXh0U3Bhbi5mb3J3YXJkKGZvcndhcmQsIGRpcikgPyAxIDogLTEsIG5leHRTcGFuLmxldmVsKTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihuZXh0SW5kZXggKyBsaW5lLmZyb20sIHNwYW4uZm9yd2FyZChmb3J3YXJkLCBkaXIpID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbn1cbmZ1bmN0aW9uIGF1dG9EaXJlY3Rpb24odGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgbGV0IHR5cGUgPSBjaGFyVHlwZSh0ZXh0LmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICBpZiAodHlwZSA9PSAxIC8qIFQuTCAqLylcbiAgICAgICAgICAgIHJldHVybiBMVFI7XG4gICAgICAgIGlmICh0eXBlID09IDIgLyogVC5SICovIHx8IHR5cGUgPT0gNCAvKiBULkFMICovKVxuICAgICAgICAgICAgcmV0dXJuIFJUTDtcbiAgICB9XG4gICAgcmV0dXJuIExUUjtcbn1cblxuY29uc3QgY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBkcmFnTW92ZXNTZWxlY3Rpb24kMSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IG1vdXNlU2VsZWN0aW9uU3R5bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBleGNlcHRpb25TaW5rID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdXBkYXRlTGlzdGVuZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBpbnB1dEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBmb2N1c0NoYW5nZUVmZmVjdCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHBlckxpbmVUZXh0RGlyZWN0aW9uID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY29uc3QgbmF0aXZlU2VsZWN0aW9uSGlkZGVuID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY2xhc3MgU2Nyb2xsVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgeSA9IFwibmVhcmVzdFwiLCB4ID0gXCJuZWFyZXN0XCIsIHlNYXJnaW4gPSA1LCB4TWFyZ2luID0gNSwgXG4gICAgLy8gVGhpcyBkYXRhIHN0cnVjdHVyZSBpcyBhYnVzZWQgdG8gYWxzbyBzdG9yZSBwcmVjaXNlIHNjcm9sbFxuICAgIC8vIHNuYXBzaG90cywgaW5zdGVhZCBvZiBhIGBzY3JvbGxJbnRvVmlld2AgcmVxdWVzdC4gV2hlbiB0aGlzXG4gICAgLy8gZmxhZyBpcyBgdHJ1ZWAsIGByYW5nZWAgcG9pbnRzIGF0IGEgcG9zaXRpb24gaW4gdGhlIHJlZmVyZW5jZVxuICAgIC8vIGxpbmUsIGB5TWFyZ2luYCBob2xkcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhhdFxuICAgIC8vIGxpbmUgYW5kIHRoZSB0b3Agb2YgdGhlIGVkaXRvciwgYW5kIGB4TWFyZ2luYCBob2xkcyB0aGVcbiAgICAvLyBlZGl0b3IncyBgc2Nyb2xsTGVmdGAuXG4gICAgaXNTbmFwc2hvdCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55TWFyZ2luID0geU1hcmdpbjtcbiAgICAgICAgdGhpcy54TWFyZ2luID0geE1hcmdpbjtcbiAgICAgICAgdGhpcy5pc1NuYXBzaG90ID0gaXNTbmFwc2hvdDtcbiAgICB9XG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZW1wdHkgPyB0aGlzIDpcbiAgICAgICAgICAgIG5ldyBTY3JvbGxUYXJnZXQodGhpcy5yYW5nZS5tYXAoY2hhbmdlcyksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbiwgdGhpcy5pc1NuYXBzaG90KTtcbiAgICB9XG4gICAgY2xpcChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZS50byA8PSBzdGF0ZS5kb2MubGVuZ3RoID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgU2Nyb2xsVGFyZ2V0KEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhdGUuZG9jLmxlbmd0aCksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbiwgdGhpcy5pc1NuYXBzaG90KTtcbiAgICB9XG59XG5jb25zdCBzY3JvbGxJbnRvVmlldyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6ICh0LCBjaCkgPT4gdC5tYXAoY2gpIH0pO1xuLyoqXG5Mb2cgb3IgcmVwb3J0IGFuIHVuaGFuZGxlZCBleGNlcHRpb24gaW4gY2xpZW50IGNvZGUuIFNob3VsZFxucHJvYmFibHkgb25seSBiZSB1c2VkIGJ5IGV4dGVuc2lvbiBjb2RlIHRoYXQgYWxsb3dzIGNsaWVudCBjb2RlIHRvXG5wcm92aWRlIGZ1bmN0aW9ucywgYW5kIGNhbGxzIHRob3NlIGZ1bmN0aW9ucyBpbiBhIGNvbnRleHQgd2hlcmUgYW5cbmV4Y2VwdGlvbiBjYW4ndCBiZSBwcm9wYWdhdGVkIHRvIGNhbGxpbmcgY29kZSBpbiBhIHJlYXNvbmFibGUgd2F5XG4oZm9yIGV4YW1wbGUgd2hlbiBpbiBhbiBldmVudCBoYW5kbGVyKS5cblxuRWl0aGVyIGNhbGxzIGEgaGFuZGxlciByZWdpc3RlcmVkIHdpdGhcbltgRWRpdG9yVmlldy5leGNlcHRpb25TaW5rYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZXhjZXB0aW9uU2luayksXG5gd2luZG93Lm9uZXJyb3JgLCBpZiBkZWZpbmVkLCBvciBgY29uc29sZS5lcnJvcmAgKGluIHdoaWNoIGNhc2Vcbml0J2xsIHBhc3MgYGNvbnRleHRgLCB3aGVuIGdpdmVuLCBhcyBmaXJzdCBhcmd1bWVudCkuXG4qL1xuZnVuY3Rpb24gbG9nRXhjZXB0aW9uKHN0YXRlLCBleGNlcHRpb24sIGNvbnRleHQpIHtcbiAgICBsZXQgaGFuZGxlciA9IHN0YXRlLmZhY2V0KGV4Y2VwdGlvblNpbmspO1xuICAgIGlmIChoYW5kbGVyLmxlbmd0aClcbiAgICAgICAgaGFuZGxlclswXShleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKHdpbmRvdy5vbmVycm9yKVxuICAgICAgICB3aW5kb3cub25lcnJvcihTdHJpbmcoZXhjZXB0aW9uKSwgY29udGV4dCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4Y2VwdGlvbik7XG4gICAgZWxzZSBpZiAoY29udGV4dClcbiAgICAgICAgY29uc29sZS5lcnJvcihjb250ZXh0ICsgXCI6XCIsIGV4Y2VwdGlvbik7XG4gICAgZWxzZVxuICAgICAgICBjb25zb2xlLmVycm9yKGV4Y2VwdGlvbik7XG59XG5jb25zdCBlZGl0YWJsZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IHRydWUgfSk7XG5sZXQgbmV4dFBsdWdpbklEID0gMDtcbmNvbnN0IHZpZXdQbHVnaW4gPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblZpZXcgcGx1Z2lucyBhc3NvY2lhdGUgc3RhdGVmdWwgdmFsdWVzIHdpdGggYSB2aWV3LiBUaGV5IGNhblxuaW5mbHVlbmNlIHRoZSB3YXkgdGhlIGNvbnRlbnQgaXMgZHJhd24sIGFuZCBhcmUgbm90aWZpZWQgb2YgdGhpbmdzXG50aGF0IGhhcHBlbiBpbiB0aGUgdmlldy5cbiovXG5jbGFzcyBWaWV3UGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNyZWF0ZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21FdmVudEhhbmRsZXJzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbUV2ZW50T2JzZXJ2ZXJzLCBidWlsZEV4dGVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAgICAgdGhpcy5kb21FdmVudEhhbmRsZXJzID0gZG9tRXZlbnRIYW5kbGVycztcbiAgICAgICAgdGhpcy5kb21FdmVudE9ic2VydmVycyA9IGRvbUV2ZW50T2JzZXJ2ZXJzO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IGJ1aWxkRXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgcGx1Z2luIGZyb20gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlXG4gICAgcGx1Z2luJ3MgdmFsdWUsIGdpdmVuIGFuIGVkaXRvciB2aWV3LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjcmVhdGUsIHNwZWMpIHtcbiAgICAgICAgY29uc3QgeyBldmVudEhhbmRsZXJzLCBldmVudE9ic2VydmVycywgcHJvdmlkZSwgZGVjb3JhdGlvbnM6IGRlY28gfSA9IHNwZWMgfHwge307XG4gICAgICAgIHJldHVybiBuZXcgVmlld1BsdWdpbihuZXh0UGx1Z2luSUQrKywgY3JlYXRlLCBldmVudEhhbmRsZXJzLCBldmVudE9ic2VydmVycywgcGx1Z2luID0+IHtcbiAgICAgICAgICAgIGxldCBleHQgPSBbdmlld1BsdWdpbi5vZihwbHVnaW4pXTtcbiAgICAgICAgICAgIGlmIChkZWNvKVxuICAgICAgICAgICAgICAgIGV4dC5wdXNoKGRlY29yYXRpb25zLm9mKHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luSW5zdCA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5JbnN0ID8gZGVjbyhwbHVnaW5JbnN0KSA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZSlcbiAgICAgICAgICAgICAgICBleHQucHVzaChwcm92aWRlKHBsdWdpbikpO1xuICAgICAgICAgICAgcmV0dXJuIGV4dDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbiBmb3IgYSBjbGFzcyB3aG9zZSBjb25zdHJ1Y3RvciB0YWtlcyBhIHNpbmdsZVxuICAgIGVkaXRvciB2aWV3IGFzIGFyZ3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGZyb21DbGFzcyhjbHMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IGNscyh2aWV3KSwgc3BlYyk7XG4gICAgfVxufVxuY2xhc3MgUGx1Z2luSW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLy8gV2hlbiBzdGFydGluZyBhbiB1cGRhdGUsIGFsbCBwbHVnaW5zIGhhdmUgdGhpcyBmaWVsZCBzZXQgdG8gdGhlXG4gICAgICAgIC8vIHVwZGF0ZSBvYmplY3QsIGluZGljYXRpbmcgdGhleSBuZWVkIHRvIGJlIHVwZGF0ZWQuIFdoZW4gZmluaXNoZWRcbiAgICAgICAgLy8gdXBkYXRpbmcsIGl0IGlzIHNldCB0byBgZmFsc2VgLiBSZXRyaWV2aW5nIGEgcGx1Z2luIHRoYXQgbmVlZHMgdG9cbiAgICAgICAgLy8gYmUgdXBkYXRlZCB3aXRoIGB2aWV3LnBsdWdpbmAgZm9yY2VzIGFuIGVhZ2VyIHVwZGF0ZS5cbiAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgLy8gVGhpcyBpcyBudWxsIHdoZW4gdGhlIHBsdWdpbiBpcyBpbml0aWFsbHkgY3JlYXRlZCwgYnV0XG4gICAgICAgIC8vIGluaXRpYWxpemVkIG9uIHRoZSBmaXJzdCB1cGRhdGUuXG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICB1cGRhdGUodmlldykge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zcGVjLmNyZWF0ZSh2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubXVzdFVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZSA9IHRoaXMubXVzdFVwZGF0ZTtcbiAgICAgICAgICAgIHRoaXMubXVzdFVwZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZS51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odXBkYXRlLnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc3Ryb3kodmlldykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLnNwZWMgPSB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG59XG5jb25zdCBlZGl0b3JBdHRyaWJ1dGVzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgY29udGVudEF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vLyBQcm92aWRlIGRlY29yYXRpb25zXG5jb25zdCBkZWNvcmF0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IG91dGVyRGVjb3JhdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhdG9taWNSYW5nZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBiaWRpSXNvbGF0ZWRSYW5nZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5mdW5jdGlvbiBnZXRJc29sYXRlZFJhbmdlcyh2aWV3LCBsaW5lKSB7XG4gICAgbGV0IGlzb2xhdGVzID0gdmlldy5zdGF0ZS5mYWNldChiaWRpSXNvbGF0ZWRSYW5nZXMpO1xuICAgIGlmICghaXNvbGF0ZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gaXNvbGF0ZXM7XG4gICAgbGV0IHNldHMgPSBpc29sYXRlcy5tYXAoaSA9PiBpIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBpKHZpZXcpIDogaSk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIFJhbmdlU2V0LnNwYW5zKHNldHMsIGxpbmUuZnJvbSwgbGluZS50bywge1xuICAgICAgICBwb2ludCgpIHsgfSxcbiAgICAgICAgc3Bhbihmcm9tRG9jLCB0b0RvYywgYWN0aXZlLCBvcGVuKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGZyb21Eb2MgLSBsaW5lLmZyb20sIHRvID0gdG9Eb2MgLSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSByZXN1bHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tLCBvcGVuLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gYWN0aXZlW2ldLnNwZWMuYmlkaUlzb2xhdGUsIHVwZGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IGF1dG9EaXJlY3Rpb24obGluZS50ZXh0LCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW4gPiAwICYmIGxldmVsLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAodXBkYXRlID0gbGV2ZWxbbGV2ZWwubGVuZ3RoIC0gMV0pLnRvID09IGZyb20gJiYgdXBkYXRlLmRpcmVjdGlvbiA9PSBkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlLnRvID0gdG87XG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gdXBkYXRlLmlubmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZCA9IHsgZnJvbSwgdG8sIGRpcmVjdGlvbiwgaW5uZXI6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgIGxldmVsLnB1c2goYWRkKTtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSBhZGQuaW5uZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHNjcm9sbE1hcmdpbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5mdW5jdGlvbiBnZXRTY3JvbGxNYXJnaW5zKHZpZXcpIHtcbiAgICBsZXQgbGVmdCA9IDAsIHJpZ2h0ID0gMCwgdG9wID0gMCwgYm90dG9tID0gMDtcbiAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygdmlldy5zdGF0ZS5mYWNldChzY3JvbGxNYXJnaW5zKSkge1xuICAgICAgICBsZXQgbSA9IHNvdXJjZSh2aWV3KTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGlmIChtLmxlZnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgbS5sZWZ0KTtcbiAgICAgICAgICAgIGlmIChtLnJpZ2h0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgbS5yaWdodCk7XG4gICAgICAgICAgICBpZiAobS50b3AgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIG0udG9wKTtcbiAgICAgICAgICAgIGlmIChtLmJvdHRvbSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGJvdHRvbSwgbS5ib3R0b20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9O1xufVxuY29uc3Qgc3R5bGVNb2R1bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jbGFzcyBDaGFuZ2VkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpIHtcbiAgICAgICAgdGhpcy5mcm9tQSA9IGZyb21BO1xuICAgICAgICB0aGlzLnRvQSA9IHRvQTtcbiAgICAgICAgdGhpcy5mcm9tQiA9IGZyb21CO1xuICAgICAgICB0aGlzLnRvQiA9IHRvQjtcbiAgICB9XG4gICAgam9pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZWRSYW5nZShNYXRoLm1pbih0aGlzLmZyb21BLCBvdGhlci5mcm9tQSksIE1hdGgubWF4KHRoaXMudG9BLCBvdGhlci50b0EpLCBNYXRoLm1pbih0aGlzLmZyb21CLCBvdGhlci5mcm9tQiksIE1hdGgubWF4KHRoaXMudG9CLCBvdGhlci50b0IpKTtcbiAgICB9XG4gICAgYWRkVG9TZXQoc2V0KSB7XG4gICAgICAgIGxldCBpID0gc2V0Lmxlbmd0aCwgbWUgPSB0aGlzO1xuICAgICAgICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2V0W2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tQSA+IG1lLnRvQSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50b0EgPCBtZS5mcm9tQSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG1lID0gbWUuam9pbihyYW5nZSk7XG4gICAgICAgICAgICBzZXQuc3BsaWNlKGkgLSAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuc3BsaWNlKGksIDAsIG1lKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgc3RhdGljIGV4dGVuZFdpdGhSYW5nZXMoZGlmZiwgcmFuZ2VzKSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkSSA9IDAsIHJJID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwOzsgZEkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBkSSA9PSBkaWZmLmxlbmd0aCA/IG51bGwgOiBkaWZmW2RJXSwgb2ZmID0gcG9zQSAtIHBvc0I7XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbUIgOiAxZTk7XG4gICAgICAgICAgICB3aGlsZSAockkgPCByYW5nZXMubGVuZ3RoICYmIHJhbmdlc1tySV0gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tySV0sIHRvID0gcmFuZ2VzW3JJICsgMV07XG4gICAgICAgICAgICAgICAgbGV0IGZyb21CID0gTWF0aC5tYXgocG9zQiwgZnJvbSksIHRvQiA9IE1hdGgubWluKGVuZCwgdG8pO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQiA8PSB0b0IpXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUIgKyBvZmYsIHRvQiArIG9mZiwgZnJvbUIsIHRvQikuYWRkVG9TZXQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAodG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgckkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbmV3IENoYW5nZWRSYW5nZShuZXh0LmZyb21BLCBuZXh0LnRvQSwgbmV4dC5mcm9tQiwgbmV4dC50b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICBwb3NBID0gbmV4dC50b0E7XG4gICAgICAgICAgICBwb3NCID0gbmV4dC50b0I7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblZpZXcgW3BsdWdpbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKSBhcmUgZ2l2ZW4gaW5zdGFuY2VzIG9mIHRoaXNcbmNsYXNzLCB3aGljaCBkZXNjcmliZSB3aGF0IGhhcHBlbmVkLCB3aGVuZXZlciB0aGUgdmlldyBpcyB1cGRhdGVkLlxuKi9cbmNsYXNzIFZpZXdVcGRhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IgdmlldyB0aGF0IHRoZSB1cGRhdGUgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICovXG4gICAgdmlldywgXG4gICAgLyoqXG4gICAgVGhlIG5ldyBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVGhlIHRyYW5zYWN0aW9ucyBpbnZvbHZlZCBpbiB0aGUgdXBkYXRlLiBNYXkgYmUgZW1wdHkuXG4gICAgKi9cbiAgICB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZsYWdzID0gMDtcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gdGhpcy5jaGFuZ2VzLmNvbXBvc2UodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBjaGFuZ2VkUmFuZ2VzID0gW107XG4gICAgICAgIHRoaXMuY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gY2hhbmdlZFJhbmdlcy5wdXNoKG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikpKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkUmFuZ2VzID0gY2hhbmdlZFJhbmdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcsIHN0YXRlLCB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3VXBkYXRlKHZpZXcsIHN0YXRlLCB0cmFuc2FjdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgW3ZpZXdwb3J0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aWV3cG9ydCkgb3JcbiAgICBbdmlzaWJsZSByYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpc2libGVSYW5nZXMpIGNoYW5nZWQgaW4gdGhpc1xuICAgIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydENoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgaGVpZ2h0IG9mIGEgYmxvY2sgZWxlbWVudCBpbiB0aGUgZWRpdG9yXG4gICAgY2hhbmdlZCBpbiB0aGlzIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCBoZWlnaHRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCB3YXMgbW9kaWZpZWQgb3IgdGhlIHNpemUgb2YgdGhlXG4gICAgZWRpdG9yLCBvciBlbGVtZW50cyB3aXRoaW4gdGhlIGVkaXRvciwgY2hhbmdlZC5cbiAgICAqL1xuICAgIGdldCBnZW9tZXRyeUNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0NoYW5nZWQgfHwgKHRoaXMuZmxhZ3MgJiAoOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgdXBkYXRlIGluZGljYXRlcyBhIGZvY3VzIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBmb2N1c0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBkb2N1bWVudCBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgc2V0IGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZsYWdzID09IDAgJiYgdGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoID09IDA7IH1cbn1cblxuY2xhc3MgRG9jVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGg7IH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCA9IFtdO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZWQgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0NvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbiA9IG5ldyBTZXQ7XG4gICAgICAgIC8vIFRyYWNrIGEgbWluaW11bSB3aWR0aCBmb3IgdGhlIGVkaXRvci4gV2hlbiBtZWFzdXJpbmcgc2l6ZXMgaW5cbiAgICAgICAgLy8gbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cywgdGhpcyBpcyB1cGRhdGVkIHRvIHBvaW50IGF0IHRoZSB3aWR0aFxuICAgICAgICAvLyBvZiBhIGdpdmVuIGVsZW1lbnQgYW5kIGl0cyBleHRlbnQgaW4gdGhlIGRvY3VtZW50LiBXaGVuIGEgY2hhbmdlXG4gICAgICAgIC8vIGhhcHBlbnMgaW4gdGhhdCByYW5nZSwgdGhlc2UgYXJlIHJlc2V0LiBUaGF0IHdheSwgb25jZSB3ZSd2ZSBzZWVuXG4gICAgICAgIC8vIGEgbGluZS9lbGVtZW50IG9mIGEgZ2l2ZW4gbGVuZ3RoLCB3ZSBrZWVwIHRoZSBlZGl0b3Igd2lkZSBlbm91Z2hcbiAgICAgICAgLy8gdG8gZml0IGF0IGxlYXN0IHRoYXQgZWxlbWVudCwgdW50aWwgaXQgaXMgY2hhbmdlZCwgYXQgd2hpY2ggcG9pbnRcbiAgICAgICAgLy8gd2UgZm9yZ2V0IGl0IGFnYWluLlxuICAgICAgICB0aGlzLm1pbldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSAwO1xuICAgICAgICB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAvLyBUcmFjayB3aGV0aGVyIHRoZSBET00gc2VsZWN0aW9uIHdhcyBzZXQgaW4gYSBsb3NzeSB3YXksIHNvIHRoYXRcbiAgICAgICAgLy8gd2UgZG9uJ3QgbWVzcyBpdCB1cCB3aGVuIHJlYWRpbmcgaXQgYmFjayBpdFxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlSGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgcmVzaXplIG9ic2VydmVyIHRvIGlnbm9yZSByZXNpemVzIHRoYXQgd2UgY2F1c2VkXG4gICAgICAgIC8vIG91cnNlbHZlc1xuICAgICAgICB0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLnNldERPTSh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMaW5lVmlld107XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0uc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZURlY28oKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbm5lcihbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpXSwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8vIFVwZGF0ZSB0aGUgZG9jdW1lbnQgdmlldyB0byBhIGdpdmVuIHN0YXRlLlxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBpZiAodGhpcy5taW5XaWR0aCA+IDAgJiYgY2hhbmdlZFJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghY2hhbmdlZFJhbmdlcy5ldmVyeSgoeyBmcm9tQSwgdG9BIH0pID0+IHRvQSA8IHRoaXMubWluV2lkdGhGcm9tIHx8IGZyb21BID4gdGhpcy5taW5XaWR0aFRvKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSB0aGlzLm1pbldpZHRoRnJvbSA9IHRoaXMubWluV2lkdGhUbyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoRnJvbSA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoRnJvbSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhUbywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlYWRDb21wb3NpdGlvbkF0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCkge1xuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuZG9tQ2hhbmdlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5ld1NlbClcbiAgICAgICAgICAgICAgICByZWFkQ29tcG9zaXRpb25BdCA9IHRoaXMuZG9tQ2hhbmdlZC5uZXdTZWwuaGVhZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0b3VjaGVzQ29tcG9zaXRpb24odXBkYXRlLmNoYW5nZXMsIHRoaXMuaGFzQ29tcG9zaXRpb24pICYmICF1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgICAgIHJlYWRDb21wb3NpdGlvbkF0ID0gdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uID0gcmVhZENvbXBvc2l0aW9uQXQgPiAtMSA/IGZpbmRDb21wb3NpdGlvblJhbmdlKHRoaXMudmlldywgdXBkYXRlLmNoYW5nZXMsIHJlYWRDb21wb3NpdGlvbkF0KSA6IG51bGw7XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uLmNsZWFyKCk7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5oYXNDb21wb3NpdGlvbjtcbiAgICAgICAgICAgIGNoYW5nZWRSYW5nZXMgPSBuZXcgQ2hhbmdlZFJhbmdlKGZyb20sIHRvLCB1cGRhdGUuY2hhbmdlcy5tYXBQb3MoZnJvbSwgLTEpLCB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModG8sIDEpKVxuICAgICAgICAgICAgICAgIC5hZGRUb1NldChjaGFuZ2VkUmFuZ2VzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbiA/IHsgZnJvbTogY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIsIHRvOiBjb21wb3NpdGlvbi5yYW5nZS50b0IgfSA6IG51bGw7XG4gICAgICAgIC8vIFdoZW4gdGhlIERPTSBub2RlcyBhcm91bmQgdGhlIHNlbGVjdGlvbiBhcmUgbW92ZWQgdG8gYW5vdGhlclxuICAgICAgICAvLyBwYXJlbnQsIENocm9tZSBzb21ldGltZXMgcmVwb3J0cyBhIGRpZmZlcmVudCBzZWxlY3Rpb24gdGhyb3VnaFxuICAgICAgICAvLyBnZXRTZWxlY3Rpb24gdGhhbiB0aGUgb25lIHRoYXQgaXQgYWN0dWFsbHkgc2hvd3MgdG8gdGhlIHVzZXIuXG4gICAgICAgIC8vIFRoaXMgZm9yY2VzIGEgc2VsZWN0aW9uIHVwZGF0ZSB3aGVuIGxpbmVzIGFyZSBqb2luZWQgdG8gd29ya1xuICAgICAgICAvLyBhcm91bmQgdGhhdC4gSXNzdWUgIzU0XG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSB8fCBicm93c2VyLmNocm9tZSkgJiYgIWNvbXBvc2l0aW9uICYmIHVwZGF0ZSAmJlxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLmRvYy5saW5lcyAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGluZXMpXG4gICAgICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5kZWNvcmF0aW9ucywgZGVjbyA9IHRoaXMudXBkYXRlRGVjbygpO1xuICAgICAgICBsZXQgZGVjb0RpZmYgPSBmaW5kQ2hhbmdlZERlY28ocHJldkRlY28sIGRlY28sIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgY2hhbmdlZFJhbmdlcyA9IENoYW5nZWRSYW5nZS5leHRlbmRXaXRoUmFuZ2VzKGNoYW5nZWRSYW5nZXMsIGRlY29EaWZmKTtcbiAgICAgICAgaWYgKCEodGhpcy5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIoY2hhbmdlZFJhbmdlcywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCwgY29tcG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2VkIGJ5IHVwZGF0ZSBhbmQgdGhlIGNvbnN0cnVjdG9yIGRvIHBlcmZvcm0gdGhlIGFjdHVhbCBET01cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVJbm5lcihjaGFuZ2VzLCBvbGRMZW5ndGgsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihjaGFuZ2VzLCBvbGRMZW5ndGgsIGNvbXBvc2l0aW9uKTtcbiAgICAgICAgbGV0IHsgb2JzZXJ2ZXIgfSA9IHRoaXMudmlldztcbiAgICAgICAgb2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIC8vIExvY2sgdGhlIGhlaWdodCBkdXJpbmcgcmVkcmF3aW5nLCBzaW5jZSBDaHJvbWUgc29tZXRpbWVzXG4gICAgICAgICAgICAvLyBtZXNzZXMgd2l0aCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBET00gbXV0YXRpb24gKHRob3VnaFxuICAgICAgICAgICAgLy8gbm8gcmVsYXlvdXQgaXMgdHJpZ2dlcmVkIGFuZCBJIGNhbm5vdCBpbWFnaW5lIGhvdyBpdCBjYW5cbiAgICAgICAgICAgIC8vIHJlY29tcHV0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBsYXlvdXQpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSB0aGlzLnZpZXcudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuZmxleEJhc2lzID0gdGhpcy5taW5XaWR0aCA/IHRoaXMubWluV2lkdGggKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzLCB3aGVuIERPTSBtdXRhdGlvbnMgb2NjdXIgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGFyb3VuZCB0aGUgc2VsZWN0aW9uLCBnZXQgY29uZnVzZWQgYW5kIHJlcG9ydCBhIGRpZmZlcmVudFxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGZyb20gdGhlIG9uZSBpdCBkaXNwbGF5cyAoaXNzdWUgIzIxOCkuIFRoaXMgdHJpZXNcbiAgICAgICAgICAgIC8vIHRvIGRldGVjdCB0aGF0IHNpdHVhdGlvbi5cbiAgICAgICAgICAgIGxldCB0cmFjayA9IGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuaW9zID8geyBub2RlOiBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUsIHdyaXR0ZW46IGZhbHNlIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN5bmModGhpcy52aWV3LCB0cmFjayk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzICY9IH43IC8qIFZpZXdGbGFnLkRpcnR5ICovO1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmICh0cmFjay53cml0dGVuIHx8IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSAhPSB0cmFjay5ub2RlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uLmZvckVhY2goY1ZpZXcgPT4gY1ZpZXcuZmxhZ3MgJj0gfjggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgICAgICBsZXQgZ2FwcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdwb3J0LmZyb20gfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvIDwgdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBjaGlsZC53aWRnZXQgaW5zdGFuY2VvZiBCbG9ja0dhcFdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgZ2Fwcy5wdXNoKGNoaWxkLmRvbSk7XG4gICAgICAgIG9ic2VydmVyLnVwZGF0ZUdhcHMoZ2Fwcyk7XG4gICAgfVxuICAgIHVwZGF0ZUNoaWxkcmVuKGNoYW5nZXMsIG9sZExlbmd0aCwgY29tcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IGNvbXBvc2l0aW9uID8gY29tcG9zaXRpb24ucmFuZ2UuYWRkVG9TZXQoY2hhbmdlcy5zbGljZSgpKSA6IGNoYW5nZXM7XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmNoaWxkQ3Vyc29yKG9sZExlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSByYW5nZXMubGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID49IDAgPyByYW5nZXNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9ID0gbmV4dCwgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQ7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIgPCB0b0IgJiYgY29tcG9zaXRpb24ucmFuZ2UudG9CID4gZnJvbUIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgZnJvbUIsIGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCB0aGlzLmRlY29yYXRpb25zLCB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBDb250ZW50QnVpbGRlci5idWlsZCh0aGlzLnZpZXcuc3RhdGUuZG9jLCBjb21wb3NpdGlvbi5yYW5nZS50b0IsIHRvQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgICAgICAgICAgYnJlYWtBdFN0YXJ0ID0gYmVmb3JlLmJyZWFrQXRTdGFydDtcbiAgICAgICAgICAgICAgICBvcGVuU3RhcnQgPSBiZWZvcmUub3BlblN0YXJ0O1xuICAgICAgICAgICAgICAgIG9wZW5FbmQgPSBhZnRlci5vcGVuRW5kO1xuICAgICAgICAgICAgICAgIGxldCBjb21wTGluZSA9IHRoaXMuY29tcG9zaXRpb25WaWV3KGNvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIuYnJlYWtBdFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZnRlci5jb250ZW50Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5tZXJnZShjb21wTGluZS5sZW5ndGgsIGNvbXBMaW5lLmxlbmd0aCwgYWZ0ZXIuY29udGVudFswXSwgZmFsc2UsIGFmdGVyLm9wZW5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUuYnJlYWtBZnRlciA9IGFmdGVyLmNvbnRlbnRbMF0uYnJlYWtBZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIuY29udGVudC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLmNvbnRlbnQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLm1lcmdlKDAsIDAsIGJlZm9yZS5jb250ZW50W2JlZm9yZS5jb250ZW50Lmxlbmd0aCAtIDFdLCB0cnVlLCAwLCBiZWZvcmUub3BlbkVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlLmNvbnRlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBiZWZvcmUuY29udGVudC5jb25jYXQoY29tcExpbmUpLmNvbmNhdChhZnRlci5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICh7IGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPVxuICAgICAgICAgICAgICAgICAgICBDb250ZW50QnVpbGRlci5idWlsZCh0aGlzLnZpZXcuc3RhdGUuZG9jLCBmcm9tQiwgdG9CLCB0aGlzLmRlY29yYXRpb25zLCB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1cnNvci5maW5kUG9zKHRvQSwgMSk7XG4gICAgICAgICAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyhmcm9tQSwgLTEpO1xuICAgICAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvc2l0aW9uKVxuICAgICAgICAgICAgdGhpcy5maXhDb21wb3NpdGlvbkRPTShjb21wb3NpdGlvbik7XG4gICAgfVxuICAgIGNvbXBvc2l0aW9uVmlldyhjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgY3VyID0gbmV3IFRleHRWaWV3KGNvbXBvc2l0aW9uLnRleHQubm9kZVZhbHVlKTtcbiAgICAgICAgY3VyLmZsYWdzIHw9IDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi87XG4gICAgICAgIGZvciAobGV0IHsgZGVjbyB9IG9mIGNvbXBvc2l0aW9uLm1hcmtzKVxuICAgICAgICAgICAgY3VyID0gbmV3IE1hcmtWaWV3KGRlY28sIFtjdXJdLCBjdXIubGVuZ3RoKTtcbiAgICAgICAgbGV0IGxpbmUgPSBuZXcgTGluZVZpZXc7XG4gICAgICAgIGxpbmUuYXBwZW5kKGN1ciwgMCk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBmaXhDb21wb3NpdGlvbkRPTShjb21wb3NpdGlvbikge1xuICAgICAgICBsZXQgZml4ID0gKGRvbSwgY1ZpZXcpID0+IHtcbiAgICAgICAgICAgIGNWaWV3LmZsYWdzIHw9IDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8gfCAoY1ZpZXcuY2hpbGRyZW4uc29tZShjID0+IGMuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSA/IDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLyA6IDApO1xuICAgICAgICAgICAgdGhpcy5tYXJrZWRGb3JDb21wb3NpdGlvbi5hZGQoY1ZpZXcpO1xuICAgICAgICAgICAgbGV0IHByZXYgPSBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYgIT0gY1ZpZXcpXG4gICAgICAgICAgICAgICAgcHJldi5kb20gPSBudWxsO1xuICAgICAgICAgICAgY1ZpZXcuc2V0RE9NKGRvbSk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmNoaWxkUG9zKGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCAxKTtcbiAgICAgICAgbGV0IGNWaWV3ID0gdGhpcy5jaGlsZHJlbltwb3MuaV07XG4gICAgICAgIGZpeChjb21wb3NpdGlvbi5saW5lLCBjVmlldyk7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb21wb3NpdGlvbi5tYXJrcy5sZW5ndGggLSAxOyBpID49IC0xOyBpLS0pIHtcbiAgICAgICAgICAgIHBvcyA9IGNWaWV3LmNoaWxkUG9zKHBvcy5vZmYsIDEpO1xuICAgICAgICAgICAgY1ZpZXcgPSBjVmlldy5jaGlsZHJlbltwb3MuaV07XG4gICAgICAgICAgICBmaXgoaSA+PSAwID8gY29tcG9zaXRpb24ubWFya3NbaV0ubm9kZSA6IGNvbXBvc2l0aW9uLnRleHQsIGNWaWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBET00gc2VsZWN0aW9uIHRvIHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgdXBkYXRlU2VsZWN0aW9uKG11c3RSZWFkID0gZmFsc2UsIGZyb21Qb2ludGVyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG11c3RSZWFkIHx8ICF0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgYWN0aXZlRWx0ID0gdGhpcy52aWV3LnJvb3QuYWN0aXZlRWxlbWVudCwgZm9jdXNlZCA9IGFjdGl2ZUVsdCA9PSB0aGlzLmRvbTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbk5vdEZvY3VzID0gIWZvY3VzZWQgJiZcbiAgICAgICAgICAgIGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlKSAmJiAhKGFjdGl2ZUVsdCAmJiB0aGlzLmRvbS5jb250YWlucyhhY3RpdmVFbHQpKTtcbiAgICAgICAgaWYgKCEoZm9jdXNlZCB8fCBmcm9tUG9pbnRlciB8fCBzZWxlY3Rpb25Ob3RGb2N1cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBmb3JjZSA9IHRoaXMuZm9yY2VTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIGxldCBhbmNob3IgPSB0aGlzLm1vdmVUb0xpbmUodGhpcy5kb21BdFBvcyhtYWluLmFuY2hvcikpO1xuICAgICAgICBsZXQgaGVhZCA9IG1haW4uZW1wdHkgPyBhbmNob3IgOiB0aGlzLm1vdmVUb0xpbmUodGhpcy5kb21BdFBvcyhtYWluLmhlYWQpKTtcbiAgICAgICAgLy8gQWx3YXlzIHJlc2V0IG9uIEZpcmVmb3ggd2hlbiBuZXh0IHRvIGFuIHVuZWRpdGFibGUgbm9kZSB0b1xuICAgICAgICAvLyBhdm9pZCBpbnZpc2libGUgY3Vyc29yIGJ1Z3MgKCMxMTEpXG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvICYmIG1haW4uZW1wdHkgJiYgIXRoaXMuaGFzQ29tcG9zaXRpb24gJiYgYmV0d2VlblVuZWRpdGFibGUoYW5jaG9yKSkge1xuICAgICAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IGFuY2hvci5ub2RlLmluc2VydEJlZm9yZShkdW1teSwgYW5jaG9yLm5vZGUuY2hpbGROb2Rlc1thbmNob3Iub2Zmc2V0XSB8fCBudWxsKSk7XG4gICAgICAgICAgICBhbmNob3IgPSBoZWFkID0gbmV3IERPTVBvcyhkdW1teSwgMCk7XG4gICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvbVNlbCA9IHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGhlcmUsIG9yIGluIGFuIGVxdWl2YWxlbnQgcG9zaXRpb24sIGRvbid0IHRvdWNoIGl0XG4gICAgICAgIGlmIChmb3JjZSB8fCAhZG9tU2VsLmZvY3VzTm9kZSB8fCAoIWlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgfHxcbiAgICAgICAgICAgICFpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkLm5vZGUsIGhlYWQub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKSAmJiAhdGhpcy5zdXBwcmVzc1dpZGdldEN1cnNvckNoYW5nZShkb21TZWwsIG1haW4pKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIGhpZGUgdGhlIHZpcnR1YWwga2V5Ym9hcmQgd2hlbiB0YXBwaW5nXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIHVuZWRpdGFibGUgbm9kZSwgYW5kIG5vdCBicmluZyBpdCBiYWNrIHdoZW4gd2VcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgdG8gaXRzIHByb3BlciBwb3NpdGlvbi4gVGhpcyB0cmllcyB0b1xuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGtleWJvYXJkIGJ5IGN5Y2xpbmcgZm9jdXMuXG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiB0aGlzLmRvbS5jb250YWlucyhkb21TZWwuZm9jdXNOb2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICBpblVuZWRpdGFibGUoZG9tU2VsLmZvY3VzTm9kZSwgdGhpcy5kb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmF3U2VsID0gZ2V0U2VsZWN0aW9uKHRoaXMudmlldy5yb290KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1NlbCkgO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1haW4uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYxMjA3NlxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRUbyA9IG5leHRUb1VuZWRpdGFibGUoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUbyAmJiBuZXh0VG8gIT0gKDEgLyogTmV4dFRvLkJlZm9yZSAqLyB8IDIgLyogTmV4dFRvLkFmdGVyICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbmVhcmJ5VGV4dE5vZGUoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIG5leHRUbyA9PSAxIC8qIE5leHRUby5CZWZvcmUgKi8gPyAxIDogLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXcgRE9NUG9zKHRleHQubm9kZSwgdGV4dC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYWluLmJpZGlMZXZlbCAhPSBudWxsICYmIHJhd1NlbC5jYXJldEJpZGlMZXZlbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNhcmV0QmlkaUxldmVsID0gbWFpbi5iaWRpTGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhd1NlbC5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0aW9uLmV4dGVuZCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gJ2ludmVydGVkJyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxuICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IGl0IHlldC5cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIHdpbGwgaWdub3JlIHRoZSBjYWxsIGFib3ZlIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBoaWRkZW4sIGFuZCB0aGVuIHJhaXNlIGFuIGVycm9yIG9uIHRoZSBjYWxsIHRvIGV4dGVuZFxuICAgICAgICAgICAgICAgICAgICAvLyAoIzk0MCkuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdTZWwuZXh0ZW5kKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW1pdGl2ZSAoSUUpIHdheVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbi5hbmNob3IgPiBtYWluLmhlYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBbYW5jaG9yLCBoZWFkXSA9IFtoZWFkLCBhbmNob3JdO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uTm90Rm9jdXMgJiYgdGhpcy52aWV3LnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFbHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVFbHQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5zZXRTZWxlY3Rpb25SYW5nZShhbmNob3IsIGhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlQW5jaG9yID0gYW5jaG9yLnByZWNpc2UgPyBudWxsIDogbmV3IERPTVBvcyhkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgIHRoaXMuaW1wcmVjaXNlSGVhZCA9IGhlYWQucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gICAgfVxuICAgIC8vIElmIGEgemVyby1sZW5ndGggd2lkZ2V0IGlzIGluc2VydGVkIG5leHQgdG8gdGhlIGN1cnNvciBkdXJpbmdcbiAgICAvLyBjb21wb3NpdGlvbiwgYXZvaWQgbW92aW5nIGl0IGFjcm9zcyBpdCBhbmQgZGlzcnVwdGluZyB0aGVcbiAgICAvLyBjb21wb3NpdGlvbi5cbiAgICBzdXBwcmVzc1dpZGdldEN1cnNvckNoYW5nZShzZWwsIGN1cnNvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNDb21wb3NpdGlvbiAmJiBjdXJzb3IuZW1wdHkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpICYmXG4gICAgICAgICAgICB0aGlzLnBvc0Zyb21ET00oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KSA9PSBjdXJzb3IuaGVhZDtcbiAgICB9XG4gICAgZW5mb3JjZUN1cnNvckFzc29jKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wb3NpdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgY3Vyc29yID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih2aWV3LnJvb3QpO1xuICAgICAgICBsZXQgeyBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQgfSA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICghc2VsIHx8ICFjdXJzb3IuZW1wdHkgfHwgIWN1cnNvci5hc3NvYyB8fCAhc2VsLm1vZGlmeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHRoaXMsIGN1cnNvci5oZWFkKTtcbiAgICAgICAgaWYgKCFsaW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZVN0YXJ0ID0gbGluZS5wb3NBdFN0YXJ0O1xuICAgICAgICBpZiAoY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0IHx8IGN1cnNvci5oZWFkID09IGxpbmVTdGFydCArIGxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgYmVmb3JlID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgLTEpLCBhZnRlciA9IHRoaXMuY29vcmRzQXQoY3Vyc29yLmhlYWQsIDEpO1xuICAgICAgICBpZiAoIWJlZm9yZSB8fCAhYWZ0ZXIgfHwgYmVmb3JlLmJvdHRvbSA+IGFmdGVyLnRvcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuZG9tQXRQb3MoY3Vyc29yLmhlYWQgKyBjdXJzb3IuYXNzb2MpO1xuICAgICAgICBzZWwuY29sbGFwc2UoZG9tLm5vZGUsIGRvbS5vZmZzZXQpO1xuICAgICAgICBzZWwubW9kaWZ5KFwibW92ZVwiLCBjdXJzb3IuYXNzb2MgPCAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIsIFwibGluZWJvdW5kYXJ5XCIpO1xuICAgICAgICAvLyBUaGlzIGNhbiBnbyB3cm9uZyBpbiBjb3JuZXIgY2FzZXMgbGlrZSBzaW5nbGUtY2hhcmFjdGVyIGxpbmVzLFxuICAgICAgICAvLyBzbyBjaGVjayBhbmQgcmVzZXQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICB2aWV3Lm9ic2VydmVyLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgbmV3UmFuZ2UgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAodmlldy5kb2NWaWV3LnBvc0Zyb21ET00obmV3UmFuZ2UuYW5jaG9yTm9kZSwgbmV3UmFuZ2UuYW5jaG9yT2Zmc2V0KSAhPSBjdXJzb3IuZnJvbSlcbiAgICAgICAgICAgIHNlbC5jb2xsYXBzZShhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICAgIH1cbiAgICAvLyBJZiBhIHBvc2l0aW9uIGlzIGluL25lYXIgYSBibG9jayB3aWRnZXQsIG1vdmUgaXQgdG8gYSBuZWFyYnkgdGV4dFxuICAgIC8vIGxpbmUsIHNpbmNlIHdlIGRvbid0IHdhbnQgdGhlIGN1cnNvciBpbnNpZGUgYSBibG9jayB3aWRnZXQuXG4gICAgbW92ZVRvTGluZShwb3MpIHtcbiAgICAgICAgLy8gQmxvY2sgd2lkZ2V0cyB3aWxsIHJldHVybiBwb3NpdGlvbnMgYmVmb3JlL2FmdGVyIHRoZW0sIHdoaWNoXG4gICAgICAgIC8vIGFyZSB0aHVzIGRpcmVjdGx5IGluIHRoZSBkb2N1bWVudCBET00gZWxlbWVudC5cbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuZG9tLCBuZXdQb3M7XG4gICAgICAgIGlmIChwb3Mubm9kZSAhPSBkb20pXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zLm9mZnNldDsgIW5ld1BvcyAmJiBpIDwgZG9tLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KGRvbS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgIGlmICh2aWV3IGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgbmV3UG9zID0gdmlldy5kb21BdFBvcygwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gcG9zLm9mZnNldCAtIDE7ICFuZXdQb3MgJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KGRvbS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgIGlmICh2aWV3IGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgbmV3UG9zID0gdmlldy5kb21BdFBvcyh2aWV3Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1BvcyA/IG5ldyBET01Qb3MobmV3UG9zLm5vZGUsIG5ld1Bvcy5vZmZzZXQsIHRydWUpIDogcG9zO1xuICAgIH1cbiAgICBuZWFyZXN0KGRvbSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjspIHtcbiAgICAgICAgICAgIGxldCBkb21WaWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1cik7XG4gICAgICAgICAgICBpZiAoZG9tVmlldyAmJiBkb21WaWV3LnJvb3RWaWV3ID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbVZpZXc7XG4gICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5lYXJlc3Qobm9kZSk7XG4gICAgICAgIGlmICghdmlldylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGZpbmQgcG9zaXRpb24gZm9yIGEgRE9NIHBvc2l0aW9uIG91dHNpZGUgb2YgdGhlIGRvY3VtZW50XCIpO1xuICAgICAgICByZXR1cm4gdmlldy5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSArIHZpZXcucG9zQXRTdGFydDtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCAtMSk7XG4gICAgICAgIGZvciAoOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChvZmYgPCBjaGlsZC5sZW5ndGggfHwgY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIG9mZiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV0uZG9tQXRQb3Mob2ZmKTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCBiZXN0ID0gbnVsbCwgYmVzdFBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRoaXMubGVuZ3RoLCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmIC0gY2hpbGQuYnJlYWtBZnRlciwgc3RhcnQgPSBlbmQgLSBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kIDwgcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDw9IHBvcyAmJiAoc3RhcnQgPCBwb3MgfHwgY2hpbGQuY292ZXJzKC0xKSkgJiYgKGVuZCA+IHBvcyB8fCBjaGlsZC5jb3ZlcnMoMSkpICYmXG4gICAgICAgICAgICAgICAgKCFiZXN0IHx8IGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcgJiYgIShiZXN0IGluc3RhbmNlb2YgTGluZVZpZXcgJiYgc2lkZSA+PSAwKSkpIHtcbiAgICAgICAgICAgICAgICBiZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgYmVzdFBvcyA9IHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3QgPyBiZXN0LmNvb3Jkc0F0KHBvcyAtIGJlc3RQb3MsIHNpZGUpIDogbnVsbDtcbiAgICB9XG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKHBvcywgMSksIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgaSwgb2ZmOiBjaGlsZE9mZiB9ID0gY2hpbGQuY2hpbGRQb3Mob2ZmLCAxKTtcbiAgICAgICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoKGNoaWxkID0gY2hpbGQuY2hpbGRyZW5baV0pLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBjaGlsZE9mZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIFRleHRWaWV3KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZW5kID0gZmluZENsdXN0ZXJCcmVhayhjaGlsZC50ZXh0LCBvZmYpO1xuICAgICAgICBpZiAoZW5kID09IG9mZilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UoY2hpbGQuZG9tLCBvZmYsIGVuZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSAmJiByZWN0LmxlZnQgPCByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZpZXdwb3J0KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgeyBmcm9tLCB0byB9ID0gdmlld3BvcnQ7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSB0aGlzLnZpZXcuY29udGVudERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgbGV0IGlzV2lkZXIgPSBjb250ZW50V2lkdGggPiBNYXRoLm1heCh0aGlzLnZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB0aGlzLm1pbldpZHRoKSArIDE7XG4gICAgICAgIGxldCB3aWRlc3QgPSAtMSwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRSZWN0ID0gY2hpbGQuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1dpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gY2hpbGQuZG9tLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RzID0gbGFzdCA/IGNsaWVudFJlY3RzRm9yKGxhc3QpIDogW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSBsdHIgPyByZWN0LnJpZ2h0IC0gY2hpbGRSZWN0LmxlZnQgOiBjaGlsZFJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPiB3aWRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRlc3QgPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgeyBpIH0gPSB0aGlzLmNoaWxkUG9zKHBvcywgMSk7XG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuY2hpbGRyZW5baV0uZG9tKS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IERpcmVjdGlvbi5SVEwgOiBEaXJlY3Rpb24uTFRSO1xuICAgIH1cbiAgICBtZWFzdXJlVGV4dFNpemUoKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmUgPSBjaGlsZC5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVhc3VyZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gd29ya2FibGUgbGluZSBleGlzdHMsIGZvcmNlIGEgbGF5b3V0IG9mIGEgbWVhc3VyYWJsZSBlbGVtZW50XG4gICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodDtcbiAgICAgICAgZHVtbXkuY2xhc3NOYW1lID0gXCJjbS1saW5lXCI7XG4gICAgICAgIGR1bW15LnN0eWxlLndpZHRoID0gXCI5OTk5OXB4XCI7XG4gICAgICAgIGR1bW15LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBkdW1teS50ZXh0Q29udGVudCA9IFwiYWJjIGRlZiBnaGkgamtsIG1ubyBwcXIgc3R1XCI7XG4gICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZHVtbXkpO1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBjbGllbnRSZWN0c0ZvcihkdW1teS5maXJzdENoaWxkKVswXTtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBkdW1teS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICBjaGFyV2lkdGggPSByZWN0ID8gcmVjdC53aWR0aCAvIDI3IDogNztcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSByZWN0ID8gcmVjdC5oZWlnaHQgOiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgZHVtbXkucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQgfTtcbiAgICB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTW92ZSBiYWNrIHRvIHN0YXJ0IG9mIGxhc3QgZWxlbWVudCB3aGVuIHBvc3NpYmxlLCBzbyB0aGF0XG4gICAgICAgIC8vIGBDaGlsZEN1cnNvci5maW5kUG9zYCBkb2Vzbid0IGhhdmUgdG8gZGVhbCB3aXRoIHRoZSBlZGdlIGNhc2VcbiAgICAgICAgLy8gb2YgYmVpbmcgYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudC5cbiAgICAgICAgbGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICBwb3MgLT0gdGhpcy5jaGlsZHJlblstLWldLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIGkpO1xuICAgIH1cbiAgICBjb21wdXRlQmxvY2tHYXBEZWNvKCkge1xuICAgICAgICBsZXQgZGVjbyA9IFtdLCB2cyA9IHRoaXMudmlldy52aWV3U3RhdGU7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gdnMudmlld3BvcnRzLmxlbmd0aCA/IG51bGwgOiB2cy52aWV3cG9ydHNbaV07XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbSAtIDEgOiB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gKHZzLmxpbmVCbG9ja0F0KGVuZCkuYm90dG9tIC0gdnMubGluZUJsb2NrQXQocG9zKS50b3ApIC8gdGhpcy52aWV3LnNjYWxlWTtcbiAgICAgICAgICAgICAgICBkZWNvLnB1c2goRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgQmxvY2tHYXBXaWRnZXQoaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNCbG9ja0dhcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KS5yYW5nZShwb3MsIGVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dC50byArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbiAgICB1cGRhdGVEZWNvKCkge1xuICAgICAgICBsZXQgYWxsRGVjbyA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucykubWFwKChkLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgZHluYW1pYyA9IHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXBbaV0gPSB0eXBlb2YgZCA9PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pYyA/IGQodGhpcy52aWV3KSA6IGQ7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgZHluYW1pY091dGVyID0gZmFsc2UsIG91dGVyRGVjbyA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChvdXRlckRlY29yYXRpb25zKS5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBkeW5hbWljID0gdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgaWYgKGR5bmFtaWMpXG4gICAgICAgICAgICAgICAgZHluYW1pY091dGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljID8gZCh0aGlzLnZpZXcpIDogZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvdXRlckRlY28ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2FsbERlY28ubGVuZ3RoXSA9IGR5bmFtaWNPdXRlcjtcbiAgICAgICAgICAgIGFsbERlY28ucHVzaChSYW5nZVNldC5qb2luKG91dGVyRGVjbykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBhbGxEZWNvLmxlbmd0aDsgaSA8IGFsbERlY28ubGVuZ3RoICsgMzsgaSsrKVxuICAgICAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9ucyA9IFtcbiAgICAgICAgICAgIC4uLmFsbERlY28sXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVCbG9ja0dhcERlY28oKSxcbiAgICAgICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubGluZUdhcERlY29cbiAgICAgICAgXTtcbiAgICB9XG4gICAgc2Nyb2xsSW50b1ZpZXcodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQuaXNTbmFwc2hvdCkge1xuICAgICAgICAgICAgbGV0IHJlZiA9IHRoaXMudmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQodGFyZ2V0LnJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSByZWYudG9wIC0gdGFyZ2V0LnlNYXJnaW47XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB0YXJnZXQueE1hcmdpbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyByYW5nZSB9ID0gdGFyZ2V0O1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuY29vcmRzQXQocmFuZ2UuaGVhZCwgcmFuZ2UuZW1wdHkgPyByYW5nZS5hc3NvYyA6IHJhbmdlLmhlYWQgPiByYW5nZS5hbmNob3IgPyAtMSA6IDEpLCBvdGhlcjtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5ICYmIChvdGhlciA9IHRoaXMuY29vcmRzQXQocmFuZ2UuYW5jaG9yLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gLTEgOiAxKSkpXG4gICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBNYXRoLm1pbihyZWN0LmxlZnQsIG90aGVyLmxlZnQpLCB0b3A6IE1hdGgubWluKHJlY3QudG9wLCBvdGhlci50b3ApLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChyZWN0LnJpZ2h0LCBvdGhlci5yaWdodCksIGJvdHRvbTogTWF0aC5tYXgocmVjdC5ib3R0b20sIG90aGVyLmJvdHRvbSkgfTtcbiAgICAgICAgbGV0IG1hcmdpbnMgPSBnZXRTY3JvbGxNYXJnaW5zKHRoaXMudmlldyk7XG4gICAgICAgIGxldCB0YXJnZXRSZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gbWFyZ2lucy5sZWZ0LCB0b3A6IHJlY3QudG9wIC0gbWFyZ2lucy50b3AsXG4gICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCArIG1hcmdpbnMucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gKyBtYXJnaW5zLmJvdHRvbVxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0IH0gPSB0aGlzLnZpZXcuc2Nyb2xsRE9NO1xuICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcy52aWV3LnNjcm9sbERPTSwgdGFyZ2V0UmVjdCwgcmFuZ2UuaGVhZCA8IHJhbmdlLmFuY2hvciA/IC0xIDogMSwgdGFyZ2V0LngsIHRhcmdldC55LCBNYXRoLm1heChNYXRoLm1pbih0YXJnZXQueE1hcmdpbiwgb2Zmc2V0V2lkdGgpLCAtb2Zmc2V0V2lkdGgpLCBNYXRoLm1heChNYXRoLm1pbih0YXJnZXQueU1hcmdpbiwgb2Zmc2V0SGVpZ2h0KSwgLW9mZnNldEhlaWdodCksIHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJldHdlZW5VbmVkaXRhYmxlKHBvcykge1xuICAgIHJldHVybiBwb3Mubm9kZS5ub2RlVHlwZSA9PSAxICYmIHBvcy5ub2RlLmZpcnN0Q2hpbGQgJiZcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gMCB8fCBwb3Mubm9kZS5jaGlsZE5vZGVzW3Bvcy5vZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSBwb3Mubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCB8fCBwb3Mubm9kZS5jaGlsZE5vZGVzW3Bvcy5vZmZzZXRdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xufVxuY2xhc3MgQmxvY2tHYXBXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IFwiY20tZ2FwXCI7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5oZWlnaHQgPT0gdGhpcy5oZWlnaHQ7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBlZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5oZWlnaHQ7IH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcsIGhlYWRQb3MpIHtcbiAgICBsZXQgc2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBsZXQgdGV4dE5vZGUgPSBzZWwuZm9jdXNOb2RlICYmIG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgMCk7XG4gICAgaWYgKCF0ZXh0Tm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZyb20gPSBoZWFkUG9zIC0gdGV4dE5vZGUub2Zmc2V0O1xuICAgIHJldHVybiB7IGZyb20sIHRvOiBmcm9tICsgdGV4dE5vZGUubm9kZS5ub2RlVmFsdWUubGVuZ3RoLCBub2RlOiB0ZXh0Tm9kZS5ub2RlIH07XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25SYW5nZSh2aWV3LCBjaGFuZ2VzLCBoZWFkUG9zKSB7XG4gICAgbGV0IGZvdW5kID0gZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBoZWFkUG9zKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBub2RlOiB0ZXh0Tm9kZSwgZnJvbSwgdG8gfSA9IGZvdW5kLCB0ZXh0ID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgIC8vIERvbid0IHRyeSB0byBwcmVzZXJ2ZSBtdWx0aS1saW5lIGNvbXBvc2l0aW9uc1xuICAgIGlmICgvW1xcblxccl0vLnRlc3QodGV4dCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhmb3VuZC5mcm9tLCBmb3VuZC50bykgIT0gdGV4dClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGludiA9IGNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgIGxldCByYW5nZSA9IG5ldyBDaGFuZ2VkUmFuZ2UoaW52Lm1hcFBvcyhmcm9tKSwgaW52Lm1hcFBvcyh0byksIGZyb20sIHRvKTtcbiAgICBsZXQgbWFya3MgPSBbXTtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlOzsgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgbGV0IHBhcmVudFZpZXcgPSBDb250ZW50Vmlldy5nZXQocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudFZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBub2RlOiBwYXJlbnQsIGRlY286IHBhcmVudFZpZXcubWFyayB9KTtcbiAgICAgICAgZWxzZSBpZiAocGFyZW50VmlldyBpbnN0YW5jZW9mIExpbmVWaWV3IHx8IHBhcmVudC5ub2RlTmFtZSA9PSBcIkRJVlwiICYmIHBhcmVudC5wYXJlbnROb2RlID09IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0OiB0ZXh0Tm9kZSwgbWFya3MsIGxpbmU6IHBhcmVudCB9O1xuICAgICAgICBlbHNlIGlmIChwYXJlbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICAgICAgbWFya3MucHVzaCh7IG5vZGU6IHBhcmVudCwgZGVjbzogbmV3IE1hcmtEZWNvcmF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBnZXRBdHRycyhwYXJlbnQpLFxuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiBwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgfSkgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5lYXJieVRleHROb2RlKHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIHNpZGUpIHtcbiAgICBpZiAoc2lkZSA8PSAwKVxuICAgICAgICBmb3IgKGxldCBub2RlID0gc3RhcnROb2RlLCBvZmZzZXQgPSBzdGFydE9mZnNldDs7KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0IH07XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgaWYgKHNpZGUgPj0gMClcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0Tm9kZSwgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7Oykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBvZmZzZXQ6IG9mZnNldCB9O1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG5leHRUb1VuZWRpdGFibGUobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChvZmZzZXQgJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAxIC8qIE5leHRUby5CZWZvcmUgKi8gOiAwKSB8XG4gICAgICAgIChvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgPyAyIC8qIE5leHRUby5BZnRlciAqLyA6IDApO1xufVxubGV0IERlY29yYXRpb25Db21wYXJhdG9yJDEgPSBjbGFzcyBEZWNvcmF0aW9uQ29tcGFyYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbn07XG5mdW5jdGlvbiBmaW5kQ2hhbmdlZERlY28oYSwgYiwgZGlmZikge1xuICAgIGxldCBjb21wID0gbmV3IERlY29yYXRpb25Db21wYXJhdG9yJDE7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuZnVuY3Rpb24gaW5VbmVkaXRhYmxlKG5vZGUsIGluc2lkZSkge1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1ciAmJiBjdXIgIT0gaW5zaWRlOyBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSAmJiBjdXIuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHRvdWNoZXNDb21wb3NpdGlvbihjaGFuZ2VzLCBjb21wb3NpdGlvbikge1xuICAgIGxldCB0b3VjaGVkID0gZmFsc2U7XG4gICAgaWYgKGNvbXBvc2l0aW9uKVxuICAgICAgICBjaGFuZ2VzLml0ZXJDaGFuZ2VkUmFuZ2VzKChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPCBjb21wb3NpdGlvbi50byAmJiB0byA+IGNvbXBvc2l0aW9uLmZyb20pXG4gICAgICAgICAgICAgICAgdG91Y2hlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIHJldHVybiB0b3VjaGVkO1xufVxuXG5mdW5jdGlvbiBncm91cEF0KHN0YXRlLCBwb3MsIGJpYXMgPSAxKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgbGluZVBvcyA9IHBvcyAtIGxpbmUuZnJvbTtcbiAgICBpZiAobGluZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcbiAgICBpZiAobGluZVBvcyA9PSAwKVxuICAgICAgICBiaWFzID0gMTtcbiAgICBlbHNlIGlmIChsaW5lUG9zID09IGxpbmUubGVuZ3RoKVxuICAgICAgICBiaWFzID0gLTE7XG4gICAgbGV0IGZyb20gPSBsaW5lUG9zLCB0byA9IGxpbmVQb3M7XG4gICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICBmcm9tID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MsIGZhbHNlKTtcbiAgICBlbHNlXG4gICAgICAgIHRvID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIHdoaWxlIChmcm9tID4gMCkge1xuICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShwcmV2LCBmcm9tKSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZyb20gPSBwcmV2O1xuICAgIH1cbiAgICB3aGlsZSAodG8gPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0byk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZSh0bywgbmV4dCkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0byA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSArIGxpbmUuZnJvbSwgdG8gKyBsaW5lLmZyb20pO1xufVxuLy8gU2VhcmNoIHRoZSBET00gZm9yIHRoZSB7bm9kZSwgb2Zmc2V0fSBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlblxuLy8gY29vcmRpbmF0ZXMuIFZlcnkgaW5lZmZpY2llbnQgYW5kIGNydWRlLCBidXQgY2FuIHVzdWFsbHkgYmUgYXZvaWRlZFxuLy8gYnkgY2FsbGluZyBjYXJldChQb3NpdGlvbnxSYW5nZSlGcm9tUG9pbnQgaW5zdGVhZC5cbmZ1bmN0aW9uIGdldGR4KHgsIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC5sZWZ0ID4geCA/IHJlY3QubGVmdCAtIHggOiBNYXRoLm1heCgwLCB4IC0gcmVjdC5yaWdodCk7XG59XG5mdW5jdGlvbiBnZXRkeSh5LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IE1hdGgubWF4KDAsIHkgLSByZWN0LmJvdHRvbSk7XG59XG5mdW5jdGlvbiB5T3ZlcmxhcChhLCBiKSB7XG4gICAgcmV0dXJuIGEudG9wIDwgYi5ib3R0b20gLSAxICYmIGEuYm90dG9tID4gYi50b3AgKyAxO1xufVxuZnVuY3Rpb24gdXBUb3AocmVjdCwgdG9wKSB7XG4gICAgcmV0dXJuIHRvcCA8IHJlY3QudG9wID8geyB0b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiB1cEJvdChyZWN0LCBib3R0b20pIHtcbiAgICByZXR1cm4gYm90dG9tID4gcmVjdC5ib3R0b20gPyB7IHRvcDogcmVjdC50b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIGRvbVBvc0F0Q29vcmRzKHBhcmVudCwgeCwgeSkge1xuICAgIGxldCBjbG9zZXN0LCBjbG9zZXN0UmVjdCwgY2xvc2VzdFgsIGNsb3Nlc3RZLCBjbG9zZXN0T3ZlcmxhcCA9IGZhbHNlO1xuICAgIGxldCBhYm92ZSwgYmVsb3csIGFib3ZlUmVjdCwgYmVsb3dSZWN0O1xuICAgIGZvciAobGV0IGNoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UmVjdCAmJiB5T3ZlcmxhcChjbG9zZXN0UmVjdCwgcmVjdCkpXG4gICAgICAgICAgICAgICAgcmVjdCA9IHVwVG9wKHVwQm90KHJlY3QsIGNsb3Nlc3RSZWN0LmJvdHRvbSksIGNsb3Nlc3RSZWN0LnRvcCk7XG4gICAgICAgICAgICBsZXQgZHggPSBnZXRkeCh4LCByZWN0KSwgZHkgPSBnZXRkeSh5LCByZWN0KTtcbiAgICAgICAgICAgIGlmIChkeCA9PSAwICYmIGR5ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLm5vZGVUeXBlID09IDMgPyBkb21Qb3NJblRleHQoY2hpbGQsIHgsIHkpIDogZG9tUG9zQXRDb29yZHMoY2hpbGQsIHgsIHkpO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0IHx8IGNsb3Nlc3RZID4gZHkgfHwgY2xvc2VzdFkgPT0gZHkgJiYgY2xvc2VzdFggPiBkeCkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFggPSBkeDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WSA9IGR5O1xuICAgICAgICAgICAgICAgIGxldCBzaWRlID0gZHkgPyAoeSA8IHJlY3QudG9wID8gLTEgOiAxKSA6IGR4ID8gKHggPCByZWN0LmxlZnQgPyAtMSA6IDEpIDogMDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T3ZlcmxhcCA9ICFzaWRlIHx8IChzaWRlID4gMCA/IGkgPCByZWN0cy5sZW5ndGggLSAxIDogaSA+IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR4ID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+IHJlY3QuYm90dG9tICYmICghYWJvdmVSZWN0IHx8IGFib3ZlUmVjdC5ib3R0b20gPCByZWN0LmJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeSA8IHJlY3QudG9wICYmICghYmVsb3dSZWN0IHx8IGJlbG93UmVjdC50b3AgPiByZWN0LnRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3cgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhYm92ZVJlY3QgJiYgeU92ZXJsYXAoYWJvdmVSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHVwQm90KGFib3ZlUmVjdCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIHlPdmVybGFwKGJlbG93UmVjdCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSB1cFRvcChiZWxvd1JlY3QsIHJlY3QudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWJvdmVSZWN0ICYmIGFib3ZlUmVjdC5ib3R0b20gPj0geSkge1xuICAgICAgICBjbG9zZXN0ID0gYWJvdmU7XG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYWJvdmVSZWN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgYmVsb3dSZWN0LnRvcCA8PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBiZWxvdztcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBiZWxvd1JlY3Q7XG4gICAgfVxuICAgIGlmICghY2xvc2VzdClcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQ6IDAgfTtcbiAgICBsZXQgY2xpcFggPSBNYXRoLm1heChjbG9zZXN0UmVjdC5sZWZ0LCBNYXRoLm1pbihjbG9zZXN0UmVjdC5yaWdodCwgeCkpO1xuICAgIGlmIChjbG9zZXN0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiBkb21Qb3NJblRleHQoY2xvc2VzdCwgY2xpcFgsIHkpO1xuICAgIGlmIChjbG9zZXN0T3ZlcmxhcCAmJiBjbG9zZXN0LmNvbnRlbnRFZGl0YWJsZSAhPSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiBkb21Qb3NBdENvb3JkcyhjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgbGV0IG9mZnNldCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwocGFyZW50LmNoaWxkTm9kZXMsIGNsb3Nlc3QpICtcbiAgICAgICAgKHggPj0gKGNsb3Nlc3RSZWN0LmxlZnQgKyBjbG9zZXN0UmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBkb21Qb3NJblRleHQobm9kZSwgeCwgeSkge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IGNsb3Nlc3RPZmZzZXQgPSAtMSwgY2xvc2VzdERZID0gMWU5LCBnZW5lcmFsU2lkZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2Uobm9kZSwgaSwgaSArIDEpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbal07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWdlbmVyYWxTaWRlKVxuICAgICAgICAgICAgICAgIGdlbmVyYWxTaWRlID0geCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgIGxldCBkeSA9IChyZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiB5IC0gcmVjdC5ib3R0b20pIC0gMTtcbiAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgLSAxIDw9IHggJiYgcmVjdC5yaWdodCArIDEgPj0geCAmJiBkeSA8IGNsb3Nlc3REWSkge1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9IHggPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgYWZ0ZXIgPSByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgUlRMIG9uIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZXR0aW5nIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAvLyByZWN0cyBmb3IgZW1wdHkgcmFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHRleHRSYW5nZShub2RlLCBpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUubGVmdCA9PSByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSAhcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkeSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGkgKyAoYWZ0ZXIgPyAxIDogMCkgfTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T2Zmc2V0ID0gaSArIChhZnRlciA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0RFkgPSBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGNsb3Nlc3RPZmZzZXQgPiAtMSA/IGNsb3Nlc3RPZmZzZXQgOiBnZW5lcmFsU2lkZSA+IDAgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiAwIH07XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCBjb29yZHMsIHByZWNpc2UsIGJpYXMgPSAtMSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvY1RvcCA9IGNvbnRlbnQudG9wICsgdmlldy52aWV3U3RhdGUucGFkZGluZ1RvcDtcbiAgICBsZXQgYmxvY2ssIHsgZG9jSGVpZ2h0IH0gPSB2aWV3LnZpZXdTdGF0ZTtcbiAgICBsZXQgeyB4LCB5IH0gPSBjb29yZHMsIHlPZmZzZXQgPSB5IC0gZG9jVG9wO1xuICAgIGlmICh5T2Zmc2V0IDwgMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHlPZmZzZXQgPiBkb2NIZWlnaHQpXG4gICAgICAgIHJldHVybiB2aWV3LnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgLy8gU2NhbiBmb3IgYSB0ZXh0IGJsb2NrIG5lYXIgdGhlIHF1ZXJpZWQgeSBwb3NpdGlvblxuICAgIGZvciAobGV0IGhhbGZMaW5lID0gdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgLyAyLCBib3VuY2VkID0gZmFsc2U7Oykge1xuICAgICAgICBibG9jayA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KHlPZmZzZXQpO1xuICAgICAgICBpZiAoYmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRoZSB5IHBvc2l0aW9uIG91dCBvZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICB5T2Zmc2V0ID0gYmlhcyA+IDAgPyBibG9jay5ib3R0b20gKyBoYWxmTGluZSA6IGJsb2NrLnRvcCAtIGhhbGZMaW5lO1xuICAgICAgICAgICAgaWYgKHlPZmZzZXQgPj0gMCAmJiB5T2Zmc2V0IDw9IGRvY0hlaWdodClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIElmIHRoZSBkb2N1bWVudCBjb25zaXN0cyBlbnRpcmVseSBvZiByZXBsYWNlZCB3aWRnZXRzLCB3ZVxuICAgICAgICAgICAgLy8gd29uJ3QgZmluZCBhIHRleHQgYmxvY2ssIHNvIHJldHVybiAwXG4gICAgICAgICAgICBpZiAoYm91bmNlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2lzZSA/IG51bGwgOiAwO1xuICAgICAgICAgICAgYm91bmNlZCA9IHRydWU7XG4gICAgICAgICAgICBiaWFzID0gLWJpYXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgeSA9IGRvY1RvcCArIHlPZmZzZXQ7XG4gICAgbGV0IGxpbmVTdGFydCA9IGJsb2NrLmZyb207XG4gICAgLy8gSWYgdGhpcyBpcyBvdXRzaWRlIG9mIHRoZSByZW5kZXJlZCB2aWV3cG9ydCwgd2UgY2FuJ3QgZGV0ZXJtaW5lIGEgcG9zaXRpb25cbiAgICBpZiAobGluZVN0YXJ0IDwgdmlldy52aWV3cG9ydC5mcm9tKVxuICAgICAgICByZXR1cm4gdmlldy52aWV3cG9ydC5mcm9tID09IDAgPyAwIDogcHJlY2lzZSA/IG51bGwgOiBwb3NBdENvb3Jkc0ltcHJlY2lzZSh2aWV3LCBjb250ZW50LCBibG9jaywgeCwgeSk7XG4gICAgaWYgKGxpbmVTdGFydCA+IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aWV3LnZpZXdwb3J0LnRvID09IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA6XG4gICAgICAgICAgICBwcmVjaXNlID8gbnVsbCA6IHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnQsIGJsb2NrLCB4LCB5KTtcbiAgICAvLyBQcmVmZXIgU2hhZG93Um9vdE9yRG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCBpZiBwcmVzZW50LCBmYWxsIGJhY2sgdG8gZG9jdW1lbnQgaWYgbm90XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgbGV0IHJvb3QgPSB2aWV3LnJvb3QuZWxlbWVudEZyb21Qb2ludCA/IHZpZXcucm9vdCA6IGRvYztcbiAgICBsZXQgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAoZWxlbWVudCAmJiAhdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGVsZW1lbnQpKVxuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyB1bmV4cGVjdGVkLCBjbGlwIHggYXQgdGhlIHNpZGVzIG9mIHRoZSBjb250ZW50IGFyZWEgYW5kIHRyeSBhZ2FpblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB4ID0gTWF0aC5tYXgoY29udGVudC5sZWZ0ICsgMSwgTWF0aC5taW4oY29udGVudC5yaWdodCAtIDEsIHgpKTtcbiAgICAgICAgZWxlbWVudCA9IHJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIXZpZXcuY29udGVudERPTS5jb250YWlucyhlbGVtZW50KSlcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBUaGVyZSdzIHZpc2libGUgZWRpdG9yIGNvbnRlbnQgdW5kZXIgdGhlIHBvaW50LCBzbyB3ZSBjYW4gdHJ5XG4gICAgLy8gdXNpbmcgY2FyZXQoUG9zaXRpb258UmFuZ2UpRnJvbVBvaW50IGFzIGEgc2hvcnRjdXRcbiAgICBsZXQgbm9kZSwgb2Zmc2V0ID0gLTE7XG4gICAgaWYgKGVsZW1lbnQgJiYgKChfYSA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGVsZW1lbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgIT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgICh7IG9mZnNldE5vZGU6IG5vZGUsIG9mZnNldCB9ID0gcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAoeyBzdGFydENvbnRhaW5lcjogbm9kZSwgc3RhcnRPZmZzZXQ6IG9mZnNldCB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmICghdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKG5vZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuc2FmYXJpICYmIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkgfHxcbiAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5jaHJvbWUgJiYgaXNTdXNwaWNpb3VzQ2hyb21lQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBObyBsdWNrLCBkbyBvdXIgb3duIChwb3RlbnRpYWxseSBleHBlbnNpdmUpIHNlYXJjaFxuICAgIGlmICghbm9kZSB8fCAhdmlldy5kb2NWaWV3LmRvbS5jb250YWlucyhub2RlKSkge1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBsaW5lU3RhcnQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm4geU9mZnNldCA+IGJsb2NrLnRvcCArIGJsb2NrLmhlaWdodCAvIDIgPyBibG9jay50byA6IGJsb2NrLmZyb207XG4gICAgICAgICh7IG5vZGUsIG9mZnNldCB9ID0gZG9tUG9zQXRDb29yZHMobGluZS5kb20sIHgsIHkpKTtcbiAgICB9XG4gICAgbGV0IG5lYXJlc3QgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChub2RlKTtcbiAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChuZWFyZXN0LmlzV2lkZ2V0ICYmICgoX2IgPSBuZWFyZXN0LmRvbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5vZGVUeXBlKSA9PSAxKSB7XG4gICAgICAgIGxldCByZWN0ID0gbmVhcmVzdC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiBjb29yZHMueSA8IHJlY3QudG9wIHx8IGNvb3Jkcy55IDw9IHJlY3QuYm90dG9tICYmIGNvb3Jkcy54IDw9IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDJcbiAgICAgICAgICAgID8gbmVhcmVzdC5wb3NBdFN0YXJ0IDogbmVhcmVzdC5wb3NBdEVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZWFyZXN0LmxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpICsgbmVhcmVzdC5wb3NBdFN0YXJ0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnRSZWN0LCBibG9jaywgeCwgeSkge1xuICAgIGxldCBpbnRvID0gTWF0aC5yb3VuZCgoeCAtIGNvbnRlbnRSZWN0LmxlZnQpICogdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpO1xuICAgIGlmICh2aWV3LmxpbmVXcmFwcGluZyAmJiBibG9jay5oZWlnaHQgPiB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0ICogMS41KSB7XG4gICAgICAgIGxldCB0ZXh0SGVpZ2h0ID0gdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQ7XG4gICAgICAgIGxldCBsaW5lID0gTWF0aC5mbG9vcigoeSAtIGJsb2NrLnRvcCAtICh2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC0gdGV4dEhlaWdodCkgKiAwLjUpIC8gdGV4dEhlaWdodCk7XG4gICAgICAgIGludG8gKz0gbGluZSAqIHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lTGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgY29udGVudCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoYmxvY2suZnJvbSwgYmxvY2sudG8pO1xuICAgIHJldHVybiBibG9jay5mcm9tICsgZmluZENvbHVtbihjb250ZW50LCBpbnRvLCB2aWV3LnN0YXRlLnRhYlNpemUpO1xufVxuLy8gSW4gY2FzZSBvZiBhIGhpZ2ggbGluZSBoZWlnaHQsIFNhZmFyaSdzIGNhcmV0UmFuZ2VGcm9tUG9pbnQgdHJlYXRzXG4vLyB0aGUgc3BhY2UgYmV0d2VlbiBsaW5lcyBhcyBiZWxvbmdpbmcgdG8gdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZVxuLy8gbGluZSBiZWZvcmUuIFRoaXMgaXMgdXNlZCB0byBkZXRlY3Qgc3VjaCBhIHJlc3VsdCBzbyB0aGF0IGl0IGNhbiBiZVxuLy8gaWdub3JlZCAoaXNzdWUgIzQwMSkuXG5mdW5jdGlvbiBpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpIHtcbiAgICBsZXQgbGVuO1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMgfHwgb2Zmc2V0ICE9IChsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7IG5leHQ7IG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nKVxuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSAhPSAxIHx8IG5leHQubm9kZU5hbWUgIT0gXCJCUlwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0ZXh0UmFuZ2Uobm9kZSwgbGVuIC0gMSwgbGVuKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4geDtcbn1cbi8vIENocm9tZSB3aWxsIG1vdmUgcG9zaXRpb25zIGJldHdlZW4gbGluZXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGxpbmVcbmZ1bmN0aW9uIGlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkge1xuICAgIGlmIChvZmZzZXQgIT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7Oykge1xuICAgICAgICBsZXQgcGFyZW50ID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IHBhcmVudC5maXJzdENoaWxkICE9IGN1cilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS1saW5lXCIpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGN1ciA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IHJlY3QgPSBub2RlLm5vZGVUeXBlID09IDEgPyBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIDogdGV4dFJhbmdlKG5vZGUsIDAsIE1hdGgubWF4KG5vZGUubm9kZVZhbHVlLmxlbmd0aCwgMSkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB4IC0gcmVjdC5sZWZ0ID4gNTtcbn1cbmZ1bmN0aW9uIGJsb2NrQXQodmlldywgcG9zKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSlcbiAgICAgICAgZm9yIChsZXQgbCBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChsLnRvID4gcG9zIHx8IGwudG8gPT0gcG9zICYmIChsLnRvID09IGxpbmUudG8gfHwgbC50eXBlID09IEJsb2NrVHlwZS5UZXh0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBsaW5lO1xufVxuZnVuY3Rpb24gbW92ZVRvTGluZUJvdW5kYXJ5KHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCkge1xuICAgIGxldCBsaW5lID0gYmxvY2tBdCh2aWV3LCBzdGFydC5oZWFkKTtcbiAgICBsZXQgY29vcmRzID0gIWluY2x1ZGVXcmFwIHx8IGxpbmUudHlwZSAhPSBCbG9ja1R5cGUuVGV4dCB8fCAhKHZpZXcubGluZVdyYXBwaW5nIHx8IGxpbmUud2lkZ2V0TGluZUJyZWFrcykgPyBudWxsXG4gICAgICAgIDogdmlldy5jb29yZHNBdFBvcyhzdGFydC5hc3NvYyA8IDAgJiYgc3RhcnQuaGVhZCA+IGxpbmUuZnJvbSA/IHN0YXJ0LmhlYWQgLSAxIDogc3RhcnQuaGVhZCk7XG4gICAgaWYgKGNvb3Jkcykge1xuICAgICAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBmb3J3YXJkID09IChkaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUikgPyBlZGl0b3JSZWN0LnJpZ2h0IC0gMSA6IGVkaXRvclJlY3QubGVmdCArIDEsXG4gICAgICAgICAgICB5OiAoY29vcmRzLnRvcCArIGNvb3Jkcy5ib3R0b20pIC8gMiB9KTtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gbW92ZUJ5Q2hhcih2aWV3LCBzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKSwgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICBsZXQgZGlyZWN0aW9uID0gdmlldy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFydCwgY2hlY2sgPSBudWxsOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlVmlzdWFsbHkobGluZSwgc3BhbnMsIGRpcmVjdGlvbiwgY3VyLCBmb3J3YXJkKSwgY2hhciA9IG1vdmVkT3ZlcjtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjaGFyID0gXCJcXG5cIjtcbiAgICAgICAgICAgIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lKGxpbmUubnVtYmVyICsgKGZvcndhcmQgPyAxIDogLTEpKTtcbiAgICAgICAgICAgIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgICAgICBuZXh0ID0gdmlldy52aXN1YWxMaW5lU2lkZShsaW5lLCAhZm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgaWYgKCFieSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIGNoZWNrID0gYnkoY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrKGNoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYnlHcm91cCh2aWV3LCBwb3MsIHN0YXJ0KSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKHN0YXJ0KTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHJldHVybiBjYXQgPT0gbmV4dENhdDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZVZlcnRpY2FsbHkodmlldywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQuaGVhZCwgZGlyID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICBpZiAoc3RhcnRQb3MgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiAwKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnRQb3MsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgZ29hbCA9IHN0YXJ0LmdvYWxDb2x1bW4sIHN0YXJ0WTtcbiAgICBsZXQgcmVjdCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc3RhcnRDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0UG9zLCBzdGFydC5hc3NvYyB8fCAtMSksIGRvY1RvcCA9IHZpZXcuZG9jdW1lbnRUb3A7XG4gICAgaWYgKHN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gc3RhcnRDb29yZHMubGVmdCAtIHJlY3QubGVmdDtcbiAgICAgICAgc3RhcnRZID0gZGlyIDwgMCA/IHN0YXJ0Q29vcmRzLnRvcCA6IHN0YXJ0Q29vcmRzLmJvdHRvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy52aWV3U3RhdGUubGluZUJsb2NrQXQoc3RhcnRQb3MpO1xuICAgICAgICBpZiAoZ29hbCA9PSBudWxsKVxuICAgICAgICAgICAgZ29hbCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoICogKHN0YXJ0UG9zIC0gbGluZS5mcm9tKSk7XG4gICAgICAgIHN0YXJ0WSA9IChkaXIgPCAwID8gbGluZS50b3AgOiBsaW5lLmJvdHRvbSkgKyBkb2NUb3A7XG4gICAgfVxuICAgIGxldCByZXNvbHZlZEdvYWwgPSByZWN0LmxlZnQgKyBnb2FsO1xuICAgIGxldCBkaXN0ID0gZGlzdGFuY2UgIT09IG51bGwgJiYgZGlzdGFuY2UgIT09IHZvaWQgMCA/IGRpc3RhbmNlIDogKHZpZXcudmlld1N0YXRlLmhlaWdodE9yYWNsZS50ZXh0SGVpZ2h0ID4+IDEpO1xuICAgIGZvciAobGV0IGV4dHJhID0gMDs7IGV4dHJhICs9IDEwKSB7XG4gICAgICAgIGxldCBjdXJZID0gc3RhcnRZICsgKGRpc3QgKyBleHRyYSkgKiBkaXI7XG4gICAgICAgIGxldCBwb3MgPSBwb3NBdENvb3Jkcyh2aWV3LCB7IHg6IHJlc29sdmVkR29hbCwgeTogY3VyWSB9LCBmYWxzZSwgZGlyKTtcbiAgICAgICAgaWYgKGN1clkgPCByZWN0LnRvcCB8fCBjdXJZID4gcmVjdC5ib3R0b20gfHwgKGRpciA8IDAgPyBwb3MgPCBzdGFydFBvcyA6IHBvcyA+IHN0YXJ0UG9zKSkge1xuICAgICAgICAgICAgbGV0IGNoYXJSZWN0ID0gdmlldy5kb2NWaWV3LmNvb3Jkc0ZvckNoYXIocG9zKTtcbiAgICAgICAgICAgIGxldCBhc3NvYyA9ICFjaGFyUmVjdCB8fCBjdXJZIDwgY2hhclJlY3QudG9wID8gLTEgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBhc3NvYywgdW5kZWZpbmVkLCBnb2FsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9taWNSYW5nZXMoYXRvbXMsIHBvcywgYmlhcykge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gMDtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIGF0b21zKSB7XG4gICAgICAgICAgICBzZXQuYmV0d2Vlbihwb3MgLSAxLCBwb3MgKyAxLCAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgcG9zIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBtb3ZlZCB8fCBiaWFzIHx8IChwb3MgLSBmcm9tIDwgdG8gLSBwb3MgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBzaWRlIDwgMCA/IGZyb20gOiB0bztcbiAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSBzaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW92ZWQpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9tcyh2aWV3LCBvbGRQb3MsIHBvcykge1xuICAgIGxldCBuZXdQb3MgPSBza2lwQXRvbWljUmFuZ2VzKHZpZXcuc3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKSwgcG9zLmZyb20sIG9sZFBvcy5oZWFkID4gcG9zLmZyb20gPyAtMSA6IDEpO1xuICAgIHJldHVybiBuZXdQb3MgPT0gcG9zLmZyb20gPyBwb3MgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5ld1BvcywgbmV3UG9zIDwgcG9zLmZyb20gPyAxIDogLTEpO1xufVxuXG4vLyBUaGlzIHdpbGwgYWxzbyBiZSB3aGVyZSBkcmFnZ2luZyBpbmZvIGFuZCBzdWNoIGdvZXNcbmNsYXNzIElucHV0U3RhdGUge1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbihvcmlnaW4pIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gMDtcbiAgICAgICAgdGhpcy5sYXN0S2V5VGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRvdWNoVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbExlZnQgPSAwO1xuICAgICAgICAvLyBPbiBpT1MsIHNvbWUga2V5cyBuZWVkIHRvIGhhdmUgdGhlaXIgZGVmYXVsdCBiZWhhdmlvciBoYXBwZW5cbiAgICAgICAgLy8gKGFmdGVyIHdoaWNoIHdlIHJldHJvYWN0aXZlbHkgaGFuZGxlIHRoZW0gYW5kIHJlc2V0IHRoZSBET00pIHRvXG4gICAgICAgIC8vIGF2b2lkIG1lc3NpbmcgdXAgdGhlIHZpcnR1YWwga2V5Ym9hcmQgc3RhdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEVzY1ByZXNzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29udGV4dE1lbnUgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyAtMSBtZWFucyBub3QgaW4gYSBjb21wb3NpdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGNvdW50cyB0aGUgbnVtYmVyXG4gICAgICAgIC8vIG9mIGNoYW5nZXMgbWFkZSBkdXJpbmcgdGhlIGNvbXBvc2l0aW9uLiBUaGUgY291bnQgaXMgdXNlZCB0b1xuICAgICAgICAvLyBhdm9pZCB0cmVhdGluZyB0aGUgc3RhcnQgc3RhdGUgb2YgdGhlIGNvbXBvc2l0aW9uLCBiZWZvcmUgYW55XG4gICAgICAgIC8vIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUsIGFzIHBhcnQgb2YgdGhlIGNvbXBvc2l0aW9uLlxuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IC0xO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGUgbmV4dCBjaGFuZ2Ugc2hvdWxkIGJlIG1hcmtlZCBhcyBzdGFydGluZyB0aGVcbiAgICAgICAgLy8gY29tcG9zaXRpb24gKG51bGwgbWVhbnMgbm8gY29tcG9zaXRpb24sIHRydWUgbWVhbnMgbmV4dCBpcyB0aGVcbiAgICAgICAgLy8gZmlyc3QsIGZhbHNlIG1lYW5zIGZpcnN0IGhhcyBhbHJlYWR5IGJlZW4gbWFya2VkIGZvciB0aGlzXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uKVxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgICAgICAvLyBFbmQgdGltZSBvZiB0aGUgcHJldmlvdXMgY29tcG9zaXRpb25cbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAwO1xuICAgICAgICAvLyBVc2VkIGluIGEga2x1ZGdlIHRvIGRldGVjdCB3aGVuIGFuIEVudGVyIGtleXByZXNzIHNob3VsZCBiZVxuICAgICAgICAvLyBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIGNvbXBvc2l0aW9uIG9uIFNhZmFyaSwgd2hpY2ggZmlyZXMgZXZlbnRzXG4gICAgICAgIC8vIGluIHRoZSB3cm9uZyBvcmRlclxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9IGZhbHNlO1xuICAgICAgICAvLyBVc2VkIHRvIGNhdGVnb3JpemUgY2hhbmdlcyBhcyBwYXJ0IG9mIGEgY29tcG9zaXRpb24sIGV2ZW4gd2hlblxuICAgICAgICAvLyB0aGUgbXV0YXRpb24gZXZlbnRzIGZpcmUgc2hvcnRseSBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnRcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIC8vIFdoZW4gYSBkcmFnIGZyb20gdGhlIGVkaXRvciBpcyBhY3RpdmUsIHRoaXMgcG9pbnRzIGF0IHRoZSByYW5nZVxuICAgICAgICAvLyBiZWluZyBkcmFnZ2VkLlxuICAgICAgICB0aGlzLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ub3RpZmllZEZvY3VzZWQgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICAvLyBPbiBTYWZhcmkgYWRkaW5nIGFuIGlucHV0IGV2ZW50IGhhbmRsZXIgc29tZWhvdyBwcmV2ZW50cyBhblxuICAgICAgICAvLyBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlbiB5b3UgcHJlc3MgZW50ZXIuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSlcbiAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvKVxuICAgICAgICAgICAgZmlyZWZveENvcHlDdXRIYWNrKHZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50KTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudEJlbG9uZ3NUb0VkaXRvcih0aGlzLnZpZXcsIGV2ZW50KSB8fCB0aGlzLmlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIgJiYgdGhpcy5rZXlkb3duKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5ydW5IYW5kbGVycyhldmVudC50eXBlLCBldmVudCk7XG4gICAgfVxuICAgIHJ1bkhhbmRsZXJzKHR5cGUsIGV2ZW50KSB7XG4gICAgICAgIGxldCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbdHlwZV07XG4gICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgICAgZm9yIChsZXQgb2JzZXJ2ZXIgb2YgaGFuZGxlcnMub2JzZXJ2ZXJzKVxuICAgICAgICAgICAgICAgIG9ic2VydmVyKHRoaXMudmlldywgZXZlbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycy5oYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcih0aGlzLnZpZXcsIGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5zdXJlSGFuZGxlcnMocGx1Z2lucykge1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSBjb21wdXRlSGFuZGxlcnMocGx1Z2lucyksIHByZXYgPSB0aGlzLmhhbmRsZXJzLCBkb20gPSB0aGlzLnZpZXcuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycylcbiAgICAgICAgICAgIGlmICh0eXBlICE9IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFzc2l2ZSA9ICFoYW5kbGVyc1t0eXBlXS5oYW5kbGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0cyA9IHByZXZbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0cyAmJiBwYXNzaXZlICE9ICFleGlzdHMuaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBleGlzdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5oYW5kbGVFdmVudCwgeyBwYXNzaXZlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0eXBlIGluIHByZXYpXG4gICAgICAgICAgICBpZiAodHlwZSAhPSBcInNjcm9sbFwiICYmICFoYW5kbGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIH1cbiAgICBrZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIC8vIE11c3QgYWx3YXlzIHJ1biwgZXZlbiBpZiBhIGN1c3RvbSBoYW5kbGVyIGhhbmRsZWQgdGhlIGV2ZW50XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICB0aGlzLmxhc3RLZXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gOSAmJiBEYXRlLm5vdygpIDwgdGhpcy5sYXN0RXNjUHJlc3MgKyAyMDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlICE9IDI3ICYmIG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0RXNjUHJlc3MgPSAwO1xuICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQgdXN1YWxseSBkb2Vzbid0IGZpcmUgcHJvcGVyIGtleSBldmVudHMsIGJ1dFxuICAgICAgICAvLyBvY2Nhc2lvbmFsbHkgZG9lcywgdXN1YWxseSBzdXJyb3VuZGVkIGJ5IGEgYnVuY2ggb2YgY29tcGxpY2F0ZWRcbiAgICAgICAgLy8gY29tcG9zaXRpb24gY2hhbmdlcy4gV2hlbiBhbiBlbnRlciBvciBiYWNrc3BhY2Uga2V5IGV2ZW50IGlzXG4gICAgICAgIC8vIHNlZW4sIGhvbGQgb2ZmIG9uIGhhbmRsaW5nIERPTSBldmVudHMgZm9yIGEgYml0LCBhbmQgdGhlblxuICAgICAgICAvLyBkaXNwYXRjaCBpdC5cbiAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiAhZXZlbnQuc3ludGhldGljICYmXG4gICAgICAgICAgICAoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDgpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KGV2ZW50LmtleSwgZXZlbnQua2V5Q29kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIEVudGVyIG9uIGlPUyBtYWtlcyB0aGVcbiAgICAgICAgLy8gdmlydHVhbCBrZXlib2FyZCBnZXQgc3R1Y2sgaW4gdGhlIHdyb25nIChsb3dlcmNhc2UpXG4gICAgICAgIC8vIHN0YXRlLiBTbyB3ZSBsZXQgaXQgZ28gdGhyb3VnaCwgYW5kIHRoZW4sIGluXG4gICAgICAgIC8vIGFwcGx5RE9NQ2hhbmdlLCBub3RpZnkga2V5IGhhbmRsZXJzIG9mIGl0IGFuZCByZXNldCB0b1xuICAgICAgICAvLyB0aGUgc3RhdGUgdGhleSBwcm9kdWNlLlxuICAgICAgICBsZXQgcGVuZGluZztcbiAgICAgICAgaWYgKGJyb3dzZXIuaW9zICYmICFldmVudC5zeW50aGV0aWMgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSAmJlxuICAgICAgICAgICAgKChwZW5kaW5nID0gUGVuZGluZ0tleXMuZmluZChrZXkgPT4ga2V5LmtleUNvZGUgPT0gZXZlbnQua2V5Q29kZSkpICYmICFldmVudC5jdHJsS2V5IHx8XG4gICAgICAgICAgICAgICAgRW1hY3N5UGVuZGluZ0tleXMuaW5kZXhPZihldmVudC5rZXkpID4gLTEgJiYgZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuc2hpZnRLZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSBwZW5kaW5nIHx8IGV2ZW50O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoSU9TS2V5KCksIDI1MCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpXG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZsdXNoSU9TS2V5KCkge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5wZW5kaW5nSU9TS2V5O1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hLZXkodGhpcy52aWV3LmNvbnRlbnRET00sIGtleS5rZXksIGtleS5rZXlDb2RlKTtcbiAgICB9XG4gICAgaWdub3JlRHVyaW5nQ29tcG9zaXRpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCEvXmtleS8udGVzdChldmVudC50eXBlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gICAgICAgIC8vIE9uIHNvbWUgaW5wdXQgbWV0aG9kIGVkaXRvcnMgKElNRXMpLCB0aGUgRW50ZXIga2V5IGlzIHVzZWQgdG9cbiAgICAgICAgLy8gY29uZmlybSBjaGFyYWN0ZXIgc2VsZWN0aW9uLiBPbiBTYWZhcmksIHdoZW4gRW50ZXIgaXMgcHJlc3NlZCxcbiAgICAgICAgLy8gY29tcG9zaXRpb25lbmQgYW5kIGtleWRvd24gZXZlbnRzIGFyZSBzb21ldGltZXMgZW1pdHRlZCBpbiB0aGVcbiAgICAgICAgLy8gd3Jvbmcgb3JkZXIuIFRoZSBrZXkgZXZlbnQgc2hvdWxkIHN0aWxsIGJlIGlnbm9yZWQsIGV2ZW4gd2hlblxuICAgICAgICAvLyBpdCBoYXBwZW5zIGFmdGVyIHRoZSBjb21wb3NpdGlvbmVuZCBldmVudC5cbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFicm93c2VyLmlvcyAmJiB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSAmJiBEYXRlLm5vdygpIC0gdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPCAxMDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0TW91c2VTZWxlY3Rpb24obW91c2VTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG1vdXNlU2VsZWN0aW9uO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dlZENvbnRlbnQgJiYgdXBkYXRlLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRyYWdnZWRDb250ZW50ID0gdGhpcy5kcmFnZ2VkQ29udGVudC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RLZXlDb2RlID0gdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmluZEhhbmRsZXIocGx1Z2luLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbChwbHVnaW4sIGV2ZW50LCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVIYW5kbGVycyhwbHVnaW5zKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gcmVjb3JkKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFt0eXBlXSB8fCAocmVzdWx0W3R5cGVdID0geyBvYnNlcnZlcnM6IFtdLCBoYW5kbGVyczogW10gfSk7XG4gICAgfVxuICAgIGZvciAobGV0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgIGxldCBzcGVjID0gcGx1Z2luLnNwZWM7XG4gICAgICAgIGlmIChzcGVjICYmIHNwZWMuZG9tRXZlbnRIYW5kbGVycylcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gc3BlYy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGYgPSBzcGVjLmRvbUV2ZW50SGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCh0eXBlKS5oYW5kbGVycy5wdXNoKGJpbmRIYW5kbGVyKHBsdWdpbi52YWx1ZSwgZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoc3BlYyAmJiBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzKVxuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGYgPSBzcGVjLmRvbUV2ZW50T2JzZXJ2ZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgICAgICByZWNvcmQodHlwZSkub2JzZXJ2ZXJzLnB1c2goYmluZEhhbmRsZXIocGx1Z2luLnZhbHVlLCBmKSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpXG4gICAgICAgIHJlY29yZCh0eXBlKS5oYW5kbGVycy5wdXNoKGhhbmRsZXJzW3R5cGVdKTtcbiAgICBmb3IgKGxldCB0eXBlIGluIG9ic2VydmVycylcbiAgICAgICAgcmVjb3JkKHR5cGUpLm9ic2VydmVycy5wdXNoKG9ic2VydmVyc1t0eXBlXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IFBlbmRpbmdLZXlzID0gW1xuICAgIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBrZXlDb2RlOiA4LCBpbnB1dFR5cGU6IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBrZXlDb2RlOiAxMywgaW5wdXRUeXBlOiBcImluc2VydFBhcmFncmFwaFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRMaW5lQnJlYWtcIiB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBrZXlDb2RlOiA0NiwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCIgfVxuXTtcbmNvbnN0IEVtYWNzeVBlbmRpbmdLZXlzID0gXCJkdGhrb1wiO1xuLy8gS2V5IGNvZGVzIGZvciBtb2RpZmllciBrZXlzXG5jb25zdCBtb2RpZmllckNvZGVzID0gWzE2LCAxNywgMTgsIDIwLCA5MSwgOTIsIDIyNCwgMjI1XTtcbmNvbnN0IGRyYWdTY3JvbGxNYXJnaW4gPSA2O1xuZnVuY3Rpb24gZHJhZ1Njcm9sbFNwZWVkKGRpc3QpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZGlzdCkgKiAwLjcgKyA4O1xufVxuZnVuY3Rpb24gZGlzdChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKGEuY2xpZW50WCAtIGIuY2xpZW50WCksIE1hdGguYWJzKGEuY2xpZW50WSAtIGIuY2xpZW50WSkpO1xufVxuY2xhc3MgTW91c2VTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIHN0YXJ0RXZlbnQsIHN0eWxlLCBtdXN0U2VsZWN0KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgdGhpcy5tdXN0U2VsZWN0ID0gbXVzdFNlbGVjdDtcbiAgICAgICAgdGhpcy5zY3JvbGxTcGVlZCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50ID0gc2Nyb2xsYWJsZVBhcmVudCh2aWV3LmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmF0b21zID0gdmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpO1xuICAgICAgICBsZXQgZG9jID0gdmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmV4dGVuZCA9IHN0YXJ0RXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIHRoaXMubXVsdGlwbGUgPSB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSAmJiBhZGRzU2VsZWN0aW9uUmFuZ2Uodmlldywgc3RhcnRFdmVudCk7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBpc0luUHJpbWFyeVNlbGVjdGlvbih2aWV3LCBzdGFydEV2ZW50KSAmJiBnZXRDbGlja1R5cGUoc3RhcnRFdmVudCkgPT0gMSA/IG51bGwgOiBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnQoZXZlbnQpIHtcbiAgICAgICAgLy8gV2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb24sIGltbWVkaWF0ZWx5IGFwcGx5IHRoZVxuICAgICAgICAvLyBlZmZlY3Qgb2Ygc3RhcnRpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdChldmVudCk7XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyB8fCB0aGlzLmRyYWdnaW5nID09IG51bGwgJiYgZGlzdCh0aGlzLnN0YXJ0RXZlbnQsIGV2ZW50KSA8IDEwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCA9IGV2ZW50KTtcbiAgICAgICAgbGV0IHN4ID0gMCwgc3kgPSAwO1xuICAgICAgICBsZXQgcmVjdCA9ICgoX2EgPSB0aGlzLnNjcm9sbFBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKVxuICAgICAgICAgICAgfHwgeyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiB0aGlzLnZpZXcud2luLmlubmVyV2lkdGgsIGJvdHRvbTogdGhpcy52aWV3Lndpbi5pbm5lckhlaWdodCB9O1xuICAgICAgICBsZXQgbWFyZ2lucyA9IGdldFNjcm9sbE1hcmdpbnModGhpcy52aWV3KTtcbiAgICAgICAgaWYgKGV2ZW50LmNsaWVudFggLSBtYXJnaW5zLmxlZnQgPD0gcmVjdC5sZWZ0ICsgZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN4ID0gLWRyYWdTY3JvbGxTcGVlZChyZWN0LmxlZnQgLSBldmVudC5jbGllbnRYKTtcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WCArIG1hcmdpbnMucmlnaHQgPj0gcmVjdC5yaWdodCAtIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeCA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRYIC0gcmVjdC5yaWdodCk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRZIC0gbWFyZ2lucy50b3AgPD0gcmVjdC50b3AgKyBkcmFnU2Nyb2xsTWFyZ2luKVxuICAgICAgICAgICAgc3kgPSAtZHJhZ1Njcm9sbFNwZWVkKHJlY3QudG9wIC0gZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFkgKyBtYXJnaW5zLmJvdHRvbSA+PSByZWN0LmJvdHRvbSAtIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeSA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRZIC0gcmVjdC5ib3R0b20pO1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKHN4LCBzeSk7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFNwZWVkKDAsIDApO1xuICAgICAgICBsZXQgZG9jID0gdGhpcy52aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbiA9IHRoaXMudmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsU3BlZWQoc3gsIHN5KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWQgPSB7IHg6IHN4LCB5OiBzeSB9O1xuICAgICAgICBpZiAoc3ggfHwgc3kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbGluZyA8IDApXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNjcm9sbCgpLCA1MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zY3JvbGxpbmcgPiAtMSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbGluZyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjcm9sbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ICs9IHRoaXMuc2Nyb2xsU3BlZWQueDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCArPSB0aGlzLnNjcm9sbFNwZWVkLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLnNjcm9sbEJ5KHRoaXMuc2Nyb2xsU3BlZWQueCwgdGhpcy5zY3JvbGxTcGVlZC55KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCk7XG4gICAgfVxuICAgIHNraXBBdG9tcyhzZWwpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2VsLnJhbmdlc1tpXSwgdXBkYXRlZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gc2tpcEF0b21pY1Jhbmdlcyh0aGlzLmF0b21zLCByYW5nZS5mcm9tLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zICE9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBza2lwQXRvbWljUmFuZ2VzKHRoaXMuYXRvbXMsIHJhbmdlLmZyb20sIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgdG8gPSBza2lwQXRvbWljUmFuZ2VzKHRoaXMuYXRvbXMsIHJhbmdlLnRvLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSAhPSByYW5nZS5mcm9tIHx8IHRvICE9IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmZyb20gPT0gcmFuZ2UuYW5jaG9yID8gZnJvbSA6IHRvLCByYW5nZS5mcm9tID09IHJhbmdlLmhlYWQgPyBmcm9tIDogdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gc2VsLnJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHJhbmdlc1tpXSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcyA/IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBzZWwubWFpbkluZGV4KSA6IHNlbDtcbiAgICB9XG4gICAgc2VsZWN0KGV2ZW50KSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbGVjdGlvbiA9IHRoaXMuc2tpcEF0b21zKHRoaXMuc3R5bGUuZ2V0KGV2ZW50LCB0aGlzLmV4dGVuZCwgdGhpcy5tdWx0aXBsZSkpO1xuICAgICAgICBpZiAodGhpcy5tdXN0U2VsZWN0IHx8ICFzZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24sIHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3QucG9pbnRlclwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tdXN0U2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KSwgMjApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZHNTZWxlY3Rpb25SYW5nZSh2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IGZhY2V0ID0gdmlldy5zdGF0ZS5mYWNldChkcmFnTW92ZXNTZWxlY3Rpb24kMSk7XG4gICAgcmV0dXJuIGZhY2V0Lmxlbmd0aCA/IGZhY2V0WzBdKGV2ZW50KSA6IGJyb3dzZXIubWFjID8gIWV2ZW50LmFsdEtleSA6ICFldmVudC5jdHJsS2V5O1xufVxuZnVuY3Rpb24gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgeyBtYWluIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAobWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIE9uIGJvdW5kYXJ5IGNsaWNrcywgY2hlY2sgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGluc2lkZSB0aGVcbiAgICAvLyBzZWxlY3Rpb24ncyBjbGllbnQgcmVjdGFuZ2xlc1xuICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICBpZiAoIXNlbCB8fCBzZWwucmFuZ2VDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgcmVjdHMgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgaWYgKHJlY3QubGVmdCA8PSBldmVudC5jbGllbnRYICYmIHJlY3QucmlnaHQgPj0gZXZlbnQuY2xpZW50WCAmJlxuICAgICAgICAgICAgcmVjdC50b3AgPD0gZXZlbnQuY2xpZW50WSAmJiByZWN0LmJvdHRvbSA+PSBldmVudC5jbGllbnRZKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV2ZW50QmVsb25nc1RvRWRpdG9yKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQsIGNWaWV3OyBub2RlICE9IHZpZXcuY29udGVudERPTTsgbm9kZSA9IG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgPT0gMTEgfHwgKChjVmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKSkgJiYgY1ZpZXcuaWdub3JlRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IGhhbmRsZXJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBvYnNlcnZlcnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChicm93c2VyLmlvcyAmJiBicm93c2VyLndlYmtpdF92ZXJzaW9uIDwgNjA0KTtcbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3KSB7XG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgaW5wdXQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcywgaSA9IDEsIHRleHQgPSBzdGF0ZS50b1RleHQoaW5wdXQpO1xuICAgIGxldCBieUxpbmUgPSB0ZXh0LmxpbmVzID09IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoO1xuICAgIGxldCBsaW5ld2lzZSA9IGxhc3RMaW5ld2lzZUNvcHkgIT0gbnVsbCAmJiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmV2ZXJ5KHIgPT4gci5lbXB0eSkgJiYgbGFzdExpbmV3aXNlQ29weSA9PSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgIGxldCBsYXN0TGluZSA9IC0xO1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3RMaW5lKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICBsYXN0TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBzdGF0ZS50b1RleHQoKGJ5TGluZSA/IHRleHQubGluZShpKyspLnRleHQgOiBpbnB1dCkgKyBzdGF0ZS5saW5lQnJlYWspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBpbnNlcnQubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnlMaW5lKSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGV4dC5saW5lKGkrKyk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBsaW5lLnRleHQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgbGluZS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goY2hhbmdlcywge1xuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucGFzdGVcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICB9KTtcbn1cbm9ic2VydmVycy5zY3JvbGwgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcDtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQgPSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0O1xufTtcbmhhbmRsZXJzLmtleWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0XCIpO1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDI3KVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEVzY1ByZXNzID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xub2JzZXJ2ZXJzLnRvdWNoc3RhcnQgPSAodmlldywgZSkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xub2JzZXJ2ZXJzLnRvdWNobW92ZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID4gRGF0ZS5ub3coKSAtIDIwMDApXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gSWdub3JlIHRvdWNoIGludGVyYWN0aW9uXG4gICAgbGV0IHN0eWxlID0gbnVsbDtcbiAgICBmb3IgKGxldCBtYWtlU3R5bGUgb2Ygdmlldy5zdGF0ZS5mYWNldChtb3VzZVNlbGVjdGlvblN0eWxlKSkge1xuICAgICAgICBzdHlsZSA9IG1ha2VTdHlsZSh2aWV3LCBldmVudCk7XG4gICAgICAgIGlmIChzdHlsZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIXN0eWxlICYmIGV2ZW50LmJ1dHRvbiA9PSAwKVxuICAgICAgICBzdHlsZSA9IGJhc2ljTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBsZXQgbXVzdEZvY3VzID0gIXZpZXcuaGFzRm9jdXM7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5zdGFydE1vdXNlU2VsZWN0aW9uKG5ldyBNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCwgc3R5bGUsIG11c3RGb2N1cykpO1xuICAgICAgICBpZiAobXVzdEZvY3VzKVxuICAgICAgICAgICAgdmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4gZm9jdXNQcmV2ZW50U2Nyb2xsKHZpZXcuY29udGVudERPTSkpO1xuICAgICAgICBsZXQgbW91c2VTZWwgPSB2aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb247XG4gICAgICAgIGlmIChtb3VzZVNlbCkge1xuICAgICAgICAgICAgbW91c2VTZWwuc3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIG1vdXNlU2VsLmRyYWdnaW5nID09PSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gcmFuZ2VGb3JDbGljayh2aWV3LCBwb3MsIGJpYXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSAxKSB7IC8vIFNpbmdsZSBjbGlja1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09IDIpIHsgLy8gRG91YmxlIGNsaWNrXG4gICAgICAgIHJldHVybiBncm91cEF0KHZpZXcuc3RhdGUsIHBvcywgYmlhcyk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBUcmlwbGUgY2xpY2tcbiAgICAgICAgbGV0IHZpc3VhbCA9IExpbmVWaWV3LmZpbmQodmlldy5kb2NWaWV3LCBwb3MpLCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0U3RhcnQgOiBsaW5lLmZyb20sIHRvID0gdmlzdWFsID8gdmlzdWFsLnBvc0F0RW5kIDogbGluZS50bztcbiAgICAgICAgaWYgKHRvIDwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoICYmIHRvID09IGxpbmUudG8pXG4gICAgICAgICAgICB0bysrO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5sZXQgaW5zaWRlWSA9ICh5LCByZWN0KSA9PiB5ID49IHJlY3QudG9wICYmIHkgPD0gcmVjdC5ib3R0b207XG5sZXQgaW5zaWRlID0gKHgsIHksIHJlY3QpID0+IGluc2lkZVkoeSwgcmVjdCkgJiYgeCA+PSByZWN0LmxlZnQgJiYgeCA8PSByZWN0LnJpZ2h0O1xuLy8gVHJ5IHRvIGRldGVybWluZSwgZm9yIHRoZSBnaXZlbiBjb29yZGluYXRlcywgYXNzb2NpYXRlZCB3aXRoIHRoZVxuLy8gZ2l2ZW4gcG9zaXRpb24sIHdoZXRoZXIgdGhleSBhcmUgcmVsYXRlZCB0byB0aGUgZWxlbWVudCBiZWZvcmUgb3Jcbi8vIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBwb3NpdGlvbi5cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvblNpZGUodmlldywgcG9zLCB4LCB5KSB7XG4gICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgcG9zKTtcbiAgICBpZiAoIWxpbmUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBvZmYgPSBwb3MgLSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgLy8gTGluZSBib3VuZGFyaWVzIHBvaW50IGludG8gdGhlIGxpbmVcbiAgICBpZiAob2ZmID09IDApXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChvZmYgPT0gbGluZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAvLyBQb3NpdGlvbnMgb24gdG9wIG9mIGFuIGVsZW1lbnQgcG9pbnQgYXQgdGhhdCBlbGVtZW50XG4gICAgbGV0IGJlZm9yZSA9IGxpbmUuY29vcmRzQXQob2ZmLCAtMSk7XG4gICAgaWYgKGJlZm9yZSAmJiBpbnNpZGUoeCwgeSwgYmVmb3JlKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBhZnRlciA9IGxpbmUuY29vcmRzQXQob2ZmLCAxKTtcbiAgICBpZiAoYWZ0ZXIgJiYgaW5zaWRlKHgsIHksIGFmdGVyKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIGxpbmUgd3JhcCBwb2ludC4gUGljayBiZWZvcmUgaWYgdGhlIHBvaW50IGlzXG4gICAgLy8gYmVzaWRlIGl0LlxuICAgIHJldHVybiBiZWZvcmUgJiYgaW5zaWRlWSh5LCBiZWZvcmUpID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gcXVlcnlQb3ModmlldywgZXZlbnQpIHtcbiAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIHJldHVybiB7IHBvcywgYmlhczogZmluZFBvc2l0aW9uU2lkZSh2aWV3LCBwb3MsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpIH07XG59XG5jb25zdCBCYWRNb3VzZURldGFpbCA9IGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExO1xubGV0IGxhc3RNb3VzZURvd24gPSBudWxsLCBsYXN0TW91c2VEb3duQ291bnQgPSAwLCBsYXN0TW91c2VEb3duVGltZSA9IDA7XG5mdW5jdGlvbiBnZXRDbGlja1R5cGUoZXZlbnQpIHtcbiAgICBpZiAoIUJhZE1vdXNlRGV0YWlsKVxuICAgICAgICByZXR1cm4gZXZlbnQuZGV0YWlsO1xuICAgIGxldCBsYXN0ID0gbGFzdE1vdXNlRG93biwgbGFzdFRpbWUgPSBsYXN0TW91c2VEb3duVGltZTtcbiAgICBsYXN0TW91c2VEb3duID0gZXZlbnQ7XG4gICAgbGFzdE1vdXNlRG93blRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBsYXN0TW91c2VEb3duQ291bnQgPSAhbGFzdCB8fCAobGFzdFRpbWUgPiBEYXRlLm5vdygpIC0gNDAwICYmIE1hdGguYWJzKGxhc3QuY2xpZW50WCAtIGV2ZW50LmNsaWVudFgpIDwgMiAmJlxuICAgICAgICBNYXRoLmFicyhsYXN0LmNsaWVudFkgLSBldmVudC5jbGllbnRZKSA8IDIpID8gKGxhc3RNb3VzZURvd25Db3VudCArIDEpICUgMyA6IDE7XG59XG5mdW5jdGlvbiBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gcXVlcnlQb3ModmlldywgZXZlbnQpLCB0eXBlID0gZ2V0Q2xpY2tUeXBlKGV2ZW50KTtcbiAgICBsZXQgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydC5wb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldChldmVudCwgZXh0ZW5kLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSwgcmVtb3ZlZDtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgY3VyLnBvcywgY3VyLmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnBvcyAhPSBjdXIucG9zICYmICFleHRlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRSYW5nZSA9IHJhbmdlRm9yQ2xpY2sodmlldywgc3RhcnQucG9zLCBzdGFydC5iaWFzLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHN0YXJ0UmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSksIHRvID0gTWF0aC5tYXgoc3RhcnRSYW5nZS50bywgcmFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gZnJvbSA8IHJhbmdlLmZyb20gPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHRlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsLnJlcGxhY2VSYW5nZShzdGFydFNlbC5tYWluLmV4dGVuZChyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgZWxzZSBpZiAobXVsdGlwbGUgJiYgdHlwZSA9PSAxICYmIHN0YXJ0U2VsLnJhbmdlcy5sZW5ndGggPiAxICYmIChyZW1vdmVkID0gcmVtb3ZlUmFuZ2VBcm91bmQoc3RhcnRTZWwsIGN1ci5wb3MpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoW3JhbmdlXSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUmFuZ2VBcm91bmQoc2VsLCBwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICAgIGlmIChmcm9tIDw9IHBvcyAmJiB0byA+PSBwb3MpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShzZWwucmFuZ2VzLnNsaWNlKDAsIGkpLmNvbmNhdChzZWwucmFuZ2VzLnNsaWNlKGkgKyAxKSksIHNlbC5tYWluSW5kZXggPT0gaSA/IDAgOiBzZWwubWFpbkluZGV4IC0gKHNlbC5tYWluSW5kZXggPiBpID8gMSA6IDApKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyBzZWxlY3Rpb246IHsgbWFpbjogcmFuZ2UgfSB9ID0gdmlldy5zdGF0ZTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgICBsZXQgY1ZpZXcgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdChldmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoY1ZpZXcgJiYgY1ZpZXcuaXNXaWRnZXQpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gY1ZpZXcucG9zQXRTdGFydCwgdG8gPSBmcm9tICsgY1ZpZXcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZyb20gPj0gcmFuZ2UudG8gfHwgdG8gPD0gcmFuZ2UuZnJvbSlcbiAgICAgICAgICAgICAgICByYW5nZSA9IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHsgaW5wdXRTdGF0ZSB9ID0gdmlldztcbiAgICBpZiAoaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgaW5wdXRTdGF0ZS5tb3VzZVNlbGVjdGlvbi5kcmFnZ2luZyA9IHRydWU7XG4gICAgaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IHJhbmdlO1xuICAgIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJUZXh0XCIsIHZpZXcuc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5oYW5kbGVycy5kcmFnZW5kID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQsIGRpcmVjdCkge1xuICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkcm9wUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGxldCB7IGRyYWdnZWRDb250ZW50IH0gPSB2aWV3LmlucHV0U3RhdGU7XG4gICAgbGV0IGRlbCA9IGRpcmVjdCAmJiBkcmFnZ2VkQ29udGVudCAmJiBkcmFnTW92ZXNTZWxlY3Rpb24odmlldywgZXZlbnQpXG4gICAgICAgID8geyBmcm9tOiBkcmFnZ2VkQ29udGVudC5mcm9tLCB0bzogZHJhZ2dlZENvbnRlbnQudG8gfSA6IG51bGw7XG4gICAgbGV0IGlucyA9IHsgZnJvbTogZHJvcFBvcywgaW5zZXJ0OiB0ZXh0IH07XG4gICAgbGV0IGNoYW5nZXMgPSB2aWV3LnN0YXRlLmNoYW5nZXMoZGVsID8gW2RlbCwgaW5zXSA6IGlucyk7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAtMSksIGhlYWQ6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIDEpIH0sXG4gICAgICAgIHVzZXJFdmVudDogZGVsID8gXCJtb3ZlLmRyb3BcIiA6IFwiaW5wdXQuZHJvcFwiXG4gICAgfSk7XG4gICAgdmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbn1cbmhhbmRsZXJzLmRyb3AgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgZmlsZXMgPSBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCkgeyAvLyBGb3IgYSBmaWxlIGRyb3AsIHJlYWQgdGhlIGZpbGUncyB0ZXh0LlxuICAgICAgICBsZXQgdGV4dCA9IEFycmF5KGZpbGVzLmxlbmd0aCksIHJlYWQgPSAwO1xuICAgICAgICBsZXQgZmluaXNoRmlsZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgrK3JlYWQgPT0gZmlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LmZpbHRlcihzID0+IHMgIT0gbnVsbCkuam9pbih2aWV3LnN0YXRlLmxpbmVCcmVhayksIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmaW5pc2hGaWxlO1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIS9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QocmVhZGVyLnJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRleHRbaV0gPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgIGZpbmlzaEZpbGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdGV4dCA9IGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKFwiVGV4dFwiKTtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGRyb3BUZXh0KHZpZXcsIGV2ZW50LCB0ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5oYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkb1Bhc3RlKHZpZXcsIGRhdGEuZ2V0RGF0YShcInRleHQvcGxhaW5cIikgfHwgZGF0YS5nZXREYXRhKFwidGV4dC91cmktdGV4dFwiKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZVBhc3RlKHZpZXcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpIHtcbiAgICAvLyBUaGUgZXh0cmEgd3JhcHBlciBpcyBzb21laG93IG5lY2Vzc2FyeSBvbiBJRS9FZGdlIHRvIHByZXZlbnQgdGhlXG4gICAgLy8gY29udGVudCBmcm9tIGJlaW5nIG1hbmdsZWQgd2hlbiBpdCBpcyBwdXQgb250byB0aGUgY2xpcGJvYXJkXG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC52YWx1ZSA9IHRleHQ7XG4gICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgdGFyZ2V0LnNlbGVjdGlvbkVuZCA9IHRleHQubGVuZ3RoO1xuICAgIHRhcmdldC5zZWxlY3Rpb25TdGFydCA9IDA7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGNvcGllZFJhbmdlKHN0YXRlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXSwgcmFuZ2VzID0gW10sIGxpbmV3aXNlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIH1cbiAgICBpZiAoIWNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgc2VsZWN0ZWQsIGRvIGEgbGluZS13aXNlIGNvcHlcbiAgICAgICAgbGV0IHVwdG8gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tIH0gb2Ygc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KGZyb20pO1xuICAgICAgICAgICAgaWYgKGxpbmUubnVtYmVyID4gdXB0bykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaChsaW5lLnRleHQpO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgbGluZS50byArIDEpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXB0byA9IGxpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxpbmV3aXNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGV4dDogY29udGVudC5qb2luKHN0YXRlLmxpbmVCcmVhayksIHJhbmdlcywgbGluZXdpc2UgfTtcbn1cbmxldCBsYXN0TGluZXdpc2VDb3B5ID0gbnVsbDtcbmhhbmRsZXJzLmNvcHkgPSBoYW5kbGVycy5jdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBsZXQgeyB0ZXh0LCByYW5nZXMsIGxpbmV3aXNlIH0gPSBjb3BpZWRSYW5nZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAoIXRleHQgJiYgIWxpbmV3aXNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGFzdExpbmV3aXNlQ29weSA9IGxpbmV3aXNlID8gdGV4dCA6IG51bGw7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJjdXRcIiAmJiAhdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBjaGFuZ2VzOiByYW5nZXMsXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIHVzZXJFdmVudDogXCJkZWxldGUuY3V0XCJcbiAgICAgICAgfSk7XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmNsZWFyRGF0YSgpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIHRleHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmNvbnN0IGlzRm9jdXNDaGFuZ2UgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbmZ1bmN0aW9uIGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24oc3RhdGUsIGZvY3VzKSB7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBnZXRFZmZlY3Qgb2Ygc3RhdGUuZmFjZXQoZm9jdXNDaGFuZ2VFZmZlY3QpKSB7XG4gICAgICAgIGxldCBlZmZlY3QgPSBnZXRFZmZlY3Qoc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgaWYgKGVmZmVjdClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0cyA/IHN0YXRlLnVwZGF0ZSh7IGVmZmVjdHMsIGFubm90YXRpb25zOiBpc0ZvY3VzQ2hhbmdlLm9mKHRydWUpIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGV0IGZvY3VzID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgaWYgKGZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24odmlldy5zdGF0ZSwgZm9jdXMpO1xuICAgICAgICAgICAgaWYgKHRyKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgfVxuICAgIH0sIDEwKTtcbn1cbm9ic2VydmVycy5mb2N1cyA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBXaGVuIGZvY3VzaW5nIHJlc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24sIG1vdmUgaXQgYmFjayB0byB3aGVyZSBpdCB3YXNcbiAgICBpZiAoIXZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAmJiAodmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3AgfHwgdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0KSkge1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcDtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XG59O1xub2JzZXJ2ZXJzLmJsdXIgPSB2aWV3ID0+IHtcbiAgICB2aWV3Lm9ic2VydmVyLmNsZWFyU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KTtcbn07XG5vYnNlcnZlcnMuY29tcG9zaXRpb25zdGFydCA9IG9ic2VydmVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IHZpZXcgPT4ge1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9PSBudWxsKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IHRydWU7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgIC8vIEZJWE1FIHBvc3NpYmx5IHNldCBhIHRpbWVvdXQgdG8gY2xlYXIgaXQgYWdhaW4gb24gQW5kcm9pZFxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gMDtcbiAgICB9XG59O1xub2JzZXJ2ZXJzLmNvbXBvc2l0aW9uZW5kID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA9IC0xO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSB0cnVlO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSB2aWV3Lm9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID4gMDtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGJyb3dzZXIuYW5kcm9pZCkge1xuICAgICAgICAvLyBEZWxheSBmbHVzaGluZyBmb3IgYSBiaXQgb24gQW5kcm9pZCBiZWNhdXNlIGl0J2xsIG9mdGVuIGZpcmUgYVxuICAgICAgICAvLyBidW5jaCBvZiBjb250cmFkaWN0b3J5IGNoYW5nZXMgaW4gYSByb3cgYXQgZW5kIG9mIGNvbXBvc2l0b25cbiAgICAgICAgdmlldy5vYnNlcnZlci5mbHVzaFNvb24oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSkge1xuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBwZW5kaW5nIHJlY29yZHMsIHNjaGVkdWxlIGEgZmx1c2guXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdmlldy5vYnNlcnZlci5mbHVzaCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgbWFrZSBzdXJlIHRoYXQsIGlmIG5vIGNoYW5nZXMgY29tZSBpbiBzb29uLCB0aGVcbiAgICAgICAgLy8gY29tcG9zaXRpb24gdmlldyBpcyBjbGVhcmVkLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCAmJiB2aWV3LmRvY1ZpZXcuaGFzQ29tcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGUoW10pO1xuICAgICAgICB9LCA1MCk7XG4gICAgfVxufTtcbm9ic2VydmVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Q29udGV4dE1lbnUgPSBEYXRlLm5vdygpO1xufTtcbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIEJlY2F1c2UgQ2hyb21lIEFuZHJvaWQgZG9lc24ndCBmaXJlIHVzZWZ1bCBrZXkgZXZlbnRzLCB1c2VcbiAgICAvLyBiZWZvcmVpbnB1dCB0byBkZXRlY3QgYmFja3NwYWNlIChhbmQgcG9zc2libHkgZW50ZXIgYW5kIGRlbGV0ZSxcbiAgICAvLyBidXQgdGhvc2UgdXN1YWxseSBkb24ndCBldmVuIHNlZW0gdG8gZmlyZSBiZWZvcmVpbnB1dCBldmVudHMgYXRcbiAgICAvLyB0aGUgbW9tZW50KSBhbmQgZmFrZSBhIGtleSBldmVudCBmb3IgaXQuXG4gICAgLy9cbiAgICAvLyAocHJldmVudERlZmF1bHQgb24gYmVmb3JlaW5wdXQsIHRob3VnaCBzdXBwb3J0ZWQgaW4gdGhlIHNwZWMsXG4gICAgLy8gc2VlbXMgdG8gZG8gbm90aGluZyBhdCBhbGwgb24gQ2hyb21lKS5cbiAgICBsZXQgcGVuZGluZztcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkICYmIChwZW5kaW5nID0gUGVuZGluZ0tleXMuZmluZChrZXkgPT4ga2V5LmlucHV0VHlwZSA9PSBldmVudC5pbnB1dFR5cGUpKSkge1xuICAgICAgICB2aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShwZW5kaW5nLmtleSwgcGVuZGluZy5rZXlDb2RlKTtcbiAgICAgICAgaWYgKHBlbmRpbmcua2V5ID09IFwiQmFja3NwYWNlXCIgfHwgcGVuZGluZy5rZXkgPT0gXCJEZWxldGVcIikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0Vmlld0hlaWdodCA9ICgoX2EgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDA7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gQmFja3NwYWNpbmcgbmVhciB1bmVkaXRhYmxlIG5vZGVzIG9uIENocm9tZSBBbmRyb2lkIHNvbWV0aW1lc1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlcyB0aGUgdmlydHVhbCBrZXlib2FyZC4gVGhpcyB0cmllcyB0byBjcnVkZWx5IGRldGVjdFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgYW5kIHJlZm9jdXMgdG8gZ2V0IGl0IGJhY2suXG4gICAgICAgICAgICAgICAgaWYgKCgoKF9hID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwKSA+IHN0YXJ0Vmlld0hlaWdodCArIDEwICYmIHZpZXcuaGFzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGFwcGxpZWRGaXJlZm94SGFjayA9IC8qQF9fUFVSRV9fKi9uZXcgU2V0O1xuLy8gSW4gRmlyZWZveCwgd2hlbiBjdXQvY29weSBoYW5kbGVycyBhcmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50LCB0aGF0XG4vLyBzb21laG93IGF2b2lkcyBhIGJ1ZyB3aGVyZSB0aG9zZSBldmVudHMgYXJlbid0IGZpcmVkIHdoZW4gdGhlXG4vLyBzZWxlY3Rpb24gaXMgZW1wdHkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzEwODJcbi8vIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05OTU5NjFcbmZ1bmN0aW9uIGZpcmVmb3hDb3B5Q3V0SGFjayhkb2MpIHtcbiAgICBpZiAoIWFwcGxpZWRGaXJlZm94SGFjay5oYXMoZG9jKSkge1xuICAgICAgICBhcHBsaWVkRmlyZWZveEhhY2suYWRkKGRvYyk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwiY29weVwiLCAoKSA9PiB7IH0pO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCAoKSA9PiB7IH0pO1xuICAgIH1cbn1cblxuY29uc3Qgd3JhcHBpbmdXaGl0ZVNwYWNlID0gW1wicHJlLXdyYXBcIiwgXCJub3JtYWxcIiwgXCJwcmUtbGluZVwiLCBcImJyZWFrLXNwYWNlc1wiXTtcbmNsYXNzIEhlaWdodE9yYWNsZSB7XG4gICAgY29uc3RydWN0b3IobGluZVdyYXBwaW5nKSB7XG4gICAgICAgIHRoaXMubGluZVdyYXBwaW5nID0gbGluZVdyYXBwaW5nO1xuICAgICAgICB0aGlzLmRvYyA9IFRleHQuZW1wdHk7XG4gICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSAxNDsgLy8gVGhlIGhlaWdodCBvZiBhbiBlbnRpcmUgbGluZSAobGluZS1oZWlnaHQpXG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gNztcbiAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gMTQ7IC8vIFRoZSBoZWlnaHQgb2YgdGhlIGFjdHVhbCBmb250IChmb250LXNpemUpXG4gICAgICAgIHRoaXMubGluZUxlbmd0aCA9IDMwO1xuICAgICAgICAvLyBVc2VkIHRvIHRyYWNrLCBkdXJpbmcgdXBkYXRlSGVpZ2h0LCBpZiBhbnkgYWN0dWFsIGhlaWdodHMgY2hhbmdlZFxuICAgICAgICB0aGlzLmhlaWdodENoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaGVpZ2h0Rm9yR2FwKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHRoaXMuZG9jLmxpbmVBdCh0bykubnVtYmVyIC0gdGhpcy5kb2MubGluZUF0KGZyb20pLm51bWJlciArIDE7XG4gICAgICAgIGlmICh0aGlzLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgIGxpbmVzICs9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoKHRvIC0gZnJvbSkgLSAobGluZXMgKiB0aGlzLmxpbmVMZW5ndGggKiAwLjUpKSAvIHRoaXMubGluZUxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0ICogbGluZXM7XG4gICAgfVxuICAgIGhlaWdodEZvckxpbmUobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsZXQgbGluZXMgPSAxICsgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZW5ndGggLSB0aGlzLmxpbmVMZW5ndGgpIC8gKHRoaXMubGluZUxlbmd0aCAtIDUpKSk7XG4gICAgICAgIHJldHVybiBsaW5lcyAqIHRoaXMubGluZUhlaWdodDtcbiAgICB9XG4gICAgc2V0RG9jKGRvYykgeyB0aGlzLmRvYyA9IGRvYzsgcmV0dXJuIHRoaXM7IH1cbiAgICBtdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpIHtcbiAgICAgICAgcmV0dXJuICh3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xKSAhPSB0aGlzLmxpbmVXcmFwcGluZztcbiAgICB9XG4gICAgbXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSB7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGggPSBsaW5lSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSkgeyAvLyBSb3VuZCB0byAuMSBwaXhlbHNcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SGVpZ2h0O1xuICAgIH1cbiAgICByZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCwgbGluZUxlbmd0aCwga25vd25IZWlnaHRzKSB7XG4gICAgICAgIGxldCBsaW5lV3JhcHBpbmcgPSB3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IE1hdGgucm91bmQobGluZUhlaWdodCkgIT0gTWF0aC5yb3VuZCh0aGlzLmxpbmVIZWlnaHQpIHx8IHRoaXMubGluZVdyYXBwaW5nICE9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gY2hhcldpZHRoO1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSB0ZXh0SGVpZ2h0O1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtub3duSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0ga25vd25IZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoIDwgMClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn1cbi8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYnkgYHVwZGF0ZUhlaWdodGAgdG8gbWFrZSBET00gbWVhc3VyZW1lbnRzXG4vLyBhcnJpdmUgYXQgdGhlIHJpZ2h0IG5pZGVzLiBUaGUgYGhlaWdodHNgIGFycmF5IGlzIGEgc2VxdWVuY2Ugb2Zcbi8vIGJsb2NrIGhlaWdodHMsIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gYGZyb21gLlxuY2xhc3MgTWVhc3VyZWRIZWlnaHRzIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCBoZWlnaHRzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaGVpZ2h0cyA9IGhlaWdodHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgbW9yZSgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmhlaWdodHMubGVuZ3RoOyB9XG59XG4vKipcblJlY29yZCB1c2VkIHRvIHJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrLWxldmVsIGVsZW1lbnRcbmluIHRoZSBlZGl0b3Igdmlldy5cbiovXG5jbGFzcyBCbG9ja0luZm8ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnQpLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBJdHMgaGVpZ2h0LlxuICAgICovXG4gICAgaGVpZ2h0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWwgV2VpcmQgcGFja2VkIGZpZWxkIHRoYXQgaG9sZHMgYW4gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICBmb3IgY29tcG9zaXRlIGJsb2NrcywgYSBkZWNvcmF0aW9uIGZvciBibG9jayB3aWRnZXRzLCBhbmQgYVxuICAgIG51bWJlciBpbmRpY2F0aW5nIHRoZSBhbW91bnQgb2Ygd2lkZ2V0LWNyZWF0ZSBsaW5lIGJyZWFrcyBmb3JcbiAgICB0ZXh0IGJsb2Nrcy5cbiAgICAqL1xuICAgIF9jb250ZW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBfY29udGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgZWxlbWVudCB0aGlzIGlzLiBXaGVuIHF1ZXJ5aW5nIGxpbmVzLCB0aGlzIG1heSBiZVxuICAgIGFuIGFycmF5IG9mIGFsbCB0aGUgYmxvY2tzIHRoYXQgbWFrZSB1cCB0aGUgbGluZS5cbiAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT0gXCJudW1iZXJcIiA/IEJsb2NrVHlwZS5UZXh0IDpcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5fY29udGVudCkgPyB0aGlzLl9jb250ZW50IDogdGhpcy5fY29udGVudC50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBlbGVtZW50IGFzIGEgZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBib3R0b20gcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYm90dG9tKCkgeyByZXR1cm4gdGhpcy50b3AgKyB0aGlzLmhlaWdodDsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSB3aWRnZXQgYmxvY2ssIHRoaXMgd2lsbCByZXR1cm4gdGhlIHdpZGdldFxuICAgIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAqL1xuICAgIGdldCB3aWRnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50IGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uID8gdGhpcy5fY29udGVudC53aWRnZXQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgdGV4dGJsb2NrLCB0aGlzIGhvbGRzIHRoZSBudW1iZXIgb2YgbGluZSBicmVha3NcbiAgICB0aGF0IGFwcGVhciBpbiB3aWRnZXRzIGluc2lkZSB0aGUgYmxvY2suXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0TGluZUJyZWFrcygpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9jb250ZW50ID09IFwibnVtYmVyXCIgPyB0aGlzLl9jb250ZW50IDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gKEFycmF5LmlzQXJyYXkodGhpcy5fY29udGVudCkgPyB0aGlzLl9jb250ZW50IDogW3RoaXNdKVxuICAgICAgICAgICAgLmNvbmNhdChBcnJheS5pc0FycmF5KG90aGVyLl9jb250ZW50KSA/IG90aGVyLl9jb250ZW50IDogW290aGVyXSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKHRoaXMuZnJvbSwgdGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGgsIHRoaXMudG9wLCB0aGlzLmhlaWdodCArIG90aGVyLmhlaWdodCwgY29udGVudCk7XG4gICAgfVxufVxudmFyIFF1ZXJ5VHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFF1ZXJ5VHlwZSkge1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc1wiXSA9IDBdID0gXCJCeVBvc1wiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeUhlaWdodFwiXSA9IDFdID0gXCJCeUhlaWdodFwiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc05vSGVpZ2h0XCJdID0gMl0gPSBcIkJ5UG9zTm9IZWlnaHRcIjtcbnJldHVybiBRdWVyeVR5cGV9KShRdWVyeVR5cGUgfHwgKFF1ZXJ5VHlwZSA9IHt9KSk7XG5jb25zdCBFcHNpbG9uID0gMWUtMztcbmNsYXNzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCAvLyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY292ZXJlZFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHRoaXMgcGFydCBvZiB0aGUgZG9jdW1lbnRcbiAgICBmbGFncyA9IDIgLyogRmxhZy5PdXRkYXRlZCAqLykge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgZ2V0IG91dGRhdGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pID4gMDsgfVxuICAgIHNldCBvdXRkYXRlZCh2YWx1ZSkgeyB0aGlzLmZsYWdzID0gKHZhbHVlID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkgfCAodGhpcy5mbGFncyAmIH4yIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pOyB9XG4gICAgc2V0SGVpZ2h0KG9yYWNsZSwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLmhlaWdodCAtIGhlaWdodCkgPiBFcHNpbG9uKVxuICAgICAgICAgICAgICAgIG9yYWNsZS5oZWlnaHRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJhc2UgY2FzZSBpcyB0byByZXBsYWNlIGEgbGVhZiBub2RlLCB3aGljaCBzaW1wbHkgYnVpbGRzIGEgdHJlZVxuICAgIC8vIGZyb20gdGhlIG5ldyBub2RlcyBhbmQgcmV0dXJucyB0aGF0IChIZWlnaHRNYXBCcmFuY2ggYW5kXG4gICAgLy8gSGVpZ2h0TWFwR2FwIG92ZXJyaWRlIHRoaXMgdG8gYWN0dWFsbHkgdXNlIGZyb20vdG8pXG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICB9XG4gICAgLy8gQWdhaW4sIHRoZXNlIGFyZSBiYXNlIGNhc2VzLCBhbmQgYXJlIG92ZXJyaWRkZW4gZm9yIGJyYW5jaCBhbmQgZ2FwIG5vZGVzLlxuICAgIGRlY29tcG9zZUxlZnQoX3RvLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBkZWNvbXBvc2VSaWdodChfZnJvbSwgcmVzdWx0KSB7IHJlc3VsdC5wdXNoKHRoaXMpOyB9XG4gICAgYXBwbHlDaGFuZ2VzKGRlY29yYXRpb25zLCBvbGREb2MsIG9yYWNsZSwgY2hhbmdlcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLCBkb2MgPSBvcmFjbGUuZG9jO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9ID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9yYWNsZS5zZXREb2Mob2xkRG9jKSwgMCwgMCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQudG8gPj0gdG9BID8gc3RhcnQgOiBtZS5saW5lQXQodG9BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIHRvQiArPSBlbmQudG8gLSB0b0E7XG4gICAgICAgICAgICB0b0EgPSBlbmQudG87XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgc3RhcnQuZnJvbSA8PSBjaGFuZ2VzW2kgLSAxXS50b0EpIHtcbiAgICAgICAgICAgICAgICBmcm9tQSA9IGNoYW5nZXNbaSAtIDFdLmZyb21BO1xuICAgICAgICAgICAgICAgIGZyb21CID0gY2hhbmdlc1tpIC0gMV0uZnJvbUI7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQSA8IHN0YXJ0LmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21CICs9IHN0YXJ0LmZyb20gLSBmcm9tQTtcbiAgICAgICAgICAgIGZyb21BID0gc3RhcnQuZnJvbTtcbiAgICAgICAgICAgIGxldCBub2RlcyA9IE5vZGVCdWlsZGVyLmJ1aWxkKG9yYWNsZS5zZXREb2MoZG9jKSwgZGVjb3JhdGlvbnMsIGZyb21CLCB0b0IpO1xuICAgICAgICAgICAgbWUgPSBtZS5yZXBsYWNlKGZyb21BLCB0b0EsIG5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWUudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbXB0eSgpIHsgcmV0dXJuIG5ldyBIZWlnaHRNYXBUZXh0KDAsIDApOyB9XG4gICAgLy8gbm9kZXMgdXNlcyBudWxsIHZhbHVlcyB0byBpbmRpY2F0ZSB0aGUgcG9zaXRpb24gb2YgbGluZSBicmVha3MuXG4gICAgLy8gVGhlcmUgYXJlIG5ldmVyIGxpbmUgYnJlYWtzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGFycmF5LCBvclxuICAgIC8vIHR3byBsaW5lIGJyZWFrcyBuZXh0IHRvIGVhY2ggb3RoZXIsIGFuZCB0aGUgYXJyYXkgaXNuJ3QgYWxsb3dlZFxuICAgIC8vIHRvIGJlIGVtcHR5IChzYW1lIHJlc3RyaWN0aW9ucyBhcyByZXR1cm4gdmFsdWUgZnJvbSB0aGUgYnVpbGRlcikuXG4gICAgc3RhdGljIG9mKG5vZGVzKSB7XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICAgICAgbGV0IGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoLCBiZWZvcmUgPSAwLCBhZnRlciA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChpID09IGopIHtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlID4gYWZ0ZXIgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgbnVsbCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoLS1pLCAxLCBzcGxpdC5sZWZ0LCBzcGxpdC5yaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGogKz0gMSArIHNwbGl0LmJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgLT0gc3BsaXQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXIgPiBiZWZvcmUgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGxpdCA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQuYnJlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaiwgMSwgc3BsaXQubGVmdCwgbnVsbCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaiwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDIgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgLT0gc3BsaXQuc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlZm9yZSA8IGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1tpKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2Rlc1stLWpdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICBhZnRlciArPSBuZXh0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJyayA9IDA7XG4gICAgICAgIGlmIChub2Rlc1tpIC0gMV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2Rlc1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmsgPSAxO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGVpZ2h0TWFwQnJhbmNoKEhlaWdodE1hcC5vZihub2Rlcy5zbGljZSgwLCBpKSksIGJyaywgSGVpZ2h0TWFwLm9mKG5vZGVzLnNsaWNlKGopKSk7XG4gICAgfVxufVxuSGVpZ2h0TWFwLnByb3RvdHlwZS5zaXplID0gMTtcbmNsYXNzIEhlaWdodE1hcEJsb2NrIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCwgZGVjbykge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuZGVjbyA9IGRlY287XG4gICAgfVxuICAgIGJsb2NrQXQoX2hlaWdodCwgX29yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8ob2Zmc2V0LCB0aGlzLmxlbmd0aCwgdG9wLCB0aGlzLmhlaWdodCwgdGhpcy5kZWNvIHx8IDApO1xuICAgIH1cbiAgICBsaW5lQXQoX3ZhbHVlLCBfdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KDAsIG9yYWNsZSwgdG9wLCBvZmZzZXQpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBpZiAoZnJvbSA8PSBvZmZzZXQgKyB0aGlzLmxlbmd0aCAmJiB0byA+PSBvZmZzZXQpXG4gICAgICAgICAgICBmKHRoaXMuYmxvY2tBdCgwLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIF9mb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXSk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGJsb2NrKCR7dGhpcy5sZW5ndGh9KWA7IH1cbn1cbmNsYXNzIEhlaWdodE1hcFRleHQgZXh0ZW5kcyBIZWlnaHRNYXBCbG9jayB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQsIG51bGwpO1xuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IDA7IC8vIEFtb3VudCBvZiBjb2xsYXBzZWQgY29udGVudCBpbiB0aGUgbGluZVxuICAgICAgICB0aGlzLndpZGdldEhlaWdodCA9IDA7IC8vIE1heGltdW0gaW5saW5lIHdpZGdldCBoZWlnaHRcbiAgICAgICAgdGhpcy5icmVha3MgPSAwOyAvLyBOdW1iZXIgb2Ygd2lkZ2V0LWludHJvZHVjZWQgbGluZSBicmVha3Mgb24gdGhlIGxpbmVcbiAgICB9XG4gICAgYmxvY2tBdChfaGVpZ2h0LCBfb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhvZmZzZXQsIHRoaXMubGVuZ3RoLCB0b3AsIHRoaXMuaGVpZ2h0LCB0aGlzLmJyZWFrcyk7XG4gICAgfVxuICAgIHJlcGxhY2UoX2Zyb20sIF90bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1swXTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAxICYmIChub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCB8fCBub2RlIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmIChub2RlLmZsYWdzICYgNCAvKiBGbGFnLlNpbmdsZUxpbmUgKi8pKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5sZW5ndGggLSBub2RlLmxlbmd0aCkgPCAxMCkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyBIZWlnaHRNYXBUZXh0KG5vZGUubGVuZ3RoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgICAgICBub2RlLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KG9yYWNsZSwgTWF0aC5tYXgodGhpcy53aWRnZXRIZWlnaHQsIG9yYWNsZS5oZWlnaHRGb3JMaW5lKHRoaXMubGVuZ3RoIC0gdGhpcy5jb2xsYXBzZWQpKSArXG4gICAgICAgICAgICAgICAgdGhpcy5icmVha3MgKiBvcmFjbGUubGluZUhlaWdodCk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYGxpbmUoJHt0aGlzLmxlbmd0aH0ke3RoaXMuY29sbGFwc2VkID8gLXRoaXMuY29sbGFwc2VkIDogXCJcIn0ke3RoaXMud2lkZ2V0SGVpZ2h0ID8gXCI6XCIgKyB0aGlzLndpZGdldEhlaWdodCA6IFwiXCJ9KWA7XG4gICAgfVxufVxuY2xhc3MgSGVpZ2h0TWFwR2FwIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHsgc3VwZXIobGVuZ3RoLCAwKTsgfVxuICAgIGhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGZpcnN0TGluZSA9IG9yYWNsZS5kb2MubGluZUF0KG9mZnNldCkubnVtYmVyLCBsYXN0TGluZSA9IG9yYWNsZS5kb2MubGluZUF0KG9mZnNldCArIHRoaXMubGVuZ3RoKS5udW1iZXI7XG4gICAgICAgIGxldCBsaW5lcyA9IGxhc3RMaW5lIC0gZmlyc3RMaW5lICsgMTtcbiAgICAgICAgbGV0IHBlckxpbmUsIHBlckNoYXIgPSAwO1xuICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgbGV0IHRvdGFsUGVyTGluZSA9IE1hdGgubWluKHRoaXMuaGVpZ2h0LCBvcmFjbGUubGluZUhlaWdodCAqIGxpbmVzKTtcbiAgICAgICAgICAgIHBlckxpbmUgPSB0b3RhbFBlckxpbmUgLyBsaW5lcztcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IGxpbmVzICsgMSlcbiAgICAgICAgICAgICAgICBwZXJDaGFyID0gKHRoaXMuaGVpZ2h0IC0gdG90YWxQZXJMaW5lKSAvICh0aGlzLmxlbmd0aCAtIGxpbmVzIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwZXJMaW5lID0gdGhpcy5oZWlnaHQgLyBsaW5lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaXJzdExpbmUsIGxhc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH07XG4gICAgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgbGFzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGlmIChvcmFjbGUubGluZVdyYXBwaW5nKSB7XG4gICAgICAgICAgICBsZXQgZ3Vlc3MgPSBvZmZzZXQgKyBNYXRoLnJvdW5kKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChoZWlnaHQgLSB0b3ApIC8gdGhpcy5oZWlnaHQpKSAqIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQoZ3Vlc3MpLCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIGxpbmUubGVuZ3RoICogcGVyQ2hhcjtcbiAgICAgICAgICAgIGxldCBsaW5lVG9wID0gTWF0aC5tYXgodG9wLCBoZWlnaHQgLSBsaW5lSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhsaW5lLmZyb20sIGxpbmUubGVuZ3RoLCBsaW5lVG9wLCBsaW5lSGVpZ2h0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGFzdExpbmUgLSBmaXJzdExpbmUsIE1hdGguZmxvb3IoKGhlaWdodCAtIHRvcCkgLyBwZXJMaW5lKSkpO1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgbGVuZ3RoIH0gPSBvcmFjbGUuZG9jLmxpbmUoZmlyc3RMaW5lICsgbGluZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCBsZW5ndGgsIHRvcCArIHBlckxpbmUgKiBsaW5lLCBwZXJMaW5lLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCh2YWx1ZSwgb3JhY2xlLCB0b3AsIG9mZnNldCk7XG4gICAgICAgIGlmICh0eXBlID09IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gb3JhY2xlLmRvYy5saW5lQXQodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgdG8gLSBmcm9tLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQodmFsdWUpLCBsaW5lSGVpZ2h0ID0gcGVyTGluZSArIGxpbmUubGVuZ3RoICogcGVyQ2hhcjtcbiAgICAgICAgbGV0IGxpbmVzQWJvdmUgPSBsaW5lLm51bWJlciAtIGZpcnN0TGluZTtcbiAgICAgICAgbGV0IGxpbmVUb3AgPSB0b3AgKyBwZXJMaW5lICogbGluZXNBYm92ZSArIHBlckNoYXIgKiAobGluZS5mcm9tIC0gb2Zmc2V0IC0gbGluZXNBYm92ZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIE1hdGgubWF4KHRvcCwgTWF0aC5taW4obGluZVRvcCwgdG9wICsgdGhpcy5oZWlnaHQgLSBsaW5lSGVpZ2h0KSksIGxpbmVIZWlnaHQsIDApO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgoZnJvbSwgb2Zmc2V0KTtcbiAgICAgICAgdG8gPSBNYXRoLm1pbih0bywgb2Zmc2V0ICsgdGhpcy5sZW5ndGgpO1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIHBlckxpbmUsIHBlckNoYXIgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGZyb20sIGxpbmVUb3AgPSB0b3A7IHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gb3JhY2xlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBsaW5lc0Fib3ZlID0gbGluZS5udW1iZXIgLSBmaXJzdExpbmU7XG4gICAgICAgICAgICAgICAgbGluZVRvcCArPSBwZXJMaW5lICogbGluZXNBYm92ZSArIHBlckNoYXIgKiAoZnJvbSAtIG9mZnNldCAtIGxpbmVzQWJvdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgcGVyQ2hhciAqIGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgZihuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIGxpbmVUb3AsIGxpbmVIZWlnaHQsIDApKTtcbiAgICAgICAgICAgIGxpbmVUb3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMubGVuZ3RoIC0gdG87XG4gICAgICAgIGlmIChhZnRlciA+IDApIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSA9IG5ldyBIZWlnaHRNYXBHYXAobGFzdC5sZW5ndGggKyBhZnRlcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGFmdGVyIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tID4gMCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gbm9kZXNbMF07XG4gICAgICAgICAgICBpZiAoZmlyc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZXNbMF0gPSBuZXcgSGVpZ2h0TWFwR2FwKGZyb20gKyBmaXJzdC5sZW5ndGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnVuc2hpZnQobmV3IEhlaWdodE1hcEdhcChmcm9tIC0gMSksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBIZWlnaHRNYXAub2Yobm9kZXMpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IEhlaWdodE1hcEdhcCh0byAtIDEpLCBudWxsKTtcbiAgICB9XG4gICAgZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAodGhpcy5sZW5ndGggLSBmcm9tIC0gMSkpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBmb3JjZSA9IGZhbHNlLCBtZWFzdXJlZCkge1xuICAgICAgICBsZXQgZW5kID0gb2Zmc2V0ICsgdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIHRoaXMubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgaW4gcGFydCBvZiB0aGlzIGdhcCB3aXRoIG1lYXN1cmVkIGxpbmVzLiBXZSBrbm93IHRoZXJlXG4gICAgICAgICAgICAvLyBjYW4ndCBiZSB3aWRnZXRzIG9yIGNvbGxhcHNlZCByYW5nZXMgaW4gdGhvc2UgbGluZXMsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHRoZXkgd291bGQgYWxyZWFkeSBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGhlaWdodG1hcCAoZ2Fwc1xuICAgICAgICAgICAgLy8gb25seSBjb250YWluIHBsYWluIHRleHQpLlxuICAgICAgICAgICAgbGV0IG5vZGVzID0gW10sIHBvcyA9IE1hdGgubWF4KG9mZnNldCwgbWVhc3VyZWQuZnJvbSksIHNpbmdsZUhlaWdodCA9IC0xO1xuICAgICAgICAgICAgaWYgKG1lYXN1cmVkLmZyb20gPiBvZmZzZXQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgSGVpZ2h0TWFwR2FwKG1lYXN1cmVkLmZyb20gLSBvZmZzZXQgLSAxKS51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQpKTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPD0gZW5kICYmIG1lYXN1cmVkLm1vcmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gb3JhY2xlLmRvYy5saW5lQXQocG9zKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0c1ttZWFzdXJlZC5pbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlSGVpZ2h0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gc2luZ2xlSGVpZ2h0KSA+PSBFcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVIZWlnaHQgPSAtMjtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IG5ldyBIZWlnaHRNYXBUZXh0KGxlbiwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBsaW5lLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kKVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcChlbmQgLSBwb3MpLnVwZGF0ZUhlaWdodChvcmFjbGUsIHBvcykpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgICAgICBpZiAoc2luZ2xlSGVpZ2h0IDwgMCB8fCBNYXRoLmFicyhyZXN1bHQuaGVpZ2h0IC0gdGhpcy5oZWlnaHQpID49IEVwc2lsb24gfHxcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhzaW5nbGVIZWlnaHQgLSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpLnBlckxpbmUpID49IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG9yYWNsZS5oZWlnaHRGb3JHYXAob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLmxlbmd0aCkpO1xuICAgICAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIGBnYXAoJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwQnJhbmNoIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCBicmssIHJpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGxlZnQubGVuZ3RoICsgYnJrICsgcmlnaHQubGVuZ3RoLCBsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodCwgYnJrIHwgKGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQgPyAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8gOiAwKSk7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5zaXplID0gbGVmdC5zaXplICsgcmlnaHQuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IGJyZWFrKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDEgLyogRmxhZy5CcmVhayAqLzsgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBtaWQgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gaGVpZ2h0IDwgbWlkID8gdGhpcy5sZWZ0LmJsb2NrQXQoaGVpZ2h0LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KVxuICAgICAgICAgICAgOiB0aGlzLnJpZ2h0LmJsb2NrQXQoaGVpZ2h0LCBvcmFjbGUsIG1pZCwgb2Zmc2V0ICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWspO1xuICAgIH1cbiAgICBsaW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHJpZ2h0VG9wID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodCwgcmlnaHRPZmZzZXQgPSBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcbiAgICAgICAgbGV0IGxlZnQgPSB0eXBlID09IFF1ZXJ5VHlwZS5CeUhlaWdodCA/IHZhbHVlIDwgcmlnaHRUb3AgOiB2YWx1ZSA8IHJpZ2h0T2Zmc2V0O1xuICAgICAgICBsZXQgYmFzZSA9IGxlZnQgPyB0aGlzLmxlZnQubGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KVxuICAgICAgICAgICAgOiB0aGlzLnJpZ2h0LmxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpO1xuICAgICAgICBpZiAodGhpcy5icmVhayB8fCAobGVmdCA/IGJhc2UudG8gPCByaWdodE9mZnNldCA6IGJhc2UuZnJvbSA+IHJpZ2h0T2Zmc2V0KSlcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBsZXQgc3ViUXVlcnkgPSB0eXBlID09IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0ID8gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgOiBRdWVyeVR5cGUuQnlQb3M7XG4gICAgICAgIGlmIChsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIGJhc2Uuam9pbih0aGlzLnJpZ2h0LmxpbmVBdChyaWdodE9mZnNldCwgc3ViUXVlcnksIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgb3JhY2xlLCB0b3AsIG9mZnNldCkuam9pbihiYXNlKTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgbGV0IHJpZ2h0VG9wID0gdG9wICsgdGhpcy5sZWZ0LmhlaWdodCwgcmlnaHRPZmZzZXQgPSBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKHRoaXMuYnJlYWspIHtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgcmlnaHRPZmZzZXQpXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKTtcbiAgICAgICAgICAgIGlmICh0byA+PSByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCwgZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gdGhpcy5saW5lQXQocmlnaHRPZmZzZXQsIFF1ZXJ5VHlwZS5CeVBvcywgb3JhY2xlLCB0b3AsIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IG1pZC5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5mb3JFYWNoTGluZShmcm9tLCBtaWQuZnJvbSAtIDEsIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKG1pZC50byA+PSBmcm9tICYmIG1pZC5mcm9tIDw9IHRvKVxuICAgICAgICAgICAgICAgIGYobWlkKTtcbiAgICAgICAgICAgIGlmICh0byA+IG1pZC50bylcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hMaW5lKG1pZC50byArIDEsIHRvLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCwgZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IHJpZ2h0U3RhcnQgPSB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcbiAgICAgICAgaWYgKHRvIDwgcmlnaHRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdC5yZXBsYWNlKGZyb20sIHRvLCBub2RlcyksIHRoaXMucmlnaHQpO1xuICAgICAgICBpZiAoZnJvbSA+IHRoaXMubGVmdC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQsIHRoaXMucmlnaHQucmVwbGFjZShmcm9tIC0gcmlnaHRTdGFydCwgdG8gLSByaWdodFN0YXJ0LCBub2RlcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlTGVmdChmcm9tLCByZXN1bHQpO1xuICAgICAgICBsZXQgbGVmdCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IG5vZGUgb2Ygbm9kZXMpXG4gICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgbWVyZ2VHYXBzKHJlc3VsdCwgbGVmdCAtIDEpO1xuICAgICAgICBpZiAodG8gPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJpZ2h0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZGVjb21wb3NlUmlnaHQodG8sIHJlc3VsdCk7XG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihyZXN1bHQpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgICAgICBpZiAodG8gPD0gbGVmdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5sZWZ0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWspIHtcbiAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIGlmICh0byA+PSBsZWZ0KVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0byA+IGxlZnQpXG4gICAgICAgICAgICB0aGlzLnJpZ2h0LmRlY29tcG9zZUxlZnQodG8gLSBsZWZ0LCByZXN1bHQpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQubGVuZ3RoLCByaWdodCA9IGxlZnQgKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAoZnJvbSA+PSByaWdodClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmRlY29tcG9zZVJpZ2h0KGZyb20gLSByaWdodCwgcmVzdWx0KTtcbiAgICAgICAgaWYgKGZyb20gPCBsZWZ0KVxuICAgICAgICAgICAgdGhpcy5sZWZ0LmRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrICYmIGZyb20gPCByaWdodClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnJpZ2h0KTtcbiAgICB9XG4gICAgYmFsYW5jZWQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKGxlZnQuc2l6ZSA+IDIgKiByaWdodC5zaXplIHx8IHJpZ2h0LnNpemUgPiAyICogbGVmdC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZih0aGlzLmJyZWFrID8gW2xlZnQsIG51bGwsIHJpZ2h0XSA6IFtsZWZ0LCByaWdodF0pO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbGVmdC5oZWlnaHQgKyByaWdodC5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkO1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgdGhpcy5icmVhayArIHJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCB7IGxlZnQsIHJpZ2h0IH0gPSB0aGlzLCByaWdodFN0YXJ0ID0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrLCByZWJhbGFuY2UgPSBudWxsO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gbGVmdCA9IGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UpO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSByaWdodFN0YXJ0ICsgcmlnaHQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSByaWdodCA9IHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlKTtcbiAgICAgICAgaWYgKHJlYmFsYW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgdGhpcy5yaWdodC5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5sZWZ0ICsgKHRoaXMuYnJlYWsgPyBcIiBcIiA6IFwiLVwiKSArIHRoaXMucmlnaHQ7IH1cbn1cbmZ1bmN0aW9uIG1lcmdlR2Fwcyhub2RlcywgYXJvdW5kKSB7XG4gICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgaWYgKG5vZGVzW2Fyb3VuZF0gPT0gbnVsbCAmJlxuICAgICAgICAoYmVmb3JlID0gbm9kZXNbYXJvdW5kIC0gMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmXG4gICAgICAgIChhZnRlciA9IG5vZGVzW2Fyb3VuZCArIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgbm9kZXMuc3BsaWNlKGFyb3VuZCAtIDEsIDMsIG5ldyBIZWlnaHRNYXBHYXAoYmVmb3JlLmxlbmd0aCArIDEgKyBhZnRlci5sZW5ndGgpKTtcbn1cbmNvbnN0IHJlbGV2YW50V2lkZ2V0SGVpZ2h0ID0gNTtcbmNsYXNzIE5vZGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIG9yYWNsZSkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5vcmFjbGUgPSBvcmFjbGU7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gLTE7XG4gICAgICAgIHRoaXMuY292ZXJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHBvcztcbiAgICB9XG4gICAgZ2V0IGlzQ292ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY292ZXJpbmcgJiYgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IHRoaXMuY292ZXJpbmc7XG4gICAgfVxuICAgIHNwYW4oX2Zyb20sIHRvKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4odG8sIHRoaXMubGluZUVuZCksIGxhc3QgPSB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbGFzdC5sZW5ndGggKz0gZW5kIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPiB0aGlzLnBvcyB8fCAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KGVuZCAtIHRoaXMucG9zLCAtMSkpO1xuICAgICAgICAgICAgdGhpcy53cml0dGVuVG8gPSBlbmQ7XG4gICAgICAgICAgICBpZiAodG8gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0dGVuVG8rKztcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgfVxuICAgIHBvaW50KGZyb20sIHRvLCBkZWNvKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgZGVjby5oZWlnaHRSZWxldmFudCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0IDogMDtcbiAgICAgICAgICAgIGxldCBicmVha3MgPSBkZWNvLndpZGdldCA/IGRlY28ud2lkZ2V0LmxpbmVCcmVha3MgOiAwO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2sobmV3IEhlaWdodE1hcEJsb2NrKGxlbiwgaGVpZ2h0LCBkZWNvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gfHwgYnJlYWtzIHx8IGhlaWdodCA+PSByZWxldmFudFdpZGdldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZURlY28oaGVpZ2h0LCBicmVha3MsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICB0aGlzLnNwYW4oZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVFbmQgPiAtMSAmJiB0aGlzLmxpbmVFbmQgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHRoaXMubGluZUVuZCA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvO1xuICAgIH1cbiAgICBlbnRlckxpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gdG87XG4gICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20gLSAxIHx8IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KHRoaXMucG9zIC0gZnJvbSwgLTEpKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcztcbiAgICB9XG4gICAgYmxhbmtDb250ZW50KGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBnYXAgPSBuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLm9yYWNsZS5kb2MubGluZUF0KGZyb20pLnRvID09IHRvKVxuICAgICAgICAgICAgZ2FwLmZsYWdzIHw9IDQgLyogRmxhZy5TaW5nbGVMaW5lICovO1xuICAgICAgICByZXR1cm4gZ2FwO1xuICAgIH1cbiAgICBlbnN1cmVMaW5lKCkge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID8gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQoMCwgLTEpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBhZGRCbG9jayhibG9jaykge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgZGVjbyA9IGJsb2NrLmRlY287XG4gICAgICAgIGlmIChkZWNvICYmIGRlY28uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgYmxvY2subGVuZ3RoO1xuICAgICAgICBpZiAoZGVjbyAmJiBkZWNvLmVuZFNpZGUgPiAwKVxuICAgICAgICAgICAgdGhpcy5jb3ZlcmluZyA9IGJsb2NrO1xuICAgIH1cbiAgICBhZGRMaW5lRGVjbyhoZWlnaHQsIGJyZWFrcywgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIGxpbmUubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgbGluZS5jb2xsYXBzZWQgKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLndpZGdldEhlaWdodCA9IE1hdGgubWF4KGxpbmUud2lkZ2V0SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICBsaW5lLmJyZWFrcyArPSBicmVha3M7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbmd0aDtcbiAgICB9XG4gICAgZmluaXNoKGZyb20pIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEgJiYgIShsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCkgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JpdHRlblRvIDwgdGhpcy5wb3MgfHwgbGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCB0aGlzLnBvcykpO1xuICAgICAgICBsZXQgcG9zID0gZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQodGhpcy5vcmFjbGUsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gbm9kZSA/IG5vZGUubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG4gICAgLy8gQWx3YXlzIGNhbGxlZCB3aXRoIGEgcmVnaW9uIHRoYXQgb24gYm90aCBzaWRlcyBlaXRoZXIgc3RyZXRjaGVzXG4gICAgLy8gdG8gYSBsaW5lIGJyZWFrIG9yIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgIC8vIFRoZSByZXR1cm5lZCBhcnJheSB1c2VzIG51bGwgdG8gaW5kaWNhdGUgbGluZSBicmVha3MsIGJ1dCBuZXZlclxuICAgIC8vIHN0YXJ0cyBvciBlbmRzIGluIGEgbGluZSBicmVhaywgb3IgaGFzIG11bHRpcGxlIGxpbmUgYnJlYWtzIG5leHRcbiAgICAvLyB0byBlYWNoIG90aGVyLlxuICAgIHN0YXRpYyBidWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBOb2RlQnVpbGRlcihmcm9tLCBvcmFjbGUpO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIsIDApO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goZnJvbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3I7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wLCAwKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKCkgeyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvLCBhLCBiKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgYSAmJiBhLmhlaWdodFJlbGV2YW50IHx8IGIgJiYgYi5oZWlnaHRSZWxldmFudClcbiAgICAgICAgICAgIGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMsIDUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaWJsZVBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGxldCBsZWZ0ID0gTWF0aC5tYXgoMCwgcmVjdC5sZWZ0KSwgcmlnaHQgPSBNYXRoLm1pbih3aW4uaW5uZXJXaWR0aCwgcmVjdC5yaWdodCk7XG4gICAgbGV0IHRvcCA9IE1hdGgubWF4KDAsIHJlY3QudG9wKSwgYm90dG9tID0gTWF0aC5taW4od2luLmlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7IHBhcmVudCAmJiBwYXJlbnQgIT0gZG9jLmJvZHk7KSB7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsdCk7XG4gICAgICAgICAgICBpZiAoKGVsdC5zY3JvbGxIZWlnaHQgPiBlbHQuY2xpZW50SGVpZ2h0IHx8IGVsdC5zY3JvbGxXaWR0aCA+IGVsdC5jbGllbnRXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyAhPSBcInZpc2libGVcIikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRSZWN0ID0gZWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBwYXJlbnRSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBhcmVudFJlY3QucmlnaHQpO1xuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgcGFyZW50UmVjdC50b3ApO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IHBhcmVudCA9PSBkb20ucGFyZW50Tm9kZSA/IHBhcmVudFJlY3QuYm90dG9tIDogTWF0aC5taW4oYm90dG9tLCBwYXJlbnRSZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBzdHlsZS5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIgfHwgc3R5bGUucG9zaXRpb24gPT0gXCJmaXhlZFwiID8gZWx0Lm9mZnNldFBhcmVudCA6IGVsdC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gcmVjdC5sZWZ0LCByaWdodDogTWF0aC5tYXgobGVmdCwgcmlnaHQpIC0gcmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IHRvcCAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApLCBib3R0b206IE1hdGgubWF4KHRvcCwgYm90dG9tKSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG5mdW5jdGlvbiBmdWxsUGl4ZWxSYW5nZShkb20sIHBhZGRpbmdUb3ApIHtcbiAgICBsZXQgcmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBwYWRkaW5nVG9wLCBib3R0b206IHJlY3QuYm90dG9tIC0gKHJlY3QudG9wICsgcGFkZGluZ1RvcCkgfTtcbn1cbi8vIExpbmUgZ2FwcyBhcmUgcGxhY2Vob2xkZXIgd2lkZ2V0cyB1c2VkIHRvIGhpZGUgcGllY2VzIG9mIG92ZXJsb25nXG4vLyBsaW5lcyB3aXRoaW4gdGhlIHZpZXdwb3J0LCBhcyBhIGtsdWRnZSB0byBrZWVwIHRoZSBlZGl0b3Jcbi8vIHJlc3BvbnNpdmUgd2hlbiBhIHJpZGljdWxvdXNseSBsb25nIGxpbmUgaXMgbG9hZGVkIGludG8gaXQuXG5jbGFzcyBMaW5lR2FwIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgc2l6ZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIHN0YXRpYyBzYW1lKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBnQSA9IGFbaV0sIGdCID0gYltpXTtcbiAgICAgICAgICAgIGlmIChnQS5mcm9tICE9IGdCLmZyb20gfHwgZ0EudG8gIT0gZ0IudG8gfHwgZ0Euc2l6ZSAhPSBnQi5zaXplKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJhdyh2aWV3U3RhdGUsIHdyYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgd2lkZ2V0OiBuZXcgTGluZUdhcFdpZGdldCh0aGlzLnNpemUgKiAod3JhcHBpbmcgPyB2aWV3U3RhdGUuc2NhbGVZIDogdmlld1N0YXRlLnNjYWxlWCksIHdyYXBwaW5nKVxuICAgICAgICB9KS5yYW5nZSh0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIH1cbn1cbmNsYXNzIExpbmVHYXBXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCB2ZXJ0aWNhbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gdmVydGljYWw7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5zaXplID09IHRoaXMuc2l6ZSAmJiBvdGhlci52ZXJ0aWNhbCA9PSB0aGlzLnZlcnRpY2FsOyB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IHRoaXMuc2l6ZSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsdC5zdHlsZS53aWR0aCA9IHRoaXMuc2l6ZSArIFwicHhcIjtcbiAgICAgICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSBcIjJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZlcnRpY2FsID8gdGhpcy5zaXplIDogLTE7IH1cbn1cbmNsYXNzIFZpZXdTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAvLyBUaGVzZSBhcmUgY29udGVudERPTS1sb2NhbCBjb29yZGluYXRlc1xuICAgICAgICB0aGlzLnBpeGVsVmlld3BvcnQgPSB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW5kb3cuaW5uZXJXaWR0aCwgdG9wOiAwLCBib3R0b206IDAgfTtcbiAgICAgICAgdGhpcy5pblZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSAwOyAvLyBQYWRkaW5nIGFib3ZlIHRoZSBkb2N1bWVudCwgc2NhbGVkXG4gICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7IC8vIFBhZGRpbmcgYmVsb3cgdGhlIGRvY3VtZW50LCBzY2FsZWRcbiAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSAwOyAvLyBjb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXG4gICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IDA7IC8vIGNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gMDsgLy8gc2Nyb2xsRE9NLmNsaWVudEhlaWdodCwgdW5zY2FsZWRcbiAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IDA7IC8vIHNjcm9sbERPTS5jbGllbnRXaWR0aCwgdW5zY2FsZWRcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSAwOyAvLyBMYXN0IHNlZW4gc2Nyb2xsRE9NLnNjcm9sbFRvcCwgc2NhbGVkXG4gICAgICAgIHRoaXMuc2Nyb2xsZWRUb0JvdHRvbSA9IHRydWU7XG4gICAgICAgIC8vIFRoZSBDU1MtdHJhbnNmb3JtYXRpb24gc2NhbGUgb2YgdGhlIGVkaXRvciAodHJhbnNmb3JtZWQgc2l6ZSAvXG4gICAgICAgIC8vIGNvbmNyZXRlIHNpemUpXG4gICAgICAgIHRoaXMuc2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5zY2FsZVkgPSAxO1xuICAgICAgICAvLyBUaGUgdmVydGljYWwgcG9zaXRpb24gKGRvY3VtZW50LXJlbGF0aXZlKSB0byB3aGljaCB0byBhbmNob3IgdGhlXG4gICAgICAgIC8vIHNjcm9sbCBwb3NpdGlvbi4gLTEgbWVhbnMgYW5jaG9yIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IDA7XG4gICAgICAgIC8vIFRoZSBoZWlnaHQgYXQgdGhlIGFuY2hvciBwb3NpdGlvbi4gU2V0IGJ5IHRoZSBET00gdXBkYXRlIHBoYXNlLlxuICAgICAgICAvLyAtMSBtZWFucyBubyBoZWlnaHQgYXZhaWxhYmxlLlxuICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAvLyBTZWUgVlAuTWF4RE9NSGVpZ2h0XG4gICAgICAgIHRoaXMuc2NhbGVyID0gSWRTY2FsZXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gQnJpZWZseSBzZXQgdG8gdHJ1ZSB3aGVuIHByaW50aW5nLCB0byBkaXNhYmxlIHZpZXdwb3J0IGxpbWl0aW5nXG4gICAgICAgIHRoaXMucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hlbiBlZGl0b3IgY29udGVudCB3YXMgcmVkcmF3biwgc28gdGhhdCB0aGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHN0YWdlIGtub3dzIGl0IG11c3QgcmVhZCBET00gbGF5b3V0XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdO1xuICAgICAgICAvLyBDdXJzb3IgJ2Fzc29jJyBpcyBvbmx5IHNpZ25pZmljYW50IHdoZW4gdGhlIGN1cnNvciBpcyBvbiBhIGxpbmVcbiAgICAgICAgLy8gd3JhcCBwb2ludCwgd2hlcmUgaXQgbXVzdCBzdGljayB0byB0aGUgY2hhcmFjdGVyIHRoYXQgaXQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoLiBTaW5jZSBicm93c2VycyBkb24ndCBwcm92aWRlIGEgcmVhc29uYWJsZVxuICAgICAgICAvLyBpbnRlcmZhY2UgdG8gc2V0IG9yIHF1ZXJ5IHRoaXMsIHdoZW4gYSBzZWxlY3Rpb24gaXMgc2V0IHRoYXRcbiAgICAgICAgLy8gbWlnaHQgY2F1c2UgdGhpcyB0byBiZSBzaWduaWZpY2FudCwgdGhpcyBmbGFnIGlzIHNldC4gVGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBwaGFzZSB3aWxsIGNoZWNrIHdoZXRoZXIgdGhlIGN1cnNvciBpcyBvbiBhIGxpbmUtd3JhcHBpbmdcbiAgICAgICAgLy8gYm91bmRhcnkgYW5kLCBpZiBzbywgcmVzZXQgaXQgdG8gbWFrZSBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgaW5cbiAgICAgICAgLy8gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgbGV0IGd1ZXNzV3JhcHBpbmcgPSBzdGF0ZS5mYWNldChjb250ZW50QXR0cmlidXRlcykuc29tZSh2ID0+IHR5cGVvZiB2ICE9IFwiZnVuY3Rpb25cIiAmJiB2LmNsYXNzID09IFwiY20tbGluZVdyYXBwaW5nXCIpO1xuICAgICAgICB0aGlzLmhlaWdodE9yYWNsZSA9IG5ldyBIZWlnaHRPcmFjbGUoZ3Vlc3NXcmFwcGluZyk7XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLmZpbHRlcihkID0+IHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2Moc3RhdGUuZG9jKSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgc3RhdGUuZG9jLmxlbmd0aCldKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgbnVsbCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIHRoaXMubGluZUdhcHMgPSB0aGlzLmVuc3VyZUxpbmVHYXBzKFtdKTtcbiAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KHRoaXMubGluZUdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLCBmYWxzZSkpKTtcbiAgICAgICAgdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgIH1cbiAgICB1cGRhdGVGb3JWaWV3cG9ydCgpIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0cyA9IFt0aGlzLnZpZXdwb3J0XSwgeyBtYWluIH0gPSB0aGlzLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gaSA/IG1haW4uaGVhZCA6IG1haW4uYW5jaG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydHMuc29tZSgoeyBmcm9tLCB0byB9KSA9PiBwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMubGluZUJsb2NrQXQocG9zKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHMucHVzaChuZXcgVmlld3BvcnQoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICB0aGlzLnNjYWxlciA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodCA8PSA3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyA/IElkU2NhbGVyIDpcbiAgICAgICAgICAgIG5ldyBCaWdTY2FsZXIodGhpcy5oZWlnaHRPcmFjbGUsIHRoaXMuaGVpZ2h0TWFwLCB0aGlzLnZpZXdwb3J0cyk7XG4gICAgfVxuICAgIHVwZGF0ZVZpZXdwb3J0TGluZXMoKSB7XG4gICAgICAgIHRoaXMudmlld3BvcnRMaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmhlaWdodE1hcC5mb3JFYWNoTGluZSh0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyh0aGlzLnN0YXRlLmRvYyksIDAsIDAsIGJsb2NrID0+IHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRMaW5lcy5wdXNoKHRoaXMuc2NhbGVyLnNjYWxlID09IDEgPyBibG9jayA6IHNjYWxlQmxvY2soYmxvY2ssIHRoaXMuc2NhbGVyKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlLCBzY3JvbGxUYXJnZXQgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB1cGRhdGUuc3RhdGU7XG4gICAgICAgIGxldCBwcmV2RGVjbyA9IHRoaXMuc3RhdGVEZWNvO1xuICAgICAgICB0aGlzLnN0YXRlRGVjbyA9IHRoaXMuc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLmZpbHRlcihkID0+IHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIik7XG4gICAgICAgIGxldCBjb250ZW50Q2hhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBsZXQgaGVpZ2h0Q2hhbmdlcyA9IENoYW5nZWRSYW5nZS5leHRlbmRXaXRoUmFuZ2VzKGNvbnRlbnRDaGFuZ2VzLCBoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzKHByZXZEZWNvLCB0aGlzLnN0YXRlRGVjbywgdXBkYXRlID8gdXBkYXRlLmNoYW5nZXMgOiBDaGFuZ2VTZXQuZW1wdHkodGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSkpO1xuICAgICAgICBsZXQgcHJldkhlaWdodCA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgbGV0IHNjcm9sbEFuY2hvciA9IHRoaXMuc2Nyb2xsZWRUb0JvdHRvbSA/IG51bGwgOiB0aGlzLnNjcm9sbEFuY2hvckF0KHRoaXMuc2Nyb2xsVG9wKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSB0aGlzLmhlaWdodE1hcC5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIHVwZGF0ZS5zdGFydFN0YXRlLmRvYywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgaGVpZ2h0Q2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE1hcC5oZWlnaHQgIT0gcHJldkhlaWdodClcbiAgICAgICAgICAgIHVwZGF0ZS5mbGFncyB8PSAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgICAgICBpZiAoc2Nyb2xsQW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyhzY3JvbGxBbmNob3IuZnJvbSwgLTEpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSBzY3JvbGxBbmNob3IudG9wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JQb3MgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IGhlaWdodENoYW5nZXMubGVuZ3RoID8gdGhpcy5tYXBWaWV3cG9ydCh0aGlzLnZpZXdwb3J0LCB1cGRhdGUuY2hhbmdlcykgOiB0aGlzLnZpZXdwb3J0O1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0ICYmIChzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB2aWV3cG9ydC50bykgfHxcbiAgICAgICAgICAgICF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh2aWV3cG9ydCkpXG4gICAgICAgICAgICB2aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgbGV0IHVwZGF0ZUxpbmVzID0gIXVwZGF0ZS5jaGFuZ2VzLmVtcHR5IHx8ICh1cGRhdGUuZmxhZ3MgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fFxuICAgICAgICAgICAgdmlld3BvcnQuZnJvbSAhPSB0aGlzLnZpZXdwb3J0LmZyb20gfHwgdmlld3BvcnQudG8gIT0gdGhpcy52aWV3cG9ydC50bztcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIGlmICh1cGRhdGVMaW5lcylcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2Fwcyh0aGlzLm1hcExpbmVHYXBzKHRoaXMubGluZUdhcHMsIHVwZGF0ZS5jaGFuZ2VzKSkpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQ7XG4gICAgICAgIGlmICghdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jICYmIHVwZGF0ZS5zZWxlY3Rpb25TZXQgJiYgdXBkYXRlLnZpZXcubGluZVdyYXBwaW5nICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jICYmXG4gICAgICAgICAgICAhdXBkYXRlLnN0YXRlLmZhY2V0KG5hdGl2ZVNlbGVjdGlvbkhpZGRlbikpXG4gICAgICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSB0cnVlO1xuICAgIH1cbiAgICBtZWFzdXJlKHZpZXcpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcuY29udGVudERPTSwgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pO1xuICAgICAgICBsZXQgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGxldCB3aGl0ZVNwYWNlID0gc3R5bGUud2hpdGVTcGFjZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IHN0eWxlLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGxldCByZWZyZXNoID0gdGhpcy5oZWlnaHRPcmFjbGUubXVzdFJlZnJlc2hGb3JXcmFwcGluZyh3aGl0ZVNwYWNlKTtcbiAgICAgICAgbGV0IGRvbVJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBtZWFzdXJlQ29udGVudCA9IHJlZnJlc2ggfHwgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgfHwgdGhpcy5jb250ZW50RE9NSGVpZ2h0ICE9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNvbnRlbnRET01IZWlnaHQgPSBkb21SZWN0LmhlaWdodDtcbiAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDAsIGJpYXMgPSAwO1xuICAgICAgICBpZiAoZG9tUmVjdC53aWR0aCAmJiBkb21SZWN0LmhlaWdodCkge1xuICAgICAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IGdldFNjYWxlKGRvbSwgZG9tUmVjdCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2FsZVggIT0gc2NhbGVYIHx8IHRoaXMuc2NhbGVZICE9IHNjYWxlWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSA4IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi87XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBWZXJ0aWNhbCBwYWRkaW5nXG4gICAgICAgIGxldCBwYWRkaW5nVG9wID0gKHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3ApIHx8IDApICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gKHBhcnNlSW50KHN0eWxlLnBhZGRpbmdCb3R0b20pIHx8IDApICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLnBhZGRpbmdUb3AgIT0gcGFkZGluZ1RvcCB8fCB0aGlzLnBhZGRpbmdCb3R0b20gIT0gcGFkZGluZ0JvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcDtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b207XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovIHwgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3JXaWR0aCAhPSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCAhPSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPSBpc1Njcm9sbGVkVG9Cb3R0b20odmlldy5zY3JvbGxET00pO1xuICAgICAgICAvLyBQaXhlbCB2aWV3cG9ydFxuICAgICAgICBsZXQgcGl4ZWxWaWV3cG9ydCA9ICh0aGlzLnByaW50aW5nID8gZnVsbFBpeGVsUmFuZ2UgOiB2aXNpYmxlUGl4ZWxSYW5nZSkoZG9tLCB0aGlzLnBhZGRpbmdUb3ApO1xuICAgICAgICBsZXQgZFRvcCA9IHBpeGVsVmlld3BvcnQudG9wIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCwgZEJvdHRvbSA9IHBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbTtcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0gcGl4ZWxWaWV3cG9ydDtcbiAgICAgICAgbGV0IGluVmlldyA9IHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gPiB0aGlzLnBpeGVsVmlld3BvcnQudG9wICYmIHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCA+IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0O1xuICAgICAgICBpZiAoaW5WaWV3ICE9IHRoaXMuaW5WaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmluVmlldyA9IGluVmlldztcbiAgICAgICAgICAgIGlmIChpblZpZXcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pblZpZXcgJiYgIXRoaXMuc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NV2lkdGggIT0gY29udGVudFdpZHRoIHx8IHRoaXMuZWRpdG9ySGVpZ2h0ICE9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NV2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSB2aWV3LnNjcm9sbERPTS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWFzdXJlQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IGxpbmVIZWlnaHRzID0gdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModGhpcy52aWV3cG9ydCk7XG4gICAgICAgICAgICBpZiAob3JhY2xlLm11c3RSZWZyZXNoRm9ySGVpZ2h0cyhsaW5lSGVpZ2h0cykpXG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocmVmcmVzaCB8fCBvcmFjbGUubGluZVdyYXBwaW5nICYmIE1hdGguYWJzKGNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGVudERPTVdpZHRoKSA+IG9yYWNsZS5jaGFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQgfSA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gbGluZUhlaWdodCA+IDAgJiYgb3JhY2xlLnJlZnJlc2god2hpdGVTcGFjZSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0LCBjb250ZW50V2lkdGggLyBjaGFyV2lkdGgsIGxpbmVIZWlnaHRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWluV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkVG9wID4gMCAmJiBkQm90dG9tID4gMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5tYXgoZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChkVG9wIDwgMCAmJiBkQm90dG9tIDwgMClcbiAgICAgICAgICAgICAgICBiaWFzID0gTWF0aC5taW4oZFRvcCwgZEJvdHRvbSk7XG4gICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgdnAgb2YgdGhpcy52aWV3cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0cyA9IHZwLmZyb20gPT0gdGhpcy52aWV3cG9ydC5mcm9tID8gbGluZUhlaWdodHMgOiB2aWV3LmRvY1ZpZXcubWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh2cCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSAocmVmcmVzaCA/IEhlaWdodE1hcC5lbXB0eSgpLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgVGV4dC5lbXB0eSwgdGhpcy5oZWlnaHRPcmFjbGUsIFtuZXcgQ2hhbmdlZFJhbmdlKDAsIDAsIDAsIHZpZXcuc3RhdGUuZG9jLmxlbmd0aCldKSA6IHRoaXMuaGVpZ2h0TWFwKS51cGRhdGVIZWlnaHQob3JhY2xlLCAwLCByZWZyZXNoLCBuZXcgTWVhc3VyZWRIZWlnaHRzKHZwLmZyb20sIGhlaWdodHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcmFjbGUuaGVpZ2h0Q2hhbmdlZClcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlld3BvcnRDaGFuZ2UgPSAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUodGhpcy52aWV3cG9ydCwgYmlhcykgfHxcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ICYmICh0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHRoaXMudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAodmlld3BvcnRDaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydChiaWFzLCB0aGlzLnNjcm9sbFRhcmdldCk7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgaWYgKChyZXN1bHQgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fCB2aWV3cG9ydENoYW5nZSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2FwcyhyZWZyZXNoID8gW10gOiB0aGlzLmxpbmVHYXBzLCB2aWV3KSk7XG4gICAgICAgIHJlc3VsdCB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MpIHtcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIGluIHRoZSByZWFkIHN0YWdlLCBiZWNhdXNlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyB0byBhIGxpbmUgZW5kIGlzIGdvaW5nIHRvIHRyaWdnZXIgYSBsYXlvdXQgYW55d2F5LCBzbyBpdFxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgYSBwdXJlIHdyaXRlLiBJdCBzaG91bGQgYmUgcmFyZSB0aGF0IGl0IGRvZXMgYW55XG4gICAgICAgICAgICAvLyB3cml0aW5nLlxuICAgICAgICAgICAgdmlldy5kb2NWaWV3LmVuZm9yY2VDdXJzb3JBc3NvYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlVG9wKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQudG9wKTsgfVxuICAgIGdldCB2aXNpYmxlQm90dG9tKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tKTsgfVxuICAgIGdldFZpZXdwb3J0KGJpYXMsIHNjcm9sbFRhcmdldCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgZGl2aWRlIFZQLk1hcmdpbiBiZXR3ZWVuIHRoZSB0b3AgYW5kIHRoZVxuICAgICAgICAvLyBib3R0b20sIGRlcGVuZGluZyBvbiB0aGUgYmlhcyAodGhlIGNoYW5nZSBpbiB2aWV3cG9ydCBwb3NpdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLiBJdCdsbCBob2xkIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgICBsZXQgbWFyZ2luVG9wID0gMC41IC0gTWF0aC5tYXgoLTAuNSwgTWF0aC5taW4oMC41LCBiaWFzIC8gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyKSk7XG4gICAgICAgIGxldCBtYXAgPSB0aGlzLmhlaWdodE1hcCwgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGxldCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHZpc2libGVUb3AgLSBtYXJnaW5Ub3AgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodmlzaWJsZUJvdHRvbSArICgxIC0gbWFyZ2luVG9wKSAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkudG8pO1xuICAgICAgICAvLyBJZiBzY3JvbGxUYXJnZXQgaXMgZ2l2ZW4sIG1ha2Ugc3VyZSB0aGUgdmlld3BvcnQgaW5jbHVkZXMgdGhhdCBwb3NpdGlvblxuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICBsZXQgeyBoZWFkIH0gPSBzY3JvbGxUYXJnZXQucmFuZ2U7XG4gICAgICAgICAgICBpZiAoaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgaGVhZCA+IHZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdIZWlnaHQgPSBNYXRoLm1pbih0aGlzLmVkaXRvckhlaWdodCwgdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApO1xuICAgICAgICAgICAgICAgIGxldCBibG9jayA9IG1hcC5saW5lQXQoaGVhZCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLCB0b3BQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldC55ID09IFwiY2VudGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IChibG9jay50b3AgKyBibG9jay5ib3R0b20pIC8gMiAtIHZpZXdIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFRhcmdldC55ID09IFwic3RhcnRcIiB8fCBzY3JvbGxUYXJnZXQueSA9PSBcIm5lYXJlc3RcIiAmJiBoZWFkIDwgdmlld3BvcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2suYm90dG9tIC0gdmlld0hlaWdodDtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHRvcFBvcyAtIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodG9wUG9zICsgdmlld0hlaWdodCArIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICAgIG1hcFZpZXdwb3J0KHZpZXdwb3J0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3cG9ydCh0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCkuZnJvbSwgdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS50byk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHZpZXdwb3J0IGNvdmVycyB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZVxuICAgIC8vIGRvY3VtZW50IGFuZCBub3QgdG9vIG11Y2ggYmV5b25kIHRoYXQuXG4gICAgdmlld3BvcnRJc0FwcHJvcHJpYXRlKHsgZnJvbSwgdG8gfSwgYmlhcyA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgeyB0b3AgfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgYm90dG9tIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApO1xuICAgICAgICBsZXQgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGZyb20gPT0gMCB8fCB0b3AgPD0gdmlzaWJsZVRvcCAtIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbigtYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG8gPT0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgYm90dG9tID49IHZpc2libGVCb3R0b20gKyBNYXRoLm1heCgxMCAvKiBWUC5NaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG9wID4gdmlzaWJsZVRvcCAtIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyAmJiBib3R0b20gPCB2aXNpYmxlQm90dG9tICsgMiAqIDEwMDAgLyogVlAuTWFyZ2luICovKTtcbiAgICB9XG4gICAgbWFwTGluZUdhcHMoZ2FwcywgY2hhbmdlcykge1xuICAgICAgICBpZiAoIWdhcHMubGVuZ3RoIHx8IGNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gZ2FwcztcbiAgICAgICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgIGlmICghY2hhbmdlcy50b3VjaGVzUmFuZ2UoZ2FwLmZyb20sIGdhcC50bykpXG4gICAgICAgICAgICAgICAgbWFwcGVkLnB1c2gobmV3IExpbmVHYXAoY2hhbmdlcy5tYXBQb3MoZ2FwLmZyb20pLCBjaGFuZ2VzLm1hcFBvcyhnYXAudG8pLCBnYXAuc2l6ZSkpO1xuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyBwb3NpdGlvbnMgaW4gdGhlIHZpZXdwb3J0IHdoZXJlIHRoZSBzdGFydCBvciBlbmQgb2YgYVxuICAgIC8vIGxpbmUgc2hvdWxkIGJlIGhpZGRlbiwgdHJ5aW5nIHRvIHJldXNlIGV4aXN0aW5nIGxpbmUgZ2FwcyB3aGVuXG4gICAgLy8gYXBwcm9wcmlhdGUgdG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVkcmF3cy5cbiAgICAvLyBVc2VzIGNydWRlIGNoYXJhY3Rlci1jb3VudGluZyBmb3IgdGhlIHBvc2l0aW9uaW5nIGFuZCBzaXppbmcsXG4gICAgLy8gc2luY2UgYWN0dWFsIERPTSBjb29yZGluYXRlcyBhcmVuJ3QgYWx3YXlzIGF2YWlsYWJsZSBhbmRcbiAgICAvLyBwcmVkaWN0YWJsZS4gUmVsaWVzIG9uIGdlbmVyb3VzIG1hcmdpbnMgKHNlZSBMRy5NYXJnaW4pIHRvIGhpZGVcbiAgICAvLyB0aGUgYXJ0aWZhY3RzIHRoaXMgbWlnaHQgcHJvZHVjZSBmcm9tIHRoZSB1c2VyLlxuICAgIGVuc3VyZUxpbmVHYXBzKGN1cnJlbnQsIG1heU1lYXN1cmUpIHtcbiAgICAgICAgbGV0IHdyYXBwaW5nID0gdGhpcy5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nO1xuICAgICAgICBsZXQgbWFyZ2luID0gd3JhcHBpbmcgPyAxMDAwMCAvKiBMRy5NYXJnaW5XcmFwICovIDogMjAwMCAvKiBMRy5NYXJnaW4gKi8sIGhhbGZNYXJnaW4gPSBtYXJnaW4gPj4gMSwgZG91YmxlTWFyZ2luID0gbWFyZ2luIDw8IDE7XG4gICAgICAgIC8vIFRoZSBub24td3JhcHBpbmcgbG9naWMgd29uJ3Qgd29yayBhdCBhbGwgaW4gcHJlZG9taW5hbnRseSByaWdodC10by1sZWZ0IHRleHQuXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uICE9IERpcmVjdGlvbi5MVFIgJiYgIXdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBsZXQgZ2FwcyA9IFtdO1xuICAgICAgICBsZXQgYWRkR2FwID0gKGZyb20sIHRvLCBsaW5lLCBzdHJ1Y3R1cmUpID0+IHtcbiAgICAgICAgICAgIGlmICh0byAtIGZyb20gPCBoYWxmTWFyZ2luKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBzZWwgPSB0aGlzLnN0YXRlLnNlbGVjdGlvbi5tYWluLCBhdm9pZCA9IFtzZWwuZnJvbV07XG4gICAgICAgICAgICBpZiAoIXNlbC5lbXB0eSlcbiAgICAgICAgICAgICAgICBhdm9pZC5wdXNoKHNlbC50byk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgYXZvaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBwb3MgPCB0bykge1xuICAgICAgICAgICAgICAgICAgICBhZGRHYXAoZnJvbSwgcG9zIC0gMTAgLyogTEcuU2VsZWN0aW9uTWFyZ2luICovLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRHYXAocG9zICsgMTAgLyogTEcuU2VsZWN0aW9uTWFyZ2luICovLCB0bywgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBnYXAgPSBmaW5kKGN1cnJlbnQsIGdhcCA9PiBnYXAuZnJvbSA+PSBsaW5lLmZyb20gJiYgZ2FwLnRvIDw9IGxpbmUudG8gJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhnYXAuZnJvbSAtIGZyb20pIDwgaGFsZk1hcmdpbiAmJiBNYXRoLmFicyhnYXAudG8gLSB0bykgPCBoYWxmTWFyZ2luICYmXG4gICAgICAgICAgICAgICAgIWF2b2lkLnNvbWUocG9zID0+IGdhcC5mcm9tIDwgcG9zICYmIGdhcC50byA+IHBvcykpO1xuICAgICAgICAgICAgaWYgKCFnYXApIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHNjcm9sbGluZyBkb3duLCBzbmFwIGdhcCBlbmRzIHRvIGxpbmUgc3RhcnRzIHRvIGF2b2lkIHNoaWZ0cyBpbiB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIGlmICh0byA8IGxpbmUudG8gJiYgbWF5TWVhc3VyZSAmJiB3cmFwcGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBtYXlNZWFzdXJlLnZpc2libGVSYW5nZXMuc29tZShyID0+IHIuZnJvbSA8PSB0byAmJiByLnRvID49IHRvKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZVN0YXJ0ID0gbWF5TWVhc3VyZS5tb3ZlVG9MaW5lQm91bmRhcnkoRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0byksIGZhbHNlLCB0cnVlKS5oZWFkO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZVN0YXJ0ID4gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gbGluZVN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnYXAgPSBuZXcgTGluZUdhcChmcm9tLCB0bywgdGhpcy5nYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdhcHMucHVzaChnYXApO1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudmlld3BvcnRMaW5lcykge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgZG91YmxlTWFyZ2luKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0cnVjdHVyZSA9IGxpbmVTdHJ1Y3R1cmUobGluZS5mcm9tLCBsaW5lLnRvLCB0aGlzLnN0YXRlRGVjbyk7XG4gICAgICAgICAgICBpZiAoc3RydWN0dXJlLnRvdGFsIDwgZG91YmxlTWFyZ2luKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc2Nyb2xsVGFyZ2V0ID8gdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA6IG51bGw7XG4gICAgICAgICAgICBsZXQgdmlld0Zyb20sIHZpZXdUbztcbiAgICAgICAgICAgIGlmICh3cmFwcGluZykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5IZWlnaHQgPSAobWFyZ2luIC8gdGhpcy5oZWlnaHRPcmFjbGUubGluZUxlbmd0aCkgKiB0aGlzLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGxldCB0b3AsIGJvdDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldEZyYWMgPSBmaW5kRnJhY3Rpb24oc3RydWN0dXJlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VGcmFjID0gKCh0aGlzLnZpc2libGVCb3R0b20gLSB0aGlzLnZpc2libGVUb3ApIC8gMiArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gdGFyZ2V0RnJhYyAtIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gdGFyZ2V0RnJhYyArIHNwYWNlRnJhYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9ICh0aGlzLnZpc2libGVUb3AgLSBsaW5lLnRvcCAtIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYm90ID0gKHRoaXMudmlzaWJsZUJvdHRvbSAtIGxpbmUudG9wICsgbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIHRvcCk7XG4gICAgICAgICAgICAgICAgdmlld1RvID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgYm90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbFdpZHRoID0gc3RydWN0dXJlLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoO1xuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5XaWR0aCA9IG1hcmdpbiAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgodGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0IC0gdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQpIC8gMiArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRGcmFjIC0gc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0IC0gbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAodGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ICsgbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICB2aWV3VG8gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmlld0Zyb20gPiBsaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgYWRkR2FwKGxpbmUuZnJvbSwgdmlld0Zyb20sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICBpZiAodmlld1RvIDwgbGluZS50bylcbiAgICAgICAgICAgICAgICBhZGRHYXAodmlld1RvLCBsaW5lLnRvLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXBzO1xuICAgIH1cbiAgICBnYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpIHtcbiAgICAgICAgbGV0IGZyYWN0aW9uID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdG8pIC0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLmhlaWdodCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUxpbmVHYXBzKGdhcHMpIHtcbiAgICAgICAgaWYgKCFMaW5lR2FwLnNhbWUoZ2FwcywgdGhpcy5saW5lR2FwcykpIHtcbiAgICAgICAgICAgIHRoaXMubGluZUdhcHMgPSBnYXBzO1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KGdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLCB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZVZpc2libGVSYW5nZXMoKSB7XG4gICAgICAgIGxldCBkZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aClcbiAgICAgICAgICAgIGRlY28gPSBkZWNvLmNvbmNhdCh0aGlzLmxpbmVHYXBEZWNvKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvLCB0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHtcbiAgICAgICAgICAgIHNwYW4oZnJvbSwgdG8pIHsgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTsgfSxcbiAgICAgICAgICAgIHBvaW50KCkgeyB9XG4gICAgICAgIH0sIDIwKTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSByYW5nZXMubGVuZ3RoICE9IHRoaXMudmlzaWJsZVJhbmdlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcy5zb21lKChyLCBpKSA9PiByLmZyb20gIT0gcmFuZ2VzW2ldLmZyb20gfHwgci50byAhPSByYW5nZXNbaV0udG8pO1xuICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkID8gNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovIDogMDtcbiAgICB9XG4gICAgbGluZUJsb2NrQXQocG9zKSB7XG4gICAgICAgIHJldHVybiAocG9zID49IHRoaXMudmlld3BvcnQuZnJvbSAmJiBwb3MgPD0gdGhpcy52aWV3cG9ydC50byAmJiB0aGlzLnZpZXdwb3J0TGluZXMuZmluZChiID0+IGIuZnJvbSA8PSBwb3MgJiYgYi50byA+PSBwb3MpKSB8fFxuICAgICAgICAgICAgc2NhbGVCbG9jayh0aGlzLmhlaWdodE1hcC5saW5lQXQocG9zLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBsaW5lQmxvY2tBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKSB7XG4gICAgICAgIGxldCBibG9jayA9IHRoaXMubGluZUJsb2NrQXRIZWlnaHQoc2Nyb2xsVG9wICsgOCk7XG4gICAgICAgIHJldHVybiBibG9jay5mcm9tID49IHRoaXMudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXdwb3J0TGluZXNbMF0udG9wIC0gc2Nyb2xsVG9wID4gMjAwID8gYmxvY2sgOiB0aGlzLnZpZXdwb3J0TGluZXNbMF07XG4gICAgfVxuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAuYmxvY2tBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBnZXQgZG9jSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZXIudG9ET00odGhpcy5oZWlnaHRNYXAuaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0hlaWdodCArIHRoaXMucGFkZGluZ1RvcCArIHRoaXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG59XG5jbGFzcyBWaWV3cG9ydCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpbmVTdHJ1Y3R1cmUoZnJvbSwgdG8sIHN0YXRlRGVjbykge1xuICAgIGxldCByYW5nZXMgPSBbXSwgcG9zID0gZnJvbSwgdG90YWwgPSAwO1xuICAgIFJhbmdlU2V0LnNwYW5zKHN0YXRlRGVjbywgZnJvbSwgdG8sIHtcbiAgICAgICAgc3BhbigpIHsgfSxcbiAgICAgICAgcG9pbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvOiBmcm9tIH0pO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGZyb20gLSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgfVxuICAgIH0sIDIwKTsgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGNvbGxhcHNlZCByYW5nZXMgb2YgYSBzaWduaWZpY2FudCBzaXplXG4gICAgaWYgKHBvcyA8IHRvKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0byB9KTtcbiAgICAgICAgdG90YWwgKz0gdG8gLSBwb3M7XG4gICAgfVxuICAgIHJldHVybiB7IHRvdGFsLCByYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvbih7IHRvdGFsLCByYW5nZXMgfSwgcmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPD0gMClcbiAgICAgICAgcmV0dXJuIHJhbmdlc1swXS5mcm9tO1xuICAgIGlmIChyYXRpbyA+PSAxKVxuICAgICAgICByZXR1cm4gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICBsZXQgZGlzdCA9IE1hdGguZmxvb3IodG90YWwgKiByYXRpbyk7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXSwgc2l6ZSA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRpc3QgPD0gc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tICsgZGlzdDtcbiAgICAgICAgZGlzdCAtPSBzaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHBvcykge1xuICAgIGxldCBjb3VudGVkID0gMDtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygc3RydWN0dXJlLnJhbmdlcykge1xuICAgICAgICBpZiAocG9zIDw9IHRvKSB7XG4gICAgICAgICAgICBjb3VudGVkICs9IHBvcyAtIGZyb207XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb3VudGVkICs9IHRvIC0gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZWQgLyBzdHJ1Y3R1cmUudG90YWw7XG59XG5mdW5jdGlvbiBmaW5kKGFycmF5LCBmKSB7XG4gICAgZm9yIChsZXQgdmFsIG9mIGFycmF5KVxuICAgICAgICBpZiAoZih2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gRG9uJ3Qgc2NhbGUgd2hlbiB0aGUgZG9jdW1lbnQgaGVpZ2h0IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Ygd2hhdFxuLy8gdGhlIERPTSBjYW4gaGFuZGxlLlxuY29uc3QgSWRTY2FsZXIgPSB7XG4gICAgdG9ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBmcm9tRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgc2NhbGU6IDFcbn07XG4vLyBXaGVuIHRoZSBoZWlnaHQgaXMgdG9vIGJpZyAoPiBWUC5NYXhET01IZWlnaHQpLCBzY2FsZSBkb3duIHRoZVxuLy8gcmVnaW9ucyBvdXRzaWRlIHRoZSB2aWV3cG9ydHMgc28gdGhhdCB0aGUgdG90YWwgaGVpZ2h0IGlzXG4vLyBWUC5NYXhET01IZWlnaHQuXG5jbGFzcyBCaWdTY2FsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9yYWNsZSwgaGVpZ2h0TWFwLCB2aWV3cG9ydHMpIHtcbiAgICAgICAgbGV0IHZwSGVpZ2h0ID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvcCA9IGhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLnRvcDtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSBoZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCkuYm90dG9tO1xuICAgICAgICAgICAgdnBIZWlnaHQgKz0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHRvcCwgYm90dG9tLCBkb21Ub3A6IDAsIGRvbUJvdHRvbTogMCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FsZSA9ICg3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyAtIHZwSGVpZ2h0KSAvIChoZWlnaHRNYXAuaGVpZ2h0IC0gdnBIZWlnaHQpO1xuICAgICAgICBmb3IgKGxldCBvYmogb2YgdGhpcy52aWV3cG9ydHMpIHtcbiAgICAgICAgICAgIG9iai5kb21Ub3AgPSBkb21CYXNlICsgKG9iai50b3AgLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBkb21CYXNlID0gb2JqLmRvbUJvdHRvbSA9IG9iai5kb21Ub3AgKyAob2JqLmJvdHRvbSAtIG9iai50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IG9iai5ib3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAudG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21CYXNlICsgKG4gLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5ib3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLmRvbVRvcCArIChuIC0gdnAudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAuZG9tVG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlICsgKG4gLSBkb21CYXNlKSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5kb21Cb3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLnRvcCArIChuIC0gdnAuZG9tVG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbGVCbG9jayhibG9jaywgc2NhbGVyKSB7XG4gICAgaWYgKHNjYWxlci5zY2FsZSA9PSAxKVxuICAgICAgICByZXR1cm4gYmxvY2s7XG4gICAgbGV0IGJUb3AgPSBzY2FsZXIudG9ET00oYmxvY2sudG9wKSwgYkJvdHRvbSA9IHNjYWxlci50b0RPTShibG9jay5ib3R0b20pO1xuICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGJsb2NrLmZyb20sIGJsb2NrLmxlbmd0aCwgYlRvcCwgYkJvdHRvbSAtIGJUb3AsIEFycmF5LmlzQXJyYXkoYmxvY2suX2NvbnRlbnQpID8gYmxvY2suX2NvbnRlbnQubWFwKGIgPT4gc2NhbGVCbG9jayhiLCBzY2FsZXIpKSA6IGJsb2NrLl9jb250ZW50KTtcbn1cblxuY29uc3QgdGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogc3RycyA9PiBzdHJzLmpvaW4oXCIgXCIpIH0pO1xuY29uc3QgZGFya1RoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuaW5kZXhPZih0cnVlKSA+IC0xIH0pO1xuY29uc3QgYmFzZVRoZW1lSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlTGlnaHRJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VEYXJrSUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuY29uc3QgbGlnaHREYXJrSURzID0geyBcIiZsaWdodFwiOiBcIi5cIiArIGJhc2VMaWdodElELCBcIiZkYXJrXCI6IFwiLlwiICsgYmFzZURhcmtJRCB9O1xuZnVuY3Rpb24gYnVpbGRUaGVtZShtYWluLCBzcGVjLCBzY29wZXMpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlTW9kdWxlKHNwZWMsIHtcbiAgICAgICAgZmluaXNoKHNlbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8mLy50ZXN0KHNlbCkgPyBzZWwucmVwbGFjZSgvJlxcdyovLCBtID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobSA9PSBcIiZcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1haW47XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZXMgfHwgIXNjb3Blc1ttXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuc3VwcG9ydGVkIHNlbGVjdG9yOiAke219YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3Blc1ttXTtcbiAgICAgICAgICAgIH0pIDogbWFpbiArIFwiIFwiICsgc2VsO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9idWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHtcbiAgICBcIiZcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZSAhaW1wb3J0YW50XCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIFwiJi5jbS1mb2N1c2VkXCI6IHtcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYSBzaW1wbGUgZGVmYXVsdCBvdXRsaW5lIHRvIG1ha2Ugc3VyZSBhIGZvY3VzZWRcbiAgICAgICAgICAgIC8vIGVkaXRvciBpcyB2aXN1YWxseSBkaXN0aW5jdC4gQ2FuJ3QgbGVhdmUgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3aWxsIGFwcGx5IHRvIHRoZSBjb250ZW50IGVsZW1lbnQsIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBpbnNpZGUgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGFuZCBkb2Vzbid0IGluY2x1ZGUgdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXJzLiBXZSBhbHNvIGNhbid0IHVzZSBhbiAnYXV0bycgb3V0bGluZSwgc2luY2UgdGhvc2VcbiAgICAgICAgICAgIC8vIGFyZSwgZm9yIHNvbWUgcmVhc29uLCBkcmF3biBiZWhpbmQgdGhlIGVsZW1lbnQgY29udGVudCwgd2hpY2hcbiAgICAgICAgICAgIC8vIHdpbGwgY2F1c2UgdGhpbmdzIGxpa2UgdGhlIGFjdGl2ZSBsaW5lIGJhY2tncm91bmQgdG8gY292ZXJcbiAgICAgICAgICAgIC8vIHRoZSBvdXRsaW5lICgjMjk3KS5cbiAgICAgICAgICAgIG91dGxpbmU6IFwiMXB4IGRvdHRlZCAjMjEyMTIxXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIlxuICAgIH0sXG4gICAgXCIuY20tc2Nyb2xsZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLFxuICAgICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnQgIWltcG9ydGFudFwiLFxuICAgICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjQsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG92ZXJmbG93WDogXCJhdXRvXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIHpJbmRleDogMFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgZmxleEdyb3c6IDIsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgICAgICAgd29yZFdyYXA6IFwibm9ybWFsXCIsIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDU2XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIG1pbkhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiNHB4IDBcIixcbiAgICAgICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgICAgIFwiJltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cIjoge1xuICAgICAgICAgICAgV2Via2l0VXNlck1vZGlmeTogXCJyZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5XCIsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbmVXcmFwcGluZ1wiOiB7XG4gICAgICAgIHdoaXRlU3BhY2VfZmFsbGJhY2s6IFwicHJlLXdyYXBcIiwgLy8gRm9yIElFXG4gICAgICAgIHdoaXRlU3BhY2U6IFwiYnJlYWstc3BhY2VzXCIsXG4gICAgICAgIHdvcmRCcmVhazogXCJicmVhay13b3JkXCIsIC8vIEZvciBTYWZhcmksIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBvdmVyZmxvdy13cmFwOiBhbnl3aGVyZVxuICAgICAgICBvdmVyZmxvd1dyYXA6IFwiYW55d2hlcmVcIixcbiAgICAgICAgZmxleFNocmluazogMVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcImJsYWNrXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJ3aGl0ZVwiIH0sXG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgcGFkZGluZzogXCIwIDJweCAwIDZweFwiXG4gICAgfSxcbiAgICBcIi5jbS1sYXllclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgY29udGFpbjogXCJzaXplIHN0eWxlXCIsXG4gICAgICAgIFwiJiA+ICpcIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiI2Q5ZDlkOVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjIyXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0LmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkN2Q0ZjBcIlxuICAgIH0sXG4gICAgXCImZGFyay5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLXNlbGVjdGlvbkxheWVyIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjMzXCJcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBcInN0ZXBzKDEpIGNtLWJsaW5rIDEuMnMgaW5maW5pdGVcIlxuICAgIH0sXG4gICAgLy8gVHdvIGFuaW1hdGlvbnMgZGVmaW5lZCBzbyB0aGF0IHdlIGNhbiBzd2l0Y2ggYmV0d2VlbiB0aGVtIHRvXG4gICAgLy8gcmVzdGFydCB0aGUgYW5pbWF0aW9uIHdpdGhvdXQgZm9yY2luZyBhbm90aGVyIHN0eWxlXG4gICAgLy8gcmVjb21wdXRhdGlvbi5cbiAgICBcIkBrZXlmcmFtZXMgY20tYmxpbmtcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rMlwiOiB7IFwiMCVcIjoge30sIFwiNTAlXCI6IHsgb3BhY2l0eTogMCB9LCBcIjEwMCVcIjoge30gfSxcbiAgICBcIi5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdDogXCIxLjJweCBzb2xpZCBibGFja1wiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0wLjZweFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICB9LFxuICAgIFwiLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBib3JkZXJMZWZ0Q29sb3I6IFwiIzQ0NFwiXG4gICAgfSxcbiAgICBcIi5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tY3Vyc29yTGF5ZXIgLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH0sXG4gICAgXCIuY20taXNvXCI6IHtcbiAgICAgICAgdW5pY29kZUJpZGk6IFwiaXNvbGF0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS1hbm5vdW5jZWRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICB0b3A6IFwiLTEwMDAwcHhcIlxuICAgIH0sXG4gICAgXCJAbWVkaWEgcHJpbnRcIjoge1xuICAgICAgICBcIi5jbS1hbm5vdW5jZWRcIjogeyBkaXNwbGF5OiBcIm5vbmVcIiB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjY2NlZWZmNDRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzk5ZWVmZjMzXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCJyZWRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwiI2Y3OFwiIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBpbnNldElubGluZVN0YXJ0OiAwLFxuICAgICAgICB6SW5kZXg6IDIwMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCIjNmM2YzZjXCIsXG4gICAgICAgIGJvcmRlclJpZ2h0OiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCIjY2NjXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsIC8vIE5lY2Vzc2FyeSAtLSBwcmV2ZW50cyBtYXJnaW4gY29sbGFwc2luZ1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiLmNtLWxpbmVOdW1iZXJzIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDNweCAwIDVweFwiLFxuICAgICAgICBtaW5XaWR0aDogXCIyMHB4XCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJyaWdodFwiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZTJmMmZmXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzIyMjIyN1wiXG4gICAgfSxcbiAgICBcIi5jbS1wYW5lbHNcIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLXRvcFwiOiB7XG4gICAgICAgIGJvcmRlckJvdHRvbTogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tcGFuZWxzLWJvdHRvbVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1wYW5lbHNcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10YWJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJib3R0b21cIlxuICAgIH0sXG4gICAgXCIuY20td2lkZ2V0QnVmZmVyXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgICAgICBoZWlnaHQ6IFwiMWVtXCIsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1wbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJ0b3BcIixcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFNwYWNlOmJlZm9yZVwiOiB7XG4gICAgICAgIGNvbnRlbnQ6IFwiYXR0cihkYXRhLWRpc3BsYXkpXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICBjb2xvcjogXCIjODg4XCJcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFRhYlwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgnZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjBcIj48cGF0aCBzdHJva2U9XCIlMjM4ODhcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBkPVwiTTEgMTBIMTk2TDE5MCA1TTE5MCAxNUwxOTYgMTBNMTk3IDRMMTk3IDE2XCIvPjwvc3ZnPicpYCxcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IFwiYXV0byAxMDAlXCIsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJyaWdodCA5MCVcIixcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIlxuICAgIH0sXG4gICAgXCIuY20tdHJhaWxpbmdTcGFjZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmYzMzIyNTVcIlxuICAgIH0sXG4gICAgXCIuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIDFlbVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNlZmYxZjUsICNkOWQ5ZGYpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2I0YjRiNCwgI2QwZDNkNilcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMzOTM5MzksICMxMTEpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzExMSwgIzMzMylcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gLjVlbVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzU1NVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfVxufSwgbGlnaHREYXJrSURzKTtcblxuY29uc3QgTGluZUJyZWFrUGxhY2Vob2xkZXIgPSBcIlxcdWZmZmZcIjtcbmNsYXNzIERPTVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzLCBzdGF0ZSkge1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5saW5lU2VwYXJhdG9yID0gc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcik7XG4gICAgfVxuICAgIGFwcGVuZCh0ZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCArPSB0ZXh0O1xuICAgIH1cbiAgICBsaW5lQnJlYWsoKSB7XG4gICAgICAgIHRoaXMudGV4dCArPSBMaW5lQnJlYWtQbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmVhZFJhbmdlKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcGFyZW50ID0gc3RhcnQucGFyZW50Tm9kZTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBjdXIpO1xuICAgICAgICAgICAgbGV0IG9sZExlbiA9IHRoaXMudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlYWROb2RlKGN1cik7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN1ci5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChuZXh0ID09IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1ciksIG5leHRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgaWYgKHZpZXcgJiYgbmV4dFZpZXcgPyB2aWV3LmJyZWFrQWZ0ZXIgOlxuICAgICAgICAgICAgICAgICh2aWV3ID8gdmlldy5icmVha0FmdGVyIDogaXNCbG9ja0VsZW1lbnQoY3VyKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQmxvY2tFbGVtZW50KG5leHQpICYmIChjdXIubm9kZU5hbWUgIT0gXCJCUlwiIHx8IGN1ci5jbUlnbm9yZSkgJiYgdGhpcy50ZXh0Lmxlbmd0aCA+IG9sZExlbikpXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBlbmQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVhZFRleHROb2RlKG5vZGUpIHtcbiAgICAgICAgbGV0IHRleHQgPSBub2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlKVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGggKyBNYXRoLm1pbihwb2ludC5vZmZzZXQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gMCwgcmUgPSB0aGlzLmxpbmVTZXBhcmF0b3IgPyBudWxsIDogL1xcclxcbj98XFxuL2c7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IC0xLCBicmVha1NpemUgPSAxLCBtO1xuICAgICAgICAgICAgaWYgKHRoaXMubGluZVNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIG5leHRCcmVhayA9IHRleHQuaW5kZXhPZih0aGlzLmxpbmVTZXBhcmF0b3IsIG9mZik7XG4gICAgICAgICAgICAgICAgYnJlYWtTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG0gPSByZS5leGVjKHRleHQpKSB7XG4gICAgICAgICAgICAgICAgbmV4dEJyZWFrID0gbS5pbmRleDtcbiAgICAgICAgICAgICAgICBicmVha1NpemUgPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKHRleHQuc2xpY2Uob2ZmLCBuZXh0QnJlYWsgPCAwID8gdGV4dC5sZW5ndGggOiBuZXh0QnJlYWspKTtcbiAgICAgICAgICAgIGlmIChuZXh0QnJlYWsgPCAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgICAgIGlmIChicmVha1NpemUgPiAxKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIHBvaW50LnBvcyA+IHRoaXMudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5wb3MgLT0gYnJlYWtTaXplIC0gMTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRCcmVhayArIGJyZWFrU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNtSWdub3JlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChub2RlKTtcbiAgICAgICAgbGV0IGZyb21WaWV3ID0gdmlldyAmJiB2aWV3Lm92ZXJyaWRlRE9NVGV4dDtcbiAgICAgICAgaWYgKGZyb21WaWV3ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50SW5zaWRlKG5vZGUsIGZyb21WaWV3Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbVZpZXcuaXRlcigpOyAhaS5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICBpZiAoaS5saW5lQnJlYWspXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChpLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFRleHROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJCUlwiKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZylcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmFuZ2Uobm9kZS5maXJzdENoaWxkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kUG9pbnRCZWZvcmUobm9kZSwgbmV4dCkge1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChwb2ludC5ub2RlID09IG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzW3BvaW50Lm9mZnNldF0gPT0gbmV4dClcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5kUG9pbnRJbnNpZGUobm9kZSwgbGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyA/IHBvaW50Lm5vZGUgPT0gbm9kZSA6IG5vZGUuY29udGFpbnMocG9pbnQubm9kZSkpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIChpc0F0RW5kKG5vZGUsIHBvaW50Lm5vZGUsIHBvaW50Lm9mZnNldCkgPyBsZW5ndGggOiAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0F0RW5kKHBhcmVudCwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoIW5vZGUgfHwgb2Zmc2V0IDwgbWF4T2Zmc2V0KG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAxICYmIC9eKERJVnxQfExJfFVMfE9MfEJMT0NLUVVPVEV8RER8RFR8SFxcZHxTRUNUSU9OfFBSRSkkLy50ZXN0KG5vZGUubm9kZU5hbWUpO1xufVxuY2xhc3MgRE9NUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wb3MgPSAtMTtcbiAgICB9XG59XG5cbmNsYXNzIERPTUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnQsIGVuZCwgdHlwZU92ZXIpIHtcbiAgICAgICAgdGhpcy50eXBlT3ZlciA9IHR5cGVPdmVyO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB7IGltcHJlY2lzZUhlYWQ6IGlIZWFkLCBpbXByZWNpc2VBbmNob3I6IGlBbmNob3IgfSA9IHZpZXcuZG9jVmlldztcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkgJiYgc3RhcnQgPiAtMSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGNoYW5nZXMgd2hlbiB0aGUgZWRpdG9yIGlzIHJlYWQtb25seVxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0ID4gLTEgJiYgKHRoaXMuYm91bmRzID0gdmlldy5kb2NWaWV3LmRvbUJvdW5kc0Fyb3VuZChzdGFydCwgZW5kLCAwKSkpIHtcbiAgICAgICAgICAgIGxldCBzZWxQb2ludHMgPSBpSGVhZCB8fCBpQW5jaG9yID8gW10gOiBzZWxlY3Rpb25Qb2ludHModmlldyk7XG4gICAgICAgICAgICBsZXQgcmVhZGVyID0gbmV3IERPTVJlYWRlcihzZWxQb2ludHMsIHZpZXcuc3RhdGUpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRSYW5nZSh0aGlzLmJvdW5kcy5zdGFydERPTSwgdGhpcy5ib3VuZHMuZW5kRE9NKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHJlYWRlci50ZXh0O1xuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBzZWxlY3Rpb25Gcm9tUG9pbnRzKHNlbFBvaW50cywgdGhpcy5ib3VuZHMuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZG9tU2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgICAgIGxldCBoZWFkID0gaUhlYWQgJiYgaUhlYWQubm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIGlIZWFkLm9mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGFuY2hvciA9IGlBbmNob3IgJiYgaUFuY2hvci5ub2RlID09IGRvbVNlbC5hbmNob3JOb2RlICYmIGlBbmNob3Iub2Zmc2V0ID09IGRvbVNlbC5hbmNob3JPZmZzZXQgfHxcbiAgICAgICAgICAgICAgICAhY29udGFpbnModmlldy5jb250ZW50RE9NLCBkb21TZWwuYW5jaG9yTm9kZSlcbiAgICAgICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yXG4gICAgICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAvLyBpT1Mgd2lsbCByZWZ1c2UgdG8gc2VsZWN0IHRoZSBibG9jayBnYXBzIHdoZW4gZG9pbmdcbiAgICAgICAgICAgIC8vIHNlbGVjdC1hbGwuXG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBwdXQgdGhlIHNlbGVjdGlvbiAqaW5zaWRlKiB0aGVtLCBjb25mdXNpbmdcbiAgICAgICAgICAgIC8vIHBvc0Zyb21ET01cbiAgICAgICAgICAgIGxldCB2cCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIuaW9zIHx8IGJyb3dzZXIuY2hyb21lKSAmJiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmIGhlYWQgIT0gYW5jaG9yICYmXG4gICAgICAgICAgICAgICAgKHZwLmZyb20gPiAwIHx8IHZwLnRvIDwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oaGVhZCwgYW5jaG9yKSwgdG8gPSBNYXRoLm1heChoZWFkLCBhbmNob3IpO1xuICAgICAgICAgICAgICAgIGxldCBvZmZGcm9tID0gdnAuZnJvbSAtIGZyb20sIG9mZlRvID0gdnAudG8gLSB0bztcbiAgICAgICAgICAgICAgICBpZiAoKG9mZkZyb20gPT0gMCB8fCBvZmZGcm9tID09IDEgfHwgZnJvbSA9PSAwKSAmJiAob2ZmVG8gPT0gMCB8fCBvZmZUbyA9PSAtMSB8fCB0byA9PSB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSB2aWV3LnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseURPTUNoYW5nZSh2aWV3LCBkb21DaGFuZ2UpIHtcbiAgICBsZXQgY2hhbmdlO1xuICAgIGxldCB7IG5ld1NlbCB9ID0gZG9tQ2hhbmdlLCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBsYXN0S2V5ID0gdmlldy5pbnB1dFN0YXRlLmxhc3RLZXlUaW1lID4gRGF0ZS5ub3coKSAtIDEwMCA/IHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA6IC0xO1xuICAgIGlmIChkb21DaGFuZ2UuYm91bmRzKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBkb21DaGFuZ2UuYm91bmRzO1xuICAgICAgICBsZXQgcHJlZmVycmVkUG9zID0gc2VsLmZyb20sIHByZWZlcnJlZFNpZGUgPSBudWxsO1xuICAgICAgICAvLyBQcmVmZXIgYW5jaG9yaW5nIHRvIGVuZCB3aGVuIEJhY2tzcGFjZSBpcyBwcmVzc2VkIChvciwgb25cbiAgICAgICAgLy8gQW5kcm9pZCwgd2hlbiBzb21ldGhpbmcgd2FzIGRlbGV0ZWQpXG4gICAgICAgIGlmIChsYXN0S2V5ID09PSA4IHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBkb21DaGFuZ2UudGV4dC5sZW5ndGggPCB0byAtIGZyb20pIHtcbiAgICAgICAgICAgIHByZWZlcnJlZFBvcyA9IHNlbC50bztcbiAgICAgICAgICAgIHByZWZlcnJlZFNpZGUgPSBcImVuZFwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWZmID0gZmluZERpZmYodmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIExpbmVCcmVha1BsYWNlaG9sZGVyKSwgZG9tQ2hhbmdlLnRleHQsIHByZWZlcnJlZFBvcyAtIGZyb20sIHByZWZlcnJlZFNpZGUpO1xuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGluc2VydHMgdHdvIG5ld2xpbmVzIHdoZW4gcHJlc3Npbmcgc2hpZnQtZW50ZXIgYXQgdGhlXG4gICAgICAgICAgICAvLyBlbmQgb2YgYSBsaW5lLiBEb21DaGFuZ2UgZHJvcHMgb25lIG9mIHRob3NlLlxuICAgICAgICAgICAgaWYgKGJyb3dzZXIuY2hyb21lICYmIGxhc3RLZXkgPT0gMTMgJiZcbiAgICAgICAgICAgICAgICBkaWZmLnRvQiA9PSBkaWZmLmZyb20gKyAyICYmIGRvbUNoYW5nZS50ZXh0LnNsaWNlKGRpZmYuZnJvbSwgZGlmZi50b0IpID09IExpbmVCcmVha1BsYWNlaG9sZGVyICsgTGluZUJyZWFrUGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAgICAgZGlmZi50b0ItLTtcbiAgICAgICAgICAgIGNoYW5nZSA9IHsgZnJvbTogZnJvbSArIGRpZmYuZnJvbSwgdG86IGZyb20gKyBkaWZmLnRvQSxcbiAgICAgICAgICAgICAgICBpbnNlcnQ6IFRleHQub2YoZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikuc3BsaXQoTGluZUJyZWFrUGxhY2Vob2xkZXIpKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5ld1NlbCAmJiAoIXZpZXcuaGFzRm9jdXMgJiYgdmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgfHwgbmV3U2VsLm1haW4uZXEoc2VsKSkpIHtcbiAgICAgICAgbmV3U2VsID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UgJiYgIW5ld1NlbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghY2hhbmdlICYmIGRvbUNoYW5nZS50eXBlT3ZlciAmJiAhc2VsLmVtcHR5ICYmIG5ld1NlbCAmJiBuZXdTZWwubWFpbi5lbXB0eSkge1xuICAgICAgICAvLyBIZXVyaXN0aWMgdG8gbm90aWNlIHR5cGluZyBvdmVyIGEgc2VsZWN0ZWQgY2hhcmFjdGVyXG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIHNlbC50bykgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlICYmIGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiZcbiAgICAgICAgKGNoYW5nZS5mcm9tICE9IHNlbC5mcm9tIHx8IGNoYW5nZS50byAhPSBzZWwudG8pICYmXG4gICAgICAgIChzZWwudG8gLSBzZWwuZnJvbSkgLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pIDw9IDQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoYW5nZSBpcyBpbnNpZGUgdGhlIHNlbGVjdGlvbiBhbmQgY292ZXJzIG1vc3Qgb2YgaXQsXG4gICAgICAgIC8vIGFzc3VtZSBpdCBpcyBhIHNlbGVjdGlvbiByZXBsYWNlICh3aXRoIGlkZW50aWNhbCBjaGFyYWN0ZXJzIGF0XG4gICAgICAgIC8vIHRoZSBzdGFydC9lbmQgbm90IGluY2x1ZGVkIGluIHRoZSBkaWZmKVxuICAgICAgICBjaGFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50byxcbiAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIGNoYW5nZS5mcm9tKS5hcHBlbmQoY2hhbmdlLmluc2VydCkuYXBwZW5kKHZpZXcuc3RhdGUuZG9jLnNsaWNlKGNoYW5nZS50bywgc2VsLnRvKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGJyb3dzZXIubWFjIHx8IGJyb3dzZXIuYW5kcm9pZCkgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAtIDEgJiZcbiAgICAgICAgL15cXC4gPyQvLnRlc3QoY2hhbmdlLmluc2VydC50b1N0cmluZygpKSAmJiB2aWV3LmNvbnRlbnRET00uZ2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIikgPT0gXCJvZmZcIikge1xuICAgICAgICAvLyBEZXRlY3QgaW5zZXJ0LXBlcmlvZC1vbi1kb3VibGUtc3BhY2UgTWFjIGFuZCBBbmRyb2lkIGJlaGF2aW9yLFxuICAgICAgICAvLyBhbmQgdHJhbnNmb3JtIGl0IGludG8gYSByZWd1bGFyIHNwYWNlIGluc2VydC5cbiAgICAgICAgaWYgKG5ld1NlbCAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAyKVxuICAgICAgICAgICAgbmV3U2VsID0gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShuZXdTZWwubWFpbi5hbmNob3IgLSAxLCBuZXdTZWwubWFpbi5oZWFkIC0gMSk7XG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogVGV4dC5vZihbXCIgXCJdKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChicm93c2VyLmNocm9tZSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkICYmXG4gICAgICAgIGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKSA9PSBcIlxcbiBcIiAmJiB2aWV3LmxpbmVXcmFwcGluZykge1xuICAgICAgICAvLyBJbiBDaHJvbWUsIGlmIHlvdSBpbnNlcnQgYSBzcGFjZSBhdCB0aGUgc3RhcnQgb2YgYSB3cmFwcGVkXG4gICAgICAgIC8vIGxpbmUsIGl0IHdpbGwgYWN0dWFsbHkgaW5zZXJ0IGEgbmV3bGluZSBhbmQgYSBzcGFjZSwgY2F1c2luZyBhXG4gICAgICAgIC8vIGJvZ3VzIG5ldyBsaW5lIHRvIGJlIGNyZWF0ZWQgaW4gQ29kZU1pcnJvciAoIzk2OClcbiAgICAgICAgaWYgKG5ld1NlbClcbiAgICAgICAgICAgIG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV3U2VsLm1haW4uYW5jaG9yIC0gMSwgbmV3U2VsLm1haW4uaGVhZCAtIDEpO1xuICAgICAgICBjaGFuZ2UgPSB7IGZyb206IHNlbC5mcm9tLCB0bzogc2VsLnRvLCBpbnNlcnQ6IFRleHQub2YoW1wiIFwiXSkgfTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgICBpZiAoYnJvd3Nlci5pb3MgJiYgdmlldy5pbnB1dFN0YXRlLmZsdXNoSU9TS2V5KCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQW5kcm9pZCBicm93c2VycyBkb24ndCBmaXJlIHJlYXNvbmFibGUga2V5IGV2ZW50cyBmb3IgZW50ZXIsXG4gICAgICAgIC8vIGJhY2tzcGFjZSwgb3IgZGVsZXRlLiBTbyB0aGlzIGRldGVjdHMgY2hhbmdlcyB0aGF0IGxvb2sgbGlrZVxuICAgICAgICAvLyB0aGV5J3JlIGNhdXNlZCBieSB0aG9zZSBrZXlzLCBhbmQgcmVpbnRlcnByZXRzIHRoZW0gYXMga2V5XG4gICAgICAgIC8vIGV2ZW50cy4gKFNvbWUgb2YgdGhlc2Uga2V5cyBhcmUgYWxzbyBoYW5kbGVkIGJ5IGJlZm9yZWlucHV0XG4gICAgICAgIC8vIGV2ZW50cyBhbmQgdGhlIHBlbmRpbmdBbmRyb2lkS2V5IG1lY2hhbmlzbSwgYnV0IHRoYXQncyBub3RcbiAgICAgICAgLy8gcmVsaWFibGUgaW4gYWxsIHNpdHVhdGlvbnMuKVxuICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmXG4gICAgICAgICAgICAoKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS5pbnNlcnQubGluZXMgPT0gMiAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJFbnRlclwiLCAxMykpIHx8XG4gICAgICAgICAgICAgICAgKChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAtIDEgJiYgY2hhbmdlLnRvID09IHNlbC50byAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIGxhc3RLZXkgPT0gOCAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA8IGNoYW5nZS50byAtIGNoYW5nZS5mcm9tICYmIGNoYW5nZS50byA+IHNlbC5oZWFkKSAmJlxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiQmFja3NwYWNlXCIsIDgpKSB8fFxuICAgICAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICsgMSAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJEZWxldGVcIiwgNDYpKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHRleHQgPSBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nKys7XG4gICAgICAgIGxldCBkZWZhdWx0VHI7XG4gICAgICAgIGxldCBkZWZhdWx0SW5zZXJ0ID0gKCkgPT4gZGVmYXVsdFRyIHx8IChkZWZhdWx0VHIgPSBhcHBseURlZmF1bHRJbnNlcnQodmlldywgY2hhbmdlLCBuZXdTZWwpKTtcbiAgICAgICAgaWYgKCF2aWV3LnN0YXRlLmZhY2V0KGlucHV0SGFuZGxlcikuc29tZShoID0+IGgodmlldywgY2hhbmdlLmZyb20sIGNoYW5nZS50bywgdGV4dCwgZGVmYXVsdEluc2VydCkpKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaChkZWZhdWx0SW5zZXJ0KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICFuZXdTZWwubWFpbi5lcShzZWwpKSB7XG4gICAgICAgIGxldCBzY3JvbGxJbnRvVmlldyA9IGZhbHNlLCB1c2VyRXZlbnQgPSBcInNlbGVjdFwiO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwKSB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW4gPT0gXCJzZWxlY3RcIilcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldyA9IHRydWU7XG4gICAgICAgICAgICB1c2VyRXZlbnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiBuZXdTZWwsIHNjcm9sbEludG9WaWV3LCB1c2VyRXZlbnQgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdEluc2VydCh2aWV3LCBjaGFuZ2UsIG5ld1NlbCkge1xuICAgIGxldCB0ciwgc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGUsIHNlbCA9IHN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gPj0gKHNlbC50byAtIHNlbC5mcm9tKSAvIDMgJiZcbiAgICAgICAgKCFuZXdTZWwgfHwgbmV3U2VsLm1haW4uZW1wdHkgJiYgbmV3U2VsLm1haW4uZnJvbSA9PSBjaGFuZ2UuZnJvbSArIGNoYW5nZS5pbnNlcnQubGVuZ3RoKSAmJlxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICBsZXQgYmVmb3JlID0gc2VsLmZyb20gPCBjaGFuZ2UuZnJvbSA/IHN0YXJ0U3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIGNoYW5nZS5mcm9tKSA6IFwiXCI7XG4gICAgICAgIGxldCBhZnRlciA9IHNlbC50byA+IGNoYW5nZS50byA/IHN0YXJ0U3RhdGUuc2xpY2VEb2MoY2hhbmdlLnRvLCBzZWwudG8pIDogXCJcIjtcbiAgICAgICAgdHIgPSBzdGFydFN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odmlldy5zdGF0ZS50b1RleHQoYmVmb3JlICsgY2hhbmdlLmluc2VydC5zbGljZVN0cmluZygwLCB1bmRlZmluZWQsIHZpZXcuc3RhdGUubGluZUJyZWFrKSArIGFmdGVyKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyhjaGFuZ2UpO1xuICAgICAgICBsZXQgbWFpblNlbCA9IG5ld1NlbCAmJiBuZXdTZWwubWFpbi50byA8PSBjaGFuZ2VzLm5ld0xlbmd0aCA/IG5ld1NlbC5tYWluIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBUcnkgdG8gYXBwbHkgYSBjb21wb3NpdGlvbiBjaGFuZ2UgdG8gYWxsIGN1cnNvcnNcbiAgICAgICAgaWYgKHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggPiAxICYmIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJlxuICAgICAgICAgICAgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gPj0gc2VsLnRvIC0gMTApIHtcbiAgICAgICAgICAgIGxldCByZXBsYWNlZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MoY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgICAgICAgICBsZXQgY29tcG9zaXRpb25SYW5nZSwgY29tcG9zaXRpb24gPSBuZXdTZWwgJiYgZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBuZXdTZWwubWFpbi5oZWFkKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBkTGVuID0gY2hhbmdlLmluc2VydC5sZW5ndGggLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pO1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB7IGZyb206IGNvbXBvc2l0aW9uLmZyb20sIHRvOiBjb21wb3NpdGlvbi50byAtIGRMZW4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uUmFuZ2UgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc2VsLmhlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHNlbC50byAtIGNoYW5nZS50bywgc2l6ZSA9IHNlbC50byAtIHNlbC5mcm9tO1xuICAgICAgICAgICAgdHIgPSBzdGFydFN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIHJhbmdlLnRvID09IHNlbC50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlcywgcmFuZ2U6IG1haW5TZWwgfHwgcmFuZ2UubWFwKGNoYW5nZXMpIH07XG4gICAgICAgICAgICAgICAgbGV0IHRvID0gcmFuZ2UudG8gLSBvZmZzZXQsIGZyb20gPSB0byAtIHJlcGxhY2VkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UudG8gLSByYW5nZS5mcm9tICE9IHNpemUgfHwgdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0bykgIT0gcmVwbGFjZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUncyBubyB3YXkgdG8gbWFrZSBtdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIGluIHRoZSBzYW1lIG5vZGUgd29yayB3aXRob3V0IGFib3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvc2l0aW9uLCBzbyBjdXJzb3JzIGluIHRoZSBjb21wb3NpdGlvbiByYW5nZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UudG8gPj0gY29tcG9zaXRpb25SYW5nZS5mcm9tICYmIHJhbmdlLmZyb20gPD0gY29tcG9zaXRpb25SYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VDaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKHsgZnJvbSwgdG8sIGluc2VydDogY2hhbmdlLmluc2VydCB9KSwgc2VsT2ZmID0gcmFuZ2UudG8gLSBzZWwudG87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VDaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogIW1haW5TZWwgPyByYW5nZS5tYXAocmFuZ2VDaGFuZ2VzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoTWF0aC5tYXgoMCwgbWFpblNlbC5hbmNob3IgKyBzZWxPZmYpLCBNYXRoLm1heCgwLCBtYWluU2VsLmhlYWQgKyBzZWxPZmYpKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyID0ge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBtYWluU2VsICYmIHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJlcGxhY2VSYW5nZShtYWluU2VsKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdXNlckV2ZW50ID0gXCJpbnB1dC50eXBlXCI7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nIHx8XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA+IERhdGUubm93KCkgLSA1MCkge1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHVzZXJFdmVudCArPSBcIi5jb21wb3NlXCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSkge1xuICAgICAgICAgICAgdXNlckV2ZW50ICs9IFwiLnN0YXJ0XCI7XG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydFN0YXRlLnVwZGF0ZSh0ciwgeyB1c2VyRXZlbnQsIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IG1pbkxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgbGV0IGZyb20gPSAwO1xuICAgIHdoaWxlIChmcm9tIDwgbWluTGVuICYmIGEuY2hhckNvZGVBdChmcm9tKSA9PSBiLmNoYXJDb2RlQXQoZnJvbSkpXG4gICAgICAgIGZyb20rKztcbiAgICBpZiAoZnJvbSA9PSBtaW5MZW4gJiYgYS5sZW5ndGggPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0b0EgPSBhLmxlbmd0aCwgdG9CID0gYi5sZW5ndGg7XG4gICAgd2hpbGUgKHRvQSA+IDAgJiYgdG9CID4gMCAmJiBhLmNoYXJDb2RlQXQodG9BIC0gMSkgPT0gYi5jaGFyQ29kZUF0KHRvQiAtIDEpKSB7XG4gICAgICAgIHRvQS0tO1xuICAgICAgICB0b0ItLTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgZnJvbSAtIE1hdGgubWluKHRvQSwgdG9CKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSB0b0EgKyBhZGp1c3QgLSBmcm9tO1xuICAgIH1cbiAgICBpZiAodG9BIDwgZnJvbSAmJiBhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQSA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQiA9IGZyb20gKyAodG9CIC0gdG9BKTtcbiAgICAgICAgdG9BID0gZnJvbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9CIDwgZnJvbSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0IgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0EgPSBmcm9tICsgKHRvQSAtIHRvQik7XG4gICAgICAgIHRvQiA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIHRvQSwgdG9CIH07XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Qb2ludHModmlldykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSk7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT0gYW5jaG9yTm9kZSB8fCBmb2N1c09mZnNldCAhPSBhbmNob3JPZmZzZXQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbVBvaW50cyhwb2ludHMsIGJhc2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yID0gcG9pbnRzWzBdLnBvcywgaGVhZCA9IHBvaW50cy5sZW5ndGggPT0gMiA/IHBvaW50c1sxXS5wb3MgOiBhbmNob3I7XG4gICAgcmV0dXJuIGFuY2hvciA+IC0xICYmIGhlYWQgPiAtMSA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yICsgYmFzZSwgaGVhZCArIGJhc2UpIDogbnVsbDtcbn1cblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG9cbi8vIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZCB0aGVyZVxuY29uc3QgdXNlQ2hhckRhdGEgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBrbm93biBzZWxlY3Rpb24uIEtlcHQgaW4gb3VyIG93biBvYmplY3QsIGFzIG9wcG9zZWQgdG8ganVzdFxuICAgICAgICAvLyBkaXJlY3RseSBhY2Nlc3NpbmcgdGhlIHNlbGVjdGlvbiBiZWNhdXNlOlxuICAgICAgICAvLyAgLSBTYWZhcmkgZG9lc24ndCByZXBvcnQgdGhlIHJpZ2h0IHNlbGVjdGlvbiBpbiBzaGFkb3cgRE9NXG4gICAgICAgIC8vICAtIFJlYWRpbmcgZnJvbSB0aGUgc2VsZWN0aW9uIGZvcmNlcyBhIERPTSBsYXlvdXRcbiAgICAgICAgLy8gIC0gVGhpcyB3YXksIHdlIGNhbiBpZ25vcmUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50cyBpZiB3ZSBoYXZlXG4gICAgICAgIC8vICAgIGFscmVhZHkgc2VlbiB0aGUgJ25ldycgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2UgPSBuZXcgRE9NU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIC8vIFNldCB3aGVuIGEgc2VsZWN0aW9uIGNoYW5nZSBpcyBkZXRlY3RlZCwgY2xlYXJlZCBvbiBmbHVzaFxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZSA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzaXplU2Nyb2xsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhcHMgPSBbXTtcbiAgICAgICAgLy8gVGltZW91dCBmb3Igc2NoZWR1bGluZyBjaGVjayBvZiB0aGUgcGFyZW50cyB0aGF0IG5lZWQgc2Nyb2xsIGhhbmRsZXJzXG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgdGhpcy5kb20gPSB2aWV3LmNvbnRlbnRET007XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIG11dGF0aW9ucylcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIHR5cGluZyBvdmVyIGEgc2VsZWN0aW9uIG9yXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyIHRleHQgbm9kZSkgY2FsbCB0aGVcbiAgICAgICAgICAgIC8vIG9ic2VydmVyIGNhbGxiYWNrIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVucmVsYXRlZGx5LCBpT1MgU2FmYXJpIHdpbGwsIHdoZW4gZW5kaW5nIGEgY29tcG9zaXRpb24sXG4gICAgICAgICAgICAvLyBzb21ldGltZXMgZmlyc3QgY2xlYXIgaXQsIGRlbGl2ZXIgdGhlIG11dGF0aW9ucywgYW5kIHRoZW5cbiAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBmaW5pc2hlZCB0ZXh0LiBDb2RlTWlycm9yJ3MgaGFuZGxpbmcgb2YgdGhlXG4gICAgICAgICAgICAvLyBkZWxldGlvbiB3aWxsIHByZXZlbnQgdGhlIHJlaW5zZXJ0aW9uIGZyb20gaGFwcGVuaW5nLFxuICAgICAgICAgICAgLy8gYnJlYWtpbmcgY29tcG9zaXRpb24uXG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuaW9zICYmIHZpZXcuY29tcG9zaW5nKSAmJlxuICAgICAgICAgICAgICAgIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnQucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVzaXplID0gdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUHJpbnQgPSB0aGlzLm9uUHJpbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbCA9IHRoaXMub25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnZpZXcuZG9jVmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RVcGRhdGUpIDwgRGF0ZS5ub3coKSAtIDc1KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplU2Nyb2xsLm9ic2VydmUodmlldy5zY3JvbGxET00pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luID0gdmlldy53aW4pO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRDaGVjayA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSBzZXRUaW1lb3V0KHRoaXMubGlzdGVuRm9yU2Nyb2xsLmJpbmQodGhpcyksIDEwMDApO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDAgJiYgKGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApICE9IHRoaXMuaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW5nID0gIXRoaXMuaW50ZXJzZWN0aW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcgIT0gdGhpcy52aWV3LmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMCwgLjAwMV0gfSk7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5vYnNlcnZlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5Gb3JTY3JvbGwoKTtcbiAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICB9XG4gICAgb25TY3JvbGxDaGFuZ2VkKGUpIHtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUucnVuSGFuZGxlcnMoXCJzY3JvbGxcIiwgZSk7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcbiAgICAgICAgICAgIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gICAgfVxuICAgIG9uU2Nyb2xsKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgICAgIHRoaXMub25TY3JvbGxDaGFuZ2VkKGUpO1xuICAgIH1cbiAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgb25QcmludCgpIHtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIHVwZGF0ZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAodGhpcy5nYXBJbnRlcnNlY3Rpb24gJiYgKGdhcHMubGVuZ3RoICE9IHRoaXMuZ2Fwcy5sZW5ndGggfHwgdGhpcy5nYXBzLnNvbWUoKGcsIGkpID0+IGcgIT0gZ2Fwc1tpXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5vYnNlcnZlKGdhcCk7XG4gICAgICAgICAgICB0aGlzLmdhcHMgPSBnYXBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGxldCB3YXNDaGFuZ2VkID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2VkO1xuICAgICAgICBpZiAoIXRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCkgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgc2VsID0gdGhpcy5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5kb20gOiAhaGFzU2VsZWN0aW9uKHZpZXcuZG9tLCBzZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29udGV4dCA9IHNlbC5hbmNob3JOb2RlICYmIHZpZXcuZG9jVmlldy5uZWFyZXN0KHNlbC5hbmNob3JOb2RlKTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5pZ25vcmVFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIGlmICghd2FzQ2hhbmdlZClcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIGhhcyBhIHNpbWlsYXIgaXNzdWUgd2hlbiBiYWNrc3BhY2luZyBvdXQgYVxuICAgICAgICAvLyBzZWxlY3Rpb24gKCM2NDUpLlxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSkgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiZcbiAgICAgICAgICAgIC8vIChTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUUpXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgfVxuICAgIHJlYWRTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgLy8gVGhlIFNlbGVjdGlvbiBvYmplY3QgaXMgYnJva2VuIGluIHNoYWRvdyByb290cyBpbiBTYWZhcmkuIFNlZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQxNFxuICAgICAgICBsZXQgcmFuZ2UgPSBicm93c2VyLnNhZmFyaSAmJiB2aWV3LnJvb3Qubm9kZVR5cGUgPT0gMTEgJiZcbiAgICAgICAgICAgIGRlZXBBY3RpdmVFbGVtZW50KHRoaXMuZG9tLm93bmVyRG9jdW1lbnQpID09IHRoaXMuZG9tICYmXG4gICAgICAgICAgICBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodGhpcy52aWV3KSB8fCBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgaWYgKCFyYW5nZSB8fCB0aGlzLnNlbGVjdGlvblJhbmdlLmVxKHJhbmdlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGxvY2FsID0gaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCByYW5nZSk7XG4gICAgICAgIC8vIERldGVjdCB0aGUgc2l0dWF0aW9uIHdoZXJlIHRoZSBicm93c2VyIGhhcywgb24gZm9jdXMsIG1vdmVkIHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuIFJlc2V0IGl0IHRvIHRoZVxuICAgICAgICAvLyBwb3NpdGlvbiBmcm9tIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAgICAgIGlmIChsb2NhbCAmJiAhdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lIDwgRGF0ZS5ub3coKSAtIDMwMCAmJlxuICAgICAgICAgICAgYXRFbGVtZW50U3RhcnQodGhpcy5kb20sIHJhbmdlKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIGlmIChsb2NhbClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb25SYW5nZShhbmNob3IsIGhlYWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2xlYXJTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQobnVsbCwgMCwgbnVsbCwgMCk7XG4gICAgfVxuICAgIGxpc3RlbkZvclNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICBsZXQgaSA9IDAsIGNoYW5nZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBkb20gPSB0aGlzLmRvbTsgZG9tOykge1xuICAgICAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmIGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmIHRoaXMuc2Nyb2xsVGFyZ2V0c1tpXSA9PSBkb20pXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmFzc2lnbmVkU2xvdCB8fCBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmICFjaGFuZ2VkKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzID0gY2hhbmdlZClcbiAgICAgICAgICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmUoZikge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgfVxuICAgIC8vIFRocm93IGF3YXkgYW55IHBlbmRpbmcgY2hhbmdlc1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENocm9tZSBBbmRyb2lkLCBlc3BlY2lhbGx5IGluIGNvbWJpbmF0aW9uIHdpdGggR0JvYXJkLCBub3Qgb25seVxuICAgIC8vIGRvZXNuJ3QgcmVsaWFibHkgZmlyZSByZWd1bGFyIGtleSBldmVudHMsIGJ1dCBhbHNvIG9mdGVuXG4gICAgLy8gc3Vycm91bmRzIHRoZSBlZmZlY3Qgb2YgZW50ZXIgb3IgYmFja3NwYWNlIHdpdGggYSBidW5jaCBvZlxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyB0aGF0LCB3aGVuIGludGVycnVwdGVkLCBjYXVzZSB0ZXh0IGR1cGxpY2F0aW9uXG4gICAgLy8gb3Igb3RoZXIga2luZHMgb2YgY29ycnVwdGlvbi4gVGhpcyBoYWNrIG1ha2VzIHRoZSBlZGl0b3IgYmFjayBvZmZcbiAgICAvLyBmcm9tIGhhbmRsaW5nIERPTSBjaGFuZ2VzIGZvciBhIG1vbWVudCB3aGVuIHN1Y2ggYSBrZXkgaXNcbiAgICAvLyBkZXRlY3RlZCAodmlhIGJlZm9yZWlucHV0IG9yIGtleWRvd24pLCBhbmQgdGhlbiB0cmllcyB0byBmbHVzaFxuICAgIC8vIHRoZW0gb3IsIGlmIHRoYXQgaGFzIG5vIGVmZmVjdCwgZGlzcGF0Y2hlcyB0aGUgZ2l2ZW4ga2V5LlxuICAgIGRlbGF5QW5kcm9pZEtleShrZXksIGtleUNvZGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkpIHtcbiAgICAgICAgICAgIGxldCBmbHVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9IGtleS5rZXlDb2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmbHVzaGVkID0gdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZsdXNoZWQgJiYga2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodGhpcy5kb20sIGtleS5rZXksIGtleS5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZShmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgYmFja3NwYWNlIGJlZm9yZWlucHV0IGlzIHNvbWV0aW1lcyBzaWduYWxsZWQgc3B1cmlvdXNseSxcbiAgICAgICAgLy8gRW50ZXIgYWx3YXlzIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSB8fCBrZXkgPT0gXCJFbnRlclwiKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IHtcbiAgICAgICAgICAgICAgICBrZXksIGtleUNvZGUsXG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gdGhlIGtleSBoYW5kbGVyIHdoZW4gbm8gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgaWZcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGNvbWluZyByaWdodCBhZnRlciBhbm90aGVyIGNoYW5nZSwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHByb2JhYmx5IHBhcnQgb2YgYSB3ZWlyZCBjaGFpbiBvZiB1cGRhdGVzLCBhbmQgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gYmUgaWdub3JlZCBpZiBpdCByZXR1cm5zIHRoZSBET00gdG8gaXRzIHByZXZpb3VzIHN0YXRlLlxuICAgICAgICAgICAgICAgIGZvcmNlOiB0aGlzLmxhc3RDaGFuZ2UgPCBEYXRlLm5vdygpIC0gNTAgfHwgISEoKF9hID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlKVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpIHtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHRoaXMuZGVsYXllZEZsdXNoID0gLTE7IHRoaXMuZmx1c2goKTsgfSk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICBwZW5kaW5nUmVjb3JkcygpIHtcbiAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgICB9XG4gICAgcHJvY2Vzc1JlY29yZHMoKSB7XG4gICAgICAgIGxldCByZWNvcmRzID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlYWRNdXRhdGlvbihyZWNvcmQpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gTWF0aC5taW4ocmFuZ2UuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heChyYW5nZS50bywgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0eXBlT3ZlciB9O1xuICAgIH1cbiAgICByZWFkQ2hhbmdlKCkge1xuICAgICAgICBsZXQgeyBmcm9tLCB0bywgdHlwZU92ZXIgfSA9IHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJiBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMuc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgIW5ld1NlbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZnJvbSA+IC0xKVxuICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlID0gbmV3IERPTUNoYW5nZSh0aGlzLnZpZXcsIGZyb20sIHRvLCB0eXBlT3Zlcik7XG4gICAgICAgIHRoaXMudmlldy5kb2NWaWV3LmRvbUNoYW5nZWQgPSB7IG5ld1NlbDogY2hhbmdlLm5ld1NlbCA/IGNoYW5nZS5uZXdTZWwubWFpbiA6IG51bGwgfTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgcGVuZGluZyBjaGFuZ2VzLCBpZiBhbnlcbiAgICBmbHVzaChyZWFkU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgICAgICAvLyBDb21wbGV0ZWx5IGhvbGQgb2ZmIGZsdXNoaW5nIHdoZW4gcGVuZGluZyBrZXlzIGFyZSBzZXTigJR0aGUgY29kZVxuICAgICAgICAvLyBtYW5hZ2luZyB0aG9zZSB3aWxsIG1ha2Ugc3VyZSBwcm9jZXNzUmVjb3JkcyBpcyBjYWxsZWQgYW5kIHRoZVxuICAgICAgICAvLyB2aWV3IGlzIHJlc3luY2hyb25pemVkIGFmdGVyXG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChyZWFkU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IGRvbUNoYW5nZSA9IHRoaXMucmVhZENoYW5nZSgpO1xuICAgICAgICBpZiAoIWRvbUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0U3RhdGUgPSB0aGlzLnZpZXcuc3RhdGU7XG4gICAgICAgIGxldCBoYW5kbGVkID0gYXBwbHlET01DaGFuZ2UodGhpcy52aWV3LCBkb21DaGFuZ2UpO1xuICAgICAgICAvLyBUaGUgdmlldyB3YXNuJ3QgdXBkYXRlZFxuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlID09IHN0YXJ0U3RhdGUpXG4gICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XG4gICAgfVxuICAgIHJlYWRNdXRhdGlvbihyZWMpIHtcbiAgICAgICAgbGV0IGNWaWV3ID0gdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdChyZWMudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFjVmlldyB8fCBjVmlldy5pZ25vcmVNdXRhdGlvbihyZWMpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNWaWV3Lm1hcmtEaXJ0eShyZWMudHlwZSA9PSBcImF0dHJpYnV0ZXNcIik7XG4gICAgICAgIGlmIChyZWMudHlwZSA9PSBcImF0dHJpYnV0ZXNcIilcbiAgICAgICAgICAgIGNWaWV3LmZsYWdzIHw9IDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLztcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZEJlZm9yZSA9IGZpbmRDaGlsZChjVmlldywgcmVjLnByZXZpb3VzU2libGluZyB8fCByZWMudGFyZ2V0LnByZXZpb3VzU2libGluZywgLTEpO1xuICAgICAgICAgICAgbGV0IGNoaWxkQWZ0ZXIgPSBmaW5kQ2hpbGQoY1ZpZXcsIHJlYy5uZXh0U2libGluZyB8fCByZWMudGFyZ2V0Lm5leHRTaWJsaW5nLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNoaWxkQmVmb3JlID8gY1ZpZXcucG9zQWZ0ZXIoY2hpbGRCZWZvcmUpIDogY1ZpZXcucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogY2hpbGRBZnRlciA/IGNWaWV3LnBvc0JlZm9yZShjaGlsZEFmdGVyKSA6IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWMudHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY1ZpZXcucG9zQXRTdGFydCwgdG86IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogcmVjLnRhcmdldC5ub2RlVmFsdWUgPT0gcmVjLm9sZFZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRXaW5kb3cod2luKSB7XG4gICAgICAgIGlmICh3aW4gIT0gdGhpcy53aW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgICAgIHRoaXMud2luID0gd2luO1xuICAgICAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFdpbmRvd0xpc3RlbmVycyh3aW4pIHtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHdpbi5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICByZW1vdmVXaW5kb3dMaXN0ZW5lcnMod2luKSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICB3aW4uZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAoX2EgPSB0aGlzLmludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9iID0gdGhpcy5nYXBJbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYyA9IHRoaXMucmVzaXplU2Nyb2xsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzY29ubmVjdCgpO1xuICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGFyZW50Q2hlY2spO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWxheWVkRmx1c2gpO1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZENoaWxkKGNWaWV3LCBkb20sIGRpcikge1xuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgbGV0IGN1clZpZXcgPSBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgaWYgKGN1clZpZXcgJiYgY3VyVmlldy5wYXJlbnQgPT0gY1ZpZXcpXG4gICAgICAgICAgICByZXR1cm4gY3VyVmlldztcbiAgICAgICAgbGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICBkb20gPSBwYXJlbnQgIT0gY1ZpZXcuZG9tID8gcGFyZW50IDogZGlyID4gMCA/IGRvbS5uZXh0U2libGluZyA6IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWcgKCM0MTQpXG5mdW5jdGlvbiBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodmlldykge1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgLy8gQmVjYXVzZSBTYWZhcmkgKGF0IGxlYXN0IGluIDIwMTgtMjAyMSkgZG9lc24ndCBwcm92aWRlIHJlZ3VsYXJcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgYSBzaGFkb3dyb290LCB3ZSBoYXZlIHRvIHBlcmZvcm0gYVxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXTigJR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxuICAgIC8vIGBiZWZvcmVJbnB1dGAgZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gdGhlXG4gICAgLy8gZXZlbnQuXG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcbiAgICB9XG4gICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICB2aWV3LmRvbS5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuY29udGVudERPTS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFuY2hvck5vZGUgPSBmb3VuZC5zdGFydENvbnRhaW5lciwgYW5jaG9yT2Zmc2V0ID0gZm91bmQuc3RhcnRPZmZzZXQ7XG4gICAgbGV0IGZvY3VzTm9kZSA9IGZvdW5kLmVuZENvbnRhaW5lciwgZm9jdXNPZmZzZXQgPSBmb3VuZC5lbmRPZmZzZXQ7XG4gICAgbGV0IGN1ckFuY2hvciA9IHZpZXcuZG9jVmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvcik7XG4gICAgLy8gU2luY2Ugc3VjaCBhIHJhbmdlIGRvZXNuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbmNob3IgYW5kIGhlYWQsXG4gICAgLy8gdXNlIGEgaGV1cmlzdGljIHRoYXQgZmxpcHMgaXQgYXJvdW5kIGlmIGl0cyBlbmQgbWF0Y2hlcyB0aGVcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cbiAgICBpZiAoaXNFcXVpdmFsZW50UG9zaXRpb24oY3VyQW5jaG9yLm5vZGUsIGN1ckFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuXG4vLyBUaGUgZWRpdG9yJ3MgdXBkYXRlIHN0YXRlIG1hY2hpbmUgbG9va3Mgc29tZXRoaW5nIGxpa2UgdGhpczpcbi8vXG4vLyAgICAgSWRsZSDihpIgVXBkYXRpbmcg4oeGIElkbGUgKHVuY2hlY2tlZCkg4oaSIE1lYXN1cmluZyDihpIgSWRsZVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSAgICAgIOKGk1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVwZGF0aW5nIChtZWFzdXJlKVxuLy9cbi8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gJ0lkbGUnIGFuZCAnSWRsZSAodW5jaGVja2VkKScgbGllcyBpblxuLy8gd2hldGhlciBhIGxheW91dCBjaGVjayBoYXMgYmVlbiBzY2hlZHVsZWQuIEEgcmVndWxhciB1cGRhdGUgdGhyb3VnaFxuLy8gdGhlIGB1cGRhdGVgIG1ldGhvZCB1cGRhdGVzIHRoZSBET00gaW4gYSB3cml0ZS1vbmx5IGZhc2hpb24sIGFuZFxuLy8gcmVsaWVzIG9uIGEgY2hlY2sgKHNjaGVkdWxlZCB3aXRoIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgKSB0byBtYWtlXG4vLyBzdXJlIGV2ZXJ5dGhpbmcgaXMgd2hlcmUgaXQgc2hvdWxkIGJlIGFuZCB0aGUgdmlld3BvcnQgY292ZXJzIHRoZVxuLy8gdmlzaWJsZSBjb2RlLiBUaGF0IGNoZWNrIGNvbnRpbnVlcyB0byBtZWFzdXJlIGFuZCB0aGVuIG9wdGlvbmFsbHlcbi8vIHVwZGF0ZSB1bnRpbCBpdCByZWFjaGVzIGEgY29oZXJlbnQgc3RhdGUuXG4vKipcbkFuIGVkaXRvciB2aWV3IHJlcHJlc2VudHMgdGhlIGVkaXRvcidzIHVzZXIgaW50ZXJmYWNlLiBJdCBob2xkc1xudGhlIGVkaXRhYmxlIERPTSBzdXJmYWNlLCBhbmQgcG9zc2libHkgb3RoZXIgZWxlbWVudHMgc3VjaCBhcyB0aGVcbmxpbmUgbnVtYmVyIGd1dHRlci4gSXQgaGFuZGxlcyBldmVudHMgYW5kIGRpc3BhdGNoZXMgc3RhdGVcbnRyYW5zYWN0aW9ucyBmb3IgZWRpdGluZyBhY3Rpb25zLlxuKi9cbmNsYXNzIEVkaXRvclZpZXcge1xuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnN0YXRlOyB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBkaXNwbGF5IGxhcmdlIGRvY3VtZW50cyB3aXRob3V0IGNvbnN1bWluZyB0b28gbXVjaFxuICAgIG1lbW9yeSBvciBvdmVybG9hZGluZyB0aGUgYnJvd3NlciwgQ29kZU1pcnJvciBvbmx5IGRyYXdzIHRoZVxuICAgIGNvZGUgdGhhdCBpcyB2aXNpYmxlIChwbHVzIGEgbWFyZ2luIGFyb3VuZCBpdCkgdG8gdGhlIERPTS4gVGhpc1xuICAgIHByb3BlcnR5IHRlbGxzIHlvdSB0aGUgZXh0ZW50IG9mIHRoZSBjdXJyZW50IGRyYXduIHZpZXdwb3J0LCBpblxuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0OyB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBhcmUsIGZvciBleGFtcGxlLCBsYXJnZSBjb2xsYXBzZWQgcmFuZ2VzIGluIHRoZVxuICAgIHZpZXdwb3J0LCBpdHMgc2l6ZSBjYW4gYmUgYSBsb3QgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCB2aXNpYmxlXG4gICAgY29udGVudC4gVGh1cywgaWYgeW91IGFyZSBkb2luZyBzb21ldGhpbmcgbGlrZSBzdHlsaW5nIHRoZVxuICAgIGNvbnRlbnQgaW4gdGhlIHZpZXdwb3J0LCBpdCBpcyBwcmVmZXJhYmxlIHRvIG9ubHkgZG8gc28gZm9yXG4gICAgdGhlc2UgcmFuZ2VzLCB3aGljaCBhcmUgdGhlIHN1YnNldCBvZiB0aGUgdmlld3BvcnQgdGhhdCBpc1xuICAgIGFjdHVhbGx5IGRyYXduLlxuICAgICovXG4gICAgZ2V0IHZpc2libGVSYW5nZXMoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aXNpYmxlUmFuZ2VzOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBmYWxzZSB3aGVuIHRoZSBlZGl0b3IgaXMgZW50aXJlbHkgc2Nyb2xsZWQgb3V0IG9mIHZpZXdcbiAgICBvciBvdGhlcndpc2UgaGlkZGVuLlxuICAgICovXG4gICAgZ2V0IGluVmlldygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmluVmlldzsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBjb21wb3NpbmcgdGV4dCB2aWFcbiAgICBbSU1FXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnB1dF9tZXRob2QpLCBhbmQgYXQgbGVhc3RcbiAgICBvbmUgY2hhbmdlIGhhcyBiZWVuIG1hZGUgaW4gdGhlIGN1cnJlbnQgY29tcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+IDA7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpcyBjdXJyZW50bHkgaW4gY29tcG9zaW5nIHN0YXRlLiBOb3RlXG4gICAgdGhhdCBvbiBzb21lIHBsYXRmb3JtcywgbGlrZSBBbmRyb2lkLCB0aGlzIHdpbGwgYmUgdGhlIGNhc2UgYVxuICAgIGxvdCwgc2luY2UganVzdCBwdXR0aW5nIHRoZSBjdXJzb3Igb24gYSB3b3JkIHN0YXJ0cyBhXG4gICAgY29tcG9zaXRpb24gdGhlcmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaXRpb25TdGFydGVkKCkgeyByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGRvY3VtZW50IG9yIHNoYWRvdyByb290IHRoYXQgdGhlIHZpZXcgbGl2ZXMgaW4uXG4gICAgKi9cbiAgICBnZXQgcm9vdCgpIHsgcmV0dXJuIHRoaXMuX3Jvb3Q7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB3aW4oKSB7IHJldHVybiB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdzsgfVxuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5ldyB2aWV3LiBZb3UnbGwgd2FudCB0byBlaXRoZXIgcHJvdmlkZSBhIGBwYXJlbnRgXG4gICAgb3B0aW9uLCBvciBwdXQgYHZpZXcuZG9tYCBpbnRvIHlvdXIgZG9jdW1lbnQgYWZ0ZXIgY3JlYXRpbmcgYVxuICAgIHZpZXcsIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHNlZSB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luTWFwID0gbmV3IE1hcDtcbiAgICAgICAgdGhpcy5lZGl0b3JBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRlbnRBdHRycyA9IHt9O1xuICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzID0gW107XG4gICAgICAgIHRoaXMuY29udGVudERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00udGFiSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uY2xhc3NOYW1lID0gXCJjbS1zY3JvbGxlclwiO1xuICAgICAgICB0aGlzLnNjcm9sbERPTS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5jbGFzc05hbWUgPSBcImNtLWFubm91bmNlZFwiO1xuICAgICAgICB0aGlzLmFubm91bmNlRE9NLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmFubm91bmNlRE9NKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxET00pO1xuICAgICAgICBpZiAoY29uZmlnLnBhcmVudClcbiAgICAgICAgICAgIGNvbmZpZy5wYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICBsZXQgeyBkaXNwYXRjaCB9ID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb25zID0gY29uZmlnLmRpc3BhdGNoVHJhbnNhY3Rpb25zIHx8XG4gICAgICAgICAgICAoZGlzcGF0Y2ggJiYgKCh0cnMpID0+IHRycy5mb3JFYWNoKHRyID0+IGRpc3BhdGNoKHRyLCB0aGlzKSkpKSB8fFxuICAgICAgICAgICAgKCh0cnMpID0+IHRoaXMudXBkYXRlKHRycykpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9yb290ID0gKGNvbmZpZy5yb290IHx8IGdldFJvb3QoY29uZmlnLnBhcmVudCkgfHwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUoY29uZmlnLnN0YXRlIHx8IEVkaXRvclN0YXRlLmNyZWF0ZShjb25maWcpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5zY3JvbGxUbyAmJiBjb25maWcuc2Nyb2xsVG8uaXMoc2Nyb2xsSW50b1ZpZXcpKVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gY29uZmlnLnNjcm9sbFRvLnZhbHVlLmNsaXAodGhpcy52aWV3U3RhdGUuc3RhdGUpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pLm1hcChzcGVjID0+IG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW4udXBkYXRlKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IERPTU9ic2VydmVyKHRoaXMpO1xuICAgICAgICB0aGlzLmlucHV0U3RhdGUgPSBuZXcgSW5wdXRTdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgIH1cbiAgICBkaXNwYXRjaCguLi5pbnB1dCkge1xuICAgICAgICBsZXQgdHJzID0gaW5wdXQubGVuZ3RoID09IDEgJiYgaW5wdXRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiA/IGlucHV0XG4gICAgICAgICAgICA6IGlucHV0Lmxlbmd0aCA9PSAxICYmIEFycmF5LmlzQXJyYXkoaW5wdXRbMF0pID8gaW5wdXRbMF1cbiAgICAgICAgICAgICAgICA6IFt0aGlzLnN0YXRlLnVwZGF0ZSguLi5pbnB1dCldO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb25zKHRycywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIHRyYW5zYWN0aW9ucy4gVGhpcyB3aWxsXG4gICAgdXBkYXRlIHRoZSB2aXNpYmxlIGRvY3VtZW50IGFuZCBzZWxlY3Rpb24gdG8gbWF0Y2ggdGhlIHN0YXRlXG4gICAgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9ucywgYW5kIG5vdGlmeSB2aWV3IHBsdWdpbnMgb2YgdGhlXG4gICAgY2hhbmdlLiBZb3Ugc2hvdWxkIHVzdWFsbHkgY2FsbFxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZCwgd2hpY2ggdXNlcyB0aGlzXG4gICAgYXMgYSBwcmltaXRpdmUuXG4gICAgKi9cbiAgICB1cGRhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcudXBkYXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGxldCByZWRyYXduID0gZmFsc2UsIGF0dHJzQ2hhbmdlZCA9IGZhbHNlLCB1cGRhdGU7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRyLnN0YXJ0U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gdXBkYXRlIHN0YXRlIHdpdGggYSB0cmFuc2FjdGlvbiB0aGF0IGRvZXNuJ3Qgc3RhcnQgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXCIpO1xuICAgICAgICAgICAgc3RhdGUgPSB0ci5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvY3VzID0gdGhpcy5oYXNGb2N1cywgZm9jdXNGbGFnID0gMCwgZGlzcGF0Y2hGb2N1cyA9IG51bGw7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5hbm5vdGF0aW9uKGlzRm9jdXNDaGFuZ2UpKSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgLy8gSWYgYSBmb2N1cy1jaGFuZ2UgdHJhbnNhY3Rpb24gaXMgYmVpbmcgZGlzcGF0Y2hlZCwgc2V0IHRoaXMgdXBkYXRlIGZsYWcuXG4gICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9jdXMgIT0gdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLm5vdGlmaWVkRm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBzZXBhcmF0ZSBmb2N1cyB0cmFuc2FjdGlvbiBpZiBuZWNlc3NhcnksIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gYWRkIGEgZmxhZyB0byB0aGlzIHVwZGF0ZVxuICAgICAgICAgICAgZGlzcGF0Y2hGb2N1cyA9IGZvY3VzQ2hhbmdlVHJhbnNhY3Rpb24oc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgICAgIGlmICghZGlzcGF0Y2hGb2N1cylcbiAgICAgICAgICAgICAgICBmb2N1c0ZsYWcgPSAxIC8qIFVwZGF0ZUZsYWcuRm9jdXMgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcGVuZGluZyBET00gY2hhbmdlLCBlYWdlcmx5IHJlYWQgaXQgYW5kIHRyeSB0b1xuICAgICAgICAvLyBhcHBseSBpdCBhZnRlciB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb25zLlxuICAgICAgICBsZXQgcGVuZGluZ0tleSA9IHRoaXMub2JzZXJ2ZXIuZGVsYXllZEFuZHJvaWRLZXksIGRvbUNoYW5nZSA9IG51bGw7XG4gICAgICAgIGlmIChwZW5kaW5nS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKTtcbiAgICAgICAgICAgIGRvbUNoYW5nZSA9IHRoaXMub2JzZXJ2ZXIucmVhZENoYW5nZSgpO1xuICAgICAgICAgICAgLy8gT25seSB0cnkgdG8gYXBwbHkgRE9NIGNoYW5nZXMgaWYgdGhlIHRyYW5zYWN0aW9ucyBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgZG9jIG9yIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIGlmIChkb21DaGFuZ2UgJiYgIXRoaXMuc3RhdGUuZG9jLmVxKHN0YXRlLmRvYykgfHwgIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgZG9tQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBwaHJhc2VzIGNoYW5nZSwgcmVkcmF3IHRoZSBlZGl0b3JcbiAgICAgICAgaWYgKHN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpICE9IHRoaXMuc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHVwZGF0ZSA9IFZpZXdVcGRhdGUuY3JlYXRlKHRoaXMsIHN0YXRlLCB0cmFuc2FjdGlvbnMpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gZm9jdXNGbGFnO1xuICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0ID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRlU3RhdGUuVXBkYXRpbmcgKi87XG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0ci5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBtYWluIH0gPSB0ci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IG5ldyBTY3JvbGxUYXJnZXQobWFpbi5lbXB0eSA/IG1haW4gOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG1haW4uaGVhZCwgbWFpbi5oZWFkID4gbWFpbi5hbmNob3IgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5pcyhzY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBlLnZhbHVlLmNsaXAodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS51cGRhdGUodXBkYXRlLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBDYWNoZWRPcmRlci51cGRhdGUodGhpcy5iaWRpQ2FjaGUsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmZhY2V0KHN0eWxlTW9kdWxlKSAhPSB0aGlzLnN0eWxlTW9kdWxlcylcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgICAgICBhdHRyc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dBbm5vdW5jZW1lbnRzKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHJlZHJhd24sIHRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmlzVXNlckV2ZW50KFwic2VsZWN0LnBvaW50ZXJcIikpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHRoZW1lKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQodGhlbWUpKVxuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHJlZHJhd24gfHwgYXR0cnNDaGFuZ2VkIHx8IHNjcm9sbFRhcmdldCB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0RW5mb3JjZUN1cnNvckFzc29jIHx8IHRoaXMudmlld1N0YXRlLm11c3RNZWFzdXJlQ29udGVudClcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlLCBcInVwZGF0ZSBsaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwYXRjaEZvY3VzIHx8IGRvbUNoYW5nZSlcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaEZvY3VzICYmIHRoaXMuc3RhdGUgPT0gZGlzcGF0Y2hGb2N1cy5zdGFydFN0YXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKGRpc3BhdGNoRm9jdXMpO1xuICAgICAgICAgICAgICAgIGlmIChkb21DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhcHBseURPTUNoYW5nZSh0aGlzLCBkb21DaGFuZ2UpICYmIHBlbmRpbmdLZXkuZm9yY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh0aGlzLmNvbnRlbnRET00sIHBlbmRpbmdLZXkua2V5LCBwZW5kaW5nS2V5LmtleUNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNldCB0aGUgdmlldyB0byB0aGUgZ2l2ZW4gc3RhdGUuIChUaGlzIHdpbGwgY2F1c2UgdGhlIGVudGlyZVxuICAgIGRvY3VtZW50IHRvIGJlIHJlZHJhd24gYW5kIGFsbCB2aWV3IHBsdWdpbnMgdG8gYmUgcmVpbml0aWFsaXplZCxcbiAgICBzbyB5b3Ugc2hvdWxkIHByb2JhYmx5IG9ubHkgdXNlIGl0IHdoZW4gdGhlIG5ldyBzdGF0ZSBpc24ndFxuICAgIGRlcml2ZWQgZnJvbSB0aGUgb2xkIHN0YXRlLiBPdGhlcndpc2UsIHVzZVxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZC4pXG4gICAgKi9cbiAgICBzZXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSAhPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxscyB0byBFZGl0b3JWaWV3LnNldFN0YXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgbGV0IGhhZEZvY3VzID0gdGhpcy5oYXNGb2N1cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3U3RhdGUuZmFjZXQodmlld1BsdWdpbikubWFwKHNwZWMgPT4gbmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHBsdWdpbi51cGRhdGUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gbmV3IERvY1ZpZXcodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYWRGb2N1cylcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgIH1cbiAgICB1cGRhdGVQbHVnaW5zKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldlNwZWNzID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQodmlld1BsdWdpbiksIHNwZWNzID0gdXBkYXRlLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pO1xuICAgICAgICBpZiAocHJldlNwZWNzICE9IHNwZWNzKSB7XG4gICAgICAgICAgICBsZXQgbmV3UGx1Z2lucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHByZXZTcGVjcy5pbmRleE9mKHNwZWMpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGx1Z2lucy5wdXNoKG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5wbHVnaW5zW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLm11c3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5tdXN0VXBkYXRlICE9IHVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdQbHVnaW5zO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHAubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tpXS51cGRhdGUodGhpcyk7XG4gICAgICAgIGlmIChwcmV2U3BlY3MgIT0gc3BlY3MpXG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtZWFzdXJlKGZsdXNoID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPiAtMSlcbiAgICAgICAgICAgIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCk7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyLmRlbGF5ZWRBbmRyb2lkS2V5KSB7XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAwOyAvLyBQcmV2ZW50IHJlcXVlc3RNZWFzdXJlIGNhbGxzIGZyb20gc2NoZWR1bGluZyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBpZiAoZmx1c2gpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICBsZXQgc0RPTSA9IHRoaXMuc2Nyb2xsRE9NLCBzY3JvbGxUb3AgPSBzRE9NLnNjcm9sbFRvcCAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsZXQgeyBzY3JvbGxBbmNob3JQb3MsIHNjcm9sbEFuY2hvckhlaWdodCB9ID0gdGhpcy52aWV3U3RhdGU7XG4gICAgICAgIGlmIChNYXRoLmFicyhzY3JvbGxUb3AgLSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUb3ApID4gMSlcbiAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbEFuY2hvckhlaWdodCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2Nyb2xsZWRUb0JvdHRvbShzRE9NKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9yUG9zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvclBvcyA9IGJsb2NrLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSBibG9jay50b3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDEgLyogVXBkYXRlU3RhdGUuTWVhc3VyaW5nICovO1xuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy52aWV3U3RhdGUubWVhc3VyZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgIXRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCAmJiB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJNZWFzdXJlIGxvb3AgcmVzdGFydGVkIG1vcmUgdGhhbiA1IHRpbWVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJWaWV3cG9ydCBmYWlsZWQgdG8gc3RhYmlsaXplXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmluZyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgcnVuIG1lYXN1cmUgcmVxdWVzdHMgaW4gdGhpcyBjeWNsZSB3aGVuIHRoZSB2aWV3cG9ydCBkaWRuJ3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKCEoY2hhbmdlZCAmIDQgLyogVXBkYXRlRmxhZy5WaWV3cG9ydCAqLykpXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLm1lYXN1cmVSZXF1ZXN0cywgbWVhc3VyaW5nXSA9IFttZWFzdXJpbmcsIHRoaXMubWVhc3VyZVJlcXVlc3RzXTtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZWQgPSBtZWFzdXJpbmcubWFwKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ucmVhZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhZE1lYXN1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgdGhpcy5zdGF0ZSwgW10pLCByZWRyYXduID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGx1Z2lucyh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3biA9IHRoaXMuZG9jVmlldy51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWFzdXJpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZFtpXSAhPSBCYWRNZWFzdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWVhc3VyaW5nW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLndyaXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLndyaXRlKG1lYXN1cmVkW2ldLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhd24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUudmlld3BvcnRDaGFuZ2VkICYmIHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcuc2Nyb2xsSW50b1ZpZXcodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0FuY2hvckhlaWdodCA9IHNjcm9sbEFuY2hvclBvcyA8IDAgPyB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRNYXAuaGVpZ2h0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQoc2Nyb2xsQW5jaG9yUG9zKS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmYgPSBuZXdBbmNob3JIZWlnaHQgLSBzY3JvbGxBbmNob3JIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAxIHx8IGRpZmYgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUb3AgPSBzY3JvbGxUb3AgKyBkaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzRE9NLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCAvIHRoaXMuc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCAmJiAhdXBkYXRlZC5lbXB0eSlcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGUuZmFjZXQodXBkYXRlTGlzdGVuZXIpKVxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHVwZGF0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIENTUyBjbGFzc2VzIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZGl0b3IgdGhlbWVzLlxuICAgICovXG4gICAgZ2V0IHRoZW1lQ2xhc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VUaGVtZUlEICsgXCIgXCIgK1xuICAgICAgICAgICAgKHRoaXMuc3RhdGUuZmFjZXQoZGFya1RoZW1lKSA/IGJhc2VEYXJrSUQgOiBiYXNlTGlnaHRJRCkgKyBcIiBcIiArXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmZhY2V0KHRoZW1lKTtcbiAgICB9XG4gICAgdXBkYXRlQXR0cnMoKSB7XG4gICAgICAgIGxldCBlZGl0b3JBdHRycyA9IGF0dHJzRnJvbUZhY2V0KHRoaXMsIGVkaXRvckF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWVkaXRvclwiICsgKHRoaXMuaGFzRm9jdXMgPyBcIiBjbS1mb2N1c2VkIFwiIDogXCIgXCIpICsgdGhpcy50aGVtZUNsYXNzZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjb250ZW50QXR0cnMgPSB7XG4gICAgICAgICAgICBzcGVsbGNoZWNrOiBcImZhbHNlXCIsXG4gICAgICAgICAgICBhdXRvY29ycmVjdDogXCJvZmZcIixcbiAgICAgICAgICAgIGF1dG9jYXBpdGFsaXplOiBcIm9mZlwiLFxuICAgICAgICAgICAgdHJhbnNsYXRlOiBcIm5vXCIsXG4gICAgICAgICAgICBjb250ZW50ZWRpdGFibGU6ICF0aGlzLnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tY29udGVudFwiLFxuICAgICAgICAgICAgc3R5bGU6IGAke2Jyb3dzZXIudGFiU2l6ZX06ICR7dGhpcy5zdGF0ZS50YWJTaXplfWAsXG4gICAgICAgICAgICByb2xlOiBcInRleHRib3hcIixcbiAgICAgICAgICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogXCJ0cnVlXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICBjb250ZW50QXR0cnNbXCJhcmlhLXJlYWRvbmx5XCJdID0gXCJ0cnVlXCI7XG4gICAgICAgIGF0dHJzRnJvbUZhY2V0KHRoaXMsIGNvbnRlbnRBdHRyaWJ1dGVzLCBjb250ZW50QXR0cnMpO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkQ29udGVudCA9IHVwZGF0ZUF0dHJzKHRoaXMuY29udGVudERPTSwgdGhpcy5jb250ZW50QXR0cnMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlZEVkaXRvciA9IHVwZGF0ZUF0dHJzKHRoaXMuZG9tLCB0aGlzLmVkaXRvckF0dHJzLCBlZGl0b3JBdHRycyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZENvbnRlbnQgfHwgY2hhbmdlZEVkaXRvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSBlZGl0b3JBdHRycztcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSBjb250ZW50QXR0cnM7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiAgICBzaG93QW5ub3VuY2VtZW50cyh0cnMpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJzKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhFZGl0b3JWaWV3LmFubm91bmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm91bmNlRE9NLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpdiA9IHRoaXMuYW5ub3VuY2VET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi50ZXh0Q29udGVudCA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgfVxuICAgIG1vdW50U3R5bGVzKCkge1xuICAgICAgICB0aGlzLnN0eWxlTW9kdWxlcyA9IHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpO1xuICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuY3NwTm9uY2UpO1xuICAgICAgICBTdHlsZU1vZHVsZS5tb3VudCh0aGlzLnJvb3QsIHRoaXMuc3R5bGVNb2R1bGVzLmNvbmNhdChiYXNlVGhlbWUkMSkucmV2ZXJzZSgpLCBub25jZSA/IHsgbm9uY2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWRpbmcgdGhlIGVkaXRvciBsYXlvdXQgaXNuJ3QgYWxsb3dlZCBkdXJpbmcgYW4gdXBkYXRlXCIpO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8gJiYgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmUoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBTY2hlZHVsZSBhIGxheW91dCBtZWFzdXJlbWVudCwgb3B0aW9uYWxseSBwcm92aWRpbmcgY2FsbGJhY2tzIHRvXG4gICAgZG8gY3VzdG9tIERPTSBtZWFzdXJpbmcgZm9sbG93ZWQgYnkgYSBET00gd3JpdGUgcGhhc2UuIFVzaW5nXG4gICAgdGhpcyBpcyBwcmVmZXJhYmxlIHJlYWRpbmcgRE9NIGxheW91dCBkaXJlY3RseSBmcm9tLCBmb3JcbiAgICBleGFtcGxlLCBhbiBldmVudCBoYW5kbGVyLCBiZWNhdXNlIGl0J2xsIG1ha2Ugc3VyZSBtZWFzdXJpbmcgYW5kXG4gICAgZHJhd2luZyBkb25lIGJ5IG90aGVyIGNvbXBvbmVudHMgaXMgc3luY2hyb25pemVkLCBhdm9pZGluZ1xuICAgIHVubmVjZXNzYXJ5IERPTSBsYXlvdXQgY29tcHV0YXRpb25zLlxuICAgICovXG4gICAgcmVxdWVzdE1lYXN1cmUocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkIDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IHRoaXMud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLm1lYXN1cmUoKSk7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZWFzdXJlUmVxdWVzdHMuaW5kZXhPZihyZXF1ZXN0KSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldLmtleSA9PT0gcmVxdWVzdC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmljIHBsdWdpbiwgaWYgcHJlc2VudC4gTm90ZSB0aGF0XG4gICAgcGx1Z2lucyB0aGF0IGNyYXNoIGNhbiBiZSBkcm9wcGVkIGZyb20gYSB2aWV3LCBzbyBldmVuIHdoZW4geW91XG4gICAga25vdyB5b3UgcmVnaXN0ZXJlZCBhIGdpdmVuIHBsdWdpbiwgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2hlY2tcbiAgICB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgcGx1Z2luKHBsdWdpbikge1xuICAgICAgICBsZXQga25vd24gPSB0aGlzLnBsdWdpbk1hcC5nZXQocGx1Z2luKTtcbiAgICAgICAgaWYgKGtub3duID09PSB1bmRlZmluZWQgfHwga25vd24gJiYga25vd24uc3BlYyAhPSBwbHVnaW4pXG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5zZXQocGx1Z2luLCBrbm93biA9IHRoaXMucGx1Z2lucy5maW5kKHAgPT4gcC5zcGVjID09IHBsdWdpbikgfHwgbnVsbCk7XG4gICAgICAgIHJldHVybiBrbm93biAmJiBrbm93bi51cGRhdGUodGhpcykudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGRvY3VtZW50LCBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuIFRoaXNcbiAgICBtYXkgYmUgbmVnYXRpdmUgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGVkIGRvd24uIFBvaW50c1xuICAgIGRpcmVjdGx5IHRvIHRoZSB0b3Agb2YgdGhlIGZpcnN0IGxpbmUsIG5vdCBhYm92ZSB0aGUgcGFkZGluZy5cbiAgICAqL1xuICAgIGdldCBkb2N1bWVudFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBvcnRzIHRoZSBwYWRkaW5nIGFib3ZlIGFuZCBiZWxvdyB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3AsIGJvdHRvbTogdGhpcy52aWV3U3RhdGUucGFkZGluZ0JvdHRvbSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBJZiB0aGUgZWRpdG9yIGlzIHRyYW5zZm9ybWVkIHdpdGggQ1NTLCB0aGlzIHByb3ZpZGVzIHRoZSBzY2FsZVxuICAgIGFsb25nIHRoZSBYIGF4aXMuIE90aGVyd2lzZSwgaXQgd2lsbCBqdXN0IGJlIDEuIE5vdGUgdGhhdFxuICAgIHRyYW5zZm9ybXMgb3RoZXIgdGhhbiB0cmFuc2xhdGlvbiBhbmQgc2NhbGluZyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAqL1xuICAgIGdldCBzY2FsZVgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVg7IH1cbiAgICAvKipcbiAgICBQcm92aWRlIHRoZSBDU1MgdHJhbnNmb3JtZWQgc2NhbGUgYWxvbmcgdGhlIFkgYXhpcy5cbiAgICAqL1xuICAgIGdldCBzY2FsZVkoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVk7IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGxpbmUgb3IgYmxvY2sgd2lkZ2V0IGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbFxuICAgIHBvc2l0aW9uICh3aGljaCBpcyBpbnRlcnByZXRlZCBhcyByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApKS5cbiAgICAqL1xuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmVsZW1lbnRBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIGJsb2NrIChzZWVcbiAgICBbYGxpbmVCbG9ja0F0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGF0IHRoZSBnaXZlblxuICAgIGhlaWdodCwgYWdhaW4gaW50ZXJwcmV0ZWQgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKS5cbiAgICAqL1xuICAgIGxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBleHRlbnQgYW5kIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGFsbCBbbGluZVxuICAgIGJsb2Nrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGluIHRoZSB2aWV3cG9ydC4gUG9zaXRpb25zXG4gICAgYXJlIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCk7XG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRMaW5lQmxvY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnRMaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayBhcm91bmQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLiBBIGxpbmVcbiAgICBibG9jayBpcyBhIHJhbmdlIGRlbGltaXRlZCBvbiBib3RoIHNpZGVzIGJ5IGVpdGhlciBhXG4gICAgbm9uLVtoaWRkZW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXnJlcGxhY2UpIGxpbmUgYnJlYWtzLCBvciB0aGVcbiAgICBzdGFydC9lbmQgb2YgdGhlIGRvY3VtZW50LiBJdCB3aWxsIHVzdWFsbHkganVzdCBob2xkIGEgbGluZSBvZlxuICAgIHRleHQsIGJ1dCBtYXkgYmUgYnJva2VuIGludG8gbXVsdGlwbGUgdGV4dGJsb2NrcyBieSBibG9ja1xuICAgIHdpZGdldHMuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IncyB0b3RhbCBjb250ZW50IGhlaWdodC5cbiAgICAqL1xuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuY29udGVudEhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBieSBbZ3JhcGhlbWVcbiAgICBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspLiBgZm9yd2FyZGAgZGV0ZXJtaW5lcyB3aGV0aGVyXG4gICAgdGhlIG1vdGlvbiBpcyBhd2F5IGZyb20gdGhlIGxpbmUgc3RhcnQsIG9yIHRvd2FyZHMgaXQuIEluXG4gICAgYmlkaXJlY3Rpb25hbCB0ZXh0LCB0aGUgbGluZSBpcyB0cmF2ZXJzZWQgaW4gdmlzdWFsIG9yZGVyLCB1c2luZ1xuICAgIHRoZSBlZGl0b3IncyBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuICAgIFdoZW4gdGhlIHN0YXJ0IHBvc2l0aW9uIHdhcyB0aGUgbGFzdCBvbmUgb24gdGhlIGxpbmUsIHRoZVxuICAgIHJldHVybmVkIHBvc2l0aW9uIHdpbGwgYmUgYWNyb3NzIHRoZSBsaW5lIGJyZWFrLiBJZiB0aGVyZSBpcyBub1xuICAgIGZ1cnRoZXIgbGluZSwgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIG1vdmVzIG92ZXIgYSBzaW5nbGUgY2x1c3Rlci4gVGhlXG4gICAgb3B0aW9uYWwgYGJ5YCBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBtb3ZlIGFjcm9zcyBtb3JlLiBJdCB3aWxsXG4gICAgYmUgY2FsbGVkIHdpdGggdGhlIGZpcnN0IGNsdXN0ZXIgYXMgYXJndW1lbnQsIGFuZCBzaG91bGQgcmV0dXJuXG4gICAgYSBwcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzLCBmb3IgZWFjaCBzdWJzZXF1ZW50IGNsdXN0ZXIsXG4gICAgd2hldGhlciBpdCBzaG91bGQgYWxzbyBiZSBtb3ZlZCBvdmVyLlxuICAgICovXG4gICAgbW92ZUJ5Q2hhcihzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgYnkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBhY3Jvc3MgdGhlIG5leHQgZ3JvdXAgb2YgZWl0aGVyXG4gICAgW2xldHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBvciBub24tbGV0dGVyXG4gICAgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIG1vdmVCeUdyb3VwKHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGluaXRpYWwgPT4gYnlHcm91cCh0aGlzLCBzdGFydC5oZWFkLCBpbml0aWFsKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnNvciBwb3NpdGlvbiB2aXN1YWxseSBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbGluZS5cbiAgICBOb3RlIHRoYXQgdGhpcyBtYXkgZGlmZmVyIGZyb20gdGhlIF9sb2dpY2FsXyBwb3NpdGlvbiBhdCBpdHNcbiAgICBzdGFydCBvciBlbmQgKHdoaWNoIGlzIHNpbXBseSBhdCBgbGluZS5mcm9tYC9gbGluZS50b2ApIGlmIHRleHRcbiAgICBhdCB0aGUgc3RhcnQgb3IgZW5kIGdvZXMgYWdhaW5zdCB0aGUgbGluZSdzIGJhc2UgdGV4dCBkaXJlY3Rpb24uXG4gICAgKi9cbiAgICB2aXN1YWxMaW5lU2lkZShsaW5lLCBlbmQpIHtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5iaWRpU3BhbnMobGluZSksIGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSk7XG4gICAgICAgIGxldCBzcGFuID0gb3JkZXJbZW5kID8gb3JkZXIubGVuZ3RoIC0gMSA6IDBdO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzcGFuLnNpZGUoZW5kLCBkaXIpICsgbGluZS5mcm9tLCBzcGFuLmZvcndhcmQoIWVuZCwgZGlyKSA/IDEgOiAtMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbGluZSBib3VuZGFyeSBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLiBJZlxuICAgIGBpbmNsdWRlV3JhcGAgaXMgdHJ1ZSwgbGluZSB3cmFwcGluZyBpcyBvbiwgYW5kIHRoZXJlIGlzIGFcbiAgICBmdXJ0aGVyIHdyYXAgcG9pbnQgb24gdGhlIGN1cnJlbnQgbGluZSwgdGhlIHdyYXAgcG9pbnQgd2lsbCBiZVxuICAgIHJldHVybmVkLiBPdGhlcndpc2UgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc3RhcnQgb3IgZW5kXG4gICAgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBtb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbW92ZVRvTGluZUJvdW5kYXJ5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbmNsdWRlV3JhcCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gdmVydGljYWxseS4gV2hlbiBgZGlzdGFuY2VgIGlzbid0IGdpdmVuLFxuICAgIGl0IGRlZmF1bHRzIHRvIG1vdmluZyB0byB0aGUgbmV4dCBsaW5lIChpbmNsdWRpbmcgd3JhcHBlZFxuICAgIGxpbmVzKS4gT3RoZXJ3aXNlLCBgZGlzdGFuY2VgIHNob3VsZCBwcm92aWRlIGEgcG9zaXRpdmUgZGlzdGFuY2VcbiAgICBpbiBwaXhlbHMuXG4gICAgXG4gICAgV2hlbiBgc3RhcnRgIGhhcyBhXG4gICAgW2Bnb2FsQ29sdW1uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5nb2FsQ29sdW1uKSwgdGhlIHZlcnRpY2FsXG4gICAgbW90aW9uIHdpbGwgdXNlIHRoYXQgYXMgYSB0YXJnZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLFxuICAgIHRoZSBjdXJzb3IncyBvd24gaG9yaXpvbnRhbCBwb3NpdGlvbiBpcyB1c2VkLiBUaGUgcmV0dXJuZWRcbiAgICBjdXJzb3Igd2lsbCBoYXZlIGl0cyBnb2FsIGNvbHVtbiBzZXQgdG8gd2hpY2hldmVyIGNvbHVtbiB3YXNcbiAgICB1c2VkLlxuICAgICovXG4gICAgbW92ZVZlcnRpY2FsbHkoc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVWZXJ0aWNhbGx5KHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBkaXN0YW5jZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcGFyZW50IG5vZGUgYW5kIG9mZnNldCAoY2hpbGQgb2Zmc2V0IGlmIGBub2RlYCBpc1xuICAgIGFuIGVsZW1lbnQsIGNoYXJhY3RlciBvZmZzZXQgd2hlbiBpdCBpcyBhIHRleHQgbm9kZSkgYXQgdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgXG4gICAgTm90ZSB0aGF0IGZvciBwb3NpdGlvbnMgdGhhdCBhcmVuJ3QgY3VycmVudGx5IGluXG4gICAgYHZpc2libGVSYW5nZXNgLCB0aGUgcmVzdWx0aW5nIERPTSBwb3NpdGlvbiBpc24ndCBuZWNlc3NhcmlseVxuICAgIG1lYW5pbmdmdWwgKGl0IG1heSBqdXN0IHBvaW50IGJlZm9yZSBvciBhZnRlciBhIHBsYWNlaG9sZGVyXG4gICAgZWxlbWVudCkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21BdFBvcyhwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gRE9NIG5vZGUuIENhbiBiZSB1c2VmdWxcbiAgICBmb3IgYXNzb2NpYXRpbmcgcG9zaXRpb25zIHdpdGggRE9NIGV2ZW50cy4gV2lsbCByYWlzZSBhbiBlcnJvclxuICAgIHdoZW4gYG5vZGVgIGlzbid0IHBhcnQgb2YgdGhlIGVkaXRvciBjb250ZW50LlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcG9zQXRDb29yZHMoY29vcmRzLCBwcmVjaXNlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzLCBwcmVjaXNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzY3JlZW4gY29vcmRpbmF0ZXMgYXQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLlxuICAgIGBzaWRlYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBiYXNlZCBvbiB0aGVcbiAgICBlbGVtZW50IGJlZm9yZSAoLTEpIG9yIGFmdGVyICgxKSB0aGUgcG9zaXRpb24gKGlmIG5vIGVsZW1lbnQgaXNcbiAgICBhdmFpbGFibGUgb24gdGhlIGdpdmVuIHNpZGUsIHRoZSBtZXRob2Qgd2lsbCB0cmFuc3BhcmVudGx5IHVzZVxuICAgIGFub3RoZXIgc3RyYXRlZ3kgdG8gZ2V0IHJlYXNvbmFibGUgY29vcmRpbmF0ZXMpLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuZG9jVmlldy5jb29yZHNBdChwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoIXJlY3QgfHwgcmVjdC5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKSwgb3JkZXIgPSB0aGlzLmJpZGlTcGFucyhsaW5lKTtcbiAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltCaWRpU3Bhbi5maW5kKG9yZGVyLCBwb3MgLSBsaW5lLmZyb20sIC0xLCBzaWRlKV07XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdChyZWN0LCAoc3Bhbi5kaXIgPT0gRGlyZWN0aW9uLkxUUikgPT0gKHNpZGUgPiAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgcmVjdGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGNoYXJhY3Rlci4gSWYgYHBvc2AgZG9lcyBub3RcbiAgICBwb2ludCBpbiBmcm9udCBvZiBhIGNoYXJhY3RlciB0aGF0IGlzIGluIHRoZSB2aWV3cG9ydCBhbmRcbiAgICByZW5kZXJlZCAoaS5lLiBub3QgcmVwbGFjZWQsIG5vdCBhIGxpbmUgYnJlYWspLCB0aGlzIHdpbGwgcmV0dXJuXG4gICAgbnVsbC4gRm9yIHNwYWNlIGNoYXJhY3RlcnMgdGhhdCBhcmUgYSBsaW5lIHdyYXAgcG9pbnQsIHRoaXMgd2lsbFxuICAgIHJldHVybiB0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBsaW5lIGJyZWFrLlxuICAgICovXG4gICAgY29vcmRzRm9yQ2hhcihwb3MpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5jb29yZHNGb3JDaGFyKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHdpZHRoIG9mIGEgY2hhcmFjdGVyIGluIHRoZSBlZGl0b3IuIE1heSBub3RcbiAgICBhY2N1cmF0ZWx5IHJlZmxlY3QgdGhlIHdpZHRoIG9mIGFsbCBjaGFyYWN0ZXJzIChnaXZlbiB2YXJpYWJsZVxuICAgIHdpZHRoIGZvbnRzIG9yIHN0eWxpbmcgb2YgaW52aWRpZHVhbCByYW5nZXMpLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRDaGFyYWN0ZXJXaWR0aCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7IH1cbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCBoZWlnaHQgb2YgYSBsaW5lIGluIHRoZSBlZGl0b3IuIE1heSBub3QgYmUgYWNjdXJhdGVcbiAgICBmb3IgYWxsIGxpbmVzLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRMaW5lSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQ7IH1cbiAgICAvKipcbiAgICBUaGUgdGV4dCBkaXJlY3Rpb25cbiAgICAoW2BkaXJlY3Rpb25gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uKVxuICAgIENTUyBwcm9wZXJ0eSkgb2YgdGhlIGVkaXRvcidzIGNvbnRlbnQgZWxlbWVudC5cbiAgICAqL1xuICAgIGdldCB0ZXh0RGlyZWN0aW9uKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuZGVmYXVsdFRleHREaXJlY3Rpb247IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGRpcmVjdGlvbiBvZiB0aGUgYmxvY2sgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhc1xuICAgIGFzc2lnbmVkIGJ5IENTUy4gSWZcbiAgICBbYHBlckxpbmVUZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdecGVyTGluZVRleHREaXJlY3Rpb24pXG4gICAgaXNuJ3QgZW5hYmxlZCwgb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0LFxuICAgIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIGFzXG4gICAgW2B0ZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuIE5vdGUgdGhhdFxuICAgIHRoaXMgbWF5IHRyaWdnZXIgYSBET00gbGF5b3V0LlxuICAgICovXG4gICAgdGV4dERpcmVjdGlvbkF0KHBvcykge1xuICAgICAgICBsZXQgcGVyTGluZSA9IHRoaXMuc3RhdGUuZmFjZXQocGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIXBlckxpbmUgfHwgcG9zIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8IHBvcyA+IHRoaXMudmlld3BvcnQudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnRleHREaXJlY3Rpb25BdChwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoaXMgZWRpdG9yIFt3cmFwcyBsaW5lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZVdyYXBwaW5nKVxuICAgIChhcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgIFtgd2hpdGUtc3BhY2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1Mvd2hpdGUtc3BhY2UpXG4gICAgQ1NTIHByb3BlcnR5IG9mIGl0cyBjb250ZW50IGVsZW1lbnQpLlxuICAgICovXG4gICAgZ2V0IGxpbmVXcmFwcGluZygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBiaWRpcmVjdGlvbmFsIHRleHQgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiBsaW5lXG4gICAgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgY3VycmVudCBkb2N1bWVudCkgYXMgYW4gYXJyYXkgb2Ygc3BhblxuICAgIG9iamVjdHMuIFRoZSBvcmRlciBvZiB0aGVzZSBzcGFucyBtYXRjaGVzIHRoZSBbdGV4dFxuICAgIGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbinigJRpZiB0aGF0IGlzXG4gICAgbGVmdC10by1yaWdodCwgdGhlIGxlZnRtb3N0IHNwYW5zIGNvbWUgZmlyc3QsIG90aGVyd2lzZSB0aGVcbiAgICByaWdodG1vc3Qgc3BhbnMgY29tZSBmaXJzdC5cbiAgICAqL1xuICAgIGJpZGlTcGFucyhsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IE1heEJpZGlMaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgICAgIGxldCBkaXIgPSB0aGlzLnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pLCBpc29sYXRlcztcbiAgICAgICAgZm9yIChsZXQgZW50cnkgb2YgdGhpcy5iaWRpQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5mcm9tID09IGxpbmUuZnJvbSAmJiBlbnRyeS5kaXIgPT0gZGlyICYmXG4gICAgICAgICAgICAgICAgKGVudHJ5LmZyZXNoIHx8IGlzb2xhdGVzRXEoZW50cnkuaXNvbGF0ZXMsIGlzb2xhdGVzID0gZ2V0SXNvbGF0ZWRSYW5nZXModGhpcywgbGluZSkpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkub3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc29sYXRlcylcbiAgICAgICAgICAgIGlzb2xhdGVzID0gZ2V0SXNvbGF0ZWRSYW5nZXModGhpcywgbGluZSk7XG4gICAgICAgIGxldCBvcmRlciA9IGNvbXB1dGVPcmRlcihsaW5lLnRleHQsIGRpciwgaXNvbGF0ZXMpO1xuICAgICAgICB0aGlzLmJpZGlDYWNoZS5wdXNoKG5ldyBDYWNoZWRPcmRlcihsaW5lLmZyb20sIGxpbmUudG8sIGRpciwgaXNvbGF0ZXMsIHRydWUsIG9yZGVyKSk7XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZWRpdG9yIGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGdldCBoYXNGb2N1cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBTYWZhcmkgcmV0dXJuIGZhbHNlIGZvciBoYXNGb2N1cyB3aGVuIHRoZSBjb250ZXh0IG1lbnUgaXMgb3BlblxuICAgICAgICAvLyBvciBjbG9zaW5nLCB3aGljaCBsZWFkcyB1cyB0byBpZ25vcmUgc2VsZWN0aW9uIGNoYW5nZXMgZnJvbSB0aGVcbiAgICAgICAgLy8gY29udGV4dCBtZW51IGJlY2F1c2UgaXQgbG9va3MgbGlrZSB0aGUgZWRpdG9yIGlzbid0IGZvY3VzZWQuXG4gICAgICAgIC8vIFRoaXMga2x1ZGdlcyBhcm91bmQgdGhhdC5cbiAgICAgICAgcmV0dXJuICh0aGlzLmRvbS5vd25lckRvY3VtZW50Lmhhc0ZvY3VzKCkgfHwgYnJvd3Nlci5zYWZhcmkgJiYgKChfYSA9IHRoaXMuaW5wdXRTdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3RDb250ZXh0TWVudSkgPiBEYXRlLm5vdygpIC0gM2U0KSAmJlxuICAgICAgICAgICAgdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5jb250ZW50RE9NO1xuICAgIH1cbiAgICAvKipcbiAgICBQdXQgZm9jdXMgb24gdGhlIGVkaXRvci5cbiAgICAqL1xuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgW3Jvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jI3ZpZXcuRWRpdG9yVmlld0NvbmZpZy5yb290KSBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLiBUaGlzIGlzIG9ubHlcbiAgICBuZWNlc3Nhcnkgd2hlbiBtb3ZpbmcgdGhlIGVkaXRvcidzIGV4aXN0aW5nIERPTSB0byBhIG5ldyB3aW5kb3cgb3Igc2hhZG93IHJvb3QuXG4gICAgKi9cbiAgICBzZXRSb290KHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgIT0gcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLnNldFdpbmRvdygocm9vdC5ub2RlVHlwZSA9PSA5ID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudCkuZGVmYXVsdFZpZXcgfHwgd2luZG93KTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDbGVhbiB1cCB0aGlzIGVkaXRvciB2aWV3LCByZW1vdmluZyBpdHMgZWxlbWVudCBmcm9tIHRoZVxuICAgIGRvY3VtZW50LCB1bnJlZ2lzdGVyaW5nIGV2ZW50IGhhbmRsZXJzLCBhbmQgbm90aWZ5aW5nXG4gICAgcGx1Z2lucy4gVGhlIHZpZXcgaW5zdGFuY2UgY2FuIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyXG4gICAgY2FsbGluZyB0aGlzLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgY2FuIGJlXG4gICAgW2FkZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0byBhIHRyYW5zYWN0aW9uIHRvXG4gICAgY2F1c2UgaXQgdG8gc2Nyb2xsIHRoZSBnaXZlbiBwb3NpdGlvbiBvciByYW5nZSBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgc2Nyb2xsSW50b1ZpZXcocG9zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQodHlwZW9mIHBvcyA9PSBcIm51bWJlclwiID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpIDogcG9zLCBvcHRpb25zLnksIG9wdGlvbnMueCwgb3B0aW9ucy55TWFyZ2luLCBvcHRpb25zLnhNYXJnaW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGFuIGVmZmVjdCB0aGF0IHJlc2V0cyB0aGUgZWRpdG9yIHRvIGl0cyBjdXJyZW50IChhdCB0aGVcbiAgICB0aW1lIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQpIHNjcm9sbCBwb3NpdGlvbi4gTm90ZSB0aGF0IHRoaXNcbiAgICBvbmx5IGFmZmVjdHMgdGhlIGVkaXRvcidzIG93biBzY3JvbGxhYmxlIGVsZW1lbnQsIG5vdCBwYXJlbnRzLlxuICAgIFNlZSBhbHNvXG4gICAgW2BFZGl0b3JWaWV3Q29uZmlnLnNjcm9sbFRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdDb25maWcuc2Nyb2xsVG8pLlxuICAgIFxuICAgIFRoZSBlZmZlY3Qgc2hvdWxkIGJlIHVzZWQgd2l0aCBhIGRvY3VtZW50IGlkZW50aWNhbCB0byB0aGUgb25lXG4gICAgaXQgd2FzIGNyZWF0ZWQgZm9yLiBGYWlsaW5nIHRvIGRvIHNvIGlzIG5vdCBhbiBlcnJvciwgYnV0IG1heVxuICAgIG5vdCBzY3JvbGwgdG8gdGhlIGV4cGVjdGVkIHBvc2l0aW9uLiBZb3UgY2FuXG4gICAgW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdC5tYXApIHRoZSBlZmZlY3QgdG8gYWNjb3VudCBmb3IgY2hhbmdlcy5cbiAgICAqL1xuICAgIHNjcm9sbFNuYXBzaG90KCkge1xuICAgICAgICBsZXQgeyBzY3JvbGxUb3AsIHNjcm9sbExlZnQgfSA9IHRoaXMuc2Nyb2xsRE9NO1xuICAgICAgICBsZXQgcmVmID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQoRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyZWYuZnJvbSksIFwic3RhcnRcIiwgXCJzdGFydFwiLCByZWYudG9wIC0gc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0LCB0cnVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIERPTSBldmVudCBoYW5kbGVycy5cbiAgICBUaGUgdmFsdWUgc2hvdWxkIGJlIGFuIG9iamVjdCBtYXBwaW5nIGV2ZW50IG5hbWVzIHRvIGhhbmRsZXJcbiAgICBmdW5jdGlvbnMuIEZvciBhbnkgZ2l2ZW4gZXZlbnQsIHN1Y2ggZnVuY3Rpb25zIGFyZSBvcmRlcmVkIGJ5XG4gICAgZXh0ZW5zaW9uIHByZWNlZGVuY2UsIGFuZCB0aGUgZmlyc3QgaGFuZGxlciB0byByZXR1cm4gdHJ1ZSB3aWxsXG4gICAgYmUgYXNzdW1lZCB0byBoYXZlIGhhbmRsZWQgdGhhdCBldmVudCwgYW5kIG5vIG90aGVyIGhhbmRsZXJzIG9yXG4gICAgYnVpbHQtaW4gYmVoYXZpb3Igd2lsbCBiZSBhY3RpdmF0ZWQgZm9yIGl0LiBUaGVzZSBhcmUgcmVnaXN0ZXJlZFxuICAgIG9uIHRoZSBbY29udGVudCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb250ZW50RE9NKSwgZXhjZXB0XG4gICAgZm9yIGBzY3JvbGxgIGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSB0aGVcbiAgICBlZGl0b3IncyBbc2Nyb2xsIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnNjcm9sbERPTSkgb3Igb25lIG9mXG4gICAgaXRzIHBhcmVudCBub2RlcyBpcyBzY3JvbGxlZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkb21FdmVudEhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSgoKSA9PiAoe30pLCB7IGV2ZW50SGFuZGxlcnM6IGhhbmRsZXJzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgcmVnaXN0ZXJzIERPTSBldmVudCBvYnNlcnZlcnMuIENvbnRyYXJ5XG4gICAgdG8gZXZlbnQgW2hhbmRsZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kb21FdmVudEhhbmRsZXJzKSxcbiAgICBvYnNlcnZlcnMgY2FuJ3QgYmUgcHJldmVudGVkIGZyb20gcnVubmluZyBieSBhIGhpZ2hlci1wcmVjZWRlbmNlXG4gICAgaGFuZGxlciByZXR1cm5pbmcgdHJ1ZS4gVGhleSBhbHNvIGRvbid0IHByZXZlbnQgb3RoZXIgaGFuZGxlcnNcbiAgICBhbmQgb2JzZXJ2ZXJzIGZyb20gcnVubmluZyB3aGVuIHRoZXkgcmV0dXJuIHRydWUsIGFuZCBzaG91bGQgbm90XG4gICAgY2FsbCBgcHJldmVudERlZmF1bHRgLlxuICAgICovXG4gICAgc3RhdGljIGRvbUV2ZW50T2JzZXJ2ZXJzKG9ic2VydmVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudE9ic2VydmVyczogb2JzZXJ2ZXJzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0aGVtZSBleHRlbnNpb24uIFRoZSBmaXJzdCBhcmd1bWVudCBjYW4gYmUgYVxuICAgIFtgc3R5bGUtbW9kYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pXG4gICAgc3R5bGUgc3BlYyBwcm92aWRpbmcgdGhlIHN0eWxlcyBmb3IgdGhlIHRoZW1lLiBUaGVzZSB3aWxsIGJlXG4gICAgcHJlZml4ZWQgd2l0aCBhIGdlbmVyYXRlZCBjbGFzcyBmb3IgdGhlIHN0eWxlLlxuICAgIFxuICAgIEJlY2F1c2UgdGhlIHNlbGVjdG9ycyB3aWxsIGJlIHByZWZpeGVkIHdpdGggYSBzY29wZSBjbGFzcywgcnVsZVxuICAgIHRoYXQgZGlyZWN0bHkgbWF0Y2ggdGhlIGVkaXRvcidzIFt3cmFwcGVyXG4gICAgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9tKeKAlHRvIHdoaWNoIHRoZSBzY29wZSBjbGFzcyB3aWxsIGJlXG4gICAgYWRkZWTigJRuZWVkIHRvIGJlIGV4cGxpY2l0bHkgZGlmZmVyZW50aWF0ZWQgYnkgYWRkaW5nIGFuIGAmYCB0b1xuICAgIHRoZSBzZWxlY3RvciBmb3IgdGhhdCBlbGVtZW504oCUZm9yIGV4YW1wbGVcbiAgICBgJi5jbS1mb2N1c2VkYC5cbiAgICBcbiAgICBXaGVuIGBkYXJrYCBpcyBzZXQgdG8gdHJ1ZSwgdGhlIHRoZW1lIHdpbGwgYmUgbWFya2VkIGFzIGRhcmssXG4gICAgd2hpY2ggd2lsbCBjYXVzZSB0aGUgYCZkYXJrYCBydWxlcyBmcm9tIFtiYXNlXG4gICAgdGhlbWVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15iYXNlVGhlbWUpIHRvIGJlIHVzZWQgKGFzIG9wcG9zZWQgdG9cbiAgICBgJmxpZ2h0YCB3aGVuIGEgbGlnaHQgdGhlbWUgaXMgYWN0aXZlKS5cbiAgICAqL1xuICAgIHN0YXRpYyB0aGVtZShzcGVjLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBTdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbdGhlbWUub2YocHJlZml4KSwgc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShgLiR7cHJlZml4fWAsIHNwZWMpKV07XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGFyaylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhcmtUaGVtZS5vZih0cnVlKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBhZGRzIHN0eWxlcyB0byB0aGUgYmFzZSB0aGVtZS4gTGlrZVxuICAgIHdpdGggW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSwgdXNlIGAmYCB0byBpbmRpY2F0ZSB0aGVcbiAgICBwbGFjZSBvZiB0aGUgZWRpdG9yIHdyYXBwZXIgZWxlbWVudCB3aGVuIGRpcmVjdGx5IHRhcmdldGluZ1xuICAgIHRoYXQuIFlvdSBjYW4gYWxzbyB1c2UgYCZkYXJrYCBvciBgJmxpZ2h0YCBpbnN0ZWFkIHRvIG9ubHlcbiAgICB0YXJnZXQgZWRpdG9ycyB3aXRoIGEgZGFyayBvciBsaWdodCB0aGVtZS5cbiAgICAqL1xuICAgIHN0YXRpYyBiYXNlVGhlbWUoc3BlYykge1xuICAgICAgICByZXR1cm4gUHJlYy5sb3dlc3Qoc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCBzcGVjLCBsaWdodERhcmtJRHMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIGFuIGVkaXRvciB2aWV3IGluc3RhbmNlIGZyb20gdGhlIHZpZXcncyBET01cbiAgICByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kRnJvbURPTShkb20pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY29udGVudCA9IGRvbS5xdWVyeVNlbGVjdG9yKFwiLmNtLWNvbnRlbnRcIik7XG4gICAgICAgIGxldCBjVmlldyA9IGNvbnRlbnQgJiYgQ29udGVudFZpZXcuZ2V0KGNvbnRlbnQpIHx8IENvbnRlbnRWaWV3LmdldChkb20pO1xuICAgICAgICByZXR1cm4gKChfYSA9IGNWaWV3ID09PSBudWxsIHx8IGNWaWV3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjVmlldy5yb290VmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZpZXcpIHx8IG51bGw7XG4gICAgfVxufVxuLyoqXG5GYWNldCB0byBhZGQgYSBbc3R5bGVcbm1vZHVsZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pIHRvXG5hbiBlZGl0b3Igdmlldy4gVGhlIHZpZXcgd2lsbCBlbnN1cmUgdGhhdCB0aGUgbW9kdWxlIGlzXG5tb3VudGVkIGluIGl0cyBbZG9jdW1lbnRcbnJvb3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnN0cnVjdG9yXmNvbmZpZy5yb290KS5cbiovXG5FZGl0b3JWaWV3LnN0eWxlTW9kdWxlID0gc3R5bGVNb2R1bGU7XG4vKipcbkFuIGlucHV0IGhhbmRsZXIgY2FuIG92ZXJyaWRlIHRoZSB3YXkgY2hhbmdlcyB0byB0aGUgZWRpdGFibGVcbkRPTSBjb250ZW50IGFyZSBoYW5kbGVkLiBIYW5kbGVycyBhcmUgcGFzc2VkIHRoZSBkb2N1bWVudFxucG9zaXRpb25zIGJldHdlZW4gd2hpY2ggdGhlIGNoYW5nZSB3YXMgZm91bmQsIGFuZCB0aGUgbmV3XG5jb250ZW50LiBXaGVuIG9uZSByZXR1cm5zIHRydWUsIG5vIGZ1cnRoZXIgaW5wdXQgaGFuZGxlcnMgYXJlXG5jYWxsZWQgYW5kIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIHByZXZlbnRlZC5cblxuVGhlIGBpbnNlcnRgIGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIGdldCB0aGUgZGVmYXVsdCB0cmFuc2FjdGlvblxudGhhdCB3b3VsZCBiZSBhcHBsaWVkIGZvciB0aGlzIGlucHV0LiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlblxuZGlzcGF0Y2hpbmcgdGhlIGN1c3RvbSBiZWhhdmlvciBhcyBhIHNlcGFyYXRlIHRyYW5zYWN0aW9uLlxuKi9cbkVkaXRvclZpZXcuaW5wdXRIYW5kbGVyID0gaW5wdXRIYW5kbGVyO1xuLyoqXG5UaGlzIGZhY2V0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgZnVuY3Rpb25zIHRoYXQgY3JlYXRlIGVmZmVjdHNcbnRvIGJlIGRpc3BhdGNoZWQgd2hlbiB0aGUgZWRpdG9yJ3MgZm9jdXMgc3RhdGUgY2hhbmdlcy5cbiovXG5FZGl0b3JWaWV3LmZvY3VzQ2hhbmdlRWZmZWN0ID0gZm9jdXNDaGFuZ2VFZmZlY3Q7XG4vKipcbkJ5IGRlZmF1bHQsIHRoZSBlZGl0b3IgYXNzdW1lcyBhbGwgaXRzIGNvbnRlbnQgaGFzIHRoZSBzYW1lXG5bdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EaXJlY3Rpb24pLiBDb25maWd1cmUgdGhpcyB3aXRoIGEgYHRydWVgXG52YWx1ZSB0byBtYWtlIGl0IHJlYWQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIGV2ZXJ5IChyZW5kZXJlZClcbmxpbmUgc2VwYXJhdGVseS5cbiovXG5FZGl0b3JWaWV3LnBlckxpbmVUZXh0RGlyZWN0aW9uID0gcGVyTGluZVRleHREaXJlY3Rpb247XG4vKipcbkFsbG93cyB5b3UgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZVxubGlicmFyeSBjYXRjaGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIGV4dGVuc2lvbiAobW9zdGx5IGZyb20gdmlld1xucGx1Z2lucywgYnV0IG1heSBiZSB1c2VkIGJ5IG90aGVyIGV4dGVuc2lvbnMgdG8gcm91dGUgZXhjZXB0aW9uc1xuZnJvbSB1c2VyLWNvZGUtcHJvdmlkZWQgY2FsbGJhY2tzKS4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvclxuZGVidWdnaW5nIGFuZCBsb2dnaW5nLiBTZWUgW2Bsb2dFeGNlcHRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubG9nRXhjZXB0aW9uKS5cbiovXG5FZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmsgPSBleGNlcHRpb25TaW5rO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbmV2ZXJ5IHRpbWUgdGhlIHZpZXcgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyID0gdXBkYXRlTGlzdGVuZXI7XG4vKipcbkZhY2V0IHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yIGNvbnRlbnQgRE9NIGlzIGVkaXRhYmxlLlxuV2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzIGBmYWxzZWAsIHRoZSBlbGVtZW50IHdpbGxcbm5vdCBoYXZlIGl0cyBgY29udGVudGVkaXRhYmxlYCBhdHRyaWJ1dGUgc2V0LiAoTm90ZSB0aGF0IHRoaXNcbmRvZXNuJ3QgYWZmZWN0IEFQSSBjYWxscyB0aGF0IGNoYW5nZSB0aGUgZWRpdG9yIGNvbnRlbnQsIGV2ZW5cbndoZW4gdGhvc2UgYXJlIGJvdW5kIHRvIGtleXMgb3IgYnV0dG9ucy4gU2VlIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGZhY2V0IGZvciB0aGF0LilcbiovXG5FZGl0b3JWaWV3LmVkaXRhYmxlID0gZWRpdGFibGU7XG4vKipcbkFsbG93cyB5b3UgdG8gaW5mbHVlbmNlIHRoZSB3YXkgbW91c2Ugc2VsZWN0aW9uIGhhcHBlbnMuIFRoZVxuZnVuY3Rpb25zIGluIHRoaXMgZmFjZXQgd2lsbCBiZSBjYWxsZWQgZm9yIGEgYG1vdXNlZG93bmAgZXZlbnRcbm9uIHRoZSBlZGl0b3IsIGFuZCBjYW4gcmV0dXJuIGFuIG9iamVjdCB0aGF0IG92ZXJyaWRlcyB0aGUgd2F5IGFcbnNlbGVjdGlvbiBpcyBjb21wdXRlZCBmcm9tIHRoYXQgbW91c2UgY2xpY2sgb3IgZHJhZy5cbiovXG5FZGl0b3JWaWV3Lm1vdXNlU2VsZWN0aW9uU3R5bGUgPSBtb3VzZVNlbGVjdGlvblN0eWxlO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW9uIGRyYWcgZXZlbnRcbnNob3VsZCBtb3ZlIG9yIGNvcHkgdGhlIHNlbGVjdGlvbi4gVGhlIGdpdmVuIHByZWRpY2F0ZSB3aWxsIGJlXG5jYWxsZWQgd2l0aCB0aGUgYG1vdXNlZG93bmAgZXZlbnQsIGFuZCBjYW4gcmV0dXJuIGB0cnVlYCB3aGVuXG50aGUgZHJhZyBzaG91bGQgbW92ZSB0aGUgY29udGVudC5cbiovXG5FZGl0b3JWaWV3LmRyYWdNb3Zlc1NlbGVjdGlvbiA9IGRyYWdNb3Zlc1NlbGVjdGlvbiQxO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNvbmZpZ3VyZSB3aGV0aGVyIGEgZ2l2ZW4gc2VsZWN0aW5nIGNsaWNrIGFkZHMgYVxubmV3IHJhbmdlIHRvIHRoZSBleGlzdGluZyBzZWxlY3Rpb24gb3IgcmVwbGFjZXMgaXQgZW50aXJlbHkuIFRoZVxuZGVmYXVsdCBiZWhhdmlvciBpcyB0byBjaGVjayBgZXZlbnQubWV0YUtleWAgb24gbWFjT1MsIGFuZFxuYGV2ZW50LmN0cmxLZXlgIGVsc2V3aGVyZS5cbiovXG5FZGl0b3JWaWV3LmNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2U7XG4vKipcbkEgZmFjZXQgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb24pXG5hcmUgc2hvd24gaW4gdGhlIHZpZXcuIERlY29yYXRpb25zIGNhbiBiZSBwcm92aWRlZCBpbiB0d29cbndheXPigJRkaXJlY3RseSwgb3IgdmlhIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBlZGl0b3Igdmlldy5cblxuT25seSBkZWNvcmF0aW9uIHNldHMgcHJvdmlkZWQgZGlyZWN0bHkgYXJlIGFsbG93ZWQgdG8gaW5mbHVlbmNlXG50aGUgZWRpdG9yJ3MgdmVydGljYWwgbGF5b3V0IHN0cnVjdHVyZS4gVGhlIG9uZXMgcHJvdmlkZWQgYXNcbmZ1bmN0aW9ucyBhcmUgY2FsbGVkIF9hZnRlcl8gdGhlIG5ldyB2aWV3cG9ydCBoYXMgYmVlbiBjb21wdXRlZCxcbmFuZCB0aHVzICoqbXVzdCBub3QqKiBpbnRyb2R1Y2UgYmxvY2sgd2lkZ2V0cyBvciByZXBsYWNpbmdcbmRlY29yYXRpb25zIHRoYXQgY292ZXIgbGluZSBicmVha3MuXG5cbklmIHlvdSB3YW50IGRlY29yYXRlZCByYW5nZXMgdG8gYmVoYXZlIGxpa2UgYXRvbWljIHVuaXRzIGZvclxuY3Vyc29yIG1vdGlvbiBhbmQgZGVsZXRpb24gcHVycG9zZXMsIGFsc28gcHJvdmlkZSB0aGUgcmFuZ2Ugc2V0XG5jb250YWluaW5nIHRoZSBkZWNvcmF0aW9ucyB0b1xuW2BFZGl0b3JWaWV3LmF0b21pY1Jhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmF0b21pY1JhbmdlcykuXG4qL1xuRWRpdG9yVmlldy5kZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zO1xuLyoqXG5GYWNldCB0aGF0IHdvcmtzIG11Y2ggbGlrZVxuW2BkZWNvcmF0aW9uc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgYnV0IHB1dHMgaXRzXG5pbnB1dHMgYXQgdGhlIHZlcnkgYm90dG9tIG9mIHRoZSBwcmVjZWRlbmNlIHN0YWNrLCBtZWFuaW5nIG1hcmtcbmRlY29yYXRpb25zIHByb3ZpZGVkIGhlcmUgd2lsbCBvbmx5IGJlIHNwbGl0IGJ5IG90aGVyLCBwYXJ0aWFsbHlcbm92ZXJsYXBwaW5nIFxcYG91dGVyRGVjb3JhdGlvbnNcXGAgcmFuZ2VzLCBhbmQgd3JhcCBhcm91bmQgYWxsXG5yZWd1bGFyIGRlY29yYXRpb25zLiBVc2UgdGhpcyBmb3IgbWFyayBlbGVtZW50cyB0aGF0IHNob3VsZCwgYXNcbm11Y2ggYXMgcG9zc2libGUsIHJlbWFpbiBpbiBvbmUgcGllY2UuXG4qL1xuRWRpdG9yVmlldy5vdXRlckRlY29yYXRpb25zID0gb3V0ZXJEZWNvcmF0aW9ucztcbi8qKlxuVXNlZCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGF0b21zIGFzIGZhciBhc1xuY3Vyc29yIG1vdGlvbiBpcyBjb25jZXJuZWQuIFRoaXMgY2F1c2VzIG1ldGhvZHMgbGlrZVxuW2Btb3ZlQnlDaGFyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5Q2hhcikgYW5kXG5bYG1vdmVWZXJ0aWNhbGx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIChhbmQgdGhlXG5jb21tYW5kcyBidWlsdCBvbiB0b3Agb2YgdGhlbSkgdG8gc2tpcCBhY3Jvc3Mgc3VjaCByZWdpb25zIHdoZW5cbmEgc2VsZWN0aW9uIGVuZHBvaW50IHdvdWxkIGVudGVyIHRoZW0uIFRoaXMgZG9lcyBfbm90XyBwcmV2ZW50XG5kaXJlY3QgcHJvZ3JhbW1hdGljIFtzZWxlY3Rpb25cbnVwZGF0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgZnJvbSBtb3ZpbmcgaW50byBzdWNoXG5yZWdpb25zLlxuKi9cbkVkaXRvclZpZXcuYXRvbWljUmFuZ2VzID0gYXRvbWljUmFuZ2VzO1xuLyoqXG5XaGVuIHJhbmdlIGRlY29yYXRpb25zIGFkZCBhIGB1bmljb2RlLWJpZGk6IGlzb2xhdGVgIHN0eWxlLCB0aGV5XG5zaG91bGQgYWxzbyBpbmNsdWRlIGFcbltgYmlkaUlzb2xhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTWFya0RlY29yYXRpb25TcGVjLmJpZGlJc29sYXRlKSBwcm9wZXJ0eVxuaW4gdGhlaXIgZGVjb3JhdGlvbiBzcGVjLCBhbmQgYmUgZXhwb3NlZCB0aHJvdWdoIHRoaXMgZmFjZXQsIHNvXG50aGF0IHRoZSBlZGl0b3IgY2FuIGNvbXB1dGUgdGhlIHByb3BlciB0ZXh0IG9yZGVyLiAoT3RoZXIgdmFsdWVzXG5mb3IgYHVuaWNvZGUtYmlkaWAsIGV4Y2VwdCBvZiBjb3Vyc2UgYG5vcm1hbGAsIGFyZSBub3RcbnN1cHBvcnRlZC4pXG4qL1xuRWRpdG9yVmlldy5iaWRpSXNvbGF0ZWRSYW5nZXMgPSBiaWRpSXNvbGF0ZWRSYW5nZXM7XG4vKipcbkZhY2V0IHRoYXQgYWxsb3dzIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIHNjcm9sbFxubWFyZ2lucyAoc3BhY2UgYXJvdW5kIHRoZSBzaWRlcyBvZiB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQgdGhhdFxuc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW52aXNpYmxlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlXG5wbHVnaW4gaW50cm9kdWNlcyBlbGVtZW50cyB0aGF0IGNvdmVyIHBhcnQgb2YgdGhhdCBlbGVtZW50IChmb3JcbmV4YW1wbGUgYSBob3Jpem9udGFsbHkgZml4ZWQgZ3V0dGVyKS5cbiovXG5FZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMgPSBzY3JvbGxNYXJnaW5zO1xuLyoqXG5UaGlzIGZhY2V0IHJlY29yZHMgd2hldGhlciBhIGRhcmsgdGhlbWUgaXMgYWN0aXZlLiBUaGUgZXh0ZW5zaW9uXG5yZXR1cm5lZCBieSBbYHRoZW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdedGhlbWUpIGF1dG9tYXRpY2FsbHlcbmluY2x1ZGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgd2hlbiB0aGUgYGRhcmtgIG9wdGlvbiBpcyBzZXQgdG9cbnRydWUuXG4qL1xuRWRpdG9yVmlldy5kYXJrVGhlbWUgPSBkYXJrVGhlbWU7XG4vKipcblByb3ZpZGVzIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgbm9uY2UgdG8gdXNlIHdoZW4gY3JlYXRpbmdcbnRoZSBzdHlsZSBzaGVldHMgZm9yIHRoZSBlZGl0b3IuIEhvbGRzIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiBub1xubm9uY2UgaGFzIGJlZW4gcHJvdmlkZWQuXG4qL1xuRWRpdG9yVmlldy5jc3BOb25jZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IFwiXCIgfSk7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgYWRkaXRpb25hbCBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzXG5lZGl0YWJsZSBET00gZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzID0gY29udGVudEF0dHJpYnV0ZXM7XG4vKipcbkZhY2V0IHRoYXQgcHJvdmlkZXMgRE9NIGF0dHJpYnV0ZXMgZm9yIHRoZSBlZGl0b3IncyBvdXRlclxuZWxlbWVudC5cbiovXG5FZGl0b3JWaWV3LmVkaXRvckF0dHJpYnV0ZXMgPSBlZGl0b3JBdHRyaWJ1dGVzO1xuLyoqXG5BbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGxpbmUgd3JhcHBpbmcgaW4gdGhlIGVkaXRvciAoYnlcbnNldHRpbmcgQ1NTIGB3aGl0ZS1zcGFjZWAgdG8gYHByZS13cmFwYCBpbiB0aGUgY29udGVudCkuXG4qL1xuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih7IFwiY2xhc3NcIjogXCJjbS1saW5lV3JhcHBpbmdcIiB9KTtcbi8qKlxuU3RhdGUgZWZmZWN0IHVzZWQgdG8gaW5jbHVkZSBzY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudHMgaW4gYVxudHJhbnNhY3Rpb24uIFRoZXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIERPTSBpbiBhIHZpc3VhbGx5IGhpZGRlblxuZWxlbWVudCB3aXRoIGBhcmlhLWxpdmU9XCJwb2xpdGVcImAgc2V0LCBhbmQgc2hvdWxkIGJlIHVzZWQgdG9cbmRlc2NyaWJlIGVmZmVjdHMgdGhhdCBhcmUgdmlzdWFsbHkgb2J2aW91cyBidXQgbWF5IG5vdCBiZVxubm90aWNlZCBieSBzY3JlZW4gcmVhZGVyIHVzZXJzIChzdWNoIGFzIG1vdmluZyB0byB0aGUgbmV4dFxuc2VhcmNoIG1hdGNoKS5cbiovXG5FZGl0b3JWaWV3LmFubm91bmNlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLy8gTWF4aW11bSBsaW5lIGxlbmd0aCBmb3Igd2hpY2ggd2UgY29tcHV0ZSBhY2N1cmF0ZSBiaWRpIGluZm9cbmNvbnN0IE1heEJpZGlMaW5lID0gNDA5NjtcbmNvbnN0IEJhZE1lYXN1cmUgPSB7fTtcbmNsYXNzIENhY2hlZE9yZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgZGlyLCBpc29sYXRlcywgZnJlc2gsIG9yZGVyKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMuaXNvbGF0ZXMgPSBpc29sYXRlcztcbiAgICAgICAgdGhpcy5mcmVzaCA9IGZyZXNoO1xuICAgICAgICB0aGlzLm9yZGVyID0gb3JkZXI7XG4gICAgfVxuICAgIHN0YXRpYyB1cGRhdGUoY2FjaGUsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgJiYgIWNhY2hlLnNvbWUoYyA9PiBjLmZyZXNoKSlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBsYXN0RGlyID0gY2FjaGUubGVuZ3RoID8gY2FjaGVbY2FjaGUubGVuZ3RoIC0gMV0uZGlyIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGgubWF4KDAsIGNhY2hlLmxlbmd0aCAtIDEwKTsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSBjYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5kaXIgPT0gbGFzdERpciAmJiAhY2hhbmdlcy50b3VjaGVzUmFuZ2UoZW50cnkuZnJvbSwgZW50cnkudG8pKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBDYWNoZWRPcmRlcihjaGFuZ2VzLm1hcFBvcyhlbnRyeS5mcm9tLCAxKSwgY2hhbmdlcy5tYXBQb3MoZW50cnkudG8sIC0xKSwgZW50cnkuZGlyLCBlbnRyeS5pc29sYXRlcywgZmFsc2UsIGVudHJ5Lm9yZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyc0Zyb21GYWNldCh2aWV3LCBmYWNldCwgYmFzZSkge1xuICAgIGZvciAobGV0IHNvdXJjZXMgPSB2aWV3LnN0YXRlLmZhY2V0KGZhY2V0KSwgaSA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHNvdXJjZXNbaV0sIHZhbHVlID0gdHlwZW9mIHNvdXJjZSA9PSBcImZ1bmN0aW9uXCIgPyBzb3VyY2UodmlldykgOiBzb3VyY2U7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGNvbWJpbmVBdHRycyh2YWx1ZSwgYmFzZSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xufVxuXG5jb25zdCBjdXJyZW50UGxhdGZvcm0gPSBicm93c2VyLm1hYyA/IFwibWFjXCIgOiBicm93c2VyLndpbmRvd3MgPyBcIndpblwiIDogYnJvd3Nlci5saW51eCA/IFwibGludXhcIiA6IFwia2V5XCI7XG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUsIHBsYXRmb3JtKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PSBcIlNwYWNlXCIpXG4gICAgICAgIHJlc3VsdCA9IFwiIFwiO1xuICAgIGxldCBhbHQsIGN0cmwsIHNoaWZ0LCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtID09IFwibWFjXCIpXG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKTtcbiAgICB9XG4gICAgaWYgKGFsdClcbiAgICAgICAgcmVzdWx0ID0gXCJBbHQtXCIgKyByZXN1bHQ7XG4gICAgaWYgKGN0cmwpXG4gICAgICAgIHJlc3VsdCA9IFwiQ3RybC1cIiArIHJlc3VsdDtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgcmVzdWx0ID0gXCJNZXRhLVwiICsgcmVzdWx0O1xuICAgIGlmIChzaGlmdClcbiAgICAgICAgcmVzdWx0ID0gXCJTaGlmdC1cIiArIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCkge1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICBuYW1lID0gXCJNZXRhLVwiICsgbmFtZTtcbiAgICBpZiAoc2hpZnQgIT09IGZhbHNlICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5jb25zdCBoYW5kbGVLZXlFdmVudHMgPSAvKkBfX1BVUkVfXyovUHJlYy5kZWZhdWx0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIGtleWRvd24oZXZlbnQsIHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIFwiZWRpdG9yXCIpO1xuICAgIH1cbn0pKTtcbi8qKlxuRmFjZXQgdXNlZCBmb3IgcmVnaXN0ZXJpbmcga2V5bWFwcy5cblxuWW91IGNhbiBhZGQgbXVsdGlwbGUga2V5bWFwcyB0byBhbiBlZGl0b3IuIFRoZWlyIHByaW9yaXRpZXNcbmRldGVybWluZSB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBzcGVjaWZpZWQgZWFybHkgb3Igd2l0aCBoaWdoXG5wcmlvcml0eSBnZXQgY2hlY2tlZCBmaXJzdCkuIFdoZW4gYSBoYW5kbGVyIGhhcyByZXR1cm5lZCBgdHJ1ZWBcbmZvciBhIGdpdmVuIGtleSwgbm8gZnVydGhlciBoYW5kbGVycyBhcmUgY2FsbGVkLlxuKi9cbmNvbnN0IGtleW1hcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBlbmFibGVzOiBoYW5kbGVLZXlFdmVudHMgfSk7XG5jb25zdCBLZXltYXBzID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vLyBUaGlzIGlzIGhpZGRlbiBiZWhpbmQgYW4gaW5kaXJlY3Rpb24sIHJhdGhlciB0aGFuIGRpcmVjdGx5IGNvbXB1dGVkXG4vLyBieSB0aGUgZmFjZXQsIHRvIGtlZXAgaW50ZXJuYWwgdHlwZXMgb3V0IG9mIHRoZSBmYWNldCdzIHR5cGUuXG5mdW5jdGlvbiBnZXRLZXltYXAoc3RhdGUpIHtcbiAgICBsZXQgYmluZGluZ3MgPSBzdGF0ZS5mYWNldChrZXltYXApO1xuICAgIGxldCBtYXAgPSBLZXltYXBzLmdldChiaW5kaW5ncyk7XG4gICAgaWYgKCFtYXApXG4gICAgICAgIEtleW1hcHMuc2V0KGJpbmRpbmdzLCBtYXAgPSBidWlsZEtleW1hcChiaW5kaW5ncy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSkpKTtcbiAgICByZXR1cm4gbWFwO1xufVxuLyoqXG5SdW4gdGhlIGtleSBoYW5kbGVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIHNjb3BlLiBUaGUgZXZlbnRcbm9iamVjdCBzaG91bGQgYmUgYSBgXCJrZXlkb3duXCJgIGV2ZW50LiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZVxuaGFuZGxlcnMgaGFuZGxlZCBpdC5cbiovXG5mdW5jdGlvbiBydW5TY29wZUhhbmRsZXJzKHZpZXcsIGV2ZW50LCBzY29wZSkge1xuICAgIHJldHVybiBydW5IYW5kbGVycyhnZXRLZXltYXAodmlldy5zdGF0ZSksIGV2ZW50LCB2aWV3LCBzY29wZSk7XG59XG5sZXQgc3RvcmVkUHJlZml4ID0gbnVsbDtcbmNvbnN0IFByZWZpeFRpbWVvdXQgPSA0MDAwO1xuZnVuY3Rpb24gYnVpbGRLZXltYXAoYmluZGluZ3MsIHBsYXRmb3JtID0gY3VycmVudFBsYXRmb3JtKSB7XG4gICAgbGV0IGJvdW5kID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaXNQcmVmaXggPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjaGVja1ByZWZpeCA9IChuYW1lLCBpcykgPT4ge1xuICAgICAgICBsZXQgY3VycmVudCA9IGlzUHJlZml4W25hbWVdO1xuICAgICAgICBpZiAoY3VycmVudCA9PSBudWxsKVxuICAgICAgICAgICAgaXNQcmVmaXhbbmFtZV0gPSBpcztcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudCAhPSBpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleSBiaW5kaW5nIFwiICsgbmFtZSArIFwiIGlzIHVzZWQgYm90aCBhcyBhIHJlZ3VsYXIgYmluZGluZyBhbmQgYXMgYSBtdWx0aS1zdHJva2UgcHJlZml4XCIpO1xuICAgIH07XG4gICAgbGV0IGFkZCA9IChzY29wZSwga2V5LCBjb21tYW5kLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgvICg/ISQpLykubWFwKGsgPT4gbm9ybWFsaXplS2V5TmFtZShrLCBwbGF0Zm9ybSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICBjaGVja1ByZWZpeChwcmVmaXgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzY29wZU9ialtwcmVmaXhdKVxuICAgICAgICAgICAgICAgIHNjb3BlT2JqW3ByZWZpeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBydW46IFsodmlldykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXJPYmogPSBzdG9yZWRQcmVmaXggPSB7IHZpZXcsIHByZWZpeCwgc2NvcGUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgaWYgKHN0b3JlZFByZWZpeCA9PSBvdXJPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7IH0sIFByZWZpeFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdWxsID0gcGFydHMuam9pbihcIiBcIik7XG4gICAgICAgIGNoZWNrUHJlZml4KGZ1bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IGJpbmRpbmcgPSBzY29wZU9ialtmdWxsXSB8fCAoc2NvcGVPYmpbZnVsbF0gPSB7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgcnVuOiAoKF9iID0gKF9hID0gc2NvcGVPYmouX2FueSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJ1bikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWNlKCkpIHx8IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29tbWFuZClcbiAgICAgICAgICAgIGJpbmRpbmcucnVuLnB1c2goY29tbWFuZCk7XG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdClcbiAgICAgICAgICAgIGJpbmRpbmcucHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICBpZiAoc3RvcFByb3BhZ2F0aW9uKVxuICAgICAgICAgICAgYmluZGluZy5zdG9wUHJvcGFnYXRpb24gPSB0cnVlO1xuICAgIH07XG4gICAgZm9yIChsZXQgYiBvZiBiaW5kaW5ncykge1xuICAgICAgICBsZXQgc2NvcGVzID0gYi5zY29wZSA/IGIuc2NvcGUuc3BsaXQoXCIgXCIpIDogW1wiZWRpdG9yXCJdO1xuICAgICAgICBpZiAoYi5hbnkpXG4gICAgICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2NvcGVPYmogPSBib3VuZFtzY29wZV0gfHwgKGJvdW5kW3Njb3BlXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVPYmouX2FueSlcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPYmouX2FueSA9IHsgcHJldmVudERlZmF1bHQ6IGZhbHNlLCBzdG9wUHJvcGFnYXRpb246IGZhbHNlLCBydW46IFtdIH07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNjb3BlT2JqKVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9ialtrZXldLnJ1bi5wdXNoKGIuYW55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWUgPSBiW3BsYXRmb3JtXSB8fCBiLmtleTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgYWRkKHNjb3BlLCBuYW1lLCBiLnJ1biwgYi5wcmV2ZW50RGVmYXVsdCwgYi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgaWYgKGIuc2hpZnQpXG4gICAgICAgICAgICAgICAgYWRkKHNjb3BlLCBcIlNoaWZ0LVwiICsgbmFtZSwgYi5zaGlmdCwgYi5wcmV2ZW50RGVmYXVsdCwgYi5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3VuZDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJzKG1hcCwgZXZlbnQsIHZpZXcsIHNjb3BlKSB7XG4gICAgbGV0IG5hbWUgPSBrZXlOYW1lKGV2ZW50KTtcbiAgICBsZXQgY2hhckNvZGUgPSBjb2RlUG9pbnRBdChuYW1lLCAwKSwgaXNDaGFyID0gY29kZVBvaW50U2l6ZShjaGFyQ29kZSkgPT0gbmFtZS5sZW5ndGggJiYgbmFtZSAhPSBcIiBcIjtcbiAgICBsZXQgcHJlZml4ID0gXCJcIiwgaGFuZGxlZCA9IGZhbHNlLCBwcmV2ZW50ZWQgPSBmYWxzZSwgc3RvcFByb3BhZ2F0aW9uID0gZmFsc2U7XG4gICAgaWYgKHN0b3JlZFByZWZpeCAmJiBzdG9yZWRQcmVmaXgudmlldyA9PSB2aWV3ICYmIHN0b3JlZFByZWZpeC5zY29wZSA9PSBzY29wZSkge1xuICAgICAgICBwcmVmaXggPSBzdG9yZWRQcmVmaXgucHJlZml4ICsgXCIgXCI7XG4gICAgICAgIGlmIChtb2RpZmllckNvZGVzLmluZGV4T2YoZXZlbnQua2V5Q29kZSkgPCAwKSB7XG4gICAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuID0gbmV3IFNldDtcbiAgICBsZXQgcnVuRm9yID0gKGJpbmRpbmcpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNtZCBvZiBiaW5kaW5nLnJ1bilcbiAgICAgICAgICAgICAgICBpZiAoIXJhbi5oYXMoY21kKSkge1xuICAgICAgICAgICAgICAgICAgICByYW4uYWRkKGNtZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbWQodmlldywgZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBsZXQgc2NvcGVPYmogPSBtYXBbc2NvcGVdLCBiYXNlTmFtZSwgc2hpZnROYW1lO1xuICAgIGlmIChzY29wZU9iaikge1xuICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgIWlzQ2hhcildKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDaGFyICYmIChldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJlxuICAgICAgICAgICAgLy8gQ3RybC1BbHQgbWF5IGJlIHVzZWQgZm9yIEFsdEdyIG9uIFdpbmRvd3NcbiAgICAgICAgICAgICEoYnJvd3Nlci53aW5kb3dzICYmIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5KSAmJlxuICAgICAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoYmFzZU5hbWUsIGV2ZW50LCB0cnVlKV0pKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoc2hpZnROYW1lID0gc2hpZnRbZXZlbnQua2V5Q29kZV0pICE9IG5hbWUgJiYgc2hpZnROYW1lICE9IGJhc2VOYW1lICYmXG4gICAgICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhzaGlmdE5hbWUsIGV2ZW50LCBmYWxzZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiBldmVudC5zaGlmdEtleSAmJlxuICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVkICYmIHJ1bkZvcihzY29wZU9iai5fYW55KSlcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJldmVudGVkKVxuICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICBpZiAoaGFuZGxlZCAmJiBzdG9wUHJvcGFnYXRpb24pXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHJldHVybiBoYW5kbGVkO1xufVxuXG4vKipcbkltcGxlbWVudGF0aW9uIG9mIFtgTGF5ZXJNYXJrZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuTGF5ZXJNYXJrZXIpIHRoYXQgY3JlYXRlc1xuYSByZWN0YW5nbGUgYXQgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMuXG4qL1xuY2xhc3MgUmVjdGFuZ2xlTWFya2VyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrZXIgd2l0aCB0aGUgZ2l2ZW4gY2xhc3MgYW5kIGRpbWVuc2lvbnMuIElmIGB3aWR0aGBcbiAgICBpcyBudWxsLCB0aGUgRE9NIGVsZW1lbnQgd2lsbCBnZXQgbm8gd2lkdGggc3R5bGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGFzc05hbWUsIFxuICAgIC8qKlxuICAgIFRoZSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIgKGluIHBpeGVscywgZG9jdW1lbnQtcmVsYXRpdmUpLlxuICAgICovXG4gICAgbGVmdCwgXG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgbWFya2VyLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBUaGUgd2lkdGggb2YgdGhlIG1hcmtlciwgb3IgbnVsbCBpZiBpdCBzaG91bGRuJ3QgZ2V0IGEgd2lkdGggYXNzaWduZWQuXG4gICAgKi9cbiAgICB3aWR0aCwgXG4gICAgLyoqXG4gICAgVGhlIGhlaWdodCBvZiB0aGUgbWFya2VyLlxuICAgICovXG4gICAgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgdXBkYXRlKGVsdCwgcHJldikge1xuICAgICAgICBpZiAocHJldi5jbGFzc05hbWUgIT0gdGhpcy5jbGFzc05hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhZGp1c3QoZWx0KSB7XG4gICAgICAgIGVsdC5zdHlsZS5sZWZ0ID0gdGhpcy5sZWZ0ICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUudG9wID0gdGhpcy50b3AgKyBcInB4XCI7XG4gICAgICAgIGlmICh0aGlzLndpZHRoICE9IG51bGwpXG4gICAgICAgICAgICBlbHQuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgXCJweFwiO1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgfVxuICAgIGVxKHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA9PSBwLmxlZnQgJiYgdGhpcy50b3AgPT0gcC50b3AgJiYgdGhpcy53aWR0aCA9PSBwLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09IHAuaGVpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9PSBwLmNsYXNzTmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIHJlY3RhbmdsZXMgZm9yIHRoZSBnaXZlbiBzZWxlY3Rpb24gcmFuZ2UsXG4gICAgYXNzaWduaW5nIHRoZW0gdGhlY2xhc3NgY2xhc3NOYW1lYC4gV2lsbCBjcmVhdGUgYSBzaW5nbGVcbiAgICByZWN0YW5nbGUgZm9yIGVtcHR5IHJhbmdlcywgYW5kIGEgc2V0IG9mIHNlbGVjdGlvbi1zdHlsZVxuICAgIHJlY3RhbmdsZXMgY292ZXJpbmcgdGhlIHJhbmdlJ3MgY29udGVudCAoaW4gYSBiaWRpLWF3YXJlXG4gICAgd2F5KSBmb3Igbm9uLWVtcHR5IG9uZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHJhbmdlLmhlYWQsIHJhbmdlLmFzc29jIHx8IDEpO1xuICAgICAgICAgICAgaWYgKCFwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgUmVjdGFuZ2xlTWFya2VyKGNsYXNzTmFtZSwgcG9zLmxlZnQgLSBiYXNlLmxlZnQsIHBvcy50b3AgLSBiYXNlLnRvcCwgbnVsbCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRCYXNlKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBsZWZ0ID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGggKiB2aWV3LnNjYWxlWDtcbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IC0gdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLCB0b3A6IHJlY3QudG9wIC0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdmlldy5zY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRMaW5lKHZpZXcsIHBvcywgaW5zaWRlKSB7XG4gICAgbGV0IHJhbmdlID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIHJldHVybiB7IGZyb206IE1hdGgubWF4KGluc2lkZS5mcm9tLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZmFsc2UsIHRydWUpLmZyb20pLFxuICAgICAgICB0bzogTWF0aC5taW4oaW5zaWRlLnRvLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgdHJ1ZSwgdHJ1ZSkuZnJvbSksXG4gICAgICAgIHR5cGU6IEJsb2NrVHlwZS5UZXh0IH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgIGlmIChyYW5nZS50byA8PSB2aWV3LnZpZXdwb3J0LmZyb20gfHwgcmFuZ2UuZnJvbSA+PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGZyb20gPSBNYXRoLm1heChyYW5nZS5mcm9tLCB2aWV3LnZpZXdwb3J0LmZyb20pLCB0byA9IE1hdGgubWluKHJhbmdlLnRvLCB2aWV3LnZpZXdwb3J0LnRvKTtcbiAgICBsZXQgbHRyID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00sIGNvbnRlbnRSZWN0ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgbGV0IGxpbmVFbHQgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY20tbGluZVwiKSwgbGluZVN0eWxlID0gbGluZUVsdCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsaW5lRWx0KTtcbiAgICBsZXQgbGVmdFNpZGUgPSBjb250ZW50UmVjdC5sZWZ0ICtcbiAgICAgICAgKGxpbmVTdHlsZSA/IHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nTGVmdCkgKyBNYXRoLm1pbigwLCBwYXJzZUludChsaW5lU3R5bGUudGV4dEluZGVudCkpIDogMCk7XG4gICAgbGV0IHJpZ2h0U2lkZSA9IGNvbnRlbnRSZWN0LnJpZ2h0IC0gKGxpbmVTdHlsZSA/IHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nUmlnaHQpIDogMCk7XG4gICAgbGV0IHN0YXJ0QmxvY2sgPSBibG9ja0F0KHZpZXcsIGZyb20pLCBlbmRCbG9jayA9IGJsb2NrQXQodmlldywgdG8pO1xuICAgIGxldCB2aXN1YWxTdGFydCA9IHN0YXJ0QmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IHN0YXJ0QmxvY2sgOiBudWxsO1xuICAgIGxldCB2aXN1YWxFbmQgPSBlbmRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gZW5kQmxvY2sgOiBudWxsO1xuICAgIGlmICh2aXN1YWxTdGFydCAmJiAodmlldy5saW5lV3JhcHBpbmcgfHwgc3RhcnRCbG9jay53aWRnZXRMaW5lQnJlYWtzKSlcbiAgICAgICAgdmlzdWFsU3RhcnQgPSB3cmFwcGVkTGluZSh2aWV3LCBmcm9tLCB2aXN1YWxTdGFydCk7XG4gICAgaWYgKHZpc3VhbEVuZCAmJiAodmlldy5saW5lV3JhcHBpbmcgfHwgZW5kQmxvY2sud2lkZ2V0TGluZUJyZWFrcykpXG4gICAgICAgIHZpc3VhbEVuZCA9IHdyYXBwZWRMaW5lKHZpZXcsIHRvLCB2aXN1YWxFbmQpO1xuICAgIGlmICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgJiYgdmlzdWFsU3RhcnQuZnJvbSA9PSB2aXN1YWxFbmQuZnJvbSkge1xuICAgICAgICByZXR1cm4gcGllY2VzKGRyYXdGb3JMaW5lKHJhbmdlLmZyb20sIHJhbmdlLnRvLCB2aXN1YWxTdGFydCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHRvcCA9IHZpc3VhbFN0YXJ0ID8gZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgbnVsbCwgdmlzdWFsU3RhcnQpIDogZHJhd0ZvcldpZGdldChzdGFydEJsb2NrLCBmYWxzZSk7XG4gICAgICAgIGxldCBib3R0b20gPSB2aXN1YWxFbmQgPyBkcmF3Rm9yTGluZShudWxsLCByYW5nZS50bywgdmlzdWFsRW5kKSA6IGRyYXdGb3JXaWRnZXQoZW5kQmxvY2ssIHRydWUpO1xuICAgICAgICBsZXQgYmV0d2VlbiA9IFtdO1xuICAgICAgICBpZiAoKHZpc3VhbFN0YXJ0IHx8IHN0YXJ0QmxvY2spLnRvIDwgKHZpc3VhbEVuZCB8fCBlbmRCbG9jaykuZnJvbSAtICh2aXN1YWxTdGFydCAmJiB2aXN1YWxFbmQgPyAxIDogMCkgfHxcbiAgICAgICAgICAgIHN0YXJ0QmxvY2sud2lkZ2V0TGluZUJyZWFrcyA+IDEgJiYgdG9wLmJvdHRvbSArIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLyAyIDwgYm90dG9tLnRvcClcbiAgICAgICAgICAgIGJldHdlZW4ucHVzaChwaWVjZShsZWZ0U2lkZSwgdG9wLmJvdHRvbSwgcmlnaHRTaWRlLCBib3R0b20udG9wKSk7XG4gICAgICAgIGVsc2UgaWYgKHRvcC5ib3R0b20gPCBib3R0b20udG9wICYmIHZpZXcuZWxlbWVudEF0SGVpZ2h0KCh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyKS50eXBlID09IEJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgdG9wLmJvdHRvbSA9IGJvdHRvbS50b3AgPSAodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMjtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyh0b3ApLmNvbmNhdChiZXR3ZWVuKS5jb25jYXQocGllY2VzKGJvdHRvbSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZShsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBsZWZ0IC0gYmFzZS5sZWZ0LCB0b3AgLSBiYXNlLnRvcCAtIDAuMDEgLyogQy5FcHNpbG9uICovLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCArIDAuMDEgLyogQy5FcHNpbG9uICovKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2VzKHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfSkge1xuICAgICAgICBsZXQgcGllY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9yaXpvbnRhbC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHBpZWNlKGhvcml6b250YWxbaV0sIHRvcCwgaG9yaXpvbnRhbFtpICsgMV0sIGJvdHRvbSkpO1xuICAgICAgICByZXR1cm4gcGllY2VzO1xuICAgIH1cbiAgICAvLyBHZXRzIHBhc3NlZCBmcm9tL3RvIGluIGxpbmUtbG9jYWwgcG9zaXRpb25zXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUoZnJvbSwgdG8sIGxpbmUpIHtcbiAgICAgICAgbGV0IHRvcCA9IDFlOSwgYm90dG9tID0gLTFlOSwgaG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRTcGFuKGZyb20sIGZyb21PcGVuLCB0bywgdG9PcGVuLCBkaXIpIHtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgMi8tMiBpcyBhIGtsdWRnZSB0byBmb3JjZSB0aGUgdmlldyB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIG9uIHRoZSBwcm9wZXIgc2lkZSBvZiBibG9jayB3aWRnZXRzLCBzaW5jZVxuICAgICAgICAgICAgLy8gbm9ybWFsaXppbmcgdGhlIHNpZGUgdGhlcmUsIHRob3VnaCBhcHByb3ByaWF0ZSBmb3IgbW9zdFxuICAgICAgICAgICAgLy8gY29vcmRzQXRQb3MgcXVlcmllcywgd291bGQgYnJlYWsgc2VsZWN0aW9uIGRyYXdpbmcuXG4gICAgICAgICAgICBsZXQgZnJvbUNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MoZnJvbSwgKGZyb20gPT0gbGluZS50byA/IC0yIDogMikpO1xuICAgICAgICAgICAgbGV0IHRvQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyh0bywgKHRvID09IGxpbmUuZnJvbSA/IDIgOiAtMikpO1xuICAgICAgICAgICAgaWYgKCFmcm9tQ29vcmRzIHx8ICF0b0Nvb3JkcylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0b3AgPSBNYXRoLm1pbihmcm9tQ29vcmRzLnRvcCwgdG9Db29yZHMudG9wLCB0b3ApO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoZnJvbUNvb3Jkcy5ib3R0b20sIHRvQ29vcmRzLmJvdHRvbSwgYm90dG9tKTtcbiAgICAgICAgICAgIGlmIChkaXIgPT0gRGlyZWN0aW9uLkxUUilcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsLnB1c2gobHRyICYmIGZyb21PcGVuID8gbGVmdFNpZGUgOiBmcm9tQ29vcmRzLmxlZnQsIGx0ciAmJiB0b09wZW4gPyByaWdodFNpZGUgOiB0b0Nvb3Jkcy5yaWdodCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKCFsdHIgJiYgdG9PcGVuID8gbGVmdFNpZGUgOiB0b0Nvb3Jkcy5sZWZ0LCAhbHRyICYmIGZyb21PcGVuID8gcmlnaHRTaWRlIDogZnJvbUNvb3Jkcy5yaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogbGluZS5mcm9tLCBlbmQgPSB0byAhPT0gbnVsbCAmJiB0byAhPT0gdm9pZCAwID8gdG8gOiBsaW5lLnRvO1xuICAgICAgICAvLyBTcGxpdCB0aGUgcmFuZ2UgYnkgdmlzaWJsZSByYW5nZSBhbmQgZG9jdW1lbnQgbGluZVxuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcylcbiAgICAgICAgICAgIGlmIChyLnRvID4gc3RhcnQgJiYgci5mcm9tIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gTWF0aC5tYXgoci5mcm9tLCBzdGFydCksIGVuZFBvcyA9IE1hdGgubWluKHIudG8sIGVuZCk7Oykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9jTGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzcGFuIG9mIHZpZXcuYmlkaVNwYW5zKGRvY0xpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhbkZyb20gPSBzcGFuLmZyb20gKyBkb2NMaW5lLmZyb20sIHNwYW5UbyA9IHNwYW4udG8gKyBkb2NMaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhbkZyb20gPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5UbyA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTcGFuKE1hdGgubWF4KHNwYW5Gcm9tLCBwb3MpLCBmcm9tID09IG51bGwgJiYgc3BhbkZyb20gPD0gc3RhcnQsIE1hdGgubWluKHNwYW5UbywgZW5kUG9zKSwgdG8gPT0gbnVsbCAmJiBzcGFuVG8gPj0gZW5kLCBzcGFuLmRpcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9zID0gZG9jTGluZS50byArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaG9yaXpvbnRhbC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGFkZFNwYW4oc3RhcnQsIGZyb20gPT0gbnVsbCwgZW5kLCB0byA9PSBudWxsLCB2aWV3LnRleHREaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4geyB0b3AsIGJvdHRvbSwgaG9yaXpvbnRhbCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3Rm9yV2lkZ2V0KGJsb2NrLCB0b3ApIHtcbiAgICAgICAgbGV0IHkgPSBjb250ZW50UmVjdC50b3AgKyAodG9wID8gYmxvY2sudG9wIDogYmxvY2suYm90dG9tKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB5LCBib3R0b206IHksIGhvcml6b250YWw6IFtdIH07XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEuY29uc3RydWN0b3IgPT0gYi5jb25zdHJ1Y3RvciAmJiBhLmVxKGIpO1xufVxuY2xhc3MgTGF5ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBsYXllcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuZHJhd24gPSBbXTtcbiAgICAgICAgdGhpcy5zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLnNjYWxlWSA9IDE7XG4gICAgICAgIHRoaXMubWVhc3VyZVJlcSA9IHsgcmVhZDogdGhpcy5tZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLmRyYXcuYmluZCh0aGlzKSB9O1xuICAgICAgICB0aGlzLmRvbSA9IHZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGF5ZXJcIik7XG4gICAgICAgIGlmIChsYXllci5hYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1sYXllci1hYm92ZVwiKTtcbiAgICAgICAgaWYgKGxheWVyLmNsYXNzKVxuICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChsYXllci5jbGFzcyk7XG4gICAgICAgIHRoaXMuc2NhbGUoKTtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLnNldE9yZGVyKHZpZXcuc3RhdGUpO1xuICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIGlmIChsYXllci5tb3VudClcbiAgICAgICAgICAgIGxheWVyLm1vdW50KHRoaXMuZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGF5ZXJPcmRlcikgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxheWVyT3JkZXIpKVxuICAgICAgICAgICAgdGhpcy5zZXRPcmRlcih1cGRhdGUuc3RhdGUpO1xuICAgICAgICBpZiAodGhpcy5sYXllci51cGRhdGUodXBkYXRlLCB0aGlzLmRvbSkgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZSgpO1xuICAgICAgICAgICAgdXBkYXRlLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5tZWFzdXJlUmVxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRPcmRlcihzdGF0ZSkge1xuICAgICAgICBsZXQgcG9zID0gMCwgb3JkZXIgPSBzdGF0ZS5mYWNldChsYXllck9yZGVyKTtcbiAgICAgICAgd2hpbGUgKHBvcyA8IG9yZGVyLmxlbmd0aCAmJiBvcmRlcltwb3NdICE9IHRoaXMubGF5ZXIpXG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgdGhpcy5kb20uc3R5bGUuekluZGV4ID0gU3RyaW5nKCh0aGlzLmxheWVyLmFib3ZlID8gMTUwIDogLTEpIC0gcG9zKTtcbiAgICB9XG4gICAgbWVhc3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXIubWFya2Vycyh0aGlzLnZpZXcpO1xuICAgIH1cbiAgICBzY2FsZSgpIHtcbiAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgaWYgKHNjYWxlWCAhPSB0aGlzLnNjYWxlWCB8fCBzY2FsZVkgIT0gdGhpcy5zY2FsZVkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgdGhpcy5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHsxIC8gc2NhbGVYfSwgJHsxIC8gc2NhbGVZfSlgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXcobWFya2Vycykge1xuICAgICAgICBpZiAobWFya2Vycy5sZW5ndGggIT0gdGhpcy5kcmF3bi5sZW5ndGggfHwgbWFya2Vycy5zb21lKChwLCBpKSA9PiAhc2FtZU1hcmtlcihwLCB0aGlzLmRyYXduW2ldKSkpIHtcbiAgICAgICAgICAgIGxldCBvbGQgPSB0aGlzLmRvbS5maXJzdENoaWxkLCBvbGRJID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IG1hcmtlciBvZiBtYXJrZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci51cGRhdGUgJiYgb2xkICYmIG1hcmtlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmRyYXduW29sZEldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci51cGRhdGUob2xkLCB0aGlzLmRyYXduW29sZEldKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGQgPSBvbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9sZEkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIuZHJhdygpLCBvbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChvbGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG9sZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBvbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgb2xkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhd24gPSBtYXJrZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLmxheWVyLmRlc3Ryb3kodGhpcy5kb20sIHRoaXMudmlldyk7XG4gICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgIH1cbn1cbmNvbnN0IGxheWVyT3JkZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkRlZmluZSBhIGxheWVyLlxuKi9cbmZ1bmN0aW9uIGxheWVyKGNvbmZpZykge1xuICAgIHJldHVybiBbXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHYgPT4gbmV3IExheWVyVmlldyh2LCBjb25maWcpKSxcbiAgICAgICAgbGF5ZXJPcmRlci5vZihjb25maWcpXG4gICAgXTtcbn1cblxuY29uc3QgQ2FuSGlkZVByaW1hcnkgPSAhYnJvd3Nlci5pb3M7IC8vIEZJWE1FIHRlc3QgSUVcbmNvbnN0IHNlbGVjdGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IDEyMDAsXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAoYSwgYikgPT4gTWF0aC5taW4oYSwgYiksXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGJcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlkZXMgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2VsZWN0aW9uIGFuZFxuY3Vyc29yLCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGEgYmFja2dyb3VuZCBiZWhpbmQgdGhlIHRleHRcbih3aXRoIHRoZSBgY20tc2VsZWN0aW9uQmFja2dyb3VuZGAgY2xhc3MpLCBhbmQgdGhlXG5jdXJzb3JzIHdpdGggZWxlbWVudHMgb3ZlcmxhaWQgb3ZlciB0aGUgY29kZSAodXNpbmdcbmBjbS1jdXJzb3ItcHJpbWFyeWAgYW5kIGBjbS1jdXJzb3Itc2Vjb25kYXJ5YCkuXG5cblRoaXMgYWxsb3dzIHRoZSBlZGl0b3IgdG8gZGlzcGxheSBzZWNvbmRhcnkgc2VsZWN0aW9uIHJhbmdlcywgYW5kXG50ZW5kcyB0byBwcm9kdWNlIGEgdHlwZSBvZiBzZWxlY3Rpb24gbW9yZSBpbiBsaW5lIHdpdGggdGhhdCB1c2Vyc1xuZXhwZWN0IGluIGEgdGV4dCBlZGl0b3IgKHRoZSBuYXRpdmUgc2VsZWN0aW9uIHN0eWxpbmcgd2lsbCBvZnRlblxubGVhdmUgZ2FwcyBiZXR3ZWVuIGxpbmVzIGFuZCB3b24ndCBmaWxsIHRoZSBob3Jpem9udGFsIHNwYWNlIGFmdGVyXG5hIGxpbmUgd2hlbiB0aGUgc2VsZWN0aW9uIGNvbnRpbnVlcyBwYXN0IGl0KS5cblxuSXQgZG9lcyBoYXZlIGEgcGVyZm9ybWFuY2UgY29zdCwgaW4gdGhhdCBpdCByZXF1aXJlcyBhbiBleHRyYSBET01cbmxheW91dCBjeWNsZSBmb3IgbWFueSB1cGRhdGVzICh0aGUgc2VsZWN0aW9uIGlzIGRyYXduIGJhc2VkIG9uIERPTVxubGF5b3V0IGluZm9ybWF0aW9uIHRoYXQncyBvbmx5IGF2YWlsYWJsZSBhZnRlciBsYXlpbmcgb3V0IHRoZVxuY29udGVudCkuXG4qL1xuZnVuY3Rpb24gZHJhd1NlbGVjdGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjdXJzb3JMYXllcixcbiAgICAgICAgc2VsZWN0aW9uTGF5ZXIsXG4gICAgICAgIGhpZGVOYXRpdmVTZWxlY3Rpb24sXG4gICAgICAgIG5hdGl2ZVNlbGVjdGlvbkhpZGRlbi5vZih0cnVlKVxuICAgIF07XG59XG4vKipcblJldHJpZXZlIHRoZSBbYGRyYXdTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbikgY29uZmlndXJhdGlvblxuZm9yIHRoaXMgc3RhdGUuIChOb3RlIHRoYXQgdGhpcyB3aWxsIHJldHVybiBhIHNldCBvZiBkZWZhdWx0cyBldmVuXG5pZiBgZHJhd1NlbGVjdGlvbmAgaXNuJ3QgZW5hYmxlZC4pXG4qL1xuZnVuY3Rpb24gZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZyhzdGF0ZSkge1xuICAgIHJldHVybiBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xufVxuZnVuY3Rpb24gY29uZmlnQ2hhbmdlZCh1cGRhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbn1cbmNvbnN0IGN1cnNvckxheWVyID0gLypAX19QVVJFX18qL2xheWVyKHtcbiAgICBhYm92ZTogdHJ1ZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNvbmYgPSBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xuICAgICAgICBsZXQgY3Vyc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBwcmltID0gciA9PSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGlmIChyLmVtcHR5ID8gIXByaW0gfHwgQ2FuSGlkZVByaW1hcnkgOiBjb25mLmRyYXdSYW5nZUN1cnNvcikge1xuICAgICAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBwcmltID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIjtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yID0gci5lbXB0eSA/IHIgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHIuaGVhZCwgci5oZWFkID4gci5hbmNob3IgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBpZWNlIG9mIFJlY3RhbmdsZU1hcmtlci5mb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIGN1cnNvcikpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcnMucHVzaChwaWVjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcnM7XG4gICAgfSxcbiAgICB1cGRhdGUodXBkYXRlLCBkb20pIHtcbiAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPSBkb20uc3R5bGUuYW5pbWF0aW9uTmFtZSA9PSBcImNtLWJsaW5rXCIgPyBcImNtLWJsaW5rMlwiIDogXCJjbS1ibGlua1wiO1xuICAgICAgICBsZXQgY29uZkNoYW5nZSA9IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2UpXG4gICAgICAgICAgICBzZXRCbGlua1JhdGUodXBkYXRlLnN0YXRlLCBkb20pO1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCBjb25mQ2hhbmdlO1xuICAgIH0sXG4gICAgbW91bnQoZG9tLCB2aWV3KSB7XG4gICAgICAgIHNldEJsaW5rUmF0ZSh2aWV3LnN0YXRlLCBkb20pO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tY3Vyc29yTGF5ZXJcIlxufSk7XG5mdW5jdGlvbiBzZXRCbGlua1JhdGUoc3RhdGUsIGRvbSkge1xuICAgIGRvbS5zdHlsZS5hbmltYXRpb25EdXJhdGlvbiA9IHN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykuY3Vyc29yQmxpbmtSYXRlICsgXCJtc1wiO1xufVxuY29uc3Qgc2VsZWN0aW9uTGF5ZXIgPSAvKkBfX1BVUkVfXyovbGF5ZXIoe1xuICAgIGFib3ZlOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5tYXAociA9PiByLmVtcHR5ID8gW10gOiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgXCJjbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCIsIHIpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHwgY29uZmlnQ2hhbmdlZCh1cGRhdGUpO1xuICAgIH0sXG4gICAgY2xhc3M6IFwiY20tc2VsZWN0aW9uTGF5ZXJcIlxufSk7XG5jb25zdCB0aGVtZVNwZWMgPSB7XG4gICAgXCIuY20tbGluZVwiOiB7XG4gICAgICAgIFwiJiA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfSxcbiAgICAgICAgXCImOjpzZWxlY3Rpb25cIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiIH1cbiAgICB9XG59O1xuaWYgKENhbkhpZGVQcmltYXJ5KSB7XG4gICAgdGhlbWVTcGVjW1wiLmNtLWxpbmVcIl0uY2FyZXRDb2xvciA9IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiO1xuICAgIHRoZW1lU3BlY1tcIi5jbS1jb250ZW50XCJdID0geyBjYXJldENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9O1xufVxuY29uc3QgaGlkZU5hdGl2ZVNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL0VkaXRvclZpZXcudGhlbWUodGhlbWVTcGVjKSk7XG5cbmNvbnN0IHNldERyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAocG9zLCBtYXBwaW5nKSB7IHJldHVybiBwb3MgPT0gbnVsbCA/IG51bGwgOiBtYXBwaW5nLm1hcFBvcyhwb3MpOyB9XG59KTtcbmNvbnN0IGRyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHBvcywgdHIpIHtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcG9zID0gdHIuY2hhbmdlcy5tYXBQb3MocG9zKTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKChwb3MsIGUpID0+IGUuaXMoc2V0RHJvcEN1cnNvclBvcykgPyBlLnZhbHVlIDogcG9zLCBwb3MpO1xuICAgIH1cbn0pO1xuY29uc3QgZHJhd0Ryb3BDdXJzb3IgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3Q3Vyc29yLmJpbmQodGhpcykgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjdXJzb3JQb3MgPSB1cGRhdGUuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGlmIChjdXJzb3JQb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnNvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NOYW1lID0gXCJjbS1kcm9wQ3Vyc29yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gY3Vyc29yUG9zIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBvcyA9IHZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGxldCByZWN0ID0gcG9zICE9IG51bGwgJiYgdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAoIXJlY3QpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG91dGVyID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBvdXRlci5sZWZ0ICsgdmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCAqIHZpZXcuc2NhbGVYLFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG91dGVyLnRvcCArIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCAqIHZpZXcuc2NhbGVZLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRyYXdDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgbGV0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldztcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5oZWlnaHQgPSBwb3MuaGVpZ2h0IC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IFwiLTEwMDAwMHB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKVxuICAgICAgICAgICAgdGhpcy5jdXJzb3IucmVtb3ZlKCk7XG4gICAgfVxuICAgIHNldERyb3BQb3MocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gcG9zKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0RHJvcEN1cnNvclBvcy5vZihwb3MpIH0pO1xuICAgIH1cbn0sIHtcbiAgICBldmVudE9ic2VydmVyczoge1xuICAgICAgICBkcmFnb3ZlcihldmVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXREcm9wUG9zKHRoaXMudmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdGhpcy52aWV3LmNvbnRlbnRET00gfHwgIXRoaXMudmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJvcCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuLyoqXG5EcmF3cyBhIGN1cnNvciBhdCB0aGUgY3VycmVudCBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nIGlzXG5kcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cbiovXG5mdW5jdGlvbiBkcm9wQ3Vyc29yKCkge1xuICAgIHJldHVybiBbZHJvcEN1cnNvclBvcywgZHJhd0Ryb3BDdXJzb3JdO1xufVxuXG5mdW5jdGlvbiBpdGVyTWF0Y2hlcyhkb2MsIHJlLCBmcm9tLCB0bywgZikge1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY3Vyc29yID0gZG9jLml0ZXJSYW5nZShmcm9tLCB0byksIHBvcyA9IGZyb20sIG07ICFjdXJzb3IubmV4dCgpLmRvbmU7IHBvcyArPSBjdXJzb3IudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghY3Vyc29yLmxpbmVCcmVhaylcbiAgICAgICAgICAgIHdoaWxlIChtID0gcmUuZXhlYyhjdXJzb3IudmFsdWUpKVxuICAgICAgICAgICAgICAgIGYocG9zICsgbS5pbmRleCwgbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hSYW5nZXModmlldywgbWF4TGVuZ3RoKSB7XG4gICAgbGV0IHZpc2libGUgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKHZpc2libGUubGVuZ3RoID09IDEgJiYgdmlzaWJsZVswXS5mcm9tID09IHZpZXcudmlld3BvcnQuZnJvbSAmJlxuICAgICAgICB2aXNpYmxlWzBdLnRvID09IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgdmlzaWJsZSkge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgodmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLmZyb20sIGZyb20gLSBtYXhMZW5ndGgpO1xuICAgICAgICB0byA9IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh0bykudG8sIHRvICsgbWF4TGVuZ3RoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA+PSBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA9IHRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IZWxwZXIgY2xhc3MgdXNlZCB0byBtYWtlIGl0IGVhc2llciB0byBtYWludGFpbiBkZWNvcmF0aW9ucyBvblxudmlzaWJsZSBjb2RlIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVG8gYmUgdXNlZFxuaW4gYSBbdmlldyBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKS4gSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0XG5yZXByZXNlbnQgYSBtYXRjaGluZyBjb25maWd1cmF0aW9uLlxuKi9cbmNsYXNzIE1hdGNoRGVjb3JhdG9yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBkZWNvcmF0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyByZWdleHAsIGRlY29yYXRpb24sIGRlY29yYXRlLCBib3VuZGFyeSwgbWF4TGVuZ3RoID0gMTAwMCB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoIXJlZ2V4cC5nbG9iYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2l2ZW4gdG8gTWF0Y2hEZWNvcmF0b3Igc2hvdWxkIGhhdmUgaXRzICdnJyBmbGFnIHNldFwiKTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSByZWdleHA7XG4gICAgICAgIGlmIChkZWNvcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgdmlldywgZnJvbSwgYWRkKSA9PiBkZWNvcmF0ZShhZGQsIGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIG1hdGNoLCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVjb3JhdGlvbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkZWNvID0gZGVjb3JhdGlvbihtYXRjaCwgdmlldywgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28pXG4gICAgICAgICAgICAgICAgICAgIGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXRjaCA9IChtYXRjaCwgX3ZpZXcsIGZyb20sIGFkZCkgPT4gYWRkKGZyb20sIGZyb20gKyBtYXRjaFswXS5sZW5ndGgsIGRlY29yYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFaXRoZXIgJ2RlY29yYXRlJyBvciAnZGVjb3JhdGlvbicgc2hvdWxkIGJlIHByb3ZpZGVkIHRvIE1hdGNoRGVjb3JhdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeTtcbiAgICAgICAgdGhpcy5tYXhMZW5ndGggPSBtYXhMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGZ1bGwgc2V0IG9mIGRlY29yYXRpb25zIGZvciBtYXRjaGVzIGluIHRoZSBnaXZlblxuICAgIHZpZXcncyB2aWV3cG9ydC4gWW91J2xsIHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXJcbiAgICBwbHVnaW4uXG4gICAgKi9cbiAgICBjcmVhdGVEZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpLCBhZGQgPSBidWlsZC5hZGQuYmluZChidWlsZCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtYXRjaFJhbmdlcyh2aWV3LCB0aGlzLm1heExlbmd0aCkpXG4gICAgICAgICAgICBpdGVyTWF0Y2hlcyh2aWV3LnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIGZyb20sIHRvLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgYSBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIGEgdmlldyB1cGRhdGUuIGBkZWNvYCBfbXVzdF8gYmVcbiAgICB0aGUgc2V0IG9mIGRlY29yYXRpb25zIHByb2R1Y2VkIGJ5IF90aGlzXyBgTWF0Y2hEZWNvcmF0b3JgIGZvclxuICAgIHRoZSB2aWV3IHN0YXRlIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICovXG4gICAgdXBkYXRlRGVjbyh1cGRhdGUsIGRlY28pIHtcbiAgICAgICAgbGV0IGNoYW5nZUZyb20gPSAxZTksIGNoYW5nZVRvID0gLTE7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChfZiwgX3QsIGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gdXBkYXRlLnZpZXcudmlld3BvcnQuZnJvbSAmJiBmcm9tIDwgdXBkYXRlLnZpZXcudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRnJvbSA9IE1hdGgubWluKGZyb20sIGNoYW5nZUZyb20pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUbyA9IE1hdGgubWF4KHRvLCBjaGFuZ2VUbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNoYW5nZVRvIC0gY2hhbmdlRnJvbSA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgaWYgKGNoYW5nZVRvID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSYW5nZSh1cGRhdGUudmlldywgZGVjby5tYXAodXBkYXRlLmNoYW5nZXMpLCBjaGFuZ2VGcm9tLCBjaGFuZ2VUbyk7XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbiAgICB1cGRhdGVSYW5nZSh2aWV3LCBkZWNvLCB1cGRhdGVGcm9tLCB1cGRhdGVUbykge1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChyLmZyb20sIHVwZGF0ZUZyb20pLCB0byA9IE1hdGgubWluKHIudG8sIHVwZGF0ZVRvKTtcbiAgICAgICAgICAgIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbUxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIHRvTGluZSA9IGZyb21MaW5lLnRvIDwgdG8gPyB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pIDogZnJvbUxpbmU7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoci5mcm9tLCBmcm9tTGluZS5mcm9tKSwgZW5kID0gTWF0aC5taW4oci50bywgdG9MaW5lLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZnJvbSA+IGZyb21MaW5lLmZyb207IGZyb20tLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QoZnJvbUxpbmUudGV4dFtmcm9tIC0gMSAtIGZyb21MaW5lLmZyb21dKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHRvIDwgdG9MaW5lLnRvOyB0bysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkudGVzdCh0b0xpbmUudGV4dFt0byAtIHRvTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdLCBtO1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSAoZnJvbSwgdG8sIGRlY28pID0+IHJhbmdlcy5wdXNoKGRlY28ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUxpbmUgPT0gdG9MaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0IC0gZnJvbUxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtID0gdGhpcy5yZWdleHAuZXhlYyhmcm9tTGluZS50ZXh0KSkgJiYgbS5pbmRleCA8IGVuZCAtIGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1hdGNoKG0sIHZpZXcsIG0uaW5kZXggKyBmcm9tTGluZS5mcm9tLCBhZGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBzdGFydCwgZW5kLCAoZnJvbSwgbSkgPT4gdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBmcm9tLCBhZGQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbyA9IGRlY28udXBkYXRlKHsgZmlsdGVyRnJvbTogc3RhcnQsIGZpbHRlclRvOiBlbmQsIGZpbHRlcjogKGZyb20sIHRvKSA9PiBmcm9tIDwgc3RhcnQgfHwgdG8gPiBlbmQsIGFkZDogcmFuZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbn1cblxuY29uc3QgVW5pY29kZVJlZ2V4cFN1cHBvcnQgPSAveC8udW5pY29kZSAhPSBudWxsID8gXCJndVwiIDogXCJnXCI7XG5jb25zdCBTcGVjaWFscyA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcdTAwMDAtXFx1MDAwOFxcdTAwMGEtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYlxcdTIwMGVcXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHUyMDJkXFx1MjAyZVxcdTIwNjZcXHUyMDY3XFx1MjA2OVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdXCIsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbmNvbnN0IE5hbWVzID0ge1xuICAgIDA6IFwibnVsbFwiLFxuICAgIDc6IFwiYmVsbFwiLFxuICAgIDg6IFwiYmFja3NwYWNlXCIsXG4gICAgMTA6IFwibmV3bGluZVwiLFxuICAgIDExOiBcInZlcnRpY2FsIHRhYlwiLFxuICAgIDEzOiBcImNhcnJpYWdlIHJldHVyblwiLFxuICAgIDI3OiBcImVzY2FwZVwiLFxuICAgIDgyMDM6IFwiemVybyB3aWR0aCBzcGFjZVwiLFxuICAgIDgyMDQ6IFwiemVybyB3aWR0aCBub24tam9pbmVyXCIsXG4gICAgODIwNTogXCJ6ZXJvIHdpZHRoIGpvaW5lclwiLFxuICAgIDgyMDY6IFwibGVmdC10by1yaWdodCBtYXJrXCIsXG4gICAgODIwNzogXCJyaWdodC10by1sZWZ0IG1hcmtcIixcbiAgICA4MjMyOiBcImxpbmUgc2VwYXJhdG9yXCIsXG4gICAgODIzNzogXCJsZWZ0LXRvLXJpZ2h0IG92ZXJyaWRlXCIsXG4gICAgODIzODogXCJyaWdodC10by1sZWZ0IG92ZXJyaWRlXCIsXG4gICAgODI5NDogXCJsZWZ0LXRvLXJpZ2h0IGlzb2xhdGVcIixcbiAgICA4Mjk1OiBcInJpZ2h0LXRvLWxlZnQgaXNvbGF0ZVwiLFxuICAgIDgyOTc6IFwicG9wIGRpcmVjdGlvbmFsIGlzb2xhdGVcIixcbiAgICA4MjMzOiBcInBhcmFncmFwaCBzZXBhcmF0b3JcIixcbiAgICA2NTI3OTogXCJ6ZXJvIHdpZHRoIG5vLWJyZWFrIHNwYWNlXCIsXG4gICAgNjU1MzI6IFwib2JqZWN0IHJlcGxhY2VtZW50XCJcbn07XG5sZXQgX3N1cHBvcnRzVGFiU2l6ZSA9IG51bGw7XG5mdW5jdGlvbiBzdXBwb3J0c1RhYlNpemUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChfc3VwcG9ydHNUYWJTaXplID09IG51bGwgJiYgdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgICAgICBsZXQgc3R5bGVzID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgX3N1cHBvcnRzVGFiU2l6ZSA9ICgoX2EgPSBzdHlsZXMudGFiU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc3R5bGVzLk1velRhYlNpemUpICE9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBfc3VwcG9ydHNUYWJTaXplIHx8IGZhbHNlO1xufVxuY29uc3Qgc3BlY2lhbENoYXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgcmVuZGVyOiBudWxsLFxuICAgICAgICAgICAgc3BlY2lhbENoYXJzOiBTcGVjaWFscyxcbiAgICAgICAgICAgIGFkZFNwZWNpYWxDaGFyczogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5yZXBsYWNlVGFicyA9ICFzdXBwb3J0c1RhYlNpemUoKSlcbiAgICAgICAgICAgIGNvbmZpZy5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKFwiXFx0fFwiICsgY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgaWYgKGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChjb25maWcuc3BlY2lhbENoYXJzLnNvdXJjZSArIFwifFwiICsgY29uZmlnLmFkZFNwZWNpYWxDaGFycy5zb3VyY2UsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBpbnN0YWxscyBoaWdobGlnaHRpbmcgb2Ygc3BlY2lhbFxuY2hhcmFjdGVycy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTcGVjaWFsQ2hhcnMoXG4vKipcbkNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiovXG5jb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbc3BlY2lhbENoYXJDb25maWcub2YoY29uZmlnKSwgc3BlY2lhbENoYXJQbHVnaW4oKV07XG59XG5sZXQgX3BsdWdpbiA9IG51bGw7XG5mdW5jdGlvbiBzcGVjaWFsQ2hhclBsdWdpbigpIHtcbiAgICByZXR1cm4gX3BsdWdpbiB8fCAoX3BsdWdpbiA9IFZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICAgICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRvciA9IHRoaXMubWFrZURlY29yYXRvcih2aWV3LnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlRGVjb3JhdG9yKGNvbmYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgICAgICAgICAgICAgIHJlZ2V4cDogY29uZi5zcGVjaWFsQ2hhcnMsXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogKG0sIHZpZXcsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBkb2MgfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29kZVBvaW50QXQobVswXSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSB2aWV3LnN0YXRlLnRhYlNpemUsIGNvbCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgc2l6ZSwgcG9zIC0gbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldDogbmV3IFRhYldpZGdldCgoc2l6ZSAtIChjb2wgJSBzaXplKSkgKiB0aGlzLnZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoIC8gdGhpcy52aWV3LnNjYWxlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdID0gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgU3BlY2lhbENoYXJXaWRnZXQoY29uZiwgY29kZSkgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmRhcnk6IGNvbmYucmVwbGFjZVRhYnMgPyB1bmRlZmluZWQgOiAvW15dL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSAhPSBjb25mKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3IoY29uZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLnVwZGF0ZURlY28odXBkYXRlLCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pKTtcbn1cbmNvbnN0IERlZmF1bHRQbGFjZWhvbGRlciA9IFwiXFx1MjAyMlwiO1xuLy8gQXNzaWducyBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzIGZyb20gdGhlIENvbnRyb2wgUGljdHVyZXMgYmxvY2sgdG9cbi8vIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyc1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIkMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPj0gMzIpXG4gICAgICAgIHJldHVybiBEZWZhdWx0UGxhY2Vob2xkZXI7XG4gICAgaWYgKGNvZGUgPT0gMTApXG4gICAgICAgIHJldHVybiBcIlxcdTI0MjRcIjtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5MjE2ICsgY29kZSk7XG59XG5jbGFzcyBTcGVjaWFsQ2hhcldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvZGUgPT0gdGhpcy5jb2RlOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgcGggPSBwbGFjZWhvbGRlciQxKHRoaXMuY29kZSk7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5zdGF0ZS5waHJhc2UoXCJDb250cm9sIGNoYXJhY3RlclwiKSArIFwiIFwiICsgKE5hbWVzW3RoaXMuY29kZV0gfHwgXCIweFwiICsgdGhpcy5jb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLm9wdGlvbnMucmVuZGVyICYmIHRoaXMub3B0aW9ucy5yZW5kZXIodGhpcy5jb2RlLCBkZXNjLCBwaCk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gcGg7XG4gICAgICAgIHNwYW4udGl0bGUgPSBkZXNjO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGVzYyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zcGVjaWFsQ2hhclwiO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuY2xhc3MgVGFiV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIud2lkdGggPT0gdGhpcy53aWR0aDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJcXHRcIjtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXRhYlwiO1xuICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuY29uc3QgcGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDAwO1xuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB1cGRhdGU7XG4gICAgICAgIGxldCBoZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5lZGl0b3JIZWlnaHQgKiB2aWV3LnNjYWxlWSAtXG4gICAgICAgICAgICB2aWV3LmRlZmF1bHRMaW5lSGVpZ2h0IC0gdmlldy5kb2N1bWVudFBhZGRpbmcudG9wIC0gMC41O1xuICAgICAgICBpZiAoaGVpZ2h0ID49IDAgJiYgaGVpZ2h0ICE9IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSB7IHN0eWxlOiBgcGFkZGluZy1ib3R0b206ICR7aGVpZ2h0fXB4YCB9O1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgbWFrZXMgc3VyZSB0aGUgY29udGVudCBoYXMgYSBib3R0b21cbm1hcmdpbiBlcXVpdmFsZW50IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGVkaXRvciwgbWludXMgb25lIGxpbmVcbmhlaWdodCwgc28gdGhhdCBldmVyeSBsaW5lIGluIHRoZSBkb2N1bWVudCBjYW4gYmUgc2Nyb2xsZWQgdG8gdGhlXG50b3Agb2YgdGhlIGVkaXRvci5cblxuVGhpcyBpcyBvbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGFibGUsIGFuZCBzaG91bGRcbm5vdCBiZSBlbmFibGVkIGluIGVkaXRvcnMgdGhhdCB0YWtlIHRoZSBzaXplIG9mIHRoZWlyIGNvbnRlbnQuXG4qL1xuZnVuY3Rpb24gc2Nyb2xsUGFzdEVuZCgpIHtcbiAgICByZXR1cm4gW3BsdWdpbiwgY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnMpIHx8IG51bGw7IH0pXTtcbn1cblxuLyoqXG5NYXJrIGxpbmVzIHRoYXQgaGF2ZSBhIGN1cnNvciBvbiB0aGVtIHdpdGggdGhlIGBcImNtLWFjdGl2ZUxpbmVcImBcbkRPTSBjbGFzcy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXI7XG59XG5jb25zdCBsaW5lRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLmxpbmUoeyBjbGFzczogXCJjbS1hY3RpdmVMaW5lXCIgfSk7XG5jb25zdCBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odXBkYXRlLnZpZXcpO1xuICAgIH1cbiAgICBnZXREZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lU3RhcnQgPSAtMSwgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KHIuaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID4gbGFzdExpbmVTdGFydCkge1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChsaW5lRGVjby5yYW5nZShsaW5lLmZyb20pKTtcbiAgICAgICAgICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5cbmNsYXNzIFBsYWNlaG9sZGVyIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoY29udGVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXBsYWNlaG9sZGVyXCI7XG4gICAgICAgIHdyYXAuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCkgOiB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwicGxhY2Vob2xkZXIgXCIgKyB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgfVxuICAgIGNvb3Jkc0F0KGRvbSkge1xuICAgICAgICBsZXQgcmVjdHMgPSBkb20uZmlyc3RDaGlsZCA/IGNsaWVudFJlY3RzRm9yKGRvbS5maXJzdENoaWxkKSA6IFtdO1xuICAgICAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20ucGFyZW50Tm9kZSk7XG4gICAgICAgIGxldCByZWN0ID0gZmxhdHRlblJlY3QocmVjdHNbMF0sIHN0eWxlLmRpcmVjdGlvbiAhPSBcInJ0bFwiKTtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSBwYXJzZUludChzdHlsZS5saW5lSGVpZ2h0KTtcbiAgICAgICAgaWYgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBsaW5lSGVpZ2h0ICogMS41KVxuICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGxpbmVIZWlnaHQgfTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhIHBsYWNlaG9sZGVy4oCUYSBwaWVjZSBvZiBleGFtcGxlIGNvbnRlbnRcbnRvIHNob3cgd2hlbiB0aGUgZWRpdG9yIGlzIGVtcHR5LlxuKi9cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICA/IERlY29yYXRpb24uc2V0KFtEZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IFBsYWNlaG9sZGVyKGNvbnRlbnQpLCBzaWRlOiAxIH0pLnJhbmdlKDApXSlcbiAgICAgICAgICAgICAgICA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVjb3JhdGlvbnMoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IERlY29yYXRpb24ubm9uZSA6IHRoaXMucGxhY2Vob2xkZXI7IH1cbiAgICB9LCB7IGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnMgfSk7XG59XG5cbi8vIERvbid0IGNvbXB1dGUgcHJlY2lzZSBjb2x1bW4gcG9zaXRpb25zIGZvciBsaW5lIG9mZnNldHMgYWJvdmUgdGhpc1xuLy8gKHNpbmNlIGl0IGNvdWxkIGdldCBleHBlbnNpdmUpLiBBc3N1bWUgb2Zmc2V0PT1jb2x1bW4gZm9yIHRoZW0uXG5jb25zdCBNYXhPZmYgPSAyMDAwO1xuZnVuY3Rpb24gcmVjdGFuZ2xlRm9yKHN0YXRlLCBhLCBiKSB7XG4gICAgbGV0IHN0YXJ0TGluZSA9IE1hdGgubWluKGEubGluZSwgYi5saW5lKSwgZW5kTGluZSA9IE1hdGgubWF4KGEubGluZSwgYi5saW5lKTtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgaWYgKGEub2ZmID4gTWF4T2ZmIHx8IGIub2ZmID4gTWF4T2ZmIHx8IGEuY29sIDwgMCB8fCBiLmNvbCA8IDApIHtcbiAgICAgICAgbGV0IHN0YXJ0T2ZmID0gTWF0aC5taW4oYS5vZmYsIGIub2ZmKSwgZW5kT2ZmID0gTWF0aC5tYXgoYS5vZmYsIGIub2ZmKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPD0gZW5kT2ZmKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydE9mZiwgbGluZS50byArIGVuZE9mZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc3RhcnRDb2wgPSBNYXRoLm1pbihhLmNvbCwgYi5jb2wpLCBlbmRDb2wgPSBNYXRoLm1heChhLmNvbCwgYi5jb2wpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZShpKTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBzdGFydENvbCwgc3RhdGUudGFiU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gZmluZENvbHVtbihsaW5lLnRleHQsIGVuZENvbCwgc3RhdGUudGFiU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGxpbmUuZnJvbSArIHN0YXJ0LCBsaW5lLmZyb20gKyBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuZnVuY3Rpb24gYWJzb2x1dGVDb2x1bW4odmlldywgeCkge1xuICAgIGxldCByZWYgPSB2aWV3LmNvb3Jkc0F0UG9zKHZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgcmV0dXJuIHJlZiA/IE1hdGgucm91bmQoTWF0aC5hYnMoKHJlZi5sZWZ0IC0geCkgLyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCkpIDogLTE7XG59XG5mdW5jdGlvbiBnZXRQb3ModmlldywgZXZlbnQpIHtcbiAgICBsZXQgb2Zmc2V0ID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KG9mZnNldCksIG9mZiA9IG9mZnNldCAtIGxpbmUuZnJvbTtcbiAgICBsZXQgY29sID0gb2ZmID4gTWF4T2ZmID8gLTFcbiAgICAgICAgOiBvZmYgPT0gbGluZS5sZW5ndGggPyBhYnNvbHV0ZUNvbHVtbih2aWV3LCBldmVudC5jbGllbnRYKVxuICAgICAgICAgICAgOiBjb3VudENvbHVtbihsaW5lLnRleHQsIHZpZXcuc3RhdGUudGFiU2l6ZSwgb2Zmc2V0IC0gbGluZS5mcm9tKTtcbiAgICByZXR1cm4geyBsaW5lOiBsaW5lLm51bWJlciwgY29sLCBvZmYgfTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZVNlbGVjdGlvblN0eWxlKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gZ2V0UG9zKHZpZXcsIGV2ZW50KSwgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoIXN0YXJ0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3U3RhcnQgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmUoc3RhcnQubGluZSkuZnJvbSk7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0xpbmUgPSB1cGRhdGUuc3RhdGUuZG9jLmxpbmVBdChuZXdTdGFydCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB7IGxpbmU6IG5ld0xpbmUubnVtYmVyLCBjb2w6IHN0YXJ0LmNvbCwgb2ZmOiBNYXRoLm1pbihzdGFydC5vZmYsIG5ld0xpbmUubGVuZ3RoKSB9O1xuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBfZXh0ZW5kLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGdldFBvcyh2aWV3LCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIWN1cilcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gcmVjdGFuZ2xlRm9yKHZpZXcuc3RhdGUsIHN0YXJ0LCBjdXIpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMuY29uY2F0KHN0YXJ0U2VsLnJhbmdlcykpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyByZWN0YW5ndWxhciBzZWxlY3Rpb25zLiBCeVxuZGVmYXVsdCwgaXQgd2lsbCByZWFjdCB0byBsZWZ0IG1vdXNlIGRyYWcgd2l0aCB0aGUgQWx0IGtleSBoZWxkXG5kb3duLiBXaGVuIHN1Y2ggYSBzZWxlY3Rpb24gb2NjdXJzLCB0aGUgdGV4dCB3aXRoaW4gdGhlIHJlY3RhbmdsZVxudGhhdCB3YXMgZHJhZ2dlZCBvdmVyIHdpbGwgYmUgc2VsZWN0ZWQsIGFzIG9uZSBzZWxlY3Rpb25cbltyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZSkgcGVyIGxpbmUuXG4qL1xuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTZWxlY3Rpb24ob3B0aW9ucykge1xuICAgIGxldCBmaWx0ZXIgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV2ZW50RmlsdGVyKSB8fCAoZSA9PiBlLmFsdEtleSAmJiBlLmJ1dHRvbiA9PSAwKTtcbiAgICByZXR1cm4gRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlLm9mKCh2aWV3LCBldmVudCkgPT4gZmlsdGVyKGV2ZW50KSA/IHJlY3RhbmdsZVNlbGVjdGlvblN0eWxlKHZpZXcsIGV2ZW50KSA6IG51bGwpO1xufVxuY29uc3Qga2V5cyA9IHtcbiAgICBBbHQ6IFsxOCwgZSA9PiAhIWUuYWx0S2V5XSxcbiAgICBDb250cm9sOiBbMTcsIGUgPT4gISFlLmN0cmxLZXldLFxuICAgIFNoaWZ0OiBbMTYsIGUgPT4gISFlLnNoaWZ0S2V5XSxcbiAgICBNZXRhOiBbOTEsIGUgPT4gISFlLm1ldGFLZXldXG59O1xuY29uc3Qgc2hvd0Nyb3NzaGFpciA9IHsgc3R5bGU6IFwiY3Vyc29yOiBjcm9zc2hhaXJcIiB9O1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IHR1cm5zIHRoZSBwb2ludGVyIGN1cnNvciBpbnRvIGFcbmNyb3NzaGFpciB3aGVuIGEgZ2l2ZW4gbW9kaWZpZXIga2V5LCBkZWZhdWx0aW5nIHRvIEFsdCwgaXMgaGVsZFxuZG93bi4gQ2FuIHNlcnZlIGFzIGEgdmlzdWFsIGhpbnQgdGhhdCByZWN0YW5ndWxhciBzZWxlY3Rpb24gaXNcbmdvaW5nIHRvIGhhcHBlbiB3aGVuIHBhaXJlZCB3aXRoXG5bYHJlY3Rhbmd1bGFyU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LnJlY3Rhbmd1bGFyU2VsZWN0aW9uKS5cbiovXG5mdW5jdGlvbiBjcm9zc2hhaXJDdXJzb3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IFtjb2RlLCBnZXR0ZXJdID0ga2V5c1tvcHRpb25zLmtleSB8fCBcIkFsdFwiXTtcbiAgICBsZXQgcGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQoaXNEb3duKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rvd24gIT0gaXNEb3duKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rvd24gPSBpc0Rvd247XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgICAgICBrZXlkb3duKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChlLmtleUNvZGUgPT0gY29kZSB8fCBnZXR0ZXIoZSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleXVwKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IGNvZGUgfHwgIWdldHRlcihlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlbW92ZShlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBsdWdpbixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih2aWV3ID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Rvd24pID8gc2hvd0Nyb3NzaGFpciA6IG51bGw7IH0pXG4gICAgXTtcbn1cblxuY29uc3QgT3V0c2lkZSA9IFwiLTEwMDAwcHhcIjtcbmNsYXNzIFRvb2x0aXBWaWV3TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodmlldywgZmFjZXQsIGNyZWF0ZVRvb2x0aXBWaWV3LCByZW1vdmVUb29sdGlwVmlldykge1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcgPSBjcmVhdGVUb29sdGlwVmlldztcbiAgICAgICAgdGhpcy5yZW1vdmVUb29sdGlwVmlldyA9IHJlbW92ZVRvb2x0aXBWaWV3O1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0aGlzLmlucHV0LmZpbHRlcih0ID0+IHQpO1xuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdGhpcy50b29sdGlwcy5tYXAodCA9PiBwcmV2ID0gY3JlYXRlVG9vbHRpcFZpZXcodCwgcHJldikpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlLCBhYm92ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0aGlzLmZhY2V0KTtcbiAgICAgICAgbGV0IHRvb2x0aXBzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICBpZiAodC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHQudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvb2x0aXBWaWV3cyA9IFtdLCBuZXdBYm92ZSA9IGFib3ZlID8gW10gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGlwID0gdG9vbHRpcHNbaV0sIGtub3duID0gLTE7XG4gICAgICAgICAgICBpZiAoIXRpcClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IHRoaXMudG9vbHRpcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyICYmIG90aGVyLmNyZWF0ZSA9PSB0aXAuY3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICBrbm93biA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcFZpZXdzW2ldID0gdGhpcy5jcmVhdGVUb29sdGlwVmlldyh0aXAsIGkgPyB0b29sdGlwVmlld3NbaSAtIDFdIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Fib3ZlKVxuICAgICAgICAgICAgICAgICAgICBuZXdBYm92ZVtpXSA9ICEhdGlwLmFib3ZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcFZpZXdzW2ldID0gdGhpcy50b29sdGlwVmlld3Nba25vd25dO1xuICAgICAgICAgICAgICAgIGlmIChuZXdBYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgbmV3QWJvdmVbaV0gPSBhYm92ZVtrbm93bl07XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcFZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgIGlmICh0b29sdGlwVmlld3MuaW5kZXhPZih0KSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRvb2x0aXBWaWV3KHQpO1xuICAgICAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChhYm92ZSkge1xuICAgICAgICAgICAgbmV3QWJvdmUuZm9yRWFjaCgodmFsLCBpKSA9PiBhYm92ZVtpXSA9IHZhbCk7XG4gICAgICAgICAgICBhYm92ZS5sZW5ndGggPSBuZXdBYm92ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdG9vbHRpcFZpZXdzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbkNyZWF0ZXMgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyB0b29sdGlwIGJlaGF2aW9yLlxuKi9cbmZ1bmN0aW9uIHRvb2x0aXBzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRvb2x0aXBDb25maWcub2YoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1NwYWNlKHZpZXcpIHtcbiAgICBsZXQgeyB3aW4gfSA9IHZpZXc7XG4gICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCwgcmlnaHQ6IHdpbi5pbm5lcldpZHRoIH07XG59XG5jb25zdCB0b29sdGlwQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgcG9zaXRpb246IGJyb3dzZXIuaW9zID8gXCJhYnNvbHV0ZVwiIDogKChfYSA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi5wb3NpdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3NpdGlvbikgfHwgXCJmaXhlZFwiLFxuICAgICAgICAgICAgcGFyZW50OiAoKF9iID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBhcmVudCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJlbnQpIHx8IG51bGwsXG4gICAgICAgICAgICB0b29sdGlwU3BhY2U6ICgoX2MgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYudG9vbHRpcFNwYWNlKSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvb2x0aXBTcGFjZSkgfHwgd2luZG93U3BhY2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3Qga25vd25IZWlnaHQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRvb2x0aXBQbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5hYm92ZSA9IFtdO1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMubWFkZUFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gMDtcbiAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGNvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBjb25maWcucGFyZW50O1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSB2aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRNZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLndyaXRlTWVhc3VyZS5iaW5kKHRoaXMpLCBrZXk6IHRoaXMgfTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy5tZWFzdXJlU29vbigpKSA6IG51bGw7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd1Rvb2x0aXAsICh0LCBwKSA9PiB0aGlzLmNyZWF0ZVRvb2x0aXAodCwgcCksIHQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodC5kb20pO1xuICAgICAgICAgICAgdC5kb20ucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFib3ZlID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCh0ID0+ICEhdC5hYm92ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiID8gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiB0aGlzLmxhc3RUcmFuc2FjdGlvbiAtIDUwICYmXG4gICAgICAgICAgICAgICAgZW50cmllcy5sZW5ndGggPiAwICYmIGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXS5pbnRlcnNlY3Rpb25SYXRpbyA8IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5tZWFzdXJlU29vbigpO1xuICAgICAgICB9LCB7IHRocmVzaG9sZDogWzFdIH0pIDogbnVsbDtcbiAgICAgICAgdGhpcy5vYnNlcnZlSW50ZXJzZWN0aW9uKCk7XG4gICAgICAgIHZpZXcud2luLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5tZWFzdXJlU29vbiA9IHRoaXMubWVhc3VyZVNvb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMudmlldy50aGVtZUNsYXNzZXM7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMudmlldy5kb207XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JzZXJ2ZUludGVyc2VjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0b29sdGlwLmRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVNvb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUsIHRoaXMuYWJvdmUpO1xuICAgICAgICBpZiAodXBkYXRlZClcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpO1xuICAgICAgICBsZXQgc2hvdWxkTWVhc3VyZSA9IHVwZGF0ZWQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZDtcbiAgICAgICAgbGV0IG5ld0NvbmZpZyA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0b29sdGlwQ29uZmlnKTtcbiAgICAgICAgaWYgKG5ld0NvbmZpZy5wb3NpdGlvbiAhPSB0aGlzLnBvc2l0aW9uICYmICF0aGlzLm1hZGVBYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ld0NvbmZpZy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3Q29uZmlnLnBhcmVudCAhPSB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBuZXdDb25maWcucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0LmRvbSk7XG4gICAgICAgICAgICBzaG91bGRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnZpZXcudGhlbWVDbGFzc2VzICE9IHRoaXMuY2xhc3Nlcykge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkTWVhc3VyZSlcbiAgICAgICAgICAgIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAodG9vbHRpcCwgcHJldikge1xuICAgICAgICBsZXQgdG9vbHRpcFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBsZXQgYmVmb3JlID0gcHJldiA/IHByZXYuZG9tIDogbnVsbDtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwXCIpO1xuICAgICAgICBpZiAodG9vbHRpcC5hcnJvdyAmJiAhdG9vbHRpcFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcCA+IC5jbS10b29sdGlwLWFycm93XCIpKSB7XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgYXJyb3cuY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWFycm93XCI7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20uaW5zZXJ0QmVmb3JlKGFycm93LCBiZWZvcmUpO1xuICAgICAgICB9XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZSh0b29sdGlwVmlldy5kb20sIGJlZm9yZSk7XG4gICAgICAgIGlmICh0b29sdGlwVmlldy5tb3VudClcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRvb2x0aXBWaWV3LmRvbSk7XG4gICAgICAgIHJldHVybiB0b29sdGlwVmlldztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMudmlldy53aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uKTtcbiAgICAgICAgZm9yIChsZXQgdG9vbHRpcFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgKF9hID0gdG9vbHRpcFZpZXcuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodG9vbHRpcFZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICAoX2IgPSB0aGlzLnJlc2l6ZU9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2MgPSB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzY29ubmVjdCgpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tZWFzdXJlVGltZW91dCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlKCkge1xuICAgICAgICBsZXQgZWRpdG9yID0gdGhpcy52aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNjYWxlWCA9IDEsIHNjYWxlWSA9IDEsIG1ha2VBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImZpeGVkXCIgJiYgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IGRvbSB9ID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1swXTtcbiAgICAgICAgICAgIGlmIChicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzZXRzIHRoZSBlbGVtZW50J3MgYG9mZnNldFBhcmVudGAgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtZWQgZWxlbWVudCB3aGVuIGEgdHJhbnNmb3JtIGludGVyZmVyZXMgd2l0aCBmaXhlZFxuICAgICAgICAgICAgICAgIC8vIHBvc2l0aW9uaW5nLlxuICAgICAgICAgICAgICAgIG1ha2VBYnNvbHV0ZSA9IGRvbS5vZmZzZXRQYXJlbnQgIT0gdGhpcy5jb250YWluZXIub3duZXJEb2N1bWVudC5ib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLnN0eWxlLnRvcCA9PSBPdXRzaWRlICYmIGRvbS5zdHlsZS5sZWZ0ID09IFwiMHB4XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBvdGhlciBicm93c2Vycywgd2UgaGF2ZSB0byBhd2t3YXJkbHkgdHJ5IGFuZCB1c2Ugb3RoZXJcbiAgICAgICAgICAgICAgICAvLyBpbmZvcm1hdGlvbiB0byBkZXRlY3QgYSB0cmFuc2Zvcm0uXG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbWFrZUFic29sdXRlID0gTWF0aC5hYnMocmVjdC50b3AgKyAxMDAwMCkgPiAxIHx8IE1hdGguYWJzKHJlY3QubGVmdCkgPiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYWtlQWJzb2x1dGUgfHwgdGhpcy5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdGhpcy5wYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVYID0gcmVjdC53aWR0aCAvIHRoaXMucGFyZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVkgPSByZWN0LmhlaWdodCAvIHRoaXMucGFyZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoeyBzY2FsZVgsIHNjYWxlWSB9ID0gdGhpcy52aWV3LnZpZXdTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQgPyB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IGVkaXRvcixcbiAgICAgICAgICAgIHBvczogdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCgodCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0diA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR2LmdldENvb3JkcyA/IHR2LmdldENvb3Jkcyh0LnBvcykgOiB0aGlzLnZpZXcuY29vcmRzQXRQb3ModC5wb3MpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzaXplOiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzLm1hcCgoeyBkb20gfSkgPT4gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxcbiAgICAgICAgICAgIHNwYWNlOiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQodG9vbHRpcENvbmZpZykudG9vbHRpcFNwYWNlKHRoaXMudmlldyksXG4gICAgICAgICAgICBzY2FsZVgsIHNjYWxlWSwgbWFrZUFic29sdXRlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHdyaXRlTWVhc3VyZShtZWFzdXJlZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChtZWFzdXJlZC5tYWtlQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHRoaXMubWFkZUFic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdC5kb20uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgZWRpdG9yLCBzcGFjZSwgc2NhbGVYLCBzY2FsZVkgfSA9IG1lYXN1cmVkO1xuICAgICAgICBsZXQgb3RoZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdG9vbHRpcCA9IHRoaXMubWFuYWdlci50b29sdGlwc1tpXSwgdFZpZXcgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldLCB7IGRvbSB9ID0gdFZpZXc7XG4gICAgICAgICAgICBsZXQgcG9zID0gbWVhc3VyZWQucG9zW2ldLCBzaXplID0gbWVhc3VyZWQuc2l6ZVtpXTtcbiAgICAgICAgICAgIC8vIEhpZGUgdG9vbHRpcHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgZWRpdG9yLlxuICAgICAgICAgICAgaWYgKCFwb3MgfHwgcG9zLmJvdHRvbSA8PSBNYXRoLm1heChlZGl0b3IudG9wLCBzcGFjZS50b3ApIHx8XG4gICAgICAgICAgICAgICAgcG9zLnRvcCA+PSBNYXRoLm1pbihlZGl0b3IuYm90dG9tLCBzcGFjZS5ib3R0b20pIHx8XG4gICAgICAgICAgICAgICAgcG9zLnJpZ2h0IDwgTWF0aC5tYXgoZWRpdG9yLmxlZnQsIHNwYWNlLmxlZnQpIC0gLjEgfHxcbiAgICAgICAgICAgICAgICBwb3MubGVmdCA+IE1hdGgubWluKGVkaXRvci5yaWdodCwgc3BhY2UucmlnaHQpICsgLjEpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gT3V0c2lkZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhcnJvdyA9IHRvb2x0aXAuYXJyb3cgPyB0Vmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwLWFycm93XCIpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBhcnJvd0hlaWdodCA9IGFycm93ID8gNyAvKiBBcnJvdy5TaXplICovIDogMDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHNpemUucmlnaHQgLSBzaXplLmxlZnQsIGhlaWdodCA9IChfYSA9IGtub3duSGVpZ2h0LmdldCh0VmlldykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNpemUuYm90dG9tIC0gc2l6ZS50b3A7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdFZpZXcub2Zmc2V0IHx8IG5vT2Zmc2V0LCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBzaXplLndpZHRoID4gc3BhY2UucmlnaHQgLSBzcGFjZS5sZWZ0ID8gKGx0ciA/IHNwYWNlLmxlZnQgOiBzcGFjZS5yaWdodCAtIHNpemUud2lkdGgpXG4gICAgICAgICAgICAgICAgOiBsdHIgPyBNYXRoLm1pbihwb3MubGVmdCAtIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApICsgb2Zmc2V0LngsIHNwYWNlLnJpZ2h0IC0gd2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIDogTWF0aC5tYXgoc3BhY2UubGVmdCwgcG9zLmxlZnQgLSB3aWR0aCArIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApIC0gb2Zmc2V0LngpO1xuICAgICAgICAgICAgbGV0IGFib3ZlID0gdGhpcy5hYm92ZVtpXTtcbiAgICAgICAgICAgIGlmICghdG9vbHRpcC5zdHJpY3RTaWRlICYmIChhYm92ZVxuICAgICAgICAgICAgICAgID8gcG9zLnRvcCAtIChzaXplLmJvdHRvbSAtIHNpemUudG9wKSAtIG9mZnNldC55IDwgc3BhY2UudG9wXG4gICAgICAgICAgICAgICAgOiBwb3MuYm90dG9tICsgKHNpemUuYm90dG9tIC0gc2l6ZS50b3ApICsgb2Zmc2V0LnkgPiBzcGFjZS5ib3R0b20pICYmXG4gICAgICAgICAgICAgICAgYWJvdmUgPT0gKHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20gPiBwb3MudG9wIC0gc3BhY2UudG9wKSlcbiAgICAgICAgICAgICAgICBhYm92ZSA9IHRoaXMuYWJvdmVbaV0gPSAhYWJvdmU7XG4gICAgICAgICAgICBsZXQgc3BhY2VWZXJ0ID0gKGFib3ZlID8gcG9zLnRvcCAtIHNwYWNlLnRvcCA6IHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20pIC0gYXJyb3dIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgaGVpZ2h0ICYmIHRWaWV3LnJlc2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgdGhpcy52aWV3LmRlZmF1bHRMaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga25vd25IZWlnaHQuc2V0KHRWaWV3LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0ID0gc3BhY2VWZXJ0KSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5zdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSBhYm92ZSA/IHBvcy50b3AgLSBoZWlnaHQgLSBhcnJvd0hlaWdodCAtIG9mZnNldC55IDogcG9zLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgb2Zmc2V0Lnk7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgICAgICBpZiAodFZpZXcub3ZlcmxhcCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG90aGVycylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIubGVmdCA8IHJpZ2h0ICYmIHIucmlnaHQgPiBsZWZ0ICYmIHIudG9wIDwgdG9wICsgaGVpZ2h0ICYmIHIuYm90dG9tID4gdG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gYWJvdmUgPyByLnRvcCAtIGhlaWdodCAtIDIgLSBhcnJvd0hlaWdodCA6IHIuYm90dG9tICsgYXJyb3dIZWlnaHQgKyAyO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9ICh0b3AgLSBtZWFzdXJlZC5wYXJlbnQudG9wKSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUubGVmdCA9IChsZWZ0IC0gbWVhc3VyZWQucGFyZW50LmxlZnQpIC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IHRvcCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUubGVmdCA9IGxlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJyb3cpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJyb3dMZWZ0ID0gcG9zLmxlZnQgKyAobHRyID8gb2Zmc2V0LnggOiAtb2Zmc2V0LngpIC0gKGxlZnQgKyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gLSA3IC8qIEFycm93LlNpemUgKi8pO1xuICAgICAgICAgICAgICAgIGFycm93LnN0eWxlLmxlZnQgPSBhcnJvd0xlZnQgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodFZpZXcub3ZlcmxhcCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBvdGhlcnMucHVzaCh7IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbTogdG9wICsgaGVpZ2h0IH0pO1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWFib3ZlXCIsIGFib3ZlKTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1iZWxvd1wiLCAhYWJvdmUpO1xuICAgICAgICAgICAgaWYgKHRWaWV3LnBvc2l0aW9uZWQpXG4gICAgICAgICAgICAgICAgdFZpZXcucG9zaXRpb25lZChtZWFzdXJlZC5zcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF5YmVNZWFzdXJlKCkge1xuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnRvb2x0aXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5pblZpZXcpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pblZpZXcgIT0gdGhpcy52aWV3LmluVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5WaWV3ID0gdGhpcy52aWV3LmluVmlldztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0diBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHYuZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgZXZlbnRPYnNlcnZlcnM6IHtcbiAgICAgICAgc2Nyb2xsKCkgeyB0aGlzLm1heWJlTWVhc3VyZSgpOyB9XG4gICAgfVxufSk7XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICB6SW5kZXg6IDEwMCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtc2VjdGlvbjpub3QoOmZpcnN0LWNoaWxkKVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2JiYlwiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xuICAgICAgICBoZWlnaHQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgIHdpZHRoOiBgJHs3IC8qIEFycm93LlNpemUgKi8gKiAyfXB4YCxcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgekluZGV4OiAtMSxcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIFwiJjpiZWZvcmUsICY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgY29udGVudDogXCInJ1wiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgYm9yZGVyTGVmdDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgICAgIGJvcmRlclJpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgdHJhbnNwYXJlbnRgLFxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWFib3ZlICZcIjoge1xuICAgICAgICAgICAgYm90dG9tOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVG9wOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLmNtLXRvb2x0aXAtYmVsb3cgJlwiOiB7XG4gICAgICAgICAgICB0b3A6IGAtJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2JiYmAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjZjVmNWY1YCxcbiAgICAgICAgICAgICAgICB0b3A6IFwiMXB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXAgLmNtLXRvb2x0aXAtYXJyb3dcIjoge1xuICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcIiMzMzMzMzhcIlxuICAgICAgICB9LFxuICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgYm9yZGVyVG9wQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcInRyYW5zcGFyZW50XCJcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuY29uc3Qgbm9PZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbi8qKlxuRmFjZXQgdG8gd2hpY2ggYW4gZXh0ZW5zaW9uIGNhbiBhZGQgYSB2YWx1ZSB0byBzaG93IGEgdG9vbHRpcC5cbiovXG5jb25zdCBzaG93VG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IFt0b29sdGlwUGx1Z2luLCBiYXNlVGhlbWVdXG59KTtcbmNvbnN0IHNob3dIb3ZlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiBpbnB1dHMgPT4gaW5wdXRzLnJlZHVjZSgoYSwgaSkgPT4gYS5jb25jYXQoaSksIFtdKVxufSk7XG5jbGFzcyBIb3ZlclRvb2x0aXBIb3N0IHtcbiAgICAvLyBOZWVkcyB0byBiZSBzdGF0aWMgc28gdGhhdCBob3N0IHRvb2x0aXAgaW5zdGFuY2VzIGFsd2F5cyBtYXRjaFxuICAgIHN0YXRpYyBjcmVhdGUodmlldykge1xuICAgICAgICByZXR1cm4gbmV3IEhvdmVyVG9vbHRpcEhvc3Qodmlldyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXAtaG92ZXJcIik7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBUb29sdGlwVmlld01hbmFnZXIodmlldywgc2hvd0hvdmVyVG9vbHRpcCwgKHQsIHApID0+IHRoaXMuY3JlYXRlSG9zdGVkVmlldyh0LCBwKSwgdCA9PiB0LmRvbS5yZW1vdmUoKSk7XG4gICAgfVxuICAgIGNyZWF0ZUhvc3RlZFZpZXcodG9vbHRpcCwgcHJldikge1xuICAgICAgICBsZXQgaG9zdGVkVmlldyA9IHRvb2x0aXAuY3JlYXRlKHRoaXMudmlldyk7XG4gICAgICAgIGhvc3RlZFZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLXNlY3Rpb25cIik7XG4gICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShob3N0ZWRWaWV3LmRvbSwgcHJldiA/IHByZXYuZG9tLm5leHRTaWJsaW5nIDogdGhpcy5kb20uZmlyc3RDaGlsZCk7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQgJiYgaG9zdGVkVmlldy5tb3VudClcbiAgICAgICAgICAgIGhvc3RlZFZpZXcubW91bnQodGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIGhvc3RlZFZpZXc7XG4gICAgfVxuICAgIG1vdW50KHZpZXcpIHtcbiAgICAgICAgZm9yIChsZXQgaG9zdGVkVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBpZiAoaG9zdGVkVmlldy5tb3VudClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHBvc2l0aW9uZWQoc3BhY2UpIHtcbiAgICAgICAgZm9yIChsZXQgaG9zdGVkVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICBpZiAoaG9zdGVkVmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIGhvc3RlZFZpZXcucG9zaXRpb25lZChzcGFjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLm1hbmFnZXIudXBkYXRlKHVwZGF0ZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgKF9hID0gdC5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0KTtcbiAgICB9XG4gICAgcGFzc1Byb3AobmFtZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IHZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgbGV0IGdpdmVuID0gdmlld1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChnaXZlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2l2ZW47XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IGdpdmVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG9mZnNldCgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJvZmZzZXRcIik7IH1cbiAgICBnZXQgZ2V0Q29vcmRzKCkgeyByZXR1cm4gdGhpcy5wYXNzUHJvcChcImdldENvb3Jkc1wiKTsgfVxuICAgIGdldCBvdmVybGFwKCkgeyByZXR1cm4gdGhpcy5wYXNzUHJvcChcIm92ZXJsYXBcIik7IH1cbiAgICBnZXQgcmVzaXplKCkgeyByZXR1cm4gdGhpcy5wYXNzUHJvcChcInJlc2l6ZVwiKTsgfVxufVxuY29uc3Qgc2hvd0hvdmVyVG9vbHRpcEhvc3QgPSAvKkBfX1BVUkVfXyovc2hvd1Rvb2x0aXAuY29tcHV0ZShbc2hvd0hvdmVyVG9vbHRpcF0sIHN0YXRlID0+IHtcbiAgICBsZXQgdG9vbHRpcHMgPSBzdGF0ZS5mYWNldChzaG93SG92ZXJUb29sdGlwKTtcbiAgICBpZiAodG9vbHRpcHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3M6IE1hdGgubWluKC4uLnRvb2x0aXBzLm1hcCh0ID0+IHQucG9zKSksXG4gICAgICAgIGVuZDogTWF0aC5tYXgoLi4udG9vbHRpcHMubWFwKHQgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0LmVuZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdC5wb3M7IH0pKSxcbiAgICAgICAgY3JlYXRlOiBIb3ZlclRvb2x0aXBIb3N0LmNyZWF0ZSxcbiAgICAgICAgYWJvdmU6IHRvb2x0aXBzWzBdLmFib3ZlLFxuICAgICAgICBhcnJvdzogdG9vbHRpcHMuc29tZSh0ID0+IHQuYXJyb3cpLFxuICAgIH07XG59KTtcbmNsYXNzIEhvdmVyUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzb3VyY2UsIGZpZWxkLCBzZXRIb3ZlciwgaG92ZXJUaW1lKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIHRoaXMuc2V0SG92ZXIgPSBzZXRIb3ZlcjtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWUgPSBob3ZlclRpbWU7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0TW92ZSA9IHsgeDogMCwgeTogMCwgdGFyZ2V0OiB2aWV3LmRvbSwgdGltZTogMCB9O1xuICAgICAgICB0aGlzLmNoZWNrSG92ZXIgPSB0aGlzLmNoZWNrSG92ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5tb3VzZWxlYXZlID0gdGhpcy5tb3VzZWxlYXZlLmJpbmQodGhpcykpO1xuICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW91c2Vtb3ZlID0gdGhpcy5tb3VzZW1vdmUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMucmVzdGFydFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhcnRIb3ZlcigpLCAyMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5maWVsZCh0aGlzLmZpZWxkKTtcbiAgICB9XG4gICAgY2hlY2tIb3ZlcigpIHtcbiAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGhvdmVyZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0TW92ZS50aW1lO1xuICAgICAgICBpZiAoaG92ZXJlZCA8IHRoaXMuaG92ZXJUaW1lKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUgLSBob3ZlcmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5zdGFydEhvdmVyKCk7XG4gICAgfVxuICAgIHN0YXJ0SG92ZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgbGV0IHsgdmlldywgbGFzdE1vdmUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QobGFzdE1vdmUudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFkZXNjKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zLCBzaWRlID0gMTtcbiAgICAgICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBXaWRnZXRWaWV3KSB7XG4gICAgICAgICAgICBwb3MgPSBkZXNjLnBvc0F0U3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGxhc3RNb3ZlKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcG9zQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICAgICAgaWYgKCFwb3NDb29yZHMgfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS55IDwgcG9zQ29vcmRzLnRvcCB8fCBsYXN0TW92ZS55ID4gcG9zQ29vcmRzLmJvdHRvbSB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnggPCBwb3NDb29yZHMubGVmdCAtIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueCA+IHBvc0Nvb3Jkcy5yaWdodCArIHZpZXcuZGVmYXVsdENoYXJhY3RlcldpZHRoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBiaWRpID0gdmlldy5iaWRpU3BhbnModmlldy5zdGF0ZS5kb2MubGluZUF0KHBvcykpLmZpbmQocyA9PiBzLmZyb20gPD0gcG9zICYmIHMudG8gPj0gcG9zKTtcbiAgICAgICAgICAgIGxldCBydGwgPSBiaWRpICYmIGJpZGkuZGlyID09IERpcmVjdGlvbi5SVEwgPyAtMSA6IDE7XG4gICAgICAgICAgICBzaWRlID0gKGxhc3RNb3ZlLnggPCBwb3NDb29yZHMubGVmdCA/IC1ydGwgOiBydGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5zb3VyY2UodmlldywgcG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKG9wZW4gPT09IG51bGwgfHwgb3BlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3Blbi50aGVuKSB7XG4gICAgICAgICAgICBsZXQgcGVuZGluZyA9IHRoaXMucGVuZGluZyA9IHsgcG9zIH07XG4gICAgICAgICAgICBvcGVuLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nID09IHBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiAhKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiAhcmVzdWx0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHQgOiBbcmVzdWx0XSkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZSA9PiBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJob3ZlciB0b29sdGlwXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVuICYmICEoQXJyYXkuaXNBcnJheShvcGVuKSAmJiAhb3Blbi5sZW5ndGgpKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihBcnJheS5pc0FycmF5KG9wZW4pID8gb3BlbiA6IFtvcGVuXSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRvb2x0aXAoKSB7XG4gICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pO1xuICAgICAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4ubWFuYWdlci50b29sdGlwcy5maW5kSW5kZXgodCA9PiB0LmNyZWF0ZSA9PSBIb3ZlclRvb2x0aXBIb3N0LmNyZWF0ZSkgOiAtMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBwbHVnaW4ubWFuYWdlci50b29sdGlwVmlld3NbaW5kZXhdIDogbnVsbDtcbiAgICB9XG4gICAgbW91c2Vtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHRhcmdldDogZXZlbnQudGFyZ2V0LCB0aW1lOiBEYXRlLm5vdygpIH07XG4gICAgICAgIGlmICh0aGlzLmhvdmVyVGltZW91dCA8IDApXG4gICAgICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5jaGVja0hvdmVyLCB0aGlzLmhvdmVyVGltZSk7XG4gICAgICAgIGxldCB7IGFjdGl2ZSwgdG9vbHRpcCB9ID0gdGhpcztcbiAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGggJiYgdG9vbHRpcCAmJiAhaXNJblRvb2x0aXAodG9vbHRpcC5kb20sIGV2ZW50KSB8fCB0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIGxldCB7IHBvcyB9ID0gYWN0aXZlWzBdIHx8IHRoaXMucGVuZGluZywgZW5kID0gKF9iID0gKF9hID0gYWN0aXZlWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwb3M7XG4gICAgICAgICAgICBpZiAoKHBvcyA9PSBlbmQgPyB0aGlzLnZpZXcucG9zQXRDb29yZHModGhpcy5sYXN0TW92ZSkgIT0gcG9zXG4gICAgICAgICAgICAgICAgOiAhaXNPdmVyUmFuZ2UodGhpcy52aWV3LCBwb3MsIGVuZCwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihbXSkgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3VzZWxlYXZlKGV2ZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhvdmVyVGltZW91dCk7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGxldCB7IGFjdGl2ZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IHRvb2x0aXAgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgaW5Ub29sdGlwID0gdG9vbHRpcCAmJiB0b29sdGlwLmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghaW5Ub29sdGlwKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoW10pIH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMud2F0Y2hUb29sdGlwTGVhdmUodG9vbHRpcC5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhdGNoVG9vbHRpcExlYXZlKHRvb2x0aXApIHtcbiAgICAgICAgbGV0IHdhdGNoID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0b29sdGlwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHdhdGNoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGggJiYgIXRoaXMudmlldy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdGhpcy5zZXRIb3Zlci5vZihbXSkgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRvb2x0aXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgd2F0Y2gpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSk7XG4gICAgICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSk7XG4gICAgfVxufVxuY29uc3QgdG9vbHRpcE1hcmdpbiA9IDQ7XG5mdW5jdGlvbiBpc0luVG9vbHRpcCh0b29sdGlwLCBldmVudCkge1xuICAgIGxldCByZWN0ID0gdG9vbHRpcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gZXZlbnQuY2xpZW50WCA+PSByZWN0LmxlZnQgLSB0b29sdGlwTWFyZ2luICYmIGV2ZW50LmNsaWVudFggPD0gcmVjdC5yaWdodCArIHRvb2x0aXBNYXJnaW4gJiZcbiAgICAgICAgZXZlbnQuY2xpZW50WSA+PSByZWN0LnRvcCAtIHRvb2x0aXBNYXJnaW4gJiYgZXZlbnQuY2xpZW50WSA8PSByZWN0LmJvdHRvbSArIHRvb2x0aXBNYXJnaW47XG59XG5mdW5jdGlvbiBpc092ZXJSYW5nZSh2aWV3LCBmcm9tLCB0bywgeCwgeSwgbWFyZ2luKSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgZG9jQm90dG9tID0gdmlldy5kb2N1bWVudFRvcCArIHZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCArIHZpZXcuY29udGVudEhlaWdodDtcbiAgICBpZiAocmVjdC5sZWZ0ID4geCB8fCByZWN0LnJpZ2h0IDwgeCB8fCByZWN0LnRvcCA+IHkgfHwgTWF0aC5taW4ocmVjdC5ib3R0b20sIGRvY0JvdHRvbSkgPCB5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4LCB5IH0sIGZhbHNlKTtcbiAgICByZXR1cm4gcG9zID49IGZyb20gJiYgcG9zIDw9IHRvO1xufVxuLyoqXG5TZXQgdXAgYSBob3ZlciB0b29sdGlwLCB3aGljaCBzaG93cyB1cCB3aGVuIHRoZSBwb2ludGVyIGhvdmVyc1xub3ZlciByYW5nZXMgb2YgdGV4dC4gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBob3ZlcnNcbm92ZXIgdGhlIGRvY3VtZW50IHRleHQuIEl0IHNob3VsZCwgaWYgdGhlcmUgaXMgYSB0b29sdGlwXG5hc3NvY2lhdGVkIHdpdGggcG9zaXRpb24gYHBvc2AsIHJldHVybiB0aGUgdG9vbHRpcCBkZXNjcmlwdGlvblxuKGVpdGhlciBkaXJlY3RseSBvciBpbiBhIHByb21pc2UpLiBUaGUgYHNpZGVgIGFyZ3VtZW50IGluZGljYXRlc1xub24gd2hpY2ggc2lkZSBvZiB0aGUgcG9zaXRpb24gdGhlIHBvaW50ZXIgaXPigJRpdCB3aWxsIGJlIC0xIGlmIHRoZVxucG9pbnRlciBpcyBiZWZvcmUgdGhlIHBvc2l0aW9uLCAxIGlmIGFmdGVyIHRoZSBwb3NpdGlvbi5cblxuTm90ZSB0aGF0IGFsbCBob3ZlciB0b29sdGlwcyBhcmUgaG9zdGVkIHdpdGhpbiBhIHNpbmdsZSB0b29sdGlwXG5jb250YWluZXIgZWxlbWVudC4gVGhpcyBhbGxvd3MgbXVsdGlwbGUgdG9vbHRpcHMgb3ZlciB0aGUgc2FtZVxucmFuZ2UgdG8gYmUgXCJtZXJnZWRcIiB0b2dldGhlciB3aXRob3V0IG92ZXJsYXBwaW5nLlxuKi9cbmZ1bmN0aW9uIGhvdmVyVG9vbHRpcChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBzZXRIb3ZlciA9IFN0YXRlRWZmZWN0LmRlZmluZSgpO1xuICAgIGxldCBob3ZlclN0YXRlID0gU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgICAgICBjcmVhdGUoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhpZGVPbkNoYW5nZSAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGlkZU9uKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmZpbHRlcih2ID0+ICFvcHRpb25zLmhpZGVPbih0ciwgdikpO1xuICAgICAgICAgICAgICAgIGlmICh0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRvb2x0aXAgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdQb3MgPSB0ci5jaGFuZ2VzLm1hcFBvcyh0b29sdGlwLnBvcywgLTEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1BvcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHRvb2x0aXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkucG9zID0gbmV3UG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3B5LmVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmVuZCA9IHRyLmNoYW5nZXMubWFwUG9zKGNvcHkuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRIb3ZlcikpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlOiBmID0+IHNob3dIb3ZlclRvb2x0aXAuZnJvbShmKVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGhvdmVyU3RhdGUsXG4gICAgICAgIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gbmV3IEhvdmVyUGx1Z2luKHZpZXcsIHNvdXJjZSwgaG92ZXJTdGF0ZSwgc2V0SG92ZXIsIG9wdGlvbnMuaG92ZXJUaW1lIHx8IDMwMCAvKiBIb3Zlci5UaW1lICovKSksXG4gICAgICAgIHNob3dIb3ZlclRvb2x0aXBIb3N0XG4gICAgXTtcbn1cbi8qKlxuR2V0IHRoZSBhY3RpdmUgdG9vbHRpcCB2aWV3IGZvciBhIGdpdmVuIHRvb2x0aXAsIGlmIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBnZXRUb29sdGlwKHZpZXcsIHRvb2x0aXApIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgaWYgKCFwbHVnaW4pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmb3VuZCA9IHBsdWdpbi5tYW5hZ2VyLnRvb2x0aXBzLmluZGV4T2YodG9vbHRpcCk7XG4gICAgcmV0dXJuIGZvdW5kIDwgMCA/IG51bGwgOiBwbHVnaW4ubWFuYWdlci50b29sdGlwVmlld3NbZm91bmRdO1xufVxuLyoqXG5SZXR1cm5zIHRydWUgaWYgYW55IGhvdmVyIHRvb2x0aXBzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuKi9cbmZ1bmN0aW9uIGhhc0hvdmVyVG9vbHRpcHMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCkuc29tZSh4ID0+IHgpO1xufVxuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcblRyYW5zYWN0aW9uIGVmZmVjdCB0aGF0IGNsb3NlcyBhbGwgaG92ZXIgdG9vbHRpcHMuXG4qL1xuY29uc3QgY2xvc2VIb3ZlclRvb2x0aXBzID0gLypAX19QVVJFX18qL2Nsb3NlSG92ZXJUb29sdGlwRWZmZWN0Lm9mKG51bGwpO1xuLyoqXG5UZWxsIHRoZSB0b29sdGlwIGV4dGVuc2lvbiB0byByZWNvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RpdmVcbnRvb2x0aXBzLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBzb21ldGhpbmcgaGFwcGVucyAoc3VjaCBhcyBhXG5yZS1wb3NpdGlvbmluZyBvciBDU1MgY2hhbmdlIGFmZmVjdGluZyB0aGUgZWRpdG9yKSB0aGF0IGNvdWxkXG5pbnZhbGlkYXRlIHRoZSBleGlzdGluZyB0b29sdGlwIHBvc2l0aW9ucy5cbiovXG5mdW5jdGlvbiByZXBvc2l0aW9uVG9vbHRpcHModmlldykge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICBpZiAocGx1Z2luKVxuICAgICAgICBwbHVnaW4ubWF5YmVNZWFzdXJlKCk7XG59XG5cbmNvbnN0IHBhbmVsQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCB0b3BDb250YWluZXIsIGJvdHRvbUNvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgYyBvZiBjb25maWdzKSB7XG4gICAgICAgICAgICB0b3BDb250YWluZXIgPSB0b3BDb250YWluZXIgfHwgYy50b3BDb250YWluZXI7XG4gICAgICAgICAgICBib3R0b21Db250YWluZXIgPSBib3R0b21Db250YWluZXIgfHwgYy5ib3R0b21Db250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXIgfTtcbiAgICB9XG59KTtcbi8qKlxuQ29uZmlndXJlcyB0aGUgcGFuZWwtbWFuYWdpbmcgZXh0ZW5zaW9uLlxuKi9cbmZ1bmN0aW9uIHBhbmVscyhjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3BhbmVsQ29uZmlnLm9mKGNvbmZpZyldIDogW107XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHBhbmVsIGNyZWF0ZWQgYnkgdGhlIGdpdmVuIGNvbnN0cnVjdG9yLCBpZiBhbnkuXG5UaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCBhY2Nlc3MgdG8geW91ciBwYW5lbHMnIERPTVxuc3RydWN0dXJlLlxuKi9cbmZ1bmN0aW9uIGdldFBhbmVsKHZpZXcsIHBhbmVsKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHBhbmVsUGx1Z2luKTtcbiAgICBsZXQgaW5kZXggPSBwbHVnaW4gPyBwbHVnaW4uc3BlY3MuaW5kZXhPZihwYW5lbCkgOiAtMTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IHBsdWdpbi5wYW5lbHNbaW5kZXhdIDogbnVsbDtcbn1cbmNvbnN0IHBhbmVsUGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSB2aWV3LnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIHRoaXMuc3BlY3MgPSB0aGlzLmlucHV0LmZpbHRlcihzID0+IHMpO1xuICAgICAgICB0aGlzLnBhbmVscyA9IHRoaXMuc3BlY3MubWFwKHNwZWMgPT4gc3BlYyh2aWV3KSk7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChwYW5lbENvbmZpZyk7XG4gICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodmlldywgdHJ1ZSwgY29uZi50b3BDb250YWluZXIpO1xuICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMudG9wLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gcC50b3ApKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luYyh0aGlzLnBhbmVscy5maWx0ZXIocCA9PiAhcC50b3ApKTtcbiAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgcC5kb20uY2xhc3NMaXN0LmFkZChcImNtLXBhbmVsXCIpO1xuICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICBpZiAodGhpcy50b3AuY29udGFpbmVyICE9IGNvbmYudG9wQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnRvcC5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3R0b20uY29udGFpbmVyICE9IGNvbmYuYm90dG9tQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gbmV3IFBhbmVsR3JvdXAodXBkYXRlLnZpZXcsIGZhbHNlLCBjb25mLmJvdHRvbUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3Auc3luY0NsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc3luY0NsYXNzZXMoKTtcbiAgICAgICAgbGV0IGlucHV0ID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNob3dQYW5lbCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSB0aGlzLmlucHV0KSB7XG4gICAgICAgICAgICBsZXQgc3BlY3MgPSBpbnB1dC5maWx0ZXIoeCA9PiB4KTtcbiAgICAgICAgICAgIGxldCBwYW5lbHMgPSBbXSwgdG9wID0gW10sIGJvdHRvbSA9IFtdLCBtb3VudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBrbm93biA9IHRoaXMuc3BlY3MuaW5kZXhPZihzcGVjKSwgcGFuZWw7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHNwZWModXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBtb3VudC5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhbmVsID0gdGhpcy5wYW5lbHNba25vd25dO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFuZWwudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWwudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhbmVscy5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgICAgICAocGFuZWwudG9wID8gdG9wIDogYm90dG9tKS5wdXNoKHBhbmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyh0b3ApO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhib3R0b20pO1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiBtb3VudCkge1xuICAgICAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgICAgICBpZiAocC5tb3VudClcbiAgICAgICAgICAgICAgICAgICAgcC5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBhbmVscylcbiAgICAgICAgICAgICAgICBpZiAocC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHAudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmMoW10pO1xuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4gRWRpdG9yVmlldy5zY3JvbGxNYXJnaW5zLm9mKHZpZXcgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgeyB0b3A6IHZhbHVlLnRvcC5zY3JvbGxNYXJnaW4oKSwgYm90dG9tOiB2YWx1ZS5ib3R0b20uc2Nyb2xsTWFyZ2luKCkgfTtcbiAgICB9KVxufSk7XG5jbGFzcyBQYW5lbEdyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCB0b3AsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNsYXNzZXMgPSBcIlwiO1xuICAgICAgICB0aGlzLnBhbmVscyA9IFtdO1xuICAgICAgICB0aGlzLnN5bmNDbGFzc2VzKCk7XG4gICAgfVxuICAgIHN5bmMocGFuZWxzKSB7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICBpZiAocC5kZXN0cm95ICYmIHBhbmVscy5pbmRleE9mKHApIDwgMClcbiAgICAgICAgICAgICAgICBwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBwYW5lbHM7XG4gICAgICAgIHRoaXMuc3luY0RPTSgpO1xuICAgIH1cbiAgICBzeW5jRE9NKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IHRoaXMudG9wID8gXCJjbS1wYW5lbHMgY20tcGFuZWxzLXRvcFwiIDogXCJjbS1wYW5lbHMgY20tcGFuZWxzLWJvdHRvbVwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGVbdGhpcy50b3AgPyBcInRvcFwiIDogXCJib3R0b21cIl0gPSBcIjBcIjtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmNvbnRhaW5lciB8fCB0aGlzLnZpZXcuZG9tO1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdGhpcy50b3AgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJET00gPSB0aGlzLmRvbS5maXJzdENoaWxkO1xuICAgICAgICBmb3IgKGxldCBwYW5lbCBvZiB0aGlzLnBhbmVscykge1xuICAgICAgICAgICAgaWYgKHBhbmVsLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckRPTSAhPSBwYW5lbC5kb20pXG4gICAgICAgICAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gY3VyRE9NLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHBhbmVsLmRvbSwgY3VyRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY3VyRE9NKVxuICAgICAgICAgICAgY3VyRE9NID0gcm0oY3VyRE9NKTtcbiAgICB9XG4gICAgc2Nyb2xsTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZG9tIHx8IHRoaXMuY29udGFpbmVyID8gMFxuICAgICAgICAgICAgOiBNYXRoLm1heCgwLCB0aGlzLnRvcCA/XG4gICAgICAgICAgICAgICAgdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gTWF0aC5tYXgoMCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIDpcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihpbm5lckhlaWdodCwgdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20pIC0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKTtcbiAgICB9XG4gICAgc3luY0NsYXNzZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIgfHwgdGhpcy5jbGFzc2VzID09IHRoaXMudmlldy50aGVtZUNsYXNzZXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB0aGlzLmNsYXNzZXMuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiAodGhpcy5jbGFzc2VzID0gdGhpcy52aWV3LnRoZW1lQ2xhc3Nlcykuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcm0obm9kZSkge1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybiBuZXh0O1xufVxuLyoqXG5PcGVuaW5nIGEgcGFuZWwgaXMgZG9uZSBieSBwcm92aWRpbmcgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3JcbnRoZSBwYW5lbCB0aHJvdWdoIHRoaXMgZmFjZXQuIChUaGUgcGFuZWwgaXMgY2xvc2VkIGFnYWluIHdoZW4gaXRzXG5jb25zdHJ1Y3RvciBpcyBubyBsb25nZXIgcHJvdmlkZWQuKSBWYWx1ZXMgb2YgYG51bGxgIGFyZSBpZ25vcmVkLlxuKi9cbmNvbnN0IHNob3dQYW5lbCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGVuYWJsZXM6IHBhbmVsUGx1Z2luXG59KTtcblxuLyoqXG5BIGd1dHRlciBtYXJrZXIgcmVwcmVzZW50cyBhIGJpdCBvZiBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byBhIGxpbmVcbmluIGEgc3BlY2lmaWMgZ3V0dGVyLiBZb3VyIG93biBjdXN0b20gbWFya2VycyBoYXZlIHRvIGV4dGVuZCB0aGlzXG5jbGFzcy5cbiovXG5jbGFzcyBHdXR0ZXJNYXJrZXIgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBvdGhlci5jb25zdHJ1Y3RvciAmJiB0aGlzLmVxKG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIG1hcmtlciB0byBhbm90aGVyIG1hcmtlciBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ2FsbGVkIGlmIHRoZSBtYXJrZXIgaGFzIGEgYHRvRE9NYCBtZXRob2QgYW5kIGl0cyByZXByZXNlbnRhdGlvblxuICAgIHdhcyByZW1vdmVkIGZyb20gYSBndXR0ZXIuXG4gICAgKi9cbiAgICBkZXN0cm95KGRvbSkgeyB9XG59XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLmVsZW1lbnRDbGFzcyA9IFwiXCI7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnRvRE9NID0gdW5kZWZpbmVkO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0JlZm9yZTtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUuc3RhcnRTaWRlID0gR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbmRTaWRlID0gLTE7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBhZGQgYSBjbGFzcyB0byBhbGwgZ3V0dGVyIGVsZW1lbnRzIGZvciBhIGdpdmVuIGxpbmUuXG5NYXJrZXJzIGdpdmVuIHRvIHRoaXMgZmFjZXQgc2hvdWxkIF9vbmx5XyBkZWZpbmUgYW5cbltgZWxlbWVudGNsYXNzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3Lkd1dHRlck1hcmtlci5lbGVtZW50Q2xhc3MpLCBub3QgYVxuW2B0b0RPTWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIudG9ET00pIChvciB0aGUgbWFya2VyIHdpbGwgYXBwZWFyXG5pbiBhbGwgZ3V0dGVycyBmb3IgdGhlIGxpbmUpLlxuKi9cbmNvbnN0IGd1dHRlckxpbmVDbGFzcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGNsYXNzOiBcIlwiLFxuICAgIHJlbmRlckVtcHR5RWxlbWVudHM6IGZhbHNlLFxuICAgIGVsZW1lbnRTdHlsZTogXCJcIixcbiAgICBtYXJrZXJzOiAoKSA9PiBSYW5nZVNldC5lbXB0eSxcbiAgICBsaW5lTWFya2VyOiAoKSA9PiBudWxsLFxuICAgIHdpZGdldE1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiBudWxsLFxuICAgIGluaXRpYWxTcGFjZXI6IG51bGwsXG4gICAgdXBkYXRlU3BhY2VyOiBudWxsLFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHt9XG59O1xuY29uc3QgYWN0aXZlR3V0dGVycyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGFuIGVkaXRvciBndXR0ZXIuIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgZ3V0dGVycyBhcHBlYXIgaXNcbmRldGVybWluZWQgYnkgdGhlaXIgZXh0ZW5zaW9uIHByaW9yaXR5LlxuKi9cbmZ1bmN0aW9uIGd1dHRlcihjb25maWcpIHtcbiAgICByZXR1cm4gW2d1dHRlcnMoKSwgYWN0aXZlR3V0dGVycy5vZihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKSwgY29uZmlnKSldO1xufVxuY29uc3QgdW5maXhHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuLyoqXG5UaGUgZ3V0dGVyLWRyYXdpbmcgcGx1Z2luIGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCB3aGVuIHlvdSBhZGQgYVxuZ3V0dGVyLCBidXQgeW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvbiB0byBleHBsaWNpdGx5IGNvbmZpZ3VyZSBpdC5cblxuVW5sZXNzIGBmaXhlZGAgaXMgZXhwbGljaXRseSBzZXQgdG8gYGZhbHNlYCwgdGhlIGd1dHRlcnMgYXJlXG5maXhlZCwgbWVhbmluZyB0aGV5IGRvbid0IHNjcm9sbCBhbG9uZyB3aXRoIHRoZSBjb250ZW50XG5ob3Jpem9udGFsbHkgKGV4Y2VwdCBvbiBJbnRlcm5ldCBFeHBsb3Jlciwgd2hpY2ggZG9lc24ndCBzdXBwb3J0XG5DU1MgW2Bwb3NpdGlvbjpcbnN0aWNreWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9wb3NpdGlvbiNzdGlja3kpKS5cbiovXG5mdW5jdGlvbiBndXR0ZXJzKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbXG4gICAgICAgIGd1dHRlclZpZXcsXG4gICAgXTtcbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5maXhlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJlc3VsdC5wdXNoKHVuZml4R3V0dGVycy5vZih0cnVlKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IGd1dHRlclZpZXcgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5wcmV2Vmlld3BvcnQgPSB2aWV3LnZpZXdwb3J0O1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyc1wiO1xuICAgICAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9ICh0aGlzLnZpZXcuY29udGVudEhlaWdodCAvIHRoaXMudmlldy5zY2FsZVkpICsgXCJweFwiO1xuICAgICAgICB0aGlzLmd1dHRlcnMgPSB2aWV3LnN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLm1hcChjb25mID0+IG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHZpZXcsIGNvbmYpKTtcbiAgICAgICAgZm9yIChsZXQgZ3V0dGVyIG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGd1dHRlci5kb20pO1xuICAgICAgICB0aGlzLmZpeGVkID0gIXZpZXcuc3RhdGUuZmFjZXQodW5maXhHdXR0ZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIElFMTEgZmFsbGJhY2ssIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBwb3NpdGlvbjogc3RpY2t5LFxuICAgICAgICAgICAgLy8gYnkgdXNpbmcgcG9zaXRpb246IHJlbGF0aXZlICsgZXZlbnQgaGFuZGxlcnMgdGhhdCByZWFsaWduIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVyIChvciBqdXN0IGZvcmNlIGZpeGVkPWZhbHNlIG9uIElFMTE/KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSBcInN0aWNreVwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3luY0d1dHRlcnMoZmFsc2UpO1xuICAgICAgICB2aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHZpZXcuY29udGVudERPTSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlR3V0dGVycyh1cGRhdGUpKSB7XG4gICAgICAgICAgICAvLyBEZXRhY2ggZHVyaW5nIHN5bmMgd2hlbiB0aGUgdmlld3BvcnQgY2hhbmdlZCBzaWduaWZpY2FudGx5XG4gICAgICAgICAgICAvLyAoc3VjaCBhcyBkdXJpbmcgc2Nyb2xsaW5nKSwgc2luY2UgZm9yIGxhcmdlIHVwZGF0ZXMgdGhhdCBpc1xuICAgICAgICAgICAgLy8gZmFzdGVyLlxuICAgICAgICAgICAgbGV0IHZwQSA9IHRoaXMucHJldlZpZXdwb3J0LCB2cEIgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgICAgIGxldCB2cE92ZXJsYXAgPSBNYXRoLm1pbih2cEEudG8sIHZwQi50bykgLSBNYXRoLm1heCh2cEEuZnJvbSwgdnBCLmZyb20pO1xuICAgICAgICAgICAgdGhpcy5zeW5jR3V0dGVycyh2cE92ZXJsYXAgPCAodnBCLnRvIC0gdnBCLmZyb20pICogMC44KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLmdlb21ldHJ5Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmlldy5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycykgIT0gIXRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZml4ZWQgPSAhdGhpcy5maXhlZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgfVxuICAgIHN5bmNHdXR0ZXJzKGRldGFjaCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICBsZXQgbGluZUNsYXNzZXMgPSBSYW5nZVNldC5pdGVyKHRoaXMudmlldy5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB0aGlzLnZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgICAgIGxldCBjbGFzc1NldCA9IFtdO1xuICAgICAgICBsZXQgY29udGV4dHMgPSB0aGlzLmd1dHRlcnMubWFwKGd1dHRlciA9PiBuZXcgVXBkYXRlQ29udGV4dChndXR0ZXIsIHRoaXMudmlldy52aWV3cG9ydCwgLXRoaXMudmlldy5kb2N1bWVudFBhZGRpbmcudG9wKSk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgaWYgKGNsYXNzU2V0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBjbGFzc1NldCA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCAmJiBmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGIuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5saW5lKHRoaXMudmlldywgYiwgY2xhc3NTZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiLndpZGdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gud2lkZ2V0KHRoaXMudmlldywgYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgY3gubGluZSh0aGlzLnZpZXcsIGxpbmUsIGNsYXNzU2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgIGN4LndpZGdldCh0aGlzLnZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgY3guZmluaXNoKCk7XG4gICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgYWZ0ZXIpO1xuICAgIH1cbiAgICB1cGRhdGVHdXR0ZXJzKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldiA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLCBjdXIgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyk7XG4gICAgICAgIGxldCBjaGFuZ2UgPSB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuaGVpZ2h0Q2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAhUmFuZ2VTZXQuZXEodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20sIHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHByZXYgPT0gY3VyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgICAgIGlmIChndXR0ZXIudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGd1dHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmYgb2YgY3VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gcHJldi5pbmRleE9mKGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHRoaXMudmlldywgY29uZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndXR0ZXJzW2tub3duXS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKHRoaXMuZ3V0dGVyc1trbm93bl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgdGhpcy5ndXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlcnMuaW5kZXhPZihnKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGcuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiBndXR0ZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGcuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ3V0dGVycyA9IGd1dHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuZ3V0dGVycy5sZW5ndGggPT0gMCB8fCAhdmFsdWUuZml4ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSXG4gICAgICAgICAgICA/IHsgbGVmdDogdmFsdWUuZG9tLm9mZnNldFdpZHRoICogdmlldy5zY2FsZVggfVxuICAgICAgICAgICAgOiB7IHJpZ2h0OiB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggKiB2aWV3LnNjYWxlWCB9O1xuICAgIH0pXG59KTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7IHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pOyB9XG5mdW5jdGlvbiBhZHZhbmNlQ3Vyc29yKGN1cnNvciwgY29sbGVjdCwgcG9zKSB7XG4gICAgd2hpbGUgKGN1cnNvci52YWx1ZSAmJiBjdXJzb3IuZnJvbSA8PSBwb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvci5mcm9tID09IHBvcylcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgIH1cbn1cbmNsYXNzIFVwZGF0ZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGd1dHRlciwgdmlld3BvcnQsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmd1dHRlciA9IGd1dHRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gUmFuZ2VTZXQuaXRlcihndXR0ZXIubWFya2Vycywgdmlld3BvcnQuZnJvbSk7XG4gICAgfVxuICAgIGFkZEVsZW1lbnQodmlldywgYmxvY2ssIG1hcmtlcnMpIHtcbiAgICAgICAgbGV0IHsgZ3V0dGVyIH0gPSB0aGlzLCBhYm92ZSA9IChibG9jay50b3AgLSB0aGlzLmhlaWdodCkgLyB2aWV3LnNjYWxlWSwgaGVpZ2h0ID0gYmxvY2suaGVpZ2h0IC8gdmlldy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLmkgPT0gZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzLnB1c2gobmV3RWx0KTtcbiAgICAgICAgICAgIGd1dHRlci5kb20uYXBwZW5kQ2hpbGQobmV3RWx0LmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHNbdGhpcy5pXS51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBibG9jay5ib3R0b207XG4gICAgICAgIHRoaXMuaSsrO1xuICAgIH1cbiAgICBsaW5lKHZpZXcsIGxpbmUsIGV4dHJhTWFya2Vycykge1xuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIGFkdmFuY2VDdXJzb3IodGhpcy5jdXJzb3IsIGxvY2FsTWFya2VycywgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGV4dHJhTWFya2Vycy5sZW5ndGgpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMgPSBsb2NhbE1hcmtlcnMuY29uY2F0KGV4dHJhTWFya2Vycyk7XG4gICAgICAgIGxldCBmb3JMaW5lID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgaWYgKGZvckxpbmUpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAobG9jYWxNYXJrZXJzLmxlbmd0aCA9PSAwICYmICFndXR0ZXIuY29uZmlnLnJlbmRlckVtcHR5RWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xuICAgIH1cbiAgICB3aWRnZXQodmlldywgYmxvY2spIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuZ3V0dGVyLmNvbmZpZy53aWRnZXRNYXJrZXIodmlldywgYmxvY2sud2lkZ2V0LCBibG9jayk7XG4gICAgICAgIGlmIChtYXJrZXIpXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQodmlldywgYmxvY2ssIFttYXJrZXJdKTtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBsZXQgZ3V0dGVyID0gdGhpcy5ndXR0ZXI7XG4gICAgICAgIHdoaWxlIChndXR0ZXIuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5pKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IGd1dHRlci5lbGVtZW50cy5wb3AoKTtcbiAgICAgICAgICAgIGd1dHRlci5kb20ucmVtb3ZlQ2hpbGQobGFzdC5kb20pO1xuICAgICAgICAgICAgbGFzdC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTaW5nbGVHdXR0ZXJWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5zcGFjZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyXCIgKyAodGhpcy5jb25maWcuY2xhc3MgPyBcIiBcIiArIHRoaXMuY29uZmlnLmNsYXNzIDogXCJcIik7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gY29uZmlnLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIocHJvcCwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCwgeTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldC5wYXJlbnROb2RlICE9IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXRIZWlnaHQoeSAtIHZpZXcuZG9jdW1lbnRUb3ApO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZG9tRXZlbnRIYW5kbGVyc1twcm9wXSh2aWV3LCBsaW5lLCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KGNvbmZpZy5tYXJrZXJzKHZpZXcpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5pbml0aWFsU3BhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLnNwYWNlciA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIDAsIDAsIFtjb25maWcuaW5pdGlhbFNwYWNlcih2aWV3KV0pO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zcGFjZXIuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuc3BhY2VyLmRvbS5zdHlsZS5jc3NUZXh0ICs9IFwidmlzaWJpbGl0eTogaGlkZGVuOyBwb2ludGVyLWV2ZW50czogbm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHByZXZNYXJrZXJzID0gdGhpcy5tYXJrZXJzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBhc0FycmF5KHRoaXMuY29uZmlnLm1hcmtlcnModXBkYXRlLnZpZXcpKTtcbiAgICAgICAgaWYgKHRoaXMuc3BhY2VyICYmIHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcikge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIodGhpcy5zcGFjZXIubWFya2Vyc1swXSwgdXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkICE9IHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0pXG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXIudXBkYXRlKHVwZGF0ZS52aWV3LCAwLCAwLCBbdXBkYXRlZF0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2cCA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICByZXR1cm4gIVJhbmdlU2V0LmVxKHRoaXMubWFya2VycywgcHJldk1hcmtlcnMsIHZwLmZyb20sIHZwLnRvKSB8fFxuICAgICAgICAgICAgKHRoaXMuY29uZmlnLmxpbmVNYXJrZXJDaGFuZ2UgPyB0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlKHVwZGF0ZSkgOiBmYWxzZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGVsdCBvZiB0aGlzLmVsZW1lbnRzKVxuICAgICAgICAgICAgZWx0LmRlc3Ryb3koKTtcbiAgICB9XG59XG5jbGFzcyBHdXR0ZXJFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gLTE7XG4gICAgICAgIHRoaXMuYWJvdmUgPSAwO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlckVsZW1lbnRcIjtcbiAgICAgICAgdGhpcy51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3LCBoZWlnaHQsIGFib3ZlLCBtYXJrZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFib3ZlICE9IGFib3ZlKVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWFyZ2luVG9wID0gKHRoaXMuYWJvdmUgPSBhYm92ZSkgPyBhYm92ZSArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgIGlmICghc2FtZU1hcmtlcnModGhpcy5tYXJrZXJzLCBtYXJrZXJzKSlcbiAgICAgICAgICAgIHRoaXMuc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKTtcbiAgICB9XG4gICAgc2V0TWFya2Vycyh2aWV3LCBtYXJrZXJzKSB7XG4gICAgICAgIGxldCBjbHMgPSBcImNtLWd1dHRlckVsZW1lbnRcIiwgZG9tUG9zID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgaU5ldyA9IDAsIGlPbGQgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBza2lwVG8gPSBpT2xkLCBtYXJrZXIgPSBpTmV3IDwgbWFya2Vycy5sZW5ndGggPyBtYXJrZXJzW2lOZXcrK10gOiBudWxsLCBtYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSBtYXJrZXIuZWxlbWVudENsYXNzO1xuICAgICAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCIgKyBjO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpT2xkOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXJrZXJzW2ldLmNvbXBhcmUobWFya2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFRvID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNraXBUbyA9IHRoaXMubWFya2Vycy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaU9sZCA8IHNraXBUbykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5tYXJrZXJzW2lPbGQrK107XG4gICAgICAgICAgICAgICAgaWYgKG5leHQudG9ET00pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5kZXN0cm95KGRvbVBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkb21Qb3MgPSBhZnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1hcmtlcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChtYXJrZXIudG9ET00pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gZG9tUG9zLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKG1hcmtlci50b0RPTSh2aWV3KSwgZG9tUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVkKVxuICAgICAgICAgICAgICAgIGlPbGQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0TWFya2VycyhudWxsLCBbXSk7IC8vIEZpcnN0IGFyZ3VtZW50IG5vdCB1c2VkIHVubGVzcyBjcmVhdGluZyBtYXJrZXJzXG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZU1hcmtlcnMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFhW2ldLmNvbXBhcmUoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkZhY2V0IHVzZWQgdG8gcHJvdmlkZSBtYXJrZXJzIHRvIHRoZSBsaW5lIG51bWJlciBndXR0ZXIuXG4qL1xuY29uc3QgbGluZU51bWJlck1hcmtlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBsaW5lTnVtYmVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCB7IGZvcm1hdE51bWJlcjogU3RyaW5nLCBkb21FdmVudEhhbmRsZXJzOiB7fSB9LCB7XG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtldmVudF0gPSBleGlzdHMgPyAodmlldywgbGluZSwgZXZlbnQpID0+IGV4aXN0cyh2aWV3LCBsaW5lLCBldmVudCkgfHwgYWRkKHZpZXcsIGxpbmUsIGV2ZW50KSA6IGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jbGFzcyBOdW1iZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMubnVtYmVyID09IG90aGVyLm51bWJlcjsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpOyB9XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmlldywgbnVtYmVyKSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZm9ybWF0TnVtYmVyKG51bWJlciwgdmlldy5zdGF0ZSk7XG59XG5jb25zdCBsaW5lTnVtYmVyR3V0dGVyID0gLypAX19QVVJFX18qL2FjdGl2ZUd1dHRlcnMuY29tcHV0ZShbbGluZU51bWJlckNvbmZpZ10sIHN0YXRlID0+ICh7XG4gICAgY2xhc3M6IFwiY20tbGluZU51bWJlcnNcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHsgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlck1hcmtlcnMpOyB9LFxuICAgIGxpbmVNYXJrZXIodmlldywgbGluZSwgb3RoZXJzKSB7XG4gICAgICAgIGlmIChvdGhlcnMuc29tZShtID0+IG0udG9ET00pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCB2aWV3LnN0YXRlLmRvYy5saW5lQXQobGluZS5mcm9tKS5udW1iZXIpKTtcbiAgICB9LFxuICAgIHdpZGdldE1hcmtlcjogKCkgPT4gbnVsbCxcbiAgICBsaW5lTWFya2VyQ2hhbmdlOiB1cGRhdGUgPT4gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLFxuICAgIGluaXRpYWxTcGFjZXIodmlldykge1xuICAgICAgICByZXR1cm4gbmV3IE51bWJlck1hcmtlcihmb3JtYXROdW1iZXIodmlldywgbWF4TGluZU51bWJlcih2aWV3LnN0YXRlLmRvYy5saW5lcykpKTtcbiAgICB9LFxuICAgIHVwZGF0ZVNwYWNlcihzcGFjZXIsIHVwZGF0ZSkge1xuICAgICAgICBsZXQgbWF4ID0gZm9ybWF0TnVtYmVyKHVwZGF0ZS52aWV3LCBtYXhMaW5lTnVtYmVyKHVwZGF0ZS52aWV3LnN0YXRlLmRvYy5saW5lcykpO1xuICAgICAgICByZXR1cm4gbWF4ID09IHNwYWNlci5udW1iZXIgPyBzcGFjZXIgOiBuZXcgTnVtYmVyTWFya2VyKG1heCk7XG4gICAgfSxcbiAgICBkb21FdmVudEhhbmRsZXJzOiBzdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKS5kb21FdmVudEhhbmRsZXJzXG59KSk7XG4vKipcbkNyZWF0ZSBhIGxpbmUgbnVtYmVyIGd1dHRlciBleHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gbGluZU51bWJlcnMoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBsaW5lTnVtYmVyQ29uZmlnLm9mKGNvbmZpZyksXG4gICAgICAgIGd1dHRlcnMoKSxcbiAgICAgICAgbGluZU51bWJlckd1dHRlclxuICAgIF07XG59XG5mdW5jdGlvbiBtYXhMaW5lTnVtYmVyKGxpbmVzKSB7XG4gICAgbGV0IGxhc3QgPSA5O1xuICAgIHdoaWxlIChsYXN0IDwgbGluZXMpXG4gICAgICAgIGxhc3QgPSBsYXN0ICogMTAgKyA5O1xuICAgIHJldHVybiBsYXN0O1xufVxuY29uc3QgYWN0aXZlTGluZUd1dHRlck1hcmtlciA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmVsZW1lbnRDbGFzcyA9IFwiY20tYWN0aXZlTGluZUd1dHRlclwiO1xuICAgIH1cbn07XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVySGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovZ3V0dGVyTGluZUNsYXNzLmNvbXB1dGUoW1wic2VsZWN0aW9uXCJdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IG1hcmtzID0gW10sIGxhc3QgPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBsaW5lUG9zID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5oZWFkKS5mcm9tO1xuICAgICAgICBpZiAobGluZVBvcyA+IGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lUG9zO1xuICAgICAgICAgICAgbWFya3MucHVzaChhY3RpdmVMaW5lR3V0dGVyTWFya2VyLnJhbmdlKGxpbmVQb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmFuZ2VTZXQub2YobWFya3MpO1xufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBhIGBjbS1hY3RpdmVMaW5lR3V0dGVyYCBjbGFzcyB0b1xuYWxsIGd1dHRlciBlbGVtZW50cyBvbiB0aGUgW2FjdGl2ZVxubGluZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmhpZ2hsaWdodEFjdGl2ZUxpbmUpLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlcjtcbn1cblxuY29uc3QgV2hpdGVzcGFjZURlY28gPSAvKkBfX1BVUkVfXyovbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0V2hpdGVzcGFjZURlY28oc3BhY2UpIHtcbiAgICBsZXQgZGVjbyA9IFdoaXRlc3BhY2VEZWNvLmdldChzcGFjZSk7XG4gICAgaWYgKCFkZWNvKVxuICAgICAgICBXaGl0ZXNwYWNlRGVjby5zZXQoc3BhY2UsIGRlY28gPSBEZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgYXR0cmlidXRlczogc3BhY2UgPT09IFwiXFx0XCIgPyB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiY20taGlnaGxpZ2h0VGFiXCIsXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBcImNtLWhpZ2hsaWdodFNwYWNlXCIsXG4gICAgICAgICAgICAgICAgXCJkYXRhLWRpc3BsYXlcIjogc3BhY2UucmVwbGFjZSgvIC9nLCBcIsK3XCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICByZXR1cm4gZGVjbztcbn1cbmZ1bmN0aW9uIG1hdGNoZXIoZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKHZpZXcgPT4gKHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IGRlY29yYXRvci5jcmVhdGVEZWNvKHZpZXcpLFxuICAgICAgICB1cGRhdGUodSkge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGRlY29yYXRvci51cGRhdGVEZWNvKHUsIHRoaXMuZGVjb3JhdGlvbnMpO1xuICAgICAgICB9LFxuICAgIH0pLCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KTtcbn1cbmNvbnN0IHdoaXRlc3BhY2VIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9tYXRjaGVyKC8qQF9fUFVSRV9fKi9uZXcgTWF0Y2hEZWNvcmF0b3Ioe1xuICAgIHJlZ2V4cDogL1xcdHwgKy9nLFxuICAgIGRlY29yYXRpb246IG1hdGNoID0+IGdldFdoaXRlc3BhY2VEZWNvKG1hdGNoWzBdKSxcbiAgICBib3VuZGFyeTogL1xcUy8sXG59KSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlnaGxpZ2h0cyB3aGl0ZXNwYWNlLCBhZGRpbmcgYVxuYGNtLWhpZ2hsaWdodFNwYWNlYCBjbGFzcyB0byBzdHJldGNoZXMgb2Ygc3BhY2VzLCBhbmQgYVxuYGNtLWhpZ2hsaWdodFRhYmAgY2xhc3MgdG8gaW5kaXZpZHVhbCB0YWIgY2hhcmFjdGVycy4gQnkgZGVmYXVsdCxcbnRoZSBmb3JtZXIgYXJlIHNob3duIGFzIGZhaW50IGRvdHMsIGFuZCB0aGUgbGF0dGVyIGFzIGFycm93cy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRXaGl0ZXNwYWNlKCkge1xuICAgIHJldHVybiB3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXI7XG59XG5jb25zdCB0cmFpbGluZ0hpZ2hsaWdodGVyID0gLypAX19QVVJFX18qL21hdGNoZXIoLypAX19QVVJFX18qL25ldyBNYXRjaERlY29yYXRvcih7XG4gICAgcmVnZXhwOiAvXFxzKyQvZyxcbiAgICBkZWNvcmF0aW9uOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tdHJhaWxpbmdTcGFjZVwiIH0pLFxuICAgIGJvdW5kYXJ5OiAvXFxTLyxcbn0pKTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLXRyYWlsaW5nU3BhY2VgIGNsYXNzIHRvIGFsbFxudHJhaWxpbmcgd2hpdGVzcGFjZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRyYWlsaW5nSGlnaGxpZ2h0ZXI7XG59XG5cbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX190ZXN0ID0geyBIZWlnaHRNYXAsIEhlaWdodE9yYWNsZSwgTWVhc3VyZWRIZWlnaHRzLCBRdWVyeVR5cGUsIENoYW5nZWRSYW5nZSwgY29tcHV0ZU9yZGVyLCBtb3ZlVmlzdWFsbHkgfTtcblxuZXhwb3J0IHsgQmlkaVNwYW4sIEJsb2NrSW5mbywgQmxvY2tUeXBlLCBEZWNvcmF0aW9uLCBEaXJlY3Rpb24sIEVkaXRvclZpZXcsIEd1dHRlck1hcmtlciwgTWF0Y2hEZWNvcmF0b3IsIFJlY3RhbmdsZU1hcmtlciwgVmlld1BsdWdpbiwgVmlld1VwZGF0ZSwgV2lkZ2V0VHlwZSwgX190ZXN0LCBjbG9zZUhvdmVyVG9vbHRpcHMsIGNyb3NzaGFpckN1cnNvciwgZHJhd1NlbGVjdGlvbiwgZHJvcEN1cnNvciwgZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZywgZ2V0UGFuZWwsIGdldFRvb2x0aXAsIGd1dHRlciwgZ3V0dGVyTGluZUNsYXNzLCBndXR0ZXJzLCBoYXNIb3ZlclRvb2x0aXBzLCBoaWdobGlnaHRBY3RpdmVMaW5lLCBoaWdobGlnaHRBY3RpdmVMaW5lR3V0dGVyLCBoaWdobGlnaHRTcGVjaWFsQ2hhcnMsIGhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSwgaGlnaGxpZ2h0V2hpdGVzcGFjZSwgaG92ZXJUb29sdGlwLCBrZXltYXAsIGxheWVyLCBsaW5lTnVtYmVyTWFya2VycywgbGluZU51bWJlcnMsIGxvZ0V4Y2VwdGlvbiwgcGFuZWxzLCBwbGFjZWhvbGRlciwgcmVjdGFuZ3VsYXJTZWxlY3Rpb24sIHJlcG9zaXRpb25Ub29sdGlwcywgcnVuU2NvcGVIYW5kbGVycywgc2Nyb2xsUGFzdEVuZCwgc2hvd1BhbmVsLCBzaG93VG9vbHRpcCwgdG9vbHRpcHMgfTtcbiJdLCJuYW1lcyI6WyJUZXh0IiwiUmFuZ2VTZXQiLCJNYXBNb2RlIiwiUmFuZ2VWYWx1ZSIsImZpbmRDbHVzdGVyQnJlYWsiLCJFZGl0b3JTZWxlY3Rpb24iLCJGYWNldCIsIlN0YXRlRWZmZWN0IiwiQ2hhbmdlU2V0IiwiZmluZENvbHVtbiIsIkNoYXJDYXRlZ29yeSIsIkFubm90YXRpb24iLCJFZGl0b3JTdGF0ZSIsIlRyYW5zYWN0aW9uIiwiUHJlYyIsImNvZGVQb2ludEF0IiwiY29kZVBvaW50U2l6ZSIsImNvbWJpbmVDb25maWciLCJTdGF0ZUZpZWxkIiwiUmFuZ2VTZXRCdWlsZGVyIiwiY291bnRDb2x1bW4iLCJTdHlsZU1vZHVsZSIsImtleU5hbWUiLCJiYXNlIiwic2hpZnQiLCJnZXRTZWxlY3Rpb24iLCJyb290IiwidGFyZ2V0Iiwibm9kZVR5cGUiLCJvd25lckRvY3VtZW50IiwiY29udGFpbnMiLCJkb20iLCJub2RlIiwicGFyZW50Tm9kZSIsImRlZXBBY3RpdmVFbGVtZW50IiwiZG9jIiwiZWx0IiwiYWN0aXZlRWxlbWVudCIsInNoYWRvd1Jvb3QiLCJoYXNTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwiXyIsImNsaWVudFJlY3RzRm9yIiwidGV4dFJhbmdlIiwibm9kZVZhbHVlIiwibGVuZ3RoIiwiZ2V0Q2xpZW50UmVjdHMiLCJpc0VxdWl2YWxlbnRQb3NpdGlvbiIsIm9mZiIsInRhcmdldE5vZGUiLCJ0YXJnZXRPZmYiLCJzY2FuRm9yIiwiZG9tSW5kZXgiLCJpbmRleCIsInByZXZpb3VzU2libGluZyIsImRpciIsIm1heE9mZnNldCIsIm5vZGVOYW1lIiwicGFyZW50IiwiY2hpbGROb2RlcyIsImNvbnRlbnRFZGl0YWJsZSIsImZsYXR0ZW5SZWN0IiwicmVjdCIsImxlZnQiLCJ4IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJ3aW5kb3dSZWN0Iiwid2luIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiZ2V0U2NhbGUiLCJzY2FsZVgiLCJ3aWR0aCIsIm9mZnNldFdpZHRoIiwic2NhbGVZIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiaXNGaW5pdGUiLCJNYXRoIiwiYWJzIiwic2Nyb2xsUmVjdEludG9WaWV3Iiwic2lkZSIsInkiLCJ4TWFyZ2luIiwieU1hcmdpbiIsImx0ciIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiY3VyIiwic3RvcCIsImJvdW5kaW5nIiwiYm9keSIsInRlc3QiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwiYXNzaWduZWRTbG90IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibW92ZVgiLCJtb3ZlWSIsInJlY3RIZWlnaHQiLCJib3VuZGluZ0hlaWdodCIsInRhcmdldFRvcCIsInRhcmdldExlZnQiLCJzY3JvbGxCeSIsIm1vdmVkWCIsIm1vdmVkWSIsInN0YXJ0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsImhvc3QiLCJzY3JvbGxhYmxlUGFyZW50IiwiRE9NU2VsZWN0aW9uU3RhdGUiLCJjb25zdHJ1Y3RvciIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiZXEiLCJkb21TZWwiLCJzZXRSYW5nZSIsInJhbmdlIiwic2V0IiwibWluIiwicHJldmVudFNjcm9sbFN1cHBvcnRlZCIsImZvY3VzUHJldmVudFNjcm9sbCIsInNldEFjdGl2ZSIsImZvY3VzIiwic3RhY2siLCJwdXNoIiwicHJldmVudFNjcm9sbCIsInVuZGVmaW5lZCIsImkiLCJzY3JhdGNoUmFuZ2UiLCJmcm9tIiwidG8iLCJkb2N1bWVudCIsImNyZWF0ZVJhbmdlIiwic2V0RW5kIiwic2V0U3RhcnQiLCJkaXNwYXRjaEtleSIsIm5hbWUiLCJjb2RlIiwib3B0aW9ucyIsImtleSIsImtleUNvZGUiLCJ3aGljaCIsImNhbmNlbGFibGUiLCJkb3duIiwiS2V5Ym9hcmRFdmVudCIsInN5bnRoZXRpYyIsImRpc3BhdGNoRXZlbnQiLCJ1cCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJnZXRSb290IiwiY2xlYXJBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsInJlbW92ZUF0dHJpYnV0ZU5vZGUiLCJhdEVsZW1lbnRTdGFydCIsIm9mZnNldCIsInByZXYiLCJpc1Njcm9sbGVkVG9Cb3R0b20iLCJtYXgiLCJET01Qb3MiLCJwcmVjaXNlIiwiYmVmb3JlIiwiYWZ0ZXIiLCJub0NoaWxkcmVuIiwiQ29udGVudFZpZXciLCJmbGFncyIsIm92ZXJyaWRlRE9NVGV4dCIsInBvc0F0U3RhcnQiLCJwb3NCZWZvcmUiLCJwb3NBdEVuZCIsInZpZXciLCJwb3MiLCJjaGlsZCIsImNoaWxkcmVuIiwiYnJlYWtBZnRlciIsIlJhbmdlRXJyb3IiLCJwb3NBZnRlciIsInN5bmMiLCJ0cmFjayIsIm5leHQiLCJuZXh0U2libGluZyIsImZpcnN0Q2hpbGQiLCJjb250ZW50VmlldyIsImdldCIsImNhblJldXNlRE9NIiwicmV1c2VET00iLCJ3cml0dGVuIiwicm0kMSIsImluc2VydEJlZm9yZSIsIl9kb20iLCJsb2NhbFBvc0Zyb21ET00iLCJiaWFzIiwibGFzdENoaWxkIiwiZG9tQm91bmRzQXJvdW5kIiwiZnJvbUkiLCJmcm9tU3RhcnQiLCJ0b0kiLCJ0b0VuZCIsInByZXZFbmQiLCJlbmQiLCJzdGFydERPTSIsImVuZERPTSIsIm1hcmtEaXJ0eSIsImFuZFBhcmVudCIsIm1hcmtQYXJlbnRzRGlydHkiLCJjaGlsZExpc3QiLCJzZXRQYXJlbnQiLCJzZXRET00iLCJjbVZpZXciLCJyb290VmlldyIsInYiLCJyZXBsYWNlQ2hpbGRyZW4iLCJpbmRleE9mIiwiZGVzdHJveSIsInNwbGljZSIsImlnbm9yZU11dGF0aW9uIiwiX3JlYyIsImlnbm9yZUV2ZW50IiwiX2V2ZW50IiwiY2hpbGRDdXJzb3IiLCJDaGlsZEN1cnNvciIsImNoaWxkUG9zIiwiZmluZFBvcyIsInRvU3RyaW5nIiwicmVwbGFjZSIsImpvaW4iLCJ0ZXh0IiwiaXNFZGl0YWJsZSIsImlzV2lkZ2V0IiwiaXNIaWRkZW4iLCJtZXJnZSIsInNvdXJjZSIsImhhc1N0YXJ0Iiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsImJlY29tZSIsIm90aGVyIiwiZ2V0U2lkZSIsInByb3RvdHlwZSIsInJlbW92ZUNoaWxkIiwicmVwbGFjZVJhbmdlIiwiZnJvbU9mZiIsInRvT2ZmIiwiaW5zZXJ0IiwiYnJlYWtBdFN0YXJ0IiwibGFzdCIsImJyZWFrQXRFbmQiLCJzcGxpdCIsInBvcCIsIm1lcmdlQ2hpbGRyZW5JbnRvIiwiZExlbiIsIm5hdiIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInZlbmRvciIsInBsYXRmb3JtIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJpZV9lZGdlIiwiZXhlYyIsImllX3VwdG8xMCIsImllXzExdXAiLCJpZSIsImdlY2tvIiwiY2hyb21lIiwid2Via2l0Iiwic2FmYXJpIiwiaW9zIiwibWF4VG91Y2hQb2ludHMiLCJicm93c2VyIiwibWFjIiwid2luZG93cyIsImxpbnV4IiwiaWVfdmVyc2lvbiIsImRvY3VtZW50TW9kZSIsImdlY2tvX3ZlcnNpb24iLCJjaHJvbWVfdmVyc2lvbiIsImFuZHJvaWQiLCJ3ZWJraXRfdmVyc2lvbiIsInRhYlNpemUiLCJNYXhKb2luTGVuIiwiVGV4dFZpZXciLCJjcmVhdGVET00iLCJ0ZXh0RE9NIiwiY3JlYXRlVGV4dE5vZGUiLCJzbGljZSIsInJlc3VsdCIsImRvbUF0UG9zIiwiX2Zyb20iLCJfdG8iLCJjb29yZHNBdCIsInRleHRDb29yZHMiLCJNYXJrVmlldyIsIm1hcmsiLCJjaCIsInNldEF0dHJzIiwiY2xhc3MiLCJjbGFzc05hbWUiLCJhdHRycyIsInNldEF0dHJpYnV0ZSIsInRhZ05hbWUiLCJ0b1VwcGVyQ2FzZSIsImNyZWF0ZUVsZW1lbnQiLCJfaGFzU3RhcnQiLCJkZXRhY2hGcm9tIiwiaW5saW5lRE9NQXRQb3MiLCJjb29yZHNJbkNoaWxkcmVuIiwiZmxhdHRlbiIsInJlY3RzIiwiQXJyYXkiLCJmaW5kIiwiY2FsbCIsInIiLCJXaWRnZXRWaWV3IiwiY3JlYXRlIiwid2lkZ2V0IiwicHJldldpZGdldCIsInVwZGF0ZURPTSIsInRvRE9NIiwiZWRpdGFibGUiLCJjb21wYXJlIiwiZXZlbnQiLCJlbXB0eSIsInN0YXRlIiwiY3VzdG9tIiwiZnJvbUJhY2siLCJXaWRnZXRCdWZmZXJWaWV3IiwiaiIsImpvaW5JbmxpbmVJbnRvIiwib3BlbiIsImJlZm9yZVBvcyIsImFmdGVyUG9zIiwic2NhbiIsImZhbGxiYWNrUmVjdCIsImNvbWJpbmVBdHRycyIsIm5vQXR0cnMiLCJPYmplY3QiLCJhdHRyc0VxIiwiYSIsImIiLCJpZ25vcmUiLCJrZXlzQSIsImtleXMiLCJrZXlzQiIsInVwZGF0ZUF0dHJzIiwiY2hhbmdlZCIsImNzc1RleHQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJnZXRBdHRycyIsImF0dHIiLCJ2YWx1ZSIsIkxpbmVWaWV3IiwiYXJndW1lbnRzIiwicHJldkF0dHJzIiwidHJhbnNmZXJET00iLCJzZXREZWNvIiwiYXQiLCJhcHBlbmQiLCJhZGRMaW5lRGVjbyIsImRlY28iLCJzcGVjIiwiY2xzIiwiX2EiLCJjbGFzc0xpc3QiLCJhZGQiLCJzb21lIiwiaGFjayIsImNtSWdub3JlIiwiYXBwZW5kQ2hpbGQiLCJtZWFzdXJlVGV4dFNpemUiLCJ0b3RhbFdpZHRoIiwidGV4dEhlaWdodCIsImxpbmVIZWlnaHQiLCJjaGFyV2lkdGgiLCJoZWlnaHRPcmFjbGUiLCJ2aWV3U3RhdGUiLCJkaXN0IiwiX290aGVyIiwiY292ZXJzIiwiZG9jVmlldyIsImJsb2NrIiwiQmxvY2tXaWRnZXRWaWV3IiwiX3Rha2VEZWNvIiwibGVuIiwic3RhcnRTaWRlIiwiZW5kU2lkZSIsIldpZGdldFR5cGUiLCJlc3RpbWF0ZWRIZWlnaHQiLCJsaW5lQnJlYWtzIiwiQmxvY2tUeXBlIiwiRGVjb3JhdGlvbiIsImhlaWdodFJlbGV2YW50IiwiTWFya0RlY29yYXRpb24iLCJpbmxpbmVPcmRlciIsIlBvaW50RGVjb3JhdGlvbiIsImlzQmxvY2tHYXAiLCJnZXRJbmNsdXNpdmUiLCJsaW5lIiwiTGluZURlY29yYXRpb24iLCJvZiIsInNvcnQiLCJoYXNIZWlnaHQiLCJub25lIiwiX2IiLCJwb2ludCIsIm1hcE1vZGUiLCJUcmFja0JlZm9yZSIsImlzUmVwbGFjZSIsIlRyYWNrRGVsIiwiVHJhY2tBZnRlciIsInR5cGUiLCJXaWRnZXRSYW5nZSIsIldpZGdldEJlZm9yZSIsIldpZGdldEFmdGVyIiwid2lkZ2V0c0VxIiwiaW5jbHVzaXZlU3RhcnQiLCJpbmNsdXNpdmVFbmQiLCJpbmNsdXNpdmUiLCJhZGRSYW5nZSIsInJhbmdlcyIsIm1hcmdpbiIsIkNvbnRlbnRCdWlsZGVyIiwiZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IiLCJjb250ZW50IiwiY3VyTGluZSIsInBlbmRpbmdCdWZmZXIiLCJidWZmZXJNYXJrcyIsImF0Q3Vyc29yUG9zIiwidGV4dE9mZiIsImN1cnNvciIsIml0ZXIiLCJza2lwIiwicG9zQ292ZXJlZCIsImxpbmVBdCIsImdldExpbmUiLCJmbHVzaEJ1ZmZlciIsImFjdGl2ZSIsIndyYXBNYXJrcyIsImFkZEJsb2NrV2lkZ2V0IiwiZmluaXNoIiwiYnVpbGRUZXh0IiwibGluZUJyZWFrIiwiZG9uZSIsIkVycm9yIiwidGFrZSIsInNwYW4iLCJOdWxsV2lkZ2V0IiwiY3Vyc29yQmVmb3JlIiwiY3Vyc29yQWZ0ZXIiLCJidWlsZCIsImRlY29yYXRpb25zIiwiZHluYW1pY0RlY29yYXRpb25NYXAiLCJidWlsZGVyIiwic3BhbnMiLCJ0YWciLCJ0b0xvd2VyQ2FzZSIsIkRpcmVjdGlvbiIsIkxUUiIsIlJUTCIsImRlYyIsInN0ciIsIkxvd1R5cGVzIiwiQXJhYmljVHlwZXMiLCJCcmFja2V0cyIsIkJyYWNrZXRTdGFjayIsInAiLCJsIiwiY2hhckNvZGVBdCIsImNoYXJUeXBlIiwiQmlkaVJFIiwiQmlkaVNwYW4iLCJsZXZlbCIsImZvcndhcmQiLCJvcmRlciIsImFzc29jIiwibWF5YmUiLCJpc29sYXRlc0VxIiwiaUEiLCJpQiIsImRpcmVjdGlvbiIsImlubmVyIiwidHlwZXMiLCJjb21wdXRlQ2hhclR5cGVzIiwickZyb20iLCJyVG8iLCJpc29sYXRlcyIsIm91dGVyVHlwZSIsImlJIiwicHJldlR5cGUiLCJwcmV2U3Ryb25nIiwicHJvY2Vzc0JyYWNrZXRQYWlycyIsIm9wcG9zaXRlVHlwZSIsInNJIiwiY29udGV4dCIsImJyIiwic0oiLCJlbWJlZCIsInByb2Nlc3NOZXV0cmFscyIsImJlZm9yZUwiLCJhZnRlckwiLCJqSSIsImZyb21KIiwiZW1pdFNwYW5zIiwiYmFzZUxldmVsIiwib3VyVHlwZSIsImlDaCIsInNhbWVEaXIiLCJpc051bSIsInJlY3Vyc2UiLCJsb2NhbExldmVsIiwiaVNjYW4iLCJydW4iLCJpc28iLCJ1cHRvIiwiZGlyU3dhcCIsImNvbXB1dGVTZWN0aW9uT3JkZXIiLCJjb21wdXRlT3JkZXIiLCJ0cml2aWFsT3JkZXIiLCJtb3ZlZE92ZXIiLCJtb3ZlVmlzdWFsbHkiLCJzdGFydEluZGV4IiwiaGVhZCIsInNwYW5JIiwiYmlkaUxldmVsIiwic3BhbkVuZCIsIm5leHRJIiwibmV4dEluZGV4IiwibmV4dFNwYW4iLCJhdXRvRGlyZWN0aW9uIiwiY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UiLCJkZWZpbmUiLCJkcmFnTW92ZXNTZWxlY3Rpb24kMSIsIm1vdXNlU2VsZWN0aW9uU3R5bGUiLCJleGNlcHRpb25TaW5rIiwidXBkYXRlTGlzdGVuZXIiLCJpbnB1dEhhbmRsZXIiLCJmb2N1c0NoYW5nZUVmZmVjdCIsInBlckxpbmVUZXh0RGlyZWN0aW9uIiwiY29tYmluZSIsInZhbHVlcyIsIm5hdGl2ZVNlbGVjdGlvbkhpZGRlbiIsIlNjcm9sbFRhcmdldCIsImlzU25hcHNob3QiLCJtYXAiLCJjaGFuZ2VzIiwiY2xpcCIsInNjcm9sbEludG9WaWV3IiwidCIsImxvZ0V4Y2VwdGlvbiIsImV4Y2VwdGlvbiIsImhhbmRsZXIiLCJmYWNldCIsIm9uZXJyb3IiLCJTdHJpbmciLCJjb25zb2xlIiwiZXJyb3IiLCJuZXh0UGx1Z2luSUQiLCJ2aWV3UGx1Z2luIiwiVmlld1BsdWdpbiIsImlkIiwiZG9tRXZlbnRIYW5kbGVycyIsImRvbUV2ZW50T2JzZXJ2ZXJzIiwiYnVpbGRFeHRlbnNpb25zIiwiZXh0ZW5zaW9uIiwiZXZlbnRIYW5kbGVycyIsImV2ZW50T2JzZXJ2ZXJzIiwicHJvdmlkZSIsInBsdWdpbiIsImV4dCIsInBsdWdpbkluc3QiLCJmcm9tQ2xhc3MiLCJQbHVnaW5JbnN0YW5jZSIsIm11c3RVcGRhdGUiLCJ1cGRhdGUiLCJlIiwiZGVhY3RpdmF0ZSIsImVkaXRvckF0dHJpYnV0ZXMiLCJjb250ZW50QXR0cmlidXRlcyIsIm91dGVyRGVjb3JhdGlvbnMiLCJhdG9taWNSYW5nZXMiLCJiaWRpSXNvbGF0ZWRSYW5nZXMiLCJnZXRJc29sYXRlZFJhbmdlcyIsInNldHMiLCJGdW5jdGlvbiIsImZyb21Eb2MiLCJ0b0RvYyIsImJpZGlJc29sYXRlIiwic2Nyb2xsTWFyZ2lucyIsImdldFNjcm9sbE1hcmdpbnMiLCJtIiwic3R5bGVNb2R1bGUiLCJDaGFuZ2VkUmFuZ2UiLCJmcm9tQSIsInRvQSIsImZyb21CIiwidG9CIiwiYWRkVG9TZXQiLCJtZSIsImV4dGVuZFdpdGhSYW5nZXMiLCJkaWZmIiwiZEkiLCJySSIsInBvc0EiLCJwb3NCIiwiVmlld1VwZGF0ZSIsInRyYW5zYWN0aW9ucyIsInN0YXJ0U3RhdGUiLCJ0ciIsImNvbXBvc2UiLCJjaGFuZ2VkUmFuZ2VzIiwiaXRlckNoYW5nZWRSYW5nZXMiLCJ2aWV3cG9ydENoYW5nZWQiLCJoZWlnaHRDaGFuZ2VkIiwiZ2VvbWV0cnlDaGFuZ2VkIiwiZG9jQ2hhbmdlZCIsImZvY3VzQ2hhbmdlZCIsInNlbGVjdGlvblNldCIsIkRvY1ZpZXciLCJkb21DaGFuZ2VkIiwiaGFzQ29tcG9zaXRpb24iLCJtYXJrZWRGb3JDb21wb3NpdGlvbiIsIlNldCIsIm1pbldpZHRoIiwibWluV2lkdGhGcm9tIiwibWluV2lkdGhUbyIsImltcHJlY2lzZUFuY2hvciIsImltcHJlY2lzZUhlYWQiLCJmb3JjZVNlbGVjdGlvbiIsImxhc3RVcGRhdGUiLCJEYXRlIiwibm93IiwiY29udGVudERPTSIsInVwZGF0ZURlY28iLCJ1cGRhdGVJbm5lciIsImV2ZXJ5IiwibWFwUG9zIiwicmVhZENvbXBvc2l0aW9uQXQiLCJpbnB1dFN0YXRlIiwiY29tcG9zaW5nIiwibmV3U2VsIiwidG91Y2hlc0NvbXBvc2l0aW9uIiwibWFpbiIsImNvbXBvc2l0aW9uIiwiZmluZENvbXBvc2l0aW9uUmFuZ2UiLCJjbGVhciIsImxpbmVzIiwicHJldkRlY28iLCJkZWNvRGlmZiIsImZpbmRDaGFuZ2VkRGVjbyIsIm9sZExlbmd0aCIsIm11c3RNZWFzdXJlQ29udGVudCIsInVwZGF0ZUNoaWxkcmVuIiwib2JzZXJ2ZXIiLCJjb250ZW50SGVpZ2h0IiwiZmxleEJhc2lzIiwic2VsZWN0aW9uUmFuZ2UiLCJmb3JFYWNoIiwiY1ZpZXciLCJnYXBzIiwidmlld3BvcnQiLCJCbG9ja0dhcFdpZGdldCIsInVwZGF0ZUdhcHMiLCJjb21wTGluZSIsImNvbXBvc2l0aW9uVmlldyIsImNvbmNhdCIsImZpeENvbXBvc2l0aW9uRE9NIiwibWFya3MiLCJmaXgiLCJjIiwidXBkYXRlU2VsZWN0aW9uIiwibXVzdFJlYWQiLCJmcm9tUG9pbnRlciIsInJlYWRTZWxlY3Rpb25SYW5nZSIsImFjdGl2ZUVsdCIsImZvY3VzZWQiLCJzZWxlY3Rpb25Ob3RGb2N1cyIsImZvcmNlIiwiYW5jaG9yIiwibW92ZVRvTGluZSIsImJldHdlZW5VbmVkaXRhYmxlIiwiZHVtbXkiLCJzdXBwcmVzc1dpZGdldEN1cnNvckNoYW5nZSIsImluVW5lZGl0YWJsZSIsImJsdXIiLCJyYXdTZWwiLCJuZXh0VG8iLCJuZXh0VG9VbmVkaXRhYmxlIiwibmVhcmJ5VGV4dE5vZGUiLCJjb2xsYXBzZSIsImNhcmV0QmlkaUxldmVsIiwiZXh0ZW5kIiwicmVtb3ZlQWxsUmFuZ2VzIiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJzZWwiLCJwb3NGcm9tRE9NIiwiZW5mb3JjZUN1cnNvckFzc29jIiwibW9kaWZ5IiwibGluZVN0YXJ0IiwibmV3UmFuZ2UiLCJuZXdQb3MiLCJuZWFyZXN0IiwiZG9tVmlldyIsImJlc3QiLCJiZXN0UG9zIiwiY29vcmRzRm9yQ2hhciIsImNoaWxkT2ZmIiwibWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyIsImNvbnRlbnRXaWR0aCIsImlzV2lkZXIiLCJzY3JvbGxET00iLCJ3aWRlc3QiLCJ0ZXh0RGlyZWN0aW9uIiwiY2hpbGRSZWN0IiwidGV4dERpcmVjdGlvbkF0IiwibWVhc3VyZSIsInRleHRDb250ZW50IiwicmVtb3ZlIiwiY29tcHV0ZUJsb2NrR2FwRGVjbyIsInZzIiwidmlld3BvcnRzIiwibGluZUJsb2NrQXQiLCJhbGxEZWNvIiwiZCIsImR5bmFtaWMiLCJkeW5hbWljT3V0ZXIiLCJvdXRlckRlY28iLCJsaW5lR2FwRGVjbyIsInJlZiIsIm1hcmdpbnMiLCJ0YXJnZXRSZWN0IiwiZmluZENvbXBvc2l0aW9uTm9kZSIsImhlYWRQb3MiLCJ0ZXh0Tm9kZSIsImZvdW5kIiwic2xpY2VTdHJpbmciLCJpbnYiLCJpbnZlcnRlZERlc2MiLCJwYXJlbnRWaWV3Iiwic3RhcnROb2RlIiwic3RhcnRPZmZzZXQiLCJEZWNvcmF0aW9uQ29tcGFyYXRvciQxIiwiRGVjb3JhdGlvbkNvbXBhcmF0b3IiLCJjb21wYXJlUmFuZ2UiLCJjb21wYXJlUG9pbnQiLCJjb21wIiwiaW5zaWRlIiwidG91Y2hlZCIsImdyb3VwQXQiLCJjYXRlZ29yaXplIiwiY2hhckNhdGVnb3JpemVyIiwibGluZVBvcyIsImNhdCIsImdldGR4IiwiZ2V0ZHkiLCJ5T3ZlcmxhcCIsInVwVG9wIiwidXBCb3QiLCJkb21Qb3NBdENvb3JkcyIsImNsb3Nlc3QiLCJjbG9zZXN0UmVjdCIsImNsb3Nlc3RYIiwiY2xvc2VzdFkiLCJjbG9zZXN0T3ZlcmxhcCIsImFib3ZlIiwiYmVsb3ciLCJhYm92ZVJlY3QiLCJiZWxvd1JlY3QiLCJkeCIsImR5IiwiZG9tUG9zSW5UZXh0IiwiY2xpcFgiLCJjbG9zZXN0T2Zmc2V0IiwiY2xvc2VzdERZIiwiZ2VuZXJhbFNpZGUiLCJyZWN0QmVmb3JlIiwicG9zQXRDb29yZHMiLCJjb29yZHMiLCJkb2NUb3AiLCJwYWRkaW5nVG9wIiwiZG9jSGVpZ2h0IiwieU9mZnNldCIsImhhbGZMaW5lIiwiYm91bmNlZCIsImVsZW1lbnRBdEhlaWdodCIsInBvc0F0Q29vcmRzSW1wcmVjaXNlIiwiZWxlbWVudEZyb21Qb2ludCIsImVsZW1lbnQiLCJjYXJldFBvc2l0aW9uRnJvbVBvaW50Iiwib2Zmc2V0Tm9kZSIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJzdGFydENvbnRhaW5lciIsImlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0IiwiaXNTdXNwaWNpb3VzQ2hyb21lQ2FyZXRSZXN1bHQiLCJjb250ZW50UmVjdCIsImludG8iLCJyb3VuZCIsImRlZmF1bHRDaGFyYWN0ZXJXaWR0aCIsImxpbmVXcmFwcGluZyIsImRlZmF1bHRMaW5lSGVpZ2h0IiwiZmxvb3IiLCJsaW5lTGVuZ3RoIiwic2xpY2VEb2MiLCJibG9ja0F0IiwiaXNBcnJheSIsIm1vdmVUb0xpbmVCb3VuZGFyeSIsImluY2x1ZGVXcmFwIiwid2lkZ2V0TGluZUJyZWFrcyIsImNvb3Jkc0F0UG9zIiwiZWRpdG9yUmVjdCIsIm1vdmVCeUNoYXIiLCJieSIsImJpZGlTcGFucyIsImNoZWNrIiwiY2hhciIsIm51bWJlciIsInZpc3VhbExpbmVTaWRlIiwiYnlHcm91cCIsIm5leHRDYXQiLCJTcGFjZSIsIm1vdmVWZXJ0aWNhbGx5IiwiZGlzdGFuY2UiLCJzdGFydFBvcyIsImdvYWwiLCJnb2FsQ29sdW1uIiwic3RhcnRZIiwic3RhcnRDb29yZHMiLCJkb2N1bWVudFRvcCIsInJlc29sdmVkR29hbCIsImV4dHJhIiwiY3VyWSIsImNoYXJSZWN0Iiwic2tpcEF0b21pY1JhbmdlcyIsImF0b21zIiwibW92ZWQiLCJiZXR3ZWVuIiwic2tpcEF0b21zIiwib2xkUG9zIiwiZiIsIklucHV0U3RhdGUiLCJzZXRTZWxlY3Rpb25PcmlnaW4iLCJvcmlnaW4iLCJsYXN0U2VsZWN0aW9uT3JpZ2luIiwibGFzdFNlbGVjdGlvblRpbWUiLCJsYXN0S2V5Q29kZSIsImxhc3RLZXlUaW1lIiwibGFzdFRvdWNoVGltZSIsImxhc3RGb2N1c1RpbWUiLCJsYXN0U2Nyb2xsVG9wIiwibGFzdFNjcm9sbExlZnQiLCJwZW5kaW5nSU9TS2V5IiwibGFzdEVzY1ByZXNzIiwibGFzdENvbnRleHRNZW51Iiwic2Nyb2xsSGFuZGxlcnMiLCJoYW5kbGVycyIsImNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UiLCJjb21wb3NpdGlvbkVuZGVkQXQiLCJjb21wb3NpdGlvblBlbmRpbmdLZXkiLCJjb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UiLCJtb3VzZVNlbGVjdGlvbiIsImRyYWdnZWRDb250ZW50IiwiaGFuZGxlRXZlbnQiLCJiaW5kIiwibm90aWZpZWRGb2N1c2VkIiwiaGFzRm9jdXMiLCJhZGRFdmVudExpc3RlbmVyIiwiZmlyZWZveENvcHlDdXRIYWNrIiwiZXZlbnRCZWxvbmdzVG9FZGl0b3IiLCJpZ25vcmVEdXJpbmdDb21wb3NpdGlvbiIsImtleWRvd24iLCJydW5IYW5kbGVycyIsIm9ic2VydmVycyIsInByZXZlbnREZWZhdWx0IiwiZW5zdXJlSGFuZGxlcnMiLCJwbHVnaW5zIiwiY29tcHV0ZUhhbmRsZXJzIiwicGFzc2l2ZSIsImV4aXN0cyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtb2RpZmllckNvZGVzIiwiZGVsYXlBbmRyb2lkS2V5IiwicGVuZGluZyIsImFsdEtleSIsIm1ldGFLZXkiLCJQZW5kaW5nS2V5cyIsImN0cmxLZXkiLCJFbWFjc3lQZW5kaW5nS2V5cyIsInNoaWZ0S2V5Iiwic2V0VGltZW91dCIsImZsdXNoSU9TS2V5IiwiZm9yY2VGbHVzaCIsInN0YXJ0TW91c2VTZWxlY3Rpb24iLCJiaW5kSGFuZGxlciIsInJlY29yZCIsImlucHV0VHlwZSIsImRyYWdTY3JvbGxNYXJnaW4iLCJkcmFnU2Nyb2xsU3BlZWQiLCJjbGllbnRYIiwiY2xpZW50WSIsIk1vdXNlU2VsZWN0aW9uIiwic3RhcnRFdmVudCIsIm11c3RTZWxlY3QiLCJzY3JvbGxTcGVlZCIsInNjcm9sbGluZyIsImxhc3RFdmVudCIsInNjcm9sbFBhcmVudCIsIm1vdmUiLCJtdWx0aXBsZSIsImFsbG93TXVsdGlwbGVTZWxlY3Rpb25zIiwiYWRkc1NlbGVjdGlvblJhbmdlIiwiZHJhZ2dpbmciLCJpc0luUHJpbWFyeVNlbGVjdGlvbiIsImdldENsaWNrVHlwZSIsInNlbGVjdCIsImJ1dHRvbnMiLCJzeCIsInN5Iiwic2V0U2Nyb2xsU3BlZWQiLCJzZXRJbnRlcnZhbCIsInNjcm9sbCIsImNsZWFySW50ZXJ2YWwiLCJ1cGRhdGVkIiwibWFpbkluZGV4IiwiZGlzcGF0Y2giLCJ1c2VyRXZlbnQiLCJkcmFnTW92ZXNTZWxlY3Rpb24iLCJyYW5nZUNvdW50IiwiZ2V0UmFuZ2VBdCIsImJ1YmJsZXMiLCJicm9rZW5DbGlwYm9hcmRBUEkiLCJjYXB0dXJlUGFzdGUiLCJkb1Bhc3RlIiwiaW5wdXQiLCJ0b1RleHQiLCJieUxpbmUiLCJsaW5ld2lzZSIsImxhc3RMaW5ld2lzZUNvcHkiLCJsYXN0TGluZSIsImNoYW5nZUJ5UmFuZ2UiLCJyZXBsYWNlU2VsZWN0aW9uIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsIm1vdXNlZG93biIsImZsdXNoIiwibWFrZVN0eWxlIiwiYnV0dG9uIiwiYmFzaWNNb3VzZVNlbGVjdGlvbiIsIm11c3RGb2N1cyIsIm1vdXNlU2VsIiwicmFuZ2VGb3JDbGljayIsInZpc3VhbCIsImluc2lkZVkiLCJmaW5kUG9zaXRpb25TaWRlIiwicXVlcnlQb3MiLCJCYWRNb3VzZURldGFpbCIsImxhc3RNb3VzZURvd24iLCJsYXN0TW91c2VEb3duQ291bnQiLCJsYXN0TW91c2VEb3duVGltZSIsImRldGFpbCIsImxhc3RUaW1lIiwic3RhcnRTZWwiLCJyZW1vdmVkIiwic3RhcnRSYW5nZSIsInJlbW92ZVJhbmdlQXJvdW5kIiwiZHJhZ3N0YXJ0IiwiZHJhZ2dhYmxlIiwiZGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsImVmZmVjdEFsbG93ZWQiLCJkcmFnZW5kIiwiZHJvcFRleHQiLCJkaXJlY3QiLCJkcm9wUG9zIiwiZGVsIiwiaW5zIiwiZHJvcCIsInJlYWRPbmx5IiwiZmlsZXMiLCJyZWFkIiwiZmluaXNoRmlsZSIsImZpbHRlciIsInMiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwicmVhZEFzVGV4dCIsImdldERhdGEiLCJwYXN0ZSIsImRhdGEiLCJjbGlwYm9hcmREYXRhIiwiY2FwdHVyZUNvcHkiLCJzZWxlY3Rpb25FbmQiLCJzZWxlY3Rpb25TdGFydCIsImNvcGllZFJhbmdlIiwiY29weSIsImN1dCIsImNsZWFyRGF0YSIsImlzRm9jdXNDaGFuZ2UiLCJmb2N1c0NoYW5nZVRyYW5zYWN0aW9uIiwiZWZmZWN0cyIsImdldEVmZmVjdCIsImVmZmVjdCIsImFubm90YXRpb25zIiwidXBkYXRlRm9yRm9jdXNDaGFuZ2UiLCJjbGVhclNlbGVjdGlvblJhbmdlIiwiY29tcG9zaXRpb25zdGFydCIsImNvbXBvc2l0aW9udXBkYXRlIiwiY29tcG9zaXRpb25lbmQiLCJwZW5kaW5nUmVjb3JkcyIsImZsdXNoU29vbiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImNvbnRleHRtZW51IiwiYmVmb3JlaW5wdXQiLCJzdGFydFZpZXdIZWlnaHQiLCJ2aXN1YWxWaWV3cG9ydCIsImFwcGxpZWRGaXJlZm94SGFjayIsImhhcyIsIndyYXBwaW5nV2hpdGVTcGFjZSIsIkhlaWdodE9yYWNsZSIsImhlaWdodFNhbXBsZXMiLCJoZWlnaHRGb3JHYXAiLCJjZWlsIiwiaGVpZ2h0Rm9yTGluZSIsInNldERvYyIsIm11c3RSZWZyZXNoRm9yV3JhcHBpbmciLCJ3aGl0ZVNwYWNlIiwibXVzdFJlZnJlc2hGb3JIZWlnaHRzIiwibGluZUhlaWdodHMiLCJuZXdIZWlnaHQiLCJoIiwicmVmcmVzaCIsImtub3duSGVpZ2h0cyIsIk1lYXN1cmVkSGVpZ2h0cyIsImhlaWdodHMiLCJtb3JlIiwiQmxvY2tJbmZvIiwiX2NvbnRlbnQiLCJRdWVyeVR5cGUiLCJFcHNpbG9uIiwiSGVpZ2h0TWFwIiwib3V0ZGF0ZWQiLCJzZXRIZWlnaHQiLCJvcmFjbGUiLCJub2RlcyIsImRlY29tcG9zZUxlZnQiLCJkZWNvbXBvc2VSaWdodCIsImFwcGx5Q2hhbmdlcyIsIm9sZERvYyIsIkJ5UG9zTm9IZWlnaHQiLCJOb2RlQnVpbGRlciIsInVwZGF0ZUhlaWdodCIsIkhlaWdodE1hcFRleHQiLCJicmVhayIsInNpemUiLCJicmsiLCJIZWlnaHRNYXBCcmFuY2giLCJIZWlnaHRNYXBCbG9jayIsIl9oZWlnaHQiLCJfb3JhY2xlIiwiX3ZhbHVlIiwiX3R5cGUiLCJmb3JFYWNoTGluZSIsIl9mb3JjZSIsIm1lYXN1cmVkIiwiY29sbGFwc2VkIiwid2lkZ2V0SGVpZ2h0IiwiYnJlYWtzIiwiSGVpZ2h0TWFwR2FwIiwiaGVpZ2h0TWV0cmljcyIsImZpcnN0TGluZSIsInBlckxpbmUiLCJwZXJDaGFyIiwidG90YWxQZXJMaW5lIiwiZ3Vlc3MiLCJsaW5lVG9wIiwiQnlIZWlnaHQiLCJsaW5lc0Fib3ZlIiwiZmlyc3QiLCJ1bnNoaWZ0Iiwic2luZ2xlSGVpZ2h0IiwibWlkIiwicmlnaHRUb3AiLCJyaWdodE9mZnNldCIsInN1YlF1ZXJ5IiwiQnlQb3MiLCJyaWdodFN0YXJ0IiwiYmFsYW5jZWQiLCJtZXJnZUdhcHMiLCJyZWJhbGFuY2UiLCJhcm91bmQiLCJyZWxldmFudFdpZGdldEhlaWdodCIsImxpbmVFbmQiLCJjb3ZlcmluZyIsIndyaXR0ZW5UbyIsImlzQ292ZXJlZCIsImFkZEJsb2NrIiwiZW50ZXJMaW5lIiwiYmxhbmtDb250ZW50IiwiZ2FwIiwiZW5zdXJlTGluZSIsImhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMiLCJ2aXNpYmxlUGl4ZWxSYW5nZSIsIm92ZXJmbG93IiwicGFyZW50UmVjdCIsIm9mZnNldFBhcmVudCIsImZ1bGxQaXhlbFJhbmdlIiwiTGluZUdhcCIsInNhbWUiLCJnQSIsImdCIiwiZHJhdyIsIndyYXBwaW5nIiwiTGluZUdhcFdpZGdldCIsInZlcnRpY2FsIiwiZGlzcGxheSIsIlZpZXdTdGF0ZSIsInBpeGVsVmlld3BvcnQiLCJpblZpZXciLCJwYWRkaW5nQm90dG9tIiwiY29udGVudERPTVdpZHRoIiwiY29udGVudERPTUhlaWdodCIsImVkaXRvckhlaWdodCIsImVkaXRvcldpZHRoIiwic2Nyb2xsZWRUb0JvdHRvbSIsInNjcm9sbEFuY2hvclBvcyIsInNjcm9sbEFuY2hvckhlaWdodCIsInNjYWxlciIsIklkU2NhbGVyIiwic2Nyb2xsVGFyZ2V0IiwicHJpbnRpbmciLCJkZWZhdWx0VGV4dERpcmVjdGlvbiIsInZpc2libGVSYW5nZXMiLCJtdXN0RW5mb3JjZUN1cnNvckFzc29jIiwiZ3Vlc3NXcmFwcGluZyIsInN0YXRlRGVjbyIsImhlaWdodE1hcCIsImdldFZpZXdwb3J0IiwidXBkYXRlVmlld3BvcnRMaW5lcyIsInVwZGF0ZUZvclZpZXdwb3J0IiwibGluZUdhcHMiLCJlbnN1cmVMaW5lR2FwcyIsImNvbXB1dGVWaXNpYmxlUmFuZ2VzIiwiVmlld3BvcnQiLCJCaWdTY2FsZXIiLCJ2aWV3cG9ydExpbmVzIiwic2NhbGUiLCJzY2FsZUJsb2NrIiwiY29udGVudENoYW5nZXMiLCJoZWlnaHRDaGFuZ2VzIiwicHJldkhlaWdodCIsInNjcm9sbEFuY2hvciIsInNjcm9sbEFuY2hvckF0IiwibWFwVmlld3BvcnQiLCJ2aWV3cG9ydElzQXBwcm9wcmlhdGUiLCJ1cGRhdGVMaW5lcyIsInVwZGF0ZUxpbmVHYXBzIiwibWFwTGluZUdhcHMiLCJkb21SZWN0IiwibWVhc3VyZUNvbnRlbnQiLCJwYXJzZUludCIsImRUb3AiLCJkQm90dG9tIiwidnAiLCJ2aWV3cG9ydENoYW5nZSIsInZpc2libGVUb3AiLCJmcm9tRE9NIiwidmlzaWJsZUJvdHRvbSIsIm1hcmdpblRvcCIsInZpZXdIZWlnaHQiLCJ0b3BQb3MiLCJtYXBwZWQiLCJ0b3VjaGVzUmFuZ2UiLCJjdXJyZW50IiwibWF5TWVhc3VyZSIsImhhbGZNYXJnaW4iLCJkb3VibGVNYXJnaW4iLCJhZGRHYXAiLCJzdHJ1Y3R1cmUiLCJhdm9pZCIsImdhcFNpemUiLCJsaW5lU3RydWN0dXJlIiwidG90YWwiLCJ2aWV3RnJvbSIsInZpZXdUbyIsIm1hcmdpbkhlaWdodCIsImJvdCIsInRhcmdldEZyYWMiLCJmaW5kRnJhY3Rpb24iLCJzcGFjZUZyYWMiLCJmaW5kUG9zaXRpb24iLCJtYXJnaW5XaWR0aCIsImZyYWN0aW9uIiwibGluZUJsb2NrQXRIZWlnaHQiLCJyYXRpbyIsImNvdW50ZWQiLCJhcnJheSIsInZhbCIsIm4iLCJ2cEhlaWdodCIsImRvbUJhc2UiLCJkb21Ub3AiLCJkb21Cb3R0b20iLCJvYmoiLCJiVG9wIiwiYkJvdHRvbSIsInRoZW1lIiwic3RycyIsImRhcmtUaGVtZSIsImJhc2VUaGVtZUlEIiwibmV3TmFtZSIsImJhc2VMaWdodElEIiwiYmFzZURhcmtJRCIsImxpZ2h0RGFya0lEcyIsImJ1aWxkVGhlbWUiLCJzY29wZXMiLCJiYXNlVGhlbWUkMSIsImJveFNpemluZyIsIm91dGxpbmUiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImZvbnRGYW1pbHkiLCJvdmVyZmxvd1giLCJ6SW5kZXgiLCJmbGV4R3JvdyIsImZsZXhTaHJpbmsiLCJ3b3JkV3JhcCIsIm1pbkhlaWdodCIsInBhZGRpbmciLCJXZWJraXRVc2VyTW9kaWZ5Iiwid2hpdGVTcGFjZV9mYWxsYmFjayIsIndvcmRCcmVhayIsIm92ZXJmbG93V3JhcCIsImNhcmV0Q29sb3IiLCJjb250YWluIiwiYmFja2dyb3VuZCIsInBvaW50ZXJFdmVudHMiLCJhbmltYXRpb24iLCJvcGFjaXR5IiwiYm9yZGVyTGVmdCIsIm1hcmdpbkxlZnQiLCJib3JkZXJMZWZ0Q29sb3IiLCJ1bmljb2RlQmlkaSIsImJhY2tncm91bmRDb2xvciIsImNvbG9yIiwiaW5zZXRJbmxpbmVTdGFydCIsImJvcmRlclJpZ2h0IiwidGV4dEFsaWduIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyVG9wIiwidmVydGljYWxBbGlnbiIsImJhY2tncm91bmRJbWFnZSIsImJhY2tncm91bmRTaXplIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFJlcGVhdCIsImZvbnRTaXplIiwiYm9yZGVyUmFkaXVzIiwiYm9yZGVyIiwiTGluZUJyZWFrUGxhY2Vob2xkZXIiLCJET01SZWFkZXIiLCJwb2ludHMiLCJsaW5lU2VwYXJhdG9yIiwicmVhZFJhbmdlIiwiZmluZFBvaW50QmVmb3JlIiwib2xkTGVuIiwicmVhZE5vZGUiLCJuZXh0VmlldyIsImlzQmxvY2tFbGVtZW50IiwicmVhZFRleHROb2RlIiwicmUiLCJuZXh0QnJlYWsiLCJicmVha1NpemUiLCJmcm9tVmlldyIsImZpbmRQb2ludEluc2lkZSIsImlzQXRFbmQiLCJET01Qb2ludCIsIkRPTUNoYW5nZSIsInR5cGVPdmVyIiwiYm91bmRzIiwiaUhlYWQiLCJpQW5jaG9yIiwic2VsUG9pbnRzIiwic2VsZWN0aW9uUG9pbnRzIiwic2VsZWN0aW9uRnJvbVBvaW50cyIsIm9mZkZyb20iLCJvZmZUbyIsInNpbmdsZSIsImFwcGx5RE9NQ2hhbmdlIiwiZG9tQ2hhbmdlIiwiY2hhbmdlIiwibGFzdEtleSIsInByZWZlcnJlZFBvcyIsInByZWZlcnJlZFNpZGUiLCJmaW5kRGlmZiIsImdldEF0dHJpYnV0ZSIsImRlZmF1bHRUciIsImRlZmF1bHRJbnNlcnQiLCJhcHBseURlZmF1bHRJbnNlcnQiLCJtYWluU2VsIiwibmV3TGVuZ3RoIiwicmVwbGFjZWQiLCJjb21wb3NpdGlvblJhbmdlIiwicmFuZ2VDaGFuZ2VzIiwic2VsT2ZmIiwibWluTGVuIiwiYWRqdXN0Iiwib2JzZXJ2ZU9wdGlvbnMiLCJjaGFyYWN0ZXJEYXRhIiwic3VidHJlZSIsImNoYXJhY3RlckRhdGFPbGRWYWx1ZSIsInVzZUNoYXJEYXRhIiwiRE9NT2JzZXJ2ZXIiLCJzZWxlY3Rpb25DaGFuZ2VkIiwiZGVsYXllZEZsdXNoIiwicmVzaXplVGltZW91dCIsInF1ZXVlIiwiZGVsYXllZEFuZHJvaWRLZXkiLCJmbHVzaGluZ0FuZHJvaWRLZXkiLCJsYXN0Q2hhbmdlIiwic2Nyb2xsVGFyZ2V0cyIsImludGVyc2VjdGlvbiIsInJlc2l6ZVNjcm9sbCIsImludGVyc2VjdGluZyIsImdhcEludGVyc2VjdGlvbiIsInBhcmVudENoZWNrIiwiTXV0YXRpb25PYnNlcnZlciIsIm11dGF0aW9ucyIsIm11dCIsInJlbW92ZWROb2RlcyIsIm9sZFZhbHVlIiwib25DaGFyRGF0YSIsInByZXZWYWx1ZSIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwib25SZXNpemUiLCJvblByaW50Iiwib25TY3JvbGwiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJhZGRXaW5kb3dMaXN0ZW5lcnMiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImVudHJpZXMiLCJsaXN0ZW5Gb3JTY3JvbGwiLCJpbnRlcnNlY3Rpb25SYXRpbyIsIm9uU2Nyb2xsQ2hhbmdlZCIsImNyZWF0ZUV2ZW50IiwidGhyZXNob2xkIiwicmVxdWVzdE1lYXN1cmUiLCJnIiwiZGlzY29ubmVjdCIsIndhc0NoYW5nZWQiLCJzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2siLCJsb2NhbCIsInByb2Nlc3NSZWNvcmRzIiwiY2xlYXJEZWxheWVkQW5kcm9pZEtleSIsImZsdXNoZWQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInRha2VSZWNvcmRzIiwicmVjb3JkcyIsInJlYWRNdXRhdGlvbiIsInJlYWRDaGFuZ2UiLCJyZWFkU2VsZWN0aW9uIiwiaGFuZGxlZCIsInJlYyIsImNoaWxkQmVmb3JlIiwiZmluZENoaWxkIiwiY2hpbGRBZnRlciIsInNldFdpbmRvdyIsInJlbW92ZVdpbmRvd0xpc3RlbmVycyIsIl9jIiwiY2xlYXJUaW1lb3V0IiwiY3VyVmlldyIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImdldFRhcmdldFJhbmdlcyIsImV4ZWNDb21tYW5kIiwiZW5kQ29udGFpbmVyIiwiZW5kT2Zmc2V0IiwiY3VyQW5jaG9yIiwiRWRpdG9yVmlldyIsImNvbXBvc2l0aW9uU3RhcnRlZCIsIl9yb290IiwiY29uZmlnIiwicGx1Z2luTWFwIiwiTWFwIiwiZWRpdG9yQXR0cnMiLCJjb250ZW50QXR0cnMiLCJiaWRpQ2FjaGUiLCJkZXN0cm95ZWQiLCJ1cGRhdGVTdGF0ZSIsIm1lYXN1cmVTY2hlZHVsZWQiLCJtZWFzdXJlUmVxdWVzdHMiLCJ0YWJJbmRleCIsImFubm91bmNlRE9NIiwiZGlzcGF0Y2hUcmFuc2FjdGlvbnMiLCJ0cnMiLCJzY3JvbGxUbyIsImlzIiwibW91bnRTdHlsZXMiLCJyZWRyYXduIiwiYXR0cnNDaGFuZ2VkIiwiZm9jdXNGbGFnIiwiZGlzcGF0Y2hGb2N1cyIsImFubm90YXRpb24iLCJwZW5kaW5nS2V5IiwicGhyYXNlcyIsInNldFN0YXRlIiwiQ2FjaGVkT3JkZXIiLCJ1cGRhdGVQbHVnaW5zIiwic3R5bGVNb2R1bGVzIiwic2hvd0Fubm91bmNlbWVudHMiLCJpc1VzZXJFdmVudCIsImxpc3RlbmVyIiwibmV3U3RhdGUiLCJoYWRGb2N1cyIsInByZXZTcGVjcyIsInNwZWNzIiwibmV3UGx1Z2lucyIsInNET00iLCJ3YXJuIiwibWVhc3VyaW5nIiwiQmFkTWVhc3VyZSIsIndyaXRlIiwibmV3QW5jaG9ySGVpZ2h0IiwidGhlbWVDbGFzc2VzIiwiYXR0cnNGcm9tRmFjZXQiLCJzcGVsbGNoZWNrIiwiYXV0b2NvcnJlY3QiLCJhdXRvY2FwaXRhbGl6ZSIsInRyYW5zbGF0ZSIsImNvbnRlbnRlZGl0YWJsZSIsInJvbGUiLCJjaGFuZ2VkQ29udGVudCIsImNoYW5nZWRFZGl0b3IiLCJhbm5vdW5jZSIsImRpdiIsIm5vbmNlIiwiY3NwTm9uY2UiLCJtb3VudCIsInJldmVyc2UiLCJyZWFkTWVhc3VyZWQiLCJyZXF1ZXN0Iiwia25vd24iLCJkb2N1bWVudFBhZGRpbmciLCJ2aWV3cG9ydExpbmVCbG9ja3MiLCJtb3ZlQnlHcm91cCIsImluaXRpYWwiLCJwb3NBdERPTSIsIk1heEJpZGlMaW5lIiwiZW50cnkiLCJmcmVzaCIsInNldFJvb3QiLCJzY3JvbGxTbmFwc2hvdCIsInByZWZpeCIsImRhcmsiLCJiYXNlVGhlbWUiLCJsb3dlc3QiLCJmaW5kRnJvbURPTSIsInF1ZXJ5U2VsZWN0b3IiLCJjYWNoZSIsImxhc3REaXIiLCJzb3VyY2VzIiwiY3VycmVudFBsYXRmb3JtIiwibm9ybWFsaXplS2V5TmFtZSIsInBhcnRzIiwiYWx0IiwiY3RybCIsIm1ldGEiLCJtb2QiLCJtb2RpZmllcnMiLCJoYW5kbGVLZXlFdmVudHMiLCJkZWZhdWx0IiwiZ2V0S2V5bWFwIiwia2V5bWFwIiwiZW5hYmxlcyIsIktleW1hcHMiLCJXZWFrTWFwIiwiYmluZGluZ3MiLCJidWlsZEtleW1hcCIsInJlZHVjZSIsInJ1blNjb3BlSGFuZGxlcnMiLCJzY29wZSIsInN0b3JlZFByZWZpeCIsIlByZWZpeFRpbWVvdXQiLCJib3VuZCIsImlzUHJlZml4IiwiY2hlY2tQcmVmaXgiLCJjb21tYW5kIiwic3RvcFByb3BhZ2F0aW9uIiwic2NvcGVPYmoiLCJrIiwib3VyT2JqIiwiZnVsbCIsImJpbmRpbmciLCJfYW55IiwiYW55IiwiY2hhckNvZGUiLCJpc0NoYXIiLCJwcmV2ZW50ZWQiLCJyYW4iLCJydW5Gb3IiLCJjbWQiLCJiYXNlTmFtZSIsInNoaWZ0TmFtZSIsIlJlY3RhbmdsZU1hcmtlciIsImZvclJhbmdlIiwiZ2V0QmFzZSIsInJlY3RhbmdsZXNGb3JSYW5nZSIsIndyYXBwZWRMaW5lIiwibGluZUVsdCIsImxpbmVTdHlsZSIsImxlZnRTaWRlIiwicGFkZGluZ0xlZnQiLCJ0ZXh0SW5kZW50IiwicmlnaHRTaWRlIiwicGFkZGluZ1JpZ2h0Iiwic3RhcnRCbG9jayIsImVuZEJsb2NrIiwidmlzdWFsU3RhcnQiLCJ2aXN1YWxFbmQiLCJwaWVjZXMiLCJkcmF3Rm9yTGluZSIsImRyYXdGb3JXaWRnZXQiLCJwaWVjZSIsImhvcml6b250YWwiLCJhZGRTcGFuIiwiZnJvbU9wZW4iLCJ0b09wZW4iLCJmcm9tQ29vcmRzIiwidG9Db29yZHMiLCJlbmRQb3MiLCJkb2NMaW5lIiwic3BhbkZyb20iLCJzcGFuVG8iLCJzYW1lTWFya2VyIiwiTGF5ZXJWaWV3IiwibGF5ZXIiLCJkcmF3biIsIm1lYXN1cmVSZXEiLCJzZXRPcmRlciIsImxheWVyT3JkZXIiLCJtYXJrZXJzIiwidHJhbnNmb3JtIiwib2xkIiwib2xkSSIsIm1hcmtlciIsIkNhbkhpZGVQcmltYXJ5Iiwic2VsZWN0aW9uQ29uZmlnIiwiY29uZmlncyIsImN1cnNvckJsaW5rUmF0ZSIsImRyYXdSYW5nZUN1cnNvciIsImRyYXdTZWxlY3Rpb24iLCJjdXJzb3JMYXllciIsInNlbGVjdGlvbkxheWVyIiwiaGlkZU5hdGl2ZVNlbGVjdGlvbiIsImdldERyYXdTZWxlY3Rpb25Db25maWciLCJjb25maWdDaGFuZ2VkIiwiY29uZiIsImN1cnNvcnMiLCJwcmltIiwiYW5pbWF0aW9uTmFtZSIsImNvbmZDaGFuZ2UiLCJzZXRCbGlua1JhdGUiLCJhbmltYXRpb25EdXJhdGlvbiIsInRoZW1lU3BlYyIsImhpZ2hlc3QiLCJzZXREcm9wQ3Vyc29yUG9zIiwibWFwcGluZyIsImRyb3BDdXJzb3JQb3MiLCJkcmF3RHJvcEN1cnNvciIsInJlYWRQb3MiLCJkcmF3Q3Vyc29yIiwiY3Vyc29yUG9zIiwiZmllbGQiLCJvdXRlciIsInNldERyb3BQb3MiLCJkcmFnb3ZlciIsImRyYWdsZWF2ZSIsInJlbGF0ZWRUYXJnZXQiLCJkcm9wQ3Vyc29yIiwiaXRlck1hdGNoZXMiLCJsYXN0SW5kZXgiLCJpdGVyUmFuZ2UiLCJtYXRjaFJhbmdlcyIsIm1heExlbmd0aCIsInZpc2libGUiLCJNYXRjaERlY29yYXRvciIsInJlZ2V4cCIsImRlY29yYXRpb24iLCJkZWNvcmF0ZSIsImJvdW5kYXJ5IiwiZ2xvYmFsIiwiYWRkTWF0Y2giLCJtYXRjaCIsIl92aWV3IiwiY3JlYXRlRGVjbyIsImNoYW5nZUZyb20iLCJjaGFuZ2VUbyIsIml0ZXJDaGFuZ2VzIiwiX2YiLCJfdCIsInVwZGF0ZVJhbmdlIiwidXBkYXRlRnJvbSIsInVwZGF0ZVRvIiwiZnJvbUxpbmUiLCJ0b0xpbmUiLCJmaWx0ZXJGcm9tIiwiZmlsdGVyVG8iLCJVbmljb2RlUmVnZXhwU3VwcG9ydCIsInVuaWNvZGUiLCJTcGVjaWFscyIsIlJlZ0V4cCIsIk5hbWVzIiwiX3N1cHBvcnRzVGFiU2l6ZSIsInN1cHBvcnRzVGFiU2l6ZSIsInN0eWxlcyIsIk1velRhYlNpemUiLCJzcGVjaWFsQ2hhckNvbmZpZyIsInJlbmRlciIsInNwZWNpYWxDaGFycyIsImFkZFNwZWNpYWxDaGFycyIsInJlcGxhY2VUYWJzIiwiaGlnaGxpZ2h0U3BlY2lhbENoYXJzIiwic3BlY2lhbENoYXJQbHVnaW4iLCJfcGx1Z2luIiwiZGVjb3JhdGlvbkNhY2hlIiwiZGVjb3JhdG9yIiwibWFrZURlY29yYXRvciIsImNvbCIsIlRhYldpZGdldCIsIlNwZWNpYWxDaGFyV2lkZ2V0IiwiRGVmYXVsdFBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXIkMSIsImZyb21DaGFyQ29kZSIsInBoIiwiZGVzYyIsInBocmFzZSIsInRpdGxlIiwic2Nyb2xsUGFzdEVuZCIsImhpZ2hsaWdodEFjdGl2ZUxpbmUiLCJhY3RpdmVMaW5lSGlnaGxpZ2h0ZXIiLCJsaW5lRGVjbyIsImdldERlY28iLCJsYXN0TGluZVN0YXJ0IiwiUGxhY2Vob2xkZXIiLCJ3cmFwIiwicGxhY2Vob2xkZXIiLCJNYXhPZmYiLCJyZWN0YW5nbGVGb3IiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwic3RhcnRPZmYiLCJlbmRPZmYiLCJzdGFydENvbCIsImVuZENvbCIsImFic29sdXRlQ29sdW1uIiwiZ2V0UG9zIiwicmVjdGFuZ2xlU2VsZWN0aW9uU3R5bGUiLCJuZXdTdGFydCIsIm5ld0xpbmUiLCJfZXh0ZW5kIiwicmVjdGFuZ3VsYXJTZWxlY3Rpb24iLCJldmVudEZpbHRlciIsIkFsdCIsIkNvbnRyb2wiLCJTaGlmdCIsIk1ldGEiLCJzaG93Q3Jvc3NoYWlyIiwiY3Jvc3NoYWlyQ3Vyc29yIiwiZ2V0dGVyIiwiaXNEb3duIiwia2V5dXAiLCJtb3VzZW1vdmUiLCJPdXRzaWRlIiwiVG9vbHRpcFZpZXdNYW5hZ2VyIiwiY3JlYXRlVG9vbHRpcFZpZXciLCJyZW1vdmVUb29sdGlwVmlldyIsInRvb2x0aXBzIiwidG9vbHRpcFZpZXdzIiwibmV3QWJvdmUiLCJ0aXAiLCJ0b29sdGlwVmlldyIsInRvb2x0aXBDb25maWciLCJ3aW5kb3dTcGFjZSIsInRvb2x0aXBTcGFjZSIsImtub3duSGVpZ2h0IiwidG9vbHRpcFBsdWdpbiIsIm1hZGVBYnNvbHV0ZSIsImxhc3RUcmFuc2FjdGlvbiIsIm1lYXN1cmVUaW1lb3V0IiwiY2xhc3NlcyIsImNyZWF0ZUNvbnRhaW5lciIsInJlYWRNZWFzdXJlIiwid3JpdGVNZWFzdXJlIiwicmVzaXplT2JzZXJ2ZXIiLCJtZWFzdXJlU29vbiIsIm1hbmFnZXIiLCJzaG93VG9vbHRpcCIsImNyZWF0ZVRvb2x0aXAiLCJ1bm9ic2VydmUiLCJpbnRlcnNlY3Rpb25PYnNlcnZlciIsIm9ic2VydmVJbnRlcnNlY3Rpb24iLCJtYXliZU1lYXN1cmUiLCJjb250YWluZXIiLCJ0b29sdGlwIiwic2hvdWxkTWVhc3VyZSIsIm5ld0NvbmZpZyIsImFycm93IiwiZWRpdG9yIiwibWFrZUFic29sdXRlIiwidHYiLCJnZXRDb29yZHMiLCJzcGFjZSIsIm90aGVycyIsInRWaWV3IiwiYXJyb3dIZWlnaHQiLCJub09mZnNldCIsInN0cmljdFNpZGUiLCJzcGFjZVZlcnQiLCJyZXNpemUiLCJvdmVybGFwIiwiYXJyb3dMZWZ0IiwidG9nZ2xlIiwicG9zaXRpb25lZCIsImJvcmRlclRvcENvbG9yIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJzaG93SG92ZXJUb29sdGlwIiwiaW5wdXRzIiwiSG92ZXJUb29sdGlwSG9zdCIsIm1vdW50ZWQiLCJjcmVhdGVIb3N0ZWRWaWV3IiwiaG9zdGVkVmlldyIsInBhc3NQcm9wIiwiZ2l2ZW4iLCJzaG93SG92ZXJUb29sdGlwSG9zdCIsImNvbXB1dGUiLCJIb3ZlclBsdWdpbiIsInNldEhvdmVyIiwiaG92ZXJUaW1lIiwiaG92ZXJUaW1lb3V0IiwicmVzdGFydFRpbWVvdXQiLCJsYXN0TW92ZSIsInRpbWUiLCJjaGVja0hvdmVyIiwibW91c2VsZWF2ZSIsInN0YXJ0SG92ZXIiLCJob3ZlcmVkIiwicG9zQ29vcmRzIiwiYmlkaSIsInJ0bCIsImZpbmRJbmRleCIsImlzSW5Ub29sdGlwIiwiaXNPdmVyUmFuZ2UiLCJpblRvb2x0aXAiLCJ3YXRjaFRvb2x0aXBMZWF2ZSIsIndhdGNoIiwidG9vbHRpcE1hcmdpbiIsImRvY0JvdHRvbSIsImhvdmVyVG9vbHRpcCIsImhvdmVyU3RhdGUiLCJoaWRlT25DaGFuZ2UiLCJoaWRlT24iLCJhc3NpZ24iLCJjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCIsImdldFRvb2x0aXAiLCJoYXNIb3ZlclRvb2x0aXBzIiwiY2xvc2VIb3ZlclRvb2x0aXBzIiwicmVwb3NpdGlvblRvb2x0aXBzIiwicGFuZWxDb25maWciLCJ0b3BDb250YWluZXIiLCJib3R0b21Db250YWluZXIiLCJwYW5lbHMiLCJnZXRQYW5lbCIsInBhbmVsIiwicGFuZWxQbHVnaW4iLCJzaG93UGFuZWwiLCJQYW5lbEdyb3VwIiwic3luY0NsYXNzZXMiLCJzY3JvbGxNYXJnaW4iLCJzeW5jRE9NIiwiY3VyRE9NIiwicm0iLCJHdXR0ZXJNYXJrZXIiLCJlbGVtZW50Q2xhc3MiLCJndXR0ZXJMaW5lQ2xhc3MiLCJkZWZhdWx0cyIsInJlbmRlckVtcHR5RWxlbWVudHMiLCJlbGVtZW50U3R5bGUiLCJsaW5lTWFya2VyIiwid2lkZ2V0TWFya2VyIiwibGluZU1hcmtlckNoYW5nZSIsImluaXRpYWxTcGFjZXIiLCJ1cGRhdGVTcGFjZXIiLCJhY3RpdmVHdXR0ZXJzIiwiZ3V0dGVyIiwiZ3V0dGVycyIsInVuZml4R3V0dGVycyIsImd1dHRlclZpZXciLCJmaXhlZCIsInByZXZWaWV3cG9ydCIsIlNpbmdsZUd1dHRlclZpZXciLCJzeW5jR3V0dGVycyIsInVwZGF0ZUd1dHRlcnMiLCJ2cEEiLCJ2cEIiLCJ2cE92ZXJsYXAiLCJkZXRhY2giLCJsaW5lQ2xhc3NlcyIsImNsYXNzU2V0IiwiY29udGV4dHMiLCJVcGRhdGVDb250ZXh0IiwiYWR2YW5jZUN1cnNvciIsImN4IiwiYXNBcnJheSIsImNvbGxlY3QiLCJhZGRFbGVtZW50IiwiZWxlbWVudHMiLCJuZXdFbHQiLCJHdXR0ZXJFbGVtZW50IiwiZXh0cmFNYXJrZXJzIiwibG9jYWxNYXJrZXJzIiwiZm9yTGluZSIsInNwYWNlciIsInByb3AiLCJwcmV2TWFya2VycyIsInNhbWVNYXJrZXJzIiwic2V0TWFya2VycyIsImRvbVBvcyIsImlOZXciLCJpT2xkIiwic2tpcFRvIiwibWF0Y2hlZCIsImxpbmVOdW1iZXJNYXJrZXJzIiwibGluZU51bWJlckNvbmZpZyIsImZvcm1hdE51bWJlciIsIk51bWJlck1hcmtlciIsImxpbmVOdW1iZXJHdXR0ZXIiLCJtYXhMaW5lTnVtYmVyIiwibGluZU51bWJlcnMiLCJhY3RpdmVMaW5lR3V0dGVyTWFya2VyIiwiYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyIiwiaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciIsIldoaXRlc3BhY2VEZWNvIiwiZ2V0V2hpdGVzcGFjZURlY28iLCJtYXRjaGVyIiwidSIsIndoaXRlc3BhY2VIaWdobGlnaHRlciIsImhpZ2hsaWdodFdoaXRlc3BhY2UiLCJ0cmFpbGluZ0hpZ2hsaWdodGVyIiwiaGlnaGxpZ2h0VHJhaWxpbmdXaGl0ZXNwYWNlIiwiX190ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/view/dist/index.js\n");

/***/ })

};
;