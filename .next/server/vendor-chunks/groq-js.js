"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.mjs":
/*!*****************************************!*\
  !*** ./node_modules/groq-js/dist/1.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   createReferenceTypeNode: () => (/* binding */ createReferenceTypeNode),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   typeEvaluate: () => (/* binding */ typeEvaluate)\n/* harmony export */ });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n    const re = [];\n    for (const part of pattern.split(\".\"))part === \"*\" ? re.push(\"[^.]+\") : part === \"**\" ? re.push(\".*\") : re.push(escapeRegExp(part));\n    return new RegExp(`^${re.join(\".\")}$`);\n}\nclass Path {\n    constructor(pattern){\n        this.pattern = pattern, this.patternRe = pathRegExp(pattern);\n    }\n    matches(str) {\n        return this.patternRe.test(str);\n    }\n    toJSON() {\n        return this.pattern;\n    }\n}\nclass StreamValue {\n    constructor(generator){\n        this.type = \"stream\";\n        this.generator = generator, this.ticker = null, this.isDone = !1, this.data = [];\n    }\n    // eslint-disable-next-line class-methods-use-this\n    isArray() {\n        return !0;\n    }\n    async get() {\n        const result = [];\n        for await (const value of this)result.push(await value.get());\n        return result;\n    }\n    async *[Symbol.asyncIterator]() {\n        let i = 0;\n        for(;;){\n            for(; i < this.data.length; i++)yield this.data[i];\n            if (this.isDone) return;\n            await this._nextTick();\n        }\n    }\n    _nextTick() {\n        if (this.ticker) return this.ticker;\n        let currentResolver;\n        const setupTicker = ()=>{\n            this.ticker = new Promise((resolve)=>{\n                currentResolver = resolve;\n            });\n        }, tick = ()=>{\n            currentResolver(), setupTicker();\n        }, fetch = async ()=>{\n            for await (const value of this.generator())this.data.push(value), tick();\n            this.isDone = !0, tick();\n        };\n        return setupTicker(), fetch(), this.ticker;\n    }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n    return RFC3339_REGEX.test(str) ? new Date(str) : null;\n}\nfunction formatRFC3339(d) {\n    const year = addLeadingZero(d.getUTCFullYear(), 4), month = addLeadingZero(d.getUTCMonth() + 1, 2), day = addLeadingZero(d.getUTCDate(), 2), hour = addLeadingZero(d.getUTCHours(), 2), minute = addLeadingZero(d.getUTCMinutes(), 2), second = addLeadingZero(d.getUTCSeconds(), 2);\n    let fractionalSecond = \"\";\n    const millis = d.getMilliseconds();\n    return millis != 0 && (fractionalSecond = `.${addLeadingZero(millis, 3)}`), `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\n}\nfunction addLeadingZero(num, targetLength) {\n    let str = num.toString();\n    for(; str.length < targetLength;)str = `0${str}`;\n    return str;\n}\nclass StaticValue {\n    constructor(data, type){\n        this.data = data, this.type = type;\n    }\n    isArray() {\n        return this.type === \"array\";\n    }\n    // eslint-disable-next-line require-await\n    async get() {\n        return this.data;\n    }\n    [Symbol.asyncIterator]() {\n        if (Array.isArray(this.data)) return function*(data) {\n            for (const element of data)yield fromJS(element);\n        }(this.data);\n        throw new Error(`Cannot iterate over: ${this.type}`);\n    }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\"), TRUE_VALUE = new StaticValue(!0, \"boolean\"), FALSE_VALUE = new StaticValue(!1, \"boolean\");\nclass DateTime {\n    constructor(date){\n        this.date = date;\n    }\n    static parseToValue(str) {\n        const date = parseRFC3339(str);\n        return date ? new StaticValue(new DateTime(date), \"datetime\") : NULL_VALUE;\n    }\n    equals(other) {\n        return this.date.getTime() == other.date.getTime();\n    }\n    add(secs) {\n        const copy = new Date(this.date.getTime());\n        return copy.setTime(copy.getTime() + secs * 1e3), new DateTime(copy);\n    }\n    difference(other) {\n        return (this.date.getTime() - other.date.getTime()) / 1e3;\n    }\n    compareTo(other) {\n        return this.date.getTime() - other.date.getTime();\n    }\n    toString() {\n        return formatRFC3339(this.date);\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nfunction fromNumber(num) {\n    return Number.isFinite(num) ? new StaticValue(num, \"number\") : NULL_VALUE;\n}\nfunction fromString(str) {\n    return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n    return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n    return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n    return obj && typeof obj.next == \"function\";\n}\nfunction fromJS(val) {\n    return isIterator(val) ? new StreamValue(async function*() {\n        for await (const value of val)yield fromJS(value);\n    }) : val == null ? NULL_VALUE : new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n    return data === null || typeof data > \"u\" ? \"null\" : Array.isArray(data) ? \"array\" : data instanceof Path ? \"path\" : data instanceof DateTime ? \"datetime\" : typeof data;\n}\nfunction isEqual(a, b) {\n    return a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\" ? a.data === b.data : a.type === \"datetime\" && b.type === \"datetime\" ? a.data.equals(b.data) : !1;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g, EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nfunction matchText(tokens, patterns) {\n    return tokens.length === 0 || patterns.length === 0 ? !1 : patterns.every((pattern)=>pattern(tokens));\n}\nfunction matchTokenize(text) {\n    return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n    return matchPatternRegex(text).map((re)=>(tokens)=>tokens.some((token)=>re.test(token)));\n}\nfunction matchPatternRegex(text) {\n    return (text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || []).map((term)=>new RegExp(`^${term.slice(0, 1024).replace(/\\*/g, \".*\")}$`, \"i\"));\n}\nasync function gatherText(value, cb) {\n    if (value.type === \"string\") return cb(value.data), !0;\n    if (value.isArray()) {\n        let success = !0;\n        for await (const part of value)part.type === \"string\" ? cb(part.data) : success = !1;\n        return success;\n    }\n    return !1;\n}\nconst TYPE_ORDER = {\n    datetime: 1,\n    number: 2,\n    string: 3,\n    boolean: 4\n};\nfunction partialCompare(a, b) {\n    const aType = getType(a), bType = getType(b);\n    if (aType !== bType) return null;\n    switch(aType){\n        case \"number\":\n        case \"boolean\":\n            return a - b;\n        case \"string\":\n            return a < b ? -1 : a > b ? 1 : 0;\n        case \"datetime\":\n            return a.compareTo(b);\n        default:\n            return null;\n    }\n}\nfunction totalCompare(a, b) {\n    const aType = getType(a), bType = getType(b), aTypeOrder = TYPE_ORDER[aType] || 100, bTypeOrder = TYPE_ORDER[bType] || 100;\n    if (aTypeOrder !== bTypeOrder) return aTypeOrder - bTypeOrder;\n    let result = partialCompare(a, b);\n    return result === null && (result = 0), result;\n}\nconst operators = {\n    \"==\": function(left, right) {\n        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"!=\": function(left, right) {\n        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n    },\n    \">\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result > 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \">=\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<=\": function(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        return result === null ? NULL_VALUE : result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    // eslint-disable-next-line func-name-matching\n    in: async function(left, right) {\n        if (right.type === \"path\") return left.type !== \"string\" ? NULL_VALUE : right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n        if (right.isArray()) {\n            for await (const b of right)if (isEqual(left, b)) return TRUE_VALUE;\n            return FALSE_VALUE;\n        }\n        return NULL_VALUE;\n    },\n    match: async function(left, right) {\n        let tokens = [], patterns = [];\n        return await gatherText(left, (part)=>{\n            tokens = tokens.concat(matchTokenize(part));\n        }), await gatherText(right, (part)=>{\n            patterns = patterns.concat(matchAnalyzePattern(part));\n        }) && matchText(tokens, patterns) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"+\": function(left, right) {\n        return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data + right.data) : left.type === \"string\" && right.type === \"string\" ? fromString(left.data + right.data) : left.type === \"object\" && right.type === \"object\" ? fromJS({\n            ...left.data,\n            ...right.data\n        }) : left.type === \"array\" && right.type === \"array\" ? fromJS(left.data.concat(right.data)) : left.isArray() && right.isArray() ? new StreamValue(async function*() {\n            for await (const val of left)yield val;\n            for await (const val of right)yield val;\n        }) : NULL_VALUE;\n    },\n    \"-\": function(left, right) {\n        return left.type === \"datetime\" && right.type === \"number\" ? fromDateTime(left.data.add(-right.data)) : left.type === \"datetime\" && right.type === \"datetime\" ? fromNumber(left.data.difference(right.data)) : left.type === \"number\" && right.type === \"number\" ? fromNumber(left.data - right.data) : NULL_VALUE;\n    },\n    \"*\": numericOperator((a, b)=>a * b),\n    \"/\": numericOperator((a, b)=>a / b),\n    \"%\": numericOperator((a, b)=>a % b),\n    \"**\": numericOperator((a, b)=>Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n    return function(left, right) {\n        if (left.type === \"number\" && right.type === \"number\") {\n            const result = impl(left.data, right.data);\n            return fromNumber(result);\n        }\n        return NULL_VALUE;\n    };\n}\nlet Scope$1 = class Scope {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(params, source, value, context, parent){\n        this.isHidden = !1;\n        this.params = params, this.source = source, this.value = value, this.context = context, this.parent = parent;\n    }\n    createNested(value) {\n        return this.isHidden ? new Scope(this.params, this.source, value, this.context, this.parent) : new Scope(this.params, this.source, value, this.context, this);\n    }\n    createHidden(value) {\n        const result = this.createNested(value);\n        return result.isHidden = !0, result;\n    }\n};\nfunction evaluate(node, scope, execute = evaluate) {\n    const func = EXECUTORS[node.type];\n    return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n    return \"then\" in value ? value.then(cb) : cb(value);\n}\nconst EXECUTORS = {\n    This (_, scope) {\n        return scope.value;\n    },\n    Selector () {\n        throw new Error(\"Selectors can not be evaluated\");\n    },\n    Everything (_, scope) {\n        return scope.source;\n    },\n    Parameter ({ name }, scope) {\n        return fromJS(scope.params[name]);\n    },\n    Context ({ key }, scope) {\n        if (key === \"before\" || key === \"after\") return scope.context[key] || NULL_VALUE;\n        throw new Error(`unknown context key: ${key}`);\n    },\n    Parent ({ n }, scope) {\n        let current = scope;\n        for(let i = 0; i < n; i++){\n            if (!current.parent) return NULL_VALUE;\n            current = current.parent;\n        }\n        return current.value;\n    },\n    OpCall ({ op, left, right }, scope, execute) {\n        const func = operators[op];\n        if (!func) throw new Error(`Unknown operator: ${op}`);\n        const leftValue = execute(left, scope), rightValue = execute(right, scope);\n        return \"then\" in leftValue || \"then\" in rightValue ? (async ()=>func(await leftValue, await rightValue))() : func(leftValue, rightValue);\n    },\n    async Select ({ alternatives, fallback }, scope, execute) {\n        for (const alt of alternatives){\n            const altCond = await execute(alt.condition, scope);\n            if (altCond.type === \"boolean\" && altCond.data === !0) return execute(alt.value, scope);\n        }\n        return fallback ? execute(fallback, scope) : NULL_VALUE;\n    },\n    async InRange ({ base, left, right, isInclusive }, scope, execute) {\n        const value = await execute(base, scope), leftValue = await execute(left, scope), rightValue = await execute(right, scope), leftCmp = partialCompare(await value.get(), await leftValue.get());\n        if (leftCmp === null) return NULL_VALUE;\n        const rightCmp = partialCompare(await value.get(), await rightValue.get());\n        return rightCmp === null ? NULL_VALUE : isInclusive ? leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE : leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    async Filter ({ base, expr }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        return baseValue.isArray() ? new StreamValue(async function*() {\n            for await (const elem of baseValue){\n                const newScope = scope.createNested(elem), exprValue = await execute(expr, newScope);\n                exprValue.type === \"boolean\" && exprValue.data === !0 && (yield elem);\n            }\n        }) : NULL_VALUE;\n    },\n    async Projection ({ base, expr }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (baseValue.type !== \"object\") return NULL_VALUE;\n        const newScope = scope.createNested(baseValue);\n        return execute(expr, newScope);\n    },\n    FuncCall ({ func, args }, scope, execute) {\n        return func(args, scope, execute);\n    },\n    async PipeFuncCall ({ func, base, args }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        return func(baseValue, args, scope, execute);\n    },\n    async AccessAttribute ({ base, name }, scope, execute) {\n        let value = scope.value;\n        return base && (value = await execute(base, scope)), value.type === \"object\" && value.data.hasOwnProperty(name) ? fromJS(value.data[name]) : NULL_VALUE;\n    },\n    async AccessElement ({ base, index }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) return NULL_VALUE;\n        const data = await baseValue.get(), finalIndex = index < 0 ? index + data.length : index;\n        return fromJS(data[finalIndex]);\n    },\n    async Slice ({ base, left, right, isInclusive }, scope, execute) {\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) return NULL_VALUE;\n        const array2 = await baseValue.get();\n        let leftIdx = left, rightIdx = right;\n        return leftIdx < 0 && (leftIdx = array2.length + leftIdx), rightIdx < 0 && (rightIdx = array2.length + rightIdx), isInclusive && rightIdx++, leftIdx < 0 && (leftIdx = 0), rightIdx < 0 && (rightIdx = 0), fromJS(array2.slice(leftIdx, rightIdx));\n    },\n    async Deref ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        if (!scope.source.isArray() || value.type !== \"object\") return NULL_VALUE;\n        const id = value.data._ref;\n        if (typeof id != \"string\") return NULL_VALUE;\n        if (scope.context.dereference) return fromJS(await scope.context.dereference({\n            _ref: id\n        }));\n        for await (const doc of scope.source)if (doc.type === \"object\" && id === doc.data._id) return doc;\n        return NULL_VALUE;\n    },\n    Value ({ value }) {\n        return fromJS(value);\n    },\n    Group ({ base }, scope, execute) {\n        return execute(base, scope);\n    },\n    async Object ({ attributes }, scope, execute) {\n        const result = {};\n        for (const attr of attributes){\n            const attrType = attr.type;\n            switch(attr.type){\n                case \"ObjectAttributeValue\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        result[attr.name] = await value.get();\n                        break;\n                    }\n                case \"ObjectConditionalSplat\":\n                    {\n                        const cond = await execute(attr.condition, scope);\n                        if (cond.type !== \"boolean\" || cond.data === !1) continue;\n                        const value = await execute(attr.value, scope);\n                        value.type === \"object\" && Object.assign(result, value.data);\n                        break;\n                    }\n                case \"ObjectSplat\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        value.type === \"object\" && Object.assign(result, value.data);\n                        break;\n                    }\n                default:\n                    throw new Error(`Unknown node type: ${attrType}`);\n            }\n        }\n        return fromJS(result);\n    },\n    Array ({ elements }, scope, execute) {\n        return new StreamValue(async function*() {\n            for (const element of elements){\n                const value = await execute(element.value, scope);\n                if (element.isSplat) {\n                    if (value.isArray()) for await (const v of value)yield v;\n                } else yield value;\n            }\n        });\n    },\n    Tuple () {\n        throw new Error(\"tuples can not be evaluated\");\n    },\n    async Or ({ left, right }, scope, execute) {\n        const leftValue = await execute(left, scope), rightValue = await execute(right, scope);\n        return leftValue.type === \"boolean\" && leftValue.data === !0 || rightValue.type === \"boolean\" && rightValue.data === !0 ? TRUE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : FALSE_VALUE;\n    },\n    async And ({ left, right }, scope, execute) {\n        const leftValue = await execute(left, scope), rightValue = await execute(right, scope);\n        return leftValue.type === \"boolean\" && leftValue.data === !1 || rightValue.type === \"boolean\" && rightValue.data === !1 ? FALSE_VALUE : leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\" ? NULL_VALUE : TRUE_VALUE;\n    },\n    async Not ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.type !== \"boolean\" ? NULL_VALUE : value.data ? FALSE_VALUE : TRUE_VALUE;\n    },\n    Neg ({ base }, scope, execute) {\n        return promiselessApply(execute(base, scope), (value)=>value.type !== \"number\" ? NULL_VALUE : fromNumber(-value.data));\n    },\n    Pos ({ base }, scope, execute) {\n        return promiselessApply(execute(base, scope), (value)=>value.type !== \"number\" ? NULL_VALUE : fromNumber(value.data));\n    },\n    Asc () {\n        return NULL_VALUE;\n    },\n    Desc () {\n        return NULL_VALUE;\n    },\n    async ArrayCoerce ({ base }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.isArray() ? value : NULL_VALUE;\n    },\n    async Map ({ base, expr }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.isArray() ? new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem);\n                yield await execute(expr, newScope);\n            }\n        }) : NULL_VALUE;\n    },\n    async FlatMap ({ base, expr }, scope, execute) {\n        const value = await execute(base, scope);\n        return value.isArray() ? new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem), innerValue = await execute(expr, newScope);\n                if (innerValue.isArray()) for await (const inner of innerValue)yield inner;\n                else yield innerValue;\n            }\n        }) : NULL_VALUE;\n    }\n};\nfunction evaluateQuery(tree, options = {}) {\n    const root = fromJS(options.root), dataset = fromJS(options.dataset), params = {\n        ...options.params\n    }, scope = new Scope$1(params, dataset, root, {\n        timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n        identity: options.identity === void 0 ? \"me\" : options.identity,\n        sanity: options.sanity,\n        after: options.after ? fromJS(options.after) : null,\n        before: options.before ? fromJS(options.before) : null,\n        dereference: options.dereference\n    }, null);\n    return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n    switch(node.type){\n        case \"Group\":\n            return canConstantEvaluate(node.base);\n        case \"Value\":\n        case \"Parameter\":\n            return !0;\n        case \"Pos\":\n        case \"Neg\":\n            return canConstantEvaluate(node.base);\n        case \"OpCall\":\n            switch(node.op){\n                case \"+\":\n                case \"-\":\n                case \"*\":\n                case \"/\":\n                case \"%\":\n                case \"**\":\n                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n                default:\n                    return !1;\n            }\n        default:\n            return !1;\n    }\n}\nconst DUMMY_SCOPE = new Scope$1({}, NULL_VALUE, NULL_VALUE, {\n    timestamp: /* @__PURE__ */ new Date(0),\n    identity: \"me\",\n    before: null,\n    after: null\n}, null);\nfunction tryConstantEvaluate(node) {\n    return canConstantEvaluate(node) ? constantEvaluate(node) : null;\n}\nfunction constantEvaluate(node) {\n    const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n    if (\"then\" in value) throw new Error(\"BUG: constant evaluate should never return a promise\");\n    return value;\n}\nasync function portableTextContent(value) {\n    if (value.type === \"object\") return blockText(value.data);\n    if (value.isArray()) {\n        const texts = await arrayText(value);\n        if (texts.length > 0) return texts.join(`\n\n`);\n    }\n    return null;\n}\nasync function arrayText(value, result = []) {\n    for await (const block of value)if (block.type === \"object\") {\n        const text = blockText(block.data);\n        text !== null && result.push(text);\n    } else block.isArray() && await arrayText(block, result);\n    return result;\n}\nfunction blockText(obj) {\n    if (typeof obj._type != \"string\") return null;\n    const children = obj.children;\n    if (!Array.isArray(children)) return null;\n    let result = \"\";\n    for (const child of children)child && typeof child == \"object\" && typeof child._type == \"string\" && child._type === \"span\" && typeof child.text == \"string\" && (result += child.text);\n    return result;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n    if (node.type === \"OpCall\" && node.op === \"match\") return evaluateMatchScore(node.left, node.right, scope, execute);\n    if (node.type === \"FuncCall\" && node.name === \"boost\") {\n        const innerScore = await evaluateScore(node.args[0], scope, execute), boost = await execute(node.args[1], scope);\n        return boost.type === \"number\" && innerScore > 0 ? innerScore + boost.data : 0;\n    }\n    switch(node.type){\n        case \"Or\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute), rightScore = await evaluateScore(node.right, scope, execute);\n                return leftScore + rightScore;\n            }\n        case \"And\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute), rightScore = await evaluateScore(node.right, scope, execute);\n                return leftScore === 0 || rightScore === 0 ? 0 : leftScore + rightScore;\n            }\n        default:\n            {\n                const res = await execute(node, scope);\n                return res.type === \"boolean\" && res.data === !0 ? 1 : 0;\n            }\n    }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n    const text = await execute(left, scope), pattern = await execute(right, scope);\n    let tokens = [], terms = [];\n    if (await gatherText(text, (part)=>{\n        tokens = tokens.concat(matchTokenize(part));\n    }), !await gatherText(pattern, (part)=>{\n        terms = terms.concat(matchPatternRegex(part));\n    }) || tokens.length === 0 || terms.length === 0) return 0;\n    let score = 0;\n    for (const re of terms){\n        const freq = tokens.reduce((c, token)=>c + (re.test(token) ? 1 : 0), 0);\n        score += freq * (BM25k + 1) / (freq + BM25k);\n    }\n    return score;\n}\nfunction hasReference(value, pathSet) {\n    switch(getType(value)){\n        case \"array\":\n            for (const v of value)if (hasReference(v, pathSet)) return !0;\n            break;\n        case \"object\":\n            if (value._ref) return pathSet.has(value._ref);\n            for (const v of Object.values(value))if (hasReference(v, pathSet)) return !0;\n            break;\n    }\n    return !1;\n}\nfunction countUTF8(str) {\n    let count2 = 0;\n    for(let i = 0; i < str.length; i++){\n        const code = str.charCodeAt(i);\n        code >= 55296 && code <= 56319 || count2++;\n    }\n    return count2;\n}\nconst _global = {};\n_global.anywhere = async function() {\n    throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function(args, scope, execute) {\n    for (const arg of args){\n        const value = await execute(arg, scope);\n        if (value.type !== \"null\") return value;\n    }\n    return NULL_VALUE;\n};\n_global.count = async function(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (!inner.isArray()) return NULL_VALUE;\n    let num = 0;\n    for await (const _ of inner)num++;\n    return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function(args, scope, execute) {\n    const val = await execute(args[0], scope);\n    return val.type === \"datetime\" ? val : val.type !== \"string\" ? NULL_VALUE : DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function(args, scope, execute) {\n    return (await execute(args[0], scope)).type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function(_args, scope) {\n    return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (inner.type === \"string\") return fromNumber(countUTF8(inner.data));\n    if (inner.isArray()) {\n        let num = 0;\n        for await (const _ of inner)num++;\n        return fromNumber(num);\n    }\n    return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    return inner.type !== \"string\" ? NULL_VALUE : fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    switch(value.type){\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n            return fromString(`${value.data}`);\n        default:\n            return NULL_VALUE;\n    }\n};\n_global.string.arity = 1;\n_global.references = async function(args, scope, execute) {\n    const pathSet = /* @__PURE__ */ new Set();\n    for (const arg of args){\n        const path2 = await execute(arg, scope);\n        if (path2.type === \"string\") pathSet.add(path2.data);\n        else if (path2.isArray()) for await (const elem of path2)elem.type === \"string\" && pathSet.add(elem.data);\n    }\n    if (pathSet.size === 0) return FALSE_VALUE;\n    const scopeValue = await scope.value.get();\n    return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = (c)=>c >= 1;\n_global.round = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"number\") return NULL_VALUE;\n    const num = value.data;\n    let prec = 0;\n    if (args.length === 2) {\n        const precValue = await execute(args[1], scope);\n        if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) return NULL_VALUE;\n        prec = precValue.data;\n    }\n    return prec === 0 ? num < 0 ? fromNumber(-Math.round(-num)) : fromNumber(Math.round(num)) : fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = (count2)=>count2 >= 1 && count2 <= 2;\n_global.now = async function(_args, scope) {\n    return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function() {\n    throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    return value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    return value.type !== \"string\" ? NULL_VALUE : fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") return NULL_VALUE;\n    const sep = await execute(args[1], scope);\n    return sep.type !== \"string\" ? NULL_VALUE : str.data.length === 0 ? fromJS([]) : sep.data.length === 0 ? fromJS(Array.from(str.data)) : fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") return NULL_VALUE;\n    const prefix = await execute(args[1], scope);\n    return prefix.type !== \"string\" ? NULL_VALUE : str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    const sep = await execute(args[1], scope);\n    if (sep.type !== \"string\") return NULL_VALUE;\n    let buf = \"\", needSep = !1;\n    for await (const elem of arr){\n        switch(needSep && (buf += sep.data), elem.type){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n            case \"datetime\":\n                buf += `${elem.data}`;\n                break;\n            default:\n                return NULL_VALUE;\n        }\n        needSep = !0;\n    }\n    return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    return arr.isArray() ? new StreamValue(async function*() {\n        for await (const elem of arr)elem.type !== \"null\" && (yield elem);\n    }) : NULL_VALUE;\n};\narray.compact.arity = 1;\narray.unique = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    return value.isArray() ? new StreamValue(async function*() {\n        const added = /* @__PURE__ */ new Set();\n        for await (const iter of value)switch(iter.type){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n            case \"datetime\":\n                added.has(iter.data) || (added.add(iter.data), yield iter);\n                break;\n            default:\n                yield iter;\n        }\n    }) : NULL_VALUE;\n};\narray.unique.arity = 1;\narray.intersects = async function(args, scope, execute) {\n    const arr1 = await execute(args[0], scope);\n    if (!arr1.isArray()) return NULL_VALUE;\n    const arr2 = await execute(args[1], scope);\n    if (!arr2.isArray()) return NULL_VALUE;\n    for await (const v1 of arr1)for await (const v2 of arr2)if (isEqual(v1, v2)) return TRUE_VALUE;\n    return FALSE_VALUE;\n};\narray.intersects.arity = 2;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n    const value = await execute(args[0], scope), text = await portableTextContent(value);\n    return text === null ? NULL_VALUE : fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(_args, scope) {\n    return scope.context.sanity ? fromString(scope.context.sanity.projectId) : NULL_VALUE;\n};\nsanity.dataset = async function(_args, scope) {\n    return scope.context.sanity ? fromString(scope.context.sanity.dataset) : NULL_VALUE;\n};\nsanity.versionOf = async function(args, scope, execute) {\n    if (!scope.source.isArray()) return NULL_VALUE;\n    const value = await execute(args[0], scope);\n    if (value.type !== \"string\") return NULL_VALUE;\n    const baseId = value.data, versionIds = [];\n    for await (const value2 of scope.source)if (getType(value2) === \"object\") {\n        const val = await value2.get();\n        val && \"_id\" in val && val._id.split(\".\").length === 2 && val._id.endsWith(`.${baseId}`) && \"_version\" in val && typeof val._version == \"object\" && versionIds.push(val._id);\n    }\n    return fromJS(versionIds);\n};\nsanity.versionOf.arity = 1;\nsanity.documentsOf = async function(args, scope, execute) {\n    if (!scope.source.isArray()) return NULL_VALUE;\n    const value = await execute(args[0], scope);\n    if (value.type !== \"string\") return NULL_VALUE;\n    const baseId = value.data, documentIdsInBundle = [];\n    for await (const value2 of scope.source)if (getType(value2) === \"object\") {\n        const val = await value2.get();\n        val && \"_id\" in val && val._id.split(\".\").length === 2 && val._id.startsWith(`${baseId}.`) && \"_version\" in val && typeof val._version == \"object\" && documentIdsInBundle.push(val._id);\n    }\n    return fromJS(documentIdsInBundle);\n};\nsanity.documentsOf.arity = 1;\nconst pipeFunctions = {};\npipeFunctions.order = async function(base, args, scope, execute) {\n    if (await !0, !base.isArray()) return NULL_VALUE;\n    const mappers = [], directions = [];\n    let n = 0;\n    for (let mapper of args){\n        let direction = \"asc\";\n        mapper.type === \"Desc\" ? (direction = \"desc\", mapper = mapper.base) : mapper.type === \"Asc\" && (mapper = mapper.base), mappers.push(mapper), directions.push(direction), n++;\n    }\n    const aux = [];\n    let idx = 0;\n    for await (const value of base){\n        const newScope = scope.createNested(value), tuple = [\n            await value.get(),\n            idx\n        ];\n        for(let i = 0; i < n; i++){\n            const result = await execute(mappers[i], newScope);\n            tuple.push(await result.get());\n        }\n        aux.push(tuple), idx++;\n    }\n    return aux.sort((aTuple, bTuple)=>{\n        for(let i = 0; i < n; i++){\n            let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n            if (directions[i] === \"desc\" && (c = -c), c !== 0) return c;\n        }\n        return aTuple[1] - bTuple[1];\n    }), fromJS(aux.map((v)=>v[0]));\n};\npipeFunctions.order.arity = (count2)=>count2 >= 1;\npipeFunctions.score = async function(base, args, scope, execute) {\n    if (!base.isArray()) return NULL_VALUE;\n    const unknown = [], scored = [];\n    for await (const value of base){\n        if (value.type !== \"object\") {\n            unknown.push(await value.get());\n            continue;\n        }\n        const newScope = scope.createNested(value);\n        let valueScore = typeof value.data._score == \"number\" ? value.data._score : 0;\n        for (const arg of args)valueScore += await evaluateScore(arg, newScope, execute);\n        const newObject = Object.assign({}, value.data, {\n            _score: valueScore\n        });\n        scored.push(newObject);\n    }\n    return scored.sort((a, b)=>b._score - a._score), fromJS(scored);\n};\npipeFunctions.score.arity = (count2)=>count2 >= 1;\nconst delta = {};\ndelta.operation = async function(_args, scope) {\n    const hasBefore = scope.context.before !== null, hasAfter = scope.context.after !== null;\n    return hasBefore && hasAfter ? fromString(\"update\") : hasAfter ? fromString(\"create\") : hasBefore ? fromString(\"delete\") : NULL_VALUE;\n};\ndelta.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        (n === void 0 || elem.data < n) && (n = elem.data);\n    }\n    return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        (n === void 0 || elem.data > n) && (n = elem.data);\n    }\n    return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n = 0;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        n += elem.data;\n    }\n    return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) return NULL_VALUE;\n    let n = 0, c = 0;\n    for await (const elem of arr)if (elem.type !== \"null\") {\n        if (elem.type !== \"number\") return NULL_VALUE;\n        n += elem.data, c++;\n    }\n    return c === 0 ? NULL_VALUE : fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst dateTime2 = {};\ndateTime2.now = async function(_args, scope) {\n    return fromDateTime(new DateTime(scope.context.timestamp));\n};\ndateTime2.now.arity = 0;\nconst namespaces = {\n    global: _global,\n    string: string2,\n    array,\n    pt,\n    delta,\n    diff,\n    sanity,\n    math,\n    dateTime: dateTime2\n};\nclass MarkProcessor {\n    constructor(string, marks, parseOptions){\n        this.allowBoost = !1;\n        this.string = string, this.marks = marks, this.index = 0, this.parseOptions = parseOptions;\n    }\n    hasMark(pos = 0) {\n        return this.index + pos < this.marks.length;\n    }\n    getMark(pos = 0) {\n        return this.marks[this.index + pos];\n    }\n    shift() {\n        this.index += 1;\n    }\n    process(visitor) {\n        const mark = this.marks[this.index];\n        this.shift();\n        const func = visitor[mark.name];\n        if (!func) throw new Error(`Unknown handler: ${mark.name}`);\n        return func.call(visitor, this, mark);\n    }\n    processString() {\n        return this.shift(), this.processStringEnd();\n    }\n    processStringEnd() {\n        const prev = this.marks[this.index - 1], curr = this.marks[this.index];\n        return this.shift(), this.string.slice(prev.position, curr.position);\n    }\n    slice(len) {\n        const pos = this.marks[this.index].position;\n        return this.string.slice(pos, pos + len);\n    }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/, NUM = /^\\d+/, IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nfunction parse$1(str) {\n    let pos = 0;\n    pos = skipWS(str, pos);\n    let result = parseExpr(str, pos, 0);\n    return result.type === \"error\" ? result : (pos = skipWS(str, result.position), pos !== str.length ? (result.failPosition && (pos = result.failPosition - 1), {\n        type: \"error\",\n        position: pos\n    }) : (delete result.position, delete result.failPosition, result));\n}\nfunction parseExpr(str, pos, level) {\n    let startPos = pos, token = str[pos], marks;\n    switch(token){\n        case \"+\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"pos\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks), pos = rhs.position;\n                break;\n            }\n        case \"-\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 8);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"neg\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks), pos = rhs.position;\n                break;\n            }\n        case \"(\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n                if (rhs.type === \"error\") return rhs;\n                switch(pos = skipWS(str, rhs.position), str[pos]){\n                    case \",\":\n                        {\n                            for(marks = [\n                                {\n                                    name: \"tuple\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks), pos = skipWS(str, pos + 1);;){\n                                if (rhs = parseExpr(str, pos, 0), rhs.type === \"error\") return rhs;\n                                if (pos = skipWS(str, rhs.position), str[pos] !== \",\") break;\n                                pos = skipWS(str, pos + 1);\n                            }\n                            if (str[pos] !== \")\") return {\n                                type: \"error\",\n                                position: pos\n                            };\n                            pos++, marks.push({\n                                name: \"tuple_end\",\n                                position: pos\n                            });\n                            break;\n                        }\n                    case \")\":\n                        {\n                            pos++, marks = [\n                                {\n                                    name: \"group\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks);\n                            break;\n                        }\n                    default:\n                        return {\n                            type: \"error\",\n                            position: pos\n                        };\n                }\n                break;\n            }\n        case \"!\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 10);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"not\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks), pos = rhs.position;\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks, pos = result.position;\n                break;\n            }\n        case \"[\":\n            if (marks = [\n                {\n                    name: \"array\",\n                    position: pos\n                }\n            ], pos = skipWS(str, pos + 1), str[pos] !== \"]\") for(;;){\n                str.slice(pos, pos + 3) === \"...\" && (marks.push({\n                    name: \"array_splat\",\n                    position: pos\n                }), pos = skipWS(str, pos + 3));\n                let res = parseExpr(str, pos, 0);\n                if (res.type === \"error\") return res;\n                if (marks = marks.concat(res.marks), pos = res.position, pos = skipWS(str, pos), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \"]\")) break;\n            }\n            if (str[pos] === \"]\") pos++, marks.push({\n                name: \"array_end\",\n                position: pos\n            });\n            else return {\n                type: \"error\",\n                position: pos\n            };\n            break;\n        case \"'\":\n        case '\"':\n            {\n                let result = parseString(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks, pos = result.position;\n                break;\n            }\n        case \"^\":\n            {\n                for(pos++, marks = []; str[pos] === \".\" && str[pos + 1] === \"^\";)marks.push({\n                    name: \"dblparent\",\n                    position: startPos\n                }), pos += 2;\n                marks.push({\n                    name: \"parent\",\n                    position: startPos\n                });\n                break;\n            }\n        case \"@\":\n            marks = [\n                {\n                    name: \"this\",\n                    position: startPos\n                }\n            ], pos++;\n            break;\n        case \"*\":\n            marks = [\n                {\n                    name: \"everything\",\n                    position: startPos\n                }\n            ], pos++;\n            break;\n        case \"$\":\n            {\n                let identLen = parseRegex(str, pos + 1, IDENT);\n                identLen && (pos += 1 + identLen, marks = [\n                    {\n                        name: \"param\",\n                        position: startPos\n                    },\n                    {\n                        name: \"ident\",\n                        position: startPos + 1\n                    },\n                    {\n                        name: \"ident_end\",\n                        position: pos\n                    }\n                ]);\n                break;\n            }\n        default:\n            {\n                let numLen = parseRegex(str, pos, NUM);\n                if (numLen) {\n                    pos += numLen;\n                    let name = \"integer\";\n                    if (str[pos] === \".\") {\n                        let fracLen = parseRegex(str, pos + 1, NUM);\n                        fracLen && (name = \"float\", pos += 1 + fracLen);\n                    }\n                    if (str[pos] === \"e\" || str[pos] === \"E\") {\n                        name = \"sci\", pos++, (str[pos] === \"+\" || str[pos] === \"-\") && pos++;\n                        let expLen = parseRegex(str, pos, NUM);\n                        if (!expLen) return {\n                            type: \"error\",\n                            position: pos\n                        };\n                        pos += expLen;\n                    }\n                    marks = [\n                        {\n                            name,\n                            position: startPos\n                        },\n                        {\n                            name: name + \"_end\",\n                            position: pos\n                        }\n                    ];\n                    break;\n                }\n                let identLen = parseRegex(str, pos, IDENT);\n                if (identLen) {\n                    switch(pos += identLen, str[pos]){\n                        case \":\":\n                        case \"(\":\n                            {\n                                let result = parseFuncCall(str, startPos, pos);\n                                if (result.type === \"error\") return result;\n                                marks = result.marks, pos = result.position;\n                                break;\n                            }\n                        default:\n                            marks = [\n                                {\n                                    name: \"this_attr\",\n                                    position: startPos\n                                },\n                                {\n                                    name: \"ident\",\n                                    position: startPos\n                                },\n                                {\n                                    name: \"ident_end\",\n                                    position: pos\n                                }\n                            ];\n                    }\n                    break;\n                }\n            }\n    }\n    if (!marks) return {\n        type: \"error\",\n        position: pos\n    };\n    let lhsLevel = 12, trav;\n    loop: for(;;){\n        let innerPos = skipWS(str, pos);\n        if (innerPos === str.length) {\n            pos = innerPos;\n            break;\n        }\n        if (trav = parseTraversal(str, innerPos), trav.type === \"success\") {\n            for(marks.unshift({\n                name: \"traverse\",\n                position: startPos\n            }); trav.type === \"success\";)marks = marks.concat(trav.marks), pos = trav.position, trav = parseTraversal(str, skipWS(str, pos));\n            marks.push({\n                name: \"traversal_end\",\n                position: pos\n            });\n            continue;\n        }\n        switch(str[innerPos]){\n            case \"=\":\n                {\n                    switch(str[innerPos + 1]){\n                        case \">\":\n                            {\n                                if (level > 1 || lhsLevel <= 1) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), 1);\n                                if (rhs.type === \"error\") return rhs;\n                                marks = marks.concat(rhs.marks), marks.unshift({\n                                    name: \"pair\",\n                                    position: startPos\n                                }), pos = rhs.position, lhsLevel = 1;\n                                break;\n                            }\n                        case \"=\":\n                            {\n                                if (level > 4 || lhsLevel <= 4) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"comp\",\n                                    position: startPos\n                                }), marks.push({\n                                    name: \"op\",\n                                    position: innerPos\n                                }, {\n                                    name: \"op_end\",\n                                    position: innerPos + 2\n                                }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                                break;\n                            }\n                        default:\n                            break loop;\n                    }\n                    break;\n                }\n            case \"+\":\n                {\n                    if (level > 6 || lhsLevel < 6) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"add\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 6;\n                    break;\n                }\n            case \"-\":\n                {\n                    if (level > 6 || lhsLevel < 6) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 7);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"sub\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 6;\n                    break;\n                }\n            case \"*\":\n                {\n                    if (str[innerPos + 1] === \"*\") {\n                        if (level > 8 || lhsLevel <= 8) break loop;\n                        let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), 8);\n                        if (rhs2.type === \"error\") return rhs2;\n                        marks = marks.concat(rhs2.marks), marks.unshift({\n                            name: \"pow\",\n                            position: startPos\n                        }), pos = rhs2.position, lhsLevel = 8;\n                        break;\n                    }\n                    if (level > 7 || lhsLevel < 7) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"mul\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 7;\n                    break;\n                }\n            case \"/\":\n                {\n                    if (level > 7 || lhsLevel < 7) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"div\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 7;\n                    break;\n                }\n            case \"%\":\n                {\n                    if (level > 7 || lhsLevel < 7) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), 8);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"mod\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 7;\n                    break;\n                }\n            case \"<\":\n            case \">\":\n                {\n                    if (level > 4 || lhsLevel <= 4) break loop;\n                    let nextPos = innerPos + 1;\n                    str[nextPos] === \"=\" && nextPos++;\n                    let rhs = parseExpr(str, skipWS(str, nextPos), 5);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    }), marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: nextPos\n                    }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                    break;\n                }\n            case \"|\":\n                {\n                    if (str[innerPos + 1] === \"|\") {\n                        if (level > 2 || lhsLevel < 2) break loop;\n                        let rhs = parseExpr(str, skipWS(str, innerPos + 2), 3);\n                        if (rhs.type === \"error\") return rhs;\n                        marks = marks.concat(rhs.marks), marks.unshift({\n                            name: \"or\",\n                            position: startPos\n                        }), pos = rhs.position, lhsLevel = 2;\n                    } else {\n                        if (level > 11 || lhsLevel < 11) break loop;\n                        let identPos = skipWS(str, innerPos + 1), identLen = parseRegex(str, identPos, IDENT);\n                        if (!identLen) return {\n                            type: \"error\",\n                            position: identPos\n                        };\n                        if (pos = identPos + identLen, str[pos] === \"(\" || str[pos] === \":\") {\n                            let result = parseFuncCall(str, identPos, pos);\n                            if (result.type === \"error\") return result;\n                            marks = marks.concat(result.marks), marks.unshift({\n                                name: \"pipecall\",\n                                position: startPos\n                            }), pos = result.position, lhsLevel = 11;\n                        }\n                    }\n                    break;\n                }\n            case \"&\":\n                {\n                    if (str[innerPos + 1] != \"&\" || level > 3 || lhsLevel < 3) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), 4);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks), marks.unshift({\n                        name: \"and\",\n                        position: startPos\n                    }), pos = rhs.position, lhsLevel = 3;\n                    break;\n                }\n            case \"!\":\n                {\n                    if (str[innerPos + 1] !== \"=\" || level > 4 || lhsLevel <= 4) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    }), marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: innerPos + 2\n                    }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                    break;\n                }\n            case \"d\":\n                {\n                    if (str.slice(innerPos, innerPos + 4) !== \"desc\" || level > 4 || lhsLevel < 4) break loop;\n                    marks.unshift({\n                        name: \"desc\",\n                        position: startPos\n                    }), pos = innerPos + 4, lhsLevel = 4;\n                    break;\n                }\n            case \"a\":\n                {\n                    if (str.slice(innerPos, innerPos + 3) !== \"asc\" || level > 4 || lhsLevel < 4) break loop;\n                    marks.unshift({\n                        name: \"asc\",\n                        position: startPos\n                    }), pos = innerPos + 3, lhsLevel = 4;\n                    break;\n                }\n            default:\n                switch(parseRegexStr(str, innerPos, IDENT)){\n                    case \"in\":\n                        {\n                            if (level > 4 || lhsLevel <= 4) break loop;\n                            pos = skipWS(str, innerPos + 2);\n                            let isGroup = !1;\n                            str[pos] === \"(\" && (isGroup = !0, pos = skipWS(str, pos + 1));\n                            let rangePos = pos, result = parseExpr(str, pos, 5);\n                            if (result.type === \"error\") return result;\n                            if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n                                let type = \"inc_range\";\n                                str[pos + 2] === \".\" ? (type = \"exc_range\", pos = skipWS(str, pos + 3)) : pos = skipWS(str, pos + 2);\n                                let rhs = parseExpr(str, pos, 5);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"in_range\",\n                                    position: startPos\n                                }), marks = marks.concat({\n                                    name: type,\n                                    position: rangePos\n                                }, result.marks, rhs.marks), pos = rhs.position;\n                            } else marks.unshift({\n                                name: \"comp\",\n                                position: startPos\n                            }), marks.push({\n                                name: \"op\",\n                                position: innerPos\n                            }, {\n                                name: \"op_end\",\n                                position: innerPos + 2\n                            }), marks = marks.concat(result.marks);\n                            if (isGroup) {\n                                if (pos = skipWS(str, pos), str[pos] !== \")\") return {\n                                    type: \"error\",\n                                    position: pos\n                                };\n                                pos++;\n                            }\n                            lhsLevel = 4;\n                            break;\n                        }\n                    case \"match\":\n                        {\n                            if (level > 4 || lhsLevel <= 4) break loop;\n                            let rhs = parseExpr(str, skipWS(str, innerPos + 5), 5);\n                            if (rhs.type === \"error\") return rhs;\n                            marks.unshift({\n                                name: \"comp\",\n                                position: startPos\n                            }), marks.push({\n                                name: \"op\",\n                                position: innerPos\n                            }, {\n                                name: \"op_end\",\n                                position: innerPos + 5\n                            }), marks = marks.concat(rhs.marks), pos = rhs.position, lhsLevel = 4;\n                            break;\n                        }\n                    default:\n                        break loop;\n                }\n        }\n    }\n    let failPosition = trav?.type === \"error\" && trav.position;\n    return {\n        type: \"success\",\n        marks,\n        position: pos,\n        failPosition\n    };\n}\nfunction parseTraversal(str, pos) {\n    let startPos = pos;\n    switch(str[pos]){\n        case \".\":\n            {\n                pos = skipWS(str, pos + 1);\n                let identStart = pos, identLen2 = parseRegex(str, pos, IDENT);\n                return identLen2 ? (pos += identLen2, {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"attr_access\",\n                            position: startPos\n                        },\n                        {\n                            name: \"ident\",\n                            position: identStart\n                        },\n                        {\n                            name: \"ident_end\",\n                            position: pos\n                        }\n                    ],\n                    position: pos\n                }) : {\n                    type: \"error\",\n                    position: pos\n                };\n            }\n        case \"-\":\n            if (str[pos + 1] !== \">\") return {\n                type: \"error\",\n                position: pos\n            };\n            let marks = [\n                {\n                    name: \"deref\",\n                    position: startPos\n                }\n            ];\n            pos += 2;\n            let identPos = skipWS(str, pos), identLen = parseRegex(str, identPos, IDENT);\n            return identLen && (pos = identPos + identLen, marks.push({\n                name: \"deref_attr\",\n                position: identPos\n            }, {\n                name: \"ident\",\n                position: identPos\n            }, {\n                name: \"ident_end\",\n                position: pos\n            })), {\n                type: \"success\",\n                marks,\n                position: pos\n            };\n        case \"[\":\n            {\n                if (pos = skipWS(str, pos + 1), str[pos] === \"]\") return {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"array_postfix\",\n                            position: startPos\n                        }\n                    ],\n                    position: pos + 1\n                };\n                let rangePos = pos, result = parseExpr(str, pos, 0);\n                if (result.type === \"error\") return result;\n                if (pos = skipWS(str, result.position), str[pos] === \".\" && str[pos + 1] === \".\") {\n                    let type = \"inc_range\";\n                    str[pos + 2] === \".\" ? (type = \"exc_range\", pos += 3) : pos += 2, pos = skipWS(str, pos);\n                    let rhs = parseExpr(str, pos, 0);\n                    return rhs.type === \"error\" ? rhs : (pos = skipWS(str, rhs.position), str[pos] !== \"]\" ? {\n                        type: \"error\",\n                        position: pos\n                    } : {\n                        type: \"success\",\n                        marks: [\n                            {\n                                name: \"slice\",\n                                position: startPos\n                            },\n                            {\n                                name: type,\n                                position: rangePos\n                            }\n                        ].concat(result.marks, rhs.marks),\n                        position: pos + 1\n                    });\n                }\n                return str[pos] !== \"]\" ? {\n                    type: \"error\",\n                    position: pos\n                } : {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"square_bracket\",\n                            position: startPos\n                        }\n                    ].concat(result.marks),\n                    position: pos + 1\n                };\n            }\n        case \"|\":\n            {\n                if (pos = skipWS(str, pos + 1), str[pos] === \"{\") {\n                    let result = parseObject(str, pos);\n                    return result.type === \"error\" || result.marks.unshift({\n                        name: \"projection\",\n                        position: startPos\n                    }), result;\n                }\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                return result.type === \"error\" || result.marks.unshift({\n                    name: \"projection\",\n                    position: startPos\n                }), result;\n            }\n    }\n    return {\n        type: \"error\",\n        position: pos\n    };\n}\nfunction parseFuncCall(str, startPos, pos) {\n    let marks = [];\n    if (marks.push({\n        name: \"func_call\",\n        position: startPos\n    }), str[pos] === \":\" && str[pos + 1] === \":\") {\n        marks.push({\n            name: \"namespace\",\n            position: startPos\n        }), marks.push({\n            name: \"ident\",\n            position: startPos\n        }, {\n            name: \"ident_end\",\n            position: pos\n        }), pos = skipWS(str, pos + 2);\n        let nameLen = parseRegex(str, pos, IDENT);\n        if (!nameLen) return {\n            type: \"error\",\n            position: pos\n        };\n        if (marks.push({\n            name: \"ident\",\n            position: pos\n        }, {\n            name: \"ident_end\",\n            position: pos + nameLen\n        }), pos = skipWS(str, pos + nameLen), str[pos] !== \"(\") return {\n            type: \"error\",\n            position: pos\n        };\n        pos++, pos = skipWS(str, pos);\n    } else marks.push({\n        name: \"ident\",\n        position: startPos\n    }, {\n        name: \"ident_end\",\n        position: pos\n    }), pos = skipWS(str, pos + 1);\n    let lastPos = pos;\n    if (str[pos] !== \")\") for(;;){\n        let result = parseExpr(str, pos, 0);\n        if (result.type === \"error\") return result;\n        if (marks = marks.concat(result.marks), lastPos = result.position, pos = skipWS(str, result.position), str[pos] !== \",\" || (pos = skipWS(str, pos + 1), str[pos] === \")\")) break;\n    }\n    return str[pos] !== \")\" ? {\n        type: \"error\",\n        position: pos\n    } : (marks.push({\n        name: \"func_args_end\",\n        position: lastPos\n    }), {\n        type: \"success\",\n        marks,\n        position: pos + 1\n    });\n}\nfunction parseObject(str, pos) {\n    let marks = [\n        {\n            name: \"object\",\n            position: pos\n        }\n    ];\n    for(pos = skipWS(str, pos + 1); str[pos] !== \"}\";){\n        let pairPos = pos;\n        if (str.slice(pos, pos + 3) === \"...\") if (pos = skipWS(str, pos + 3), str[pos] !== \"}\" && str[pos] !== \",\") {\n            let expr = parseExpr(str, pos, 0);\n            if (expr.type === \"error\") return expr;\n            marks.push({\n                name: \"object_splat\",\n                position: pairPos\n            }), marks = marks.concat(expr.marks), pos = expr.position;\n        } else marks.push({\n            name: \"object_splat_this\",\n            position: pairPos\n        });\n        else {\n            let expr = parseExpr(str, pos, 0);\n            if (expr.type === \"error\") return expr;\n            let nextPos = skipWS(str, expr.position);\n            if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n                let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n                if (value.type === \"error\") return value;\n                marks.push({\n                    name: \"object_pair\",\n                    position: pairPos\n                }), marks = marks.concat(expr.marks, value.marks), pos = value.position;\n            } else marks = marks.concat({\n                name: \"object_expr\",\n                position: pos\n            }, expr.marks), pos = expr.position;\n        }\n        if (pos = skipWS(str, pos), str[pos] !== \",\") break;\n        pos = skipWS(str, pos + 1);\n    }\n    return str[pos] !== \"}\" ? {\n        type: \"error\",\n        position: pos\n    } : (pos++, marks.push({\n        name: \"object_end\",\n        position: pos\n    }), {\n        type: \"success\",\n        marks,\n        position: pos\n    });\n}\nfunction parseString(str, pos) {\n    let token = str[pos];\n    pos = pos + 1;\n    const marks = [\n        {\n            name: \"str\",\n            position: pos\n        }\n    ];\n    str: for(;; pos++){\n        if (pos > str.length) return {\n            type: \"error\",\n            position: pos\n        };\n        switch(str[pos]){\n            case token:\n                {\n                    marks.push({\n                        name: \"str_end\",\n                        position: pos\n                    }), pos++;\n                    break str;\n                }\n            case \"\\\\\":\n                marks.push({\n                    name: \"str_pause\",\n                    position: pos\n                }), str[pos + 1] === \"u\" ? str[pos + 2] === \"{\" ? (marks.push({\n                    name: \"unicode_hex\",\n                    position: pos + 3\n                }), pos = str.indexOf(\"}\", pos + 3), marks.push({\n                    name: \"unicode_hex_end\",\n                    position: pos\n                })) : (marks.push({\n                    name: \"unicode_hex\",\n                    position: pos + 2\n                }), marks.push({\n                    name: \"unicode_hex_end\",\n                    position: pos + 6\n                }), pos += 5) : (marks.push({\n                    name: \"single_escape\",\n                    position: pos + 1\n                }), pos += 1), marks.push({\n                    name: \"str_start\",\n                    position: pos + 1\n                });\n        }\n    }\n    return {\n        type: \"success\",\n        marks,\n        position: pos\n    };\n}\nfunction skipWS(str, pos) {\n    return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0] : null;\n}\nfunction join(a, b) {\n    return (base)=>b(a(base));\n}\nfunction map(inner) {\n    return (base)=>({\n            type: \"Map\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction flatMap(inner) {\n    return (base)=>({\n            type: \"FlatMap\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction traverseArray(build, right) {\n    if (!right) return {\n        type: \"a-a\",\n        build\n    };\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(build, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"a-a\",\n                build: join(build, map(right.build))\n            };\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, flatMap(right.build))\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nfunction traversePlain(mapper, right) {\n    if (!right) return {\n        type: \"b-b\",\n        build: mapper\n    };\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nfunction traverseElement(mapper, right) {\n    if (!right) return {\n        type: \"a-b\",\n        build: mapper\n    };\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"a-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nfunction traverseProjection(mapper, right) {\n    if (!right) return {\n        type: \"b-b\",\n        build: mapper\n    };\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(map(mapper), right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(map(mapper), right.build)\n            };\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(`unknown type: ${right.type}`);\n    }\n}\nconst ESCAPE_SEQUENCE = {\n    \"'\": \"'\",\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n    \"/\": \"/\",\n    b: \"\\b\",\n    f: \"\\f\",\n    n: `\n`,\n    r: \"\\r\",\n    t: \"\t\"\n};\nfunction expandHex(str) {\n    const charCode = parseInt(str, 16);\n    return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n    constructor(...args){\n        super(...args);\n        this.name = \"GroqQueryError\";\n    }\n}\nconst EXPR_BUILDER = {\n    group (p) {\n        return {\n            type: \"Group\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    everything () {\n        return {\n            type: \"Everything\"\n        };\n    },\n    this () {\n        return {\n            type: \"This\"\n        };\n    },\n    parent () {\n        return {\n            type: \"Parent\",\n            n: 1\n        };\n    },\n    dblparent (p) {\n        return {\n            type: \"Parent\",\n            n: p.process(EXPR_BUILDER).n + 1\n        };\n    },\n    traverse (p) {\n        const base = p.process(EXPR_BUILDER), traversalList = [];\n        for(; p.getMark().name !== \"traversal_end\";)traversalList.push(p.process(TRAVERSE_BUILDER));\n        p.shift();\n        let traversal = null;\n        for(let i = traversalList.length - 1; i >= 0; i--)traversal = traversalList[i](traversal);\n        if ((base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") && (traversal = traverseArray((val)=>val, traversal)), traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n        return traversal.build(base);\n    },\n    this_attr (p) {\n        const name = p.processString();\n        return name === \"null\" ? {\n            type: \"Value\",\n            value: null\n        } : name === \"true\" ? {\n            type: \"Value\",\n            value: !0\n        } : name === \"false\" ? {\n            type: \"Value\",\n            value: !1\n        } : {\n            type: \"AccessAttribute\",\n            name\n        };\n    },\n    neg (p) {\n        return {\n            type: \"Neg\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    pos (p) {\n        return {\n            type: \"Pos\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    add (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"+\",\n            left,\n            right\n        };\n    },\n    sub (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"-\",\n            left,\n            right\n        };\n    },\n    mul (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"*\",\n            left,\n            right\n        };\n    },\n    div (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"/\",\n            left,\n            right\n        };\n    },\n    mod (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"%\",\n            left,\n            right\n        };\n    },\n    pow (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"**\",\n            left,\n            right\n        };\n    },\n    comp (p) {\n        const left = p.process(EXPR_BUILDER), op = p.processString(), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op,\n            left,\n            right\n        };\n    },\n    in_range (p) {\n        const base = p.process(EXPR_BUILDER), isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"InRange\",\n            base,\n            left,\n            right,\n            isInclusive\n        };\n    },\n    str (p) {\n        let value = \"\";\n        loop: for(; p.hasMark();){\n            const mark = p.getMark();\n            switch(mark.name){\n                case \"str_end\":\n                    value += p.processStringEnd();\n                    break loop;\n                case \"str_pause\":\n                    value += p.processStringEnd();\n                    break;\n                case \"str_start\":\n                    p.shift();\n                    break;\n                case \"single_escape\":\n                    {\n                        const char = p.slice(1);\n                        p.shift(), value += ESCAPE_SEQUENCE[char];\n                        break;\n                    }\n                case \"unicode_hex\":\n                    p.shift(), value += expandHex(p.processStringEnd());\n                    break;\n                default:\n                    throw new Error(`unexpected mark: ${mark.name}`);\n            }\n        }\n        return {\n            type: \"Value\",\n            value\n        };\n    },\n    integer (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    float (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    sci (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    object (p) {\n        const attributes = [];\n        for(; p.getMark().name !== \"object_end\";)attributes.push(p.process(OBJECT_BUILDER));\n        return p.shift(), {\n            type: \"Object\",\n            attributes\n        };\n    },\n    array (p) {\n        const elements = [];\n        for(; p.getMark().name !== \"array_end\";){\n            let isSplat = !1;\n            p.getMark().name === \"array_splat\" && (isSplat = !0, p.shift());\n            const value = p.process(EXPR_BUILDER);\n            elements.push({\n                type: \"ArrayElement\",\n                value,\n                isSplat\n            });\n        }\n        return p.shift(), {\n            type: \"Array\",\n            elements\n        };\n    },\n    tuple (p) {\n        const members = [];\n        for(; p.getMark().name !== \"tuple_end\";)members.push(p.process(EXPR_BUILDER));\n        return p.shift(), {\n            type: \"Tuple\",\n            members\n        };\n    },\n    func_call (p) {\n        let namespace = \"global\";\n        p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString());\n        const name = p.processString();\n        if (namespace === \"global\" && name === \"select\") {\n            const result = {\n                type: \"Select\",\n                alternatives: []\n            };\n            for(; p.getMark().name !== \"func_args_end\";)if (p.getMark().name === \"pair\") {\n                if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                p.shift();\n                const condition = p.process(EXPR_BUILDER), value = p.process(EXPR_BUILDER);\n                result.alternatives.push({\n                    type: \"SelectAlternative\",\n                    condition,\n                    value\n                });\n            } else {\n                if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                const value = p.process(EXPR_BUILDER);\n                result.fallback = value;\n            }\n            return p.shift(), result;\n        }\n        const args = [];\n        for(; p.getMark().name !== \"func_args_end\";)argumentShouldBeSelector(namespace, name, args.length) ? (p.process(SELECTOR_BUILDER), args.push({\n            type: \"Selector\"\n        })) : args.push(p.process(EXPR_BUILDER));\n        if (p.shift(), namespace === \"global\" && (name === \"before\" || name === \"after\") && p.parseOptions.mode === \"delta\") return {\n            type: \"Context\",\n            key: name\n        };\n        if (namespace === \"global\" && name === \"boost\" && !p.allowBoost) throw new GroqQueryError(\"unexpected boost\");\n        const funcs = namespaces[namespace];\n        if (!funcs) throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n        const func = funcs[name];\n        if (!func) throw new GroqQueryError(`Undefined function: ${name}`);\n        if (func.arity !== void 0 && validateArity(name, func.arity, args.length), func.mode !== void 0 && func.mode !== p.parseOptions.mode) throw new GroqQueryError(`Undefined function: ${name}`);\n        return {\n            type: \"FuncCall\",\n            func,\n            namespace,\n            name,\n            args\n        };\n    },\n    pipecall (p) {\n        const base = p.process(EXPR_BUILDER);\n        p.shift();\n        let namespace = \"global\";\n        if (p.getMark().name === \"namespace\" && (p.shift(), namespace = p.processString()), namespace !== \"global\") throw new GroqQueryError(`Undefined namespace: ${namespace}`);\n        const name = p.processString(), args = [], oldAllowBoost = p.allowBoost;\n        for(name === \"score\" && (p.allowBoost = !0);;){\n            const markName = p.getMark().name;\n            if (markName === \"func_args_end\") break;\n            if (name === \"order\") {\n                if (markName === \"asc\") {\n                    p.shift(), args.push({\n                        type: \"Asc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                } else if (markName === \"desc\") {\n                    p.shift(), args.push({\n                        type: \"Desc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                }\n            }\n            args.push(p.process(EXPR_BUILDER));\n        }\n        p.shift(), p.allowBoost = oldAllowBoost;\n        const func = pipeFunctions[name];\n        if (!func) throw new GroqQueryError(`Undefined pipe function: ${name}`);\n        return func.arity && validateArity(name, func.arity, args.length), {\n            type: \"PipeFuncCall\",\n            func,\n            base,\n            name,\n            args\n        };\n    },\n    pair () {\n        throw new GroqQueryError(\"unexpected =>\");\n    },\n    and (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"And\",\n            left,\n            right\n        };\n    },\n    or (p) {\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER);\n        return {\n            type: \"Or\",\n            left,\n            right\n        };\n    },\n    not (p) {\n        return {\n            type: \"Not\",\n            base: p.process(EXPR_BUILDER)\n        };\n    },\n    asc () {\n        throw new GroqQueryError(\"unexpected asc\");\n    },\n    desc () {\n        throw new GroqQueryError(\"unexpected desc\");\n    },\n    param (p) {\n        const name = p.processString();\n        return p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name) ? {\n            type: \"Value\",\n            value: p.parseOptions.params[name]\n        } : {\n            type: \"Parameter\",\n            name\n        };\n    }\n}, OBJECT_BUILDER = {\n    object_expr (p) {\n        if (p.getMark().name === \"pair\") {\n            p.shift();\n            const condition = p.process(EXPR_BUILDER), value2 = p.process(EXPR_BUILDER);\n            return {\n                type: \"ObjectConditionalSplat\",\n                condition,\n                value: value2\n            };\n        }\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: extractPropertyKey(value),\n            value\n        };\n    },\n    object_pair (p) {\n        const name = p.process(EXPR_BUILDER);\n        if (name.type !== \"Value\") throw new Error(\"name must be string\");\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: name.value,\n            value\n        };\n    },\n    object_splat (p) {\n        return {\n            type: \"ObjectSplat\",\n            value: p.process(EXPR_BUILDER)\n        };\n    },\n    object_splat_this () {\n        return {\n            type: \"ObjectSplat\",\n            value: {\n                type: \"This\"\n            }\n        };\n    }\n}, TRAVERSE_BUILDER = {\n    square_bracket (p) {\n        const expr = p.process(EXPR_BUILDER), value = tryConstantEvaluate(expr);\n        return value && value.type === \"number\" ? (right)=>traverseElement((base)=>({\n                    type: \"AccessElement\",\n                    base,\n                    index: value.data\n                }), right) : value && value.type === \"string\" ? (right)=>traversePlain((base)=>({\n                    type: \"AccessAttribute\",\n                    base,\n                    name: value.data\n                }), right) : (right)=>traverseArray((base)=>({\n                    type: \"Filter\",\n                    base,\n                    expr\n                }), right);\n    },\n    slice (p) {\n        const isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER), right = p.process(EXPR_BUILDER), leftValue = tryConstantEvaluate(left), rightValue = tryConstantEvaluate(right);\n        if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") throw new GroqQueryError(\"slicing must use constant numbers\");\n        return (rhs)=>traverseArray((base)=>({\n                    type: \"Slice\",\n                    base,\n                    left: leftValue.data,\n                    right: rightValue.data,\n                    isInclusive\n                }), rhs);\n    },\n    projection (p) {\n        const obj = p.process(EXPR_BUILDER);\n        return (right)=>traverseProjection((base)=>({\n                    type: \"Projection\",\n                    base,\n                    expr: obj\n                }), right);\n    },\n    attr_access (p) {\n        const name = p.processString();\n        return (right)=>traversePlain((base)=>({\n                    type: \"AccessAttribute\",\n                    base,\n                    name\n                }), right);\n    },\n    deref (p) {\n        let attr = null;\n        p.getMark().name === \"deref_attr\" && (p.shift(), attr = p.processString());\n        const wrap = (base)=>attr ? {\n                type: \"AccessAttribute\",\n                base,\n                name: attr\n            } : base;\n        return (right)=>traversePlain((base)=>wrap({\n                    type: \"Deref\",\n                    base\n                }), right);\n    },\n    array_postfix () {\n        return (right)=>traverseArray((base)=>({\n                    type: \"ArrayCoerce\",\n                    base\n                }), right);\n    }\n}, SELECTOR_BUILDER = {\n    group (p) {\n        return p.process(SELECTOR_BUILDER), null;\n    },\n    everything () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    this () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    parent () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    dblparent () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    traverse (p) {\n        for(p.process(SELECTOR_BUILDER); p.getMark().name !== \"traversal_end\";)p.process(TRAVERSE_BUILDER);\n        return p.shift(), null;\n    },\n    this_attr (p) {\n        return p.processString(), null;\n    },\n    neg () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pos () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    add () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sub () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mul () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    div () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mod () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pow () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    comp () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    in_range () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    str () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    integer () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    float () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sci () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    object () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    array () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    tuple () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    func_call (p, mark) {\n        const func = EXPR_BUILDER.func_call(p, mark);\n        if (func.name === \"anywhere\" && func.args.length === 1) return null;\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pipecall () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pair () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    and () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    or () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    not () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    asc () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    desc () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    param () {\n        throw new Error(\"Invalid selector syntax\");\n    }\n};\nfunction extractPropertyKey(node) {\n    if (node.type === \"AccessAttribute\" && !node.base) return node.name;\n    if (node.type === \"PipeFuncCall\" || node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\" || node.type === \"Group\") return extractPropertyKey(node.base);\n    throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\n}\nfunction validateArity(name, arity, count) {\n    if (typeof arity == \"number\") {\n        if (count !== arity) throw new GroqQueryError(`Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`);\n    } else if (arity && !arity(count)) throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n    const functionsRequiringSelectors = [\n        \"changedAny\",\n        \"changedOnly\"\n    ];\n    return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n    constructor(position){\n        var _temp;\n        _temp = super(`Syntax error in GROQ query at position ${position}`), this.name = \"GroqSyntaxError\", _temp, this.position = position;\n    }\n}\nfunction parse(input, options = {}) {\n    const result = parse$1(input);\n    if (result.type === \"error\") throw new GroqSyntaxError(result.position);\n    return new MarkProcessor(input, result.marks, options).process(EXPR_BUILDER);\n}\nconst { compare } = new Intl.Collator(\"en\");\nfunction typeNodesSorter(a, b) {\n    return a.type === \"null\" ? 1 : compare(hashField(a), hashField(b));\n}\nfunction hashField(field) {\n    switch(field.type){\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n            return field.value !== void 0 ? `${field.type}(${field.value})` : `${field.type}`;\n        case \"null\":\n        case \"unknown\":\n            return field.type;\n        case \"array\":\n            return `${field.type}(${hashField(field.of)})`;\n        case \"object\":\n            {\n                const attributes = Object.entries(field.attributes);\n                return attributes.sort(([a], [b])=>compare(a, b)), `${field.type}:(${attributes.map(([key, value])=>`${key}:${hashField(value.value)}(${value.optional ? \"optional\" : \"non-optional\"})`).join(\",\")}):ref-${field.dereferencesTo}:${field.rest ? hashField(field.rest) : \"no-rest\"}`;\n            }\n        case \"union\":\n            {\n                const sorted = [\n                    ...field.of\n                ];\n                return sorted.sort(typeNodesSorter), `${field.type}(${sorted.map(hashField).join(\",\")})`;\n            }\n        case \"inline\":\n            return `${field.type}(${field.name})`;\n        default:\n            return field.type;\n    }\n}\nfunction removeDuplicateTypeNodes(typeNodes) {\n    const seenTypes = /* @__PURE__ */ new Set(), newTypeNodes = [], sortedTypeNodes = [\n        ...typeNodes\n    ];\n    sortedTypeNodes.sort(typeNodesSorter);\n    for (const typeNode of sortedTypeNodes){\n        const hash = hashField(typeNode);\n        if (hash === null) {\n            newTypeNodes.push(typeNode);\n            continue;\n        }\n        seenTypes.has(hash) || (seenTypes.add(hash), newTypeNodes.push(typeNode));\n    }\n    return newTypeNodes;\n}\nfunction optimizeUnions(field) {\n    if (field.type === \"union\") {\n        if (field.of.length === 0) return field;\n        if (field.of = removeDuplicateTypeNodes(field.of), field.of.length === 1) return optimizeUnions(field.of[0]);\n        for(let idx = 0; field.of.length > idx; idx++){\n            const subField = field.of[idx];\n            if (subField.type === \"union\") {\n                field.of.splice(idx, 1, ...subField.of), idx--;\n                continue;\n            }\n            field.of[idx] = optimizeUnions(subField);\n        }\n        return field.of.sort((a, b)=>a.type === \"null\" ? 1 : compare(hashField(a), hashField(b))), field;\n    }\n    if (field.type === \"array\") return field.of = optimizeUnions(field.of), field;\n    if (field.type === \"object\") {\n        for(const idx in field.attributes)Object.hasOwn(field.attributes, idx) && (field.attributes[idx].value = optimizeUnions(field.attributes[idx].value));\n        return field;\n    }\n    return field;\n}\nfunction createReferenceTypeNode(name, inArray = !1) {\n    const attributes = {\n        _ref: {\n            type: \"objectAttribute\",\n            value: {\n                type: \"string\"\n            }\n        },\n        _type: {\n            type: \"objectAttribute\",\n            value: {\n                type: \"string\",\n                value: \"reference\"\n            }\n        },\n        _weak: {\n            type: \"objectAttribute\",\n            value: {\n                type: \"boolean\"\n            },\n            optional: !0\n        }\n    };\n    return inArray && (attributes._key = {\n        type: \"objectAttribute\",\n        value: {\n            type: \"string\"\n        }\n    }), {\n        type: \"object\",\n        attributes,\n        dereferencesTo: name\n    };\n}\nfunction nullUnion(node) {\n    return node.type === \"union\" ? unionOf(...node.of, {\n        type: \"null\"\n    }) : unionOf(node, {\n        type: \"null\"\n    });\n}\nfunction unionOf(...nodes) {\n    return {\n        type: \"union\",\n        of: nodes\n    };\n}\nfunction resolveInline(node, scope) {\n    if (node.type === \"inline\") {\n        const resolvedInline = scope.context.lookupTypeDeclaration(node);\n        return resolveInline(resolvedInline, scope);\n    }\n    return node;\n}\nfunction mapNode(node, scope, mapper, mergeUnions = (nodes)=>optimizeUnions({\n        type: \"union\",\n        of: nodes\n    })) {\n    switch(node.type){\n        case \"boolean\":\n        case \"array\":\n        case \"null\":\n        case \"object\":\n        case \"string\":\n        case \"number\":\n        case \"unknown\":\n            return mapper(node);\n        case \"union\":\n            return mergeUnions(node.of.map((inner)=>mapNode(inner, scope, mapper), mergeUnions));\n        case \"inline\":\n            {\n                const resolvedInline = resolveInline(node, scope);\n                return mapNode(resolvedInline, scope, mapper, mergeUnions);\n            }\n        default:\n            throw new Error(`Unknown type: ${node.type}`);\n    }\n}\nfunction isFuncCall(node, name) {\n    return node.type === \"Group\" ? isFuncCall(node.base, name) : node.type === \"FuncCall\" && `${node.namespace}::${node.name}` === name;\n}\nfunction booleanValue(node, scope) {\n    switch(node.type){\n        case \"unknown\":\n            return {\n                canBeTrue: !0,\n                canBeFalse: !0,\n                canBeNull: !0\n            };\n        case \"boolean\":\n            return node.value === !0 ? {\n                canBeTrue: !0,\n                canBeFalse: !1,\n                canBeNull: !1\n            } : node.value === !1 ? {\n                canBeTrue: !1,\n                canBeFalse: !0,\n                canBeNull: !1\n            } : {\n                canBeTrue: !0,\n                canBeFalse: !0,\n                canBeNull: !1\n            };\n        case \"union\":\n            {\n                const value = {\n                    canBeTrue: !1,\n                    canBeFalse: !1,\n                    canBeNull: !1\n                };\n                for (const sub of node.of){\n                    const match2 = booleanValue(sub, scope);\n                    match2.canBeNull && (value.canBeNull = !0), match2.canBeTrue && (value.canBeTrue = !0), match2.canBeFalse && (value.canBeFalse = !0);\n                }\n                return value;\n            }\n        case \"inline\":\n            {\n                const resolved = resolveInline(node, scope);\n                return booleanValue(resolved, scope);\n            }\n        case \"null\":\n        case \"string\":\n        case \"number\":\n        case \"object\":\n        case \"array\":\n            return {\n                canBeTrue: !1,\n                canBeFalse: !1,\n                canBeNull: !0\n            };\n        default:\n            throw new Error(`unknown node type ${node.type}`);\n    }\n}\nfunction booleanOr(left, right) {\n    return left.canBeTrue && !left.canBeFalse && !left.canBeNull ? left : right.canBeTrue && !right.canBeFalse && !right.canBeNull ? right : {\n        // Either side can be true for the expression to be true\n        canBeTrue: left.canBeTrue || right.canBeTrue,\n        // Both sides must be false for the expression to be false\n        canBeFalse: left.canBeFalse && right.canBeFalse,\n        // if either side can be null, the expression can be null if the other side can't only be true\n        canBeNull: left.canBeNull || right.canBeNull\n    };\n}\nfunction booleanAnd(left, right) {\n    return left.canBeFalse && !left.canBeTrue && !left.canBeNull ? left : right.canBeFalse && !right.canBeTrue && !right.canBeNull ? right : {\n        // Both sides must be true for the expression to be true\n        canBeTrue: left.canBeTrue && right.canBeTrue,\n        // if either side can be false, the expression can be false\n        canBeFalse: left.canBeFalse || right.canBeFalse,\n        // if either side can be null, the expression can be null\n        canBeNull: left.canBeNull || right.canBeNull\n    };\n}\nfunction booleanInterpretationToTypeNode(bool) {\n    return bool.canBeTrue ? bool.canBeFalse ? bool.canBeNull ? nullUnion({\n        type: \"boolean\"\n    }) : {\n        type: \"boolean\"\n    } : bool.canBeNull ? nullUnion({\n        type: \"boolean\",\n        value: !0\n    }) : {\n        type: \"boolean\",\n        value: !0\n    } : bool.canBeFalse ? bool.canBeNull ? nullUnion({\n        type: \"boolean\",\n        value: !1\n    }) : {\n        type: \"boolean\",\n        value: !1\n    } : {\n        type: \"null\"\n    };\n}\nconst $trace$1 = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:scope:trace\");\n$trace$1.log = console.log.bind(console);\nclass Context {\n    constructor(schema){\n        this.schema = schema;\n    }\n    lookupRef(refTo) {\n        for (const val of this.schema)if (val.type === \"document\" && val.name === refTo) return {\n            type: \"object\",\n            attributes: val.attributes\n        };\n        return {\n            type: \"null\"\n        };\n    }\n    lookupTypeDeclaration(alias) {\n        for (const val of this.schema)if (val.type === \"type\" && val.name === alias.name) return val.value;\n        return {\n            type: \"null\"\n        };\n    }\n}\nclass Scope2 {\n    constructor(value, parent, context){\n        this.value = {\n            type: \"union\",\n            of: value\n        }, this.parent = parent, this.context = context || parent?.context || new Context([]), this.isHidden = !1;\n    }\n    createNested(value) {\n        return this.isHidden ? new Scope2(value, this.parent, this.context) : new Scope2(value, this, this.context);\n    }\n    createHidden(value) {\n        const result = this.createNested(value);\n        return result.isHidden = !0, result;\n    }\n}\nfunction unionWithoutNull(unionTypeNode) {\n    return unionTypeNode.type === \"union\" ? {\n        type: \"union\",\n        of: unionTypeNode.of.filter((type)=>type.type !== \"null\")\n    } : unionTypeNode;\n}\nfunction handleFuncCallNode(node, scope) {\n    switch(`${node.namespace}.${node.name}`){\n        case \"array.compact\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>{\n                    if (arg2.type === \"unknown\") return nullUnion({\n                        type: \"array\",\n                        of: {\n                            type: \"unknown\"\n                        }\n                    });\n                    if (arg2.type !== \"array\") return {\n                        type: \"null\"\n                    };\n                    const of = mapNode(arg2.of, scope, (of2)=>of2);\n                    return {\n                        type: \"array\",\n                        of: unionWithoutNull(of)\n                    };\n                });\n            }\n        case \"array.join\":\n            {\n                const arrayArg = walk({\n                    node: node.args[0],\n                    scope\n                }), sepArg = walk({\n                    node: node.args[1],\n                    scope\n                });\n                return mapNode(arrayArg, scope, (arrayArg2)=>mapNode(sepArg, scope, (sepArg2)=>arrayArg2.type === \"unknown\" || sepArg2.type === \"unknown\" ? nullUnion({\n                            type: \"string\"\n                        }) : arrayArg2.type !== \"array\" || sepArg2.type !== \"string\" ? {\n                            type: \"null\"\n                        } : mapNode(arrayArg2.of, scope, (of)=>of.type === \"unknown\" ? nullUnion({\n                                type: \"string\"\n                            }) : of.type !== \"string\" && of.type !== \"number\" && of.type !== \"boolean\" ? {\n                                type: \"null\"\n                            } : {\n                                type: \"string\"\n                            })));\n            }\n        case \"array.unique\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"array\",\n                        of: {\n                            type: \"unknown\"\n                        }\n                    }) : arg2.type !== \"array\" ? {\n                        type: \"null\"\n                    } : arg2);\n            }\n        case \"array.intersects\":\n            {\n                const arg1 = walk({\n                    node: node.args[0],\n                    scope\n                }), arg2 = walk({\n                    node: node.args[1],\n                    scope\n                });\n                return mapNode(arg1, scope, (arg12)=>mapNode(arg2, scope, (arg22)=>arg12.type !== \"array\" ? {\n                            type: \"null\"\n                        } : arg22.type !== \"array\" ? {\n                            type: \"null\"\n                        } : {\n                            type: \"boolean\"\n                        }));\n            }\n        case \"global.lower\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : arg2.type !== \"string\" ? {\n                        type: \"null\"\n                    } : arg2.value !== void 0 ? {\n                        type: \"string\",\n                        value: arg2.value.toLowerCase()\n                    } : {\n                        type: \"string\"\n                    });\n            }\n        case \"global.upper\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : arg2.type !== \"string\" ? {\n                        type: \"null\"\n                    } : arg2.value !== void 0 ? {\n                        type: \"string\",\n                        value: arg2.value.toUpperCase()\n                    } : {\n                        type: \"string\"\n                    });\n            }\n        case \"dateTime.now\":\n            return {\n                type: \"string\"\n            };\n        case \"global.now\":\n            return {\n                type: \"string\"\n            };\n        case \"global.defined\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (node2)=>node2.type === \"unknown\" ? {\n                        type: \"boolean\"\n                    } : {\n                        type: \"boolean\",\n                        value: node2.type !== \"null\"\n                    });\n            }\n        case \"global.path\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : arg2.type === \"string\" ? {\n                        type: \"string\"\n                    } : {\n                        type: \"null\"\n                    });\n            }\n        case \"global.coalesce\":\n            {\n                if (node.args.length === 0) return {\n                    type: \"null\"\n                };\n                const typeNodes = [];\n                let canBeNull = !0;\n                for (const arg of node.args){\n                    const argNode = optimizeUnions(walk({\n                        node: arg,\n                        scope\n                    })), allNull = argNode.type === \"null\" || argNode.type === \"union\" && argNode.of.every((t)=>t.type === \"null\");\n                    if (canBeNull = allNull || argNode.type === \"unknown\" || argNode.type === \"union\" && argNode.of.some((t)=>t.type === \"null\" || t.type === \"unknown\"), allNull || typeNodes.push(unionWithoutNull(argNode)), !canBeNull) break;\n                }\n                return canBeNull && typeNodes.push({\n                    type: \"null\"\n                }), {\n                    type: \"union\",\n                    of: typeNodes\n                };\n            }\n        case \"global.count\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : arg2.type === \"array\" ? {\n                        type: \"number\"\n                    } : {\n                        type: \"null\"\n                    });\n            }\n        case \"global.dateTime\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : arg2.type === \"string\" ? nullUnion({\n                        type: \"string\"\n                    }) : {\n                        type: \"null\"\n                    });\n            }\n        case \"global.length\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (arg2)=>arg2.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : arg2.type === \"array\" || arg2.type === \"string\" ? {\n                        type: \"number\"\n                    } : {\n                        type: \"null\"\n                    });\n            }\n        case \"global.references\":\n            return {\n                type: \"boolean\"\n            };\n        case \"global.round\":\n            {\n                const numNode = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(numNode, scope, (num)=>{\n                    if (num.type === \"unknown\") return nullUnion({\n                        type: \"number\"\n                    });\n                    if (num.type !== \"number\") return {\n                        type: \"null\"\n                    };\n                    if (node.args.length === 2) {\n                        const precisionNode = walk({\n                            node: node.args[1],\n                            scope\n                        });\n                        return mapNode(precisionNode, scope, (precision)=>precision.type === \"unknown\" ? nullUnion({\n                                type: \"number\"\n                            }) : precision.type !== \"number\" ? {\n                                type: \"null\"\n                            } : {\n                                type: \"number\"\n                            });\n                    }\n                    return {\n                        type: \"number\"\n                    };\n                });\n            }\n        case \"global.string\":\n            {\n                const arg = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(arg, scope, (node2)=>node2.type === \"unknown\" ? nullUnion({\n                        type: \"string\"\n                    }) : node2.type === \"string\" || node2.type === \"number\" || node2.type === \"boolean\" ? node2.value ? {\n                        type: \"string\",\n                        value: node2.value.toString()\n                    } : {\n                        type: \"string\"\n                    } : {\n                        type: \"null\"\n                    });\n            }\n        case \"math.sum\":\n            {\n                const values = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(values, scope, (node2)=>node2.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : node2.type !== \"array\" ? {\n                        type: \"null\"\n                    } : mapNode(node2.of, scope, (node3)=>node3.type === \"unknown\" ? nullUnion({\n                            type: \"number\"\n                        }) : node3.type === \"number\" || node3.type === \"null\" ? {\n                            type: \"number\"\n                        } : {\n                            type: \"null\"\n                        }));\n            }\n        case \"math.avg\":\n            {\n                const values = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(values, scope, (node2)=>node2.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : node2.type !== \"array\" ? {\n                        type: \"null\"\n                    } : mapNode(node2.of, scope, (node3)=>node3.type === \"unknown\" ? nullUnion({\n                            type: \"number\"\n                        }) : node3.type === \"number\" ? {\n                            type: \"number\"\n                        } : {\n                            type: \"null\"\n                        }));\n            }\n        case \"math.max\":\n        case \"math.min\":\n            {\n                const values = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(values, scope, (node2)=>node2.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : node2.type !== \"array\" ? {\n                        type: \"null\"\n                    } : mapNode(node2.of, scope, (node3)=>node3.type === \"unknown\" ? nullUnion({\n                            type: \"number\"\n                        }) : node3.type === \"number\" ? node3 : {\n                            type: \"null\"\n                        }));\n            }\n        case \"pt.text\":\n            return node.args.length === 0 ? {\n                type: \"null\"\n            } : {\n                type: \"string\"\n            };\n        case \"string.startsWith\":\n            {\n                const strTypeNode = walk({\n                    node: node.args[0],\n                    scope\n                }), prefixTypeNode = walk({\n                    node: node.args[1],\n                    scope\n                });\n                return mapNode(strTypeNode, scope, (strNode)=>mapNode(prefixTypeNode, scope, (prefixNode)=>strNode.type === \"unknown\" || prefixNode.type === \"unknown\" ? nullUnion({\n                            type: \"boolean\"\n                        }) : strNode.type !== \"string\" || prefixNode.type !== \"string\" ? {\n                            type: \"null\"\n                        } : {\n                            type: \"boolean\"\n                        }));\n            }\n        case \"string.split\":\n            {\n                const strTypeNode = walk({\n                    node: node.args[0],\n                    scope\n                }), sepTypeNode = walk({\n                    node: node.args[1],\n                    scope\n                });\n                return mapNode(strTypeNode, scope, (strNode)=>mapNode(sepTypeNode, scope, (sepNode)=>strNode.type === \"unknown\" || sepNode.type === \"unknown\" ? nullUnion({\n                            type: \"array\",\n                            of: {\n                                type: \"string\"\n                            }\n                        }) : strNode.type !== \"string\" || sepNode.type !== \"string\" ? {\n                            type: \"null\"\n                        } : {\n                            type: \"array\",\n                            of: {\n                                type: \"string\"\n                            }\n                        }));\n            }\n        case \"sanity.versionOf\":\n            {\n                const typeNode = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(typeNode, scope, (typeNode2)=>typeNode2.type === \"unknown\" ? nullUnion({\n                        type: \"array\",\n                        of: {\n                            type: \"string\"\n                        }\n                    }) : typeNode2.type !== \"string\" ? {\n                        type: \"null\"\n                    } : {\n                        type: \"array\",\n                        of: {\n                            type: \"string\"\n                        }\n                    });\n            }\n        case \"sanity.documentsOf\":\n            {\n                const typeNode = walk({\n                    node: node.args[0],\n                    scope\n                });\n                return mapNode(typeNode, scope, (typeNode2)=>typeNode2.type === \"unknown\" ? nullUnion({\n                        type: \"array\",\n                        of: {\n                            type: \"string\"\n                        }\n                    }) : typeNode2.type !== \"string\" ? {\n                        type: \"null\"\n                    } : {\n                        type: \"array\",\n                        of: {\n                            type: \"string\"\n                        }\n                    });\n            }\n        default:\n            return {\n                type: \"unknown\"\n            };\n    }\n}\nfunction match(left, right) {\n    let tokens = [], patterns = [];\n    if (left.type === \"string\") {\n        if (left.value === void 0) return;\n        tokens = tokens.concat(matchTokenize(left.value));\n    }\n    if (left.type === \"array\") {\n        if (left.of.type === \"unknown\") return;\n        if (left.of.type === \"string\") {\n            if (left.of.value === void 0) return;\n            tokens = tokens.concat(matchTokenize(left.of.value));\n        }\n        if (left.of.type === \"union\") for (const node of left.of.of)node.type === \"string\" && node.value !== void 0 && (tokens = tokens.concat(matchTokenize(node.value)));\n    }\n    if (right.type === \"string\") {\n        if (right.value === void 0) return;\n        patterns = patterns.concat(matchAnalyzePattern(right.value));\n    }\n    if (right.type === \"array\") {\n        if (right.of.type === \"unknown\") return;\n        if (right.of.type === \"string\") {\n            if (right.of.value === void 0) return;\n            patterns = patterns.concat(matchAnalyzePattern(right.of.value));\n        }\n        if (right.of.type === \"union\") for (const node of right.of.of){\n            if (node.type === \"string\") {\n                if (node.value === void 0) return;\n                patterns = patterns.concat(matchAnalyzePattern(node.value));\n            }\n            if (node.type !== \"string\") return !1;\n        }\n    }\n    return matchText(tokens, patterns);\n}\nconst $trace = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:trace\");\n$trace.log = console.log.bind(console);\nconst $debug = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:debug\");\n$debug.log = console.log.bind(console);\nconst $warn = debug__WEBPACK_IMPORTED_MODULE_0__(\"typeEvaluator:evaluate:warn\");\nfunction typeEvaluate(ast, schema) {\n    $debug(\"evaluateQueryType.ast %O\", ast), $debug(\"evaluateQueryType.schema %O\", schema);\n    const parsed = walk({\n        node: ast,\n        scope: new Scope2([], void 0, new Context(schema))\n    });\n    $trace(\"evaluateQueryType.parsed %O\", parsed);\n    const optimized = optimizeUnions(parsed);\n    return $debug(\"evaluateQueryType.optimized %O\", optimized), optimized;\n}\nfunction mapDeref(base, scope) {\n    return base.type === \"union\" ? {\n        type: \"union\",\n        of: base.of.map((node)=>mapDeref(node, scope))\n    } : base.type === \"array\" ? {\n        type: \"array\",\n        of: mapDeref(base.of, scope)\n    } : base.type === \"object\" && base.dereferencesTo !== void 0 ? scope.context.lookupRef(base.dereferencesTo) : {\n        type: \"null\"\n    };\n}\nfunction handleDerefNode(node, scope) {\n    $trace(\"deref.node %O\", node);\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    if ($trace(\"deref.base %O\", base), base.type === \"null\" || base.type === \"unknown\") return {\n        type: \"null\"\n    };\n    const derefedNode = mapDeref(base, scope);\n    return $trace(\"deref.derefedNode %O\", derefedNode), derefedNode;\n}\nfunction handleObjectSplatNode(attr, scope) {\n    const value = walk({\n        node: attr.value,\n        scope\n    });\n    return $trace(\"object.splat.value %O\", value), mapNode(value, scope, (node)=>{\n        if (node.type === \"unknown\") return {\n            type: \"unknown\"\n        };\n        if (node.type !== \"object\") return {\n            type: \"object\",\n            attributes: {}\n        };\n        const attributes = {};\n        for(const name in node.attributes)node.attributes.hasOwnProperty(name) && (attributes[name] = node.attributes[name]);\n        if (node.rest !== void 0) {\n            const resolvedRest = resolveInline(node.rest, scope);\n            if (resolvedRest.type === \"unknown\") return {\n                type: \"unknown\"\n            };\n            if (resolvedRest.type !== \"object\") return {\n                type: \"null\"\n            };\n            for(const name in resolvedRest.attributes)resolvedRest.attributes.hasOwnProperty(name) && (attributes[name] = resolvedRest.attributes[name]);\n        }\n        return {\n            type: \"object\",\n            attributes\n        };\n    });\n}\nfunction handleObjectNode(node, scope) {\n    if ($trace(\"object.node %O\", node), node.attributes.length === 0) return {\n        type: \"object\",\n        attributes: {}\n    };\n    const objectAttributes = [], splatVariants = [], conditionalVariants = [];\n    for (const [idx, attr] of node.attributes.entries()){\n        if (attr.type === \"ObjectAttributeValue\") {\n            const attributeNode = walk({\n                node: attr.value,\n                scope\n            });\n            objectAttributes.push([\n                idx,\n                attr.name,\n                {\n                    type: \"objectAttribute\",\n                    value: attributeNode\n                }\n            ]);\n            continue;\n        }\n        if (attr.type === \"ObjectSplat\") {\n            const attributeNode = handleObjectSplatNode(attr, scope);\n            switch($trace(\"object.splat.result %O\", attributeNode), attributeNode.type){\n                case \"object\":\n                    {\n                        splatVariants.push([\n                            idx,\n                            attributeNode\n                        ]);\n                        continue;\n                    }\n                case \"union\":\n                    {\n                        for (const node2 of attributeNode.of)if (node2.type === \"unknown\") return node2;\n                        splatVariants.push([\n                            idx,\n                            attributeNode\n                        ]);\n                        continue;\n                    }\n                default:\n                    return {\n                        type: \"unknown\"\n                    };\n            }\n        }\n        if (attr.type === \"ObjectConditionalSplat\") {\n            const condition = booleanValue(walk({\n                node: attr.condition,\n                scope\n            }), scope);\n            if ($trace(\"object.conditional.splat.condition %O\", condition), condition.canBeTrue === !1) continue;\n            const attributeNode = handleObjectSplatNode(attr, scope);\n            if ($trace(\"object.conditional.splat.result %O\", attributeNode), condition.canBeFalse === !1 && condition.canBeNull === !1) switch(attributeNode.type){\n                case \"object\":\n                    {\n                        splatVariants.push([\n                            idx,\n                            attributeNode\n                        ]);\n                        continue;\n                    }\n                case \"union\":\n                    {\n                        for (const node2 of attributeNode.of)if (node2.type !== \"object\") return {\n                            type: \"unknown\"\n                        };\n                        splatVariants.push([\n                            idx,\n                            attributeNode\n                        ]);\n                        continue;\n                    }\n                default:\n                    return {\n                        type: \"unknown\"\n                    };\n            }\n            const variant = mapNode(attributeNode, scope, (attributeNode2)=>($trace(\"object.conditional.splat.result.concrete %O\", attributeNode2), attributeNode2.type !== \"object\" ? {\n                    type: \"unknown\"\n                } : {\n                    type: \"object\",\n                    attributes: attributeNode2.attributes\n                }));\n            if (variant.type === \"union\") {\n                for (const node2 of variant.of)if (node2.type !== \"object\") return {\n                    type: \"unknown\"\n                };\n                variant.of.push({\n                    type: \"object\",\n                    attributes: {}\n                }), conditionalVariants.push([\n                    idx,\n                    variant\n                ]);\n                continue;\n            }\n            if (variant.type !== \"object\") return {\n                type: \"unknown\"\n            };\n            conditionalVariants.push([\n                idx,\n                {\n                    type: \"union\",\n                    of: [\n                        {\n                            type: \"object\",\n                            attributes: {}\n                        },\n                        variant\n                    ]\n                }\n            ]);\n            continue;\n        }\n        throw new Error(`Unknown object attribute type: ${attr.type}`);\n    }\n    const guaranteedAttributes = [];\n    guaranteedAttributes.push(...objectAttributes);\n    for (const [idx, splatNode] of splatVariants){\n        if (splatNode.type === \"object\") {\n            for(const name in splatNode.attributes){\n                if (!splatNode.attributes.hasOwnProperty(name)) continue;\n                const attribute = splatNode.attributes[name];\n                guaranteedAttributes.push([\n                    idx,\n                    name,\n                    attribute\n                ]);\n            }\n            continue;\n        }\n        conditionalVariants.push([\n            idx,\n            splatNode\n        ]);\n    }\n    if (guaranteedAttributes.sort(([a], [b])=>a - b), conditionalVariants.length === 0) return {\n        type: \"object\",\n        attributes: Object.fromEntries(guaranteedAttributes.map(([, name, attribute])=>[\n                name,\n                attribute\n            ]))\n    };\n    const matrix = [];\n    for (const [unionIdx, union] of conditionalVariants){\n        const unionGuaranteedBefore = [], unionGuaranteedAfter = [];\n        for (const [guaranteedIndex, name, attribute] of guaranteedAttributes)guaranteedIndex < unionIdx && unionGuaranteedBefore.push([\n            guaranteedIndex,\n            name,\n            attribute\n        ]), guaranteedIndex > unionIdx && unionGuaranteedAfter.push([\n            guaranteedIndex,\n            name,\n            attribute\n        ]);\n        const allVariantsAttributes = [];\n        for (const [conditionalVariantIdx, otherUnion] of conditionalVariants){\n            const variantAttributes = [];\n            for (const node2 of otherUnion.of)variantAttributes.push(node2.attributes);\n            allVariantsAttributes.push([\n                conditionalVariantIdx,\n                variantAttributes\n            ]);\n        }\n        for (const node2 of union.of){\n            matrix.push({\n                type: \"object\",\n                attributes: {\n                    ...Object.fromEntries(unionGuaranteedBefore.map(([, name, attribute])=>[\n                            name,\n                            attribute\n                        ])),\n                    ...node2.attributes,\n                    ...Object.fromEntries(unionGuaranteedAfter.map(([, name, attribute])=>[\n                            name,\n                            attribute\n                        ]))\n                }\n            });\n            for (const [outerIdx, outerAttributes] of allVariantsAttributes)for (const outer of outerAttributes)for (const [innerIdx, innerAttributes] of allVariantsAttributes)if (outerIdx !== innerIdx) for (const inner of innerAttributes){\n                const _before = [\n                    ...unionGuaranteedBefore\n                ], _after = [\n                    ...unionGuaranteedAfter\n                ];\n                for(const name in outer)outer.hasOwnProperty(name) && outerIdx !== unionIdx && (outerIdx < unionIdx && _before.push([\n                    outerIdx,\n                    name,\n                    outer[name]\n                ]), outerIdx > unionIdx && _after.push([\n                    outerIdx,\n                    name,\n                    outer[name]\n                ]));\n                for(const name in inner)inner.hasOwnProperty(name) && outerIdx !== unionIdx && (innerIdx < unionIdx && _before.push([\n                    innerIdx,\n                    name,\n                    inner[name]\n                ]), innerIdx > unionIdx && _after.push([\n                    innerIdx,\n                    name,\n                    inner[name]\n                ]));\n                _before.sort(([a], [b])=>a - b), _after.sort(([a], [b])=>a - b);\n                const before = Object.fromEntries(_before.map(([, name, attribute])=>[\n                        name,\n                        attribute\n                    ])), after = Object.fromEntries(_after.map(([, name, attribute])=>[\n                        name,\n                        attribute\n                    ]));\n                matrix.push({\n                    type: \"object\",\n                    attributes: {\n                        ...before,\n                        ...node2.attributes,\n                        ...after\n                    }\n                });\n            }\n        }\n    }\n    return optimizeUnions({\n        type: \"union\",\n        of: matrix\n    });\n}\nfunction handleOpCallNode(node, scope) {\n    $trace(\"opcall.node %O\", node);\n    const lhs = walk({\n        node: node.left,\n        scope\n    }), rhs = walk({\n        node: node.right,\n        scope\n    });\n    return mapNode(lhs, scope, (left)=>// eslint-disable-next-line complexity, max-statements\n        mapNode(rhs, scope, (right)=>{\n            switch($trace('opcall.node.concrete \"%s\" %O', node.op, {\n                left,\n                right\n            }), node.op){\n                case \"==\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? {\n                        type: \"boolean\"\n                    } : left.type !== right.type ? {\n                        type: \"boolean\",\n                        value: !1\n                    } : left.type === \"null\" ? {\n                        type: \"boolean\",\n                        value: !0\n                    } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? {\n                        type: \"boolean\",\n                        value: !1\n                    } : {\n                        type: \"boolean\",\n                        value: evaluateComparison(node.op, left, right)\n                    };\n                case \"!=\":\n                    {\n                        if (left.type === \"unknown\" || right.type === \"unknown\") return {\n                            type: \"boolean\"\n                        };\n                        if (left.type !== right.type) return {\n                            type: \"boolean\",\n                            value: !0\n                        };\n                        if (left.type === \"null\") return {\n                            type: \"boolean\",\n                            value: !1\n                        };\n                        if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) return {\n                            type: \"boolean\",\n                            value: !0\n                        };\n                        let value = evaluateComparison(\"==\", left, right);\n                        return value !== void 0 && (value = !value), {\n                            type: \"boolean\",\n                            value\n                        };\n                    }\n                case \">\":\n                case \">=\":\n                case \"<\":\n                case \"<=\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"boolean\"\n                    }) : left.type !== right.type ? {\n                        type: \"null\"\n                    } : !isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right) ? {\n                        type: \"null\"\n                    } : {\n                        type: \"boolean\",\n                        value: evaluateComparison(node.op, left, right)\n                    };\n                case \"in\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"boolean\"\n                    }) : right.type !== \"array\" ? isFuncCall(node.right, \"global::path\") ? {\n                        type: \"boolean\"\n                    } : {\n                        type: \"null\"\n                    } : !isPrimitiveTypeNode(left) && left.type !== \"null\" ? {\n                        type: \"boolean\",\n                        value: !1\n                    } : mapNode(right.of, scope, (arrayTypeNode)=>arrayTypeNode.type === \"unknown\" ? nullUnion({\n                            type: \"boolean\"\n                        }) : left.type === \"null\" ? {\n                            type: \"boolean\",\n                            value: arrayTypeNode.type === \"null\"\n                        } : left.value === void 0 ? {\n                            type: \"boolean\"\n                        } : isPrimitiveTypeNode(arrayTypeNode) ? arrayTypeNode.value === void 0 ? {\n                            type: \"boolean\"\n                        } : {\n                            type: \"boolean\",\n                            value: left.value === arrayTypeNode.value\n                        } : {\n                            type: \"boolean\",\n                            value: !1\n                        });\n                case \"match\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? {\n                        type: \"boolean\"\n                    } : {\n                        type: \"boolean\",\n                        value: match(left, right)\n                    };\n                case \"+\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? {\n                        type: \"unknown\"\n                    } : left.type === \"string\" && right.type === \"string\" ? {\n                        type: \"string\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n                    } : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value + right.value : void 0\n                    } : left.type === \"array\" && right.type === \"array\" ? {\n                        type: \"array\",\n                        of: {\n                            type: \"union\",\n                            of: [\n                                left.of,\n                                right.of\n                            ]\n                        }\n                    } : left.type === \"object\" && right.type === \"object\" ? {\n                        type: \"object\",\n                        attributes: {\n                            ...left.attributes,\n                            ...right.attributes\n                        }\n                    } : {\n                        type: \"null\"\n                    };\n                case \"-\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value - right.value : void 0\n                    } : {\n                        type: \"null\"\n                    };\n                case \"*\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value * right.value : void 0\n                    } : {\n                        type: \"null\"\n                    };\n                case \"/\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value / right.value : void 0\n                    } : {\n                        type: \"null\"\n                    };\n                case \"**\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value ** right.value : void 0\n                    } : {\n                        type: \"null\"\n                    };\n                case \"%\":\n                    return left.type === \"unknown\" || right.type === \"unknown\" ? nullUnion({\n                        type: \"number\"\n                    }) : left.type === \"number\" && right.type === \"number\" ? {\n                        type: \"number\",\n                        value: left.value !== void 0 && right.value !== void 0 ? left.value % right.value : void 0\n                    } : {\n                        type: \"null\"\n                    };\n                default:\n                    return {\n                        type: \"unknown\"\n                    };\n            }\n        }));\n}\nfunction handleSelectNode(node, scope) {\n    const values = [];\n    let guaranteed = !1;\n    for (const alternative of node.alternatives){\n        const conditionValue = walk({\n            node: alternative.condition,\n            scope\n        }), conditionScope = resolveFilter(alternative.condition, scope);\n        conditionScope.type === \"union\" && conditionScope.of.length > 0 && values.push(walk({\n            node: alternative.value,\n            scope: scope.createHidden(conditionScope.of)\n        })), conditionValue.type === \"boolean\" && conditionValue.value === !0 && (guaranteed = !0);\n    }\n    return node.fallback && !guaranteed && values.push(walk({\n        node: node.fallback,\n        scope\n    })), values.length === 0 ? {\n        type: \"null\"\n    } : {\n        type: \"union\",\n        of: values\n    };\n}\nfunction handleArrayCoerceNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return $trace(\"arrayCoerce.base %O\", base), mapArray(base, scope, (base2)=>base2);\n}\nfunction handleFlatMap(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return mapArray(base, scope, (base2)=>{\n        const inner = walk({\n            node: node.expr,\n            scope: scope.createHidden([\n                base2.of\n            ])\n        });\n        return mapNode(inner, scope, (inner2)=>inner2.type === \"array\" ? inner2 : {\n                type: \"array\",\n                of: inner2\n            }, (nodes)=>{\n            const inner2 = [];\n            for (const node2 of nodes){\n                if (node2.type === \"unknown\") return {\n                    type: \"array\",\n                    of: node2\n                };\n                if (node2.type !== \"array\") throw new Error(`Unexpected type: ${node2.type}`);\n                inner2.push(node2.of);\n            }\n            return {\n                type: \"array\",\n                of: optimizeUnions({\n                    type: \"union\",\n                    of: inner2\n                })\n            };\n        });\n    });\n}\nfunction handleMap(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return $trace(\"map.base %O\", base), mapArray(base, scope, (base2)=>({\n            type: \"array\",\n            of: walk({\n                node: node.expr,\n                scope: scope.createHidden([\n                    base2.of\n                ])\n            })\n        }));\n}\nfunction handleProjectionNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return $trace(\"projection.base %O\", base), mapObject(base, scope, (base2)=>walk({\n            node: node.expr,\n            scope: scope.createNested([\n                base2\n            ])\n        }));\n}\nfunction createFilterScope(base, scope) {\n    return base.type === \"array\" ? base.of.type === \"union\" ? scope.createNested(base.of.of) : scope.createNested([\n        base.of\n    ]) : scope.createNested([\n        base\n    ]);\n}\nfunction handleFilterNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return $trace(\"filter.base %O\", base), mapNode(base, scope, (base2)=>{\n        if ($trace(\"filter.resolving %O\", base2), base2.type === \"null\") return base2;\n        const resolved = resolveFilter(node.expr, createFilterScope(base2, scope));\n        return $trace(\"filter.resolved %O\", resolved), {\n            type: \"array\",\n            of: resolved\n        };\n    });\n}\nfunction handleAccessAttributeNode(node, scope) {\n    let attributeBase = scope.value;\n    return node.base && (attributeBase = walk({\n        node: node.base,\n        scope\n    })), $trace(\"accessAttribute.base %s %O\", node.name, attributeBase), handleAccessAttributeBase(attributeBase, node.name, scope);\n}\nfunction handleAccessAttributeBase(base, name, scope) {\n    return mapObject(base, scope, (base2)=>{\n        $trace('Looking for attribute \"%s\" in object %O', name, base2);\n        const attribute = base2.attributes[name];\n        return attribute !== void 0 ? ($debug(`accessAttribute.attribute found ${name} %O`, attribute), attribute.optional ? nullUnion(attribute.value) : attribute.value) : base2.rest ? handleAccessAttributeBase(base2.rest, name, scope) : ($warn(`attribute \"${name}\" not found in object`), {\n            type: \"null\"\n        });\n    });\n}\nfunction handleAccessElementNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return $trace(\"accessElement.base %O\", base), mapArray(base, scope, (base2)=>nullUnion(base2.of));\n}\nfunction handleArrayNode(node, scope) {\n    const of = [];\n    for (const el of node.elements){\n        const node2 = walk({\n            node: el.value,\n            scope\n        });\n        node2 !== null && of.push(node2);\n    }\n    return {\n        type: \"array\",\n        of: {\n            type: \"union\",\n            of\n        }\n    };\n}\nfunction handleValueNode(node, scope) {\n    if (node.value === null) return {\n        type: \"null\"\n    };\n    switch(typeof node.value){\n        case \"string\":\n            return {\n                type: \"string\",\n                value: node.value\n            };\n        case \"number\":\n            return {\n                type: \"number\",\n                value: node.value\n            };\n        case \"boolean\":\n            return {\n                type: \"boolean\",\n                value: node.value\n            };\n        case \"object\":\n            return node.value === null ? {\n                type: \"null\"\n            } : Array.isArray(node.value) ? {\n                type: \"array\",\n                of: {\n                    type: \"union\",\n                    of: node.value.map((value)=>walk({\n                            node: {\n                                type: \"Value\",\n                                value\n                            },\n                            scope\n                        }))\n                }\n            } : {\n                type: \"object\",\n                attributes: Object.fromEntries(Object.entries(node.value).map(([key, value])=>[\n                        key,\n                        {\n                            type: \"objectAttribute\",\n                            value: walk({\n                                node: {\n                                    type: \"Value\",\n                                    value\n                                },\n                                scope\n                            })\n                        }\n                    ]))\n            };\n        default:\n            return {\n                type: \"unknown\"\n            };\n    }\n}\nfunction handleSlice(node, scope) {\n    $trace(\"slice.node %O\", node);\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return mapArray(base, scope, (base2)=>base2);\n}\nfunction handleParentNode({ n }, scope) {\n    $trace(\"handle.parent.currentScope %d %O\", n, scope);\n    let current = scope;\n    for(let i = 0; i < n; i++){\n        for(; current?.isHidden;)current = current.parent;\n        current = current?.parent;\n    }\n    return $trace(\"handle.parent.newScope %d %O\", n, current), current ? current.value.of.length === 0 ? {\n        type: \"null\"\n    } : current.value : {\n        type: \"null\"\n    };\n}\nfunction handleNotNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return mapNode(base, scope, (base2)=>base2.type === \"unknown\" ? nullUnion({\n            type: \"boolean\"\n        }) : base2.type === \"boolean\" ? base2.value !== void 0 ? {\n            type: \"boolean\",\n            value: base2.value === !1\n        } : {\n            type: \"boolean\"\n        } : {\n            type: \"null\"\n        });\n}\nfunction handleNegNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return mapNode(base, scope, (base2)=>base2.type === \"unknown\" ? nullUnion({\n            type: \"number\"\n        }) : base2.type !== \"number\" ? {\n            type: \"null\"\n        } : base2.value !== void 0 ? {\n            type: \"number\",\n            value: -base2.value\n        } : base2);\n}\nfunction handlePosNode(node, scope) {\n    const base = walk({\n        node: node.base,\n        scope\n    });\n    return mapNode(base, scope, (base2)=>base2.type === \"unknown\" ? nullUnion({\n            type: \"number\"\n        }) : base2.type !== \"number\" ? {\n            type: \"null\"\n        } : base2);\n}\nfunction handleEverythingNode(_, scope) {\n    return {\n        type: \"array\",\n        of: {\n            type: \"union\",\n            of: scope.context.schema.filter((obj)=>obj.type === \"document\").map((doc)=>({\n                    type: \"object\",\n                    attributes: doc.attributes\n                }))\n        }\n    };\n}\nfunction handleAndNode(node, scope) {\n    const left = walk({\n        node: node.left,\n        scope\n    }), right = walk({\n        node: node.right,\n        scope\n    });\n    return mapNode(left, scope, (lhs)=>mapNode(right, scope, (rhs)=>{\n            const value = booleanAnd(booleanValue(lhs, scope), booleanValue(rhs, scope));\n            return booleanInterpretationToTypeNode(value);\n        }));\n}\nfunction handleOrNode(node, scope) {\n    const left = walk({\n        node: node.left,\n        scope\n    }), right = walk({\n        node: node.right,\n        scope\n    });\n    return mapNode(left, scope, (lhs)=>mapNode(right, scope, (rhs)=>{\n            const value = booleanOr(booleanValue(lhs, scope), booleanValue(rhs, scope));\n            return booleanInterpretationToTypeNode(value);\n        }));\n}\nconst OVERRIDE_TYPE_SYMBOL = Symbol(\"groq-js.type\");\nfunction walk({ node, scope }) {\n    if (OVERRIDE_TYPE_SYMBOL in node) return node[OVERRIDE_TYPE_SYMBOL];\n    switch(node.type){\n        // Filtering, traversal & projections\n        case \"Map\":\n            return handleMap(node, scope);\n        case \"Projection\":\n            return handleProjectionNode(node, scope);\n        case \"Filter\":\n            return handleFilterNode(node, scope);\n        case \"AccessAttribute\":\n            return optimizeUnions(handleAccessAttributeNode(node, scope));\n        case \"AccessElement\":\n            return handleAccessElementNode(node, scope);\n        case \"ArrayCoerce\":\n            return handleArrayCoerceNode(node, scope);\n        case \"FlatMap\":\n            return handleFlatMap(node, scope);\n        // Operations\n        case \"OpCall\":\n            return handleOpCallNode(node, scope);\n        case \"And\":\n            return handleAndNode(node, scope);\n        case \"Or\":\n            return handleOrNode(node, scope);\n        case \"Select\":\n            return handleSelectNode(node, scope);\n        case \"PipeFuncCall\":\n            return walk({\n                node: node.base,\n                scope\n            });\n        // Values\n        case \"Deref\":\n            return handleDerefNode(node, scope);\n        case \"Object\":\n            return handleObjectNode(node, scope);\n        case \"Value\":\n            return handleValueNode(node, scope);\n        case \"Array\":\n            return handleArrayNode(node, scope);\n        // Special cases\n        case \"Everything\":\n            return handleEverythingNode(node, scope);\n        case \"This\":\n            return $trace(\"this %O\", scope.value), scope.value;\n        case \"Parent\":\n            return handleParentNode(node, scope);\n        case \"FuncCall\":\n            return handleFuncCallNode(node, scope);\n        case \"Group\":\n            return walk({\n                node: node.base,\n                scope\n            });\n        case \"Not\":\n            return handleNotNode(node, scope);\n        case \"Parameter\":\n            return {\n                type: \"unknown\"\n            };\n        case \"Slice\":\n            return handleSlice(node, scope);\n        case \"Neg\":\n            return handleNegNode(node, scope);\n        case \"Pos\":\n            return handlePosNode(node, scope);\n        // everything else\n        case \"Asc\":\n        case \"Desc\":\n        case \"Context\":\n        case \"Tuple\":\n        case \"Selector\":\n        case \"InRange\":\n            return {\n                type: \"unknown\"\n            };\n        default:\n            throw new Error(`unknown node type ${node.type}`);\n    }\n}\nfunction isPrimitiveTypeNode(node) {\n    return node.type === \"string\" || node.type === \"number\" || node.type === \"boolean\";\n}\nfunction evaluateComparison(opcall, left, right) {\n    if (!(left.value === void 0 || right.value === void 0)) switch(opcall){\n        case \"==\":\n            return left.value === right.value;\n        case \"<\":\n            return left.value < right.value;\n        case \"<=\":\n            return left.value <= right.value;\n        case \">\":\n            return left.value > right.value;\n        case \">=\":\n            return left.value >= right.value;\n        default:\n            throw new Error(`unknown comparison operator ${opcall}`);\n    }\n}\nfunction resolveFilter(expr, scope) {\n    $trace(\"resolveFilter.expr %O\", expr);\n    const filtered = scope.value.of.filter((node)=>{\n        const subScope = scope.createHidden([\n            node\n        ]), cond = walk({\n            node: expr,\n            scope: subScope\n        });\n        return booleanValue(cond, subScope).canBeTrue;\n    });\n    return $trace(`resolveFilter ${expr.type === \"OpCall\" ? `${expr.type}/${expr.op}` : expr.type} %O`, filtered), {\n        type: \"union\",\n        of: filtered\n    };\n}\nfunction mapArray(node, scope, mapper) {\n    return mapNode(node, scope, (base)=>base.type === \"unknown\" ? base : base.type === \"array\" ? mapper(base) : {\n            type: \"null\"\n        });\n}\nfunction mapObject(node, scope, mapper) {\n    return mapNode(node, scope, (base)=>base.type === \"unknown\" ? base : base.type === \"object\" ? mapper(base) : {\n            type: \"null\"\n        });\n}\n //# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVFFLENBQ0YsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0LzEubWpzPzk4YzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYnVnIGZyb20gXCJkZWJ1Z1wiO1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xuICBjb25zdCByZSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybi5zcGxpdChcIi5cIikpXG4gICAgcGFydCA9PT0gXCIqXCIgPyByZS5wdXNoKFwiW14uXStcIikgOiBwYXJ0ID09PSBcIioqXCIgPyByZS5wdXNoKFwiLipcIikgOiByZS5wdXNoKGVzY2FwZVJlZ0V4cChwYXJ0KSk7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZS5qb2luKFwiLlwiKX0kYCk7XG59XG5jbGFzcyBQYXRoIHtcbiAgcGF0dGVybjtcbiAgcGF0dGVyblJlO1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybiwgdGhpcy5wYXR0ZXJuUmUgPSBwYXRoUmVnRXhwKHBhdHRlcm4pO1xuICB9XG4gIG1hdGNoZXMoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVyblJlLnRlc3Qoc3RyKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0dGVybjtcbiAgfVxufVxuY2xhc3MgU3RyZWFtVmFsdWUge1xuICB0eXBlID0gXCJzdHJlYW1cIjtcbiAgZ2VuZXJhdG9yO1xuICB0aWNrZXI7XG4gIGlzRG9uZTtcbiAgZGF0YTtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yKSB7XG4gICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3IsIHRoaXMudGlja2VyID0gbnVsbCwgdGhpcy5pc0RvbmUgPSAhMSwgdGhpcy5kYXRhID0gW107XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgaXNBcnJheSgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgYXN5bmMgZ2V0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcylcbiAgICAgIHJlc3VsdC5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGZvciAoOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICB5aWVsZCB0aGlzLmRhdGFbaV07XG4gICAgICBpZiAodGhpcy5pc0RvbmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGF3YWl0IHRoaXMuX25leHRUaWNrKCk7XG4gICAgfVxuICB9XG4gIF9uZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy50aWNrZXIpXG4gICAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gICAgbGV0IGN1cnJlbnRSZXNvbHZlcjtcbiAgICBjb25zdCBzZXR1cFRpY2tlciA9ICgpID0+IHtcbiAgICAgIHRoaXMudGlja2VyID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY3VycmVudFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgIH0pO1xuICAgIH0sIHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKSwgc2V0dXBUaWNrZXIoKTtcbiAgICB9LCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSlcbiAgICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpLCB0aWNrKCk7XG4gICAgICB0aGlzLmlzRG9uZSA9ICEwLCB0aWNrKCk7XG4gICAgfTtcbiAgICByZXR1cm4gc2V0dXBUaWNrZXIoKSwgZmV0Y2goKSwgdGhpcy50aWNrZXI7XG4gIH1cbn1cbmNvbnN0IFJGQzMzMzlfUkVHRVggPSAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KFxcLlxcZCspPyhafChbLStdXFxkezJ9OlxcZHsyfSkpJC87XG5mdW5jdGlvbiBwYXJzZVJGQzMzMzkoc3RyKSB7XG4gIHJldHVybiBSRkMzMzM5X1JFR0VYLnRlc3Qoc3RyKSA/IG5ldyBEYXRlKHN0cikgOiBudWxsO1xufVxuZnVuY3Rpb24gZm9ybWF0UkZDMzMzOShkKSB7XG4gIGNvbnN0IHllYXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0Z1bGxZZWFyKCksIDQpLCBtb250aCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTW9udGgoKSArIDEsIDIpLCBkYXkgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0RhdGUoKSwgMiksIGhvdXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0hvdXJzKCksIDIpLCBtaW51dGUgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01pbnV0ZXMoKSwgMiksIHNlY29uZCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbiAgbGV0IGZyYWN0aW9uYWxTZWNvbmQgPSBcIlwiO1xuICBjb25zdCBtaWxsaXMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xuICByZXR1cm4gbWlsbGlzICE9IDAgJiYgKGZyYWN0aW9uYWxTZWNvbmQgPSBgLiR7YWRkTGVhZGluZ1plcm8obWlsbGlzLCAzKX1gKSwgYCR7eWVhcn0tJHttb250aH0tJHtkYXl9VCR7aG91cn06JHttaW51dGV9OiR7c2Vjb25kfSR7ZnJhY3Rpb25hbFNlY29uZH1aYDtcbn1cbmZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvKG51bSwgdGFyZ2V0TGVuZ3RoKSB7XG4gIGxldCBzdHIgPSBudW0udG9TdHJpbmcoKTtcbiAgZm9yICg7IHN0ci5sZW5ndGggPCB0YXJnZXRMZW5ndGg7IClcbiAgICBzdHIgPSBgMCR7c3RyfWA7XG4gIHJldHVybiBzdHI7XG59XG5jbGFzcyBTdGF0aWNWYWx1ZSB7XG4gIGRhdGE7XG4gIHR5cGU7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHR5cGUpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhLCB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gXCJhcnJheVwiO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF3YWl0XG4gIGFzeW5jIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhKSlcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpXG4gICAgICAgICAgeWllbGQgZnJvbUpTKGVsZW1lbnQpO1xuICAgICAgfSh0aGlzLmRhdGEpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGl0ZXJhdGUgb3ZlcjogJHt0aGlzLnR5cGV9YCk7XG4gIH1cbn1cbmNvbnN0IE5VTExfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUobnVsbCwgXCJudWxsXCIpLCBUUlVFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKCEwLCBcImJvb2xlYW5cIiksIEZBTFNFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKCExLCBcImJvb2xlYW5cIik7XG5jbGFzcyBEYXRlVGltZSB7XG4gIGRhdGU7XG4gIGNvbnN0cnVjdG9yKGRhdGUpIHtcbiAgICB0aGlzLmRhdGUgPSBkYXRlO1xuICB9XG4gIHN0YXRpYyBwYXJzZVRvVmFsdWUoc3RyKSB7XG4gICAgY29uc3QgZGF0ZSA9IHBhcnNlUkZDMzMzOShzdHIpO1xuICAgIHJldHVybiBkYXRlID8gbmV3IFN0YXRpY1ZhbHVlKG5ldyBEYXRlVGltZShkYXRlKSwgXCJkYXRldGltZVwiKSA6IE5VTExfVkFMVUU7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgPT0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgYWRkKHNlY3MpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgcmV0dXJuIGNvcHkuc2V0VGltZShjb3B5LmdldFRpbWUoKSArIHNlY3MgKiAxZTMpLCBuZXcgRGF0ZVRpbWUoY29weSk7XG4gIH1cbiAgZGlmZmVyZW5jZShvdGhlcikge1xuICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDFlMztcbiAgfVxuICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobnVtKSA/IG5ldyBTdGF0aWNWYWx1ZShudW0sIFwibnVtYmVyXCIpIDogTlVMTF9WQUxVRTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoc3RyLCBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21EYXRlVGltZShkdCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGR0LCBcImRhdGV0aW1lXCIpO1xufVxuZnVuY3Rpb24gZnJvbVBhdGgocGF0aCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgsIFwicGF0aFwiKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3Iob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai5uZXh0ID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGZyb21KUyh2YWwpIHtcbiAgcmV0dXJuIGlzSXRlcmF0b3IodmFsKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdmFsKVxuICAgICAgeWllbGQgZnJvbUpTKHZhbHVlKTtcbiAgfSkgOiB2YWwgPT0gbnVsbCA/IE5VTExfVkFMVUUgOiBuZXcgU3RhdGljVmFsdWUodmFsLCBnZXRUeXBlKHZhbCkpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID4gXCJ1XCIgPyBcIm51bGxcIiA6IEFycmF5LmlzQXJyYXkoZGF0YSkgPyBcImFycmF5XCIgOiBkYXRhIGluc3RhbmNlb2YgUGF0aCA/IFwicGF0aFwiIDogZGF0YSBpbnN0YW5jZW9mIERhdGVUaW1lID8gXCJkYXRldGltZVwiIDogdHlwZW9mIGRhdGE7XG59XG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBiLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgYS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBiLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IGEudHlwZSA9PT0gXCJudWxsXCIgJiYgYi50eXBlID09PSBcIm51bGxcIiB8fCBhLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgYi50eXBlID09PSBcIm51bWJlclwiID8gYS5kYXRhID09PSBiLmRhdGEgOiBhLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiBiLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiA/IGEuZGF0YS5lcXVhbHMoYi5kYXRhKSA6ICExO1xufVxuY29uc3QgQ0hBUlMgPSAvKFteIUAjJCVeJiooKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZywgQ0hBUlNfV0lUSF9XSUxEQ0FSRCA9IC8oW14hQCMkJV4mKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2csIEVER0VfQ0hBUlMgPSAvKFxcYlxcLit8XFwuK1xcYikvZztcbmZ1bmN0aW9uIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSB7XG4gIHJldHVybiB0b2tlbnMubGVuZ3RoID09PSAwIHx8IHBhdHRlcm5zLmxlbmd0aCA9PT0gMCA/ICExIDogcGF0dGVybnMuZXZlcnkoKHBhdHRlcm4pID0+IHBhdHRlcm4odG9rZW5zKSk7XG59XG5mdW5jdGlvbiBtYXRjaFRva2VuaXplKHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSUykgfHwgW107XG59XG5mdW5jdGlvbiBtYXRjaEFuYWx5emVQYXR0ZXJuKHRleHQpIHtcbiAgcmV0dXJuIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpLm1hcCgocmUpID0+ICh0b2tlbnMpID0+IHRva2Vucy5zb21lKCh0b2tlbikgPT4gcmUudGVzdCh0b2tlbikpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpIHtcbiAgcmV0dXJuICh0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW10pLm1hcChcbiAgICAodGVybSkgPT4gbmV3IFJlZ0V4cChgXiR7dGVybS5zbGljZSgwLCAxMDI0KS5yZXBsYWNlKC9cXCovZywgXCIuKlwiKX0kYCwgXCJpXCIpXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBnYXRoZXJUZXh0KHZhbHVlLCBjYikge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gY2IodmFsdWUuZGF0YSksICEwO1xuICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSAhMDtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdmFsdWUpXG4gICAgICBwYXJ0LnR5cGUgPT09IFwic3RyaW5nXCIgPyBjYihwYXJ0LmRhdGEpIDogc3VjY2VzcyA9ICExO1xuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmNvbnN0IFRZUEVfT1JERVIgPSB7XG4gIGRhdGV0aW1lOiAxLFxuICBudW1iZXI6IDIsXG4gIHN0cmluZzogMyxcbiAgYm9vbGVhbjogNFxufTtcbmZ1bmN0aW9uIHBhcnRpYWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpLCBiVHlwZSA9IGdldFR5cGUoYik7XG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpXG4gICAgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAoYVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICByZXR1cm4gYS5jb21wYXJlVG8oYik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiB0b3RhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSksIGJUeXBlID0gZ2V0VHlwZShiKSwgYVR5cGVPcmRlciA9IFRZUEVfT1JERVJbYVR5cGVdIHx8IDEwMCwgYlR5cGVPcmRlciA9IFRZUEVfT1JERVJbYlR5cGVdIHx8IDEwMDtcbiAgaWYgKGFUeXBlT3JkZXIgIT09IGJUeXBlT3JkZXIpXG4gICAgcmV0dXJuIGFUeXBlT3JkZXIgLSBiVHlwZU9yZGVyO1xuICBsZXQgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUoYSwgYik7XG4gIHJldHVybiByZXN1bHQgPT09IG51bGwgJiYgKHJlc3VsdCA9IDApLCByZXN1bHQ7XG59XG5jb25zdCBvcGVyYXRvcnMgPSB7XG4gIFwiPT1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiIT1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIFwiPlwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA+IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPj1cIjogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiByZXN1bHQgPj0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8XCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyBOVUxMX1ZBTFVFIDogcmVzdWx0IDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8PVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBudWxsID8gTlVMTF9WQUxVRSA6IHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gIGluOiBhc3luYyBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodC50eXBlID09PSBcInBhdGhcIilcbiAgICAgIHJldHVybiBsZWZ0LnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgaWYgKHJpZ2h0LmlzQXJyYXkoKSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBiIG9mIHJpZ2h0KVxuICAgICAgICBpZiAoaXNFcXVhbChsZWZ0LCBiKSlcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIG1hdGNoOiBhc3luYyBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGxldCB0b2tlbnMgPSBbXSwgcGF0dGVybnMgPSBbXTtcbiAgICByZXR1cm4gYXdhaXQgZ2F0aGVyVGV4dChsZWZ0LCAocGFydCkgPT4ge1xuICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgICB9KSwgYXdhaXQgZ2F0aGVyVGV4dChyaWdodCwgKHBhcnQpID0+IHtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpO1xuICAgIH0pICYmIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCIrXCI6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZChyaWdodC5kYXRhKSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IGZyb21OdW1iZXIobGVmdC5kYXRhICsgcmlnaHQuZGF0YSkgOiBsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGZyb21TdHJpbmcobGVmdC5kYXRhICsgcmlnaHQuZGF0YSkgOiBsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIiA/IGZyb21KUyh7IC4uLmxlZnQuZGF0YSwgLi4ucmlnaHQuZGF0YSB9KSA6IGxlZnQudHlwZSA9PT0gXCJhcnJheVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiYXJyYXlcIiA/IGZyb21KUyhsZWZ0LmRhdGEuY29uY2F0KHJpZ2h0LmRhdGEpKSA6IGxlZnQuaXNBcnJheSgpICYmIHJpZ2h0LmlzQXJyYXkoKSA/IG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgbGVmdClcbiAgICAgICAgeWllbGQgdmFsO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgcmlnaHQpXG4gICAgICAgIHlpZWxkIHZhbDtcbiAgICB9KSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIFwiLVwiOiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQoLXJpZ2h0LmRhdGEpKSA6IGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiA/IGZyb21OdW1iZXIobGVmdC5kYXRhLmRpZmZlcmVuY2UocmlnaHQuZGF0YSkpIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyBmcm9tTnVtYmVyKGxlZnQuZGF0YSAtIHJpZ2h0LmRhdGEpIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCIqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAqIGIpLFxuICBcIi9cIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhIC8gYiksXG4gIFwiJVwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgJSBiKSxcbiAgXCIqKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IE1hdGgucG93KGEsIGIpKVxufTtcbmZ1bmN0aW9uIG51bWVyaWNPcGVyYXRvcihpbXBsKSB7XG4gIHJldHVybiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH07XG59XG5sZXQgU2NvcGUkMSA9IGNsYXNzIFNjb3BlIHtcbiAgcGFyYW1zO1xuICBzb3VyY2U7XG4gIHZhbHVlO1xuICBwYXJlbnQ7XG4gIGNvbnRleHQ7XG4gIGlzSGlkZGVuID0gITE7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgc291cmNlLCB2YWx1ZSwgY29udGV4dCwgcGFyZW50KSB7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXMsIHRoaXMuc291cmNlID0gc291cmNlLCB0aGlzLnZhbHVlID0gdmFsdWUsIHRoaXMuY29udGV4dCA9IGNvbnRleHQsIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG4gIGNyZWF0ZU5lc3RlZCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmlzSGlkZGVuID8gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpIDogbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcyk7XG4gIH1cbiAgY3JlYXRlSGlkZGVuKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuaXNIaWRkZW4gPSAhMCwgcmVzdWx0O1xuICB9XG59O1xuZnVuY3Rpb24gZXZhbHVhdGUobm9kZSwgc2NvcGUsIGV4ZWN1dGUgPSBldmFsdWF0ZSkge1xuICBjb25zdCBmdW5jID0gRVhFQ1VUT1JTW25vZGUudHlwZV07XG4gIHJldHVybiBmdW5jKG5vZGUsIHNjb3BlLCBleGVjdXRlKTtcbn1cbmZ1bmN0aW9uIHByb21pc2VsZXNzQXBwbHkodmFsdWUsIGNiKSB7XG4gIHJldHVybiBcInRoZW5cIiBpbiB2YWx1ZSA/IHZhbHVlLnRoZW4oY2IpIDogY2IodmFsdWUpO1xufVxuY29uc3QgRVhFQ1VUT1JTID0ge1xuICBUaGlzKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnZhbHVlO1xuICB9LFxuICBTZWxlY3RvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3RvcnMgY2FuIG5vdCBiZSBldmFsdWF0ZWRcIik7XG4gIH0sXG4gIEV2ZXJ5dGhpbmcoXywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGUuc291cmNlO1xuICB9LFxuICBQYXJhbWV0ZXIoeyBuYW1lIH0sIHNjb3BlKSB7XG4gICAgcmV0dXJuIGZyb21KUyhzY29wZS5wYXJhbXNbbmFtZV0pO1xuICB9LFxuICBDb250ZXh0KHsga2V5IH0sIHNjb3BlKSB7XG4gICAgaWYgKGtleSA9PT0gXCJiZWZvcmVcIiB8fCBrZXkgPT09IFwiYWZ0ZXJcIilcbiAgICAgIHJldHVybiBzY29wZS5jb250ZXh0W2tleV0gfHwgTlVMTF9WQUxVRTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY29udGV4dCBrZXk6ICR7a2V5fWApO1xuICB9LFxuICBQYXJlbnQoeyBuIH0sIHNjb3BlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBzY29wZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKCFjdXJyZW50LnBhcmVudClcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICB9LFxuICBPcENhbGwoeyBvcCwgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3I6ICR7b3B9YCk7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gZXhlY3V0ZShsZWZ0LCBzY29wZSksIHJpZ2h0VmFsdWUgPSBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgcmV0dXJuIFwidGhlblwiIGluIGxlZnRWYWx1ZSB8fCBcInRoZW5cIiBpbiByaWdodFZhbHVlID8gKGFzeW5jICgpID0+IGZ1bmMoYXdhaXQgbGVmdFZhbHVlLCBhd2FpdCByaWdodFZhbHVlKSkoKSA6IGZ1bmMobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgfSxcbiAgYXN5bmMgU2VsZWN0KHsgYWx0ZXJuYXRpdmVzLCBmYWxsYmFjayB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGZvciAoY29uc3QgYWx0IG9mIGFsdGVybmF0aXZlcykge1xuICAgICAgY29uc3QgYWx0Q29uZCA9IGF3YWl0IGV4ZWN1dGUoYWx0LmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgaWYgKGFsdENvbmQudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYWx0Q29uZC5kYXRhID09PSAhMClcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjayA/IGV4ZWN1dGUoZmFsbGJhY2ssIHNjb3BlKSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEluUmFuZ2UoeyBiYXNlLCBsZWZ0LCByaWdodCwgaXNJbmNsdXNpdmUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKSwgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKSwgbGVmdENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCBsZWZ0VmFsdWUuZ2V0KCkpO1xuICAgIGlmIChsZWZ0Q21wID09PSBudWxsKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmlnaHRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgcmlnaHRWYWx1ZS5nZXQoKSk7XG4gICAgcmV0dXJuIHJpZ2h0Q21wID09PSBudWxsID8gTlVMTF9WQUxVRSA6IGlzSW5jbHVzaXZlID8gbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUUgOiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBGaWx0ZXIoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIGJhc2VWYWx1ZS5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBiYXNlVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoZWxlbSksIGV4cHJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBleHByVmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgZXhwclZhbHVlLmRhdGEgPT09ICEwICYmICh5aWVsZCBlbGVtKTtcbiAgICAgIH1cbiAgICB9KSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIFByb2plY3Rpb24oeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKGJhc2VWYWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoYmFzZVZhbHVlKTtcbiAgICByZXR1cm4gZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gIH0sXG4gIEZ1bmNDYWxsKHsgZnVuYywgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgUGlwZUZ1bmNDYWxsKHsgZnVuYywgYmFzZSwgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiBmdW5jKGJhc2VWYWx1ZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xuICB9LFxuICBhc3luYyBBY2Nlc3NBdHRyaWJ1dGUoeyBiYXNlLCBuYW1lIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHZhbHVlID0gc2NvcGUudmFsdWU7XG4gICAgcmV0dXJuIGJhc2UgJiYgKHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSkpLCB2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLmRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkgPyBmcm9tSlModmFsdWUuZGF0YVtuYW1lXSkgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBY2Nlc3NFbGVtZW50KHsgYmFzZSwgaW5kZXggfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgYmFzZVZhbHVlLmdldCgpLCBmaW5hbEluZGV4ID0gaW5kZXggPCAwID8gaW5kZXggKyBkYXRhLmxlbmd0aCA6IGluZGV4O1xuICAgIHJldHVybiBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSk7XG4gIH0sXG4gIGFzeW5jIFNsaWNlKHsgYmFzZSwgbGVmdCwgcmlnaHQsIGlzSW5jbHVzaXZlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgYXJyYXkyID0gYXdhaXQgYmFzZVZhbHVlLmdldCgpO1xuICAgIGxldCBsZWZ0SWR4ID0gbGVmdCwgcmlnaHRJZHggPSByaWdodDtcbiAgICByZXR1cm4gbGVmdElkeCA8IDAgJiYgKGxlZnRJZHggPSBhcnJheTIubGVuZ3RoICsgbGVmdElkeCksIHJpZ2h0SWR4IDwgMCAmJiAocmlnaHRJZHggPSBhcnJheTIubGVuZ3RoICsgcmlnaHRJZHgpLCBpc0luY2x1c2l2ZSAmJiByaWdodElkeCsrLCBsZWZ0SWR4IDwgMCAmJiAobGVmdElkeCA9IDApLCByaWdodElkeCA8IDAgJiYgKHJpZ2h0SWR4ID0gMCksIGZyb21KUyhhcnJheTIuc2xpY2UobGVmdElkeCwgcmlnaHRJZHgpKTtcbiAgfSxcbiAgYXN5bmMgRGVyZWYoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXNjb3BlLnNvdXJjZS5pc0FycmF5KCkgfHwgdmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IGlkID0gdmFsdWUuZGF0YS5fcmVmO1xuICAgIGlmICh0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGlmIChzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKVxuICAgICAgcmV0dXJuIGZyb21KUyhhd2FpdCBzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKHsgX3JlZjogaWQgfSkpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIHNjb3BlLnNvdXJjZSlcbiAgICAgIGlmIChkb2MudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBpZCA9PT0gZG9jLmRhdGEuX2lkKVxuICAgICAgICByZXR1cm4gZG9jO1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBWYWx1ZSh7IHZhbHVlIH0pIHtcbiAgICByZXR1cm4gZnJvbUpTKHZhbHVlKTtcbiAgfSxcbiAgR3JvdXAoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICB9LFxuICBhc3luYyBPYmplY3QoeyBhdHRyaWJ1dGVzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJUeXBlID0gYXR0ci50eXBlO1xuICAgICAgc3dpdGNoIChhdHRyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCI6IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIHJlc3VsdFthdHRyLm5hbWVdID0gYXdhaXQgdmFsdWUuZ2V0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIjoge1xuICAgICAgICAgIGNvbnN0IGNvbmQgPSBhd2FpdCBleGVjdXRlKGF0dHIuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgICAgaWYgKGNvbmQudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgY29uZC5kYXRhID09PSAhMSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgdmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdFNwbGF0XCI6IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHthdHRyVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyb21KUyhyZXN1bHQpO1xuICB9LFxuICBBcnJheSh7IGVsZW1lbnRzIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShlbGVtZW50LnZhbHVlLCBzY29wZSk7XG4gICAgICAgIGlmIChlbGVtZW50LmlzU3BsYXQpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaXNBcnJheSgpKVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgICAgICAgICB5aWVsZCB2O1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgVHVwbGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBhc3luYyBPcih7IGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSksIHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgcmV0dXJuIGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBsZWZ0VmFsdWUuZGF0YSA9PT0gITAgfHwgcmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIiAmJiByaWdodFZhbHVlLmRhdGEgPT09ICEwID8gVFJVRV9WQUxVRSA6IGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiID8gTlVMTF9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBbmQoeyBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpLCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIHJldHVybiBsZWZ0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgbGVmdFZhbHVlLmRhdGEgPT09ICExIHx8IHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmlnaHRWYWx1ZS5kYXRhID09PSAhMSA/IEZBTFNFX1ZBTFVFIDogbGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgPyBOVUxMX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgTm90KHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgcmV0dXJuIHZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiID8gTlVMTF9WQUxVRSA6IHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIE5lZyh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICByZXR1cm4gcHJvbWlzZWxlc3NBcHBseShleGVjdXRlKGJhc2UsIHNjb3BlKSwgKHZhbHVlKSA9PiB2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiID8gTlVMTF9WQUxVRSA6IGZyb21OdW1iZXIoLXZhbHVlLmRhdGEpKTtcbiAgfSxcbiAgUG9zKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCAodmFsdWUpID0+IHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgPyBOVUxMX1ZBTFVFIDogZnJvbU51bWJlcih2YWx1ZS5kYXRhKSk7XG4gIH0sXG4gIEFzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgRGVzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQXJyYXlDb2VyY2UoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gdmFsdWUgOiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBNYXAoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XG4gICAgICAgIHlpZWxkIGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgfVxuICAgIH0pIDogTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgRmxhdE1hcCh7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihlbGVtKSwgaW5uZXJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBpZiAoaW5uZXJWYWx1ZS5pc0FycmF5KCkpXG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpbm5lciBvZiBpbm5lclZhbHVlKVxuICAgICAgICAgICAgeWllbGQgaW5uZXI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB5aWVsZCBpbm5lclZhbHVlO1xuICAgICAgfVxuICAgIH0pIDogTlVMTF9WQUxVRTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KSwgZGF0YXNldCA9IGZyb21KUyhvcHRpb25zLmRhdGFzZXQpLCBwYXJhbXMgPSB7IC4uLm9wdGlvbnMucGFyYW1zIH0sIHNjb3BlID0gbmV3IFNjb3BlJDEoXG4gICAgcGFyYW1zLFxuICAgIGRhdGFzZXQsXG4gICAgcm9vdCxcbiAgICB7XG4gICAgICB0aW1lc3RhbXA6IG9wdGlvbnMudGltZXN0YW1wIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHZvaWQgMCA/IFwibWVcIiA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgICBzYW5pdHk6IG9wdGlvbnMuc2FuaXR5LFxuICAgICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxuICAgICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsLFxuICAgICAgZGVyZWZlcmVuY2U6IG9wdGlvbnMuZGVyZWZlcmVuY2VcbiAgICB9LFxuICAgIG51bGxcbiAgKTtcbiAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiVmFsdWVcIjpcbiAgICBjYXNlIFwiUGFyYW1ldGVyXCI6XG4gICAgICByZXR1cm4gITA7XG4gICAgY2FzZSBcIlBvc1wiOlxuICAgIGNhc2UgXCJOZWdcIjpcbiAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUuYmFzZSk7XG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxuICAgICAgc3dpdGNoIChub2RlLm9wKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICAgIHJldHVybiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUubGVmdCkgJiYgY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlLnJpZ2h0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAhMTtcbiAgfVxufVxuY29uc3QgRFVNTVlfU0NPUEUgPSBuZXcgU2NvcGUkMShcbiAge30sXG4gIE5VTExfVkFMVUUsXG4gIE5VTExfVkFMVUUsXG4gIHsgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCksIGlkZW50aXR5OiBcIm1lXCIsIGJlZm9yZTogbnVsbCwgYWZ0ZXI6IG51bGwgfSxcbiAgbnVsbFxuKTtcbmZ1bmN0aW9uIHRyeUNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICByZXR1cm4gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSA/IGNvbnN0YW50RXZhbHVhdGUobm9kZSkgOiBudWxsO1xufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIGNvbnN0IHZhbHVlID0gZXZhbHVhdGUobm9kZSwgRFVNTVlfU0NPUEUsIGNvbnN0YW50RXZhbHVhdGUpO1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBjb25zdGFudCBldmFsdWF0ZSBzaG91bGQgbmV2ZXIgcmV0dXJuIGEgcHJvbWlzZVwiKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gYmxvY2tUZXh0KHZhbHVlLmRhdGEpO1xuICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgY29uc3QgdGV4dHMgPSBhd2FpdCBhcnJheVRleHQodmFsdWUpO1xuICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIHRleHRzLmpvaW4oYFxuXG5gKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSwgcmVzdWx0ID0gW10pIHtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiB2YWx1ZSlcbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdGV4dCA9IGJsb2NrVGV4dChibG9jay5kYXRhKTtcbiAgICAgIHRleHQgIT09IG51bGwgJiYgcmVzdWx0LnB1c2godGV4dCk7XG4gICAgfSBlbHNlIGJsb2NrLmlzQXJyYXkoKSAmJiBhd2FpdCBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBibG9ja1RleHQob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9IFwic3RyaW5nXCIpIHJldHVybiBudWxsO1xuICBjb25zdCBjaGlsZHJlbiA9IG9iai5jaGlsZHJlbjtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgcmV0dXJuIG51bGw7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgIGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjaGlsZC5fdHlwZSA9PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PSBcInN0cmluZ1wiICYmIChyZXN1bHQgKz0gY2hpbGQudGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTTI1ayA9IDEuMjtcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpXG4gICAgcmV0dXJuIGV2YWx1YXRlTWF0Y2hTY29yZShub2RlLmxlZnQsIG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIG5vZGUubmFtZSA9PT0gXCJib29zdFwiKSB7XG4gICAgY29uc3QgaW5uZXJTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5hcmdzWzBdLCBzY29wZSwgZXhlY3V0ZSksIGJvb3N0ID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICByZXR1cm4gYm9vc3QudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCA/IGlubmVyU2NvcmUgKyBib29zdC5kYXRhIDogMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgY2FzZSBcIkFuZFwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpLCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDAgPyAwIDogbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZXhlY3V0ZShub2RlLCBzY29wZSk7XG4gICAgICByZXR1cm4gcmVzLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlcy5kYXRhID09PSAhMCA/IDEgOiAwO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVNYXRjaFNjb3JlKGxlZnQsIHJpZ2h0LCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSksIHBhdHRlcm4gPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gIGxldCB0b2tlbnMgPSBbXSwgdGVybXMgPSBbXTtcbiAgaWYgKGF3YWl0IGdhdGhlclRleHQodGV4dCwgKHBhcnQpID0+IHtcbiAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICB9KSwgIWF3YWl0IGdhdGhlclRleHQocGF0dGVybiwgKHBhcnQpID0+IHtcbiAgICB0ZXJtcyA9IHRlcm1zLmNvbmNhdChtYXRjaFBhdHRlcm5SZWdleChwYXJ0KSk7XG4gIH0pIHx8IHRva2Vucy5sZW5ndGggPT09IDAgfHwgdGVybXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAwO1xuICBsZXQgc2NvcmUgPSAwO1xuICBmb3IgKGNvbnN0IHJlIG9mIHRlcm1zKSB7XG4gICAgY29uc3QgZnJlcSA9IHRva2Vucy5yZWR1Y2UoKGMsIHRva2VuKSA9PiBjICsgKHJlLnRlc3QodG9rZW4pID8gMSA6IDApLCAwKTtcbiAgICBzY29yZSArPSBmcmVxICogKEJNMjVrICsgMSkgLyAoZnJlcSArIEJNMjVrKTtcbiAgfVxuICByZXR1cm4gc2NvcmU7XG59XG5mdW5jdGlvbiBoYXNSZWZlcmVuY2UodmFsdWUsIHBhdGhTZXQpIHtcbiAgc3dpdGNoIChnZXRUeXBlKHZhbHVlKSkge1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmICh2YWx1ZS5fcmVmKVxuICAgICAgICByZXR1cm4gcGF0aFNldC5oYXModmFsdWUuX3JlZik7XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpXG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gY291bnRVVEY4KHN0cikge1xuICBsZXQgY291bnQyID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgY29kZSA+PSA1NTI5NiAmJiBjb2RlIDw9IDU2MzE5IHx8IGNvdW50MisrO1xuICB9XG4gIHJldHVybiBjb3VudDI7XG59XG5jb25zdCBfZ2xvYmFsID0ge307XG5fZ2xvYmFsLmFueXdoZXJlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5fZ2xvYmFsLmFueXdoZXJlLmFyaXR5ID0gMTtcbl9nbG9iYWwuY29hbGVzY2UgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZywgc2NvcGUpO1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bGxcIilcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5fZ2xvYmFsLmNvdW50ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFpbm5lci5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGxldCBudW0gPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgaW5uZXIpXG4gICAgbnVtKys7XG4gIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG59O1xuX2dsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5fZ2xvYmFsLmRhdGVUaW1lID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiB2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiID8gdmFsIDogdmFsLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKTtcbn07XG5fZ2xvYmFsLmRhdGVUaW1lLmFyaXR5ID0gMTtcbl9nbG9iYWwuZGVmaW5lZCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIHJldHVybiAoYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSkpLnR5cGUgPT09IFwibnVsbFwiID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xufTtcbl9nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG5fZ2xvYmFsLmlkZW50aXR5ID0gYXN5bmMgZnVuY3Rpb24oX2FyZ3MsIHNjb3BlKSB7XG4gIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuaWRlbnRpdHkpO1xufTtcbl9nbG9iYWwuaWRlbnRpdHkuYXJpdHkgPSAwO1xuX2dsb2JhbC5sZW5ndGggPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZnJvbU51bWJlcihjb3VudFVURjgoaW5uZXIuZGF0YSkpO1xuICBpZiAoaW5uZXIuaXNBcnJheSgpKSB7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgZm9yIGF3YWl0IChjb25zdCBfIG9mIGlubmVyKVxuICAgICAgbnVtKys7XG4gICAgcmV0dXJuIGZyb21OdW1iZXIobnVtKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5fZ2xvYmFsLmxlbmd0aC5hcml0eSA9IDE7XG5fZ2xvYmFsLnBhdGggPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gaW5uZXIudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBmcm9tUGF0aChuZXcgUGF0aChpbm5lci5kYXRhKSk7XG59O1xuX2dsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbl9nbG9iYWwuc3RyaW5nID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoYCR7dmFsdWUuZGF0YX1gKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbn07XG5fZ2xvYmFsLnN0cmluZy5hcml0eSA9IDE7XG5fZ2xvYmFsLnJlZmVyZW5jZXMgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBwYXRoU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHBhdGgyID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAocGF0aDIudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHBhdGhTZXQuYWRkKHBhdGgyLmRhdGEpO1xuICAgIGVsc2UgaWYgKHBhdGgyLmlzQXJyYXkoKSlcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBwYXRoMilcbiAgICAgICAgZWxlbS50eXBlID09PSBcInN0cmluZ1wiICYmIHBhdGhTZXQuYWRkKGVsZW0uZGF0YSk7XG4gIH1cbiAgaWYgKHBhdGhTZXQuc2l6ZSA9PT0gMClcbiAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIGNvbnN0IHNjb3BlVmFsdWUgPSBhd2FpdCBzY29wZS52YWx1ZS5nZXQoKTtcbiAgcmV0dXJuIGhhc1JlZmVyZW5jZShzY29wZVZhbHVlLCBwYXRoU2V0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbn07XG5fZ2xvYmFsLnJlZmVyZW5jZXMuYXJpdHkgPSAoYykgPT4gYyA+PSAxO1xuX2dsb2JhbC5yb3VuZCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBudW0gPSB2YWx1ZS5kYXRhO1xuICBsZXQgcHJlYyA9IDA7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHByZWNWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCBwcmVjVmFsdWUuZGF0YSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocHJlY1ZhbHVlLmRhdGEpKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgcHJlYyA9IHByZWNWYWx1ZS5kYXRhO1xuICB9XG4gIHJldHVybiBwcmVjID09PSAwID8gbnVtIDwgMCA/IGZyb21OdW1iZXIoLU1hdGgucm91bmQoLW51bSkpIDogZnJvbU51bWJlcihNYXRoLnJvdW5kKG51bSkpIDogZnJvbU51bWJlcihOdW1iZXIobnVtLnRvRml4ZWQocHJlYykpKTtcbn07XG5fZ2xvYmFsLnJvdW5kLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDEgJiYgY291bnQyIDw9IDI7XG5fZ2xvYmFsLm5vdyA9IGFzeW5jIGZ1bmN0aW9uKF9hcmdzLCBzY29wZSkge1xuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnRpbWVzdGFtcC50b0lTT1N0cmluZygpKTtcbn07XG5fZ2xvYmFsLm5vdy5hcml0eSA9IDA7XG5fZ2xvYmFsLmJvb3N0ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3QgY2FsbFwiKTtcbn07XG5fZ2xvYmFsLmJvb3N0LmFyaXR5ID0gMjtcbmNvbnN0IHN0cmluZzIgPSB7fTtcbnN0cmluZzIubG93ZXIgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gdmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIiA/IE5VTExfVkFMVUUgOiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9Mb3dlckNhc2UoKSk7XG59O1xuc3RyaW5nMi5sb3dlci5hcml0eSA9IDE7XG5zdHJpbmcyLnVwcGVyID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvVXBwZXJDYXNlKCkpO1xufTtcbnN0cmluZzIudXBwZXIuYXJpdHkgPSAxO1xuc3RyaW5nMi5zcGxpdCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHN0ciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoc3RyLnR5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHNlcCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICByZXR1cm4gc2VwLnR5cGUgIT09IFwic3RyaW5nXCIgPyBOVUxMX1ZBTFVFIDogc3RyLmRhdGEubGVuZ3RoID09PSAwID8gZnJvbUpTKFtdKSA6IHNlcC5kYXRhLmxlbmd0aCA9PT0gMCA/IGZyb21KUyhBcnJheS5mcm9tKHN0ci5kYXRhKSkgOiBmcm9tSlMoc3RyLmRhdGEuc3BsaXQoc2VwLmRhdGEpKTtcbn07XG5zdHJpbmcyLnNwbGl0LmFyaXR5ID0gMjtcbl9nbG9iYWwubG93ZXIgPSBzdHJpbmcyLmxvd2VyO1xuX2dsb2JhbC51cHBlciA9IHN0cmluZzIudXBwZXI7XG5zdHJpbmcyLnN0YXJ0c1dpdGggPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCBwcmVmaXggPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgcmV0dXJuIHByZWZpeC50eXBlICE9PSBcInN0cmluZ1wiID8gTlVMTF9WQUxVRSA6IHN0ci5kYXRhLnN0YXJ0c1dpdGgocHJlZml4LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xufTtcbnN0cmluZzIuc3RhcnRzV2l0aC5hcml0eSA9IDI7XG5jb25zdCBhcnJheSA9IHt9O1xuYXJyYXkuam9pbiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHNlcCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICBpZiAoc2VwLnR5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGxldCBidWYgPSBcIlwiLCBuZWVkU2VwID0gITE7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICBzd2l0Y2ggKG5lZWRTZXAgJiYgKGJ1ZiArPSBzZXAuZGF0YSksIGVsZW0udHlwZSkge1xuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICBidWYgKz0gYCR7ZWxlbS5kYXRhfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIG5lZWRTZXAgPSAhMDtcbiAgfVxuICByZXR1cm4gZnJvbUpTKGJ1Zik7XG59O1xuYXJyYXkuam9pbi5hcml0eSA9IDI7XG5hcnJheS5jb21wYWN0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiBhcnIuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycilcbiAgICAgIGVsZW0udHlwZSAhPT0gXCJudWxsXCIgJiYgKHlpZWxkIGVsZW0pO1xuICB9KSA6IE5VTExfVkFMVUU7XG59O1xuYXJyYXkuY29tcGFjdC5hcml0eSA9IDE7XG5hcnJheS51bmlxdWUgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWRkZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlciBvZiB2YWx1ZSlcbiAgICAgIHN3aXRjaCAoaXRlci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgICBhZGRlZC5oYXMoaXRlci5kYXRhKSB8fCAoYWRkZWQuYWRkKGl0ZXIuZGF0YSksIHlpZWxkIGl0ZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHlpZWxkIGl0ZXI7XG4gICAgICB9XG4gIH0pIDogTlVMTF9WQUxVRTtcbn07XG5hcnJheS51bmlxdWUuYXJpdHkgPSAxO1xuYXJyYXkuaW50ZXJzZWN0cyA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFycjEgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFhcnIxLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3QgYXJyMiA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICBpZiAoIWFycjIuaXNBcnJheSgpKVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICBmb3IgYXdhaXQgKGNvbnN0IHYxIG9mIGFycjEpXG4gICAgZm9yIGF3YWl0IChjb25zdCB2MiBvZiBhcnIyKVxuICAgICAgaWYgKGlzRXF1YWwodjEsIHYyKSlcbiAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gIHJldHVybiBGQUxTRV9WQUxVRTtcbn07XG5hcnJheS5pbnRlcnNlY3RzLmFyaXR5ID0gMjtcbmNvbnN0IHB0ID0ge307XG5wdC50ZXh0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKSwgdGV4dCA9IGF3YWl0IHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpO1xuICByZXR1cm4gdGV4dCA9PT0gbnVsbCA/IE5VTExfVkFMVUUgOiBmcm9tU3RyaW5nKHRleHQpO1xufTtcbnB0LnRleHQuYXJpdHkgPSAxO1xuY29uc3Qgc2FuaXR5ID0ge307XG5zYW5pdHkucHJvamVjdElkID0gYXN5bmMgZnVuY3Rpb24oX2FyZ3MsIHNjb3BlKSB7XG4gIHJldHVybiBzY29wZS5jb250ZXh0LnNhbml0eSA/IGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKSA6IE5VTExfVkFMVUU7XG59O1xuc2FuaXR5LmRhdGFzZXQgPSBhc3luYyBmdW5jdGlvbihfYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIHNjb3BlLmNvbnRleHQuc2FuaXR5ID8gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5kYXRhc2V0KSA6IE5VTExfVkFMVUU7XG59O1xuc2FuaXR5LnZlcnNpb25PZiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmICghc2NvcGUuc291cmNlLmlzQXJyYXkoKSkgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3QgYmFzZUlkID0gdmFsdWUuZGF0YSwgdmVyc2lvbklkcyA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlMiBvZiBzY29wZS5zb3VyY2UpXG4gICAgaWYgKGdldFR5cGUodmFsdWUyKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdmFsID0gYXdhaXQgdmFsdWUyLmdldCgpO1xuICAgICAgdmFsICYmIFwiX2lkXCIgaW4gdmFsICYmIHZhbC5faWQuc3BsaXQoXCIuXCIpLmxlbmd0aCA9PT0gMiAmJiB2YWwuX2lkLmVuZHNXaXRoKGAuJHtiYXNlSWR9YCkgJiYgXCJfdmVyc2lvblwiIGluIHZhbCAmJiB0eXBlb2YgdmFsLl92ZXJzaW9uID09IFwib2JqZWN0XCIgJiYgdmVyc2lvbklkcy5wdXNoKHZhbC5faWQpO1xuICAgIH1cbiAgcmV0dXJuIGZyb21KUyh2ZXJzaW9uSWRzKTtcbn07XG5zYW5pdHkudmVyc2lvbk9mLmFyaXR5ID0gMTtcbnNhbml0eS5kb2N1bWVudHNPZiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmICghc2NvcGUuc291cmNlLmlzQXJyYXkoKSkgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gTlVMTF9WQUxVRTtcbiAgY29uc3QgYmFzZUlkID0gdmFsdWUuZGF0YSwgZG9jdW1lbnRJZHNJbkJ1bmRsZSA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlMiBvZiBzY29wZS5zb3VyY2UpXG4gICAgaWYgKGdldFR5cGUodmFsdWUyKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdmFsID0gYXdhaXQgdmFsdWUyLmdldCgpO1xuICAgICAgdmFsICYmIFwiX2lkXCIgaW4gdmFsICYmIHZhbC5faWQuc3BsaXQoXCIuXCIpLmxlbmd0aCA9PT0gMiAmJiB2YWwuX2lkLnN0YXJ0c1dpdGgoYCR7YmFzZUlkfS5gKSAmJiBcIl92ZXJzaW9uXCIgaW4gdmFsICYmIHR5cGVvZiB2YWwuX3ZlcnNpb24gPT0gXCJvYmplY3RcIiAmJiBkb2N1bWVudElkc0luQnVuZGxlLnB1c2godmFsLl9pZCk7XG4gICAgfVxuICByZXR1cm4gZnJvbUpTKGRvY3VtZW50SWRzSW5CdW5kbGUpO1xufTtcbnNhbml0eS5kb2N1bWVudHNPZi5hcml0eSA9IDE7XG5jb25zdCBwaXBlRnVuY3Rpb25zID0ge307XG5waXBlRnVuY3Rpb25zLm9yZGVyID0gYXN5bmMgZnVuY3Rpb24oYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKGF3YWl0ICEwLCAhYmFzZS5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IG1hcHBlcnMgPSBbXSwgZGlyZWN0aW9ucyA9IFtdO1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IG1hcHBlciBvZiBhcmdzKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IFwiYXNjXCI7XG4gICAgbWFwcGVyLnR5cGUgPT09IFwiRGVzY1wiID8gKGRpcmVjdGlvbiA9IFwiZGVzY1wiLCBtYXBwZXIgPSBtYXBwZXIuYmFzZSkgOiBtYXBwZXIudHlwZSA9PT0gXCJBc2NcIiAmJiAobWFwcGVyID0gbWFwcGVyLmJhc2UpLCBtYXBwZXJzLnB1c2gobWFwcGVyKSwgZGlyZWN0aW9ucy5wdXNoKGRpcmVjdGlvbiksIG4rKztcbiAgfVxuICBjb25zdCBhdXggPSBbXTtcbiAgbGV0IGlkeCA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKSwgdHVwbGUgPSBbYXdhaXQgdmFsdWUuZ2V0KCksIGlkeF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGUobWFwcGVyc1tpXSwgbmV3U2NvcGUpO1xuICAgICAgdHVwbGUucHVzaChhd2FpdCByZXN1bHQuZ2V0KCkpO1xuICAgIH1cbiAgICBhdXgucHVzaCh0dXBsZSksIGlkeCsrO1xuICB9XG4gIHJldHVybiBhdXguc29ydCgoYVR1cGxlLCBiVHVwbGUpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgbGV0IGMgPSB0b3RhbENvbXBhcmUoYVR1cGxlW2kgKyAyXSwgYlR1cGxlW2kgKyAyXSk7XG4gICAgICBpZiAoZGlyZWN0aW9uc1tpXSA9PT0gXCJkZXNjXCIgJiYgKGMgPSAtYyksIGMgIT09IDApXG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICByZXR1cm4gYVR1cGxlWzFdIC0gYlR1cGxlWzFdO1xuICB9KSwgZnJvbUpTKGF1eC5tYXAoKHYpID0+IHZbMF0pKTtcbn07XG5waXBlRnVuY3Rpb25zLm9yZGVyLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDE7XG5waXBlRnVuY3Rpb25zLnNjb3JlID0gYXN5bmMgZnVuY3Rpb24oYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKCFiYXNlLmlzQXJyYXkoKSkgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHVua25vd24gPSBbXSwgc2NvcmVkID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB1bmtub3duLnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICBsZXQgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PSBcIm51bWJlclwiID8gdmFsdWUuZGF0YS5fc2NvcmUgOiAwO1xuICAgIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpXG4gICAgICB2YWx1ZVNjb3JlICs9IGF3YWl0IGV2YWx1YXRlU2NvcmUoYXJnLCBuZXdTY29wZSwgZXhlY3V0ZSk7XG4gICAgY29uc3QgbmV3T2JqZWN0ID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUuZGF0YSwgeyBfc2NvcmU6IHZhbHVlU2NvcmUgfSk7XG4gICAgc2NvcmVkLnB1c2gobmV3T2JqZWN0KTtcbiAgfVxuICByZXR1cm4gc2NvcmVkLnNvcnQoKGEsIGIpID0+IGIuX3Njb3JlIC0gYS5fc2NvcmUpLCBmcm9tSlMoc2NvcmVkKTtcbn07XG5waXBlRnVuY3Rpb25zLnNjb3JlLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDE7XG5jb25zdCBkZWx0YSA9IHt9O1xuZGVsdGEub3BlcmF0aW9uID0gYXN5bmMgZnVuY3Rpb24oX2FyZ3MsIHNjb3BlKSB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsLCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIHJldHVybiBoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIgPyBmcm9tU3RyaW5nKFwidXBkYXRlXCIpIDogaGFzQWZ0ZXIgPyBmcm9tU3RyaW5nKFwiY3JlYXRlXCIpIDogaGFzQmVmb3JlID8gZnJvbVN0cmluZyhcImRlbGV0ZVwiKSA6IE5VTExfVkFMVUU7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gXCJkZWx0YVwiO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbmNvbnN0IG1hdGggPSB7fTtcbm1hdGgubWluID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG47XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPCBuKSAmJiAobiA9IGVsZW0uZGF0YSk7XG4gICAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWluLmFyaXR5ID0gMTtcbm1hdGgubWF4ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG47XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPiBuKSAmJiAobiA9IGVsZW0uZGF0YSk7XG4gICAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWF4LmFyaXR5ID0gMTtcbm1hdGguc3VtID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSlcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgbGV0IG4gPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKVxuICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVsbFwiKSB7XG4gICAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIG4gKz0gZWxlbS5kYXRhO1xuICAgIH1cbiAgcmV0dXJuIGZyb21KUyhuKTtcbn07XG5tYXRoLnN1bS5hcml0eSA9IDE7XG5tYXRoLmF2ZyA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGxldCBuID0gMCwgYyA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpXG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgbiArPSBlbGVtLmRhdGEsIGMrKztcbiAgICB9XG4gIHJldHVybiBjID09PSAwID8gTlVMTF9WQUxVRSA6IGZyb21KUyhuIC8gYyk7XG59O1xubWF0aC5hdmcuYXJpdHkgPSAxO1xuY29uc3QgZGF0ZVRpbWUyID0ge307XG5kYXRlVGltZTIubm93ID0gYXN5bmMgZnVuY3Rpb24oX2FyZ3MsIHNjb3BlKSB7XG4gIHJldHVybiBmcm9tRGF0ZVRpbWUobmV3IERhdGVUaW1lKHNjb3BlLmNvbnRleHQudGltZXN0YW1wKSk7XG59O1xuZGF0ZVRpbWUyLm5vdy5hcml0eSA9IDA7XG5jb25zdCBuYW1lc3BhY2VzID0ge1xuICBnbG9iYWw6IF9nbG9iYWwsXG4gIHN0cmluZzogc3RyaW5nMixcbiAgYXJyYXksXG4gIHB0LFxuICBkZWx0YSxcbiAgZGlmZixcbiAgc2FuaXR5LFxuICBtYXRoLFxuICBkYXRlVGltZTogZGF0ZVRpbWUyXG59O1xuY2xhc3MgTWFya1Byb2Nlc3NvciB7XG4gIHN0cmluZztcbiAgbWFya3M7XG4gIGluZGV4O1xuICBwYXJzZU9wdGlvbnM7XG4gIGFsbG93Qm9vc3QgPSAhMTtcbiAgY29uc3RydWN0b3Ioc3RyaW5nLCBtYXJrcywgcGFyc2VPcHRpb25zKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmcsIHRoaXMubWFya3MgPSBtYXJrcywgdGhpcy5pbmRleCA9IDAsIHRoaXMucGFyc2VPcHRpb25zID0gcGFyc2VPcHRpb25zO1xuICB9XG4gIGhhc01hcmsocG9zID0gMCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ICsgcG9zIDwgdGhpcy5tYXJrcy5sZW5ndGg7XG4gIH1cbiAgZ2V0TWFyayhwb3MgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubWFya3NbdGhpcy5pbmRleCArIHBvc107XG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgdGhpcy5pbmRleCArPSAxO1xuICB9XG4gIHByb2Nlc3ModmlzaXRvcikge1xuICAgIGNvbnN0IG1hcmsgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuc2hpZnQoKTtcbiAgICBjb25zdCBmdW5jID0gdmlzaXRvclttYXJrLm5hbWVdO1xuICAgIGlmICghZnVuYylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBoYW5kbGVyOiAke21hcmsubmFtZX1gKTtcbiAgICByZXR1cm4gZnVuYy5jYWxsKHZpc2l0b3IsIHRoaXMsIG1hcmspO1xuICB9XG4gIHByb2Nlc3NTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hpZnQoKSwgdGhpcy5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZ0VuZCgpIHtcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4IC0gMV0sIGN1cnIgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KCksIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xuICB9XG4gIHNsaWNlKGxlbikge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMubWFya3NbdGhpcy5pbmRleF0ucG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcbiAgfVxufVxuY29uc3QgV1MgPSAvXihbXFx0XFxuXFx2XFxmXFxyIFxcdTAwODVcXHUwMEEwXXwoXFwvXFwvW15cXG5dKlxcbikpKy8sIE5VTSA9IC9eXFxkKy8sIElERU5UID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qLztcbmZ1bmN0aW9uIHBhcnNlJDEoc3RyKSB7XG4gIGxldCBwb3MgPSAwO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBcImVycm9yXCIgPyByZXN1bHQgOiAocG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKSwgcG9zICE9PSBzdHIubGVuZ3RoID8gKHJlc3VsdC5mYWlsUG9zaXRpb24gJiYgKHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxKSwgeyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfSkgOiAoZGVsZXRlIHJlc3VsdC5wb3NpdGlvbiwgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb24sIHJlc3VsdCkpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByKHN0ciwgcG9zLCBsZXZlbCkge1xuICBsZXQgc3RhcnRQb3MgPSBwb3MsIHRva2VuID0gc3RyW3Bvc10sIG1hcmtzO1xuICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgY2FzZSBcIitcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAxMCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJwb3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIi1cIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCA4KTtcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcIm5lZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiKFwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICBzd2l0Y2ggKHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbiksIHN0cltwb3NdKSB7XG4gICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICBmb3IgKG1hcmtzID0gW3sgbmFtZTogXCJ0dXBsZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpOyA7ICkge1xuICAgICAgICAgICAgaWYgKHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCksIHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKSwgc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICBwb3MrKywgbWFya3MucHVzaCh7IG5hbWU6IFwidHVwbGVfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIilcIjoge1xuICAgICAgICAgIHBvcysrLCBtYXJrcyA9IFt7IG5hbWU6IFwiZ3JvdXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIiFcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAxMCk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJub3RcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpLCBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIntcIjoge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgbWFya3MgPSByZXN1bHQubWFya3MsIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiW1wiOlxuICAgICAgaWYgKG1hcmtzID0gW3sgbmFtZTogXCJhcnJheVwiLCBwb3NpdGlvbjogcG9zIH1dLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gIT09IFwiXVwiKVxuICAgICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgICBzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIiAmJiAobWFya3MucHVzaCh7IG5hbWU6IFwiYXJyYXlfc3BsYXRcIiwgcG9zaXRpb246IHBvcyB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMykpO1xuICAgICAgICAgIGxldCByZXMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgIGlmIChyZXMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzO1xuICAgICAgICAgIGlmIChtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXMubWFya3MpLCBwb3MgPSByZXMucG9zaXRpb24sIHBvcyA9IHNraXBXUyhzdHIsIHBvcyksIHN0cltwb3NdICE9PSBcIixcIiB8fCAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIl1cIikpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKVxuICAgICAgICBwb3MrKywgbWFya3MucHVzaCh7IG5hbWU6IFwiYXJyYXlfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIidcIjpcbiAgICBjYXNlICdcIic6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZVN0cmluZyhzdHIsIHBvcyk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzLCBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIl5cIjoge1xuICAgICAgZm9yIChwb3MrKywgbWFya3MgPSBbXTsgc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCJeXCI7IClcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiZGJscGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zICs9IDI7XG4gICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJwYXJlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJAXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwidGhpc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sIHBvcysrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIipcIjpcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJldmVyeXRoaW5nXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XSwgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiJFwiOiB7XG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zICsgMSwgSURFTlQpO1xuICAgICAgaWRlbnRMZW4gJiYgKHBvcyArPSAxICsgaWRlbnRMZW4sIG1hcmtzID0gW1xuICAgICAgICB7IG5hbWU6IFwicGFyYW1cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgKyAxIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICBdKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgIGlmIChudW1MZW4pIHtcbiAgICAgICAgcG9zICs9IG51bUxlbjtcbiAgICAgICAgbGV0IG5hbWUgPSBcImludGVnZXJcIjtcbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIikge1xuICAgICAgICAgIGxldCBmcmFjTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIE5VTSk7XG4gICAgICAgICAgZnJhY0xlbiAmJiAobmFtZSA9IFwiZmxvYXRcIiwgcG9zICs9IDEgKyBmcmFjTGVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiZVwiIHx8IHN0cltwb3NdID09PSBcIkVcIikge1xuICAgICAgICAgIG5hbWUgPSBcInNjaVwiLCBwb3MrKywgKHN0cltwb3NdID09PSBcIitcIiB8fCBzdHJbcG9zXSA9PT0gXCItXCIpICYmIHBvcysrO1xuICAgICAgICAgIGxldCBleHBMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBOVU0pO1xuICAgICAgICAgIGlmICghZXhwTGVuKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICBwb3MgKz0gZXhwTGVuO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgIHsgbmFtZSwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgeyBuYW1lOiBuYW1lICsgXCJfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICBdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICBzd2l0Y2ggKHBvcyArPSBpZGVudExlbiwgc3RyW3Bvc10pIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgIGNhc2UgXCIoXCI6IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzLCBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1hcmtzID0gW1xuICAgICAgICAgICAgICB7IG5hbWU6IFwidGhpc19hdHRyXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIW1hcmtzKVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICBsZXQgbGhzTGV2ZWwgPSAxMiwgdHJhdjtcbiAgbG9vcDogZm9yICg7IDsgKSB7XG4gICAgbGV0IGlubmVyUG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICBpZiAoaW5uZXJQb3MgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIHBvcyA9IGlubmVyUG9zO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBpbm5lclBvcyksIHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgIGZvciAobWFya3MudW5zaGlmdCh7IG5hbWU6IFwidHJhdmVyc2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pOyB0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiOyApXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHRyYXYubWFya3MpLCBwb3MgPSB0cmF2LnBvc2l0aW9uLCB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBza2lwV1Moc3RyLCBwb3MpKTtcbiAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInRyYXZlcnNhbF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0cltpbm5lclBvc10pIHtcbiAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgc3dpdGNoIChzdHJbaW5uZXJQb3MgKyAxXSkge1xuICAgICAgICAgIGNhc2UgXCI+XCI6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDEgfHwgbGhzTGV2ZWwgPD0gMSkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCAxKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGFpclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA1KTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIitcIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA2IHx8IGxoc0xldmVsIDwgNikgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDcpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYWRkXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIi1cIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA2IHx8IGxoc0xldmVsIDwgNikgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIDcpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwic3ViXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIipcIjoge1xuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgaWYgKGxldmVsID4gOCB8fCBsaHNMZXZlbCA8PSA4KSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMyID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgOCk7XG4gICAgICAgICAgaWYgKHJoczIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzMjtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMyLm1hcmtzKSwgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicG93XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzMi5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZXZlbCA+IDcgfHwgbGhzTGV2ZWwgPCA3KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgOCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJtdWxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiL1wiOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IDcgfHwgbGhzTGV2ZWwgPCA3KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgOCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJkaXZcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiJVwiOiB7XG4gICAgICAgIGlmIChsZXZlbCA+IDcgfHwgbGhzTGV2ZWwgPCA3KSBicmVhayBsb29wO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgOCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpLCBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJtb2RcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSByaHMucG9zaXRpb24sIGxoc0xldmVsID0gNztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiPFwiOlxuICAgICAgY2FzZSBcIj5cIjoge1xuICAgICAgICBpZiAobGV2ZWwgPiA0IHx8IGxoc0xldmVsIDw9IDQpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCBuZXh0UG9zID0gaW5uZXJQb3MgKyAxO1xuICAgICAgICBzdHJbbmV4dFBvc10gPT09IFwiPVwiICYmIG5leHRQb3MrKztcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MpLCA1KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogbmV4dFBvcyB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInxcIjoge1xuICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwifFwiKSB7XG4gICAgICAgICAgaWYgKGxldmVsID4gMiB8fCBsaHNMZXZlbCA8IDIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDMpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm9yXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxldmVsID4gMTEgfHwgbGhzTGV2ZWwgPCAxMSkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgICAgIGlmICghaWRlbnRMZW4pIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IGlkZW50UG9zIH07XG4gICAgICAgICAgaWYgKHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW4sIHN0cltwb3NdID09PSBcIihcIiB8fCBzdHJbcG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgaWRlbnRQb3MsIHBvcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBpcGVjYWxsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcG9zID0gcmVzdWx0LnBvc2l0aW9uLCBsaHNMZXZlbCA9IDExO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCImXCI6IHtcbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9IFwiJlwiIHx8IGxldmVsID4gMyB8fCBsaHNMZXZlbCA8IDMpIGJyZWFrIGxvb3A7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA0KTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFuZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSAzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9PSBcIj1cIiB8fCBsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDUpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbiwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkXCI6IHtcbiAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyA0KSAhPT0gXCJkZXNjXCIgfHwgbGV2ZWwgPiA0IHx8IGxoc0xldmVsIDwgNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGVzY1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHBvcyA9IGlubmVyUG9zICsgNCwgbGhzTGV2ZWwgPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhXCI6IHtcbiAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyAzKSAhPT0gXCJhc2NcIiB8fCBsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPCA0KSBicmVhayBsb29wO1xuICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBwb3MgPSBpbm5lclBvcyArIDMsIGxoc0xldmVsID0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzd2l0Y2ggKHBhcnNlUmVnZXhTdHIoc3RyLCBpbm5lclBvcywgSURFTlQpKSB7XG4gICAgICAgICAgY2FzZSBcImluXCI6IHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IDQgfHwgbGhzTGV2ZWwgPD0gNCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMik7XG4gICAgICAgICAgICBsZXQgaXNHcm91cCA9ICExO1xuICAgICAgICAgICAgc3RyW3Bvc10gPT09IFwiKFwiICYmIChpc0dyb3VwID0gITAsIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpKTtcbiAgICAgICAgICAgIGxldCByYW5nZVBvcyA9IHBvcywgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCA1KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbiksIHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgICAgICAgc3RyW3BvcyArIDJdID09PSBcIi5cIiA/ICh0eXBlID0gXCJleGNfcmFuZ2VcIiwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMykpIDogcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDUpO1xuICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiaW5fcmFuZ2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvcyB9LCByZXN1bHQubWFya3MsIHJocy5tYXJrcyksIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgICAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBzdHJbcG9zXSAhPT0gXCIpXCIpIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibWF0Y2hcIjoge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gNCB8fCBsaHNMZXZlbCA8PSA0KSBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgNSksIDUpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgNSB9KSwgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKSwgcG9zID0gcmhzLnBvc2l0aW9uLCBsaHNMZXZlbCA9IDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGZhaWxQb3NpdGlvbiA9IHRyYXY/LnR5cGUgPT09IFwiZXJyb3JcIiAmJiB0cmF2LnBvc2l0aW9uO1xuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MsIGZhaWxQb3NpdGlvbiB9O1xufVxuZnVuY3Rpb24gcGFyc2VUcmF2ZXJzYWwoc3RyLCBwb3MpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgY2FzZSBcIi5cIjoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBsZXQgaWRlbnRTdGFydCA9IHBvcywgaWRlbnRMZW4yID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgcmV0dXJuIGlkZW50TGVuMiA/IChwb3MgKz0gaWRlbnRMZW4yLCB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBtYXJrczogW1xuICAgICAgICAgIHsgbmFtZTogXCJhdHRyX2FjY2Vzc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IGlkZW50U3RhcnQgfSxcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxuICAgICAgICBdLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9KSA6IHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgfVxuICAgIGNhc2UgXCItXCI6XG4gICAgICBpZiAoc3RyW3BvcyArIDFdICE9PSBcIj5cIikgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcImRlcmVmXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XTtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgcG9zKSwgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgIHJldHVybiBpZGVudExlbiAmJiAocG9zID0gaWRlbnRQb3MgKyBpZGVudExlbiwgbWFya3MucHVzaChcbiAgICAgICAgeyBuYW1lOiBcImRlcmVmX2F0dHJcIiwgcG9zaXRpb246IGlkZW50UG9zIH0sXG4gICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSxcbiAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICkpLCB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBtYXJrcyxcbiAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgfTtcbiAgICBjYXNlIFwiW1wiOiB7XG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSksIHN0cltwb3NdID09PSBcIl1cIilcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtYXJrczogW3sgbmFtZTogXCJhcnJheV9wb3N0Zml4XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9O1xuICAgICAgbGV0IHJhbmdlUG9zID0gcG9zLCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAocG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKSwgc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBcImluY19yYW5nZVwiO1xuICAgICAgICBzdHJbcG9zICsgMl0gPT09IFwiLlwiID8gKHR5cGUgPSBcImV4Y19yYW5nZVwiLCBwb3MgKz0gMykgOiBwb3MgKz0gMiwgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIHJldHVybiByaHMudHlwZSA9PT0gXCJlcnJvclwiID8gcmhzIDogKHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbiksIHN0cltwb3NdICE9PSBcIl1cIiA/IHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH0gOiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJzbGljZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgIHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH1cbiAgICAgICAgICBdLmNvbmNhdChyZXN1bHQubWFya3MsIHJocy5tYXJrcyksXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyW3Bvc10gIT09IFwiXVwiID8geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfSA6IHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcInNxdWFyZV9icmFja2V0XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmVzdWx0Lm1hcmtzKSxcbiAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ8XCI6IHtcbiAgICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKSwgc3RyW3Bvc10gPT09IFwie1wiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiIHx8IHJlc3VsdC5tYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwcm9qZWN0aW9uXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgcmVzdWx0O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICByZXR1cm4gcmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIiB8fCByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG59XG5mdW5jdGlvbiBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcykge1xuICBsZXQgbWFya3MgPSBbXTtcbiAgaWYgKG1hcmtzLnB1c2goeyBuYW1lOiBcImZ1bmNfY2FsbFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSksIHN0cltwb3NdID09PSBcIjpcIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiOlwiKSB7XG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwibmFtZXNwYWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KSwgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgaWYgKCFuYW1lTGVuKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBpZiAobWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyBuYW1lTGVuIH0pLCBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyBuYW1lTGVuKSwgc3RyW3Bvc10gIT09IFwiKFwiKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBwb3MrKywgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgfSBlbHNlXG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSwgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIGxldCBsYXN0UG9zID0gcG9zO1xuICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxuICAgIGZvciAoOyA7ICkge1xuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmIChtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpLCBsYXN0UG9zID0gcmVzdWx0LnBvc2l0aW9uLCBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pLCBzdHJbcG9zXSAhPT0gXCIsXCIgfHwgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpLCBzdHJbcG9zXSA9PT0gXCIpXCIpKSBicmVhaztcbiAgICB9XG4gIHJldHVybiBzdHJbcG9zXSAhPT0gXCIpXCIgPyB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9IDogKG1hcmtzLnB1c2goeyBuYW1lOiBcImZ1bmNfYXJnc19lbmRcIiwgcG9zaXRpb246IGxhc3RQb3MgfSksIHtcbiAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICBtYXJrcyxcbiAgICBwb3NpdGlvbjogcG9zICsgMVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KHN0ciwgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwib2JqZWN0XCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gIGZvciAocG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7IHN0cltwb3NdICE9PSBcIn1cIjsgKSB7XG4gICAgbGV0IHBhaXJQb3MgPSBwb3M7XG4gICAgaWYgKHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSBcIi4uLlwiKVxuICAgICAgaWYgKHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpLCBzdHJbcG9zXSAhPT0gXCJ9XCIgJiYgc3RyW3Bvc10gIT09IFwiLFwiKSB7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gZXhwcjtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0XCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pLCBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKSwgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3Rfc3BsYXRfdGhpc1wiLCBwb3NpdGlvbjogcGFpclBvcyB9KTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIGV4cHI7XG4gICAgICBsZXQgbmV4dFBvcyA9IHNraXBXUyhzdHIsIGV4cHIucG9zaXRpb24pO1xuICAgICAgaWYgKGV4cHIubWFya3NbMF0ubmFtZSA9PT0gXCJzdHJcIiAmJiBzdHJbbmV4dFBvc10gPT09IFwiOlwiKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MgKyAxKSwgMCk7XG4gICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcImVycm9yXCIpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3BhaXJcIiwgcG9zaXRpb246IHBhaXJQb3MgfSksIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKSwgcG9zID0gdmFsdWUucG9zaXRpb247XG4gICAgICB9IGVsc2VcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoeyBuYW1lOiBcIm9iamVjdF9leHByXCIsIHBvc2l0aW9uOiBwb3MgfSwgZXhwci5tYXJrcyksIHBvcyA9IGV4cHIucG9zaXRpb247XG4gICAgfVxuICAgIGlmIChwb3MgPSBza2lwV1Moc3RyLCBwb3MpLCBzdHJbcG9zXSAhPT0gXCIsXCIpIGJyZWFrO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG4gIHJldHVybiBzdHJbcG9zXSAhPT0gXCJ9XCIgPyB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9IDogKHBvcysrLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSksIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBwb3MpIHtcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIHBvcyA9IHBvcyArIDE7XG4gIGNvbnN0IG1hcmtzID0gW3sgbmFtZTogXCJzdHJcIiwgcG9zaXRpb246IHBvcyB9XTtcbiAgc3RyOiBmb3IgKDsgOyBwb3MrKykge1xuICAgIGlmIChwb3MgPiBzdHIubGVuZ3RoKSByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICBjYXNlIHRva2VuOiB7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSwgcG9zKys7XG4gICAgICAgIGJyZWFrIHN0cjtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9wYXVzZVwiLCBwb3NpdGlvbjogcG9zIH0pLCBzdHJbcG9zICsgMV0gPT09IFwidVwiID8gc3RyW3BvcyArIDJdID09PSBcIntcIiA/IChtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleFwiLCBwb3NpdGlvbjogcG9zICsgMyB9KSwgcG9zID0gc3RyLmluZGV4T2YoXCJ9XCIsIHBvcyArIDMpLCBtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KSkgOiAobWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDIgfSksIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgNiB9KSwgcG9zICs9IDUpIDogKG1hcmtzLnB1c2goeyBuYW1lOiBcInNpbmdsZV9lc2NhcGVcIiwgcG9zaXRpb246IHBvcyArIDEgfSksIHBvcyArPSAxKSwgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX3N0YXJ0XCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHNraXBXUyhzdHIsIHBvcykge1xuICByZXR1cm4gcG9zICsgcGFyc2VSZWdleChzdHIsIHBvcywgV1MpO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleChzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdLmxlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4U3RyKHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0gOiBudWxsO1xufVxuZnVuY3Rpb24gam9pbihhLCBiKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gYihhKGJhc2UpKTtcbn1cbmZ1bmN0aW9uIG1hcChpbm5lcikge1xuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiTWFwXCIsIGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogXCJUaGlzXCIgfSkgfSk7XG59XG5mdW5jdGlvbiBmbGF0TWFwKGlubmVyKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gKHsgdHlwZTogXCJGbGF0TWFwXCIsIGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogXCJUaGlzXCIgfSkgfSk7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUFycmF5KGJ1aWxkLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgYnVpbGRcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIG1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBmbGF0TWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlUGxhaW4obWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyYXZlcnNlRWxlbWVudChtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQcm9qZWN0aW9uKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XG4gIH1cbn1cbmNvbnN0IEVTQ0FQRV9TRVFVRU5DRSA9IHtcbiAgXCInXCI6IFwiJ1wiLFxuICAnXCInOiAnXCInLFxuICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gIFwiL1wiOiBcIi9cIixcbiAgYjogXCJcXGJcIixcbiAgZjogXCJcXGZcIixcbiAgbjogYFxuYCxcbiAgcjogXCJcXHJcIixcbiAgdDogXCJcdFwiXG59O1xuZnVuY3Rpb24gZXhwYW5kSGV4KHN0cikge1xuICBjb25zdCBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59XG5jbGFzcyBHcm9xUXVlcnlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgbmFtZSA9IFwiR3JvcVF1ZXJ5RXJyb3JcIjtcbn1cbmNvbnN0IEVYUFJfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkdyb3VwXCIsXG4gICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgIH07XG4gIH0sXG4gIGV2ZXJ5dGhpbmcoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJFdmVyeXRoaW5nXCIgfTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcIlRoaXNcIiB9O1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiAxXG4gICAgfTtcbiAgfSxcbiAgZGJscGFyZW50KHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXJlbnRcIixcbiAgICAgIG46IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLm4gKyAxXG4gICAgfTtcbiAgfSxcbiAgdHJhdmVyc2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdHJhdmVyc2FsTGlzdCA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIjsgKVxuICAgICAgdHJhdmVyc2FsTGlzdC5wdXNoKHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKSk7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCB0cmF2ZXJzYWwgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSB0cmF2ZXJzYWxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2FsTGlzdFtpXSh0cmF2ZXJzYWwpO1xuICAgIGlmICgoYmFzZS50eXBlID09PSBcIkV2ZXJ5dGhpbmdcIiB8fCBiYXNlLnR5cGUgPT09IFwiQXJyYXlcIiB8fCBiYXNlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIpICYmICh0cmF2ZXJzYWwgPSB0cmF2ZXJzZUFycmF5KCh2YWwpID0+IHZhbCwgdHJhdmVyc2FsKSksIHRyYXZlcnNhbCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbFwiKTtcbiAgICByZXR1cm4gdHJhdmVyc2FsLmJ1aWxkKGJhc2UpO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gbmFtZSA9PT0gXCJudWxsXCIgPyB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IG51bGwgfSA6IG5hbWUgPT09IFwidHJ1ZVwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiAhMCB9IDogbmFtZSA9PT0gXCJmYWxzZVwiID8geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiAhMSB9IDoge1xuICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9LFxuICBuZWcocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5lZ1wiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBwb3MocCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvc1wiLFxuICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICB9O1xuICB9LFxuICBhZGQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIitcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiLVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbXVsKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBkaXYocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi9cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiJVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgcG93KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIqKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgY29tcChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCBvcCA9IHAucHJvY2Vzc1N0cmluZygpLCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3AsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJblJhbmdlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgaXNJbmNsdXNpdmVcbiAgICB9O1xuICB9LFxuICBzdHIocCkge1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgbG9vcDogZm9yICg7IHAuaGFzTWFyaygpOyApIHtcbiAgICAgIGNvbnN0IG1hcmsgPSBwLmdldE1hcmsoKTtcbiAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJzdHJfZW5kXCI6XG4gICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgY2FzZSBcInN0cl9wYXVzZVwiOlxuICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RyX3N0YXJ0XCI6XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2luZ2xlX2VzY2FwZVwiOiB7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHAuc2xpY2UoMSk7XG4gICAgICAgICAgcC5zaGlmdCgpLCB2YWx1ZSArPSBFU0NBUEVfU0VRVUVOQ0VbY2hhcl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaWNvZGVfaGV4XCI6XG4gICAgICAgICAgcC5zaGlmdCgpLCB2YWx1ZSArPSBleHBhbmRIZXgocC5wcm9jZXNzU3RyaW5nRW5kKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBtYXJrOiAke21hcmsubmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZSB9O1xuICB9LFxuICBpbnRlZ2VyKHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIGZsb2F0KHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIHNjaShwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBvYmplY3QocCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICBmb3IgKDsgcC5nZXRNYXJrKCkubmFtZSAhPT0gXCJvYmplY3RfZW5kXCI7IClcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChwLnByb2Nlc3MoT0JKRUNUX0JVSUxERVIpKTtcbiAgICByZXR1cm4gcC5zaGlmdCgpLCB7XG4gICAgICB0eXBlOiBcIk9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH07XG4gIH0sXG4gIGFycmF5KHApIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIGZvciAoOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcImFycmF5X2VuZFwiOyApIHtcbiAgICAgIGxldCBpc1NwbGF0ID0gITE7XG4gICAgICBwLmdldE1hcmsoKS5uYW1lID09PSBcImFycmF5X3NwbGF0XCIgJiYgKGlzU3BsYXQgPSAhMCwgcC5zaGlmdCgpKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICBlbGVtZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJBcnJheUVsZW1lbnRcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGlzU3BsYXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcC5zaGlmdCgpLCB7XG4gICAgICB0eXBlOiBcIkFycmF5XCIsXG4gICAgICBlbGVtZW50c1xuICAgIH07XG4gIH0sXG4gIHR1cGxlKHApIHtcbiAgICBjb25zdCBtZW1iZXJzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHVwbGVfZW5kXCI7IClcbiAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgcmV0dXJuIHAuc2hpZnQoKSwge1xuICAgICAgdHlwZTogXCJUdXBsZVwiLFxuICAgICAgbWVtYmVyc1xuICAgIH07XG4gIH0sXG4gIGZ1bmNfY2FsbChwKSB7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIiAmJiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKSk7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgbmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcIlNlbGVjdFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZXM6IFtdXG4gICAgICB9O1xuICAgICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiOyApXG4gICAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgICAgIHJlc3VsdC5hbHRlcm5hdGl2ZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIlNlbGVjdEFsdGVybmF0aXZlXCIsXG4gICAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClcIik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHAuc2hpZnQoKSwgcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgZm9yICg7IHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiOyApXG4gICAgICBhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBuYW1lLCBhcmdzLmxlbmd0aCkgPyAocC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpLCBhcmdzLnB1c2goeyB0eXBlOiBcIlNlbGVjdG9yXCIgfSkpIDogYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICBpZiAocC5zaGlmdCgpLCBuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgKG5hbWUgPT09IFwiYmVmb3JlXCIgfHwgbmFtZSA9PT0gXCJhZnRlclwiKSAmJiBwLnBhcnNlT3B0aW9ucy5tb2RlID09PSBcImRlbHRhXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkNvbnRleHRcIixcbiAgICAgICAga2V5OiBuYW1lXG4gICAgICB9O1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgbmFtZSA9PT0gXCJib29zdFwiICYmICFwLmFsbG93Qm9vc3QpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0XCIpO1xuICAgIGNvbnN0IGZ1bmNzID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VdO1xuICAgIGlmICghZnVuY3MpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBuYW1lc3BhY2U6ICR7bmFtZXNwYWNlfWApO1xuICAgIGNvbnN0IGZ1bmMgPSBmdW5jc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIGlmIChmdW5jLmFyaXR5ICE9PSB2b2lkIDAgJiYgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCksIGZ1bmMubW9kZSAhPT0gdm9pZCAwICYmIGZ1bmMubW9kZSAhPT0gcC5wYXJzZU9wdGlvbnMubW9kZSlcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBpcGVjYWxsKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiICYmIChwLnNoaWZ0KCksIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpKSwgbmFtZXNwYWNlICE9PSBcImdsb2JhbFwiKVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgbmFtZXNwYWNlOiAke25hbWVzcGFjZX1gKTtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCksIGFyZ3MgPSBbXSwgb2xkQWxsb3dCb29zdCA9IHAuYWxsb3dCb29zdDtcbiAgICBmb3IgKG5hbWUgPT09IFwic2NvcmVcIiAmJiAocC5hbGxvd0Jvb3N0ID0gITApOyA7ICkge1xuICAgICAgY29uc3QgbWFya05hbWUgPSBwLmdldE1hcmsoKS5uYW1lO1xuICAgICAgaWYgKG1hcmtOYW1lID09PSBcImZ1bmNfYXJnc19lbmRcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAobmFtZSA9PT0gXCJvcmRlclwiKSB7XG4gICAgICAgIGlmIChtYXJrTmFtZSA9PT0gXCJhc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKSwgYXJncy5wdXNoKHsgdHlwZTogXCJBc2NcIiwgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAobWFya05hbWUgPT09IFwiZGVzY1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpLCBhcmdzLnB1c2goeyB0eXBlOiBcIkRlc2NcIiwgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKSwgcC5hbGxvd0Jvb3N0ID0gb2xkQWxsb3dCb29zdDtcbiAgICBjb25zdCBmdW5jID0gcGlwZUZ1bmN0aW9uc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmMpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBwaXBlIGZ1bmN0aW9uOiAke25hbWV9YCk7XG4gICAgcmV0dXJuIGZ1bmMuYXJpdHkgJiYgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCksIHtcbiAgICAgIHR5cGU6IFwiUGlwZUZ1bmNDYWxsXCIsXG4gICAgICBmdW5jLFxuICAgICAgYmFzZSxcbiAgICAgIG5hbWUsXG4gICAgICBhcmdzXG4gICAgfTtcbiAgfSxcbiAgcGFpcigpIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkID0+XCIpO1xuICB9LFxuICBhbmQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBbmRcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG9yKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3JcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG5vdChwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTm90XCIsXG4gICAgICBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgIH07XG4gIH0sXG4gIGFzYygpIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFzY1wiKTtcbiAgfSxcbiAgZGVzYygpIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGRlc2NcIik7XG4gIH0sXG4gIHBhcmFtKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIHAucGFyc2VPcHRpb25zLnBhcmFtcyAmJiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogcC5wYXJzZU9wdGlvbnMucGFyYW1zW25hbWVdXG4gICAgfSA6IHtcbiAgICAgIHR5cGU6IFwiUGFyYW1ldGVyXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfVxufSwgT0JKRUNUX0JVSUxERVIgPSB7XG4gIG9iamVjdF9leHByKHApIHtcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpLCB2YWx1ZTIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiLFxuICAgICAgICBjb25kaXRpb24sXG4gICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcbiAgICAgIG5hbWU6IGV4dHJhY3RQcm9wZXJ0eUtleSh2YWx1ZSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9wYWlyKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgaWYgKG5hbWUudHlwZSAhPT0gXCJWYWx1ZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcbiAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdChwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcbiAgICAgIHZhbHVlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdF90aGlzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICB2YWx1ZTogeyB0eXBlOiBcIlRoaXNcIiB9XG4gICAgfTtcbiAgfVxufSwgVFJBVkVSU0VfQlVJTERFUiA9IHtcbiAgc3F1YXJlX2JyYWNrZXQocCkge1xuICAgIGNvbnN0IGV4cHIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSwgdmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGV4cHIpO1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcIm51bWJlclwiID8gKHJpZ2h0KSA9PiB0cmF2ZXJzZUVsZW1lbnQoKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzRWxlbWVudFwiLCBiYXNlLCBpbmRleDogdmFsdWUuZGF0YSB9KSwgcmlnaHQpIDogdmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIiA/IChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZTogdmFsdWUuZGF0YSB9KSwgcmlnaHQpIDogKHJpZ2h0KSA9PiB0cmF2ZXJzZUFycmF5KFxuICAgICAgKGJhc2UpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiRmlsdGVyXCIsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIGV4cHJcbiAgICAgIH0pLFxuICAgICAgcmlnaHRcbiAgICApO1xuICB9LFxuICBzbGljZShwKSB7XG4gICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUiksIGxlZnRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUobGVmdCksIHJpZ2h0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKHJpZ2h0KTtcbiAgICBpZiAoIWxlZnRWYWx1ZSB8fCAhcmlnaHRWYWx1ZSB8fCBsZWZ0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJzbGljaW5nIG11c3QgdXNlIGNvbnN0YW50IG51bWJlcnNcIik7XG4gICAgcmV0dXJuIChyaHMpID0+IHRyYXZlcnNlQXJyYXkoXG4gICAgICAoYmFzZSkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJTbGljZVwiLFxuICAgICAgICBiYXNlLFxuICAgICAgICBsZWZ0OiBsZWZ0VmFsdWUuZGF0YSxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0VmFsdWUuZGF0YSxcbiAgICAgICAgaXNJbmNsdXNpdmVcbiAgICAgIH0pLFxuICAgICAgcmhzXG4gICAgKTtcbiAgfSxcbiAgcHJvamVjdGlvbihwKSB7XG4gICAgY29uc3Qgb2JqID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQcm9qZWN0aW9uKChiYXNlKSA9PiAoeyB0eXBlOiBcIlByb2plY3Rpb25cIiwgYmFzZSwgZXhwcjogb2JqIH0pLCByaWdodCk7XG4gIH0sXG4gIGF0dHJfYWNjZXNzKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZSB9KSwgcmlnaHQpO1xuICB9LFxuICBkZXJlZihwKSB7XG4gICAgbGV0IGF0dHIgPSBudWxsO1xuICAgIHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZGVyZWZfYXR0clwiICYmIChwLnNoaWZ0KCksIGF0dHIgPSBwLnByb2Nlc3NTdHJpbmcoKSk7XG4gICAgY29uc3Qgd3JhcCA9IChiYXNlKSA9PiBhdHRyID8geyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lOiBhdHRyIH0gOiBiYXNlO1xuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oXG4gICAgICAoYmFzZSkgPT4gd3JhcCh7XG4gICAgICAgIHR5cGU6IFwiRGVyZWZcIixcbiAgICAgICAgYmFzZVxuICAgICAgfSksXG4gICAgICByaWdodFxuICAgICk7XG4gIH0sXG4gIGFycmF5X3Bvc3RmaXgoKSB7XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHsgdHlwZTogXCJBcnJheUNvZXJjZVwiLCBiYXNlIH0pLCByaWdodCk7XG4gIH1cbn0sIFNFTEVDVE9SX0JVSUxERVIgPSB7XG4gIGdyb3VwKHApIHtcbiAgICByZXR1cm4gcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpLCBudWxsO1xuICB9LFxuICBldmVyeXRoaW5nKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0aGlzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRibHBhcmVudCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdHJhdmVyc2UocCkge1xuICAgIGZvciAocC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpOyBwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIjsgKVxuICAgICAgcC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpO1xuICAgIHJldHVybiBwLnNoaWZ0KCksIG51bGw7XG4gIH0sXG4gIHRoaXNfYXR0cihwKSB7XG4gICAgcmV0dXJuIHAucHJvY2Vzc1N0cmluZygpLCBudWxsO1xuICB9LFxuICBuZWcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYWRkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBzdWIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG11bCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZGl2KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBtb2QoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvdygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgY29tcCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgaW5fcmFuZ2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN0cigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgaW50ZWdlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgZmxvYXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHNjaSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgb2JqZWN0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhcnJheSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdHVwbGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGZ1bmNfY2FsbChwLCBtYXJrKSB7XG4gICAgY29uc3QgZnVuYyA9IEVYUFJfQlVJTERFUi5mdW5jX2NhbGwocCwgbWFyayk7XG4gICAgaWYgKGZ1bmMubmFtZSA9PT0gXCJhbnl3aGVyZVwiICYmIGZ1bmMuYXJncy5sZW5ndGggPT09IDEpIHJldHVybiBudWxsO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwaXBlY2FsbCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFpcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYW5kKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgbm90KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhc2MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRlc2MoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBhcmFtKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9XG59O1xuZnVuY3Rpb24gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NBdHRyaWJ1dGVcIiAmJiAhbm9kZS5iYXNlKVxuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIgfHwgbm9kZS50eXBlID09PSBcIkRlcmVmXCIgfHwgbm9kZS50eXBlID09PSBcIk1hcFwiIHx8IG5vZGUudHlwZSA9PT0gXCJQcm9qZWN0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlNsaWNlXCIgfHwgbm9kZS50eXBlID09PSBcIkZpbHRlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NFbGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkFycmF5Q29lcmNlXCIgfHwgbm9kZS50eXBlID09PSBcIkdyb3VwXCIpXG4gICAgcmV0dXJuIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlLmJhc2UpO1xuICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYENhbm5vdCBkZXRlcm1pbmUgcHJvcGVydHkga2V5IGZvciB0eXBlOiAke25vZGUudHlwZX1gKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJpdHkobmFtZSwgYXJpdHksIGNvdW50KSB7XG4gIGlmICh0eXBlb2YgYXJpdHkgPT0gXCJudW1iZXJcIikge1xuICAgIGlmIChjb3VudCAhPT0gYXJpdHkpXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXG4gICAgICAgIGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuIEV4cGVjdGVkICR7YXJpdHl9LCBnb3QgJHtjb3VudH0uYFxuICAgICAgKTtcbiAgfSBlbHNlIGlmIChhcml0eSAmJiAhYXJpdHkoY291bnQpKVxuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJHtuYW1lfSgpLmApO1xufVxuZnVuY3Rpb24gYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgZnVuY3Rpb25OYW1lLCBhcmdDb3VudCkge1xuICBjb25zdCBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMgPSBbXCJjaGFuZ2VkQW55XCIsIFwiY2hhbmdlZE9ubHlcIl07XG4gIHJldHVybiBuYW1lc3BhY2UgPT0gXCJkaWZmXCIgJiYgYXJnQ291bnQgPT0gMiAmJiBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMuaW5jbHVkZXMoZnVuY3Rpb25OYW1lKTtcbn1cbmNsYXNzIEdyb3FTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcG9zaXRpb247XG4gIG5hbWUgPSBcIkdyb3FTeW50YXhFcnJvclwiO1xuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbikge1xuICAgIHN1cGVyKGBTeW50YXggZXJyb3IgaW4gR1JPUSBxdWVyeSBhdCBwb3NpdGlvbiAke3Bvc2l0aW9ufWApLCB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2UkMShpbnB1dCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgIHRocm93IG5ldyBHcm9xU3ludGF4RXJyb3IocmVzdWx0LnBvc2l0aW9uKTtcbiAgcmV0dXJuIG5ldyBNYXJrUHJvY2Vzc29yKGlucHV0LCByZXN1bHQubWFya3MsIG9wdGlvbnMpLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbn1cbmNvbnN0IHsgY29tcGFyZSB9ID0gbmV3IEludGwuQ29sbGF0b3IoXCJlblwiKTtcbmZ1bmN0aW9uIHR5cGVOb2Rlc1NvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhLnR5cGUgPT09IFwibnVsbFwiID8gMSA6IGNvbXBhcmUoaGFzaEZpZWxkKGEpLCBoYXNoRmllbGQoYikpO1xufVxuZnVuY3Rpb24gaGFzaEZpZWxkKGZpZWxkKSB7XG4gIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBmaWVsZC52YWx1ZSAhPT0gdm9pZCAwID8gYCR7ZmllbGQudHlwZX0oJHtmaWVsZC52YWx1ZX0pYCA6IGAke2ZpZWxkLnR5cGV9YDtcbiAgICBjYXNlIFwibnVsbFwiOlxuICAgIGNhc2UgXCJ1bmtub3duXCI6XG4gICAgICByZXR1cm4gZmllbGQudHlwZTtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZC50eXBlfSgke2hhc2hGaWVsZChmaWVsZC5vZil9KWA7XG4gICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmVudHJpZXMoZmllbGQuYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gYXR0cmlidXRlcy5zb3J0KChbYV0sIFtiXSkgPT4gY29tcGFyZShhLCBiKSksIGAke2ZpZWxkLnR5cGV9Oigke2F0dHJpYnV0ZXMubWFwKFxuICAgICAgICAoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9OiR7aGFzaEZpZWxkKHZhbHVlLnZhbHVlKX0oJHt2YWx1ZS5vcHRpb25hbCA/IFwib3B0aW9uYWxcIiA6IFwibm9uLW9wdGlvbmFsXCJ9KWBcbiAgICAgICkuam9pbihcIixcIil9KTpyZWYtJHtmaWVsZC5kZXJlZmVyZW5jZXNUb306JHtmaWVsZC5yZXN0ID8gaGFzaEZpZWxkKGZpZWxkLnJlc3QpIDogXCJuby1yZXN0XCJ9YDtcbiAgICB9XG4gICAgY2FzZSBcInVuaW9uXCI6IHtcbiAgICAgIGNvbnN0IHNvcnRlZCA9IFsuLi5maWVsZC5vZl07XG4gICAgICByZXR1cm4gc29ydGVkLnNvcnQodHlwZU5vZGVzU29ydGVyKSwgYCR7ZmllbGQudHlwZX0oJHtzb3J0ZWQubWFwKGhhc2hGaWVsZCkuam9pbihcIixcIil9KWA7XG4gICAgfVxuICAgIGNhc2UgXCJpbmxpbmVcIjpcbiAgICAgIHJldHVybiBgJHtmaWVsZC50eXBlfSgke2ZpZWxkLm5hbWV9KWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmaWVsZC50eXBlO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVUeXBlTm9kZXModHlwZU5vZGVzKSB7XG4gIGNvbnN0IHNlZW5UeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG5ld1R5cGVOb2RlcyA9IFtdLCBzb3J0ZWRUeXBlTm9kZXMgPSBbLi4udHlwZU5vZGVzXTtcbiAgc29ydGVkVHlwZU5vZGVzLnNvcnQodHlwZU5vZGVzU29ydGVyKTtcbiAgZm9yIChjb25zdCB0eXBlTm9kZSBvZiBzb3J0ZWRUeXBlTm9kZXMpIHtcbiAgICBjb25zdCBoYXNoID0gaGFzaEZpZWxkKHR5cGVOb2RlKTtcbiAgICBpZiAoaGFzaCA9PT0gbnVsbCkge1xuICAgICAgbmV3VHlwZU5vZGVzLnB1c2godHlwZU5vZGUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHNlZW5UeXBlcy5oYXMoaGFzaCkgfHwgKHNlZW5UeXBlcy5hZGQoaGFzaCksIG5ld1R5cGVOb2Rlcy5wdXNoKHR5cGVOb2RlKSk7XG4gIH1cbiAgcmV0dXJuIG5ld1R5cGVOb2Rlcztcbn1cbmZ1bmN0aW9uIG9wdGltaXplVW5pb25zKGZpZWxkKSB7XG4gIGlmIChmaWVsZC50eXBlID09PSBcInVuaW9uXCIpIHtcbiAgICBpZiAoZmllbGQub2YubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIGlmIChmaWVsZC5vZiA9IHJlbW92ZUR1cGxpY2F0ZVR5cGVOb2RlcyhmaWVsZC5vZiksIGZpZWxkLm9mLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiBvcHRpbWl6ZVVuaW9ucyhmaWVsZC5vZlswXSk7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgZmllbGQub2YubGVuZ3RoID4gaWR4OyBpZHgrKykge1xuICAgICAgY29uc3Qgc3ViRmllbGQgPSBmaWVsZC5vZltpZHhdO1xuICAgICAgaWYgKHN1YkZpZWxkLnR5cGUgPT09IFwidW5pb25cIikge1xuICAgICAgICBmaWVsZC5vZi5zcGxpY2UoaWR4LCAxLCAuLi5zdWJGaWVsZC5vZiksIGlkeC0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZpZWxkLm9mW2lkeF0gPSBvcHRpbWl6ZVVuaW9ucyhzdWJGaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZC5vZi5zb3J0KChhLCBiKSA9PiBhLnR5cGUgPT09IFwibnVsbFwiID8gMSA6IGNvbXBhcmUoaGFzaEZpZWxkKGEpLCBoYXNoRmllbGQoYikpKSwgZmllbGQ7XG4gIH1cbiAgaWYgKGZpZWxkLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICByZXR1cm4gZmllbGQub2YgPSBvcHRpbWl6ZVVuaW9ucyhmaWVsZC5vZiksIGZpZWxkO1xuICBpZiAoZmllbGQudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgIGZvciAoY29uc3QgaWR4IGluIGZpZWxkLmF0dHJpYnV0ZXMpXG4gICAgICBPYmplY3QuaGFzT3duKGZpZWxkLmF0dHJpYnV0ZXMsIGlkeCkgJiYgKGZpZWxkLmF0dHJpYnV0ZXNbaWR4XS52YWx1ZSA9IG9wdGltaXplVW5pb25zKGZpZWxkLmF0dHJpYnV0ZXNbaWR4XS52YWx1ZSkpO1xuICAgIHJldHVybiBmaWVsZDtcbiAgfVxuICByZXR1cm4gZmllbGQ7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2VUeXBlTm9kZShuYW1lLCBpbkFycmF5ID0gITEpIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICBfcmVmOiB7XG4gICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfVxuICAgIH0sXG4gICAgX3R5cGU6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogXCJyZWZlcmVuY2VcIlxuICAgICAgfVxuICAgIH0sXG4gICAgX3dlYWs6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIlxuICAgICAgfSxcbiAgICAgIG9wdGlvbmFsOiAhMFxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGluQXJyYXkgJiYgKGF0dHJpYnV0ZXMuX2tleSA9IHtcbiAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgfVxuICB9KSwge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgYXR0cmlidXRlcyxcbiAgICBkZXJlZmVyZW5jZXNUbzogbmFtZVxuICB9O1xufVxuZnVuY3Rpb24gbnVsbFVuaW9uKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ1bmlvblwiID8gdW5pb25PZiguLi5ub2RlLm9mLCB7IHR5cGU6IFwibnVsbFwiIH0pIDogdW5pb25PZihub2RlLCB7IHR5cGU6IFwibnVsbFwiIH0pO1xufVxuZnVuY3Rpb24gdW5pb25PZiguLi5ub2Rlcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvZjogbm9kZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVJbmxpbmUobm9kZSwgc2NvcGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJpbmxpbmVcIikge1xuICAgIGNvbnN0IHJlc29sdmVkSW5saW5lID0gc2NvcGUuY29udGV4dC5sb29rdXBUeXBlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgcmV0dXJuIHJlc29sdmVJbmxpbmUocmVzb2x2ZWRJbmxpbmUsIHNjb3BlKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG1hcE5vZGUobm9kZSwgc2NvcGUsIG1hcHBlciwgbWVyZ2VVbmlvbnMgPSAobm9kZXMpID0+IG9wdGltaXplVW5pb25zKHsgdHlwZTogXCJ1bmlvblwiLCBvZjogbm9kZXMgfSkpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgIGNhc2UgXCJudWxsXCI6XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiBtYXBwZXIobm9kZSk7XG4gICAgY2FzZSBcInVuaW9uXCI6XG4gICAgICByZXR1cm4gbWVyZ2VVbmlvbnMobm9kZS5vZi5tYXAoKGlubmVyKSA9PiBtYXBOb2RlKGlubmVyLCBzY29wZSwgbWFwcGVyKSwgbWVyZ2VVbmlvbnMpKTtcbiAgICBjYXNlIFwiaW5saW5lXCI6IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkSW5saW5lID0gcmVzb2x2ZUlubGluZShub2RlLCBzY29wZSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShyZXNvbHZlZElubGluZSwgc2NvcGUsIG1hcHBlciwgbWVyZ2VVbmlvbnMpO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGU6ICR7bm9kZS50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiBpc0Z1bmNDYWxsKG5vZGUsIG5hbWUpIHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJHcm91cFwiID8gaXNGdW5jQ2FsbChub2RlLmJhc2UsIG5hbWUpIDogbm9kZS50eXBlID09PSBcIkZ1bmNDYWxsXCIgJiYgYCR7bm9kZS5uYW1lc3BhY2V9Ojoke25vZGUubmFtZX1gID09PSBuYW1lO1xufVxuZnVuY3Rpb24gYm9vbGVhblZhbHVlKG5vZGUsIHNjb3BlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiB7IGNhbkJlVHJ1ZTogITAsIGNhbkJlRmFsc2U6ICEwLCBjYW5CZU51bGw6ICEwIH07XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBub2RlLnZhbHVlID09PSAhMCA/IHsgY2FuQmVUcnVlOiAhMCwgY2FuQmVGYWxzZTogITEsIGNhbkJlTnVsbDogITEgfSA6IG5vZGUudmFsdWUgPT09ICExID8geyBjYW5CZVRydWU6ICExLCBjYW5CZUZhbHNlOiAhMCwgY2FuQmVOdWxsOiAhMSB9IDogeyBjYW5CZVRydWU6ICEwLCBjYW5CZUZhbHNlOiAhMCwgY2FuQmVOdWxsOiAhMSB9O1xuICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHsgY2FuQmVUcnVlOiAhMSwgY2FuQmVGYWxzZTogITEsIGNhbkJlTnVsbDogITEgfTtcbiAgICAgIGZvciAoY29uc3Qgc3ViIG9mIG5vZGUub2YpIHtcbiAgICAgICAgY29uc3QgbWF0Y2gyID0gYm9vbGVhblZhbHVlKHN1Yiwgc2NvcGUpO1xuICAgICAgICBtYXRjaDIuY2FuQmVOdWxsICYmICh2YWx1ZS5jYW5CZU51bGwgPSAhMCksIG1hdGNoMi5jYW5CZVRydWUgJiYgKHZhbHVlLmNhbkJlVHJ1ZSA9ICEwKSwgbWF0Y2gyLmNhbkJlRmFsc2UgJiYgKHZhbHVlLmNhbkJlRmFsc2UgPSAhMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNhc2UgXCJpbmxpbmVcIjoge1xuICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlSW5saW5lKG5vZGUsIHNjb3BlKTtcbiAgICAgIHJldHVybiBib29sZWFuVmFsdWUocmVzb2x2ZWQsIHNjb3BlKTtcbiAgICB9XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJldHVybiB7IGNhbkJlVHJ1ZTogITEsIGNhbkJlRmFsc2U6ICExLCBjYW5CZU51bGw6ICEwIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBub2RlIHR5cGUgJHtub2RlLnR5cGV9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJvb2xlYW5PcihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gbGVmdC5jYW5CZVRydWUgJiYgIWxlZnQuY2FuQmVGYWxzZSAmJiAhbGVmdC5jYW5CZU51bGwgPyBsZWZ0IDogcmlnaHQuY2FuQmVUcnVlICYmICFyaWdodC5jYW5CZUZhbHNlICYmICFyaWdodC5jYW5CZU51bGwgPyByaWdodCA6IHtcbiAgICAvLyBFaXRoZXIgc2lkZSBjYW4gYmUgdHJ1ZSBmb3IgdGhlIGV4cHJlc3Npb24gdG8gYmUgdHJ1ZVxuICAgIGNhbkJlVHJ1ZTogbGVmdC5jYW5CZVRydWUgfHwgcmlnaHQuY2FuQmVUcnVlLFxuICAgIC8vIEJvdGggc2lkZXMgbXVzdCBiZSBmYWxzZSBmb3IgdGhlIGV4cHJlc3Npb24gdG8gYmUgZmFsc2VcbiAgICBjYW5CZUZhbHNlOiBsZWZ0LmNhbkJlRmFsc2UgJiYgcmlnaHQuY2FuQmVGYWxzZSxcbiAgICAvLyBpZiBlaXRoZXIgc2lkZSBjYW4gYmUgbnVsbCwgdGhlIGV4cHJlc3Npb24gY2FuIGJlIG51bGwgaWYgdGhlIG90aGVyIHNpZGUgY2FuJ3Qgb25seSBiZSB0cnVlXG4gICAgY2FuQmVOdWxsOiBsZWZ0LmNhbkJlTnVsbCB8fCByaWdodC5jYW5CZU51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGJvb2xlYW5BbmQobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIGxlZnQuY2FuQmVGYWxzZSAmJiAhbGVmdC5jYW5CZVRydWUgJiYgIWxlZnQuY2FuQmVOdWxsID8gbGVmdCA6IHJpZ2h0LmNhbkJlRmFsc2UgJiYgIXJpZ2h0LmNhbkJlVHJ1ZSAmJiAhcmlnaHQuY2FuQmVOdWxsID8gcmlnaHQgOiB7XG4gICAgLy8gQm90aCBzaWRlcyBtdXN0IGJlIHRydWUgZm9yIHRoZSBleHByZXNzaW9uIHRvIGJlIHRydWVcbiAgICBjYW5CZVRydWU6IGxlZnQuY2FuQmVUcnVlICYmIHJpZ2h0LmNhbkJlVHJ1ZSxcbiAgICAvLyBpZiBlaXRoZXIgc2lkZSBjYW4gYmUgZmFsc2UsIHRoZSBleHByZXNzaW9uIGNhbiBiZSBmYWxzZVxuICAgIGNhbkJlRmFsc2U6IGxlZnQuY2FuQmVGYWxzZSB8fCByaWdodC5jYW5CZUZhbHNlLFxuICAgIC8vIGlmIGVpdGhlciBzaWRlIGNhbiBiZSBudWxsLCB0aGUgZXhwcmVzc2lvbiBjYW4gYmUgbnVsbFxuICAgIGNhbkJlTnVsbDogbGVmdC5jYW5CZU51bGwgfHwgcmlnaHQuY2FuQmVOdWxsXG4gIH07XG59XG5mdW5jdGlvbiBib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlKGJvb2wpIHtcbiAgcmV0dXJuIGJvb2wuY2FuQmVUcnVlID8gYm9vbC5jYW5CZUZhbHNlID8gYm9vbC5jYW5CZU51bGwgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHsgdHlwZTogXCJib29sZWFuXCIgfSA6IGJvb2wuY2FuQmVOdWxsID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIsIHZhbHVlOiAhMCB9KSA6IHsgdHlwZTogXCJib29sZWFuXCIsIHZhbHVlOiAhMCB9IDogYm9vbC5jYW5CZUZhbHNlID8gYm9vbC5jYW5CZU51bGwgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6ICExIH0pIDogeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6ICExIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG59XG5jb25zdCAkdHJhY2UkMSA9IGRlYnVnKFwidHlwZUV2YWx1YXRvcjpzY29wZTp0cmFjZVwiKTtcbiR0cmFjZSQxLmxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5jbGFzcyBDb250ZXh0IHtcbiAgc2NoZW1hO1xuICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgfVxuICBsb29rdXBSZWYocmVmVG8pIHtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLnNjaGVtYSlcbiAgICAgIGlmICh2YWwudHlwZSA9PT0gXCJkb2N1bWVudFwiICYmIHZhbC5uYW1lID09PSByZWZUbylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHZhbC5hdHRyaWJ1dGVzXG4gICAgICAgIH07XG4gICAgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIgfTtcbiAgfVxuICBsb29rdXBUeXBlRGVjbGFyYXRpb24oYWxpYXMpIHtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLnNjaGVtYSlcbiAgICAgIGlmICh2YWwudHlwZSA9PT0gXCJ0eXBlXCIgJiYgdmFsLm5hbWUgPT09IGFsaWFzLm5hbWUpXG4gICAgICAgIHJldHVybiB2YWwudmFsdWU7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIgfTtcbiAgfVxufVxuY2xhc3MgU2NvcGUyIHtcbiAgdmFsdWU7XG4gIHBhcmVudDtcbiAgY29udGV4dDtcbiAgaXNIaWRkZW47XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBwYXJlbnQsIGNvbnRleHQpIHtcbiAgICB0aGlzLnZhbHVlID0geyB0eXBlOiBcInVuaW9uXCIsIG9mOiB2YWx1ZSB9LCB0aGlzLnBhcmVudCA9IHBhcmVudCwgdGhpcy5jb250ZXh0ID0gY29udGV4dCB8fCBwYXJlbnQ/LmNvbnRleHQgfHwgbmV3IENvbnRleHQoW10pLCB0aGlzLmlzSGlkZGVuID0gITE7XG4gIH1cbiAgY3JlYXRlTmVzdGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNIaWRkZW4gPyBuZXcgU2NvcGUyKHZhbHVlLCB0aGlzLnBhcmVudCwgdGhpcy5jb250ZXh0KSA6IG5ldyBTY29wZTIodmFsdWUsIHRoaXMsIHRoaXMuY29udGV4dCk7XG4gIH1cbiAgY3JlYXRlSGlkZGVuKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuaXNIaWRkZW4gPSAhMCwgcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiB1bmlvbldpdGhvdXROdWxsKHVuaW9uVHlwZU5vZGUpIHtcbiAgcmV0dXJuIHVuaW9uVHlwZU5vZGUudHlwZSA9PT0gXCJ1bmlvblwiID8ge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvZjogdW5pb25UeXBlTm9kZS5vZi5maWx0ZXIoKHR5cGUpID0+IHR5cGUudHlwZSAhPT0gXCJudWxsXCIpXG4gIH0gOiB1bmlvblR5cGVOb2RlO1xufVxuZnVuY3Rpb24gaGFuZGxlRnVuY0NhbGxOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIHN3aXRjaCAoYCR7bm9kZS5uYW1lc3BhY2V9LiR7bm9kZS5uYW1lfWApIHtcbiAgICBjYXNlIFwiYXJyYXkuY29tcGFjdFwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiB7XG4gICAgICAgIGlmIChhcmcyLnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgICAgIHJldHVybiBudWxsVW5pb24oeyB0eXBlOiBcImFycmF5XCIsIG9mOiB7IHR5cGU6IFwidW5rbm93blwiIH0gfSk7XG4gICAgICAgIGlmIChhcmcyLnR5cGUgIT09IFwiYXJyYXlcIilcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICBjb25zdCBvZiA9IG1hcE5vZGUoYXJnMi5vZiwgc2NvcGUsIChvZjIpID0+IG9mMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIG9mOiB1bmlvbldpdGhvdXROdWxsKG9mKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJhcnJheS5qb2luXCI6IHtcbiAgICAgIGNvbnN0IGFycmF5QXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSksIHNlcEFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoXG4gICAgICAgIGFycmF5QXJnLFxuICAgICAgICBzY29wZSxcbiAgICAgICAgKGFycmF5QXJnMikgPT4gbWFwTm9kZShzZXBBcmcsIHNjb3BlLCAoc2VwQXJnMikgPT4gYXJyYXlBcmcyLnR5cGUgPT09IFwidW5rbm93blwiIHx8IHNlcEFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJyYXlBcmcyLnR5cGUgIT09IFwiYXJyYXlcIiB8fCBzZXBBcmcyLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKGFycmF5QXJnMi5vZiwgc2NvcGUsIChvZikgPT4gb2YudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogb2YudHlwZSAhPT0gXCJzdHJpbmdcIiAmJiBvZi50eXBlICE9PSBcIm51bWJlclwiICYmIG9mLnR5cGUgIT09IFwiYm9vbGVhblwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcInN0cmluZ1wiIH0pKVxuICAgICAgKTtcbiAgICB9XG4gICAgY2FzZSBcImFycmF5LnVuaXF1ZVwiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChhcmcyKSA9PiBhcmcyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJhcnJheVwiLCBvZjogeyB0eXBlOiBcInVua25vd25cIiB9IH0pIDogYXJnMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBhcmcyKTtcbiAgICB9XG4gICAgY2FzZSBcImFycmF5LmludGVyc2VjdHNcIjoge1xuICAgICAgY29uc3QgYXJnMSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pLCBhcmcyID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1sxXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShcbiAgICAgICAgYXJnMSxcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIChhcmcxMikgPT4gbWFwTm9kZShhcmcyLCBzY29wZSwgKGFyZzIyKSA9PiBhcmcxMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBhcmcyMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmxvd2VyXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYXJnMi52YWx1ZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogYXJnMi52YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgICB9IDogeyB0eXBlOiBcInN0cmluZ1wiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLnVwcGVyXCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlICE9PSBcInN0cmluZ1wiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYXJnMi52YWx1ZSAhPT0gdm9pZCAwID8ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogYXJnMi52YWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgICB9IDogeyB0eXBlOiBcInN0cmluZ1wiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZGF0ZVRpbWUubm93XCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInN0cmluZ1wiIH07XG4gICAgY2FzZSBcImdsb2JhbC5ub3dcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIgfTtcbiAgICBjYXNlIFwiZ2xvYmFsLmRlZmluZWRcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAobm9kZTIpID0+IG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8geyB0eXBlOiBcImJvb2xlYW5cIiB9IDogeyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6IG5vZGUyLnR5cGUgIT09IFwibnVsbFwiIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLnBhdGhcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwic3RyaW5nXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwuY29hbGVzY2VcIjoge1xuICAgICAgaWYgKG5vZGUuYXJncy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICBjb25zdCB0eXBlTm9kZXMgPSBbXTtcbiAgICAgIGxldCBjYW5CZU51bGwgPSAhMDtcbiAgICAgIGZvciAoY29uc3QgYXJnIG9mIG5vZGUuYXJncykge1xuICAgICAgICBjb25zdCBhcmdOb2RlID0gb3B0aW1pemVVbmlvbnMod2Fsayh7IG5vZGU6IGFyZywgc2NvcGUgfSkpLCBhbGxOdWxsID0gYXJnTm9kZS50eXBlID09PSBcIm51bGxcIiB8fCBhcmdOb2RlLnR5cGUgPT09IFwidW5pb25cIiAmJiBhcmdOb2RlLm9mLmV2ZXJ5KCh0KSA9PiB0LnR5cGUgPT09IFwibnVsbFwiKTtcbiAgICAgICAgaWYgKGNhbkJlTnVsbCA9IGFsbE51bGwgfHwgYXJnTm9kZS50eXBlID09PSBcInVua25vd25cIiB8fCBhcmdOb2RlLnR5cGUgPT09IFwidW5pb25cIiAmJiBhcmdOb2RlLm9mLnNvbWUoKHQpID0+IHQudHlwZSA9PT0gXCJudWxsXCIgfHwgdC50eXBlID09PSBcInVua25vd25cIiksIGFsbE51bGwgfHwgdHlwZU5vZGVzLnB1c2godW5pb25XaXRob3V0TnVsbChhcmdOb2RlKSksICFjYW5CZU51bGwpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuQmVOdWxsICYmIHR5cGVOb2Rlcy5wdXNoKHsgdHlwZTogXCJudWxsXCIgfSksIHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvZjogdHlwZU5vZGVzXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLmNvdW50XCI6IHtcbiAgICAgIGNvbnN0IGFyZyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoYXJnLCBzY29wZSwgKGFyZzIpID0+IGFyZzIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogYXJnMi50eXBlID09PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVtYmVyXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwuZGF0ZVRpbWVcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwic3RyaW5nXCIgfSkgOiBhcmcyLnR5cGUgPT09IFwic3RyaW5nXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcImdsb2JhbC5sZW5ndGhcIjoge1xuICAgICAgY29uc3QgYXJnID0gd2Fsayh7IG5vZGU6IG5vZGUuYXJnc1swXSwgc2NvcGUgfSk7XG4gICAgICByZXR1cm4gbWFwTm9kZShhcmcsIHNjb3BlLCAoYXJnMikgPT4gYXJnMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBhcmcyLnR5cGUgPT09IFwiYXJyYXlcIiB8fCBhcmcyLnR5cGUgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVtYmVyXCIgfSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG4gICAgfVxuICAgIGNhc2UgXCJnbG9iYWwucmVmZXJlbmNlc1wiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJib29sZWFuXCIgfTtcbiAgICBjYXNlIFwiZ2xvYmFsLnJvdW5kXCI6IHtcbiAgICAgIGNvbnN0IG51bU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKG51bU5vZGUsIHNjb3BlLCAobnVtKSA9PiB7XG4gICAgICAgIGlmIChudW0udHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgcmV0dXJuIG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSk7XG4gICAgICAgIGlmIChudW0udHlwZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICBpZiAobm9kZS5hcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGNvbnN0IHByZWNpc2lvbk5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzFdLCBzY29wZSB9KTtcbiAgICAgICAgICByZXR1cm4gbWFwTm9kZShwcmVjaXNpb25Ob2RlLCBzY29wZSwgKHByZWNpc2lvbikgPT4gcHJlY2lzaW9uLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IHByZWNpc2lvbi50eXBlICE9PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogeyB0eXBlOiBcIm51bWJlclwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibnVtYmVyXCIgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYXNlIFwiZ2xvYmFsLnN0cmluZ1wiOiB7XG4gICAgICBjb25zdCBhcmcgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKGFyZywgc2NvcGUsIChub2RlMikgPT4gbm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcInN0cmluZ1wiIH0pIDogbm9kZTIudHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBub2RlMi50eXBlID09PSBcIm51bWJlclwiIHx8IG5vZGUyLnR5cGUgPT09IFwiYm9vbGVhblwiID8gbm9kZTIudmFsdWUgPyB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIHZhbHVlOiBub2RlMi52YWx1ZS50b1N0cmluZygpXG4gICAgICB9IDoge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbiAgICB9XG4gICAgY2FzZSBcIm1hdGguc3VtXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodmFsdWVzLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKG5vZGUyLm9mLCBzY29wZSwgKG5vZGUzKSA9PiBub2RlMy50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMy50eXBlID09PSBcIm51bWJlclwiIHx8IG5vZGUzLnR5cGUgPT09IFwibnVsbFwiID8geyB0eXBlOiBcIm51bWJlclwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcIm1hdGguYXZnXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodmFsdWVzLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKG5vZGUyLm9mLCBzY29wZSwgKG5vZGUzKSA9PiBub2RlMy50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMy50eXBlID09PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bWJlclwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcIm1hdGgubWF4XCI6XG4gICAgY2FzZSBcIm1hdGgubWluXCI6IHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUodmFsdWVzLCBzY29wZSwgKG5vZGUyKSA9PiBub2RlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMi50eXBlICE9PSBcImFycmF5XCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBtYXBOb2RlKG5vZGUyLm9mLCBzY29wZSwgKG5vZGUzKSA9PiBub2RlMy50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBub2RlMy50eXBlID09PSBcIm51bWJlclwiID8gbm9kZTMgOiB7IHR5cGU6IFwibnVsbFwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcInB0LnRleHRcIjpcbiAgICAgIHJldHVybiBub2RlLmFyZ3MubGVuZ3RoID09PSAwID8geyB0eXBlOiBcIm51bGxcIiB9IDoge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9O1xuICAgIGNhc2UgXCJzdHJpbmcuc3RhcnRzV2l0aFwiOiB7XG4gICAgICBjb25zdCBzdHJUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pLCBwcmVmaXhUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoc3RyVHlwZU5vZGUsIHNjb3BlLCAoc3RyTm9kZSkgPT4gbWFwTm9kZShwcmVmaXhUeXBlTm9kZSwgc2NvcGUsIChwcmVmaXhOb2RlKSA9PiBzdHJOb2RlLnR5cGUgPT09IFwidW5rbm93blwiIHx8IHByZWZpeE5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHN0ck5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiB8fCBwcmVmaXhOb2RlLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0pKTtcbiAgICB9XG4gICAgY2FzZSBcInN0cmluZy5zcGxpdFwiOiB7XG4gICAgICBjb25zdCBzdHJUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMF0sIHNjb3BlIH0pLCBzZXBUeXBlTm9kZSA9IHdhbGsoeyBub2RlOiBub2RlLmFyZ3NbMV0sIHNjb3BlIH0pO1xuICAgICAgcmV0dXJuIG1hcE5vZGUoc3RyVHlwZU5vZGUsIHNjb3BlLCAoc3RyTm9kZSkgPT4gbWFwTm9kZShzZXBUeXBlTm9kZSwgc2NvcGUsIChzZXBOb2RlKSA9PiBzdHJOb2RlLnR5cGUgPT09IFwidW5rbm93blwiIHx8IHNlcE5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImFycmF5XCIsIG9mOiB7IHR5cGU6IFwic3RyaW5nXCIgfSB9KSA6IHN0ck5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIiB8fCBzZXBOb2RlLnR5cGUgIT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiB7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0pKTtcbiAgICB9XG4gICAgY2FzZSBcInNhbml0eS52ZXJzaW9uT2ZcIjoge1xuICAgICAgY29uc3QgdHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKHR5cGVOb2RlLCBzY29wZSwgKHR5cGVOb2RlMikgPT4gdHlwZU5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJhcnJheVwiLCBvZjogeyB0eXBlOiBcInN0cmluZ1wiIH0gfSkgOiB0eXBlTm9kZTIudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJhcnJheVwiLCBvZjogeyB0eXBlOiBcInN0cmluZ1wiIH0gfSk7XG4gICAgfVxuICAgIGNhc2UgXCJzYW5pdHkuZG9jdW1lbnRzT2ZcIjoge1xuICAgICAgY29uc3QgdHlwZU5vZGUgPSB3YWxrKHsgbm9kZTogbm9kZS5hcmdzWzBdLCBzY29wZSB9KTtcbiAgICAgIHJldHVybiBtYXBOb2RlKHR5cGVOb2RlLCBzY29wZSwgKHR5cGVOb2RlMikgPT4gdHlwZU5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJhcnJheVwiLCBvZjogeyB0eXBlOiBcInN0cmluZ1wiIH0gfSkgOiB0eXBlTm9kZTIudHlwZSAhPT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHsgdHlwZTogXCJhcnJheVwiLCBvZjogeyB0eXBlOiBcInN0cmluZ1wiIH0gfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICB9XG59XG5mdW5jdGlvbiBtYXRjaChsZWZ0LCByaWdodCkge1xuICBsZXQgdG9rZW5zID0gW10sIHBhdHRlcm5zID0gW107XG4gIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobGVmdC52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShsZWZ0LnZhbHVlKSk7XG4gIH1cbiAgaWYgKGxlZnQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKGxlZnQub2YudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGxlZnQub2YudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGxlZnQub2YudmFsdWUgPT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKGxlZnQub2YudmFsdWUpKTtcbiAgICB9XG4gICAgaWYgKGxlZnQub2YudHlwZSA9PT0gXCJ1bmlvblwiKVxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIGxlZnQub2Yub2YpXG4gICAgICAgIG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBub2RlLnZhbHVlICE9PSB2b2lkIDAgJiYgKHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShub2RlLnZhbHVlKSkpO1xuICB9XG4gIGlmIChyaWdodC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHJpZ2h0LnZhbHVlID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihyaWdodC52YWx1ZSkpO1xuICB9XG4gIGlmIChyaWdodC50eXBlID09PSBcImFycmF5XCIpIHtcbiAgICBpZiAocmlnaHQub2YudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHJpZ2h0Lm9mLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChyaWdodC5vZi52YWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBwYXR0ZXJucyA9IHBhdHRlcm5zLmNvbmNhdChtYXRjaEFuYWx5emVQYXR0ZXJuKHJpZ2h0Lm9mLnZhbHVlKSk7XG4gICAgfVxuICAgIGlmIChyaWdodC5vZi50eXBlID09PSBcInVuaW9uXCIpXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgcmlnaHQub2Yub2YpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChub2RlLnZhbHVlID09PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihub2RlLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKTtcbn1cbmNvbnN0ICR0cmFjZSA9IGRlYnVnKFwidHlwZUV2YWx1YXRvcjpldmFsdWF0ZTp0cmFjZVwiKTtcbiR0cmFjZS5sb2cgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuY29uc3QgJGRlYnVnID0gZGVidWcoXCJ0eXBlRXZhbHVhdG9yOmV2YWx1YXRlOmRlYnVnXCIpO1xuJGRlYnVnLmxvZyA9IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5jb25zdCAkd2FybiA9IGRlYnVnKFwidHlwZUV2YWx1YXRvcjpldmFsdWF0ZTp3YXJuXCIpO1xuZnVuY3Rpb24gdHlwZUV2YWx1YXRlKGFzdCwgc2NoZW1hKSB7XG4gICRkZWJ1ZyhcImV2YWx1YXRlUXVlcnlUeXBlLmFzdCAlT1wiLCBhc3QpLCAkZGVidWcoXCJldmFsdWF0ZVF1ZXJ5VHlwZS5zY2hlbWEgJU9cIiwgc2NoZW1hKTtcbiAgY29uc3QgcGFyc2VkID0gd2Fsayh7XG4gICAgbm9kZTogYXN0LFxuICAgIHNjb3BlOiBuZXcgU2NvcGUyKFtdLCB2b2lkIDAsIG5ldyBDb250ZXh0KHNjaGVtYSkpXG4gIH0pO1xuICAkdHJhY2UoXCJldmFsdWF0ZVF1ZXJ5VHlwZS5wYXJzZWQgJU9cIiwgcGFyc2VkKTtcbiAgY29uc3Qgb3B0aW1pemVkID0gb3B0aW1pemVVbmlvbnMocGFyc2VkKTtcbiAgcmV0dXJuICRkZWJ1ZyhcImV2YWx1YXRlUXVlcnlUeXBlLm9wdGltaXplZCAlT1wiLCBvcHRpbWl6ZWQpLCBvcHRpbWl6ZWQ7XG59XG5mdW5jdGlvbiBtYXBEZXJlZihiYXNlLCBzY29wZSkge1xuICByZXR1cm4gYmFzZS50eXBlID09PSBcInVuaW9uXCIgPyB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiBiYXNlLm9mLm1hcCgobm9kZSkgPT4gbWFwRGVyZWYobm9kZSwgc2NvcGUpKVxuICB9IDogYmFzZS50eXBlID09PSBcImFycmF5XCIgPyB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG9mOiBtYXBEZXJlZihiYXNlLm9mLCBzY29wZSlcbiAgfSA6IGJhc2UudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBiYXNlLmRlcmVmZXJlbmNlc1RvICE9PSB2b2lkIDAgPyBzY29wZS5jb250ZXh0Lmxvb2t1cFJlZihiYXNlLmRlcmVmZXJlbmNlc1RvKSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZURlcmVmTm9kZShub2RlLCBzY29wZSkge1xuICAkdHJhY2UoXCJkZXJlZi5ub2RlICVPXCIsIG5vZGUpO1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIGlmICgkdHJhY2UoXCJkZXJlZi5iYXNlICVPXCIsIGJhc2UpLCBiYXNlLnR5cGUgPT09IFwibnVsbFwiIHx8IGJhc2UudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIgfTtcbiAgY29uc3QgZGVyZWZlZE5vZGUgPSBtYXBEZXJlZihiYXNlLCBzY29wZSk7XG4gIHJldHVybiAkdHJhY2UoXCJkZXJlZi5kZXJlZmVkTm9kZSAlT1wiLCBkZXJlZmVkTm9kZSksIGRlcmVmZWROb2RlO1xufVxuZnVuY3Rpb24gaGFuZGxlT2JqZWN0U3BsYXROb2RlKGF0dHIsIHNjb3BlKSB7XG4gIGNvbnN0IHZhbHVlID0gd2Fsayh7IG5vZGU6IGF0dHIudmFsdWUsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwib2JqZWN0LnNwbGF0LnZhbHVlICVPXCIsIHZhbHVlKSwgbWFwTm9kZSh2YWx1ZSwgc2NvcGUsIChub2RlKSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4geyB0eXBlOiBcIm9iamVjdFwiLCBhdHRyaWJ1dGVzOiB7fSB9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZS5hdHRyaWJ1dGVzKVxuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIChhdHRyaWJ1dGVzW25hbWVdID0gbm9kZS5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICBpZiAobm9kZS5yZXN0ICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkUmVzdCA9IHJlc29sdmVJbmxpbmUobm9kZS5yZXN0LCBzY29wZSk7XG4gICAgICBpZiAocmVzb2x2ZWRSZXN0LnR5cGUgPT09IFwidW5rbm93blwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgaWYgKHJlc29sdmVkUmVzdC50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHJlc29sdmVkUmVzdC5hdHRyaWJ1dGVzKVxuICAgICAgICByZXNvbHZlZFJlc3QuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAoYXR0cmlidXRlc1tuYW1lXSA9IHJlc29sdmVkUmVzdC5hdHRyaWJ1dGVzW25hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJvYmplY3RcIiwgYXR0cmlidXRlcyB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9iamVjdE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgaWYgKCR0cmFjZShcIm9iamVjdC5ub2RlICVPXCIsIG5vZGUpLCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlczoge31cbiAgICB9O1xuICBjb25zdCBvYmplY3RBdHRyaWJ1dGVzID0gW10sIHNwbGF0VmFyaWFudHMgPSBbXSwgY29uZGl0aW9uYWxWYXJpYW50cyA9IFtdO1xuICBmb3IgKGNvbnN0IFtpZHgsIGF0dHJdIG9mIG5vZGUuYXR0cmlidXRlcy5lbnRyaWVzKCkpIHtcbiAgICBpZiAoYXR0ci50eXBlID09PSBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5vZGUgPSB3YWxrKHsgbm9kZTogYXR0ci52YWx1ZSwgc2NvcGUgfSk7XG4gICAgICBvYmplY3RBdHRyaWJ1dGVzLnB1c2goW1xuICAgICAgICBpZHgsXG4gICAgICAgIGF0dHIubmFtZSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICAgICAgdmFsdWU6IGF0dHJpYnV0ZU5vZGVcbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGF0dHIudHlwZSA9PT0gXCJPYmplY3RTcGxhdFwiKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOb2RlID0gaGFuZGxlT2JqZWN0U3BsYXROb2RlKGF0dHIsIHNjb3BlKTtcbiAgICAgIHN3aXRjaCAoJHRyYWNlKFwib2JqZWN0LnNwbGF0LnJlc3VsdCAlT1wiLCBhdHRyaWJ1dGVOb2RlKSwgYXR0cmlidXRlTm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgIHNwbGF0VmFyaWFudHMucHVzaChbaWR4LCBhdHRyaWJ1dGVOb2RlXSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaW9uXCI6IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIGF0dHJpYnV0ZU5vZGUub2YpXG4gICAgICAgICAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJ1bmtub3duXCIpXG4gICAgICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHIudHlwZSA9PT0gXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGJvb2xlYW5WYWx1ZSh3YWxrKHsgbm9kZTogYXR0ci5jb25kaXRpb24sIHNjb3BlIH0pLCBzY29wZSk7XG4gICAgICBpZiAoJHRyYWNlKFwib2JqZWN0LmNvbmRpdGlvbmFsLnNwbGF0LmNvbmRpdGlvbiAlT1wiLCBjb25kaXRpb24pLCBjb25kaXRpb24uY2FuQmVUcnVlID09PSAhMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOb2RlID0gaGFuZGxlT2JqZWN0U3BsYXROb2RlKGF0dHIsIHNjb3BlKTtcbiAgICAgIGlmICgkdHJhY2UoXCJvYmplY3QuY29uZGl0aW9uYWwuc3BsYXQucmVzdWx0ICVPXCIsIGF0dHJpYnV0ZU5vZGUpLCBjb25kaXRpb24uY2FuQmVGYWxzZSA9PT0gITEgJiYgY29uZGl0aW9uLmNhbkJlTnVsbCA9PT0gITEpXG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlTm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ1bmlvblwiOiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIGF0dHJpYnV0ZU5vZGUub2YpXG4gICAgICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgICAgICAgICBzcGxhdFZhcmlhbnRzLnB1c2goW2lkeCwgYXR0cmlidXRlTm9kZV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgICB9XG4gICAgICBjb25zdCB2YXJpYW50ID0gbWFwTm9kZShhdHRyaWJ1dGVOb2RlLCBzY29wZSwgKGF0dHJpYnV0ZU5vZGUyKSA9PiAoJHRyYWNlKFwib2JqZWN0LmNvbmRpdGlvbmFsLnNwbGF0LnJlc3VsdC5jb25jcmV0ZSAlT1wiLCBhdHRyaWJ1dGVOb2RlMiksIGF0dHJpYnV0ZU5vZGUyLnR5cGUgIT09IFwib2JqZWN0XCIgPyB7IHR5cGU6IFwidW5rbm93blwiIH0gOiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZU5vZGUyLmF0dHJpYnV0ZXNcbiAgICAgIH0pKTtcbiAgICAgIGlmICh2YXJpYW50LnR5cGUgPT09IFwidW5pb25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIHZhcmlhbnQub2YpXG4gICAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgICB2YXJpYW50Lm9mLnB1c2goeyB0eXBlOiBcIm9iamVjdFwiLCBhdHRyaWJ1dGVzOiB7fSB9KSwgY29uZGl0aW9uYWxWYXJpYW50cy5wdXNoKFtpZHgsIHZhcmlhbnRdKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodmFyaWFudC50eXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICAgICAgY29uZGl0aW9uYWxWYXJpYW50cy5wdXNoKFtcbiAgICAgICAgaWR4LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICAgIG9mOiBbeyB0eXBlOiBcIm9iamVjdFwiLCBhdHRyaWJ1dGVzOiB7fSB9LCB2YXJpYW50XVxuICAgICAgICB9XG4gICAgICBdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb2JqZWN0IGF0dHJpYnV0ZSB0eXBlOiAke2F0dHIudHlwZX1gKTtcbiAgfVxuICBjb25zdCBndWFyYW50ZWVkQXR0cmlidXRlcyA9IFtdO1xuICBndWFyYW50ZWVkQXR0cmlidXRlcy5wdXNoKC4uLm9iamVjdEF0dHJpYnV0ZXMpO1xuICBmb3IgKGNvbnN0IFtpZHgsIHNwbGF0Tm9kZV0gb2Ygc3BsYXRWYXJpYW50cykge1xuICAgIGlmIChzcGxhdE5vZGUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHNwbGF0Tm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghc3BsYXROb2RlLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHNwbGF0Tm9kZS5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBndWFyYW50ZWVkQXR0cmlidXRlcy5wdXNoKFtpZHgsIG5hbWUsIGF0dHJpYnV0ZV0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbmRpdGlvbmFsVmFyaWFudHMucHVzaChbaWR4LCBzcGxhdE5vZGVdKTtcbiAgfVxuICBpZiAoZ3VhcmFudGVlZEF0dHJpYnV0ZXMuc29ydCgoW2FdLCBbYl0pID0+IGEgLSBiKSwgY29uZGl0aW9uYWxWYXJpYW50cy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIGd1YXJhbnRlZWRBdHRyaWJ1dGVzLm1hcCgoWywgbmFtZSwgYXR0cmlidXRlXSkgPT4gW25hbWUsIGF0dHJpYnV0ZV0pXG4gICAgICApXG4gICAgfTtcbiAgY29uc3QgbWF0cml4ID0gW107XG4gIGZvciAoY29uc3QgW3VuaW9uSWR4LCB1bmlvbl0gb2YgY29uZGl0aW9uYWxWYXJpYW50cykge1xuICAgIGNvbnN0IHVuaW9uR3VhcmFudGVlZEJlZm9yZSA9IFtdLCB1bmlvbkd1YXJhbnRlZWRBZnRlciA9IFtdO1xuICAgIGZvciAoY29uc3QgW2d1YXJhbnRlZWRJbmRleCwgbmFtZSwgYXR0cmlidXRlXSBvZiBndWFyYW50ZWVkQXR0cmlidXRlcylcbiAgICAgIGd1YXJhbnRlZWRJbmRleCA8IHVuaW9uSWR4ICYmIHVuaW9uR3VhcmFudGVlZEJlZm9yZS5wdXNoKFtndWFyYW50ZWVkSW5kZXgsIG5hbWUsIGF0dHJpYnV0ZV0pLCBndWFyYW50ZWVkSW5kZXggPiB1bmlvbklkeCAmJiB1bmlvbkd1YXJhbnRlZWRBZnRlci5wdXNoKFtndWFyYW50ZWVkSW5kZXgsIG5hbWUsIGF0dHJpYnV0ZV0pO1xuICAgIGNvbnN0IGFsbFZhcmlhbnRzQXR0cmlidXRlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2NvbmRpdGlvbmFsVmFyaWFudElkeCwgb3RoZXJVbmlvbl0gb2YgY29uZGl0aW9uYWxWYXJpYW50cykge1xuICAgICAgY29uc3QgdmFyaWFudEF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgbm9kZTIgb2Ygb3RoZXJVbmlvbi5vZilcbiAgICAgICAgdmFyaWFudEF0dHJpYnV0ZXMucHVzaChub2RlMi5hdHRyaWJ1dGVzKTtcbiAgICAgIGFsbFZhcmlhbnRzQXR0cmlidXRlcy5wdXNoKFtjb25kaXRpb25hbFZhcmlhbnRJZHgsIHZhcmlhbnRBdHRyaWJ1dGVzXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgbm9kZTIgb2YgdW5pb24ub2YpIHtcbiAgICAgIG1hdHJpeC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLk9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgIHVuaW9uR3VhcmFudGVlZEJlZm9yZS5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgICAgICksXG4gICAgICAgICAgLi4ubm9kZTIuYXR0cmlidXRlcyxcbiAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICB1bmlvbkd1YXJhbnRlZWRBZnRlci5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IFtvdXRlcklkeCwgb3V0ZXJBdHRyaWJ1dGVzXSBvZiBhbGxWYXJpYW50c0F0dHJpYnV0ZXMpXG4gICAgICAgIGZvciAoY29uc3Qgb3V0ZXIgb2Ygb3V0ZXJBdHRyaWJ1dGVzKVxuICAgICAgICAgIGZvciAoY29uc3QgW2lubmVySWR4LCBpbm5lckF0dHJpYnV0ZXNdIG9mIGFsbFZhcmlhbnRzQXR0cmlidXRlcylcbiAgICAgICAgICAgIGlmIChvdXRlcklkeCAhPT0gaW5uZXJJZHgpXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaW5uZXIgb2YgaW5uZXJBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2JlZm9yZSA9IFsuLi51bmlvbkd1YXJhbnRlZWRCZWZvcmVdLCBfYWZ0ZXIgPSBbLi4udW5pb25HdWFyYW50ZWVkQWZ0ZXJdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvdXRlcilcbiAgICAgICAgICAgICAgICAgIG91dGVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIG91dGVySWR4ICE9PSB1bmlvbklkeCAmJiAob3V0ZXJJZHggPCB1bmlvbklkeCAmJiBfYmVmb3JlLnB1c2goW291dGVySWR4LCBuYW1lLCBvdXRlcltuYW1lXV0pLCBvdXRlcklkeCA+IHVuaW9uSWR4ICYmIF9hZnRlci5wdXNoKFtvdXRlcklkeCwgbmFtZSwgb3V0ZXJbbmFtZV1dKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGlubmVyKVxuICAgICAgICAgICAgICAgICAgaW5uZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgb3V0ZXJJZHggIT09IHVuaW9uSWR4ICYmIChpbm5lcklkeCA8IHVuaW9uSWR4ICYmIF9iZWZvcmUucHVzaChbaW5uZXJJZHgsIG5hbWUsIGlubmVyW25hbWVdXSksIGlubmVySWR4ID4gdW5pb25JZHggJiYgX2FmdGVyLnB1c2goW2lubmVySWR4LCBuYW1lLCBpbm5lcltuYW1lXV0pKTtcbiAgICAgICAgICAgICAgICBfYmVmb3JlLnNvcnQoKFthXSwgW2JdKSA9PiBhIC0gYiksIF9hZnRlci5zb3J0KChbYV0sIFtiXSkgPT4gYSAtIGIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgIF9iZWZvcmUubWFwKChbLCBuYW1lLCBhdHRyaWJ1dGVdKSA9PiBbbmFtZSwgYXR0cmlidXRlXSlcbiAgICAgICAgICAgICAgICApLCBhZnRlciA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgIF9hZnRlci5tYXAoKFssIG5hbWUsIGF0dHJpYnV0ZV0pID0+IFtuYW1lLCBhdHRyaWJ1dGVdKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbWF0cml4LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYmVmb3JlLFxuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlMi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAuLi5hZnRlclxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpbWl6ZVVuaW9ucyh7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiBtYXRyaXhcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVPcENhbGxOb2RlKG5vZGUsIHNjb3BlKSB7XG4gICR0cmFjZShcIm9wY2FsbC5ub2RlICVPXCIsIG5vZGUpO1xuICBjb25zdCBsaHMgPSB3YWxrKHsgbm9kZTogbm9kZS5sZWZ0LCBzY29wZSB9KSwgcmhzID0gd2Fsayh7IG5vZGU6IG5vZGUucmlnaHQsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShcbiAgICBsaHMsXG4gICAgc2NvcGUsXG4gICAgKGxlZnQpID0+IChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50c1xuICAgICAgbWFwTm9kZShyaHMsIHNjb3BlLCAocmlnaHQpID0+IHtcbiAgICAgICAgc3dpdGNoICgkdHJhY2UoJ29wY2FsbC5ub2RlLmNvbmNyZXRlIFwiJXNcIiAlTycsIG5vZGUub3AsIHsgbGVmdCwgcmlnaHQgfSksIG5vZGUub3ApIHtcbiAgICAgICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8geyB0eXBlOiBcImJvb2xlYW5cIiB9IDogbGVmdC50eXBlICE9PSByaWdodC50eXBlID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgICAgICB9IDogbGVmdC50eXBlID09PSBcIm51bGxcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMFxuICAgICAgICAgICAgfSA6ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKGxlZnQpIHx8ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKHJpZ2h0KSA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBldmFsdWF0ZUNvbXBhcmlzb24obm9kZS5vcCwgbGVmdCwgcmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgXCIhPVwiOiB7XG4gICAgICAgICAgICBpZiAobGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIilcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJib29sZWFuXCIgfTtcbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgIT09IHJpZ2h0LnR5cGUpXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobGVmdC50eXBlID09PSBcIm51bGxcIilcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogITFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghaXNQcmltaXRpdmVUeXBlTm9kZShsZWZ0KSB8fCAhaXNQcmltaXRpdmVUeXBlTm9kZShyaWdodCkpXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICEwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBldmFsdWF0ZUNvbXBhcmlzb24oXCI9PVwiLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCAmJiAodmFsdWUgPSAhdmFsdWUpLCB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IGxlZnQudHlwZSAhPT0gcmlnaHQudHlwZSA/IHsgdHlwZTogXCJudWxsXCIgfSA6ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKGxlZnQpIHx8ICFpc1ByaW1pdGl2ZVR5cGVOb2RlKHJpZ2h0KSA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBldmFsdWF0ZUNvbXBhcmlzb24obm9kZS5vcCwgbGVmdCwgcmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgXCJpblwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcImJvb2xlYW5cIiB9KSA6IHJpZ2h0LnR5cGUgIT09IFwiYXJyYXlcIiA/IGlzRnVuY0NhbGwobm9kZS5yaWdodCwgXCJnbG9iYWw6OnBhdGhcIikgPyB7IHR5cGU6IFwiYm9vbGVhblwiIH0gOiB7IHR5cGU6IFwibnVsbFwiIH0gOiAhaXNQcmltaXRpdmVUeXBlTm9kZShsZWZ0KSAmJiBsZWZ0LnR5cGUgIT09IFwibnVsbFwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6ICExXG4gICAgICAgICAgICB9IDogbWFwTm9kZShyaWdodC5vZiwgc2NvcGUsIChhcnJheVR5cGVOb2RlKSA9PiBhcnJheVR5cGVOb2RlLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJib29sZWFuXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVsbFwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgdmFsdWU6IGFycmF5VHlwZU5vZGUudHlwZSA9PT0gXCJudWxsXCJcbiAgICAgICAgICAgIH0gOiBsZWZ0LnZhbHVlID09PSB2b2lkIDAgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICB9IDogaXNQcmltaXRpdmVUeXBlTm9kZShhcnJheVR5cGVOb2RlKSA/IGFycmF5VHlwZU5vZGUudmFsdWUgPT09IHZvaWQgMCA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSA9PT0gYXJyYXlUeXBlTm9kZS52YWx1ZVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiAhMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSBcIm1hdGNoXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IHsgdHlwZTogXCJib29sZWFuXCIgfSA6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBtYXRjaChsZWZ0LCByaWdodClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8geyB0eXBlOiBcInVua25vd25cIiB9IDogbGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgKyByaWdodC52YWx1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgfSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlICsgcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiBsZWZ0LnR5cGUgPT09IFwiYXJyYXlcIiAmJiByaWdodC50eXBlID09PSBcImFycmF5XCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb2Y6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgICAgICAgICAgb2Y6IFtsZWZ0Lm9mLCByaWdodC5vZl1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSA6IGxlZnQudHlwZSA9PT0gXCJvYmplY3RcIiAmJiByaWdodC50eXBlID09PSBcIm9iamVjdFwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IC4uLmxlZnQuYXR0cmlidXRlcywgLi4ucmlnaHQuYXR0cmlidXRlcyB9XG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSAtIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSAqIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50eXBlID09PSBcInVua25vd25cIiB8fCByaWdodC50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgdmFsdWU6IGxlZnQudmFsdWUgIT09IHZvaWQgMCAmJiByaWdodC52YWx1ZSAhPT0gdm9pZCAwID8gbGVmdC52YWx1ZSAvIHJpZ2h0LnZhbHVlIDogdm9pZCAwXG4gICAgICAgICAgICB9IDogeyB0eXBlOiBcIm51bGxcIiB9O1xuICAgICAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICAgICAgcmV0dXJuIGxlZnQudHlwZSA9PT0gXCJ1bmtub3duXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsVW5pb24oeyB0eXBlOiBcIm51bWJlclwiIH0pIDogbGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBsZWZ0LnZhbHVlICE9PSB2b2lkIDAgJiYgcmlnaHQudmFsdWUgIT09IHZvaWQgMCA/IGxlZnQudmFsdWUgKiogcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnR5cGUgPT09IFwidW5rbm93blwiIHx8IHJpZ2h0LnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiID8ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICB2YWx1ZTogbGVmdC52YWx1ZSAhPT0gdm9pZCAwICYmIHJpZ2h0LnZhbHVlICE9PSB2b2lkIDAgPyBsZWZ0LnZhbHVlICUgcmlnaHQudmFsdWUgOiB2b2lkIDBcbiAgICAgICAgICAgIH0gOiB7IHR5cGU6IFwibnVsbFwiIH07XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVNlbGVjdE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgdmFsdWVzID0gW107XG4gIGxldCBndWFyYW50ZWVkID0gITE7XG4gIGZvciAoY29uc3QgYWx0ZXJuYXRpdmUgb2Ygbm9kZS5hbHRlcm5hdGl2ZXMpIHtcbiAgICBjb25zdCBjb25kaXRpb25WYWx1ZSA9IHdhbGsoeyBub2RlOiBhbHRlcm5hdGl2ZS5jb25kaXRpb24sIHNjb3BlIH0pLCBjb25kaXRpb25TY29wZSA9IHJlc29sdmVGaWx0ZXIoYWx0ZXJuYXRpdmUuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgY29uZGl0aW9uU2NvcGUudHlwZSA9PT0gXCJ1bmlvblwiICYmIGNvbmRpdGlvblNjb3BlLm9mLmxlbmd0aCA+IDAgJiYgdmFsdWVzLnB1c2god2Fsayh7IG5vZGU6IGFsdGVybmF0aXZlLnZhbHVlLCBzY29wZTogc2NvcGUuY3JlYXRlSGlkZGVuKGNvbmRpdGlvblNjb3BlLm9mKSB9KSksIGNvbmRpdGlvblZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGNvbmRpdGlvblZhbHVlLnZhbHVlID09PSAhMCAmJiAoZ3VhcmFudGVlZCA9ICEwKTtcbiAgfVxuICByZXR1cm4gbm9kZS5mYWxsYmFjayAmJiAhZ3VhcmFudGVlZCAmJiB2YWx1ZXMucHVzaCh3YWxrKHsgbm9kZTogbm9kZS5mYWxsYmFjaywgc2NvcGUgfSkpLCB2YWx1ZXMubGVuZ3RoID09PSAwID8geyB0eXBlOiBcIm51bGxcIiB9IDoge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvZjogdmFsdWVzXG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVBcnJheUNvZXJjZU5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwiYXJyYXlDb2VyY2UuYmFzZSAlT1wiLCBiYXNlKSwgbWFwQXJyYXkoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4gYmFzZTIpO1xufVxuZnVuY3Rpb24gaGFuZGxlRmxhdE1hcChub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBBcnJheShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSB3YWxrKHsgbm9kZTogbm9kZS5leHByLCBzY29wZTogc2NvcGUuY3JlYXRlSGlkZGVuKFtiYXNlMi5vZl0pIH0pO1xuICAgIHJldHVybiBtYXBOb2RlKFxuICAgICAgaW5uZXIsXG4gICAgICBzY29wZSxcbiAgICAgIChpbm5lcjIpID0+IGlubmVyMi50eXBlID09PSBcImFycmF5XCIgPyBpbm5lcjIgOiB7IHR5cGU6IFwiYXJyYXlcIiwgb2Y6IGlubmVyMiB9LFxuICAgICAgKG5vZGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGlubmVyMiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUyIG9mIG5vZGVzKSB7XG4gICAgICAgICAgaWYgKG5vZGUyLnR5cGUgPT09IFwidW5rbm93blwiKSByZXR1cm4geyB0eXBlOiBcImFycmF5XCIsIG9mOiBub2RlMiB9O1xuICAgICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImFycmF5XCIpIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlOiAke25vZGUyLnR5cGV9YCk7XG4gICAgICAgICAgaW5uZXIyLnB1c2gobm9kZTIub2YpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgIG9mOiBvcHRpbWl6ZVVuaW9ucyh7IHR5cGU6IFwidW5pb25cIiwgb2Y6IGlubmVyMiB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlTWFwKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgcmV0dXJuICR0cmFjZShcIm1hcC5iYXNlICVPXCIsIGJhc2UpLCBtYXBBcnJheShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiAoe1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBvZjogd2Fsayh7IG5vZGU6IG5vZGUuZXhwciwgc2NvcGU6IHNjb3BlLmNyZWF0ZUhpZGRlbihbYmFzZTIub2ZdKSB9KVxuICB9KSk7XG59XG5mdW5jdGlvbiBoYW5kbGVQcm9qZWN0aW9uTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiAkdHJhY2UoXCJwcm9qZWN0aW9uLmJhc2UgJU9cIiwgYmFzZSksIG1hcE9iamVjdChcbiAgICBiYXNlLFxuICAgIHNjb3BlLFxuICAgIChiYXNlMikgPT4gd2Fsayh7IG5vZGU6IG5vZGUuZXhwciwgc2NvcGU6IHNjb3BlLmNyZWF0ZU5lc3RlZChbYmFzZTJdKSB9KVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRmlsdGVyU2NvcGUoYmFzZSwgc2NvcGUpIHtcbiAgcmV0dXJuIGJhc2UudHlwZSA9PT0gXCJhcnJheVwiID8gYmFzZS5vZi50eXBlID09PSBcInVuaW9uXCIgPyBzY29wZS5jcmVhdGVOZXN0ZWQoYmFzZS5vZi5vZikgOiBzY29wZS5jcmVhdGVOZXN0ZWQoW2Jhc2Uub2ZdKSA6IHNjb3BlLmNyZWF0ZU5lc3RlZChbYmFzZV0pO1xufVxuZnVuY3Rpb24gaGFuZGxlRmlsdGVyTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiAkdHJhY2UoXCJmaWx0ZXIuYmFzZSAlT1wiLCBiYXNlKSwgbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiB7XG4gICAgaWYgKCR0cmFjZShcImZpbHRlci5yZXNvbHZpbmcgJU9cIiwgYmFzZTIpLCBiYXNlMi50eXBlID09PSBcIm51bGxcIilcbiAgICAgIHJldHVybiBiYXNlMjtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVGaWx0ZXIobm9kZS5leHByLCBjcmVhdGVGaWx0ZXJTY29wZShiYXNlMiwgc2NvcGUpKTtcbiAgICByZXR1cm4gJHRyYWNlKFwiZmlsdGVyLnJlc29sdmVkICVPXCIsIHJlc29sdmVkKSwge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgb2Y6IHJlc29sdmVkXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGxldCBhdHRyaWJ1dGVCYXNlID0gc2NvcGUudmFsdWU7XG4gIHJldHVybiBub2RlLmJhc2UgJiYgKGF0dHJpYnV0ZUJhc2UgPSB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KSksICR0cmFjZShcImFjY2Vzc0F0dHJpYnV0ZS5iYXNlICVzICVPXCIsIG5vZGUubmFtZSwgYXR0cmlidXRlQmFzZSksIGhhbmRsZUFjY2Vzc0F0dHJpYnV0ZUJhc2UoYXR0cmlidXRlQmFzZSwgbm9kZS5uYW1lLCBzY29wZSk7XG59XG5mdW5jdGlvbiBoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVCYXNlKGJhc2UsIG5hbWUsIHNjb3BlKSB7XG4gIHJldHVybiBtYXBPYmplY3QoYmFzZSwgc2NvcGUsIChiYXNlMikgPT4ge1xuICAgICR0cmFjZSgnTG9va2luZyBmb3IgYXR0cmlidXRlIFwiJXNcIiBpbiBvYmplY3QgJU8nLCBuYW1lLCBiYXNlMik7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYmFzZTIuYXR0cmlidXRlc1tuYW1lXTtcbiAgICByZXR1cm4gYXR0cmlidXRlICE9PSB2b2lkIDAgPyAoJGRlYnVnKGBhY2Nlc3NBdHRyaWJ1dGUuYXR0cmlidXRlIGZvdW5kICR7bmFtZX0gJU9gLCBhdHRyaWJ1dGUpLCBhdHRyaWJ1dGUub3B0aW9uYWwgPyBudWxsVW5pb24oYXR0cmlidXRlLnZhbHVlKSA6IGF0dHJpYnV0ZS52YWx1ZSkgOiBiYXNlMi5yZXN0ID8gaGFuZGxlQWNjZXNzQXR0cmlidXRlQmFzZShiYXNlMi5yZXN0LCBuYW1lLCBzY29wZSkgOiAoJHdhcm4oYGF0dHJpYnV0ZSBcIiR7bmFtZX1cIiBub3QgZm91bmQgaW4gb2JqZWN0YCksIHsgdHlwZTogXCJudWxsXCIgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQWNjZXNzRWxlbWVudE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gJHRyYWNlKFwiYWNjZXNzRWxlbWVudC5iYXNlICVPXCIsIGJhc2UpLCBtYXBBcnJheShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBudWxsVW5pb24oYmFzZTIub2YpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFycmF5Tm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBvZiA9IFtdO1xuICBmb3IgKGNvbnN0IGVsIG9mIG5vZGUuZWxlbWVudHMpIHtcbiAgICBjb25zdCBub2RlMiA9IHdhbGsoeyBub2RlOiBlbC52YWx1ZSwgc2NvcGUgfSk7XG4gICAgbm9kZTIgIT09IG51bGwgJiYgb2YucHVzaChub2RlMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IHtcbiAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgIG9mXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlVmFsdWVOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGlmIChub2RlLnZhbHVlID09PSBudWxsKVxuICAgIHJldHVybiB7IHR5cGU6IFwibnVsbFwiIH07XG4gIHN3aXRjaCAodHlwZW9mIG5vZGUudmFsdWUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxuICAgICAgfTtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICB2YWx1ZTogbm9kZS52YWx1ZVxuICAgICAgfTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIHZhbHVlOiBub2RlLnZhbHVlXG4gICAgICB9O1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBub2RlLnZhbHVlID09PSBudWxsID8geyB0eXBlOiBcIm51bGxcIiB9IDogQXJyYXkuaXNBcnJheShub2RlLnZhbHVlKSA/IHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBvZjoge1xuICAgICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgICBvZjogbm9kZS52YWx1ZS5tYXAoKHZhbHVlKSA9PiB3YWxrKHsgbm9kZTogeyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlIH0sIHNjb3BlIH0pKVxuICAgICAgICB9XG4gICAgICB9IDoge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMobm9kZS52YWx1ZSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHdhbGsoeyBub2RlOiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWUgfSwgc2NvcGUgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKVxuICAgICAgICApXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInVua25vd25cIiB9O1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTbGljZShub2RlLCBzY29wZSkge1xuICAkdHJhY2UoXCJzbGljZS5ub2RlICVPXCIsIG5vZGUpO1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBBcnJheShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMik7XG59XG5mdW5jdGlvbiBoYW5kbGVQYXJlbnROb2RlKHsgbiB9LCBzY29wZSkge1xuICAkdHJhY2UoXCJoYW5kbGUucGFyZW50LmN1cnJlbnRTY29wZSAlZCAlT1wiLCBuLCBzY29wZSk7XG4gIGxldCBjdXJyZW50ID0gc2NvcGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgZm9yICg7IGN1cnJlbnQ/LmlzSGlkZGVuOyApXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgY3VycmVudCA9IGN1cnJlbnQ/LnBhcmVudDtcbiAgfVxuICByZXR1cm4gJHRyYWNlKFwiaGFuZGxlLnBhcmVudC5uZXdTY29wZSAlZCAlT1wiLCBuLCBjdXJyZW50KSwgY3VycmVudCA/IGN1cnJlbnQudmFsdWUub2YubGVuZ3RoID09PSAwID8geyB0eXBlOiBcIm51bGxcIiB9IDogY3VycmVudC52YWx1ZSA6IHsgdHlwZTogXCJudWxsXCIgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vdE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwiYm9vbGVhblwiIH0pIDogYmFzZTIudHlwZSA9PT0gXCJib29sZWFuXCIgPyBiYXNlMi52YWx1ZSAhPT0gdm9pZCAwID8geyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6IGJhc2UyLnZhbHVlID09PSAhMSB9IDogeyB0eXBlOiBcImJvb2xlYW5cIiB9IDogeyB0eXBlOiBcIm51bGxcIiB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5lZ05vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgYmFzZSA9IHdhbGsoeyBub2RlOiBub2RlLmJhc2UsIHNjb3BlIH0pO1xuICByZXR1cm4gbWFwTm9kZShiYXNlLCBzY29wZSwgKGJhc2UyKSA9PiBiYXNlMi50eXBlID09PSBcInVua25vd25cIiA/IG51bGxVbmlvbih7IHR5cGU6IFwibnVtYmVyXCIgfSkgOiBiYXNlMi50eXBlICE9PSBcIm51bWJlclwiID8geyB0eXBlOiBcIm51bGxcIiB9IDogYmFzZTIudmFsdWUgIT09IHZvaWQgMCA/IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IC1iYXNlMi52YWx1ZSB9IDogYmFzZTIpO1xufVxuZnVuY3Rpb24gaGFuZGxlUG9zTm9kZShub2RlLCBzY29wZSkge1xuICBjb25zdCBiYXNlID0gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKGJhc2UsIHNjb3BlLCAoYmFzZTIpID0+IGJhc2UyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbFVuaW9uKHsgdHlwZTogXCJudW1iZXJcIiB9KSA6IGJhc2UyLnR5cGUgIT09IFwibnVtYmVyXCIgPyB7IHR5cGU6IFwibnVsbFwiIH0gOiBiYXNlMik7XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVyeXRoaW5nTm9kZShfLCBzY29wZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBvZjoge1xuICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgb2Y6IHNjb3BlLmNvbnRleHQuc2NoZW1hLmZpbHRlcigob2JqKSA9PiBvYmoudHlwZSA9PT0gXCJkb2N1bWVudFwiKS5tYXAoKGRvYykgPT4gKHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczogZG9jLmF0dHJpYnV0ZXNcbiAgICAgIH0pKVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFuZE5vZGUobm9kZSwgc2NvcGUpIHtcbiAgY29uc3QgbGVmdCA9IHdhbGsoeyBub2RlOiBub2RlLmxlZnQsIHNjb3BlIH0pLCByaWdodCA9IHdhbGsoeyBub2RlOiBub2RlLnJpZ2h0LCBzY29wZSB9KTtcbiAgcmV0dXJuIG1hcE5vZGUoXG4gICAgbGVmdCxcbiAgICBzY29wZSxcbiAgICAobGhzKSA9PiBtYXBOb2RlKHJpZ2h0LCBzY29wZSwgKHJocykgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBib29sZWFuQW5kKGJvb2xlYW5WYWx1ZShsaHMsIHNjb3BlKSwgYm9vbGVhblZhbHVlKHJocywgc2NvcGUpKTtcbiAgICAgIHJldHVybiBib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlKHZhbHVlKTtcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gaGFuZGxlT3JOb2RlKG5vZGUsIHNjb3BlKSB7XG4gIGNvbnN0IGxlZnQgPSB3YWxrKHsgbm9kZTogbm9kZS5sZWZ0LCBzY29wZSB9KSwgcmlnaHQgPSB3YWxrKHsgbm9kZTogbm9kZS5yaWdodCwgc2NvcGUgfSk7XG4gIHJldHVybiBtYXBOb2RlKFxuICAgIGxlZnQsXG4gICAgc2NvcGUsXG4gICAgKGxocykgPT4gbWFwTm9kZShyaWdodCwgc2NvcGUsIChyaHMpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYm9vbGVhbk9yKGJvb2xlYW5WYWx1ZShsaHMsIHNjb3BlKSwgYm9vbGVhblZhbHVlKHJocywgc2NvcGUpKTtcbiAgICAgIHJldHVybiBib29sZWFuSW50ZXJwcmV0YXRpb25Ub1R5cGVOb2RlKHZhbHVlKTtcbiAgICB9KVxuICApO1xufVxuY29uc3QgT1ZFUlJJREVfVFlQRV9TWU1CT0wgPSBTeW1ib2woXCJncm9xLWpzLnR5cGVcIik7XG5mdW5jdGlvbiB3YWxrKHsgbm9kZSwgc2NvcGUgfSkge1xuICBpZiAoT1ZFUlJJREVfVFlQRV9TWU1CT0wgaW4gbm9kZSlcbiAgICByZXR1cm4gbm9kZVtPVkVSUklERV9UWVBFX1NZTUJPTF07XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgLy8gRmlsdGVyaW5nLCB0cmF2ZXJzYWwgJiBwcm9qZWN0aW9uc1xuICAgIGNhc2UgXCJNYXBcIjpcbiAgICAgIHJldHVybiBoYW5kbGVNYXAobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJQcm9qZWN0aW9uXCI6XG4gICAgICByZXR1cm4gaGFuZGxlUHJvamVjdGlvbk5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJGaWx0ZXJcIjpcbiAgICAgIHJldHVybiBoYW5kbGVGaWx0ZXJOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiQWNjZXNzQXR0cmlidXRlXCI6XG4gICAgICByZXR1cm4gb3B0aW1pemVVbmlvbnMoaGFuZGxlQWNjZXNzQXR0cmlidXRlTm9kZShub2RlLCBzY29wZSkpO1xuICAgIGNhc2UgXCJBY2Nlc3NFbGVtZW50XCI6XG4gICAgICByZXR1cm4gaGFuZGxlQWNjZXNzRWxlbWVudE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJBcnJheUNvZXJjZVwiOlxuICAgICAgcmV0dXJuIGhhbmRsZUFycmF5Q29lcmNlTm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkZsYXRNYXBcIjpcbiAgICAgIHJldHVybiBoYW5kbGVGbGF0TWFwKG5vZGUsIHNjb3BlKTtcbiAgICAvLyBPcGVyYXRpb25zXG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxuICAgICAgcmV0dXJuIGhhbmRsZU9wQ2FsbE5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJBbmRcIjpcbiAgICAgIHJldHVybiBoYW5kbGVBbmROb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiT3JcIjpcbiAgICAgIHJldHVybiBoYW5kbGVPck5vZGUobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJTZWxlY3RcIjpcbiAgICAgIHJldHVybiBoYW5kbGVTZWxlY3ROb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiUGlwZUZ1bmNDYWxsXCI6XG4gICAgICByZXR1cm4gd2Fsayh7IG5vZGU6IG5vZGUuYmFzZSwgc2NvcGUgfSk7XG4gICAgLy8gVmFsdWVzXG4gICAgY2FzZSBcIkRlcmVmXCI6XG4gICAgICByZXR1cm4gaGFuZGxlRGVyZWZOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgICByZXR1cm4gaGFuZGxlT2JqZWN0Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlZhbHVlXCI6XG4gICAgICByZXR1cm4gaGFuZGxlVmFsdWVOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgIHJldHVybiBoYW5kbGVBcnJheU5vZGUobm9kZSwgc2NvcGUpO1xuICAgIC8vIFNwZWNpYWwgY2FzZXNcbiAgICBjYXNlIFwiRXZlcnl0aGluZ1wiOlxuICAgICAgcmV0dXJuIGhhbmRsZUV2ZXJ5dGhpbmdOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiVGhpc1wiOlxuICAgICAgcmV0dXJuICR0cmFjZShcInRoaXMgJU9cIiwgc2NvcGUudmFsdWUpLCBzY29wZS52YWx1ZTtcbiAgICBjYXNlIFwiUGFyZW50XCI6XG4gICAgICByZXR1cm4gaGFuZGxlUGFyZW50Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIkZ1bmNDYWxsXCI6XG4gICAgICByZXR1cm4gaGFuZGxlRnVuY0NhbGxOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgIHJldHVybiB3YWxrKHsgbm9kZTogbm9kZS5iYXNlLCBzY29wZSB9KTtcbiAgICBjYXNlIFwiTm90XCI6XG4gICAgICByZXR1cm4gaGFuZGxlTm90Tm9kZShub2RlLCBzY29wZSk7XG4gICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ1bmtub3duXCJcbiAgICAgIH07XG4gICAgY2FzZSBcIlNsaWNlXCI6XG4gICAgICByZXR1cm4gaGFuZGxlU2xpY2Uobm9kZSwgc2NvcGUpO1xuICAgIGNhc2UgXCJOZWdcIjpcbiAgICAgIHJldHVybiBoYW5kbGVOZWdOb2RlKG5vZGUsIHNjb3BlKTtcbiAgICBjYXNlIFwiUG9zXCI6XG4gICAgICByZXR1cm4gaGFuZGxlUG9zTm9kZShub2RlLCBzY29wZSk7XG4gICAgLy8gZXZlcnl0aGluZyBlbHNlXG4gICAgY2FzZSBcIkFzY1wiOlxuICAgIGNhc2UgXCJEZXNjXCI6XG4gICAgY2FzZSBcIkNvbnRleHRcIjpcbiAgICBjYXNlIFwiVHVwbGVcIjpcbiAgICBjYXNlIFwiU2VsZWN0b3JcIjpcbiAgICBjYXNlIFwiSW5SYW5nZVwiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIG5vZGUgdHlwZSAke25vZGUudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQcmltaXRpdmVUeXBlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgbm9kZS50eXBlID09PSBcIm51bWJlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBldmFsdWF0ZUNvbXBhcmlzb24ob3BjYWxsLCBsZWZ0LCByaWdodCkge1xuICBpZiAoIShsZWZ0LnZhbHVlID09PSB2b2lkIDAgfHwgcmlnaHQudmFsdWUgPT09IHZvaWQgMCkpXG4gICAgc3dpdGNoIChvcGNhbGwpIHtcbiAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZSA9PT0gcmlnaHQudmFsdWU7XG4gICAgICBjYXNlIFwiPFwiOlxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZSA8IHJpZ2h0LnZhbHVlO1xuICAgICAgY2FzZSBcIjw9XCI6XG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlIDw9IHJpZ2h0LnZhbHVlO1xuICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQudmFsdWUgPiByaWdodC52YWx1ZTtcbiAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICByZXR1cm4gbGVmdC52YWx1ZSA+PSByaWdodC52YWx1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBjb21wYXJpc29uIG9wZXJhdG9yICR7b3BjYWxsfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIoZXhwciwgc2NvcGUpIHtcbiAgJHRyYWNlKFwicmVzb2x2ZUZpbHRlci5leHByICVPXCIsIGV4cHIpO1xuICBjb25zdCBmaWx0ZXJlZCA9IHNjb3BlLnZhbHVlLm9mLmZpbHRlcigobm9kZSkgPT4ge1xuICAgIGNvbnN0IHN1YlNjb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKFtub2RlXSksIGNvbmQgPSB3YWxrKHsgbm9kZTogZXhwciwgc2NvcGU6IHN1YlNjb3BlIH0pO1xuICAgIHJldHVybiBib29sZWFuVmFsdWUoY29uZCwgc3ViU2NvcGUpLmNhbkJlVHJ1ZTtcbiAgfSk7XG4gIHJldHVybiAkdHJhY2UoXG4gICAgYHJlc29sdmVGaWx0ZXIgJHtleHByLnR5cGUgPT09IFwiT3BDYWxsXCIgPyBgJHtleHByLnR5cGV9LyR7ZXhwci5vcH1gIDogZXhwci50eXBlfSAlT2AsXG4gICAgZmlsdGVyZWRcbiAgKSwgeyB0eXBlOiBcInVuaW9uXCIsIG9mOiBmaWx0ZXJlZCB9O1xufVxuZnVuY3Rpb24gbWFwQXJyYXkobm9kZSwgc2NvcGUsIG1hcHBlcikge1xuICByZXR1cm4gbWFwTm9kZShub2RlLCBzY29wZSwgKGJhc2UpID0+IGJhc2UudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBiYXNlIDogYmFzZS50eXBlID09PSBcImFycmF5XCIgPyBtYXBwZXIoYmFzZSkgOiB7IHR5cGU6IFwibnVsbFwiIH0pO1xufVxuZnVuY3Rpb24gbWFwT2JqZWN0KG5vZGUsIHNjb3BlLCBtYXBwZXIpIHtcbiAgcmV0dXJuIG1hcE5vZGUobm9kZSwgc2NvcGUsIChiYXNlKSA9PiBiYXNlLnR5cGUgPT09IFwidW5rbm93blwiID8gYmFzZSA6IGJhc2UudHlwZSA9PT0gXCJvYmplY3RcIiA/IG1hcHBlcihiYXNlKSA6IHsgdHlwZTogXCJudWxsXCIgfSk7XG59XG5leHBvcnQge1xuICBEYXRlVGltZSxcbiAgUGF0aCxcbiAgY3JlYXRlUmVmZXJlbmNlVHlwZU5vZGUsXG4gIGV2YWx1YXRlUXVlcnkgYXMgZXZhbHVhdGUsXG4gIHBhcnNlLFxuICB0eXBlRXZhbHVhdGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD0xLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZWJ1ZyIsImVzY2FwZVJlZ0V4cCIsInN0cmluZyIsInJlcGxhY2UiLCJwYXRoUmVnRXhwIiwicGF0dGVybiIsInJlIiwicGFydCIsInNwbGl0IiwicHVzaCIsIlJlZ0V4cCIsImpvaW4iLCJQYXRoIiwiY29uc3RydWN0b3IiLCJwYXR0ZXJuUmUiLCJtYXRjaGVzIiwic3RyIiwidGVzdCIsInRvSlNPTiIsIlN0cmVhbVZhbHVlIiwiZ2VuZXJhdG9yIiwidHlwZSIsInRpY2tlciIsImlzRG9uZSIsImRhdGEiLCJpc0FycmF5IiwiZ2V0IiwicmVzdWx0IiwidmFsdWUiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwiaSIsImxlbmd0aCIsIl9uZXh0VGljayIsImN1cnJlbnRSZXNvbHZlciIsInNldHVwVGlja2VyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aWNrIiwiZmV0Y2giLCJSRkMzMzM5X1JFR0VYIiwicGFyc2VSRkMzMzM5IiwiRGF0ZSIsImZvcm1hdFJGQzMzMzkiLCJkIiwieWVhciIsImFkZExlYWRpbmdaZXJvIiwiZ2V0VVRDRnVsbFllYXIiLCJtb250aCIsImdldFVUQ01vbnRoIiwiZGF5IiwiZ2V0VVRDRGF0ZSIsImhvdXIiLCJnZXRVVENIb3VycyIsIm1pbnV0ZSIsImdldFVUQ01pbnV0ZXMiLCJzZWNvbmQiLCJnZXRVVENTZWNvbmRzIiwiZnJhY3Rpb25hbFNlY29uZCIsIm1pbGxpcyIsImdldE1pbGxpc2Vjb25kcyIsIm51bSIsInRhcmdldExlbmd0aCIsInRvU3RyaW5nIiwiU3RhdGljVmFsdWUiLCJBcnJheSIsImVsZW1lbnQiLCJmcm9tSlMiLCJFcnJvciIsIk5VTExfVkFMVUUiLCJUUlVFX1ZBTFVFIiwiRkFMU0VfVkFMVUUiLCJEYXRlVGltZSIsImRhdGUiLCJwYXJzZVRvVmFsdWUiLCJlcXVhbHMiLCJvdGhlciIsImdldFRpbWUiLCJhZGQiLCJzZWNzIiwiY29weSIsInNldFRpbWUiLCJkaWZmZXJlbmNlIiwiY29tcGFyZVRvIiwiZnJvbU51bWJlciIsIk51bWJlciIsImlzRmluaXRlIiwiZnJvbVN0cmluZyIsImZyb21EYXRlVGltZSIsImR0IiwiZnJvbVBhdGgiLCJwYXRoIiwiaXNJdGVyYXRvciIsIm9iaiIsIm5leHQiLCJ2YWwiLCJnZXRUeXBlIiwiaXNFcXVhbCIsImEiLCJiIiwiQ0hBUlMiLCJDSEFSU19XSVRIX1dJTERDQVJEIiwiRURHRV9DSEFSUyIsIm1hdGNoVGV4dCIsInRva2VucyIsInBhdHRlcm5zIiwiZXZlcnkiLCJtYXRjaFRva2VuaXplIiwidGV4dCIsIm1hdGNoIiwibWF0Y2hBbmFseXplUGF0dGVybiIsIm1hdGNoUGF0dGVyblJlZ2V4IiwibWFwIiwic29tZSIsInRva2VuIiwidGVybSIsInNsaWNlIiwiZ2F0aGVyVGV4dCIsImNiIiwic3VjY2VzcyIsIlRZUEVfT1JERVIiLCJkYXRldGltZSIsIm51bWJlciIsImJvb2xlYW4iLCJwYXJ0aWFsQ29tcGFyZSIsImFUeXBlIiwiYlR5cGUiLCJ0b3RhbENvbXBhcmUiLCJhVHlwZU9yZGVyIiwiYlR5cGVPcmRlciIsIm9wZXJhdG9ycyIsImxlZnQiLCJyaWdodCIsImluIiwiY29uY2F0IiwibnVtZXJpY09wZXJhdG9yIiwiTWF0aCIsInBvdyIsImltcGwiLCJTY29wZSQxIiwiU2NvcGUiLCJwYXJhbXMiLCJzb3VyY2UiLCJjb250ZXh0IiwicGFyZW50IiwiaXNIaWRkZW4iLCJjcmVhdGVOZXN0ZWQiLCJjcmVhdGVIaWRkZW4iLCJldmFsdWF0ZSIsIm5vZGUiLCJzY29wZSIsImV4ZWN1dGUiLCJmdW5jIiwiRVhFQ1VUT1JTIiwicHJvbWlzZWxlc3NBcHBseSIsInRoZW4iLCJUaGlzIiwiXyIsIlNlbGVjdG9yIiwiRXZlcnl0aGluZyIsIlBhcmFtZXRlciIsIm5hbWUiLCJDb250ZXh0Iiwia2V5IiwiUGFyZW50IiwibiIsImN1cnJlbnQiLCJPcENhbGwiLCJvcCIsImxlZnRWYWx1ZSIsInJpZ2h0VmFsdWUiLCJTZWxlY3QiLCJhbHRlcm5hdGl2ZXMiLCJmYWxsYmFjayIsImFsdCIsImFsdENvbmQiLCJjb25kaXRpb24iLCJJblJhbmdlIiwiYmFzZSIsImlzSW5jbHVzaXZlIiwibGVmdENtcCIsInJpZ2h0Q21wIiwiRmlsdGVyIiwiZXhwciIsImJhc2VWYWx1ZSIsImVsZW0iLCJuZXdTY29wZSIsImV4cHJWYWx1ZSIsIlByb2plY3Rpb24iLCJGdW5jQ2FsbCIsImFyZ3MiLCJQaXBlRnVuY0NhbGwiLCJBY2Nlc3NBdHRyaWJ1dGUiLCJoYXNPd25Qcm9wZXJ0eSIsIkFjY2Vzc0VsZW1lbnQiLCJpbmRleCIsImZpbmFsSW5kZXgiLCJTbGljZSIsImFycmF5MiIsImxlZnRJZHgiLCJyaWdodElkeCIsIkRlcmVmIiwiaWQiLCJfcmVmIiwiZGVyZWZlcmVuY2UiLCJkb2MiLCJfaWQiLCJWYWx1ZSIsIkdyb3VwIiwiT2JqZWN0IiwiYXR0cmlidXRlcyIsImF0dHIiLCJhdHRyVHlwZSIsImNvbmQiLCJhc3NpZ24iLCJlbGVtZW50cyIsImlzU3BsYXQiLCJ2IiwiVHVwbGUiLCJPciIsIkFuZCIsIk5vdCIsIk5lZyIsIlBvcyIsIkFzYyIsIkRlc2MiLCJBcnJheUNvZXJjZSIsIk1hcCIsIkZsYXRNYXAiLCJpbm5lclZhbHVlIiwiaW5uZXIiLCJldmFsdWF0ZVF1ZXJ5IiwidHJlZSIsIm9wdGlvbnMiLCJyb290IiwiZGF0YXNldCIsInRpbWVzdGFtcCIsImlkZW50aXR5Iiwic2FuaXR5IiwiYWZ0ZXIiLCJiZWZvcmUiLCJjYW5Db25zdGFudEV2YWx1YXRlIiwiRFVNTVlfU0NPUEUiLCJ0cnlDb25zdGFudEV2YWx1YXRlIiwiY29uc3RhbnRFdmFsdWF0ZSIsInBvcnRhYmxlVGV4dENvbnRlbnQiLCJibG9ja1RleHQiLCJ0ZXh0cyIsImFycmF5VGV4dCIsImJsb2NrIiwiX3R5cGUiLCJjaGlsZHJlbiIsImNoaWxkIiwiQk0yNWsiLCJldmFsdWF0ZVNjb3JlIiwiZXZhbHVhdGVNYXRjaFNjb3JlIiwiaW5uZXJTY29yZSIsImJvb3N0IiwibGVmdFNjb3JlIiwicmlnaHRTY29yZSIsInJlcyIsInRlcm1zIiwic2NvcmUiLCJmcmVxIiwicmVkdWNlIiwiYyIsImhhc1JlZmVyZW5jZSIsInBhdGhTZXQiLCJoYXMiLCJ2YWx1ZXMiLCJjb3VudFVURjgiLCJjb3VudDIiLCJjb2RlIiwiY2hhckNvZGVBdCIsIl9nbG9iYWwiLCJhbnl3aGVyZSIsImFyaXR5IiwiY29hbGVzY2UiLCJhcmciLCJjb3VudCIsImRhdGVUaW1lIiwiZGVmaW5lZCIsIl9hcmdzIiwicmVmZXJlbmNlcyIsIlNldCIsInBhdGgyIiwic2l6ZSIsInNjb3BlVmFsdWUiLCJyb3VuZCIsInByZWMiLCJwcmVjVmFsdWUiLCJpc0ludGVnZXIiLCJ0b0ZpeGVkIiwibm93IiwidG9JU09TdHJpbmciLCJzdHJpbmcyIiwibG93ZXIiLCJ0b0xvd2VyQ2FzZSIsInVwcGVyIiwidG9VcHBlckNhc2UiLCJzZXAiLCJmcm9tIiwic3RhcnRzV2l0aCIsInByZWZpeCIsImFycmF5IiwiYXJyIiwiYnVmIiwibmVlZFNlcCIsImNvbXBhY3QiLCJ1bmlxdWUiLCJhZGRlZCIsIml0ZXIiLCJpbnRlcnNlY3RzIiwiYXJyMSIsImFycjIiLCJ2MSIsInYyIiwicHQiLCJwcm9qZWN0SWQiLCJ2ZXJzaW9uT2YiLCJiYXNlSWQiLCJ2ZXJzaW9uSWRzIiwidmFsdWUyIiwiZW5kc1dpdGgiLCJfdmVyc2lvbiIsImRvY3VtZW50c09mIiwiZG9jdW1lbnRJZHNJbkJ1bmRsZSIsInBpcGVGdW5jdGlvbnMiLCJvcmRlciIsIm1hcHBlcnMiLCJkaXJlY3Rpb25zIiwibWFwcGVyIiwiZGlyZWN0aW9uIiwiYXV4IiwiaWR4IiwidHVwbGUiLCJzb3J0IiwiYVR1cGxlIiwiYlR1cGxlIiwidW5rbm93biIsInNjb3JlZCIsInZhbHVlU2NvcmUiLCJfc2NvcmUiLCJuZXdPYmplY3QiLCJkZWx0YSIsIm9wZXJhdGlvbiIsImhhc0JlZm9yZSIsImhhc0FmdGVyIiwiY2hhbmdlZEFueSIsIm1vZGUiLCJjaGFuZ2VkT25seSIsImRpZmYiLCJtYXRoIiwibWluIiwibWF4Iiwic3VtIiwiYXZnIiwiZGF0ZVRpbWUyIiwibmFtZXNwYWNlcyIsImdsb2JhbCIsIk1hcmtQcm9jZXNzb3IiLCJtYXJrcyIsInBhcnNlT3B0aW9ucyIsImFsbG93Qm9vc3QiLCJoYXNNYXJrIiwicG9zIiwiZ2V0TWFyayIsInNoaWZ0IiwicHJvY2VzcyIsInZpc2l0b3IiLCJtYXJrIiwiY2FsbCIsInByb2Nlc3NTdHJpbmciLCJwcm9jZXNzU3RyaW5nRW5kIiwicHJldiIsImN1cnIiLCJwb3NpdGlvbiIsImxlbiIsIldTIiwiTlVNIiwiSURFTlQiLCJwYXJzZSQxIiwic2tpcFdTIiwicGFyc2VFeHByIiwiZmFpbFBvc2l0aW9uIiwibGV2ZWwiLCJzdGFydFBvcyIsInJocyIsInBhcnNlT2JqZWN0IiwicGFyc2VTdHJpbmciLCJpZGVudExlbiIsInBhcnNlUmVnZXgiLCJudW1MZW4iLCJmcmFjTGVuIiwiZXhwTGVuIiwicGFyc2VGdW5jQ2FsbCIsImxoc0xldmVsIiwidHJhdiIsImxvb3AiLCJpbm5lclBvcyIsInBhcnNlVHJhdmVyc2FsIiwidW5zaGlmdCIsInJoczIiLCJuZXh0UG9zIiwiaWRlbnRQb3MiLCJwYXJzZVJlZ2V4U3RyIiwiaXNHcm91cCIsInJhbmdlUG9zIiwiaWRlbnRTdGFydCIsImlkZW50TGVuMiIsIm5hbWVMZW4iLCJsYXN0UG9zIiwicGFpclBvcyIsImluZGV4T2YiLCJtIiwiZXhlYyIsImZsYXRNYXAiLCJ0cmF2ZXJzZUFycmF5IiwiYnVpbGQiLCJ0cmF2ZXJzZVBsYWluIiwidHJhdmVyc2VFbGVtZW50IiwidHJhdmVyc2VQcm9qZWN0aW9uIiwiRVNDQVBFX1NFUVVFTkNFIiwiZiIsInIiLCJ0IiwiZXhwYW5kSGV4IiwiY2hhckNvZGUiLCJwYXJzZUludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkdyb3FRdWVyeUVycm9yIiwiRVhQUl9CVUlMREVSIiwiZ3JvdXAiLCJwIiwiZXZlcnl0aGluZyIsInRoaXMiLCJkYmxwYXJlbnQiLCJ0cmF2ZXJzZSIsInRyYXZlcnNhbExpc3QiLCJUUkFWRVJTRV9CVUlMREVSIiwidHJhdmVyc2FsIiwidGhpc19hdHRyIiwibmVnIiwic3ViIiwibXVsIiwiZGl2IiwibW9kIiwiY29tcCIsImluX3JhbmdlIiwiY2hhciIsImludGVnZXIiLCJzdHJWYWx1ZSIsImZsb2F0Iiwic2NpIiwib2JqZWN0IiwiT0JKRUNUX0JVSUxERVIiLCJtZW1iZXJzIiwiZnVuY19jYWxsIiwibmFtZXNwYWNlIiwiYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yIiwiU0VMRUNUT1JfQlVJTERFUiIsImZ1bmNzIiwidmFsaWRhdGVBcml0eSIsInBpcGVjYWxsIiwib2xkQWxsb3dCb29zdCIsIm1hcmtOYW1lIiwicGFpciIsImFuZCIsIm9yIiwibm90IiwiYXNjIiwiZGVzYyIsInBhcmFtIiwib2JqZWN0X2V4cHIiLCJleHRyYWN0UHJvcGVydHlLZXkiLCJvYmplY3RfcGFpciIsIm9iamVjdF9zcGxhdCIsIm9iamVjdF9zcGxhdF90aGlzIiwic3F1YXJlX2JyYWNrZXQiLCJwcm9qZWN0aW9uIiwiYXR0cl9hY2Nlc3MiLCJkZXJlZiIsIndyYXAiLCJhcnJheV9wb3N0Zml4IiwiZnVuY3Rpb25OYW1lIiwiYXJnQ291bnQiLCJmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMiLCJpbmNsdWRlcyIsIkdyb3FTeW50YXhFcnJvciIsInBhcnNlIiwiaW5wdXQiLCJjb21wYXJlIiwiSW50bCIsIkNvbGxhdG9yIiwidHlwZU5vZGVzU29ydGVyIiwiaGFzaEZpZWxkIiwiZmllbGQiLCJvZiIsImVudHJpZXMiLCJvcHRpb25hbCIsImRlcmVmZXJlbmNlc1RvIiwicmVzdCIsInNvcnRlZCIsInJlbW92ZUR1cGxpY2F0ZVR5cGVOb2RlcyIsInR5cGVOb2RlcyIsInNlZW5UeXBlcyIsIm5ld1R5cGVOb2RlcyIsInNvcnRlZFR5cGVOb2RlcyIsInR5cGVOb2RlIiwiaGFzaCIsIm9wdGltaXplVW5pb25zIiwic3ViRmllbGQiLCJzcGxpY2UiLCJoYXNPd24iLCJjcmVhdGVSZWZlcmVuY2VUeXBlTm9kZSIsImluQXJyYXkiLCJfd2VhayIsIl9rZXkiLCJudWxsVW5pb24iLCJ1bmlvbk9mIiwibm9kZXMiLCJyZXNvbHZlSW5saW5lIiwicmVzb2x2ZWRJbmxpbmUiLCJsb29rdXBUeXBlRGVjbGFyYXRpb24iLCJtYXBOb2RlIiwibWVyZ2VVbmlvbnMiLCJpc0Z1bmNDYWxsIiwiYm9vbGVhblZhbHVlIiwiY2FuQmVUcnVlIiwiY2FuQmVGYWxzZSIsImNhbkJlTnVsbCIsIm1hdGNoMiIsInJlc29sdmVkIiwiYm9vbGVhbk9yIiwiYm9vbGVhbkFuZCIsImJvb2xlYW5JbnRlcnByZXRhdGlvblRvVHlwZU5vZGUiLCJib29sIiwiJHRyYWNlJDEiLCJsb2ciLCJjb25zb2xlIiwiYmluZCIsInNjaGVtYSIsImxvb2t1cFJlZiIsInJlZlRvIiwiYWxpYXMiLCJTY29wZTIiLCJ1bmlvbldpdGhvdXROdWxsIiwidW5pb25UeXBlTm9kZSIsImZpbHRlciIsImhhbmRsZUZ1bmNDYWxsTm9kZSIsIndhbGsiLCJhcmcyIiwib2YyIiwiYXJyYXlBcmciLCJzZXBBcmciLCJhcnJheUFyZzIiLCJzZXBBcmcyIiwiYXJnMSIsImFyZzEyIiwiYXJnMjIiLCJub2RlMiIsImFyZ05vZGUiLCJhbGxOdWxsIiwibnVtTm9kZSIsInByZWNpc2lvbk5vZGUiLCJwcmVjaXNpb24iLCJub2RlMyIsInN0clR5cGVOb2RlIiwicHJlZml4VHlwZU5vZGUiLCJzdHJOb2RlIiwicHJlZml4Tm9kZSIsInNlcFR5cGVOb2RlIiwic2VwTm9kZSIsInR5cGVOb2RlMiIsIiR0cmFjZSIsIiRkZWJ1ZyIsIiR3YXJuIiwidHlwZUV2YWx1YXRlIiwiYXN0IiwicGFyc2VkIiwib3B0aW1pemVkIiwibWFwRGVyZWYiLCJoYW5kbGVEZXJlZk5vZGUiLCJkZXJlZmVkTm9kZSIsImhhbmRsZU9iamVjdFNwbGF0Tm9kZSIsInJlc29sdmVkUmVzdCIsImhhbmRsZU9iamVjdE5vZGUiLCJvYmplY3RBdHRyaWJ1dGVzIiwic3BsYXRWYXJpYW50cyIsImNvbmRpdGlvbmFsVmFyaWFudHMiLCJhdHRyaWJ1dGVOb2RlIiwidmFyaWFudCIsImF0dHJpYnV0ZU5vZGUyIiwiZ3VhcmFudGVlZEF0dHJpYnV0ZXMiLCJzcGxhdE5vZGUiLCJhdHRyaWJ1dGUiLCJmcm9tRW50cmllcyIsIm1hdHJpeCIsInVuaW9uSWR4IiwidW5pb24iLCJ1bmlvbkd1YXJhbnRlZWRCZWZvcmUiLCJ1bmlvbkd1YXJhbnRlZWRBZnRlciIsImd1YXJhbnRlZWRJbmRleCIsImFsbFZhcmlhbnRzQXR0cmlidXRlcyIsImNvbmRpdGlvbmFsVmFyaWFudElkeCIsIm90aGVyVW5pb24iLCJ2YXJpYW50QXR0cmlidXRlcyIsIm91dGVySWR4Iiwib3V0ZXJBdHRyaWJ1dGVzIiwib3V0ZXIiLCJpbm5lcklkeCIsImlubmVyQXR0cmlidXRlcyIsIl9iZWZvcmUiLCJfYWZ0ZXIiLCJoYW5kbGVPcENhbGxOb2RlIiwibGhzIiwiaXNQcmltaXRpdmVUeXBlTm9kZSIsImV2YWx1YXRlQ29tcGFyaXNvbiIsImFycmF5VHlwZU5vZGUiLCJoYW5kbGVTZWxlY3ROb2RlIiwiZ3VhcmFudGVlZCIsImFsdGVybmF0aXZlIiwiY29uZGl0aW9uVmFsdWUiLCJjb25kaXRpb25TY29wZSIsInJlc29sdmVGaWx0ZXIiLCJoYW5kbGVBcnJheUNvZXJjZU5vZGUiLCJtYXBBcnJheSIsImJhc2UyIiwiaGFuZGxlRmxhdE1hcCIsImlubmVyMiIsImhhbmRsZU1hcCIsImhhbmRsZVByb2plY3Rpb25Ob2RlIiwibWFwT2JqZWN0IiwiY3JlYXRlRmlsdGVyU2NvcGUiLCJoYW5kbGVGaWx0ZXJOb2RlIiwiaGFuZGxlQWNjZXNzQXR0cmlidXRlTm9kZSIsImF0dHJpYnV0ZUJhc2UiLCJoYW5kbGVBY2Nlc3NBdHRyaWJ1dGVCYXNlIiwiaGFuZGxlQWNjZXNzRWxlbWVudE5vZGUiLCJoYW5kbGVBcnJheU5vZGUiLCJlbCIsImhhbmRsZVZhbHVlTm9kZSIsImhhbmRsZVNsaWNlIiwiaGFuZGxlUGFyZW50Tm9kZSIsImhhbmRsZU5vdE5vZGUiLCJoYW5kbGVOZWdOb2RlIiwiaGFuZGxlUG9zTm9kZSIsImhhbmRsZUV2ZXJ5dGhpbmdOb2RlIiwiaGFuZGxlQW5kTm9kZSIsImhhbmRsZU9yTm9kZSIsIk9WRVJSSURFX1RZUEVfU1lNQk9MIiwib3BjYWxsIiwiZmlsdGVyZWQiLCJzdWJTY29wZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;