"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sanity-diff-patch";
exports.ids = ["vendor-chunks/sanity-diff-patch"];
exports.modules = {

/***/ "(ssr)/./node_modules/sanity-diff-patch/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/sanity-diff-patch/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiffError: () => (/* binding */ DiffError),\n/* harmony export */   diffItem: () => (/* binding */ diffItem),\n/* harmony export */   diffPatch: () => (/* binding */ diffPatch)\n/* harmony export */ });\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.js\");\n\nconst IS_DOTTABLE_RE = /^[A-Za-z_][A-Za-z0-9_]*$/;\nfunction pathToString(path) {\n    return path.reduce((target, segment, i)=>{\n        if (Array.isArray(segment)) return `${target}[${segment.join(\":\")}]`;\n        if (isKeyedObject(segment)) return `${target}[_key==\"${segment._key}\"]`;\n        if (typeof segment == \"number\") return `${target}[${segment}]`;\n        if (typeof segment == \"string\" && !IS_DOTTABLE_RE.test(segment)) return `${target}['${segment}']`;\n        if (typeof segment == \"string\") return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n        throw new Error(`Unsupported path segment \"${segment}\"`);\n    }, \"\");\n}\nfunction isKeyedObject(obj) {\n    return typeof obj == \"object\" && typeof obj._key == \"string\";\n}\nclass DiffError extends Error {\n    constructor(message, path, value){\n        const serializedPath = pathToString(path);\n        super(`${message} (at '${serializedPath}')`), this.path = path, this.serializedPath = serializedPath, this.value = value;\n    }\n}\nconst idPattern = /^[a-z0-9][a-z0-9_.-]+$/i, propPattern = /^[a-zA-Z_][a-zA-Z0-9_-]*$/, propStartPattern = /^[a-z_]/i;\nfunction validateProperty(property, value, path) {\n    if (!propStartPattern.test(property)) throw new DiffError(\"Keys must start with a letter (a-z)\", path.concat(property), value);\n    if (!propPattern.test(property)) throw new DiffError(\"Keys can only contain letters, numbers and underscores\", path.concat(property), value);\n    if (property === \"_key\" || property === \"_ref\" || property === \"_type\") {\n        if (typeof value != \"string\") throw new DiffError(\"Keys must be strings\", path.concat(property), value);\n        if (!idPattern.test(value)) throw new DiffError(\"Invalid key - use less exotic characters\", path.concat(property), value);\n    }\n    return property;\n}\nconst ignoredKeys = [\n    \"_id\",\n    \"_type\",\n    \"_createdAt\",\n    \"_updatedAt\",\n    \"_rev\"\n], defaultOptions = {\n    hideWarnings: !1,\n    diffMatchPatch: {\n        enabled: !0,\n        // Only use diff-match-patch if target string is longer than this threshold\n        lengthThresholdAbsolute: 30,\n        // Only use generated diff-match-patch if the patch length is less than or equal to\n        // (targetString * relative). Example: A 100 character target with a relative factor\n        // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,\n        // it will fall back to a regular `set` patch.\n        lengthThresholdRelative: 1.2\n    }\n};\nfunction mergeOptions(options) {\n    return {\n        ...defaultOptions,\n        ...options,\n        diffMatchPatch: {\n            ...defaultOptions.diffMatchPatch,\n            ...options.diffMatchPatch || {}\n        }\n    };\n}\nfunction diffPatch(itemA, itemB, opts) {\n    const options = mergeOptions(opts || {}), id = options.id || itemA._id === itemB._id && itemA._id, revisionLocked = options.ifRevisionID, ifRevisionID = typeof revisionLocked == \"boolean\" ? itemA._rev : revisionLocked, basePath = options.basePath || [];\n    if (!id) throw new Error(\"_id on itemA and itemB not present or differs, specify document id the mutations should be applied to\");\n    if (revisionLocked === !0 && !ifRevisionID) throw new Error(\"`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.\");\n    if (basePath.length === 0 && itemA._type !== itemB._type) throw new Error(`_type is immutable and cannot be changed (${itemA._type} => ${itemB._type})`);\n    const operations = diffItem(itemA, itemB, options, basePath, []);\n    return serializePatches(operations, {\n        id,\n        ifRevisionID: revisionLocked ? ifRevisionID : void 0\n    });\n}\nfunction diffItem(itemA, itemB, opts = defaultOptions, path = [], patches = []) {\n    if (itemA === itemB) return patches;\n    const aType = Array.isArray(itemA) ? \"array\" : typeof itemA, bType = Array.isArray(itemB) ? \"array\" : typeof itemB, aIsUndefined = aType === \"undefined\", bIsUndefined = bType === \"undefined\";\n    if (aIsUndefined && !bIsUndefined) return patches.push({\n        op: \"set\",\n        path,\n        value: itemB\n    }), patches;\n    if (!aIsUndefined && bIsUndefined) return patches.push({\n        op: \"unset\",\n        path\n    }), patches;\n    const options = mergeOptions(opts), dataType = aIsUndefined ? bType : aType;\n    return dataType === \"object\" || dataType === \"array\" ? aType !== bType ? (patches.push({\n        op: \"set\",\n        path,\n        value: itemB\n    }), patches) : dataType === \"array\" ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches) : diffPrimitive(itemA, itemB, options, path, patches);\n}\nfunction diffObject(itemA, itemB, options, path, patches) {\n    const atRoot = path.length === 0, aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map((key)=>validateProperty(key, itemA[key], path)), aKeysLength = aKeys.length, bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map((key)=>validateProperty(key, itemB[key], path)), bKeysLength = bKeys.length;\n    for(let i = 0; i < aKeysLength; i++){\n        const key = aKeys[i];\n        key in itemB || patches.push({\n            op: \"unset\",\n            path: path.concat(key)\n        });\n    }\n    for(let i = 0; i < bKeysLength; i++){\n        const key = bKeys[i];\n        diffItem(itemA[key], itemB[key], options, path.concat([\n            key\n        ]), patches);\n    }\n    return patches;\n}\nfunction diffArray(itemA, itemB, options, path, patches) {\n    if (itemB.length > itemA.length && patches.push({\n        op: \"insert\",\n        after: path.concat([\n            -1\n        ]),\n        items: itemB.slice(itemA.length).map((item, i)=>nullifyUndefined(item, path, i, options))\n    }), itemB.length < itemA.length) {\n        const isSingle = itemA.length - itemB.length === 1, unsetItems = itemA.slice(itemB.length);\n        isRevisionLocked(options) || !isUniquelyKeyed(unsetItems) ? patches.push({\n            op: \"unset\",\n            path: path.concat([\n                isSingle ? itemB.length : [\n                    itemB.length,\n                    \"\"\n                ]\n            ])\n        }) : patches.push(...unsetItems.map((item)=>({\n                op: \"unset\",\n                path: path.concat({\n                    _key: item._key\n                })\n            })));\n    }\n    for(let i = 0; i < itemB.length; i++)if (Array.isArray(itemB[i])) throw new DiffError(\"Multi-dimensional arrays not supported\", path.concat(i), itemB[i]);\n    const overlapping = Math.min(itemA.length, itemB.length), segmentA = itemA.slice(0, overlapping), segmentB = itemB.slice(0, overlapping);\n    return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);\n}\nfunction diffArrayByIndex(itemA, itemB, options, path, patches) {\n    for(let i = 0; i < itemA.length; i++)diffItem(itemA[i], nullifyUndefined(itemB[i], path, i, options), options, path.concat(i), patches);\n    return patches;\n}\nfunction diffArrayByKey(itemA, itemB, options, path, patches) {\n    const keyedA = indexByKey(itemA), keyedB = indexByKey(itemB);\n    if (!arrayIsEqual(keyedA.keys, keyedB.keys)) return diffArrayByIndex(itemA, itemB, options, path, patches);\n    for(let i = 0; i < keyedB.keys.length; i++){\n        const key = keyedB.keys[i], valueA = keyedA.index[key], valueB = nullifyUndefined(keyedB.index[key], path, i, options);\n        diffItem(valueA, valueB, options, path.concat({\n            _key: key\n        }), patches);\n    }\n    return patches;\n}\nfunction getDiffMatchPatch(itemA, itemB, options, path) {\n    const { enabled, lengthThresholdRelative, lengthThresholdAbsolute } = options.diffMatchPatch, segment = path[path.length - 1];\n    if (!enabled || // Don't use for anything but strings\n    typeof itemA != \"string\" || typeof itemB != \"string\" || // Don't use for `_key`, `_ref` etc\n    typeof segment == \"string\" && segment[0] === \"_\" || // Don't use on short strings\n    itemB.length < lengthThresholdAbsolute) return;\n    let strPatch = \"\";\n    try {\n        const patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.makeDiff)(itemA, itemB), diff = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.cleanupEfficiency)(patch);\n        strPatch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.stringifyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_0__.makePatches)(diff));\n    } catch  {\n        return;\n    }\n    return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : {\n        op: \"diffMatchPatch\",\n        path,\n        value: strPatch\n    };\n}\nfunction diffPrimitive(itemA, itemB, options, path, patches) {\n    const dmp = getDiffMatchPatch(itemA, itemB, options, path);\n    return patches.push(dmp || {\n        op: \"set\",\n        path,\n        value: itemB\n    }), patches;\n}\nfunction isNotIgnoredKey(key) {\n    return ignoredKeys.indexOf(key) === -1;\n}\nfunction serializePatches(patches, options) {\n    if (patches.length === 0) return [];\n    const { id, ifRevisionID } = options, set = patches.filter((patch)=>patch.op === \"set\"), unset = patches.filter((patch)=>patch.op === \"unset\"), insert = patches.filter((patch)=>patch.op === \"insert\"), dmp = patches.filter((patch)=>patch.op === \"diffMatchPatch\"), withSet = set.length > 0 && set.reduce((patch, item)=>{\n        const path = pathToString(item.path);\n        return patch.set[path] = item.value, patch;\n    }, {\n        id,\n        set: {}\n    }), withUnset = unset.length > 0 && unset.reduce((patch, item)=>{\n        const path = pathToString(item.path);\n        return patch.unset.push(path), patch;\n    }, {\n        id,\n        unset: []\n    }), withInsert = insert.reduce((acc, item)=>{\n        const after = pathToString(item.after);\n        return acc.concat({\n            id,\n            insert: {\n                after,\n                items: item.items\n            }\n        });\n    }, []), withDmp = dmp.length > 0 && dmp.reduce((patch, item)=>{\n        const path = pathToString(item.path);\n        return patch.diffMatchPatch[path] = item.value, patch;\n    }, {\n        id,\n        diffMatchPatch: {}\n    });\n    return [\n        withUnset,\n        withSet,\n        withDmp,\n        ...withInsert\n    ].filter((item)=>item !== !1).map((patch, i)=>({\n            patch: ifRevisionID && i === 0 ? {\n                ...patch,\n                ifRevisionID\n            } : patch\n        }));\n}\nfunction isUniquelyKeyed(arr) {\n    const keys = [];\n    for(let i = 0; i < arr.length; i++){\n        const key = getKey(arr[i]);\n        if (!key || keys.indexOf(key) !== -1) return !1;\n        keys.push(key);\n    }\n    return !0;\n}\nfunction getKey(obj) {\n    return typeof obj == \"object\" && obj !== null && obj._key;\n}\nfunction indexByKey(arr) {\n    return arr.reduce((acc, item)=>(acc.keys.push(item._key), acc.index[item._key] = item, acc), {\n        keys: [],\n        index: {}\n    });\n}\nfunction arrayIsEqual(itemA, itemB) {\n    return itemA.length === itemB.length && itemA.every((item, i)=>itemB[i] === item);\n}\nfunction nullifyUndefined(item, path, index, options) {\n    if (typeof item < \"u\") return item;\n    if (!options.hideWarnings) {\n        const serializedPath = pathToString(path.concat(index));\n        console.warn(`undefined value in array converted to null (at '${serializedPath}')`);\n    }\n    return null;\n}\nfunction isRevisionLocked(options) {\n    return !!options.ifRevisionID;\n}\nfunction yes(_) {\n    return !0;\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2FuaXR5LWRpZmYtcGF0Y2gvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNHO0FBQ3RHLE1BQU1JLGlCQUFpQjtBQUN2QixTQUFTQyxhQUFhQyxJQUFJO0lBQ3hCLE9BQU9BLEtBQUtDLE1BQU0sQ0FBQyxDQUFDQyxRQUFRQyxTQUFTQztRQUNuQyxJQUFJQyxNQUFNQyxPQUFPLENBQUNILFVBQ2hCLE9BQU8sQ0FBQyxFQUFFRCxPQUFPLENBQUMsRUFBRUMsUUFBUUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFDLElBQUlDLGNBQWNMLFVBQ2hCLE9BQU8sQ0FBQyxFQUFFRCxPQUFPLFFBQVEsRUFBRUMsUUFBUU0sSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUM3QyxJQUFJLE9BQU9OLFdBQVcsVUFDcEIsT0FBTyxDQUFDLEVBQUVELE9BQU8sQ0FBQyxFQUFFQyxRQUFRLENBQUMsQ0FBQztRQUNoQyxJQUFJLE9BQU9BLFdBQVcsWUFBWSxDQUFDTCxlQUFlWSxJQUFJLENBQUNQLFVBQ3JELE9BQU8sQ0FBQyxFQUFFRCxPQUFPLEVBQUUsRUFBRUMsUUFBUSxFQUFFLENBQUM7UUFDbEMsSUFBSSxPQUFPQSxXQUFXLFVBQ3BCLE9BQU8sQ0FBQyxFQUFFRCxPQUFPLEVBQUVFLE1BQU0sSUFBSSxLQUFLLElBQUksRUFBRUQsUUFBUSxDQUFDO1FBQ25ELE1BQU0sSUFBSVEsTUFBTSxDQUFDLDBCQUEwQixFQUFFUixRQUFRLENBQUMsQ0FBQztJQUN6RCxHQUFHO0FBQ0w7QUFDQSxTQUFTSyxjQUFjSSxHQUFHO0lBQ3hCLE9BQU8sT0FBT0EsT0FBTyxZQUFZLE9BQU9BLElBQUlILElBQUksSUFBSTtBQUN0RDtBQUNBLE1BQU1JLGtCQUFrQkY7SUFJdEJHLFlBQVlDLE9BQU8sRUFBRWYsSUFBSSxFQUFFZ0IsS0FBSyxDQUFFO1FBQ2hDLE1BQU1DLGlCQUFpQmxCLGFBQWFDO1FBQ3BDLEtBQUssQ0FBQyxDQUFDLEVB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QUMvQixFQUFFLEtBQUtzRTtBQUNoRjtBQUNBLFNBQVNDLGlCQUFpQkQsSUFBSSxFQUFFMUUsSUFBSSxFQUFFNEYsS0FBSyxFQUFFNUQsT0FBTztJQUNsRCxJQUFJLE9BQU8wQyxPQUFPLEtBQ2hCLE9BQU9BO0lBQ1QsSUFBSSxDQUFDMUMsUUFBUU4sWUFBWSxFQUFFO1FBQ3pCLE1BQU1ULGlCQUFpQmxCLGFBQWFDLEtBQUt1QixNQUFNLENBQUNxRTtRQUNoRG1CLFFBQVFDLElBQUksQ0FBQyxDQUFDLGdEQUFnRCxFQUFFL0YsZUFBZSxFQUFFLENBQUM7SUFDcEY7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTNkQsaUJBQWlCOUMsT0FBTztJQUMvQixPQUFPLENBQUMsQ0FBQ0EsUUFBUVEsWUFBWTtBQUMvQjtBQUNBLFNBQVN5QixJQUFJZ0QsQ0FBQztJQUNaLE9BQU8sQ0FBQztBQUNWO0FBS0UsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy9zYW5pdHktZGlmZi1wYXRjaC9kaXN0L2luZGV4LmpzP2IzY2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFrZURpZmYsIGNsZWFudXBFZmZpY2llbmN5LCBzdHJpbmdpZnlQYXRjaGVzLCBtYWtlUGF0Y2hlcyB9IGZyb20gXCJAc2FuaXR5L2RpZmYtbWF0Y2gtcGF0Y2hcIjtcbmNvbnN0IElTX0RPVFRBQkxFX1JFID0gL15bQS1aYS16X11bQS1aYS16MC05X10qJC87XG5mdW5jdGlvbiBwYXRoVG9TdHJpbmcocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoKHRhcmdldCwgc2VnbWVudCwgaSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNlZ21lbnQpKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bJHtzZWdtZW50LmpvaW4oXCI6XCIpfV1gO1xuICAgIGlmIChpc0tleWVkT2JqZWN0KHNlZ21lbnQpKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bX2tleT09XCIke3NlZ21lbnQuX2tleX1cIl1gO1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bJHtzZWdtZW50fV1gO1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiICYmICFJU19ET1RUQUJMRV9SRS50ZXN0KHNlZ21lbnQpKVxuICAgICAgcmV0dXJuIGAke3RhcmdldH1bJyR7c2VnbWVudH0nXWA7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fSR7aSA9PT0gMCA/IFwiXCIgOiBcIi5cIn0ke3NlZ21lbnR9YDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhdGggc2VnbWVudCBcIiR7c2VnbWVudH1cImApO1xuICB9LCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzS2V5ZWRPYmplY3Qob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iai5fa2V5ID09IFwic3RyaW5nXCI7XG59XG5jbGFzcyBEaWZmRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHBhdGg7XG4gIHZhbHVlO1xuICBzZXJpYWxpemVkUGF0aDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgdmFsdWUpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF0aCA9IHBhdGhUb1N0cmluZyhwYXRoKTtcbiAgICBzdXBlcihgJHttZXNzYWdlfSAoYXQgJyR7c2VyaWFsaXplZFBhdGh9JylgKSwgdGhpcy5wYXRoID0gcGF0aCwgdGhpcy5zZXJpYWxpemVkUGF0aCA9IHNlcmlhbGl6ZWRQYXRoLCB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cbmNvbnN0IGlkUGF0dGVybiA9IC9eW2EtejAtOV1bYS16MC05Xy4tXSskL2ksIHByb3BQYXR0ZXJuID0gL15bYS16QS1aX11bYS16QS1aMC05Xy1dKiQvLCBwcm9wU3RhcnRQYXR0ZXJuID0gL15bYS16X10vaTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCBwYXRoKSB7XG4gIGlmICghcHJvcFN0YXJ0UGF0dGVybi50ZXN0KHByb3BlcnR5KSlcbiAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiS2V5cyBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIgKGEteilcIiwgcGF0aC5jb25jYXQocHJvcGVydHkpLCB2YWx1ZSk7XG4gIGlmICghcHJvcFBhdHRlcm4udGVzdChwcm9wZXJ0eSkpXG4gICAgdGhyb3cgbmV3IERpZmZFcnJvcihcbiAgICAgIFwiS2V5cyBjYW4gb25seSBjb250YWluIGxldHRlcnMsIG51bWJlcnMgYW5kIHVuZGVyc2NvcmVzXCIsXG4gICAgICBwYXRoLmNvbmNhdChwcm9wZXJ0eSksXG4gICAgICB2YWx1ZVxuICAgICk7XG4gIGlmIChwcm9wZXJ0eSA9PT0gXCJfa2V5XCIgfHwgcHJvcGVydHkgPT09IFwiX3JlZlwiIHx8IHByb3BlcnR5ID09PSBcIl90eXBlXCIpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiS2V5cyBtdXN0IGJlIHN0cmluZ3NcIiwgcGF0aC5jb25jYXQocHJvcGVydHkpLCB2YWx1ZSk7XG4gICAgaWYgKCFpZFBhdHRlcm4udGVzdCh2YWx1ZSkpXG4gICAgICB0aHJvdyBuZXcgRGlmZkVycm9yKFwiSW52YWxpZCBrZXkgLSB1c2UgbGVzcyBleG90aWMgY2hhcmFjdGVyc1wiLCBwYXRoLmNvbmNhdChwcm9wZXJ0eSksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHk7XG59XG5jb25zdCBpZ25vcmVkS2V5cyA9IFtcIl9pZFwiLCBcIl90eXBlXCIsIFwiX2NyZWF0ZWRBdFwiLCBcIl91cGRhdGVkQXRcIiwgXCJfcmV2XCJdLCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaGlkZVdhcm5pbmdzOiAhMSxcbiAgZGlmZk1hdGNoUGF0Y2g6IHtcbiAgICBlbmFibGVkOiAhMCxcbiAgICAvLyBPbmx5IHVzZSBkaWZmLW1hdGNoLXBhdGNoIGlmIHRhcmdldCBzdHJpbmcgaXMgbG9uZ2VyIHRoYW4gdGhpcyB0aHJlc2hvbGRcbiAgICBsZW5ndGhUaHJlc2hvbGRBYnNvbHV0ZTogMzAsXG4gICAgLy8gT25seSB1c2UgZ2VuZXJhdGVkIGRpZmYtbWF0Y2gtcGF0Y2ggaWYgdGhlIHBhdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAvLyAodGFyZ2V0U3RyaW5nICogcmVsYXRpdmUpLiBFeGFtcGxlOiBBIDEwMCBjaGFyYWN0ZXIgdGFyZ2V0IHdpdGggYSByZWxhdGl2ZSBmYWN0b3JcbiAgICAvLyBvZiAxLjIgd2lsbCBhbGxvdyBhIDEyMCBjaGFyYWN0ZXIgZGlmZi1tYXRjaC1wYXRjaC4gSWYgbGFyZ2VyIHRoYW4gdGhpcyBudW1iZXIsXG4gICAgLy8gaXQgd2lsbCBmYWxsIGJhY2sgdG8gYSByZWd1bGFyIGBzZXRgIHBhdGNoLlxuICAgIGxlbmd0aFRocmVzaG9sZFJlbGF0aXZlOiAxLjJcbiAgfVxufTtcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBkaWZmTWF0Y2hQYXRjaDogeyAuLi5kZWZhdWx0T3B0aW9ucy5kaWZmTWF0Y2hQYXRjaCwgLi4ub3B0aW9ucy5kaWZmTWF0Y2hQYXRjaCB8fCB7fSB9XG4gIH07XG59XG5mdW5jdGlvbiBkaWZmUGF0Y2goaXRlbUEsIGl0ZW1CLCBvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0cyB8fCB7fSksIGlkID0gb3B0aW9ucy5pZCB8fCBpdGVtQS5faWQgPT09IGl0ZW1CLl9pZCAmJiBpdGVtQS5faWQsIHJldmlzaW9uTG9ja2VkID0gb3B0aW9ucy5pZlJldmlzaW9uSUQsIGlmUmV2aXNpb25JRCA9IHR5cGVvZiByZXZpc2lvbkxvY2tlZCA9PSBcImJvb2xlYW5cIiA/IGl0ZW1BLl9yZXYgOiByZXZpc2lvbkxvY2tlZCwgYmFzZVBhdGggPSBvcHRpb25zLmJhc2VQYXRoIHx8IFtdO1xuICBpZiAoIWlkKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiX2lkIG9uIGl0ZW1BIGFuZCBpdGVtQiBub3QgcHJlc2VudCBvciBkaWZmZXJzLCBzcGVjaWZ5IGRvY3VtZW50IGlkIHRoZSBtdXRhdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgdG9cIlxuICAgICk7XG4gIGlmIChyZXZpc2lvbkxvY2tlZCA9PT0gITAgJiYgIWlmUmV2aXNpb25JRClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImBpZlJldmlzaW9uSURgIGlzIHNldCB0byBgdHJ1ZWAsIGJ1dCBubyBgX3JldmAgd2FzIHBhc3NlZCBpbiBpdGVtIEEuIEVpdGhlciBleHBsaWNpdGx5IHNldCBgaWZSZXZpc2lvbklEYCB0byBhIHJldmlzaW9uLCBvciBwYXNzIGBfcmV2YCBhcyBwYXJ0IG9mIGl0ZW0gQS5cIlxuICAgICk7XG4gIGlmIChiYXNlUGF0aC5sZW5ndGggPT09IDAgJiYgaXRlbUEuX3R5cGUgIT09IGl0ZW1CLl90eXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihgX3R5cGUgaXMgaW1tdXRhYmxlIGFuZCBjYW5ub3QgYmUgY2hhbmdlZCAoJHtpdGVtQS5fdHlwZX0gPT4gJHtpdGVtQi5fdHlwZX0pYCk7XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBkaWZmSXRlbShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIGJhc2VQYXRoLCBbXSk7XG4gIHJldHVybiBzZXJpYWxpemVQYXRjaGVzKG9wZXJhdGlvbnMsIHsgaWQsIGlmUmV2aXNpb25JRDogcmV2aXNpb25Mb2NrZWQgPyBpZlJldmlzaW9uSUQgOiB2b2lkIDAgfSk7XG59XG5mdW5jdGlvbiBkaWZmSXRlbShpdGVtQSwgaXRlbUIsIG9wdHMgPSBkZWZhdWx0T3B0aW9ucywgcGF0aCA9IFtdLCBwYXRjaGVzID0gW10pIHtcbiAgaWYgKGl0ZW1BID09PSBpdGVtQilcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgY29uc3QgYVR5cGUgPSBBcnJheS5pc0FycmF5KGl0ZW1BKSA/IFwiYXJyYXlcIiA6IHR5cGVvZiBpdGVtQSwgYlR5cGUgPSBBcnJheS5pc0FycmF5KGl0ZW1CKSA/IFwiYXJyYXlcIiA6IHR5cGVvZiBpdGVtQiwgYUlzVW5kZWZpbmVkID0gYVR5cGUgPT09IFwidW5kZWZpbmVkXCIsIGJJc1VuZGVmaW5lZCA9IGJUeXBlID09PSBcInVuZGVmaW5lZFwiO1xuICBpZiAoYUlzVW5kZWZpbmVkICYmICFiSXNVbmRlZmluZWQpXG4gICAgcmV0dXJuIHBhdGNoZXMucHVzaCh7IG9wOiBcInNldFwiLCBwYXRoLCB2YWx1ZTogaXRlbUIgfSksIHBhdGNoZXM7XG4gIGlmICghYUlzVW5kZWZpbmVkICYmIGJJc1VuZGVmaW5lZClcbiAgICByZXR1cm4gcGF0Y2hlcy5wdXNoKHsgb3A6IFwidW5zZXRcIiwgcGF0aCB9KSwgcGF0Y2hlcztcbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRzKSwgZGF0YVR5cGUgPSBhSXNVbmRlZmluZWQgPyBiVHlwZSA6IGFUeXBlO1xuICByZXR1cm4gZGF0YVR5cGUgPT09IFwib2JqZWN0XCIgfHwgZGF0YVR5cGUgPT09IFwiYXJyYXlcIiA/IGFUeXBlICE9PSBiVHlwZSA/IChwYXRjaGVzLnB1c2goeyBvcDogXCJzZXRcIiwgcGF0aCwgdmFsdWU6IGl0ZW1CIH0pLCBwYXRjaGVzKSA6IGRhdGFUeXBlID09PSBcImFycmF5XCIgPyBkaWZmQXJyYXkoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSA6IGRpZmZPYmplY3QoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSA6IGRpZmZQcmltaXRpdmUoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKTtcbn1cbmZ1bmN0aW9uIGRpZmZPYmplY3QoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGNvbnN0IGF0Um9vdCA9IHBhdGgubGVuZ3RoID09PSAwLCBhS2V5cyA9IE9iamVjdC5rZXlzKGl0ZW1BKS5maWx0ZXIoYXRSb290ID8gaXNOb3RJZ25vcmVkS2V5IDogeWVzKS5tYXAoKGtleSkgPT4gdmFsaWRhdGVQcm9wZXJ0eShrZXksIGl0ZW1BW2tleV0sIHBhdGgpKSwgYUtleXNMZW5ndGggPSBhS2V5cy5sZW5ndGgsIGJLZXlzID0gT2JqZWN0LmtleXMoaXRlbUIpLmZpbHRlcihhdFJvb3QgPyBpc05vdElnbm9yZWRLZXkgOiB5ZXMpLm1hcCgoa2V5KSA9PiB2YWxpZGF0ZVByb3BlcnR5KGtleSwgaXRlbUJba2V5XSwgcGF0aCkpLCBiS2V5c0xlbmd0aCA9IGJLZXlzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhS2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gYUtleXNbaV07XG4gICAga2V5IGluIGl0ZW1CIHx8IHBhdGNoZXMucHVzaCh7IG9wOiBcInVuc2V0XCIsIHBhdGg6IHBhdGguY29uY2F0KGtleSkgfSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiS2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gYktleXNbaV07XG4gICAgZGlmZkl0ZW0oaXRlbUFba2V5XSwgaXRlbUJba2V5XSwgb3B0aW9ucywgcGF0aC5jb25jYXQoW2tleV0pLCBwYXRjaGVzKTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIGRpZmZBcnJheShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgaWYgKGl0ZW1CLmxlbmd0aCA+IGl0ZW1BLmxlbmd0aCAmJiBwYXRjaGVzLnB1c2goe1xuICAgIG9wOiBcImluc2VydFwiLFxuICAgIGFmdGVyOiBwYXRoLmNvbmNhdChbLTFdKSxcbiAgICBpdGVtczogaXRlbUIuc2xpY2UoaXRlbUEubGVuZ3RoKS5tYXAoKGl0ZW0sIGkpID0+IG51bGxpZnlVbmRlZmluZWQoaXRlbSwgcGF0aCwgaSwgb3B0aW9ucykpXG4gIH0pLCBpdGVtQi5sZW5ndGggPCBpdGVtQS5sZW5ndGgpIHtcbiAgICBjb25zdCBpc1NpbmdsZSA9IGl0ZW1BLmxlbmd0aCAtIGl0ZW1CLmxlbmd0aCA9PT0gMSwgdW5zZXRJdGVtcyA9IGl0ZW1BLnNsaWNlKGl0ZW1CLmxlbmd0aCk7XG4gICAgaXNSZXZpc2lvbkxvY2tlZChvcHRpb25zKSB8fCAhaXNVbmlxdWVseUtleWVkKHVuc2V0SXRlbXMpID8gcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBcInVuc2V0XCIsXG4gICAgICBwYXRoOiBwYXRoLmNvbmNhdChbaXNTaW5nbGUgPyBpdGVtQi5sZW5ndGggOiBbaXRlbUIubGVuZ3RoLCBcIlwiXV0pXG4gICAgfSkgOiBwYXRjaGVzLnB1c2goXG4gICAgICAuLi51bnNldEl0ZW1zLm1hcChcbiAgICAgICAgKGl0ZW0pID0+ICh7IG9wOiBcInVuc2V0XCIsIHBhdGg6IHBhdGguY29uY2F0KHsgX2tleTogaXRlbS5fa2V5IH0pIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1CLmxlbmd0aDsgaSsrKVxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1CW2ldKSlcbiAgICAgIHRocm93IG5ldyBEaWZmRXJyb3IoXCJNdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCBwYXRoLmNvbmNhdChpKSwgaXRlbUJbaV0pO1xuICBjb25zdCBvdmVybGFwcGluZyA9IE1hdGgubWluKGl0ZW1BLmxlbmd0aCwgaXRlbUIubGVuZ3RoKSwgc2VnbWVudEEgPSBpdGVtQS5zbGljZSgwLCBvdmVybGFwcGluZyksIHNlZ21lbnRCID0gaXRlbUIuc2xpY2UoMCwgb3ZlcmxhcHBpbmcpO1xuICByZXR1cm4gaXNVbmlxdWVseUtleWVkKHNlZ21lbnRBKSAmJiBpc1VuaXF1ZWx5S2V5ZWQoc2VnbWVudEIpID8gZGlmZkFycmF5QnlLZXkoc2VnbWVudEEsIHNlZ21lbnRCLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSA6IGRpZmZBcnJheUJ5SW5kZXgoc2VnbWVudEEsIHNlZ21lbnRCLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKTtcbn1cbmZ1bmN0aW9uIGRpZmZBcnJheUJ5SW5kZXgoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbUEubGVuZ3RoOyBpKyspXG4gICAgZGlmZkl0ZW0oXG4gICAgICBpdGVtQVtpXSxcbiAgICAgIG51bGxpZnlVbmRlZmluZWQoaXRlbUJbaV0sIHBhdGgsIGksIG9wdGlvbnMpLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHBhdGguY29uY2F0KGkpLFxuICAgICAgcGF0Y2hlc1xuICAgICk7XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gZGlmZkFycmF5QnlLZXkoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGNvbnN0IGtleWVkQSA9IGluZGV4QnlLZXkoaXRlbUEpLCBrZXllZEIgPSBpbmRleEJ5S2V5KGl0ZW1CKTtcbiAgaWYgKCFhcnJheUlzRXF1YWwoa2V5ZWRBLmtleXMsIGtleWVkQi5rZXlzKSlcbiAgICByZXR1cm4gZGlmZkFycmF5QnlJbmRleChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleWVkQi5rZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5ZWRCLmtleXNbaV0sIHZhbHVlQSA9IGtleWVkQS5pbmRleFtrZXldLCB2YWx1ZUIgPSBudWxsaWZ5VW5kZWZpbmVkKGtleWVkQi5pbmRleFtrZXldLCBwYXRoLCBpLCBvcHRpb25zKTtcbiAgICBkaWZmSXRlbSh2YWx1ZUEsIHZhbHVlQiwgb3B0aW9ucywgcGF0aC5jb25jYXQoeyBfa2V5OiBrZXkgfSksIHBhdGNoZXMpO1xuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gZ2V0RGlmZk1hdGNoUGF0Y2goaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoKSB7XG4gIGNvbnN0IHsgZW5hYmxlZCwgbGVuZ3RoVGhyZXNob2xkUmVsYXRpdmUsIGxlbmd0aFRocmVzaG9sZEFic29sdXRlIH0gPSBvcHRpb25zLmRpZmZNYXRjaFBhdGNoLCBzZWdtZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICBpZiAoIWVuYWJsZWQgfHwgLy8gRG9uJ3QgdXNlIGZvciBhbnl0aGluZyBidXQgc3RyaW5nc1xuICB0eXBlb2YgaXRlbUEgIT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgaXRlbUIgIT0gXCJzdHJpbmdcIiB8fCAvLyBEb24ndCB1c2UgZm9yIGBfa2V5YCwgYF9yZWZgIGV0Y1xuICB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiICYmIHNlZ21lbnRbMF0gPT09IFwiX1wiIHx8IC8vIERvbid0IHVzZSBvbiBzaG9ydCBzdHJpbmdzXG4gIGl0ZW1CLmxlbmd0aCA8IGxlbmd0aFRocmVzaG9sZEFic29sdXRlKVxuICAgIHJldHVybjtcbiAgbGV0IHN0clBhdGNoID0gXCJcIjtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXRjaCA9IG1ha2VEaWZmKGl0ZW1BLCBpdGVtQiksIGRpZmYgPSBjbGVhbnVwRWZmaWNpZW5jeShwYXRjaCk7XG4gICAgc3RyUGF0Y2ggPSBzdHJpbmdpZnlQYXRjaGVzKG1ha2VQYXRjaGVzKGRpZmYpKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBzdHJQYXRjaC5sZW5ndGggPiBpdGVtQi5sZW5ndGggKiBsZW5ndGhUaHJlc2hvbGRSZWxhdGl2ZSA/IHZvaWQgMCA6IHsgb3A6IFwiZGlmZk1hdGNoUGF0Y2hcIiwgcGF0aCwgdmFsdWU6IHN0clBhdGNoIH07XG59XG5mdW5jdGlvbiBkaWZmUHJpbWl0aXZlKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBjb25zdCBkbXAgPSBnZXREaWZmTWF0Y2hQYXRjaChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgpO1xuICByZXR1cm4gcGF0Y2hlcy5wdXNoKFxuICAgIGRtcCB8fCB7XG4gICAgICBvcDogXCJzZXRcIixcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZTogaXRlbUJcbiAgICB9XG4gICksIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBpc05vdElnbm9yZWRLZXkoa2V5KSB7XG4gIHJldHVybiBpZ25vcmVkS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUGF0Y2hlcyhwYXRjaGVzLCBvcHRpb25zKSB7XG4gIGlmIChwYXRjaGVzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHsgaWQsIGlmUmV2aXNpb25JRCB9ID0gb3B0aW9ucywgc2V0ID0gcGF0Y2hlcy5maWx0ZXIoKHBhdGNoKSA9PiBwYXRjaC5vcCA9PT0gXCJzZXRcIiksIHVuc2V0ID0gcGF0Y2hlcy5maWx0ZXIoKHBhdGNoKSA9PiBwYXRjaC5vcCA9PT0gXCJ1bnNldFwiKSwgaW5zZXJ0ID0gcGF0Y2hlcy5maWx0ZXIoKHBhdGNoKSA9PiBwYXRjaC5vcCA9PT0gXCJpbnNlcnRcIiksIGRtcCA9IHBhdGNoZXMuZmlsdGVyKChwYXRjaCkgPT4gcGF0Y2gub3AgPT09IFwiZGlmZk1hdGNoUGF0Y2hcIiksIHdpdGhTZXQgPSBzZXQubGVuZ3RoID4gMCAmJiBzZXQucmVkdWNlKFxuICAgIChwYXRjaCwgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgcGF0aCA9IHBhdGhUb1N0cmluZyhpdGVtLnBhdGgpO1xuICAgICAgcmV0dXJuIHBhdGNoLnNldFtwYXRoXSA9IGl0ZW0udmFsdWUsIHBhdGNoO1xuICAgIH0sXG4gICAgeyBpZCwgc2V0OiB7fSB9XG4gICksIHdpdGhVbnNldCA9IHVuc2V0Lmxlbmd0aCA+IDAgJiYgdW5zZXQucmVkdWNlKFxuICAgIChwYXRjaCwgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgcGF0aCA9IHBhdGhUb1N0cmluZyhpdGVtLnBhdGgpO1xuICAgICAgcmV0dXJuIHBhdGNoLnVuc2V0LnB1c2gocGF0aCksIHBhdGNoO1xuICAgIH0sXG4gICAgeyBpZCwgdW5zZXQ6IFtdIH1cbiAgKSwgd2l0aEluc2VydCA9IGluc2VydC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgIGNvbnN0IGFmdGVyID0gcGF0aFRvU3RyaW5nKGl0ZW0uYWZ0ZXIpO1xuICAgIHJldHVybiBhY2MuY29uY2F0KHsgaWQsIGluc2VydDogeyBhZnRlciwgaXRlbXM6IGl0ZW0uaXRlbXMgfSB9KTtcbiAgfSwgW10pLCB3aXRoRG1wID0gZG1wLmxlbmd0aCA+IDAgJiYgZG1wLnJlZHVjZShcbiAgICAocGF0Y2gsIGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHBhdGggPSBwYXRoVG9TdHJpbmcoaXRlbS5wYXRoKTtcbiAgICAgIHJldHVybiBwYXRjaC5kaWZmTWF0Y2hQYXRjaFtwYXRoXSA9IGl0ZW0udmFsdWUsIHBhdGNoO1xuICAgIH0sXG4gICAgeyBpZCwgZGlmZk1hdGNoUGF0Y2g6IHt9IH1cbiAgKTtcbiAgcmV0dXJuIFt3aXRoVW5zZXQsIHdpdGhTZXQsIHdpdGhEbXAsIC4uLndpdGhJbnNlcnRdLmZpbHRlcihcbiAgICAoaXRlbSkgPT4gaXRlbSAhPT0gITFcbiAgKS5tYXAoKHBhdGNoLCBpKSA9PiAoe1xuICAgIHBhdGNoOiBpZlJldmlzaW9uSUQgJiYgaSA9PT0gMCA/IHsgLi4ucGF0Y2gsIGlmUmV2aXNpb25JRCB9IDogcGF0Y2hcbiAgfSkpO1xufVxuZnVuY3Rpb24gaXNVbmlxdWVseUtleWVkKGFycikge1xuICBjb25zdCBrZXlzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGFycltpXSk7XG4gICAgaWYgKCFrZXkgfHwga2V5cy5pbmRleE9mKGtleSkgIT09IC0xKVxuICAgICAgcmV0dXJuICExO1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGdldEtleShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgb2JqLl9rZXk7XG59XG5mdW5jdGlvbiBpbmRleEJ5S2V5KGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZShcbiAgICAoYWNjLCBpdGVtKSA9PiAoYWNjLmtleXMucHVzaChpdGVtLl9rZXkpLCBhY2MuaW5kZXhbaXRlbS5fa2V5XSA9IGl0ZW0sIGFjYyksXG4gICAgeyBrZXlzOiBbXSwgaW5kZXg6IHt9IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGFycmF5SXNFcXVhbChpdGVtQSwgaXRlbUIpIHtcbiAgcmV0dXJuIGl0ZW1BLmxlbmd0aCA9PT0gaXRlbUIubGVuZ3RoICYmIGl0ZW1BLmV2ZXJ5KChpdGVtLCBpKSA9PiBpdGVtQltpXSA9PT0gaXRlbSk7XG59XG5mdW5jdGlvbiBudWxsaWZ5VW5kZWZpbmVkKGl0ZW0sIHBhdGgsIGluZGV4LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaXRlbSA8IFwidVwiKVxuICAgIHJldHVybiBpdGVtO1xuICBpZiAoIW9wdGlvbnMuaGlkZVdhcm5pbmdzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFBhdGggPSBwYXRoVG9TdHJpbmcocGF0aC5jb25jYXQoaW5kZXgpKTtcbiAgICBjb25zb2xlLndhcm4oYHVuZGVmaW5lZCB2YWx1ZSBpbiBhcnJheSBjb252ZXJ0ZWQgdG8gbnVsbCAoYXQgJyR7c2VyaWFsaXplZFBhdGh9JylgKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzUmV2aXNpb25Mb2NrZWQob3B0aW9ucykge1xuICByZXR1cm4gISFvcHRpb25zLmlmUmV2aXNpb25JRDtcbn1cbmZ1bmN0aW9uIHllcyhfKSB7XG4gIHJldHVybiAhMDtcbn1cbmV4cG9ydCB7XG4gIERpZmZFcnJvcixcbiAgZGlmZkl0ZW0sXG4gIGRpZmZQYXRjaFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIm1ha2VEaWZmIiwiY2xlYW51cEVmZmljaWVuY3kiLCJzdHJpbmdpZnlQYXRjaGVzIiwibWFrZVBhdGNoZXMiLCJJU19ET1RUQUJMRV9SRSIsInBhdGhUb1N0cmluZyIsInBhdGgiLCJyZWR1Y2UiLCJ0YXJnZXQiLCJzZWdtZW50IiwiaSIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJpc0tleWVkT2JqZWN0IiwiX2tleSIsInRlc3QiLCJFcnJvciIsIm9iaiIsIkRpZmZFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsInZhbHVlIiwic2VyaWFsaXplZFBhdGgiLCJpZFBhdHRlcm4iLCJwcm9wUGF0dGVybiIsInByb3BTdGFydFBhdHRlcm4iLCJ2YWxpZGF0ZVByb3BlcnR5IiwicHJvcGVydHkiLCJjb25jYXQiLCJpZ25vcmVkS2V5cyIsImRlZmF1bHRPcHRpb25zIiwiaGlkZVdhcm5pbmdzIiwiZGlmZk1hdGNoUGF0Y2giLCJlbmFibGVkIiwibGVuZ3RoVGhyZXNob2xkQWJzb2x1dGUiLCJsZW5ndGhUaHJlc2hvbGRSZWxhdGl2ZSIsIm1lcmdlT3B0aW9ucyIsIm9wdGlvbnMiLCJkaWZmUGF0Y2giLCJpdGVtQSIsIml0ZW1CIiwib3B0cyIsImlkIiwiX2lkIiwicmV2aXNpb25Mb2NrZWQiLCJpZlJldmlzaW9uSUQiLCJfcmV2IiwiYmFzZVBhdGgiLCJsZW5ndGgiLCJfdHlwZSIsIm9wZXJhdGlvbnMiLCJkaWZmSXRlbSIsInNlcmlhbGl6ZVBhdGNoZXMiLCJwYXRjaGVzIiwiYVR5cGUiLCJiVHlwZSIsImFJc1VuZGVmaW5lZCIsImJJc1VuZGVmaW5lZCIsInB1c2giLCJvcCIsImRhdGFUeXBlIiwiZGlmZkFycmF5IiwiZGlmZk9iamVjdCIsImRpZmZQcmltaXRpdmUiLCJhdFJvb3QiLCJhS2V5cyIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJpc05vdElnbm9yZWRLZXkiLCJ5ZXMiLCJtYXAiLCJrZXkiLCJhS2V5c0xlbmd0aCIsImJLZXlzIiwiYktleXNMZW5ndGgiLCJhZnRlciIsIml0ZW1zIiwic2xpY2UiLCJpdGVtIiwibnVsbGlmeVVuZGVmaW5lZCIsImlzU2luZ2xlIiwidW5zZXRJdGVtcyIsImlzUmV2aXNpb25Mb2NrZWQiLCJpc1VuaXF1ZWx5S2V5ZWQiLCJvdmVybGFwcGluZyIsIk1hdGgiLCJtaW4iLCJzZWdtZW50QSIsInNlZ21lbnRCIiwiZGlmZkFycmF5QnlLZXkiLCJkaWZmQXJyYXlCeUluZGV4Iiwia2V5ZWRBIiwiaW5kZXhCeUtleSIsImtleWVkQiIsImFycmF5SXNFcXVhbCIsInZhbHVlQSIsImluZGV4IiwidmFsdWVCIiwiZ2V0RGlmZk1hdGNoUGF0Y2giLCJzdHJQYXRjaCIsInBhdGNoIiwiZGlmZiIsImRtcCIsImluZGV4T2YiLCJzZXQiLCJ1bnNldCIsImluc2VydCIsIndpdGhTZXQiLCJ3aXRoVW5zZXQiLCJ3aXRoSW5zZXJ0IiwiYWNjIiwid2l0aERtcCIsImFyciIsImdldEtleSIsImV2ZXJ5IiwiY29uc29sZSIsIndhcm4iLCJfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sanity-diff-patch/dist/index.js\n");

/***/ })

};
;