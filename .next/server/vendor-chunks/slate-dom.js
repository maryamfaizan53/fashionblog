"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-dom";
exports.ids = ["vendor-chunks/slate-dom"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate-dom/dist/index.es.js":
/*!*************************************************!*\
  !*** ./node_modules/slate-dom/dist/index.es.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   DOMEditor: () => (/* binding */ DOMEditor),\n/* harmony export */   DOMElement: () => (/* binding */ DOMElement),\n/* harmony export */   DOMNode: () => (/* binding */ DOMNode),\n/* harmony export */   DOMRange: () => (/* binding */ DOMRange),\n/* harmony export */   DOMSelection: () => (/* binding */ DOMSelection),\n/* harmony export */   DOMStaticRange: () => (/* binding */ DOMStaticRange),\n/* harmony export */   DOMText: () => (/* binding */ DOMText),\n/* harmony export */   EDITOR_TO_ELEMENT: () => (/* binding */ EDITOR_TO_ELEMENT),\n/* harmony export */   EDITOR_TO_FORCE_RENDER: () => (/* binding */ EDITOR_TO_FORCE_RENDER),\n/* harmony export */   EDITOR_TO_KEY_TO_ELEMENT: () => (/* binding */ EDITOR_TO_KEY_TO_ELEMENT),\n/* harmony export */   EDITOR_TO_ON_CHANGE: () => (/* binding */ EDITOR_TO_ON_CHANGE),\n/* harmony export */   EDITOR_TO_PENDING_ACTION: () => (/* binding */ EDITOR_TO_PENDING_ACTION),\n/* harmony export */   EDITOR_TO_PENDING_DIFFS: () => (/* binding */ EDITOR_TO_PENDING_DIFFS),\n/* harmony export */   EDITOR_TO_PENDING_INSERTION_MARKS: () => (/* binding */ EDITOR_TO_PENDING_INSERTION_MARKS),\n/* harmony export */   EDITOR_TO_PENDING_SELECTION: () => (/* binding */ EDITOR_TO_PENDING_SELECTION),\n/* harmony export */   EDITOR_TO_PLACEHOLDER_ELEMENT: () => (/* binding */ EDITOR_TO_PLACEHOLDER_ELEMENT),\n/* harmony export */   EDITOR_TO_SCHEDULE_FLUSH: () => (/* binding */ EDITOR_TO_SCHEDULE_FLUSH),\n/* harmony export */   EDITOR_TO_USER_MARKS: () => (/* binding */ EDITOR_TO_USER_MARKS),\n/* harmony export */   EDITOR_TO_USER_SELECTION: () => (/* binding */ EDITOR_TO_USER_SELECTION),\n/* harmony export */   EDITOR_TO_WINDOW: () => (/* binding */ EDITOR_TO_WINDOW),\n/* harmony export */   ELEMENT_TO_NODE: () => (/* binding */ ELEMENT_TO_NODE),\n/* harmony export */   HAS_BEFORE_INPUT_SUPPORT: () => (/* binding */ HAS_BEFORE_INPUT_SUPPORT),\n/* harmony export */   Hotkeys: () => (/* binding */ hotkeys),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_COMPOSING: () => (/* binding */ IS_COMPOSING),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_FIREFOX_LEGACY: () => (/* binding */ IS_FIREFOX_LEGACY),\n/* harmony export */   IS_FOCUSED: () => (/* binding */ IS_FOCUSED),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_NODE_MAP_DIRTY: () => (/* binding */ IS_NODE_MAP_DIRTY),\n/* harmony export */   IS_READ_ONLY: () => (/* binding */ IS_READ_ONLY),\n/* harmony export */   IS_UC_MOBILE: () => (/* binding */ IS_UC_MOBILE),\n/* harmony export */   IS_WEBKIT: () => (/* binding */ IS_WEBKIT),\n/* harmony export */   IS_WECHATBROWSER: () => (/* binding */ IS_WECHATBROWSER),\n/* harmony export */   Key: () => (/* binding */ Key),\n/* harmony export */   MARK_PLACEHOLDER_SYMBOL: () => (/* binding */ MARK_PLACEHOLDER_SYMBOL),\n/* harmony export */   NODE_TO_ELEMENT: () => (/* binding */ NODE_TO_ELEMENT),\n/* harmony export */   NODE_TO_INDEX: () => (/* binding */ NODE_TO_INDEX),\n/* harmony export */   NODE_TO_KEY: () => (/* binding */ NODE_TO_KEY),\n/* harmony export */   NODE_TO_PARENT: () => (/* binding */ NODE_TO_PARENT),\n/* harmony export */   PLACEHOLDER_SYMBOL: () => (/* binding */ PLACEHOLDER_SYMBOL),\n/* harmony export */   TRIPLE_CLICK: () => (/* binding */ TRIPLE_CLICK),\n/* harmony export */   applyStringDiff: () => (/* binding */ applyStringDiff),\n/* harmony export */   getActiveElement: () => (/* binding */ getActiveElement),\n/* harmony export */   getDefaultView: () => (/* binding */ getDefaultView),\n/* harmony export */   getSelection: () => (/* binding */ getSelection),\n/* harmony export */   hasShadowRoot: () => (/* binding */ hasShadowRoot),\n/* harmony export */   isAfter: () => (/* binding */ isAfter),\n/* harmony export */   isBefore: () => (/* binding */ isBefore),\n/* harmony export */   isDOMElement: () => (/* binding */ isDOMElement),\n/* harmony export */   isDOMNode: () => (/* binding */ isDOMNode),\n/* harmony export */   isDOMSelection: () => (/* binding */ isDOMSelection),\n/* harmony export */   isElementDecorationsEqual: () => (/* binding */ isElementDecorationsEqual),\n/* harmony export */   isPlainTextOnlyPaste: () => (/* binding */ isPlainTextOnlyPaste),\n/* harmony export */   isTextDecorationsEqual: () => (/* binding */ isTextDecorationsEqual),\n/* harmony export */   isTrackedMutation: () => (/* binding */ isTrackedMutation),\n/* harmony export */   mergeStringDiffs: () => (/* binding */ mergeStringDiffs),\n/* harmony export */   normalizeDOMPoint: () => (/* binding */ normalizeDOMPoint),\n/* harmony export */   normalizePoint: () => (/* binding */ normalizePoint),\n/* harmony export */   normalizeRange: () => (/* binding */ normalizeRange),\n/* harmony export */   normalizeStringDiff: () => (/* binding */ normalizeStringDiff),\n/* harmony export */   targetRange: () => (/* binding */ targetRange),\n/* harmony export */   verifyDiffState: () => (/* binding */ verifyDiffState),\n/* harmony export */   withDOM: () => (/* binding */ withDOM)\n/* harmony export */ });\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/slate/dist/index.es.js\");\n/* harmony import */ var is_hotkey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-hotkey */ \"(ssr)/./node_modules/is-hotkey/lib/index.js\");\n\n\n/**\n * Types.\n */ // COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nvar DOMNode = globalThis.Node;\nvar DOMElement = globalThis.Element;\nvar DOMText = globalThis.Text;\nvar DOMRange = globalThis.Range;\nvar DOMSelection = globalThis.Selection;\nvar DOMStaticRange = globalThis.StaticRange;\n/**\n * Returns the host window of a DOM node\n */ var getDefaultView = (value)=>{\n    return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\n * Check if a DOM node is a comment node.\n */ var isDOMComment = (value)=>{\n    return isDOMNode(value) && value.nodeType === 8;\n};\n/**\n * Check if a DOM node is an element node.\n */ var isDOMElement = (value)=>{\n    return isDOMNode(value) && value.nodeType === 1;\n};\n/**\n * Check if a value is a DOM node.\n */ var isDOMNode = (value)=>{\n    var window1 = getDefaultView(value);\n    return !!window1 && value instanceof window1.Node;\n};\n/**\n * Check if a value is a DOM selection.\n */ var isDOMSelection = (value)=>{\n    var window1 = value && value.anchorNode && getDefaultView(value.anchorNode);\n    return !!window1 && value instanceof window1.Selection;\n};\n/**\n * Check if a DOM node is an element node.\n */ var isDOMText = (value)=>{\n    return isDOMNode(value) && value.nodeType === 3;\n};\n/**\n * Checks whether a paste event is a plaintext-only event.\n */ var isPlainTextOnlyPaste = (event)=>{\n    return event.clipboardData && event.clipboardData.getData(\"text/plain\") !== \"\" && event.clipboardData.types.length === 1;\n};\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */ var normalizeDOMPoint = (domPoint)=>{\n    var [node, offset] = domPoint;\n    // If it's an element node, its offset refers to the index of its children\n    // including comment nodes, so try to find the right text child node.\n    if (isDOMElement(node) && node.childNodes.length) {\n        var isLast = offset === node.childNodes.length;\n        var index = isLast ? offset - 1 : offset;\n        [node, index] = getEditableChildAndIndex(node, index, isLast ? \"backward\" : \"forward\");\n        // If the editable child found is in front of input offset, we instead seek to its end\n        isLast = index < offset;\n        // If the node has children, traverse until we have a leaf node. Leaf nodes\n        // can be either text nodes, or other void DOM nodes.\n        while(isDOMElement(node) && node.childNodes.length){\n            var i = isLast ? node.childNodes.length - 1 : 0;\n            node = getEditableChild(node, i, isLast ? \"backward\" : \"forward\");\n        }\n        // Determine the new offset inside the text node.\n        offset = isLast && node.textContent != null ? node.textContent.length : 0;\n    }\n    // Return the node and offset.\n    return [\n        node,\n        offset\n    ];\n};\n/**\n * Determines whether the active element is nested within a shadowRoot\n */ var hasShadowRoot = (node)=>{\n    var parent = node && node.parentNode;\n    while(parent){\n        if (parent.toString() === \"[object ShadowRoot]\") {\n            return true;\n        }\n        parent = parent.parentNode;\n    }\n    return false;\n};\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */ var getEditableChildAndIndex = (parent, index, direction)=>{\n    var { childNodes } = parent;\n    var child = childNodes[index];\n    var i = index;\n    var triedForward = false;\n    var triedBackward = false;\n    // While the child is a comment node, or an element node with no children,\n    // keep iterating to find a sibling non-void, non-comment node.\n    while(isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute(\"contenteditable\") === \"false\"){\n        if (triedForward && triedBackward) {\n            break;\n        }\n        if (i >= childNodes.length) {\n            triedForward = true;\n            i = index - 1;\n            direction = \"backward\";\n            continue;\n        }\n        if (i < 0) {\n            triedBackward = true;\n            i = index + 1;\n            direction = \"forward\";\n            continue;\n        }\n        child = childNodes[i];\n        index = i;\n        i += direction === \"forward\" ? 1 : -1;\n    }\n    return [\n        child,\n        index\n    ];\n};\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */ var getEditableChild = (parent, index, direction)=>{\n    var [child] = getEditableChildAndIndex(parent, index, direction);\n    return child;\n};\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */ var getPlainText = (domNode)=>{\n    var text = \"\";\n    if (isDOMText(domNode) && domNode.nodeValue) {\n        return domNode.nodeValue;\n    }\n    if (isDOMElement(domNode)) {\n        for (var childNode of Array.from(domNode.childNodes)){\n            text += getPlainText(childNode);\n        }\n        var display = getComputedStyle(domNode).getPropertyValue(\"display\");\n        if (display === \"block\" || display === \"list\" || domNode.tagName === \"BR\") {\n            text += \"\\n\";\n        }\n    }\n    return text;\n};\n/**\n * Get x-slate-fragment attribute from data-slate-fragment\n */ var catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = (dataTransfer)=>{\n    var htmlData = dataTransfer.getData(\"text/html\");\n    var [, fragment] = htmlData.match(catchSlateFragment) || [];\n    return fragment;\n};\n/**\n * Get the dom selection from Shadow Root if possible, otherwise from the document\n */ var getSelection = (root)=>{\n    if (root.getSelection != null) {\n        return root.getSelection();\n    }\n    return document.getSelection();\n};\n/**\n * Check whether a mutation originates from a editable element inside the editor.\n */ var isTrackedMutation = (editor, mutation, batch)=>{\n    var { target } = mutation;\n    if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n        return false;\n    }\n    var { document: document1 } = DOMEditor.getWindow(editor);\n    if (document1.contains(target)) {\n        return DOMEditor.hasDOMNode(editor, target, {\n            editable: true\n        });\n    }\n    var parentMutation = batch.find((_ref)=>{\n        var { addedNodes, removedNodes } = _ref;\n        for (var node of addedNodes){\n            if (node === target || node.contains(target)) {\n                return true;\n            }\n        }\n        for (var _node of removedNodes){\n            if (_node === target || _node.contains(target)) {\n                return true;\n            }\n        }\n    });\n    if (!parentMutation || parentMutation === mutation) {\n        return false;\n    }\n    // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n    return isTrackedMutation(editor, parentMutation, batch);\n};\n/**\n * Retrieves the deepest active element in the DOM, considering nested shadow DOMs.\n */ var getActiveElement = ()=>{\n    var activeElement = document.activeElement;\n    while((_activeElement = activeElement) !== null && _activeElement !== void 0 && _activeElement.shadowRoot && (_activeElement$shadow = activeElement.shadowRoot) !== null && _activeElement$shadow !== void 0 && _activeElement$shadow.activeElement){\n        var _activeElement, _activeElement$shadow, _activeElement2;\n        activeElement = (_activeElement2 = activeElement) === null || _activeElement2 === void 0 || (_activeElement2 = _activeElement2.shadowRoot) === null || _activeElement2 === void 0 ? void 0 : _activeElement2.activeElement;\n    }\n    return activeElement;\n};\n/**\n * @returns `true` if `otherNode` is before `node` in the document; otherwise, `false`.\n */ var isBefore = (node, otherNode)=>Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_PRECEDING);\n/**\n * @returns `true` if `otherNode` is after `node` in the document; otherwise, `false`.\n */ var isAfter = (node, otherNode)=>Boolean(node.compareDocumentPosition(otherNode) & DOMNode.DOCUMENT_POSITION_FOLLOWING);\nvar _navigator$userAgent$, _navigator$userAgent$2;\nvar IS_IOS = typeof navigator !== \"undefined\" && \"undefined\" !== \"undefined\" && 0 && 0;\nvar IS_APPLE = typeof navigator !== \"undefined\" && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== \"undefined\" && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== \"undefined\" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_WEBKIT = typeof navigator !== \"undefined\" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent);\n// \"modern\" Edge was released at 79.x\nvar IS_EDGE_LEGACY = typeof navigator !== \"undefined\" && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== \"undefined\" && /Chrome/i.test(navigator.userAgent);\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nvar IS_CHROME_LEGACY = typeof navigator !== \"undefined\" && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== \"undefined\" && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent);\n// Firefox did not support `beforeInput` until `v87`.\nvar IS_FIREFOX_LEGACY = typeof navigator !== \"undefined\" && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent);\n// UC mobile browser\nvar IS_UC_MOBILE = typeof navigator !== \"undefined\" && /.*UCBrowser/.test(navigator.userAgent);\n// Wechat browser (not including mac wechat)\nvar IS_WECHATBROWSER = typeof navigator !== \"undefined\" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent); // avoid lookbehind (buggy in safari < 16.4)\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nvar CAN_USE_DOM = !!( false && 0);\n// Check if the browser is Safari and older than 17\ntypeof navigator !== \"undefined\" && /Safari/.test(navigator.userAgent) && /Version\\/(\\d+)/.test(navigator.userAgent) && ((_navigator$userAgent$ = navigator.userAgent.match(/Version\\/(\\d+)/)) !== null && _navigator$userAgent$ !== void 0 && _navigator$userAgent$[1] ? parseInt((_navigator$userAgent$2 = navigator.userAgent.match(/Version\\/(\\d+)/)) === null || _navigator$userAgent$2 === void 0 ? void 0 : _navigator$userAgent$2[1], 10) < 17 : false);\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers\ntypeof globalThis !== \"undefined\" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === \"function\";\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _toPrimitive(input, hint) {\n    if (_typeof(input) !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n/**\n * An auto-incrementing identifier for keys.\n */ var n = 0;\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */ class Key {\n    constructor(){\n        _defineProperty(this, \"id\", void 0);\n        this.id = \"\".concat(n++);\n    }\n}\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */ var IS_NODE_MAP_DIRTY = new WeakMap();\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */ var EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\n * Weak maps for storing editor-related state.\n */ var IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */ var EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\n * Weak maps for saving pending state on composition stage.\n */ var EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\n * Android input handling specific weak-maps\n */ var EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\n * Symbols.\n */ var PLACEHOLDER_SYMBOL = Symbol(\"placeholder\");\nvar MARK_PLACEHOLDER_SYMBOL = Symbol(\"mark-placeholder\");\n// eslint-disable-next-line no-redeclare\nvar DOMEditor = {\n    androidPendingDiffs: (editor)=>EDITOR_TO_PENDING_DIFFS.get(editor),\n    androidScheduleFlush: (editor)=>{\n        var _EDITOR_TO_SCHEDULE_F;\n        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n    },\n    blur: (editor)=>{\n        var el = DOMEditor.toDOMNode(editor, editor);\n        var root = DOMEditor.findDocumentOrShadowRoot(editor);\n        IS_FOCUSED.set(editor, false);\n        if (root.activeElement === el) {\n            el.blur();\n        }\n    },\n    deselect: (editor)=>{\n        var { selection } = editor;\n        var root = DOMEditor.findDocumentOrShadowRoot(editor);\n        var domSelection = getSelection(root);\n        if (domSelection && domSelection.rangeCount > 0) {\n            domSelection.removeAllRanges();\n        }\n        if (selection) {\n            slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.deselect(editor);\n        }\n    },\n    findDocumentOrShadowRoot: (editor)=>{\n        var el = DOMEditor.toDOMNode(editor, editor);\n        var root = el.getRootNode();\n        if (root instanceof Document || root instanceof ShadowRoot) {\n            return root;\n        }\n        return el.ownerDocument;\n    },\n    findEventRange: (editor, event)=>{\n        if (\"nativeEvent\" in event) {\n            event = event.nativeEvent;\n        }\n        var { clientX: x, clientY: y, target } = event;\n        if (x == null || y == null) {\n            throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n        }\n        var node = DOMEditor.toSlateNode(editor, event.target);\n        var path = DOMEditor.findPath(editor, node);\n        // If the drop target is inside a void node, move it into either the\n        // next or previous node, depending on which side the `x` and `y`\n        // coordinates are closest to.\n        if (slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(node) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isVoid(editor, node)) {\n            var rect = target.getBoundingClientRect();\n            var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n            var edge = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.point(editor, path, {\n                edge: isPrev ? \"start\" : \"end\"\n            });\n            var point = isPrev ? slate__WEBPACK_IMPORTED_MODULE_1__.Editor.before(editor, edge) : slate__WEBPACK_IMPORTED_MODULE_1__.Editor.after(editor, edge);\n            if (point) {\n                var _range = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, point);\n                return _range;\n            }\n        }\n        // Else resolve a range from the caret position where the drop occured.\n        var domRange;\n        var { document: document1 } = DOMEditor.getWindow(editor);\n        // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n        if (document1.caretRangeFromPoint) {\n            domRange = document1.caretRangeFromPoint(x, y);\n        } else {\n            var position = document1.caretPositionFromPoint(x, y);\n            if (position) {\n                domRange = document1.createRange();\n                domRange.setStart(position.offsetNode, position.offset);\n                domRange.setEnd(position.offsetNode, position.offset);\n            }\n        }\n        if (!domRange) {\n            throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n        }\n        // Resolve a Slate range from the DOM range.\n        var range = DOMEditor.toSlateRange(editor, domRange, {\n            exactMatch: false,\n            suppressThrow: false\n        });\n        return range;\n    },\n    findKey: (editor, node)=>{\n        var key = NODE_TO_KEY.get(node);\n        if (!key) {\n            key = new Key();\n            NODE_TO_KEY.set(node, key);\n        }\n        return key;\n    },\n    findPath: (editor, node)=>{\n        var path = [];\n        var child = node;\n        while(true){\n            var parent = NODE_TO_PARENT.get(child);\n            if (parent == null) {\n                if (slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isEditor(child)) {\n                    return path;\n                } else {\n                    break;\n                }\n            }\n            var i = NODE_TO_INDEX.get(child);\n            if (i == null) {\n                break;\n            }\n            path.unshift(i);\n            child = parent;\n        }\n        throw new Error(\"Unable to find the path for Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(node)));\n    },\n    focus: function focus(editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            retries: 5\n        };\n        // Return if already focused\n        if (IS_FOCUSED.get(editor)) {\n            return;\n        }\n        // Retry setting focus if the editor has pending operations.\n        // The DOM (selection) is unstable while changes are applied.\n        // Retry until retries are exhausted or editor is focused.\n        if (options.retries <= 0) {\n            throw new Error(\"Could not set focus, editor seems stuck with pending operations\");\n        }\n        if (editor.operations.length > 0) {\n            setTimeout(()=>{\n                DOMEditor.focus(editor, {\n                    retries: options.retries - 1\n                });\n            }, 10);\n            return;\n        }\n        var el = DOMEditor.toDOMNode(editor, editor);\n        var root = DOMEditor.findDocumentOrShadowRoot(editor);\n        if (root.activeElement !== el) {\n            // Ensure that the DOM selection state is set to the editor's selection\n            if (editor.selection && root instanceof Document) {\n                var domSelection = getSelection(root);\n                var domRange = DOMEditor.toDOMRange(editor, editor.selection);\n                domSelection === null || domSelection === void 0 || domSelection.removeAllRanges();\n                domSelection === null || domSelection === void 0 || domSelection.addRange(domRange);\n            }\n            // Create a new selection in the top of the document if missing\n            if (!editor.selection) {\n                slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.select(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.start(editor, []));\n            }\n            // IS_FOCUSED should be set before calling el.focus() to ensure that\n            // FocusedContext is updated to the correct value\n            IS_FOCUSED.set(editor, true);\n            el.focus({\n                preventScroll: true\n            });\n        }\n    },\n    getWindow: (editor)=>{\n        var window1 = EDITOR_TO_WINDOW.get(editor);\n        if (!window1) {\n            throw new Error(\"Unable to find a host window element for this editor\");\n        }\n        return window1;\n    },\n    hasDOMNode: function hasDOMNode(editor, target) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { editable = false } = options;\n        var editorEl = DOMEditor.toDOMNode(editor, editor);\n        var targetEl;\n        // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n        // target is originating from an internal \"restricted\" element (e.g. a\n        // stepper arrow on a number input). (2018/05/04)\n        // https://github.com/ianstormtaylor/slate/issues/1819\n        try {\n            targetEl = isDOMElement(target) ? target : target.parentElement;\n        } catch (err) {\n            if (err instanceof Error && !err.message.includes('Permission denied to access property \"nodeType\"')) {\n                throw err;\n            }\n        }\n        if (!targetEl) {\n            return false;\n        }\n        return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === \"boolean\" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n        // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n        targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute(\"data-slate-zero-width\"));\n    },\n    hasEditableTarget: (editor, target)=>isDOMNode(target) && DOMEditor.hasDOMNode(editor, target, {\n            editable: true\n        }),\n    hasRange: (editor, range)=>{\n        var { anchor, focus } = range;\n        return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, anchor.path) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, focus.path);\n    },\n    hasSelectableTarget: (editor, target)=>DOMEditor.hasEditableTarget(editor, target) || DOMEditor.isTargetInsideNonReadonlyVoid(editor, target),\n    hasTarget: (editor, target)=>isDOMNode(target) && DOMEditor.hasDOMNode(editor, target),\n    insertData: (editor, data)=>{\n        editor.insertData(data);\n    },\n    insertFragmentData: (editor, data)=>editor.insertFragmentData(data),\n    insertTextData: (editor, data)=>editor.insertTextData(data),\n    isComposing: (editor)=>{\n        return !!IS_COMPOSING.get(editor);\n    },\n    isFocused: (editor)=>!!IS_FOCUSED.get(editor),\n    isReadOnly: (editor)=>!!IS_READ_ONLY.get(editor),\n    isTargetInsideNonReadonlyVoid: (editor, target)=>{\n        if (IS_READ_ONLY.get(editor)) return false;\n        var slateNode = DOMEditor.hasTarget(editor, target) && DOMEditor.toSlateNode(editor, target);\n        return slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(slateNode) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isVoid(editor, slateNode);\n    },\n    setFragmentData: (editor, data, originEvent)=>editor.setFragmentData(data, originEvent),\n    toDOMNode: (editor, node)=>{\n        var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n        var domNode = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(DOMEditor.findKey(editor, node));\n        if (!domNode) {\n            throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(node)));\n        }\n        return domNode;\n    },\n    toDOMPoint: (editor, point)=>{\n        var [node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(editor, point.path);\n        var el = DOMEditor.toDOMNode(editor, node);\n        var domPoint;\n        // If we're inside a void node, force the offset to 0, otherwise the zero\n        // width spacing character will result in an incorrect offset of 1\n        if (slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(editor, {\n            at: point\n        })) {\n            point = {\n                path: point.path,\n                offset: 0\n            };\n        }\n        // For each leaf, we need to isolate its content, which means filtering\n        // to its direct text and zero-width spans. (We have to filter out any\n        // other siblings that may have been rendered alongside them.)\n        var selector = \"[data-slate-string], [data-slate-zero-width]\";\n        var texts = Array.from(el.querySelectorAll(selector));\n        var start = 0;\n        for(var i = 0; i < texts.length; i++){\n            var text = texts[i];\n            var domNode = text.childNodes[0];\n            if (domNode == null || domNode.textContent == null) {\n                continue;\n            }\n            var { length } = domNode.textContent;\n            var attr = text.getAttribute(\"data-slate-length\");\n            var trueLength = attr == null ? length : parseInt(attr, 10);\n            var end = start + trueLength;\n            // Prefer putting the selection inside the mark placeholder to ensure\n            // composed text is displayed with the correct marks.\n            var nextText = texts[i + 1];\n            if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute(\"data-slate-mark-placeholder\")) {\n                var _nextText$textContent;\n                var domText = nextText.childNodes[0];\n                domPoint = [\n                    // COMPAT: If we don't explicity set the dom point to be on the actual\n                    // dom text element, chrome will put the selection behind the actual dom\n                    // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n                    // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n                    // which will cause issues when scrolling to it.\n                    domText instanceof DOMText ? domText : nextText,\n                    (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith(\"\\uFEFF\") ? 1 : 0\n                ];\n                break;\n            }\n            if (point.offset <= end) {\n                var offset = Math.min(length, Math.max(0, point.offset - start));\n                domPoint = [\n                    domNode,\n                    offset\n                ];\n                break;\n            }\n            start = end;\n        }\n        if (!domPoint) {\n            throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(slate__WEBPACK_IMPORTED_MODULE_1__.Scrubber.stringify(point)));\n        }\n        return domPoint;\n    },\n    toDOMRange: (editor, range)=>{\n        var { anchor, focus } = range;\n        var isBackward = slate__WEBPACK_IMPORTED_MODULE_1__.Range.isBackward(range);\n        var domAnchor = DOMEditor.toDOMPoint(editor, anchor);\n        var domFocus = slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range) ? domAnchor : DOMEditor.toDOMPoint(editor, focus);\n        var window1 = DOMEditor.getWindow(editor);\n        var domRange = window1.document.createRange();\n        var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n        var [endNode, endOffset] = isBackward ? domAnchor : domFocus;\n        // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n        // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n        // adjust the offset accordingly.\n        var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n        var isStartAtZeroWidth = !!startEl.getAttribute(\"data-slate-zero-width\");\n        var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n        var isEndAtZeroWidth = !!endEl.getAttribute(\"data-slate-zero-width\");\n        domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n        domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n        return domRange;\n    },\n    toSlateNode: (editor, domNode)=>{\n        var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n        if (domEl && !domEl.hasAttribute(\"data-slate-node\")) {\n            domEl = domEl.closest(\"[data-slate-node]\");\n        }\n        var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n        if (!node) {\n            throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n        }\n        return node;\n    },\n    toSlatePoint: (editor, domPoint, options)=>{\n        var { exactMatch, suppressThrow, searchDirection = \"backward\" } = options;\n        var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n        var parentNode = nearestNode.parentNode;\n        var textNode = null;\n        var offset = 0;\n        if (parentNode) {\n            var _domNode$textContent, _domNode$textContent2;\n            var editorEl = DOMEditor.toDOMNode(editor, editor);\n            var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]');\n            // Need to ensure that the closest void node is actually a void node\n            // within this editor, and not a void node within some parent editor. This can happen\n            // if this editor is within a void node of another editor (\"nested editors\", like in\n            // the \"Editable Voids\" example on the docs site).\n            var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n            var potentialNonEditableNode = parentNode.closest('[contenteditable=\"false\"]');\n            var nonEditableNode = potentialNonEditableNode && editorEl.contains(potentialNonEditableNode) ? potentialNonEditableNode : null;\n            var leafNode = parentNode.closest(\"[data-slate-leaf]\");\n            var domNode = null;\n            // Calculate how far into the text node the `nearestNode` is, so that we\n            // can determine what the offset relative to the text node is.\n            if (leafNode) {\n                textNode = leafNode.closest('[data-slate-node=\"text\"]');\n                if (textNode) {\n                    var window1 = DOMEditor.getWindow(editor);\n                    var range = window1.document.createRange();\n                    range.setStart(textNode, 0);\n                    range.setEnd(nearestNode, nearestOffset);\n                    var contents = range.cloneContents();\n                    var removals = [\n                        ...Array.prototype.slice.call(contents.querySelectorAll(\"[data-slate-zero-width]\")),\n                        ...Array.prototype.slice.call(contents.querySelectorAll(\"[contenteditable=false]\"))\n                    ];\n                    removals.forEach((el)=>{\n                        // COMPAT: While composing at the start of a text node, some keyboards put\n                        // the text content inside the zero width space.\n                        if (IS_ANDROID && !exactMatch && el.hasAttribute(\"data-slate-zero-width\") && el.textContent.length > 0 && el.textContext !== \"\\uFEFF\") {\n                            if (el.textContent.startsWith(\"\\uFEFF\")) {\n                                el.textContent = el.textContent.slice(1);\n                            }\n                            return;\n                        }\n                        el.parentNode.removeChild(el);\n                    });\n                    // COMPAT: Edge has a bug where Range.prototype.toString() will\n                    // convert \\n into \\r\\n. The bug causes a loop when slate-dom\n                    // attempts to reposition its cursor to match the native position. Use\n                    // textContent.length instead.\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n                    offset = contents.textContent.length;\n                    domNode = textNode;\n                }\n            } else if (voidNode) {\n                // For void nodes, the element with the offset key will be a cousin, not an\n                // ancestor, so find it by going down from the nearest void parent and taking the\n                // first one that isn't inside a nested editor.\n                var leafNodes = voidNode.querySelectorAll(\"[data-slate-leaf]\");\n                for(var index = 0; index < leafNodes.length; index++){\n                    var current = leafNodes[index];\n                    if (DOMEditor.hasDOMNode(editor, current)) {\n                        leafNode = current;\n                        break;\n                    }\n                }\n                // COMPAT: In read-only editors the leaf is not rendered.\n                if (!leafNode) {\n                    offset = 1;\n                } else {\n                    textNode = leafNode.closest('[data-slate-node=\"text\"]');\n                    domNode = leafNode;\n                    offset = domNode.textContent.length;\n                    domNode.querySelectorAll(\"[data-slate-zero-width]\").forEach((el)=>{\n                        offset -= el.textContent.length;\n                    });\n                }\n            } else if (nonEditableNode) {\n                // Find the edge of the nearest leaf in `searchDirection`\n                var getLeafNodes = (node)=>node ? node.querySelectorAll(// Exclude leaf nodes in nested editors\n                    \"[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])\") : [];\n                var elementNode = nonEditableNode.closest('[data-slate-node=\"element\"]');\n                if (searchDirection === \"forward\") {\n                    var _leafNodes$find;\n                    var _leafNodes = [\n                        ...getLeafNodes(elementNode),\n                        ...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.nextElementSibling)\n                    ];\n                    leafNode = (_leafNodes$find = _leafNodes.find((leaf)=>isAfter(nonEditableNode, leaf))) !== null && _leafNodes$find !== void 0 ? _leafNodes$find : null;\n                } else {\n                    var _leafNodes2$findLast;\n                    var _leafNodes2 = [\n                        ...getLeafNodes(elementNode === null || elementNode === void 0 ? void 0 : elementNode.previousElementSibling),\n                        ...getLeafNodes(elementNode)\n                    ];\n                    leafNode = (_leafNodes2$findLast = _leafNodes2.findLast((leaf)=>isBefore(nonEditableNode, leaf))) !== null && _leafNodes2$findLast !== void 0 ? _leafNodes2$findLast : null;\n                }\n                if (leafNode) {\n                    textNode = leafNode.closest('[data-slate-node=\"text\"]');\n                    domNode = leafNode;\n                    if (searchDirection === \"forward\") {\n                        offset = 0;\n                    } else {\n                        offset = domNode.textContent.length;\n                        domNode.querySelectorAll(\"[data-slate-zero-width]\").forEach((el)=>{\n                            offset -= el.textContent.length;\n                        });\n                    }\n                }\n            }\n            if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,\n            // and we don't add it for line-breaks.\n            IS_ANDROID && domNode.getAttribute(\"data-slate-zero-width\") === \"z\" && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith(\"\\uFEFF\") && // COMPAT: If the parent node is a Slate zero-width space, editor is\n            // because the text node should have no characters. However, during IME\n            // composition the ASCII characters will be prepended to the zero-width\n            // space, so subtract 1 from the offset to account for the zero-width\n            // space character.\n            (parentNode.hasAttribute(\"data-slate-zero-width\") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n            // when the document ends with a new-line character. This results in the offset\n            // length being off by one, so we need to subtract one to account for this.\n            IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith(\"\\n\\n\"))) {\n                offset--;\n            }\n        }\n        if (IS_ANDROID && !textNode && !exactMatch) {\n            var node = parentNode.hasAttribute(\"data-slate-node\") ? parentNode : parentNode.closest(\"[data-slate-node]\");\n            if (node && DOMEditor.hasDOMNode(editor, node, {\n                editable: true\n            })) {\n                var _slateNode = DOMEditor.toSlateNode(editor, node);\n                var { path: _path, offset: _offset } = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.start(editor, DOMEditor.findPath(editor, _slateNode));\n                if (!node.querySelector(\"[data-slate-leaf]\")) {\n                    _offset = nearestOffset;\n                }\n                return {\n                    path: _path,\n                    offset: _offset\n                };\n            }\n        }\n        if (!textNode) {\n            if (suppressThrow) {\n                return null;\n            }\n            throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n        }\n        // COMPAT: If someone is clicking from one Slate editor into another,\n        // the select event fires twice, once for the old editor's `element`\n        // first, and then afterwards for the correct `element`. (2017/03/03)\n        var slateNode = DOMEditor.toSlateNode(editor, textNode);\n        var path = DOMEditor.findPath(editor, slateNode);\n        return {\n            path,\n            offset\n        };\n    },\n    toSlateRange: (editor, domRange, options)=>{\n        var _focusNode$textConten;\n        var { exactMatch, suppressThrow } = options;\n        var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n        var anchorNode;\n        var anchorOffset;\n        var focusNode;\n        var focusOffset;\n        var isCollapsed;\n        if (el) {\n            if (isDOMSelection(domRange)) {\n                // COMPAT: In firefox the normal seletion way does not work\n                // (https://github.com/ianstormtaylor/slate/pull/5486#issue-1820720223)\n                if (IS_FIREFOX && domRange.rangeCount > 1) {\n                    focusNode = domRange.focusNode; // Focus node works fine\n                    var firstRange = domRange.getRangeAt(0);\n                    var lastRange = domRange.getRangeAt(domRange.rangeCount - 1);\n                    // Here we are in the contenteditable mode of a table in firefox\n                    if (focusNode instanceof HTMLTableRowElement && firstRange.startContainer instanceof HTMLTableRowElement && lastRange.startContainer instanceof HTMLTableRowElement) {\n                        // HTMLElement, becouse Element is a slate element\n                        function getLastChildren(element) {\n                            if (element.childElementCount > 0) {\n                                return getLastChildren(element.children[0]);\n                            } else {\n                                return element;\n                            }\n                        }\n                        var firstNodeRow = firstRange.startContainer;\n                        var lastNodeRow = lastRange.startContainer;\n                        // This should never fail as \"The HTMLElement interface represents any HTML element.\"\n                        var firstNode = getLastChildren(firstNodeRow.children[firstRange.startOffset]);\n                        var lastNode = getLastChildren(lastNodeRow.children[lastRange.startOffset]);\n                        // Zero, as we allways take the right one as the anchor point\n                        focusOffset = 0;\n                        if (lastNode.childNodes.length > 0) {\n                            anchorNode = lastNode.childNodes[0];\n                        } else {\n                            anchorNode = lastNode;\n                        }\n                        if (firstNode.childNodes.length > 0) {\n                            focusNode = firstNode.childNodes[0];\n                        } else {\n                            focusNode = firstNode;\n                        }\n                        if (lastNode instanceof HTMLElement) {\n                            anchorOffset = lastNode.innerHTML.length;\n                        } else {\n                            // Fallback option\n                            anchorOffset = 0;\n                        }\n                    } else {\n                        // This is the read only mode of a firefox table\n                        // Right to left\n                        if (firstRange.startContainer === focusNode) {\n                            anchorNode = lastRange.endContainer;\n                            anchorOffset = lastRange.endOffset;\n                            focusOffset = firstRange.startOffset;\n                        } else {\n                            // Left to right\n                            anchorNode = firstRange.startContainer;\n                            anchorOffset = firstRange.endOffset;\n                            focusOffset = lastRange.startOffset;\n                        }\n                    }\n                } else {\n                    anchorNode = domRange.anchorNode;\n                    anchorOffset = domRange.anchorOffset;\n                    focusNode = domRange.focusNode;\n                    focusOffset = domRange.focusOffset;\n                }\n                // COMPAT: There's a bug in chrome that always returns `true` for\n                // `isCollapsed` for a Selection that comes from a ShadowRoot.\n                // (2020/08/08)\n                // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n                // IsCollapsed might not work in firefox, but this will\n                if (IS_CHROME && hasShadowRoot(anchorNode) || IS_FIREFOX) {\n                    isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n                } else {\n                    isCollapsed = domRange.isCollapsed;\n                }\n            } else {\n                anchorNode = domRange.startContainer;\n                anchorOffset = domRange.startOffset;\n                focusNode = domRange.endContainer;\n                focusOffset = domRange.endOffset;\n                isCollapsed = domRange.collapsed;\n            }\n        }\n        if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n            throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n        }\n        // COMPAT: Firefox sometimes includes an extra \\n (rendered by TextString\n        // when isTrailing is true) in the focusOffset, resulting in an invalid\n        // Slate point. (2023/11/01)\n        if (IS_FIREFOX && (_focusNode$textConten = focusNode.textContent) !== null && _focusNode$textConten !== void 0 && _focusNode$textConten.endsWith(\"\\n\\n\") && focusOffset === focusNode.textContent.length) {\n            focusOffset--;\n        }\n        var anchor = DOMEditor.toSlatePoint(editor, [\n            anchorNode,\n            anchorOffset\n        ], {\n            exactMatch,\n            suppressThrow\n        });\n        if (!anchor) {\n            return null;\n        }\n        var focusBeforeAnchor = isBefore(anchorNode, focusNode) || anchorNode === focusNode && focusOffset < anchorOffset;\n        var focus = isCollapsed ? anchor : DOMEditor.toSlatePoint(editor, [\n            focusNode,\n            focusOffset\n        ], {\n            exactMatch,\n            suppressThrow,\n            searchDirection: focusBeforeAnchor ? \"forward\" : \"backward\"\n        });\n        if (!focus) {\n            return null;\n        }\n        var range = {\n            anchor: anchor,\n            focus: focus\n        };\n        // if the selection is a hanging range that ends in a void\n        // and the DOM focus is an Element\n        // (meaning that the selection ends before the element)\n        // unhang the range to avoid mistakenly including the void\n        if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isExpanded(range) && slate__WEBPACK_IMPORTED_MODULE_1__.Range.isForward(range) && isDOMElement(focusNode) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(editor, {\n            at: range.focus,\n            mode: \"highest\"\n        })) {\n            range = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.unhangRange(editor, range, {\n                voids: true\n            });\n        }\n        return range;\n    }\n};\n/**\n * Check whether a text diff was applied in a way we can perform the pending action on /\n * recover the pending selection.\n */ function verifyDiffState(editor, textDiff) {\n    var { path, diff } = textDiff;\n    if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, path)) {\n        return false;\n    }\n    var node = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(node)) {\n        return false;\n    }\n    if (diff.start !== node.text.length || diff.text.length === 0) {\n        return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n    }\n    var nextPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.next(path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, nextPath)) {\n        return false;\n    }\n    var nextNode = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, nextPath);\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n    for(var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        diffs[_key - 1] = arguments[_key];\n    }\n    return diffs.reduce((text, diff)=>text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\nfunction longestCommonPrefixLength(str, another) {\n    var length = Math.min(str.length, another.length);\n    for(var i = 0; i < length; i++){\n        if (str.charAt(i) !== another.charAt(i)) {\n            return i;\n        }\n    }\n    return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n    var length = Math.min(str.length, another.length, max);\n    for(var i = 0; i < length; i++){\n        if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n            return i;\n        }\n    }\n    return length;\n}\n/**\n * Remove redundant changes from the diff so that it spans the minimal possible range\n */ function normalizeStringDiff(targetText, diff) {\n    var { start, end, text } = diff;\n    var removedText = targetText.slice(start, end);\n    var prefixLength = longestCommonPrefixLength(removedText, text);\n    var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n    var suffixLength = longestCommonSuffixLength(removedText, text, max);\n    var normalized = {\n        start: start + prefixLength,\n        end: end - suffixLength,\n        text: text.slice(prefixLength, text.length - suffixLength)\n    };\n    if (normalized.start === normalized.end && normalized.text.length === 0) {\n        return null;\n    }\n    return normalized;\n}\n/**\n * Return a string diff that is equivalent to applying b after a spanning the range of\n * both changes\n */ function mergeStringDiffs(targetText, a, b) {\n    var start = Math.min(a.start, b.start);\n    var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n    var applied = applyStringDiff(targetText, a, b);\n    var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n    var text = applied.slice(start, sliceEnd);\n    var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n    return normalizeStringDiff(targetText, {\n        start,\n        end,\n        text\n    });\n}\n/**\n * Get the slate range the text diff spans.\n */ function targetRange(textDiff) {\n    var { path, diff } = textDiff;\n    return {\n        anchor: {\n            path,\n            offset: diff.start\n        },\n        focus: {\n            path,\n            offset: diff.end\n        }\n    };\n}\n/**\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\n * the pending diffs. Since the pending diffs might have been inserted with different\n * marks we have to 'walk' the offset from the starting position to ensure we still\n * have a valid point inside the document\n */ function normalizePoint(editor, point) {\n    var { path, offset } = point;\n    if (!slate__WEBPACK_IMPORTED_MODULE_1__.Editor.hasPath(editor, path)) {\n        return null;\n    }\n    var leaf = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, path);\n    if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(leaf)) {\n        return null;\n    }\n    var parentBlock = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.above(editor, {\n        match: (n)=>slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isBlock(editor, n),\n        at: path\n    });\n    if (!parentBlock) {\n        return null;\n    }\n    while(offset > leaf.text.length){\n        var entry = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.next(editor, {\n            at: path,\n            match: slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText\n        });\n        if (!entry || !slate__WEBPACK_IMPORTED_MODULE_1__.Path.isDescendant(entry[1], parentBlock[1])) {\n            return null;\n        }\n        offset -= leaf.text.length;\n        leaf = entry[0];\n        path = entry[1];\n    }\n    return {\n        path,\n        offset\n    };\n}\n/**\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\n */ function normalizeRange(editor, range) {\n    var anchor = normalizePoint(editor, range.anchor);\n    if (!anchor) {\n        return null;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range)) {\n        return {\n            anchor,\n            focus: anchor\n        };\n    }\n    var focus = normalizePoint(editor, range.focus);\n    if (!focus) {\n        return null;\n    }\n    return {\n        anchor,\n        focus\n    };\n}\nfunction transformPendingPoint(editor, point, op) {\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n    var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find((_ref)=>{\n        var { path } = _ref;\n        return slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(path, point.path);\n    });\n    if (!textDiff || point.offset <= textDiff.diff.start) {\n        return slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(point, op, {\n            affinity: \"backward\"\n        });\n    }\n    var { diff } = textDiff;\n    // Point references location inside the diff => transform the point based on the location\n    // the diff will be applied to and add the offset inside the diff.\n    if (point.offset <= diff.start + diff.text.length) {\n        var _anchor = {\n            path: point.path,\n            offset: diff.start\n        };\n        var _transformed = slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(_anchor, op, {\n            affinity: \"backward\"\n        });\n        if (!_transformed) {\n            return null;\n        }\n        return {\n            path: _transformed.path,\n            offset: _transformed.offset + point.offset - diff.start\n        };\n    }\n    // Point references location after the diff\n    var anchor = {\n        path: point.path,\n        offset: point.offset - diff.text.length + diff.end - diff.start\n    };\n    var transformed = slate__WEBPACK_IMPORTED_MODULE_1__.Point.transform(anchor, op, {\n        affinity: \"backward\"\n    });\n    if (!transformed) {\n        return null;\n    }\n    if (op.type === \"split_node\" && slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n        return transformed;\n    }\n    return {\n        path: transformed.path,\n        offset: transformed.offset + diff.text.length - diff.end + diff.start\n    };\n}\nfunction transformPendingRange(editor, range, op) {\n    var anchor = transformPendingPoint(editor, range.anchor, op);\n    if (!anchor) {\n        return null;\n    }\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(range)) {\n        return {\n            anchor,\n            focus: anchor\n        };\n    }\n    var focus = transformPendingPoint(editor, range.focus, op);\n    if (!focus) {\n        return null;\n    }\n    return {\n        anchor,\n        focus\n    };\n}\nfunction transformTextDiff(textDiff, op) {\n    var { path, diff, id } = textDiff;\n    switch(op.type){\n        case \"insert_text\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.offset >= diff.end) {\n                    return textDiff;\n                }\n                if (op.offset <= diff.start) {\n                    return {\n                        diff: {\n                            start: op.text.length + diff.start,\n                            end: op.text.length + diff.end,\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start,\n                        end: diff.end + op.text.length,\n                        text: diff.text\n                    },\n                    id,\n                    path\n                };\n            }\n        case \"remove_text\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.offset >= diff.end) {\n                    return textDiff;\n                }\n                if (op.offset + op.text.length <= diff.start) {\n                    return {\n                        diff: {\n                            start: diff.start - op.text.length,\n                            end: diff.end - op.text.length,\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start,\n                        end: diff.end - op.text.length,\n                        text: diff.text\n                    },\n                    id,\n                    path\n                };\n            }\n        case \"split_node\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path) || op.position >= diff.end) {\n                    return {\n                        diff,\n                        id,\n                        path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op, {\n                            affinity: \"backward\"\n                        })\n                    };\n                }\n                if (op.position > diff.start) {\n                    return {\n                        diff: {\n                            start: diff.start,\n                            end: Math.min(op.position, diff.end),\n                            text: diff.text\n                        },\n                        id,\n                        path\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start - op.position,\n                        end: diff.end - op.position,\n                        text: diff.text\n                    },\n                    id,\n                    path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op, {\n                        affinity: \"forward\"\n                    })\n                };\n            }\n        case \"merge_node\":\n            {\n                if (!slate__WEBPACK_IMPORTED_MODULE_1__.Path.equals(op.path, path)) {\n                    return {\n                        diff,\n                        id,\n                        path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op)\n                    };\n                }\n                return {\n                    diff: {\n                        start: diff.start + op.position,\n                        end: diff.end + op.position,\n                        text: diff.text\n                    },\n                    id,\n                    path: slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op)\n                };\n            }\n    }\n    var newPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.transform(path, op);\n    if (!newPath) {\n        return null;\n    }\n    return {\n        diff,\n        path: newPath,\n        id\n    };\n}\n/**\n * Utilities for single-line deletion\n */ var doRectsIntersect = (rect, compareRect)=>{\n    var middle = (compareRect.top + compareRect.bottom) / 2;\n    return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = (editor, range1, range2)=>{\n    var rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect();\n    var rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();\n    return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */ var findCurrentLineRange = (editor, parentRange)=>{\n    var parentRangeBoundary = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Range.end(parentRange));\n    var positions = Array.from(slate__WEBPACK_IMPORTED_MODULE_1__.Editor.positions(editor, {\n        at: parentRange\n    }));\n    var left = 0;\n    var right = positions.length;\n    var middle = Math.floor(right / 2);\n    if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[left]), parentRangeBoundary)) {\n        return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[left], parentRangeBoundary);\n    }\n    if (positions.length < 2) {\n        return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n    }\n    while(middle !== positions.length && middle !== left){\n        if (areRangesSameLine(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n            right = middle;\n        } else {\n            left = middle;\n        }\n        middle = Math.floor((left + right) / 2);\n    }\n    return slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(editor, positions[right], parentRangeBoundary);\n};\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n/**\n * `withDOM` adds DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */ var withDOM = function withDOM(editor) {\n    var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"x-slate-fragment\";\n    var e = editor;\n    var { apply, onChange, deleteBackward, addMark, removeMark } = e;\n    // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n    // avoid collisions between editors in the DOM that share the same value.\n    EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n    e.addMark = (key, value)=>{\n        var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n        (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 || _EDITOR_TO_SCHEDULE_F();\n        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n            // Ensure the current pending diffs originating from changes before the addMark\n            // are applied with the current formatting\n            EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n        }\n        EDITOR_TO_USER_MARKS.delete(e);\n        addMark(key, value);\n    };\n    e.removeMark = (key)=>{\n        var _EDITOR_TO_PENDING_DI2;\n        if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n            // Ensure the current pending diffs originating from changes before the addMark\n            // are applied with the current formatting\n            EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n        }\n        EDITOR_TO_USER_MARKS.delete(e);\n        removeMark(key);\n    };\n    e.deleteBackward = (unit)=>{\n        if (unit !== \"line\") {\n            return deleteBackward(unit);\n        }\n        if (e.selection && slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(e.selection)) {\n            var parentBlockEntry = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.above(e, {\n                match: (n)=>slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(n) && slate__WEBPACK_IMPORTED_MODULE_1__.Editor.isBlock(e, n),\n                at: e.selection\n            });\n            if (parentBlockEntry) {\n                var [, parentBlockPath] = parentBlockEntry;\n                var parentElementRange = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.range(e, parentBlockPath, e.selection.anchor);\n                var currentLineRange = findCurrentLineRange(e, parentElementRange);\n                if (!slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(currentLineRange)) {\n                    slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.delete(e, {\n                        at: currentLineRange\n                    });\n                }\n            }\n        }\n    };\n    // This attempts to reset the NODE_TO_KEY entry to the correct value\n    // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n    e.apply = (op)=>{\n        var matches = [];\n        var pathRefMatches = [];\n        var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n        if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n            var transformed = pendingDiffs.map((textDiff)=>transformTextDiff(textDiff, op)).filter(Boolean);\n            EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n        }\n        var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n        if (pendingSelection) {\n            EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n        }\n        var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n        if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n            var at = slate__WEBPACK_IMPORTED_MODULE_1__.Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n            EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n                at\n            }) : null);\n        }\n        switch(op.type){\n            case \"insert_text\":\n            case \"remove_text\":\n            case \"set_node\":\n            case \"split_node\":\n                {\n                    matches.push(...getMatches(e, op.path));\n                    break;\n                }\n            case \"set_selection\":\n                {\n                    var _EDITOR_TO_USER_SELEC;\n                    // Selection was manually set, don't restore the user selection after the change.\n                    (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 || _EDITOR_TO_USER_SELEC.unref();\n                    EDITOR_TO_USER_SELECTION.delete(e);\n                    break;\n                }\n            case \"insert_node\":\n            case \"remove_node\":\n                {\n                    matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path)));\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var prevPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.previous(op.path);\n                    matches.push(...getMatches(e, prevPath));\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var commonPath = slate__WEBPACK_IMPORTED_MODULE_1__.Path.common(slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path), slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.newPath));\n                    matches.push(...getMatches(e, commonPath));\n                    var changedPath;\n                    if (slate__WEBPACK_IMPORTED_MODULE_1__.Path.isBefore(op.path, op.newPath)) {\n                        matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.path)));\n                        changedPath = op.newPath;\n                    } else {\n                        matches.push(...getMatches(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(op.newPath)));\n                        changedPath = op.path;\n                    }\n                    var changedNode = slate__WEBPACK_IMPORTED_MODULE_1__.Node.get(editor, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(changedPath));\n                    var changedNodeKey = DOMEditor.findKey(e, changedNode);\n                    var changedPathRef = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.pathRef(e, slate__WEBPACK_IMPORTED_MODULE_1__.Path.parent(changedPath));\n                    pathRefMatches.push([\n                        changedPathRef,\n                        changedNodeKey\n                    ]);\n                    break;\n                }\n        }\n        apply(op);\n        switch(op.type){\n            case \"insert_node\":\n            case \"remove_node\":\n            case \"merge_node\":\n            case \"move_node\":\n            case \"split_node\":\n                {\n                    IS_NODE_MAP_DIRTY.set(e, true);\n                }\n        }\n        for (var [path, key] of matches){\n            var [node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(e, path);\n            NODE_TO_KEY.set(node, key);\n        }\n        for (var [pathRef, _key] of pathRefMatches){\n            if (pathRef.current) {\n                var [_node] = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.node(e, pathRef.current);\n                NODE_TO_KEY.set(_node, _key);\n            }\n            pathRef.unref();\n        }\n    };\n    e.setFragmentData = (data)=>{\n        var { selection } = e;\n        if (!selection) {\n            return;\n        }\n        var [start, end] = slate__WEBPACK_IMPORTED_MODULE_1__.Range.edges(selection);\n        var startVoid = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(e, {\n            at: start.path\n        });\n        var endVoid = slate__WEBPACK_IMPORTED_MODULE_1__.Editor.void(e, {\n            at: end.path\n        });\n        if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isCollapsed(selection) && !startVoid) {\n            return;\n        }\n        // Create a fake selection so that we can add a Base64-encoded copy of the\n        // fragment to the HTML, to decode on future pastes.\n        var domRange = DOMEditor.toDOMRange(e, selection);\n        var contents = domRange.cloneContents();\n        var attach = contents.childNodes[0];\n        // Make sure attach is non-empty, since empty nodes will not get copied.\n        contents.childNodes.forEach((node)=>{\n            if (node.textContent && node.textContent.trim() !== \"\") {\n                attach = node;\n            }\n        });\n        // COMPAT: If the end node is a void node, we need to move the end of the\n        // range from the void node's spacer span, to the end of the void node's\n        // content, since the spacer is before void's content in the DOM.\n        if (endVoid) {\n            var [voidNode] = endVoid;\n            var r = domRange.cloneRange();\n            var domNode = DOMEditor.toDOMNode(e, voidNode);\n            r.setEndAfter(domNode);\n            contents = r.cloneContents();\n        }\n        // COMPAT: If the start node is a void node, we need to attach the encoded\n        // fragment to the void node's content node instead of the spacer, because\n        // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n        // most browsers. (2018/04/27)\n        if (startVoid) {\n            attach = contents.querySelector(\"[data-slate-spacer]\");\n        }\n        // Remove any zero-width space spans from the cloned DOM so that they don't\n        // show up elsewhere when pasted.\n        Array.from(contents.querySelectorAll(\"[data-slate-zero-width]\")).forEach((zw)=>{\n            var isNewline = zw.getAttribute(\"data-slate-zero-width\") === \"n\";\n            zw.textContent = isNewline ? \"\\n\" : \"\";\n        });\n        // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n        // in the HTML, and can be used for intra-Slate pasting. If it's a text\n        // node, wrap it in a `<span>` so we have something to set an attribute on.\n        if (isDOMText(attach)) {\n            var span = attach.ownerDocument.createElement(\"span\");\n            // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n            // then leading and trailing spaces will be ignored. (2017/09/21)\n            span.style.whiteSpace = \"pre\";\n            span.appendChild(attach);\n            contents.appendChild(span);\n            attach = span;\n        }\n        var fragment = e.getFragment();\n        var string = JSON.stringify(fragment);\n        var encoded = window.btoa(encodeURIComponent(string));\n        attach.setAttribute(\"data-slate-fragment\", encoded);\n        data.setData(\"application/\".concat(clipboardFormatKey), encoded);\n        // Add the content to a <div> so that we can get its inner HTML.\n        var div = contents.ownerDocument.createElement(\"div\");\n        div.appendChild(contents);\n        div.setAttribute(\"hidden\", \"true\");\n        contents.ownerDocument.body.appendChild(div);\n        data.setData(\"text/html\", div.innerHTML);\n        data.setData(\"text/plain\", getPlainText(div));\n        contents.ownerDocument.body.removeChild(div);\n        return data;\n    };\n    e.insertData = (data)=>{\n        if (!e.insertFragmentData(data)) {\n            e.insertTextData(data);\n        }\n    };\n    e.insertFragmentData = (data)=>{\n        /**\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\n     */ var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n        if (fragment) {\n            var decoded = decodeURIComponent(window.atob(fragment));\n            var parsed = JSON.parse(decoded);\n            e.insertFragment(parsed);\n            return true;\n        }\n        return false;\n    };\n    e.insertTextData = (data)=>{\n        var text = data.getData(\"text/plain\");\n        if (text) {\n            var lines = text.split(/\\r\\n|\\r|\\n/);\n            var split = false;\n            for (var line of lines){\n                if (split) {\n                    slate__WEBPACK_IMPORTED_MODULE_1__.Transforms.splitNodes(e, {\n                        always: true\n                    });\n                }\n                e.insertText(line);\n                split = true;\n            }\n            return true;\n        }\n        return false;\n    };\n    e.onChange = (options)=>{\n        var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n        if (onContextChange) {\n            onContextChange(options);\n        }\n        onChange(options);\n    };\n    return e;\n};\nvar getMatches = (e, path)=>{\n    var matches = [];\n    for (var [n, p] of slate__WEBPACK_IMPORTED_MODULE_1__.Editor.levels(e, {\n        at: path\n    })){\n        var key = DOMEditor.findKey(e, n);\n        matches.push([\n            p,\n            key\n        ]);\n    }\n    return matches;\n};\nvar TRIPLE_CLICK = 3;\n/**\n * Hotkey mappings for each platform.\n */ var HOTKEYS = {\n    bold: \"mod+b\",\n    compose: [\n        \"down\",\n        \"left\",\n        \"right\",\n        \"up\",\n        \"backspace\",\n        \"enter\"\n    ],\n    moveBackward: \"left\",\n    moveForward: \"right\",\n    moveWordBackward: \"ctrl+left\",\n    moveWordForward: \"ctrl+right\",\n    deleteBackward: \"shift?+backspace\",\n    deleteForward: \"shift?+delete\",\n    extendBackward: \"shift+left\",\n    extendForward: \"shift+right\",\n    italic: \"mod+i\",\n    insertSoftBreak: \"shift+enter\",\n    splitBlock: \"enter\",\n    undo: \"mod+z\"\n};\nvar APPLE_HOTKEYS = {\n    moveLineBackward: \"opt+up\",\n    moveLineForward: \"opt+down\",\n    moveWordBackward: \"opt+left\",\n    moveWordForward: \"opt+right\",\n    deleteBackward: [\n        \"ctrl+backspace\",\n        \"ctrl+h\"\n    ],\n    deleteForward: [\n        \"ctrl+delete\",\n        \"ctrl+d\"\n    ],\n    deleteLineBackward: \"cmd+shift?+backspace\",\n    deleteLineForward: [\n        \"cmd+shift?+delete\",\n        \"ctrl+k\"\n    ],\n    deleteWordBackward: \"opt+shift?+backspace\",\n    deleteWordForward: \"opt+shift?+delete\",\n    extendLineBackward: \"opt+shift+up\",\n    extendLineForward: \"opt+shift+down\",\n    redo: \"cmd+shift+z\",\n    transposeCharacter: \"ctrl+t\"\n};\nvar WINDOWS_HOTKEYS = {\n    deleteWordBackward: \"ctrl+shift?+backspace\",\n    deleteWordForward: \"ctrl+shift?+delete\",\n    redo: [\n        \"ctrl+y\",\n        \"ctrl+shift+z\"\n    ]\n};\n/**\n * Create a platform-aware hotkey checker.\n */ var create = (key)=>{\n    var generic = HOTKEYS[key];\n    var apple = APPLE_HOTKEYS[key];\n    var windows = WINDOWS_HOTKEYS[key];\n    var isGeneric = generic && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(generic);\n    var isApple = apple && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(apple);\n    var isWindows = windows && (0,is_hotkey__WEBPACK_IMPORTED_MODULE_0__.isHotkey)(windows);\n    return (event)=>{\n        if (isGeneric && isGeneric(event)) return true;\n        if (IS_APPLE && isApple && isApple(event)) return true;\n        if (!IS_APPLE && isWindows && isWindows(event)) return true;\n        return false;\n    };\n};\n/**\n * Hotkeys.\n */ var hotkeys = {\n    isBold: create(\"bold\"),\n    isCompose: create(\"compose\"),\n    isMoveBackward: create(\"moveBackward\"),\n    isMoveForward: create(\"moveForward\"),\n    isDeleteBackward: create(\"deleteBackward\"),\n    isDeleteForward: create(\"deleteForward\"),\n    isDeleteLineBackward: create(\"deleteLineBackward\"),\n    isDeleteLineForward: create(\"deleteLineForward\"),\n    isDeleteWordBackward: create(\"deleteWordBackward\"),\n    isDeleteWordForward: create(\"deleteWordForward\"),\n    isExtendBackward: create(\"extendBackward\"),\n    isExtendForward: create(\"extendForward\"),\n    isExtendLineBackward: create(\"extendLineBackward\"),\n    isExtendLineForward: create(\"extendLineForward\"),\n    isItalic: create(\"italic\"),\n    isMoveLineBackward: create(\"moveLineBackward\"),\n    isMoveLineForward: create(\"moveLineForward\"),\n    isMoveWordBackward: create(\"moveWordBackward\"),\n    isMoveWordForward: create(\"moveWordForward\"),\n    isRedo: create(\"redo\"),\n    isSoftBreak: create(\"insertSoftBreak\"),\n    isSplitBlock: create(\"splitBlock\"),\n    isTransposeCharacter: create(\"transposeCharacter\"),\n    isUndo: create(\"undo\")\n};\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar _excluded = [\n    \"anchor\",\n    \"focus\"\n], _excluded2 = [\n    \"anchor\",\n    \"focus\"\n];\nvar shallowCompare = (obj1, obj2)=>Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key)=>obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\nvar isDecorationFlagsEqual = (range, other)=>{\n    var rangeOwnProps = _objectWithoutProperties(range, _excluded);\n    var otherOwnProps = _objectWithoutProperties(other, _excluded2);\n    return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */ var isElementDecorationsEqual = (list, another)=>{\n    if (list.length !== another.length) {\n        return false;\n    }\n    for(var i = 0; i < list.length; i++){\n        var range = list[i];\n        var other = another[i];\n        if (!slate__WEBPACK_IMPORTED_MODULE_1__.Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */ var isTextDecorationsEqual = (list, another)=>{\n    if (list.length !== another.length) {\n        return false;\n    }\n    for(var i = 0; i < list.length; i++){\n        var range = list[i];\n        var other = another[i];\n        // compare only offsets because paths doesn't matter for text\n        if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n            return false;\n        }\n    }\n    return true;\n};\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUtZG9tL2Rpc3QvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEY7QUFDekQ7QUFFckM7O0NBRUMsR0FDRCw4RUFBOEU7QUFDOUUsNkVBQTZFO0FBQzdFLHVEQUF1RDtBQUN2RCxJQUFJVSxVQUFVQyxXQUFXTixJQUFJO0FBQzdCLElBQUlPLGFBQWFELFdBQVdWLE9BQU87QUFDbkMsSUFBSVksVUFBVUYsV0FBV0wsSUFBSTtBQUM3QixJQUFJUSxXQUFXSCxXQUFXUCxLQUFLO0FBQy9CLElBQUlXLGVBQWVKLFdBQVdLLFNBQVM7QUFDdkMsSUFBSUMsaUJBQWlCTixXQUFXTyxXQUFXO0FBQzNDOztDQUVDLEdBQ0QsSUFBSUMsaUJBQWlCQyxDQUFBQTtJQUNuQixPQUFPQSxTQUFTQSxNQUFNQyxhQUFhLElBQUlELE1BQU1DLGFBQWEsQ0FBQ0MsV0FBVyxJQUFJO0FBQzVFO0FBQ0E7O0NBRUMsR0FDRCxJQUFJQyxlQUFlSCxDQUFBQTtJQUNqQixPQUFPSSxVQUFVSixVQUFVQSxNQUFNSyxRQUFRLEtBQUs7QUFDaEQ7QUFDQTs7Q0FFQyxHQUNELElBQUlDLGVBQWVOLENBQUFBO0lBQ2pCLE9BQU9JLFVBQVVKLFVBQVVBLE1BQU1LLFFBQVEsS0FBSztBQUNoRDtBQUNBOztDQUVDLEdBQ0QsSUFBSUQsWUFBWUosQ0FBQUE7SUFDZCxJQUFJTyxVQUFTUixlQUFlQztJQUM1QixPQUFPLENBQUMsQ0FBQ08sV0FBVVAsaUJBQWlCTyxRQUFPdEIsSUFBSTtBQUNqRDtBQUNBOztDQUVDLEdBQ0QsSUFBSXVCLGlCQUFpQlIsQ0FBQUE7SUFDbkIsSUFBSU8sVUFBU1AsU0FBU0EsTUFBTVMsVUFBVSxJQUFJVixlQUFlQyxNQUFNUyxVQUFVO0lBQ3pFLE9BQU8sQ0FBQyxDQUFDRixXQUFVUCxpQkFBaUJPLFFB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WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMvc2xhdGUtZG9tL2Rpc3QvaW5kZXguZXMuanM/YzAyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc2Zvcm1zLCBFbGVtZW50LCBFZGl0b3IsIFNjcnViYmVyLCBSYW5nZSwgTm9kZSwgVGV4dCwgUGF0aCwgUG9pbnQgfSBmcm9tICdzbGF0ZSc7XG5pbXBvcnQgeyBpc0hvdGtleSB9IGZyb20gJ2lzLWhvdGtleSc7XG5cbi8qKlxuICogVHlwZXMuXG4gKi9cbi8vIENPTVBBVDogVGhpcyBpcyByZXF1aXJlZCB0byBwcmV2ZW50IFR5cGVTY3JpcHQgYWxpYXNlcyBmcm9tIGRvaW5nIHNvbWUgdmVyeVxuLy8gd2VpcmQgdGhpbmdzIGZvciBTbGF0ZSdzIHR5cGVzIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBnbG9iYWxzLiAoMjAxOS8xMS8yNylcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzUwMDJcbnZhciBET01Ob2RlID0gZ2xvYmFsVGhpcy5Ob2RlO1xudmFyIERPTUVsZW1lbnQgPSBnbG9iYWxUaGlzLkVsZW1lbnQ7XG52YXIgRE9NVGV4dCA9IGdsb2JhbFRoaXMuVGV4dDtcbnZhciBET01SYW5nZSA9IGdsb2JhbFRoaXMuUmFuZ2U7XG52YXIgRE9NU2VsZWN0aW9uID0gZ2xvYmFsVGhpcy5TZWxlY3Rpb247XG52YXIgRE9NU3RhdGljUmFuZ2UgPSBnbG9iYWxUaGlzLlN0YXRpY1JhbmdlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBob3N0IHdpbmRvdyBvZiBhIERPTSBub2RlXG4gKi9cbnZhciBnZXREZWZhdWx0VmlldyA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm93bmVyRG9jdW1lbnQgJiYgdmFsdWUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCBudWxsO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhIGNvbW1lbnQgbm9kZS5cbiAqL1xudmFyIGlzRE9NQ29tbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDg7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGFuIGVsZW1lbnQgbm9kZS5cbiAqL1xudmFyIGlzRE9NRWxlbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgRE9NIG5vZGUuXG4gKi9cbnZhciBpc0RPTU5vZGUgPSB2YWx1ZSA9PiB7XG4gIHZhciB3aW5kb3cgPSBnZXREZWZhdWx0Vmlldyh2YWx1ZSk7XG4gIHJldHVybiAhIXdpbmRvdyAmJiB2YWx1ZSBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIERPTSBzZWxlY3Rpb24uXG4gKi9cbnZhciBpc0RPTVNlbGVjdGlvbiA9IHZhbHVlID0+IHtcbiAgdmFyIHdpbmRvdyA9IHZhbHVlICYmIHZhbHVlLmFuY2hvck5vZGUgJiYgZ2V0RGVmYXVsdFZpZXcodmFsdWUuYW5jaG9yTm9kZSk7XG4gIHJldHVybiAhIXdpbmRvdyAmJiB2YWx1ZSBpbnN0YW5jZW9mIHdpbmRvdy5TZWxlY3Rpb247XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGFuIGVsZW1lbnQgbm9kZS5cbiAqL1xudmFyIGlzRE9NVGV4dCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDM7XG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHBhc3RlIGV2ZW50IGlzIGEgcGxhaW50ZXh0LW9ubHkgZXZlbnQuXG4gKi9cbnZhciBpc1BsYWluVGV4dE9ubHlQYXN0ZSA9IGV2ZW50ID0+IHtcbiAgcmV0dXJuIGV2ZW50LmNsaXBib2FyZERhdGEgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJykgIT09ICcnICYmIGV2ZW50LmNsaXBib2FyZERhdGEudHlwZXMubGVuZ3RoID09PSAxO1xufTtcbi8qKlxuICogTm9ybWFsaXplIGEgRE9NIHBvaW50IHNvIHRoYXQgaXQgYWx3YXlzIHJlZmVycyB0byBhIHRleHQgbm9kZS5cbiAqL1xudmFyIG5vcm1hbGl6ZURPTVBvaW50ID0gZG9tUG9pbnQgPT4ge1xuICB2YXIgW25vZGUsIG9mZnNldF0gPSBkb21Qb2ludDtcbiAgLy8gSWYgaXQncyBhbiBlbGVtZW50IG5vZGUsIGl0cyBvZmZzZXQgcmVmZXJzIHRvIHRoZSBpbmRleCBvZiBpdHMgY2hpbGRyZW5cbiAgLy8gaW5jbHVkaW5nIGNvbW1lbnQgbm9kZXMsIHNvIHRyeSB0byBmaW5kIHRoZSByaWdodCB0ZXh0IGNoaWxkIG5vZGUuXG4gIGlmIChpc0RPTUVsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgIHZhciBpc0xhc3QgPSBvZmZzZXQgPT09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gaXNMYXN0ID8gb2Zmc2V0IC0gMSA6IG9mZnNldDtcbiAgICBbbm9kZSwgaW5kZXhdID0gZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4KG5vZGUsIGluZGV4LCBpc0xhc3QgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnKTtcbiAgICAvLyBJZiB0aGUgZWRpdGFibGUgY2hpbGQgZm91bmQgaXMgaW4gZnJvbnQgb2YgaW5wdXQgb2Zmc2V0LCB3ZSBpbnN0ZWFkIHNlZWsgdG8gaXRzIGVuZFxuICAgIGlzTGFzdCA9IGluZGV4IDwgb2Zmc2V0O1xuICAgIC8vIElmIHRoZSBub2RlIGhhcyBjaGlsZHJlbiwgdHJhdmVyc2UgdW50aWwgd2UgaGF2ZSBhIGxlYWYgbm9kZS4gTGVhZiBub2Rlc1xuICAgIC8vIGNhbiBiZSBlaXRoZXIgdGV4dCBub2Rlcywgb3Igb3RoZXIgdm9pZCBET00gbm9kZXMuXG4gICAgd2hpbGUgKGlzRE9NRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgaSA9IGlzTGFzdCA/IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxIDogMDtcbiAgICAgIG5vZGUgPSBnZXRFZGl0YWJsZUNoaWxkKG5vZGUsIGksIGlzTGFzdCA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcpO1xuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgdGhlIG5ldyBvZmZzZXQgaW5zaWRlIHRoZSB0ZXh0IG5vZGUuXG4gICAgb2Zmc2V0ID0gaXNMYXN0ICYmIG5vZGUudGV4dENvbnRlbnQgIT0gbnVsbCA/IG5vZGUudGV4dENvbnRlbnQubGVuZ3RoIDogMDtcbiAgfVxuICAvLyBSZXR1cm4gdGhlIG5vZGUgYW5kIG9mZnNldC5cbiAgcmV0dXJuIFtub2RlLCBvZmZzZXRdO1xufTtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBuZXN0ZWQgd2l0aGluIGEgc2hhZG93Um9vdFxuICovXG52YXIgaGFzU2hhZG93Um9vdCA9IG5vZGUgPT4ge1xuICB2YXIgcGFyZW50ID0gbm9kZSAmJiBub2RlLnBhcmVudE5vZGU7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIEdldCB0aGUgbmVhcmVzdCBlZGl0YWJsZSBjaGlsZCBhbmQgaW5kZXggYXQgYGluZGV4YCBpbiBhIGBwYXJlbnRgLCBwcmVmZXJyaW5nXG4gKiBgZGlyZWN0aW9uYC5cbiAqL1xudmFyIGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleCA9IChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZE5vZGVzXG4gIH0gPSBwYXJlbnQ7XG4gIHZhciBjaGlsZCA9IGNoaWxkTm9kZXNbaW5kZXhdO1xuICB2YXIgaSA9IGluZGV4O1xuICB2YXIgdHJpZWRGb3J3YXJkID0gZmFsc2U7XG4gIHZhciB0cmllZEJhY2t3YXJkID0gZmFsc2U7XG4gIC8vIFdoaWxlIHRoZSBjaGlsZCBpcyBhIGNvbW1lbnQgbm9kZSwgb3IgYW4gZWxlbWVudCBub2RlIHdpdGggbm8gY2hpbGRyZW4sXG4gIC8vIGtlZXAgaXRlcmF0aW5nIHRvIGZpbmQgYSBzaWJsaW5nIG5vbi12b2lkLCBub24tY29tbWVudCBub2RlLlxuICB3aGlsZSAoaXNET01Db21tZW50KGNoaWxkKSB8fCBpc0RPTUVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwIHx8IGlzRE9NRWxlbWVudChjaGlsZCkgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA9PT0gJ2ZhbHNlJykge1xuICAgIGlmICh0cmllZEZvcndhcmQgJiYgdHJpZWRCYWNrd2FyZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpID49IGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB0cmllZEZvcndhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4IC0gMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdiYWNrd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0cmllZEJhY2t3YXJkID0gdHJ1ZTtcbiAgICAgIGkgPSBpbmRleCArIDE7XG4gICAgICBkaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY2hpbGQgPSBjaGlsZE5vZGVzW2ldO1xuICAgIGluZGV4ID0gaTtcbiAgICBpICs9IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiBbY2hpbGQsIGluZGV4XTtcbn07XG4vKipcbiAqIEdldCB0aGUgbmVhcmVzdCBlZGl0YWJsZSBjaGlsZCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcbiAqIGBkaXJlY3Rpb25gLlxuICovXG52YXIgZ2V0RWRpdGFibGVDaGlsZCA9IChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pID0+IHtcbiAgdmFyIFtjaGlsZF0gPSBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgocGFyZW50LCBpbmRleCwgZGlyZWN0aW9uKTtcbiAgcmV0dXJuIGNoaWxkO1xufTtcbi8qKlxuICogR2V0IGEgcGxhaW50ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb250ZW50IG9mIGEgbm9kZSwgYWNjb3VudGluZyBmb3IgYmxvY2tcbiAqIGVsZW1lbnRzIHdoaWNoIGdldCBhIG5ld2xpbmUgYXBwZW5kZWQuXG4gKlxuICogVGhlIGRvbU5vZGUgbXVzdCBiZSBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICovXG52YXIgZ2V0UGxhaW5UZXh0ID0gZG9tTm9kZSA9PiB7XG4gIHZhciB0ZXh0ID0gJyc7XG4gIGlmIChpc0RPTVRleHQoZG9tTm9kZSkgJiYgZG9tTm9kZS5ub2RlVmFsdWUpIHtcbiAgICByZXR1cm4gZG9tTm9kZS5ub2RlVmFsdWU7XG4gIH1cbiAgaWYgKGlzRE9NRWxlbWVudChkb21Ob2RlKSkge1xuICAgIGZvciAodmFyIGNoaWxkTm9kZSBvZiBBcnJheS5mcm9tKGRvbU5vZGUuY2hpbGROb2RlcykpIHtcbiAgICAgIHRleHQgKz0gZ2V0UGxhaW5UZXh0KGNoaWxkTm9kZSk7XG4gICAgfVxuICAgIHZhciBkaXNwbGF5ID0gZ2V0Q29tcHV0ZWRTdHlsZShkb21Ob2RlKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5Jyk7XG4gICAgaWYgKGRpc3BsYXkgPT09ICdibG9jaycgfHwgZGlzcGxheSA9PT0gJ2xpc3QnIHx8IGRvbU5vZGUudGFnTmFtZSA9PT0gJ0JSJykge1xuICAgICAgdGV4dCArPSAnXFxuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59O1xuLyoqXG4gKiBHZXQgeC1zbGF0ZS1mcmFnbWVudCBhdHRyaWJ1dGUgZnJvbSBkYXRhLXNsYXRlLWZyYWdtZW50XG4gKi9cbnZhciBjYXRjaFNsYXRlRnJhZ21lbnQgPSAvZGF0YS1zbGF0ZS1mcmFnbWVudD1cIiguKz8pXCIvbTtcbnZhciBnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlID0gZGF0YVRyYW5zZmVyID0+IHtcbiAgdmFyIGh0bWxEYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICB2YXIgWywgZnJhZ21lbnRdID0gaHRtbERhdGEubWF0Y2goY2F0Y2hTbGF0ZUZyYWdtZW50KSB8fCBbXTtcbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcbi8qKlxuICogR2V0IHRoZSBkb20gc2VsZWN0aW9uIGZyb20gU2hhZG93IFJvb3QgaWYgcG9zc2libGUsIG90aGVyd2lzZSBmcm9tIHRoZSBkb2N1bWVudFxuICovXG52YXIgZ2V0U2VsZWN0aW9uID0gcm9vdCA9PiB7XG4gIGlmIChyb290LmdldFNlbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xufTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIG11dGF0aW9uIG9yaWdpbmF0ZXMgZnJvbSBhIGVkaXRhYmxlIGVsZW1lbnQgaW5zaWRlIHRoZSBlZGl0b3IuXG4gKi9cbnZhciBpc1RyYWNrZWRNdXRhdGlvbiA9IChlZGl0b3IsIG11dGF0aW9uLCBiYXRjaCkgPT4ge1xuICB2YXIge1xuICAgIHRhcmdldFxuICB9ID0gbXV0YXRpb247XG4gIGlmIChpc0RPTUVsZW1lbnQodGFyZ2V0KSAmJiB0YXJnZXQubWF0Y2hlcygnW2NvbnRlbnRFZGl0YWJsZT1cImZhbHNlXCJdJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHtcbiAgICBkb2N1bWVudFxuICB9ID0gRE9NRWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICBpZiAoZG9jdW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgIHJldHVybiBET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCwge1xuICAgICAgZWRpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICB2YXIgcGFyZW50TXV0YXRpb24gPSBiYXRjaC5maW5kKF9yZWYgPT4ge1xuICAgIHZhciB7XG4gICAgICBhZGRlZE5vZGVzLFxuICAgICAgcmVtb3ZlZE5vZGVzXG4gICAgfSA9IF9yZWY7XG4gICAgZm9yICh2YXIgbm9kZSBvZiBhZGRlZE5vZGVzKSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGFyZ2V0IHx8IG5vZGUuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX25vZGUgb2YgcmVtb3ZlZE5vZGVzKSB7XG4gICAgICBpZiAoX25vZGUgPT09IHRhcmdldCB8fCBfbm9kZS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmICghcGFyZW50TXV0YXRpb24gfHwgcGFyZW50TXV0YXRpb24gPT09IG11dGF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRhcmdldCBhZGQvcmVtb3ZlIGlzIHRyYWNrZWQuIFRyYWNrIHRoZSBtdXRhdGlvbiBpZiB3ZSB0cmFjayB0aGUgcGFyZW50IG11dGF0aW9uLlxuICByZXR1cm4gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBwYXJlbnRNdXRhdGlvbiwgYmF0Y2gpO1xufTtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBkZWVwZXN0IGFjdGl2ZSBlbGVtZW50IGluIHRoZSBET00sIGNvbnNpZGVyaW5nIG5lc3RlZCBzaGFkb3cgRE9Ncy5cbiAqL1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSAoKSA9PiB7XG4gIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgd2hpbGUgKChfYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQpICE9PSBudWxsICYmIF9hY3RpdmVFbGVtZW50ICE9PSB2b2lkIDAgJiYgX2FjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCAmJiAoX2FjdGl2ZUVsZW1lbnQkc2hhZG93ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSAhPT0gbnVsbCAmJiBfYWN0aXZlRWxlbWVudCRzaGFkb3cgIT09IHZvaWQgMCAmJiBfYWN0aXZlRWxlbWVudCRzaGFkb3cuYWN0aXZlRWxlbWVudCkge1xuICAgIHZhciBfYWN0aXZlRWxlbWVudCwgX2FjdGl2ZUVsZW1lbnQkc2hhZG93LCBfYWN0aXZlRWxlbWVudDI7XG4gICAgYWN0aXZlRWxlbWVudCA9IChfYWN0aXZlRWxlbWVudDIgPSBhY3RpdmVFbGVtZW50KSA9PT0gbnVsbCB8fCBfYWN0aXZlRWxlbWVudDIgPT09IHZvaWQgMCB8fCAoX2FjdGl2ZUVsZW1lbnQyID0gX2FjdGl2ZUVsZW1lbnQyLnNoYWRvd1Jvb3QpID09PSBudWxsIHx8IF9hY3RpdmVFbGVtZW50MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FjdGl2ZUVsZW1lbnQyLmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG59O1xuLyoqXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYG90aGVyTm9kZWAgaXMgYmVmb3JlIGBub2RlYCBpbiB0aGUgZG9jdW1lbnQ7IG90aGVyd2lzZSwgYGZhbHNlYC5cbiAqL1xudmFyIGlzQmVmb3JlID0gKG5vZGUsIG90aGVyTm9kZSkgPT4gQm9vbGVhbihub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG90aGVyTm9kZSkgJiBET01Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyk7XG4vKipcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBgb3RoZXJOb2RlYCBpcyBhZnRlciBgbm9kZWAgaW4gdGhlIGRvY3VtZW50OyBvdGhlcndpc2UsIGBmYWxzZWAuXG4gKi9cbnZhciBpc0FmdGVyID0gKG5vZGUsIG90aGVyTm9kZSkgPT4gQm9vbGVhbihub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG90aGVyTm9kZSkgJiBET01Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyk7XG5cbnZhciBfbmF2aWdhdG9yJHVzZXJBZ2VudCQsIF9uYXZpZ2F0b3IkdXNlckFnZW50JDI7XG52YXIgSVNfSU9TID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTtcbnZhciBJU19BUFBMRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9NYWMgT1MgWC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19BTkRST0lEID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfRklSRUZPWCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19XRUJLSVQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQXBwbGVXZWJLaXQoPyEuKkNocm9tZSkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gXCJtb2Rlcm5cIiBFZGdlIHdhcyByZWxlYXNlZCBhdCA3OS54XG52YXIgSVNfRURHRV9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvRWRnZT9cXC8oPzpbMC02XVswLTldfFswLTddWzAtOF0pKD86XFwuKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQ0hST01FID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0Nocm9tZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBOYXRpdmUgYGJlZm9yZUlucHV0YCBldmVudHMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggcmVhY3Qgb24gQ2hyb21lIDc1XG4vLyBhbmQgb2xkZXIsIENocm9tZSA3NisgY2FuIHVzZSBgYmVmb3JlSW5wdXRgIHRob3VnaC5cbnZhciBJU19DSFJPTUVfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0Nocm9tZT9cXC8oPzpbMC03XVswLTVdfFswLTZdWzAtOV0pKD86XFwuKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfQU5EUk9JRF9DSFJPTUVfTEVHQUNZID0gSVNfQU5EUk9JRCAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lP1xcLyg/OlswLTVdP1xcZCkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIEZpcmVmb3ggZGlkIG5vdCBzdXBwb3J0IGBiZWZvcmVJbnB1dGAgdW50aWwgYHY4N2AuXG52YXIgSVNfRklSRUZPWF9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveFxcLyg/OlswLTddWzAtOV18WzAtOF1bMC02XSkoPzpcXC4pKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIFVDIG1vYmlsZSBicm93c2VyXG52YXIgSVNfVUNfTU9CSUxFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLy4qVUNCcm93c2VyLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gV2VjaGF0IGJyb3dzZXIgKG5vdCBpbmNsdWRpbmcgbWFjIHdlY2hhdClcbnZhciBJU19XRUNIQVRCUk9XU0VSID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLy4qV2VjaGF0Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvLipNYWNXZWNoYXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIGF2b2lkIGxvb2tiZWhpbmQgKGJ1Z2d5IGluIHNhZmFyaSA8IDE2LjQpXG4vLyBDaGVjayBpZiBET00gaXMgYXZhaWxhYmxlIGFzIFJlYWN0IGRvZXMgaW50ZXJuYWxseS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21hc3Rlci9wYWNrYWdlcy9zaGFyZWQvRXhlY3V0aW9uRW52aXJvbm1lbnQuanNcbnZhciBDQU5fVVNFX0RPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpO1xuLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgaXMgU2FmYXJpIGFuZCBvbGRlciB0aGFuIDE3XG50eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIC9WZXJzaW9uXFwvKFxcZCspLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICgoX25hdmlnYXRvciR1c2VyQWdlbnQkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhcXGQrKS8pKSAhPT0gbnVsbCAmJiBfbmF2aWdhdG9yJHVzZXJBZ2VudCQgIT09IHZvaWQgMCAmJiBfbmF2aWdhdG9yJHVzZXJBZ2VudCRbMV0gPyBwYXJzZUludCgoX25hdmlnYXRvciR1c2VyQWdlbnQkMiA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oXFxkKykvKSkgPT09IG51bGwgfHwgX25hdmlnYXRvciR1c2VyQWdlbnQkMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25hdmlnYXRvciR1c2VyQWdlbnQkMlsxXSwgMTApIDwgMTcgOiBmYWxzZSk7XG4vLyBDT01QQVQ6IEZpcmVmb3gvRWRnZSBMZWdhY3kgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudFxuLy8gQ2hyb21lIExlZ2FjeSBkb2Vzbid0IHN1cHBvcnQgYGJlZm9yZWlucHV0YCBjb3JyZWN0bHlcbnZhciBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgPSAoIUlTX0NIUk9NRV9MRUdBQ1kgfHwgIUlTX0FORFJPSURfQ0hST01FX0xFR0FDWSkgJiYgIUlTX0VER0VfTEVHQUNZICYmXG4vLyBnbG9iYWxUaGlzIGlzIHVuZGVmaW5lZCBpbiBvbGRlciBicm93c2Vyc1xudHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuSW5wdXRFdmVudCAmJlxuLy8gQHRzLWlnbm9yZSBUaGUgYGdldFRhcmdldFJhbmdlc2AgcHJvcGVydHkgaXNuJ3QgcmVjb2duaXplZC5cbnR5cGVvZiBnbG9iYWxUaGlzLklucHV0RXZlbnQucHJvdG90eXBlLmdldFRhcmdldFJhbmdlcyA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQW4gYXV0by1pbmNyZW1lbnRpbmcgaWRlbnRpZmllciBmb3Iga2V5cy5cbiAqL1xudmFyIG4gPSAwO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgYSBrZXkgc3RyaW5nLiBXZSB1c2UgYSBmdWxsIGNsYXNzIGhlcmUgYmVjYXVzZSB3ZVxuICogd2FudCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtIGFzIGtleXMgaW4gYFdlYWtNYXBgIG9iamVjdHMuXG4gKi9cbmNsYXNzIEtleSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlkXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5pZCA9IFwiXCIuY29uY2F0KG4rKyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUd28gd2VhayBtYXBzIHRoYXQgYWxsb3cgdXMgcmVidWlsZCBhIHBhdGggZ2l2ZW4gYSBub2RlLiBUaGV5IGFyZSBwb3B1bGF0ZWRcbiAqIGF0IHJlbmRlciB0aW1lIHN1Y2ggdGhhdCBhZnRlciBhIHJlbmRlciBvY2N1cnMgd2UgY2FuIGFsd2F5cyBiYWNrdHJhY2suXG4gKi9cbnZhciBJU19OT0RFX01BUF9ESVJUWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19JTkRFWCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19QQVJFTlQgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBXZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyB0byBnbyBiZXR3ZWVuIFNsYXRlIG5vZGVzIGFuZCBET00gbm9kZXMuIFRoZXNlXG4gKiBhcmUgdXNlZCB0byByZXNvbHZlIERPTSBldmVudC1yZWxhdGVkIGxvZ2ljIGludG8gU2xhdGUgYWN0aW9ucy5cbiAqL1xudmFyIEVESVRPUl9UT19XSU5ET1cgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUExBQ0VIT0xERVJfRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRUxFTUVOVF9UT19OT0RFID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PREVfVE9fS0VZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBXZWFrIG1hcHMgZm9yIHN0b3JpbmcgZWRpdG9yLXJlbGF0ZWQgc3RhdGUuXG4gKi9cbnZhciBJU19SRUFEX09OTFkgPSBuZXcgV2Vha01hcCgpO1xudmFyIElTX0ZPQ1VTRUQgPSBuZXcgV2Vha01hcCgpO1xudmFyIElTX0NPTVBPU0lORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogV2VhayBtYXAgZm9yIGFzc29jaWF0aW5nIHRoZSBjb250ZXh0IGBvbkNoYW5nZWAgY29udGV4dCB3aXRoIHRoZSBwbHVnaW4uXG4gKi9cbnZhciBFRElUT1JfVE9fT05fQ0hBTkdFID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogV2VhayBtYXBzIGZvciBzYXZpbmcgcGVuZGluZyBzdGF0ZSBvbiBjb21wb3NpdGlvbiBzdGFnZS5cbiAqL1xudmFyIEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fVVNFUl9NQVJLUyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEFuZHJvaWQgaW5wdXQgaGFuZGxpbmcgc3BlY2lmaWMgd2Vhay1tYXBzXG4gKi9cbnZhciBFRElUT1JfVE9fUEVORElOR19ESUZGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19GT1JDRV9SRU5ERVIgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBTeW1ib2xzLlxuICovXG52YXIgUExBQ0VIT0xERVJfU1lNQk9MID0gU3ltYm9sKCdwbGFjZWhvbGRlcicpO1xudmFyIE1BUktfUExBQ0VIT0xERVJfU1lNQk9MID0gU3ltYm9sKCdtYXJrLXBsYWNlaG9sZGVyJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBET01FZGl0b3IgPSB7XG4gIGFuZHJvaWRQZW5kaW5nRGlmZnM6IGVkaXRvciA9PiBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSxcbiAgYW5kcm9pZFNjaGVkdWxlRmx1c2g6IGVkaXRvciA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fU0NIRURVTEVfRjtcbiAgICAoX0VESVRPUl9UT19TQ0hFRFVMRV9GID0gRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILmdldChlZGl0b3IpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1NDSEVEVUxFX0YgPT09IHZvaWQgMCB8fCBfRURJVE9SX1RPX1NDSEVEVUxFX0YoKTtcbiAgfSxcbiAgYmx1cjogZWRpdG9yID0+IHtcbiAgICB2YXIgZWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICB2YXIgcm9vdCA9IERPTUVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICBpZiAocm9vdC5hY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgICAgZWwuYmx1cigpO1xuICAgIH1cbiAgfSxcbiAgZGVzZWxlY3Q6IGVkaXRvciA9PiB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgdmFyIHJvb3QgPSBET01FZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgdmFyIGRvbVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihyb290KTtcbiAgICBpZiAoZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgfVxuICB9LFxuICBmaW5kRG9jdW1lbnRPclNoYWRvd1Jvb3Q6IGVkaXRvciA9PiB7XG4gICAgdmFyIGVsID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBlbC5nZXRSb290Tm9kZSgpO1xuICAgIGlmIChyb290IGluc3RhbmNlb2YgRG9jdW1lbnQgfHwgcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICByZXR1cm4gZWwub3duZXJEb2N1bWVudDtcbiAgfSxcbiAgZmluZEV2ZW50UmFuZ2U6IChlZGl0b3IsIGV2ZW50KSA9PiB7XG4gICAgaWYgKCduYXRpdmVFdmVudCcgaW4gZXZlbnQpIHtcbiAgICAgIGV2ZW50ID0gZXZlbnQubmF0aXZlRXZlbnQ7XG4gICAgfVxuICAgIHZhciB7XG4gICAgICBjbGllbnRYOiB4LFxuICAgICAgY2xpZW50WTogeSxcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIGEgRE9NIGV2ZW50OiBcIi5jb25jYXQoZXZlbnQpKTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBET01FZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgIHZhciBwYXRoID0gRE9NRWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7XG4gICAgLy8gSWYgdGhlIGRyb3AgdGFyZ2V0IGlzIGluc2lkZSBhIHZvaWQgbm9kZSwgbW92ZSBpdCBpbnRvIGVpdGhlciB0aGVcbiAgICAvLyBuZXh0IG9yIHByZXZpb3VzIG5vZGUsIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlIHRoZSBgeGAgYW5kIGB5YFxuICAgIC8vIGNvb3JkaW5hdGVzIGFyZSBjbG9zZXN0IHRvLlxuICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgIHZhciByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGlzUHJldiA9IGVkaXRvci5pc0lubGluZShub2RlKSA/IHggLSByZWN0LmxlZnQgPCByZWN0LmxlZnQgKyByZWN0LndpZHRoIC0geCA6IHkgLSByZWN0LnRvcCA8IHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLSB5O1xuICAgICAgdmFyIGVkZ2UgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBwYXRoLCB7XG4gICAgICAgIGVkZ2U6IGlzUHJldiA/ICdzdGFydCcgOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICB2YXIgcG9pbnQgPSBpc1ByZXYgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZWRnZSkgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBlZGdlKTtcbiAgICAgIGlmIChwb2ludCkge1xuICAgICAgICB2YXIgX3JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9pbnQpO1xuICAgICAgICByZXR1cm4gX3JhbmdlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBFbHNlIHJlc29sdmUgYSByYW5nZSBmcm9tIHRoZSBjYXJldCBwb3NpdGlvbiB3aGVyZSB0aGUgZHJvcCBvY2N1cmVkLlxuICAgIHZhciBkb21SYW5nZTtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnRcbiAgICB9ID0gRE9NRWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIC8vIENPTVBBVDogSW4gRmlyZWZveCwgYGNhcmV0UmFuZ2VGcm9tUG9pbnRgIGRvZXNuJ3QgZXhpc3QuICgyMDE2LzA3LzI1KVxuICAgIGlmIChkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICBkb21SYW5nZSA9IGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBkb21SYW5nZS5zZXRTdGFydChwb3NpdGlvbi5vZmZzZXROb2RlLCBwb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgICBkb21SYW5nZS5zZXRFbmQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkb21SYW5nZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSByYW5nZSBmcm9tIGEgRE9NIGV2ZW50OiBcIi5jb25jYXQoZXZlbnQpKTtcbiAgICB9XG4gICAgLy8gUmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gdGhlIERPTSByYW5nZS5cbiAgICB2YXIgcmFuZ2UgPSBET01FZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tUmFuZ2UsIHtcbiAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH0sXG4gIGZpbmRLZXk6IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgICB2YXIga2V5ID0gTk9ERV9UT19LRVkuZ2V0KG5vZGUpO1xuICAgIGlmICgha2V5KSB7XG4gICAgICBrZXkgPSBuZXcgS2V5KCk7XG4gICAgICBOT0RFX1RPX0tFWS5zZXQobm9kZSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSxcbiAgZmluZFBhdGg6IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHZhciBjaGlsZCA9IG5vZGU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBOT0RFX1RPX1BBUkVOVC5nZXQoY2hpbGQpO1xuICAgICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChFZGl0b3IuaXNFZGl0b3IoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpID0gTk9ERV9UT19JTkRFWC5nZXQoY2hpbGQpO1xuICAgICAgaWYgKGkgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHBhdGgudW5zaGlmdChpKTtcbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB0aGUgcGF0aCBmb3IgU2xhdGUgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICB9LFxuICBmb2N1czogZnVuY3Rpb24gZm9jdXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIHJldHJpZXM6IDVcbiAgICB9O1xuICAgIC8vIFJldHVybiBpZiBhbHJlYWR5IGZvY3VzZWRcbiAgICBpZiAoSVNfRk9DVVNFRC5nZXQoZWRpdG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZXRyeSBzZXR0aW5nIGZvY3VzIGlmIHRoZSBlZGl0b3IgaGFzIHBlbmRpbmcgb3BlcmF0aW9ucy5cbiAgICAvLyBUaGUgRE9NIChzZWxlY3Rpb24pIGlzIHVuc3RhYmxlIHdoaWxlIGNoYW5nZXMgYXJlIGFwcGxpZWQuXG4gICAgLy8gUmV0cnkgdW50aWwgcmV0cmllcyBhcmUgZXhoYXVzdGVkIG9yIGVkaXRvciBpcyBmb2N1c2VkLlxuICAgIGlmIChvcHRpb25zLnJldHJpZXMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3Qgc2V0IGZvY3VzLCBlZGl0b3Igc2VlbXMgc3R1Y2sgd2l0aCBwZW5kaW5nIG9wZXJhdGlvbnMnKTtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5vcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBET01FZGl0b3IuZm9jdXMoZWRpdG9yLCB7XG4gICAgICAgICAgcmV0cmllczogb3B0aW9ucy5yZXRyaWVzIC0gMVxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVsID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBET01FZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgaWYgKHJvb3QuYWN0aXZlRWxlbWVudCAhPT0gZWwpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBET00gc2VsZWN0aW9uIHN0YXRlIGlzIHNldCB0byB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uXG4gICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiByb290IGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGRvbVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihyb290KTtcbiAgICAgICAgdmFyIGRvbVJhbmdlID0gRE9NRWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKTtcbiAgICAgICAgZG9tU2VsZWN0aW9uID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gdm9pZCAwIHx8IGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgZG9tU2VsZWN0aW9uID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gdm9pZCAwIHx8IGRvbVNlbGVjdGlvbi5hZGRSYW5nZShkb21SYW5nZSk7XG4gICAgICB9XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgc2VsZWN0aW9uIGluIHRoZSB0b3Agb2YgdGhlIGRvY3VtZW50IGlmIG1pc3NpbmdcbiAgICAgIGlmICghZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSk7XG4gICAgICB9XG4gICAgICAvLyBJU19GT0NVU0VEIHNob3VsZCBiZSBzZXQgYmVmb3JlIGNhbGxpbmcgZWwuZm9jdXMoKSB0byBlbnN1cmUgdGhhdFxuICAgICAgLy8gRm9jdXNlZENvbnRleHQgaXMgdXBkYXRlZCB0byB0aGUgY29ycmVjdCB2YWx1ZVxuICAgICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgIGVsLmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBnZXRXaW5kb3c6IGVkaXRvciA9PiB7XG4gICAgdmFyIHdpbmRvdyA9IEVESVRPUl9UT19XSU5ET1cuZ2V0KGVkaXRvcik7XG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgYSBob3N0IHdpbmRvdyBlbGVtZW50IGZvciB0aGlzIGVkaXRvcicpO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93O1xuICB9LFxuICBoYXNET01Ob2RlOiBmdW5jdGlvbiBoYXNET01Ob2RlKGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBlZGl0YWJsZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGVkaXRvckVsID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHRhcmdldEVsO1xuICAgIC8vIENPTVBBVDogSW4gRmlyZWZveCwgcmVhZGluZyBgdGFyZ2V0Lm5vZGVUeXBlYCB3aWxsIHRocm93IGFuIGVycm9yIGlmXG4gICAgLy8gdGFyZ2V0IGlzIG9yaWdpbmF0aW5nIGZyb20gYW4gaW50ZXJuYWwgXCJyZXN0cmljdGVkXCIgZWxlbWVudCAoZS5nLiBhXG4gICAgLy8gc3RlcHBlciBhcnJvdyBvbiBhIG51bWJlciBpbnB1dCkuICgyMDE4LzA1LzA0KVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pYW5zdG9ybXRheWxvci9zbGF0ZS9pc3N1ZXMvMTgxOVxuICAgIHRyeSB7XG4gICAgICB0YXJnZXRFbCA9IGlzRE9NRWxlbWVudCh0YXJnZXQpID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdQZXJtaXNzaW9uIGRlbmllZCB0byBhY2Nlc3MgcHJvcGVydHkgXCJub2RlVHlwZVwiJykpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRhcmdldEVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRFbC5jbG9zZXN0KFwiW2RhdGEtc2xhdGUtZWRpdG9yXVwiKSA9PT0gZWRpdG9yRWwgJiYgKCFlZGl0YWJsZSB8fCB0YXJnZXRFbC5pc0NvbnRlbnRFZGl0YWJsZSA/IHRydWUgOiB0eXBlb2YgdGFyZ2V0RWwuaXNDb250ZW50RWRpdGFibGUgPT09ICdib29sZWFuJyAmJlxuICAgIC8vIGlzQ29udGVudEVkaXRhYmxlIGV4aXN0cyBvbmx5IG9uIEhUTUxFbGVtZW50LCBhbmQgb24gb3RoZXIgbm9kZXMgaXQgd2lsbCBiZSB1bmRlZmluZWRcbiAgICAvLyB0aGlzIGlzIHRoZSBjb3JlIGxvZ2ljIHRoYXQgbGV0cyB5b3Uga25vdyB5b3UgZ290IHRoZSByaWdodCBlZGl0b3Iuc2VsZWN0aW9uIGluc3RlYWQgb2YgbnVsbCB3aGVuIGVkaXRvciBpcyBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiKHJlYWRPbmx5KVxuICAgIHRhcmdldEVsLmNsb3Nlc3QoJ1tjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXScpID09PSBlZGl0b3JFbCB8fCAhIXRhcmdldEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykpO1xuICB9LFxuICBoYXNFZGl0YWJsZVRhcmdldDogKGVkaXRvciwgdGFyZ2V0KSA9PiBpc0RPTU5vZGUodGFyZ2V0KSAmJiBET01FZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCwge1xuICAgIGVkaXRhYmxlOiB0cnVlXG4gIH0pLFxuICBoYXNSYW5nZTogKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIEVkaXRvci5oYXNQYXRoKGVkaXRvciwgYW5jaG9yLnBhdGgpICYmIEVkaXRvci5oYXNQYXRoKGVkaXRvciwgZm9jdXMucGF0aCk7XG4gIH0sXG4gIGhhc1NlbGVjdGFibGVUYXJnZXQ6IChlZGl0b3IsIHRhcmdldCkgPT4gRE9NRWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSB8fCBET01FZGl0b3IuaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCB0YXJnZXQpLFxuICBoYXNUYXJnZXQ6IChlZGl0b3IsIHRhcmdldCkgPT4gaXNET01Ob2RlKHRhcmdldCkgJiYgRE9NRWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQpLFxuICBpbnNlcnREYXRhOiAoZWRpdG9yLCBkYXRhKSA9PiB7XG4gICAgZWRpdG9yLmluc2VydERhdGEoZGF0YSk7XG4gIH0sXG4gIGluc2VydEZyYWdtZW50RGF0YTogKGVkaXRvciwgZGF0YSkgPT4gZWRpdG9yLmluc2VydEZyYWdtZW50RGF0YShkYXRhKSxcbiAgaW5zZXJ0VGV4dERhdGE6IChlZGl0b3IsIGRhdGEpID0+IGVkaXRvci5pbnNlcnRUZXh0RGF0YShkYXRhKSxcbiAgaXNDb21wb3Npbmc6IGVkaXRvciA9PiB7XG4gICAgcmV0dXJuICEhSVNfQ09NUE9TSU5HLmdldChlZGl0b3IpO1xuICB9LFxuICBpc0ZvY3VzZWQ6IGVkaXRvciA9PiAhIUlTX0ZPQ1VTRUQuZ2V0KGVkaXRvciksXG4gIGlzUmVhZE9ubHk6IGVkaXRvciA9PiAhIUlTX1JFQURfT05MWS5nZXQoZWRpdG9yKSxcbiAgaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQ6IChlZGl0b3IsIHRhcmdldCkgPT4ge1xuICAgIGlmIChJU19SRUFEX09OTFkuZ2V0KGVkaXRvcikpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc2xhdGVOb2RlID0gRE9NRWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIHRhcmdldCkgJiYgRE9NRWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGFyZ2V0KTtcbiAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQoc2xhdGVOb2RlKSAmJiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgc2xhdGVOb2RlKTtcbiAgfSxcbiAgc2V0RnJhZ21lbnREYXRhOiAoZWRpdG9yLCBkYXRhLCBvcmlnaW5FdmVudCkgPT4gZWRpdG9yLnNldEZyYWdtZW50RGF0YShkYXRhLCBvcmlnaW5FdmVudCksXG4gIHRvRE9NTm9kZTogKGVkaXRvciwgbm9kZSkgPT4ge1xuICAgIHZhciBLRVlfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcbiAgICB2YXIgZG9tTm9kZSA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IEVESVRPUl9UT19FTEVNRU5ULmdldChlZGl0b3IpIDogS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULmdldChET01FZGl0b3IuZmluZEtleShlZGl0b3IsIG5vZGUpKTtcbiAgICBpZiAoIWRvbU5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgRE9NIG5vZGUgZnJvbSBTbGF0ZSBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiBkb21Ob2RlO1xuICB9LFxuICB0b0RPTVBvaW50OiAoZWRpdG9yLCBwb2ludCkgPT4ge1xuICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBvaW50LnBhdGgpO1xuICAgIHZhciBlbCA9IERPTUVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBub2RlKTtcbiAgICB2YXIgZG9tUG9pbnQ7XG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgdm9pZCBub2RlLCBmb3JjZSB0aGUgb2Zmc2V0IHRvIDAsIG90aGVyd2lzZSB0aGUgemVyb1xuICAgIC8vIHdpZHRoIHNwYWNpbmcgY2hhcmFjdGVyIHdpbGwgcmVzdWx0IGluIGFuIGluY29ycmVjdCBvZmZzZXQgb2YgMVxuICAgIGlmIChFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiBwb2ludFxuICAgIH0pKSB7XG4gICAgICBwb2ludCA9IHtcbiAgICAgICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBGb3IgZWFjaCBsZWFmLCB3ZSBuZWVkIHRvIGlzb2xhdGUgaXRzIGNvbnRlbnQsIHdoaWNoIG1lYW5zIGZpbHRlcmluZ1xuICAgIC8vIHRvIGl0cyBkaXJlY3QgdGV4dCBhbmQgemVyby13aWR0aCBzcGFucy4gKFdlIGhhdmUgdG8gZmlsdGVyIG91dCBhbnlcbiAgICAvLyBvdGhlciBzaWJsaW5ncyB0aGF0IG1heSBoYXZlIGJlZW4gcmVuZGVyZWQgYWxvbmdzaWRlIHRoZW0uKVxuICAgIHZhciBzZWxlY3RvciA9IFwiW2RhdGEtc2xhdGUtc3RyaW5nXSwgW2RhdGEtc2xhdGUtemVyby13aWR0aF1cIjtcbiAgICB2YXIgdGV4dHMgPSBBcnJheS5mcm9tKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0ZXh0ID0gdGV4dHNbaV07XG4gICAgICB2YXIgZG9tTm9kZSA9IHRleHQuY2hpbGROb2Rlc1swXTtcbiAgICAgIGlmIChkb21Ob2RlID09IG51bGwgfHwgZG9tTm9kZS50ZXh0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gZG9tTm9kZS50ZXh0Q29udGVudDtcbiAgICAgIHZhciBhdHRyID0gdGV4dC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbGVuZ3RoJyk7XG4gICAgICB2YXIgdHJ1ZUxlbmd0aCA9IGF0dHIgPT0gbnVsbCA/IGxlbmd0aCA6IHBhcnNlSW50KGF0dHIsIDEwKTtcbiAgICAgIHZhciBlbmQgPSBzdGFydCArIHRydWVMZW5ndGg7XG4gICAgICAvLyBQcmVmZXIgcHV0dGluZyB0aGUgc2VsZWN0aW9uIGluc2lkZSB0aGUgbWFyayBwbGFjZWhvbGRlciB0byBlbnN1cmVcbiAgICAgIC8vIGNvbXBvc2VkIHRleHQgaXMgZGlzcGxheWVkIHdpdGggdGhlIGNvcnJlY3QgbWFya3MuXG4gICAgICB2YXIgbmV4dFRleHQgPSB0ZXh0c1tpICsgMV07XG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID09PSBlbmQgJiYgbmV4dFRleHQgIT09IG51bGwgJiYgbmV4dFRleHQgIT09IHZvaWQgMCAmJiBuZXh0VGV4dC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbWFyay1wbGFjZWhvbGRlcicpKSB7XG4gICAgICAgIHZhciBfbmV4dFRleHQkdGV4dENvbnRlbnQ7XG4gICAgICAgIHZhciBkb21UZXh0ID0gbmV4dFRleHQuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgZG9tUG9pbnQgPSBbXG4gICAgICAgIC8vIENPTVBBVDogSWYgd2UgZG9uJ3QgZXhwbGljaXR5IHNldCB0aGUgZG9tIHBvaW50IHRvIGJlIG9uIHRoZSBhY3R1YWxcbiAgICAgICAgLy8gZG9tIHRleHQgZWxlbWVudCwgY2hyb21lIHdpbGwgcHV0IHRoZSBzZWxlY3Rpb24gYmVoaW5kIHRoZSBhY3R1YWwgZG9tXG4gICAgICAgIC8vIHRleHQgZWxlbWVudCwgY2F1c2luZyBkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBjYWxscyBvbiBhIGNvbGxhcHNlZFxuICAgICAgICAvLyBzZWxlY3Rpb24gdG8gcmV0dXJuIGluY29ycmVjdCB6ZXJvIHZhbHVlcyAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDM1NDM4KVxuICAgICAgICAvLyB3aGljaCB3aWxsIGNhdXNlIGlzc3VlcyB3aGVuIHNjcm9sbGluZyB0byBpdC5cbiAgICAgICAgZG9tVGV4dCBpbnN0YW5jZW9mIERPTVRleHQgPyBkb21UZXh0IDogbmV4dFRleHQsIChfbmV4dFRleHQkdGV4dENvbnRlbnQgPSBuZXh0VGV4dC50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX25leHRUZXh0JHRleHRDb250ZW50ICE9PSB2b2lkIDAgJiYgX25leHRUZXh0JHRleHRDb250ZW50LnN0YXJ0c1dpdGgoJ1xcdUZFRkYnKSA/IDEgOiAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAocG9pbnQub2Zmc2V0IDw9IGVuZCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5taW4obGVuZ3RoLCBNYXRoLm1heCgwLCBwb2ludC5vZmZzZXQgLSBzdGFydCkpO1xuICAgICAgICBkb21Qb2ludCA9IFtkb21Ob2RlLCBvZmZzZXRdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gZW5kO1xuICAgIH1cbiAgICBpZiAoIWRvbVBvaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIERPTSBwb2ludCBmcm9tIFNsYXRlIHBvaW50OiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHBvaW50KSkpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tUG9pbnQ7XG4gIH0sXG4gIHRvRE9NUmFuZ2U6IChlZGl0b3IsIHJhbmdlKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHZhciBpc0JhY2t3YXJkID0gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gICAgdmFyIGRvbUFuY2hvciA9IERPTUVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgYW5jaG9yKTtcbiAgICB2YXIgZG9tRm9jdXMgPSBSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkgPyBkb21BbmNob3IgOiBET01FZGl0b3IudG9ET01Qb2ludChlZGl0b3IsIGZvY3VzKTtcbiAgICB2YXIgd2luZG93ID0gRE9NRWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHZhciBkb21SYW5nZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHZhciBbc3RhcnROb2RlLCBzdGFydE9mZnNldF0gPSBpc0JhY2t3YXJkID8gZG9tRm9jdXMgOiBkb21BbmNob3I7XG4gICAgdmFyIFtlbmROb2RlLCBlbmRPZmZzZXRdID0gaXNCYWNrd2FyZCA/IGRvbUFuY2hvciA6IGRvbUZvY3VzO1xuICAgIC8vIEEgc2xhdGUgUG9pbnQgYXQgemVyby13aWR0aCBMZWFmIGFsd2F5cyBoYXMgYW4gb2Zmc2V0IG9mIDAgYnV0IGEgbmF0aXZlIERPTSBzZWxlY3Rpb24gYXRcbiAgICAvLyB6ZXJvLXdpZHRoIG5vZGUgaGFzIGFuIG9mZnNldCBvZiAxIHNvIHdlIGhhdmUgdG8gY2hlY2sgaWYgd2UgYXJlIGluIGEgemVyby13aWR0aCBub2RlIGFuZFxuICAgIC8vIGFkanVzdCB0aGUgb2Zmc2V0IGFjY29yZGluZ2x5LlxuICAgIHZhciBzdGFydEVsID0gaXNET01FbGVtZW50KHN0YXJ0Tm9kZSkgPyBzdGFydE5vZGUgOiBzdGFydE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB2YXIgaXNTdGFydEF0WmVyb1dpZHRoID0gISFzdGFydEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJyk7XG4gICAgdmFyIGVuZEVsID0gaXNET01FbGVtZW50KGVuZE5vZGUpID8gZW5kTm9kZSA6IGVuZE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB2YXIgaXNFbmRBdFplcm9XaWR0aCA9ICEhZW5kRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKTtcbiAgICBkb21SYW5nZS5zZXRTdGFydChzdGFydE5vZGUsIGlzU3RhcnRBdFplcm9XaWR0aCA/IDEgOiBzdGFydE9mZnNldCk7XG4gICAgZG9tUmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGlzRW5kQXRaZXJvV2lkdGggPyAxIDogZW5kT2Zmc2V0KTtcbiAgICByZXR1cm4gZG9tUmFuZ2U7XG4gIH0sXG4gIHRvU2xhdGVOb2RlOiAoZWRpdG9yLCBkb21Ob2RlKSA9PiB7XG4gICAgdmFyIGRvbUVsID0gaXNET01FbGVtZW50KGRvbU5vZGUpID8gZG9tTm9kZSA6IGRvbU5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoZG9tRWwgJiYgIWRvbUVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1ub2RlJykpIHtcbiAgICAgIGRvbUVsID0gZG9tRWwuY2xvc2VzdChcIltkYXRhLXNsYXRlLW5vZGVdXCIpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IGRvbUVsID8gRUxFTUVOVF9UT19OT0RFLmdldChkb21FbCkgOiBudWxsO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSBub2RlIGZyb20gRE9NIG5vZGU6IFwiLmNvbmNhdChkb21FbCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgdG9TbGF0ZVBvaW50OiAoZWRpdG9yLCBkb21Qb2ludCwgb3B0aW9ucykgPT4ge1xuICAgIHZhciB7XG4gICAgICBleGFjdE1hdGNoLFxuICAgICAgc3VwcHJlc3NUaHJvdyxcbiAgICAgIHNlYXJjaERpcmVjdGlvbiA9ICdiYWNrd2FyZCdcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgW25lYXJlc3ROb2RlLCBuZWFyZXN0T2Zmc2V0XSA9IGV4YWN0TWF0Y2ggPyBkb21Qb2ludCA6IG5vcm1hbGl6ZURPTVBvaW50KGRvbVBvaW50KTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG5lYXJlc3ROb2RlLnBhcmVudE5vZGU7XG4gICAgdmFyIHRleHROb2RlID0gbnVsbDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgdmFyIF9kb21Ob2RlJHRleHRDb250ZW50LCBfZG9tTm9kZSR0ZXh0Q29udGVudDI7XG4gICAgICB2YXIgZWRpdG9yRWwgPSBET01FZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgIHZhciBwb3RlbnRpYWxWb2lkTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtdm9pZD1cInRydWVcIl0nKTtcbiAgICAgIC8vIE5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNsb3Nlc3Qgdm9pZCBub2RlIGlzIGFjdHVhbGx5IGEgdm9pZCBub2RlXG4gICAgICAvLyB3aXRoaW4gdGhpcyBlZGl0b3IsIGFuZCBub3QgYSB2b2lkIG5vZGUgd2l0aGluIHNvbWUgcGFyZW50IGVkaXRvci4gVGhpcyBjYW4gaGFwcGVuXG4gICAgICAvLyBpZiB0aGlzIGVkaXRvciBpcyB3aXRoaW4gYSB2b2lkIG5vZGUgb2YgYW5vdGhlciBlZGl0b3IgKFwibmVzdGVkIGVkaXRvcnNcIiwgbGlrZSBpblxuICAgICAgLy8gdGhlIFwiRWRpdGFibGUgVm9pZHNcIiBleGFtcGxlIG9uIHRoZSBkb2NzIHNpdGUpLlxuICAgICAgdmFyIHZvaWROb2RlID0gcG90ZW50aWFsVm9pZE5vZGUgJiYgZWRpdG9yRWwuY29udGFpbnMocG90ZW50aWFsVm9pZE5vZGUpID8gcG90ZW50aWFsVm9pZE5vZGUgOiBudWxsO1xuICAgICAgdmFyIHBvdGVudGlhbE5vbkVkaXRhYmxlTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdJyk7XG4gICAgICB2YXIgbm9uRWRpdGFibGVOb2RlID0gcG90ZW50aWFsTm9uRWRpdGFibGVOb2RlICYmIGVkaXRvckVsLmNvbnRhaW5zKHBvdGVudGlhbE5vbkVkaXRhYmxlTm9kZSkgPyBwb3RlbnRpYWxOb25FZGl0YWJsZU5vZGUgOiBudWxsO1xuICAgICAgdmFyIGxlYWZOb2RlID0gcGFyZW50Tm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1sZWFmXScpO1xuICAgICAgdmFyIGRvbU5vZGUgPSBudWxsO1xuICAgICAgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgaW50byB0aGUgdGV4dCBub2RlIHRoZSBgbmVhcmVzdE5vZGVgIGlzLCBzbyB0aGF0IHdlXG4gICAgICAvLyBjYW4gZGV0ZXJtaW5lIHdoYXQgdGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgdGV4dCBub2RlIGlzLlxuICAgICAgaWYgKGxlYWZOb2RlKSB7XG4gICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcbiAgICAgICAgaWYgKHRleHROb2RlKSB7XG4gICAgICAgICAgdmFyIHdpbmRvdyA9IERPTUVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5lYXJlc3ROb2RlLCBuZWFyZXN0T2Zmc2V0KTtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSByYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICAgICAgdmFyIHJlbW92YWxzID0gWy4uLkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykpLCAuLi5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbY29udGVudGVkaXRhYmxlPWZhbHNlXScpKV07XG4gICAgICAgICAgcmVtb3ZhbHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAvLyBDT01QQVQ6IFdoaWxlIGNvbXBvc2luZyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGUsIHNvbWUga2V5Ym9hcmRzIHB1dFxuICAgICAgICAgICAgLy8gdGhlIHRleHQgY29udGVudCBpbnNpZGUgdGhlIHplcm8gd2lkdGggc3BhY2UuXG4gICAgICAgICAgICBpZiAoSVNfQU5EUk9JRCAmJiAhZXhhY3RNYXRjaCAmJiBlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpICYmIGVsLnRleHRDb250ZW50Lmxlbmd0aCA+IDAgJiYgZWwudGV4dENvbnRleHQgIT09ICdcXHVGRUZGJykge1xuICAgICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQuc3RhcnRzV2l0aCgnXFx1RkVGRicpKSB7XG4gICAgICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBDT01QQVQ6IEVkZ2UgaGFzIGEgYnVnIHdoZXJlIFJhbmdlLnByb3RvdHlwZS50b1N0cmluZygpIHdpbGxcbiAgICAgICAgICAvLyBjb252ZXJ0IFxcbiBpbnRvIFxcclxcbi4gVGhlIGJ1ZyBjYXVzZXMgYSBsb29wIHdoZW4gc2xhdGUtZG9tXG4gICAgICAgICAgLy8gYXR0ZW1wdHMgdG8gcmVwb3NpdGlvbiBpdHMgY3Vyc29yIHRvIG1hdGNoIHRoZSBuYXRpdmUgcG9zaXRpb24uIFVzZVxuICAgICAgICAgIC8vIHRleHRDb250ZW50Lmxlbmd0aCBpbnN0ZWFkLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMjkxMTE2L1xuICAgICAgICAgIG9mZnNldCA9IGNvbnRlbnRzLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICBkb21Ob2RlID0gdGV4dE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodm9pZE5vZGUpIHtcbiAgICAgICAgLy8gRm9yIHZvaWQgbm9kZXMsIHRoZSBlbGVtZW50IHdpdGggdGhlIG9mZnNldCBrZXkgd2lsbCBiZSBhIGNvdXNpbiwgbm90IGFuXG4gICAgICAgIC8vIGFuY2VzdG9yLCBzbyBmaW5kIGl0IGJ5IGdvaW5nIGRvd24gZnJvbSB0aGUgbmVhcmVzdCB2b2lkIHBhcmVudCBhbmQgdGFraW5nIHRoZVxuICAgICAgICAvLyBmaXJzdCBvbmUgdGhhdCBpc24ndCBpbnNpZGUgYSBuZXN0ZWQgZWRpdG9yLlxuICAgICAgICB2YXIgbGVhZk5vZGVzID0gdm9pZE5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtbGVhZl0nKTtcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlYWZOb2Rlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGxlYWZOb2Rlc1tpbmRleF07XG4gICAgICAgICAgaWYgKERPTUVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgY3VycmVudCkpIHtcbiAgICAgICAgICAgIGxlYWZOb2RlID0gY3VycmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDT01QQVQ6IEluIHJlYWQtb25seSBlZGl0b3JzIHRoZSBsZWFmIGlzIG5vdCByZW5kZXJlZC5cbiAgICAgICAgaWYgKCFsZWFmTm9kZSkge1xuICAgICAgICAgIG9mZnNldCA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuICAgICAgICAgIGRvbU5vZGUgPSBsZWFmTm9kZTtcbiAgICAgICAgICBvZmZzZXQgPSBkb21Ob2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBvZmZzZXQgLT0gZWwudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vbkVkaXRhYmxlTm9kZSkge1xuICAgICAgICAvLyBGaW5kIHRoZSBlZGdlIG9mIHRoZSBuZWFyZXN0IGxlYWYgaW4gYHNlYXJjaERpcmVjdGlvbmBcbiAgICAgICAgdmFyIGdldExlYWZOb2RlcyA9IG5vZGUgPT4gbm9kZSA/IG5vZGUucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgLy8gRXhjbHVkZSBsZWFmIG5vZGVzIGluIG5lc3RlZCBlZGl0b3JzXG4gICAgICAgICdbZGF0YS1zbGF0ZS1sZWFmXTpub3QoOnNjb3BlIFtkYXRhLXNsYXRlLWVkaXRvcl0gW2RhdGEtc2xhdGUtbGVhZl0pJykgOiBbXTtcbiAgICAgICAgdmFyIGVsZW1lbnROb2RlID0gbm9uRWRpdGFibGVOb2RlLmNsb3Nlc3QoJ1tkYXRhLXNsYXRlLW5vZGU9XCJlbGVtZW50XCJdJyk7XG4gICAgICAgIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgIHZhciBfbGVhZk5vZGVzJGZpbmQ7XG4gICAgICAgICAgdmFyIF9sZWFmTm9kZXMgPSBbLi4uZ2V0TGVhZk5vZGVzKGVsZW1lbnROb2RlKSwgLi4uZ2V0TGVhZk5vZGVzKGVsZW1lbnROb2RlID09PSBudWxsIHx8IGVsZW1lbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50Tm9kZS5uZXh0RWxlbWVudFNpYmxpbmcpXTtcbiAgICAgICAgICBsZWFmTm9kZSA9IChfbGVhZk5vZGVzJGZpbmQgPSBfbGVhZk5vZGVzLmZpbmQobGVhZiA9PiBpc0FmdGVyKG5vbkVkaXRhYmxlTm9kZSwgbGVhZikpKSAhPT0gbnVsbCAmJiBfbGVhZk5vZGVzJGZpbmQgIT09IHZvaWQgMCA/IF9sZWFmTm9kZXMkZmluZCA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9sZWFmTm9kZXMyJGZpbmRMYXN0O1xuICAgICAgICAgIHZhciBfbGVhZk5vZGVzMiA9IFsuLi5nZXRMZWFmTm9kZXMoZWxlbWVudE5vZGUgPT09IG51bGwgfHwgZWxlbWVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnROb2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLCAuLi5nZXRMZWFmTm9kZXMoZWxlbWVudE5vZGUpXTtcbiAgICAgICAgICBsZWFmTm9kZSA9IChfbGVhZk5vZGVzMiRmaW5kTGFzdCA9IF9sZWFmTm9kZXMyLmZpbmRMYXN0KGxlYWYgPT4gaXNCZWZvcmUobm9uRWRpdGFibGVOb2RlLCBsZWFmKSkpICE9PSBudWxsICYmIF9sZWFmTm9kZXMyJGZpbmRMYXN0ICE9PSB2b2lkIDAgPyBfbGVhZk5vZGVzMiRmaW5kTGFzdCA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWZOb2RlKSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuICAgICAgICAgIGRvbU5vZGUgPSBsZWFmTm9kZTtcbiAgICAgICAgICBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgICBvZmZzZXQgLT0gZWwudGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZG9tTm9kZSAmJiBvZmZzZXQgPT09IGRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoICYmXG4gICAgICAvLyBDT01QQVQ6IEFuZHJvaWQgSU1FcyBtaWdodCByZW1vdmUgdGhlIHplcm8gd2lkdGggc3BhY2Ugd2hpbGUgY29tcG9zaW5nLFxuICAgICAgLy8gYW5kIHdlIGRvbid0IGFkZCBpdCBmb3IgbGluZS1icmVha3MuXG4gICAgICBJU19BTkRST0lEICYmIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSA9PT0gJ3onICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudCA9IGRvbU5vZGUudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9kb21Ob2RlJHRleHRDb250ZW50ICE9PSB2b2lkIDAgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQuc3RhcnRzV2l0aCgnXFx1RkVGRicpICYmIChcbiAgICAgIC8vIENPTVBBVDogSWYgdGhlIHBhcmVudCBub2RlIGlzIGEgU2xhdGUgemVyby13aWR0aCBzcGFjZSwgZWRpdG9yIGlzXG4gICAgICAvLyBiZWNhdXNlIHRoZSB0ZXh0IG5vZGUgc2hvdWxkIGhhdmUgbm8gY2hhcmFjdGVycy4gSG93ZXZlciwgZHVyaW5nIElNRVxuICAgICAgLy8gY29tcG9zaXRpb24gdGhlIEFTQ0lJIGNoYXJhY3RlcnMgd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhlIHplcm8td2lkdGhcbiAgICAgIC8vIHNwYWNlLCBzbyBzdWJ0cmFjdCAxIGZyb20gdGhlIG9mZnNldCB0byBhY2NvdW50IGZvciB0aGUgemVyby13aWR0aFxuICAgICAgLy8gc3BhY2UgY2hhcmFjdGVyLlxuICAgICAgcGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpIHx8XG4gICAgICAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIGByYW5nZS5jbG9uZUNvbnRlbnRzKClgIHJldHVybnMgYW4gZXh0cmEgdHJhaWxpbmcgJ1xcbidcbiAgICAgIC8vIHdoZW4gdGhlIGRvY3VtZW50IGVuZHMgd2l0aCBhIG5ldy1saW5lIGNoYXJhY3Rlci4gVGhpcyByZXN1bHRzIGluIHRoZSBvZmZzZXRcbiAgICAgIC8vIGxlbmd0aCBiZWluZyBvZmYgYnkgb25lLCBzbyB3ZSBuZWVkIHRvIHN1YnRyYWN0IG9uZSB0byBhY2NvdW50IGZvciB0aGlzLlxuICAgICAgSVNfRklSRUZPWCAmJiAoX2RvbU5vZGUkdGV4dENvbnRlbnQyID0gZG9tTm9kZS50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQyICE9PSB2b2lkIDAgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQyLmVuZHNXaXRoKCdcXG5cXG4nKSkpIHtcbiAgICAgICAgb2Zmc2V0LS07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChJU19BTkRST0lEICYmICF0ZXh0Tm9kZSAmJiAhZXhhY3RNYXRjaCkge1xuICAgICAgdmFyIG5vZGUgPSBwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1ub2RlJykgPyBwYXJlbnROb2RlIDogcGFyZW50Tm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlXScpO1xuICAgICAgaWYgKG5vZGUgJiYgRE9NRWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCBub2RlLCB7XG4gICAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgX3NsYXRlTm9kZSA9IERPTUVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIG5vZGUpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldDogX29mZnNldFxuICAgICAgICB9ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgRE9NRWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgX3NsYXRlTm9kZSkpO1xuICAgICAgICBpZiAoIW5vZGUucXVlcnlTZWxlY3RvcignW2RhdGEtc2xhdGUtbGVhZl0nKSkge1xuICAgICAgICAgIF9vZmZzZXQgPSBuZWFyZXN0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGV4dE5vZGUpIHtcbiAgICAgIGlmIChzdXBwcmVzc1Rocm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSBwb2ludCBmcm9tIERPTSBwb2ludDogXCIuY29uY2F0KGRvbVBvaW50KSk7XG4gICAgfVxuICAgIC8vIENPTVBBVDogSWYgc29tZW9uZSBpcyBjbGlja2luZyBmcm9tIG9uZSBTbGF0ZSBlZGl0b3IgaW50byBhbm90aGVyLFxuICAgIC8vIHRoZSBzZWxlY3QgZXZlbnQgZmlyZXMgdHdpY2UsIG9uY2UgZm9yIHRoZSBvbGQgZWRpdG9yJ3MgYGVsZW1lbnRgXG4gICAgLy8gZmlyc3QsIGFuZCB0aGVuIGFmdGVyd2FyZHMgZm9yIHRoZSBjb3JyZWN0IGBlbGVtZW50YC4gKDIwMTcvMDMvMDMpXG4gICAgdmFyIHNsYXRlTm9kZSA9IERPTUVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHRleHROb2RlKTtcbiAgICB2YXIgcGF0aCA9IERPTUVkaXRvci5maW5kUGF0aChlZGl0b3IsIHNsYXRlTm9kZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXRcbiAgICB9O1xuICB9LFxuICB0b1NsYXRlUmFuZ2U6IChlZGl0b3IsIGRvbVJhbmdlLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIF9mb2N1c05vZGUkdGV4dENvbnRlbjtcbiAgICB2YXIge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgZWwgPSBpc0RPTVNlbGVjdGlvbihkb21SYW5nZSkgPyBkb21SYW5nZS5hbmNob3JOb2RlIDogZG9tUmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgdmFyIGFuY2hvck5vZGU7XG4gICAgdmFyIGFuY2hvck9mZnNldDtcbiAgICB2YXIgZm9jdXNOb2RlO1xuICAgIHZhciBmb2N1c09mZnNldDtcbiAgICB2YXIgaXNDb2xsYXBzZWQ7XG4gICAgaWYgKGVsKSB7XG4gICAgICBpZiAoaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpKSB7XG4gICAgICAgIC8vIENPTVBBVDogSW4gZmlyZWZveCB0aGUgbm9ybWFsIHNlbGV0aW9uIHdheSBkb2VzIG5vdCB3b3JrXG4gICAgICAgIC8vIChodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC81NDg2I2lzc3VlLTE4MjA3MjAyMjMpXG4gICAgICAgIGlmIChJU19GSVJFRk9YICYmIGRvbVJhbmdlLnJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgICAgZm9jdXNOb2RlID0gZG9tUmFuZ2UuZm9jdXNOb2RlOyAvLyBGb2N1cyBub2RlIHdvcmtzIGZpbmVcbiAgICAgICAgICB2YXIgZmlyc3RSYW5nZSA9IGRvbVJhbmdlLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgdmFyIGxhc3RSYW5nZSA9IGRvbVJhbmdlLmdldFJhbmdlQXQoZG9tUmFuZ2UucmFuZ2VDb3VudCAtIDEpO1xuICAgICAgICAgIC8vIEhlcmUgd2UgYXJlIGluIHRoZSBjb250ZW50ZWRpdGFibGUgbW9kZSBvZiBhIHRhYmxlIGluIGZpcmVmb3hcbiAgICAgICAgICBpZiAoZm9jdXNOb2RlIGluc3RhbmNlb2YgSFRNTFRhYmxlUm93RWxlbWVudCAmJiBmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyIGluc3RhbmNlb2YgSFRNTFRhYmxlUm93RWxlbWVudCAmJiBsYXN0UmFuZ2Uuc3RhcnRDb250YWluZXIgaW5zdGFuY2VvZiBIVE1MVGFibGVSb3dFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBIVE1MRWxlbWVudCwgYmVjb3VzZSBFbGVtZW50IGlzIGEgc2xhdGUgZWxlbWVudFxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TGFzdENoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldExhc3RDaGlsZHJlbihlbGVtZW50LmNoaWxkcmVuWzBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpcnN0Tm9kZVJvdyA9IGZpcnN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICB2YXIgbGFzdE5vZGVSb3cgPSBsYXN0UmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBmYWlsIGFzIFwiVGhlIEhUTUxFbGVtZW50IGludGVyZmFjZSByZXByZXNlbnRzIGFueSBIVE1MIGVsZW1lbnQuXCJcbiAgICAgICAgICAgIHZhciBmaXJzdE5vZGUgPSBnZXRMYXN0Q2hpbGRyZW4oZmlyc3ROb2RlUm93LmNoaWxkcmVuW2ZpcnN0UmFuZ2Uuc3RhcnRPZmZzZXRdKTtcbiAgICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IGdldExhc3RDaGlsZHJlbihsYXN0Tm9kZVJvdy5jaGlsZHJlbltsYXN0UmFuZ2Uuc3RhcnRPZmZzZXRdKTtcbiAgICAgICAgICAgIC8vIFplcm8sIGFzIHdlIGFsbHdheXMgdGFrZSB0aGUgcmlnaHQgb25lIGFzIHRoZSBhbmNob3IgcG9pbnRcbiAgICAgICAgICAgIGZvY3VzT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmIChsYXN0Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZSA9IGxhc3ROb2RlLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlID0gbGFzdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3ROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb2N1c05vZGUgPSBmaXJzdE5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvY3VzTm9kZSA9IGZpcnN0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0Tm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGxhc3ROb2RlLmlubmVySFRNTC5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGYWxsYmFjayBvcHRpb25cbiAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcmVhZCBvbmx5IG1vZGUgb2YgYSBmaXJlZm94IHRhYmxlXG4gICAgICAgICAgICAvLyBSaWdodCB0byBsZWZ0XG4gICAgICAgICAgICBpZiAoZmlyc3RSYW5nZS5zdGFydENvbnRhaW5lciA9PT0gZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBsYXN0UmFuZ2UuZW5kQ29udGFpbmVyO1xuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBsYXN0UmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgICBmb2N1c09mZnNldCA9IGZpcnN0UmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBMZWZ0IHRvIHJpZ2h0XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBmaXJzdFJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgICAgICAgICAgICBhbmNob3JPZmZzZXQgPSBmaXJzdFJhbmdlLmVuZE9mZnNldDtcbiAgICAgICAgICAgICAgZm9jdXNPZmZzZXQgPSBsYXN0UmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5hbmNob3JOb2RlO1xuICAgICAgICAgIGFuY2hvck9mZnNldCA9IGRvbVJhbmdlLmFuY2hvck9mZnNldDtcbiAgICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5mb2N1c05vZGU7XG4gICAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5mb2N1c09mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDT01QQVQ6IFRoZXJlJ3MgYSBidWcgaW4gY2hyb21lIHRoYXQgYWx3YXlzIHJldHVybnMgYHRydWVgIGZvclxuICAgICAgICAvLyBgaXNDb2xsYXBzZWRgIGZvciBhIFNlbGVjdGlvbiB0aGF0IGNvbWVzIGZyb20gYSBTaGFkb3dSb290LlxuICAgICAgICAvLyAoMjAyMC8wOC8wOClcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3NTIzXG4gICAgICAgIC8vIElzQ29sbGFwc2VkIG1pZ2h0IG5vdCB3b3JrIGluIGZpcmVmb3gsIGJ1dCB0aGlzIHdpbGxcbiAgICAgICAgaWYgKElTX0NIUk9NRSAmJiBoYXNTaGFkb3dSb290KGFuY2hvck5vZGUpIHx8IElTX0ZJUkVGT1gpIHtcbiAgICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmFuY2hvck5vZGUgPT09IGRvbVJhbmdlLmZvY3VzTm9kZSAmJiBkb21SYW5nZS5hbmNob3JPZmZzZXQgPT09IGRvbVJhbmdlLmZvY3VzT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuaXNDb2xsYXBzZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gZG9tUmFuZ2Uuc3RhcnRPZmZzZXQ7XG4gICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5lbmRPZmZzZXQ7XG4gICAgICAgIGlzQ29sbGFwc2VkID0gZG9tUmFuZ2UuY29sbGFwc2VkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYW5jaG9yTm9kZSA9PSBudWxsIHx8IGZvY3VzTm9kZSA9PSBudWxsIHx8IGFuY2hvck9mZnNldCA9PSBudWxsIHx8IGZvY3VzT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBET00gcmFuZ2U6IFwiLmNvbmNhdChkb21SYW5nZSkpO1xuICAgIH1cbiAgICAvLyBDT01QQVQ6IEZpcmVmb3ggc29tZXRpbWVzIGluY2x1ZGVzIGFuIGV4dHJhIFxcbiAocmVuZGVyZWQgYnkgVGV4dFN0cmluZ1xuICAgIC8vIHdoZW4gaXNUcmFpbGluZyBpcyB0cnVlKSBpbiB0aGUgZm9jdXNPZmZzZXQsIHJlc3VsdGluZyBpbiBhbiBpbnZhbGlkXG4gICAgLy8gU2xhdGUgcG9pbnQuICgyMDIzLzExLzAxKVxuICAgIGlmIChJU19GSVJFRk9YICYmIChfZm9jdXNOb2RlJHRleHRDb250ZW4gPSBmb2N1c05vZGUudGV4dENvbnRlbnQpICE9PSBudWxsICYmIF9mb2N1c05vZGUkdGV4dENvbnRlbiAhPT0gdm9pZCAwICYmIF9mb2N1c05vZGUkdGV4dENvbnRlbi5lbmRzV2l0aCgnXFxuXFxuJykgJiYgZm9jdXNPZmZzZXQgPT09IGZvY3VzTm9kZS50ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICAgIGZvY3VzT2Zmc2V0LS07XG4gICAgfVxuICAgIHZhciBhbmNob3IgPSBET01FZGl0b3IudG9TbGF0ZVBvaW50KGVkaXRvciwgW2FuY2hvck5vZGUsIGFuY2hvck9mZnNldF0sIHtcbiAgICAgIGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93XG4gICAgfSk7XG4gICAgaWYgKCFhbmNob3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgZm9jdXNCZWZvcmVBbmNob3IgPSBpc0JlZm9yZShhbmNob3JOb2RlLCBmb2N1c05vZGUpIHx8IGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBmb2N1c09mZnNldCA8IGFuY2hvck9mZnNldDtcbiAgICB2YXIgZm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFuY2hvciA6IERPTUVkaXRvci50b1NsYXRlUG9pbnQoZWRpdG9yLCBbZm9jdXNOb2RlLCBmb2N1c09mZnNldF0sIHtcbiAgICAgIGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93LFxuICAgICAgc2VhcmNoRGlyZWN0aW9uOiBmb2N1c0JlZm9yZUFuY2hvciA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCdcbiAgICB9KTtcbiAgICBpZiAoIWZvY3VzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0ge1xuICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICBmb2N1czogZm9jdXNcbiAgICB9O1xuICAgIC8vIGlmIHRoZSBzZWxlY3Rpb24gaXMgYSBoYW5naW5nIHJhbmdlIHRoYXQgZW5kcyBpbiBhIHZvaWRcbiAgICAvLyBhbmQgdGhlIERPTSBmb2N1cyBpcyBhbiBFbGVtZW50XG4gICAgLy8gKG1lYW5pbmcgdGhhdCB0aGUgc2VsZWN0aW9uIGVuZHMgYmVmb3JlIHRoZSBlbGVtZW50KVxuICAgIC8vIHVuaGFuZyB0aGUgcmFuZ2UgdG8gYXZvaWQgbWlzdGFrZW5seSBpbmNsdWRpbmcgdGhlIHZvaWRcbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChyYW5nZSkgJiYgUmFuZ2UuaXNGb3J3YXJkKHJhbmdlKSAmJiBpc0RPTUVsZW1lbnQoZm9jdXNOb2RlKSAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZS5mb2N1cyxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pKSB7XG4gICAgICByYW5nZSA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlLCB7XG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSB0ZXh0IGRpZmYgd2FzIGFwcGxpZWQgaW4gYSB3YXkgd2UgY2FuIHBlcmZvcm0gdGhlIHBlbmRpbmcgYWN0aW9uIG9uIC9cbiAqIHJlY292ZXIgdGhlIHBlbmRpbmcgc2VsZWN0aW9uLlxuICovXG5mdW5jdGlvbiB2ZXJpZnlEaWZmU3RhdGUoZWRpdG9yLCB0ZXh0RGlmZikge1xuICB2YXIge1xuICAgIHBhdGgsXG4gICAgZGlmZlxuICB9ID0gdGV4dERpZmY7XG4gIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBwYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRpZmYuc3RhcnQgIT09IG5vZGUudGV4dC5sZW5ndGggfHwgZGlmZi50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBub2RlLnRleHQuc2xpY2UoZGlmZi5zdGFydCwgZGlmZi5zdGFydCArIGRpZmYudGV4dC5sZW5ndGgpID09PSBkaWZmLnRleHQ7XG4gIH1cbiAgdmFyIG5leHRQYXRoID0gUGF0aC5uZXh0KHBhdGgpO1xuICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgbmV4dFBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBuZXh0Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgbmV4dFBhdGgpO1xuICByZXR1cm4gVGV4dC5pc1RleHQobmV4dE5vZGUpICYmIG5leHROb2RlLnRleHQuc3RhcnRzV2l0aChkaWZmLnRleHQpO1xufVxuZnVuY3Rpb24gYXBwbHlTdHJpbmdEaWZmKHRleHQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGRpZmZzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBkaWZmc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIGRpZmZzLnJlZHVjZSgodGV4dCwgZGlmZikgPT4gdGV4dC5zbGljZSgwLCBkaWZmLnN0YXJ0KSArIGRpZmYudGV4dCArIHRleHQuc2xpY2UoZGlmZi5lbmQpLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIGxvbmdlc3RDb21tb25QcmVmaXhMZW5ndGgoc3RyLCBhbm90aGVyKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyLmNoYXJBdChpKSAhPT0gYW5vdGhlci5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblN1ZmZpeExlbmd0aChzdHIsIGFub3RoZXIsIG1heCkge1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgsIG1heCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gaSAtIDEpICE9PSBhbm90aGVyLmNoYXJBdChhbm90aGVyLmxlbmd0aCAtIGkgLSAxKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqIFJlbW92ZSByZWR1bmRhbnQgY2hhbmdlcyBmcm9tIHRoZSBkaWZmIHNvIHRoYXQgaXQgc3BhbnMgdGhlIG1pbmltYWwgcG9zc2libGUgcmFuZ2VcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nRGlmZih0YXJnZXRUZXh0LCBkaWZmKSB7XG4gIHZhciB7XG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIHRleHRcbiAgfSA9IGRpZmY7XG4gIHZhciByZW1vdmVkVGV4dCA9IHRhcmdldFRleHQuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHZhciBwcmVmaXhMZW5ndGggPSBsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoKHJlbW92ZWRUZXh0LCB0ZXh0KTtcbiAgdmFyIG1heCA9IE1hdGgubWluKHJlbW92ZWRUZXh0Lmxlbmd0aCAtIHByZWZpeExlbmd0aCwgdGV4dC5sZW5ndGggLSBwcmVmaXhMZW5ndGgpO1xuICB2YXIgc3VmZml4TGVuZ3RoID0gbG9uZ2VzdENvbW1vblN1ZmZpeExlbmd0aChyZW1vdmVkVGV4dCwgdGV4dCwgbWF4KTtcbiAgdmFyIG5vcm1hbGl6ZWQgPSB7XG4gICAgc3RhcnQ6IHN0YXJ0ICsgcHJlZml4TGVuZ3RoLFxuICAgIGVuZDogZW5kIC0gc3VmZml4TGVuZ3RoLFxuICAgIHRleHQ6IHRleHQuc2xpY2UocHJlZml4TGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIHN1ZmZpeExlbmd0aClcbiAgfTtcbiAgaWYgKG5vcm1hbGl6ZWQuc3RhcnQgPT09IG5vcm1hbGl6ZWQuZW5kICYmIG5vcm1hbGl6ZWQudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8qKlxuICogUmV0dXJuIGEgc3RyaW5nIGRpZmYgdGhhdCBpcyBlcXVpdmFsZW50IHRvIGFwcGx5aW5nIGIgYWZ0ZXIgYSBzcGFubmluZyB0aGUgcmFuZ2Ugb2ZcbiAqIGJvdGggY2hhbmdlc1xuICovXG5mdW5jdGlvbiBtZXJnZVN0cmluZ0RpZmZzKHRhcmdldFRleHQsIGEsIGIpIHtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4oYS5zdGFydCwgYi5zdGFydCk7XG4gIHZhciBvdmVybGFwID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oYS5zdGFydCArIGEudGV4dC5sZW5ndGgsIGIuZW5kKSAtIGIuc3RhcnQpO1xuICB2YXIgYXBwbGllZCA9IGFwcGx5U3RyaW5nRGlmZih0YXJnZXRUZXh0LCBhLCBiKTtcbiAgdmFyIHNsaWNlRW5kID0gTWF0aC5tYXgoYi5zdGFydCArIGIudGV4dC5sZW5ndGgsIGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoICsgKGEuc3RhcnQgKyBhLnRleHQubGVuZ3RoID4gYi5zdGFydCA/IGIudGV4dC5sZW5ndGggOiAwKSAtIG92ZXJsYXApO1xuICB2YXIgdGV4dCA9IGFwcGxpZWQuc2xpY2Uoc3RhcnQsIHNsaWNlRW5kKTtcbiAgdmFyIGVuZCA9IE1hdGgubWF4KGEuZW5kLCBiLmVuZCAtIGEudGV4dC5sZW5ndGggKyAoYS5lbmQgLSBhLnN0YXJ0KSk7XG4gIHJldHVybiBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldFRleHQsIHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgdGV4dFxuICB9KTtcbn1cbi8qKlxuICogR2V0IHRoZSBzbGF0ZSByYW5nZSB0aGUgdGV4dCBkaWZmIHNwYW5zLlxuICovXG5mdW5jdGlvbiB0YXJnZXRSYW5nZSh0ZXh0RGlmZikge1xuICB2YXIge1xuICAgIHBhdGgsXG4gICAgZGlmZlxuICB9ID0gdGV4dERpZmY7XG4gIHJldHVybiB7XG4gICAgYW5jaG9yOiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLnN0YXJ0XG4gICAgfSxcbiAgICBmb2N1czoge1xuICAgICAgcGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5lbmRcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhICdwZW5kaW5nIHBvaW50JyBhLmsuYSBhIHBvaW50IGJhc2VkIG9uIHRoZSBkb20gc3RhdGUgYmVmb3JlIGFwcGx5aW5nXG4gKiB0aGUgcGVuZGluZyBkaWZmcy4gU2luY2UgdGhlIHBlbmRpbmcgZGlmZnMgbWlnaHQgaGF2ZSBiZWVuIGluc2VydGVkIHdpdGggZGlmZmVyZW50XG4gKiBtYXJrcyB3ZSBoYXZlIHRvICd3YWxrJyB0aGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGVuc3VyZSB3ZSBzdGlsbFxuICogaGF2ZSBhIHZhbGlkIHBvaW50IGluc2lkZSB0aGUgZG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCBwb2ludCkge1xuICB2YXIge1xuICAgIHBhdGgsXG4gICAgb2Zmc2V0XG4gIH0gPSBwb2ludDtcbiAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGxlYWYgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICBpZiAoIVRleHQuaXNUZXh0KGxlYWYpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHBhcmVudEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgYXQ6IHBhdGhcbiAgfSk7XG4gIGlmICghcGFyZW50QmxvY2spIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB3aGlsZSAob2Zmc2V0ID4gbGVhZi50ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IEVkaXRvci5uZXh0KGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICB9KTtcbiAgICBpZiAoIWVudHJ5IHx8ICFQYXRoLmlzRGVzY2VuZGFudChlbnRyeVsxXSwgcGFyZW50QmxvY2tbMV0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgb2Zmc2V0IC09IGxlYWYudGV4dC5sZW5ndGg7XG4gICAgbGVhZiA9IGVudHJ5WzBdO1xuICAgIHBhdGggPSBlbnRyeVsxXTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgb2Zmc2V0XG4gIH07XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhICdwZW5kaW5nIHNlbGVjdGlvbicgdG8gZW5zdXJlIGl0J3MgdmFsaWQgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgdmFyIGFuY2hvciA9IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcmFuZ2UuYW5jaG9yKTtcbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzOiBhbmNob3JcbiAgICB9O1xuICB9XG4gIHZhciBmb2N1cyA9IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMpO1xuICBpZiAoIWZvY3VzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHBvaW50LCBvcCkge1xuICB2YXIgcGVuZGluZ0RpZmZzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcik7XG4gIHZhciB0ZXh0RGlmZiA9IHBlbmRpbmdEaWZmcyA9PT0gbnVsbCB8fCBwZW5kaW5nRGlmZnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdEaWZmcy5maW5kKF9yZWYgPT4ge1xuICAgIHZhciB7XG4gICAgICBwYXRoXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKHBhdGgsIHBvaW50LnBhdGgpO1xuICB9KTtcbiAgaWYgKCF0ZXh0RGlmZiB8fCBwb2ludC5vZmZzZXQgPD0gdGV4dERpZmYuZGlmZi5zdGFydCkge1xuICAgIHJldHVybiBQb2ludC50cmFuc2Zvcm0ocG9pbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG4gIHZhciB7XG4gICAgZGlmZlxuICB9ID0gdGV4dERpZmY7XG4gIC8vIFBvaW50IHJlZmVyZW5jZXMgbG9jYXRpb24gaW5zaWRlIHRoZSBkaWZmID0+IHRyYW5zZm9ybSB0aGUgcG9pbnQgYmFzZWQgb24gdGhlIGxvY2F0aW9uXG4gIC8vIHRoZSBkaWZmIHdpbGwgYmUgYXBwbGllZCB0byBhbmQgYWRkIHRoZSBvZmZzZXQgaW5zaWRlIHRoZSBkaWZmLlxuICBpZiAocG9pbnQub2Zmc2V0IDw9IGRpZmYuc3RhcnQgKyBkaWZmLnRleHQubGVuZ3RoKSB7XG4gICAgdmFyIF9hbmNob3IgPSB7XG4gICAgICBwYXRoOiBwb2ludC5wYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLnN0YXJ0XG4gICAgfTtcbiAgICB2YXIgX3RyYW5zZm9ybWVkID0gUG9pbnQudHJhbnNmb3JtKF9hbmNob3IsIG9wLCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICAgIGlmICghX3RyYW5zZm9ybWVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IF90cmFuc2Zvcm1lZC5wYXRoLFxuICAgICAgb2Zmc2V0OiBfdHJhbnNmb3JtZWQub2Zmc2V0ICsgcG9pbnQub2Zmc2V0IC0gZGlmZi5zdGFydFxuICAgIH07XG4gIH1cbiAgLy8gUG9pbnQgcmVmZXJlbmNlcyBsb2NhdGlvbiBhZnRlciB0aGUgZGlmZlxuICB2YXIgYW5jaG9yID0ge1xuICAgIHBhdGg6IHBvaW50LnBhdGgsXG4gICAgb2Zmc2V0OiBwb2ludC5vZmZzZXQgLSBkaWZmLnRleHQubGVuZ3RoICsgZGlmZi5lbmQgLSBkaWZmLnN0YXJ0XG4gIH07XG4gIHZhciB0cmFuc2Zvcm1lZCA9IFBvaW50LnRyYW5zZm9ybShhbmNob3IsIG9wLCB7XG4gICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgfSk7XG4gIGlmICghdHJhbnNmb3JtZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3AudHlwZSA9PT0gJ3NwbGl0X25vZGUnICYmIFBhdGguZXF1YWxzKG9wLnBhdGgsIHBvaW50LnBhdGgpICYmIGFuY2hvci5vZmZzZXQgPCBvcC5wb3NpdGlvbiAmJiBkaWZmLnN0YXJ0IDwgb3AucG9zaXRpb24pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiB0cmFuc2Zvcm1lZC5wYXRoLFxuICAgIG9mZnNldDogdHJhbnNmb3JtZWQub2Zmc2V0ICsgZGlmZi50ZXh0Lmxlbmd0aCAtIGRpZmYuZW5kICsgZGlmZi5zdGFydFxuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtUGVuZGluZ1JhbmdlKGVkaXRvciwgcmFuZ2UsIG9wKSB7XG4gIHZhciBhbmNob3IgPSB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCByYW5nZS5hbmNob3IsIG9wKTtcbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzOiBhbmNob3JcbiAgICB9O1xuICB9XG4gIHZhciBmb2N1cyA9IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHJhbmdlLmZvY3VzLCBvcCk7XG4gIGlmICghZm9jdXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmLFxuICAgIGlkXG4gIH0gPSB0ZXh0RGlmZjtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLm9mZnNldCA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0RGlmZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3Aub2Zmc2V0IDw9IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogb3AudGV4dC5sZW5ndGggKyBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IG9wLnRleHQubGVuZ3RoICsgZGlmZi5lbmQsXG4gICAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgKyBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBvcC5vZmZzZXQgPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dERpZmY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLm9mZnNldCArIG9wLnRleHQubGVuZ3RoIDw9IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICBlbmQ6IGRpZmYuZW5kIC0gb3AudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLnBvc2l0aW9uID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmYsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCB7XG4gICAgICAgICAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wLnBvc2l0aW9uID4gZGlmZi5zdGFydCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IE1hdGgubWluKG9wLnBvc2l0aW9uLCBkaWZmLmVuZCksXG4gICAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCAtIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwge1xuICAgICAgICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkaWZmLnN0YXJ0ICsgb3AucG9zaXRpb24sXG4gICAgICAgICAgICBlbmQ6IGRpZmYuZW5kICsgb3AucG9zaXRpb24sXG4gICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHBhdGg6IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKVxuICAgICAgICB9O1xuICAgICAgfVxuICB9XG4gIHZhciBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICBpZiAoIW5ld1BhdGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRpZmYsXG4gICAgcGF0aDogbmV3UGF0aCxcbiAgICBpZFxuICB9O1xufVxuXG4vKipcbiAqIFV0aWxpdGllcyBmb3Igc2luZ2xlLWxpbmUgZGVsZXRpb25cbiAqL1xudmFyIGRvUmVjdHNJbnRlcnNlY3QgPSAocmVjdCwgY29tcGFyZVJlY3QpID0+IHtcbiAgdmFyIG1pZGRsZSA9IChjb21wYXJlUmVjdC50b3AgKyBjb21wYXJlUmVjdC5ib3R0b20pIC8gMjtcbiAgcmV0dXJuIHJlY3QudG9wIDw9IG1pZGRsZSAmJiByZWN0LmJvdHRvbSA+PSBtaWRkbGU7XG59O1xudmFyIGFyZVJhbmdlc1NhbWVMaW5lID0gKGVkaXRvciwgcmFuZ2UxLCByYW5nZTIpID0+IHtcbiAgdmFyIHJlY3QxID0gRE9NRWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZTEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgcmVjdDIgPSBET01FZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHJhbmdlMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBkb1JlY3RzSW50ZXJzZWN0KHJlY3QxLCByZWN0MikgJiYgZG9SZWN0c0ludGVyc2VjdChyZWN0MiwgcmVjdDEpO1xufTtcbi8qKlxuICogQSBoZWxwZXIgdXRpbGl0eSB0aGF0IHJldHVybnMgdGhlIGVuZCBwb3J0aW9uIG9mIGEgYFJhbmdlYFxuICogd2hpY2ggaXMgbG9jYXRlZCBvbiBhIHNpbmdsZSBsaW5lLlxuICpcbiAqIEBwYXJhbSB7RWRpdG9yfSBlZGl0b3IgVGhlIGVkaXRvciBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0XG4gKiBAcGFyYW0ge1JhbmdlfSBwYXJlbnRSYW5nZSBUaGUgcGFyZW50IHJhbmdlIHRvIGNvbXBhcmUgYWdhaW5zdFxuICogQHJldHVybnMge1JhbmdlfSBBIHZhbGlkIHBvcnRpb24gb2YgdGhlIHBhcmVudFJhbmdlIHdoaWNoIGlzIG9uZSBhIHNpbmdsZSBsaW5lXG4gKi9cbnZhciBmaW5kQ3VycmVudExpbmVSYW5nZSA9IChlZGl0b3IsIHBhcmVudFJhbmdlKSA9PiB7XG4gIHZhciBwYXJlbnRSYW5nZUJvdW5kYXJ5ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgUmFuZ2UuZW5kKHBhcmVudFJhbmdlKSk7XG4gIHZhciBwb3NpdGlvbnMgPSBBcnJheS5mcm9tKEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCB7XG4gICAgYXQ6IHBhcmVudFJhbmdlXG4gIH0pKTtcbiAgdmFyIGxlZnQgPSAwO1xuICB2YXIgcmlnaHQgPSBwb3NpdGlvbnMubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihyaWdodCAvIDIpO1xuICBpZiAoYXJlUmFuZ2VzU2FtZUxpbmUoZWRpdG9yLCBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbbGVmdF0pLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KSkge1xuICAgIHJldHVybiBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbbGVmdF0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xuICB9XG4gIGlmIChwb3NpdGlvbnMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtIDFdLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KTtcbiAgfVxuICB3aGlsZSAobWlkZGxlICE9PSBwb3NpdGlvbnMubGVuZ3RoICYmIG1pZGRsZSAhPT0gbGVmdCkge1xuICAgIGlmIChhcmVSYW5nZXNTYW1lTGluZShlZGl0b3IsIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1ttaWRkbGVdKSwgcGFyZW50UmFuZ2VCb3VuZGFyeSkpIHtcbiAgICAgIHJpZ2h0ID0gbWlkZGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gbWlkZGxlO1xuICAgIH1cbiAgICBtaWRkbGUgPSBNYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG4gIH1cbiAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1tyaWdodF0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vKipcbiAqIGB3aXRoRE9NYCBhZGRzIERPTSBzcGVjaWZpYyBiZWhhdmlvcnMgdG8gdGhlIGVkaXRvci5cbiAqXG4gKiBJZiB5b3UgYXJlIHVzaW5nIFR5cGVTY3JpcHQsIHlvdSBtdXN0IGV4dGVuZCBTbGF0ZSdzIEN1c3RvbVR5cGVzIHRvIHVzZVxuICogdGhpcyBwbHVnaW4uXG4gKlxuICogU2VlIGh0dHBzOi8vZG9jcy5zbGF0ZWpzLm9yZy9jb25jZXB0cy8xMS10eXBlc2NyaXB0IHRvIGxlYXJuIGhvdy5cbiAqL1xudmFyIHdpdGhET00gPSBmdW5jdGlvbiB3aXRoRE9NKGVkaXRvcikge1xuICB2YXIgY2xpcGJvYXJkRm9ybWF0S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAneC1zbGF0ZS1mcmFnbWVudCc7XG4gIHZhciBlID0gZWRpdG9yO1xuICB2YXIge1xuICAgIGFwcGx5LFxuICAgIG9uQ2hhbmdlLFxuICAgIGRlbGV0ZUJhY2t3YXJkLFxuICAgIGFkZE1hcmssXG4gICAgcmVtb3ZlTWFya1xuICB9ID0gZTtcbiAgLy8gVGhlIFdlYWtNYXAgd2hpY2ggbWFwcyBhIGtleSB0byBhIHNwZWNpZmljIEhUTUxFbGVtZW50IG11c3QgYmUgc2NvcGVkIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UgdG9cbiAgLy8gYXZvaWQgY29sbGlzaW9ucyBiZXR3ZWVuIGVkaXRvcnMgaW4gdGhlIERPTSB0aGF0IHNoYXJlIHRoZSBzYW1lIHZhbHVlLlxuICBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuc2V0KGUsIG5ldyBXZWFrTWFwKCkpO1xuICBlLmFkZE1hcmsgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1NDSEVEVUxFX0YsIF9FRElUT1JfVE9fUEVORElOR19ESTtcbiAgICAoX0VESVRPUl9UT19TQ0hFRFVMRV9GID0gRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNILmdldChlKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GID09PSB2b2lkIDAgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GKCk7XG4gICAgaWYgKCFFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGUpICYmIChfRURJVE9SX1RPX1BFTkRJTkdfREkgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSkpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESSAhPT0gdm9pZCAwICYmIF9FRElUT1JfVE9fUEVORElOR19ESS5sZW5ndGgpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGUgY3VycmVudCBwZW5kaW5nIGRpZmZzIG9yaWdpbmF0aW5nIGZyb20gY2hhbmdlcyBiZWZvcmUgdGhlIGFkZE1hcmtcbiAgICAgIC8vIGFyZSBhcHBsaWVkIHdpdGggdGhlIGN1cnJlbnQgZm9ybWF0dGluZ1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLnNldChlLCBudWxsKTtcbiAgICB9XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGUpO1xuICAgIGFkZE1hcmsoa2V5LCB2YWx1ZSk7XG4gIH07XG4gIGUucmVtb3ZlTWFyayA9IGtleSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTI7XG4gICAgaWYgKCFFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGUpICYmIChfRURJVE9SX1RPX1BFTkRJTkdfREkyID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkyICE9PSB2b2lkIDAgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJMi5sZW5ndGgpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGUgY3VycmVudCBwZW5kaW5nIGRpZmZzIG9yaWdpbmF0aW5nIGZyb20gY2hhbmdlcyBiZWZvcmUgdGhlIGFkZE1hcmtcbiAgICAgIC8vIGFyZSBhcHBsaWVkIHdpdGggdGhlIGN1cnJlbnQgZm9ybWF0dGluZ1xuICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLnNldChlLCBudWxsKTtcbiAgICB9XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGUpO1xuICAgIHJlbW92ZU1hcmsoa2V5KTtcbiAgfTtcbiAgZS5kZWxldGVCYWNrd2FyZCA9IHVuaXQgPT4ge1xuICAgIGlmICh1bml0ICE9PSAnbGluZScpIHtcbiAgICAgIHJldHVybiBkZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgICB9XG4gICAgaWYgKGUuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGUuc2VsZWN0aW9uKSkge1xuICAgICAgdmFyIHBhcmVudEJsb2NrRW50cnkgPSBFZGl0b3IuYWJvdmUoZSwge1xuICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlLCBuKSxcbiAgICAgICAgYXQ6IGUuc2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGlmIChwYXJlbnRCbG9ja0VudHJ5KSB7XG4gICAgICAgIHZhciBbLCBwYXJlbnRCbG9ja1BhdGhdID0gcGFyZW50QmxvY2tFbnRyeTtcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnRSYW5nZSA9IEVkaXRvci5yYW5nZShlLCBwYXJlbnRCbG9ja1BhdGgsIGUuc2VsZWN0aW9uLmFuY2hvcik7XG4gICAgICAgIHZhciBjdXJyZW50TGluZVJhbmdlID0gZmluZEN1cnJlbnRMaW5lUmFuZ2UoZSwgcGFyZW50RWxlbWVudFJhbmdlKTtcbiAgICAgICAgaWYgKCFSYW5nZS5pc0NvbGxhcHNlZChjdXJyZW50TGluZVJhbmdlKSkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGUsIHtcbiAgICAgICAgICAgIGF0OiBjdXJyZW50TGluZVJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoaXMgYXR0ZW1wdHMgdG8gcmVzZXQgdGhlIE5PREVfVE9fS0VZIGVudHJ5IHRvIHRoZSBjb3JyZWN0IHZhbHVlXG4gIC8vIGFzIGFwcGx5KCkgY2hhbmdlcyB0aGUgb2JqZWN0IHJlZmVyZW5jZSBhbmQgaGVuY2UgaW52YWxpZGF0ZXMgdGhlIE5PREVfVE9fS0VZIGVudHJ5XG4gIGUuYXBwbHkgPSBvcCA9PiB7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgcGF0aFJlZk1hdGNoZXMgPSBbXTtcbiAgICB2YXIgcGVuZGluZ0RpZmZzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGUpO1xuICAgIGlmIChwZW5kaW5nRGlmZnMgIT09IG51bGwgJiYgcGVuZGluZ0RpZmZzICE9PSB2b2lkIDAgJiYgcGVuZGluZ0RpZmZzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zZm9ybWVkID0gcGVuZGluZ0RpZmZzLm1hcCh0ZXh0RGlmZiA9PiB0cmFuc2Zvcm1UZXh0RGlmZih0ZXh0RGlmZiwgb3ApKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICBFRElUT1JfVE9fUEVORElOR19ESUZGUy5zZXQoZSwgdHJhbnNmb3JtZWQpO1xuICAgIH1cbiAgICB2YXIgcGVuZGluZ1NlbGVjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5nZXQoZSk7XG4gICAgaWYgKHBlbmRpbmdTZWxlY3Rpb24pIHtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5zZXQoZSwgdHJhbnNmb3JtUGVuZGluZ1JhbmdlKGUsIHBlbmRpbmdTZWxlY3Rpb24sIG9wKSk7XG4gICAgfVxuICAgIHZhciBwZW5kaW5nQWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlKTtcbiAgICBpZiAocGVuZGluZ0FjdGlvbiAhPT0gbnVsbCAmJiBwZW5kaW5nQWN0aW9uICE9PSB2b2lkIDAgJiYgcGVuZGluZ0FjdGlvbi5hdCkge1xuICAgICAgdmFyIGF0ID0gUG9pbnQuaXNQb2ludChwZW5kaW5nQWN0aW9uID09PSBudWxsIHx8IHBlbmRpbmdBY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdBY3Rpb24uYXQpID8gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGUsIHBlbmRpbmdBY3Rpb24uYXQsIG9wKSA6IHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlLCBwZW5kaW5nQWN0aW9uLmF0LCBvcCk7XG4gICAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uc2V0KGUsIGF0ID8gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwZW5kaW5nQWN0aW9uKSwge30sIHtcbiAgICAgICAgYXRcbiAgICAgIH0pIDogbnVsbCk7XG4gICAgfVxuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goLi4uZ2V0TWF0Y2hlcyhlLCBvcC5wYXRoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9FRElUT1JfVE9fVVNFUl9TRUxFQztcbiAgICAgICAgICAvLyBTZWxlY3Rpb24gd2FzIG1hbnVhbGx5IHNldCwgZG9uJ3QgcmVzdG9yZSB0aGUgdXNlciBzZWxlY3Rpb24gYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgICAgICAgICAoX0VESVRPUl9UT19VU0VSX1NFTEVDID0gRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmdldChlKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19VU0VSX1NFTEVDID09PSB2b2lkIDAgfHwgX0VESVRPUl9UT19VU0VSX1NFTEVDLnVucmVmKCk7XG4gICAgICAgICAgRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OLmRlbGV0ZShlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgUGF0aC5wYXJlbnQob3AucGF0aCkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKG9wLnBhdGgpO1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIHByZXZQYXRoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKFBhdGgucGFyZW50KG9wLnBhdGgpLCBQYXRoLnBhcmVudChvcC5uZXdQYXRoKSk7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgY29tbW9uUGF0aCkpO1xuICAgICAgICAgIHZhciBjaGFuZ2VkUGF0aDtcbiAgICAgICAgICBpZiAoUGF0aC5pc0JlZm9yZShvcC5wYXRoLCBvcC5uZXdQYXRoKSkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgUGF0aC5wYXJlbnQob3AucGF0aCkpKTtcbiAgICAgICAgICAgIGNoYW5nZWRQYXRoID0gb3AubmV3UGF0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgUGF0aC5wYXJlbnQob3AubmV3UGF0aCkpKTtcbiAgICAgICAgICAgIGNoYW5nZWRQYXRoID0gb3AucGF0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNoYW5nZWROb2RlID0gTm9kZS5nZXQoZWRpdG9yLCBQYXRoLnBhcmVudChjaGFuZ2VkUGF0aCkpO1xuICAgICAgICAgIHZhciBjaGFuZ2VkTm9kZUtleSA9IERPTUVkaXRvci5maW5kS2V5KGUsIGNoYW5nZWROb2RlKTtcbiAgICAgICAgICB2YXIgY2hhbmdlZFBhdGhSZWYgPSBFZGl0b3IucGF0aFJlZihlLCBQYXRoLnBhcmVudChjaGFuZ2VkUGF0aCkpO1xuICAgICAgICAgIHBhdGhSZWZNYXRjaGVzLnB1c2goW2NoYW5nZWRQYXRoUmVmLCBjaGFuZ2VkTm9kZUtleV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5KG9wKTtcbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgSVNfTk9ERV9NQVBfRElSVFkuc2V0KGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIFtwYXRoLCBrZXldIG9mIG1hdGNoZXMpIHtcbiAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlLCBwYXRoKTtcbiAgICAgIE5PREVfVE9fS0VZLnNldChub2RlLCBrZXkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBbcGF0aFJlZiwgX2tleV0gb2YgcGF0aFJlZk1hdGNoZXMpIHtcbiAgICAgIGlmIChwYXRoUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgdmFyIFtfbm9kZV0gPSBFZGl0b3Iubm9kZShlLCBwYXRoUmVmLmN1cnJlbnQpO1xuICAgICAgICBOT0RFX1RPX0tFWS5zZXQoX25vZGUsIF9rZXkpO1xuICAgICAgfVxuICAgICAgcGF0aFJlZi51bnJlZigpO1xuICAgIH1cbiAgfTtcbiAgZS5zZXRGcmFnbWVudERhdGEgPSBkYXRhID0+IHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGU7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbik7XG4gICAgdmFyIHN0YXJ0Vm9pZCA9IEVkaXRvci52b2lkKGUsIHtcbiAgICAgIGF0OiBzdGFydC5wYXRoXG4gICAgfSk7XG4gICAgdmFyIGVuZFZvaWQgPSBFZGl0b3Iudm9pZChlLCB7XG4gICAgICBhdDogZW5kLnBhdGhcbiAgICB9KTtcbiAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGZha2Ugc2VsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBhIEJhc2U2NC1lbmNvZGVkIGNvcHkgb2YgdGhlXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIEhUTUwsIHRvIGRlY29kZSBvbiBmdXR1cmUgcGFzdGVzLlxuICAgIHZhciBkb21SYW5nZSA9IERPTUVkaXRvci50b0RPTVJhbmdlKGUsIHNlbGVjdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZG9tUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgIHZhciBhdHRhY2ggPSBjb250ZW50cy5jaGlsZE5vZGVzWzBdO1xuICAgIC8vIE1ha2Ugc3VyZSBhdHRhY2ggaXMgbm9uLWVtcHR5LCBzaW5jZSBlbXB0eSBub2RlcyB3aWxsIG5vdCBnZXQgY29waWVkLlxuICAgIGNvbnRlbnRzLmNoaWxkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGlmIChub2RlLnRleHRDb250ZW50ICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpICE9PSAnJykge1xuICAgICAgICBhdHRhY2ggPSBub2RlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIENPTVBBVDogSWYgdGhlIGVuZCBub2RlIGlzIGEgdm9pZCBub2RlLCB3ZSBuZWVkIHRvIG1vdmUgdGhlIGVuZCBvZiB0aGVcbiAgICAvLyByYW5nZSBmcm9tIHRoZSB2b2lkIG5vZGUncyBzcGFjZXIgc3BhbiwgdG8gdGhlIGVuZCBvZiB0aGUgdm9pZCBub2RlJ3NcbiAgICAvLyBjb250ZW50LCBzaW5jZSB0aGUgc3BhY2VyIGlzIGJlZm9yZSB2b2lkJ3MgY29udGVudCBpbiB0aGUgRE9NLlxuICAgIGlmIChlbmRWb2lkKSB7XG4gICAgICB2YXIgW3ZvaWROb2RlXSA9IGVuZFZvaWQ7XG4gICAgICB2YXIgciA9IGRvbVJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgIHZhciBkb21Ob2RlID0gRE9NRWRpdG9yLnRvRE9NTm9kZShlLCB2b2lkTm9kZSk7XG4gICAgICByLnNldEVuZEFmdGVyKGRvbU5vZGUpO1xuICAgICAgY29udGVudHMgPSByLmNsb25lQ29udGVudHMoKTtcbiAgICB9XG4gICAgLy8gQ09NUEFUOiBJZiB0aGUgc3RhcnQgbm9kZSBpcyBhIHZvaWQgbm9kZSwgd2UgbmVlZCB0byBhdHRhY2ggdGhlIGVuY29kZWRcbiAgICAvLyBmcmFnbWVudCB0byB0aGUgdm9pZCBub2RlJ3MgY29udGVudCBub2RlIGluc3RlYWQgb2YgdGhlIHNwYWNlciwgYmVjYXVzZVxuICAgIC8vIGF0dGFjaGluZyBpdCB0byBlbXB0eSBgPGRpdj4vPHNwYW4+YCBub2RlcyB3aWxsIGVuZCB1cCBoYXZpbmcgaXQgZXJhc2VkIGJ5XG4gICAgLy8gbW9zdCBicm93c2Vycy4gKDIwMTgvMDQvMjcpXG4gICAgaWYgKHN0YXJ0Vm9pZCkge1xuICAgICAgYXR0YWNoID0gY29udGVudHMucXVlcnlTZWxlY3RvcignW2RhdGEtc2xhdGUtc3BhY2VyXScpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgYW55IHplcm8td2lkdGggc3BhY2Ugc3BhbnMgZnJvbSB0aGUgY2xvbmVkIERPTSBzbyB0aGF0IHRoZXkgZG9uJ3RcbiAgICAvLyBzaG93IHVwIGVsc2V3aGVyZSB3aGVuIHBhc3RlZC5cbiAgICBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykpLmZvckVhY2goencgPT4ge1xuICAgICAgdmFyIGlzTmV3bGluZSA9IHp3LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgPT09ICduJztcbiAgICAgIHp3LnRleHRDb250ZW50ID0gaXNOZXdsaW5lID8gJ1xcbicgOiAnJztcbiAgICB9KTtcbiAgICAvLyBTZXQgYSBgZGF0YS1zbGF0ZS1mcmFnbWVudGAgYXR0cmlidXRlIG9uIGEgbm9uLWVtcHR5IG5vZGUsIHNvIGl0IHNob3dzIHVwXG4gICAgLy8gaW4gdGhlIEhUTUwsIGFuZCBjYW4gYmUgdXNlZCBmb3IgaW50cmEtU2xhdGUgcGFzdGluZy4gSWYgaXQncyBhIHRleHRcbiAgICAvLyBub2RlLCB3cmFwIGl0IGluIGEgYDxzcGFuPmAgc28gd2UgaGF2ZSBzb21ldGhpbmcgdG8gc2V0IGFuIGF0dHJpYnV0ZSBvbi5cbiAgICBpZiAoaXNET01UZXh0KGF0dGFjaCkpIHtcbiAgICAgIHZhciBzcGFuID0gYXR0YWNoLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgLy8gQ09NUEFUOiBJbiBDaHJvbWUgYW5kIFNhZmFyaSwgaWYgd2UgZG9uJ3QgYWRkIHRoZSBgd2hpdGUtc3BhY2VgIHN0eWxlXG4gICAgICAvLyB0aGVuIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlcyB3aWxsIGJlIGlnbm9yZWQuICgyMDE3LzA5LzIxKVxuICAgICAgc3Bhbi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZSc7XG4gICAgICBzcGFuLmFwcGVuZENoaWxkKGF0dGFjaCk7XG4gICAgICBjb250ZW50cy5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgIGF0dGFjaCA9IHNwYW47XG4gICAgfVxuICAgIHZhciBmcmFnbWVudCA9IGUuZ2V0RnJhZ21lbnQoKTtcbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZnJhZ21lbnQpO1xuICAgIHZhciBlbmNvZGVkID0gd2luZG93LmJ0b2EoZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykpO1xuICAgIGF0dGFjaC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtZnJhZ21lbnQnLCBlbmNvZGVkKTtcbiAgICBkYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9cIi5jb25jYXQoY2xpcGJvYXJkRm9ybWF0S2V5KSwgZW5jb2RlZCk7XG4gICAgLy8gQWRkIHRoZSBjb250ZW50IHRvIGEgPGRpdj4gc28gdGhhdCB3ZSBjYW4gZ2V0IGl0cyBpbm5lciBIVE1MLlxuICAgIHZhciBkaXYgPSBjb250ZW50cy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5hcHBlbmRDaGlsZChjb250ZW50cyk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJ3RydWUnKTtcbiAgICBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICBkYXRhLnNldERhdGEoJ3RleHQvaHRtbCcsIGRpdi5pbm5lckhUTUwpO1xuICAgIGRhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIGdldFBsYWluVGV4dChkaXYpKTtcbiAgICBjb250ZW50cy5vd25lckRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgZS5pbnNlcnREYXRhID0gZGF0YSA9PiB7XG4gICAgaWYgKCFlLmluc2VydEZyYWdtZW50RGF0YShkYXRhKSkge1xuICAgICAgZS5pbnNlcnRUZXh0RGF0YShkYXRhKTtcbiAgICB9XG4gIH07XG4gIGUuaW5zZXJ0RnJhZ21lbnREYXRhID0gZGF0YSA9PiB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tpbmcgY29waWVkIGZyYWdtZW50IGZyb20gYXBwbGljYXRpb24veC1zbGF0ZS1mcmFnbWVudCBvciBkYXRhLXNsYXRlLWZyYWdtZW50XG4gICAgICovXG4gICAgdmFyIGZyYWdtZW50ID0gZGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vXCIuY29uY2F0KGNsaXBib2FyZEZvcm1hdEtleSkpIHx8IGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUoZGF0YSk7XG4gICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICB2YXIgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudCh3aW5kb3cuYXRvYihmcmFnbWVudCkpO1xuICAgICAgdmFyIHBhcnNlZCA9IEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgICBlLmluc2VydEZyYWdtZW50KHBhcnNlZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBlLmluc2VydFRleHREYXRhID0gZGF0YSA9PiB7XG4gICAgdmFyIHRleHQgPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICBpZiAodGV4dCkge1xuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcbiAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgbGluZSBvZiBsaW5lcykge1xuICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZSwge1xuICAgICAgICAgICAgYWx3YXlzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZS5pbnNlcnRUZXh0KGxpbmUpO1xuICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBlLm9uQ2hhbmdlID0gb3B0aW9ucyA9PiB7XG4gICAgdmFyIG9uQ29udGV4dENoYW5nZSA9IEVESVRPUl9UT19PTl9DSEFOR0UuZ2V0KGUpO1xuICAgIGlmIChvbkNvbnRleHRDaGFuZ2UpIHtcbiAgICAgIG9uQ29udGV4dENoYW5nZShvcHRpb25zKTtcbiAgICB9XG4gICAgb25DaGFuZ2Uob3B0aW9ucyk7XG4gIH07XG4gIHJldHVybiBlO1xufTtcbnZhciBnZXRNYXRjaGVzID0gKGUsIHBhdGgpID0+IHtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgZm9yICh2YXIgW24sIHBdIG9mIEVkaXRvci5sZXZlbHMoZSwge1xuICAgIGF0OiBwYXRoXG4gIH0pKSB7XG4gICAgdmFyIGtleSA9IERPTUVkaXRvci5maW5kS2V5KGUsIG4pO1xuICAgIG1hdGNoZXMucHVzaChbcCwga2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59O1xuXG52YXIgVFJJUExFX0NMSUNLID0gMztcblxuLyoqXG4gKiBIb3RrZXkgbWFwcGluZ3MgZm9yIGVhY2ggcGxhdGZvcm0uXG4gKi9cbnZhciBIT1RLRVlTID0ge1xuICBib2xkOiAnbW9kK2InLFxuICBjb21wb3NlOiBbJ2Rvd24nLCAnbGVmdCcsICdyaWdodCcsICd1cCcsICdiYWNrc3BhY2UnLCAnZW50ZXInXSxcbiAgbW92ZUJhY2t3YXJkOiAnbGVmdCcsXG4gIG1vdmVGb3J3YXJkOiAncmlnaHQnLFxuICBtb3ZlV29yZEJhY2t3YXJkOiAnY3RybCtsZWZ0JyxcbiAgbW92ZVdvcmRGb3J3YXJkOiAnY3RybCtyaWdodCcsXG4gIGRlbGV0ZUJhY2t3YXJkOiAnc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZUZvcndhcmQ6ICdzaGlmdD8rZGVsZXRlJyxcbiAgZXh0ZW5kQmFja3dhcmQ6ICdzaGlmdCtsZWZ0JyxcbiAgZXh0ZW5kRm9yd2FyZDogJ3NoaWZ0K3JpZ2h0JyxcbiAgaXRhbGljOiAnbW9kK2knLFxuICBpbnNlcnRTb2Z0QnJlYWs6ICdzaGlmdCtlbnRlcicsXG4gIHNwbGl0QmxvY2s6ICdlbnRlcicsXG4gIHVuZG86ICdtb2Qreidcbn07XG52YXIgQVBQTEVfSE9US0VZUyA9IHtcbiAgbW92ZUxpbmVCYWNrd2FyZDogJ29wdCt1cCcsXG4gIG1vdmVMaW5lRm9yd2FyZDogJ29wdCtkb3duJyxcbiAgbW92ZVdvcmRCYWNrd2FyZDogJ29wdCtsZWZ0JyxcbiAgbW92ZVdvcmRGb3J3YXJkOiAnb3B0K3JpZ2h0JyxcbiAgZGVsZXRlQmFja3dhcmQ6IFsnY3RybCtiYWNrc3BhY2UnLCAnY3RybCtoJ10sXG4gIGRlbGV0ZUZvcndhcmQ6IFsnY3RybCtkZWxldGUnLCAnY3RybCtkJ10sXG4gIGRlbGV0ZUxpbmVCYWNrd2FyZDogJ2NtZCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlTGluZUZvcndhcmQ6IFsnY21kK3NoaWZ0PytkZWxldGUnLCAnY3RybCtrJ10sXG4gIGRlbGV0ZVdvcmRCYWNrd2FyZDogJ29wdCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlV29yZEZvcndhcmQ6ICdvcHQrc2hpZnQ/K2RlbGV0ZScsXG4gIGV4dGVuZExpbmVCYWNrd2FyZDogJ29wdCtzaGlmdCt1cCcsXG4gIGV4dGVuZExpbmVGb3J3YXJkOiAnb3B0K3NoaWZ0K2Rvd24nLFxuICByZWRvOiAnY21kK3NoaWZ0K3onLFxuICB0cmFuc3Bvc2VDaGFyYWN0ZXI6ICdjdHJsK3QnXG59O1xudmFyIFdJTkRPV1NfSE9US0VZUyA9IHtcbiAgZGVsZXRlV29yZEJhY2t3YXJkOiAnY3RybCtzaGlmdD8rYmFja3NwYWNlJyxcbiAgZGVsZXRlV29yZEZvcndhcmQ6ICdjdHJsK3NoaWZ0PytkZWxldGUnLFxuICByZWRvOiBbJ2N0cmwreScsICdjdHJsK3NoaWZ0K3onXVxufTtcbi8qKlxuICogQ3JlYXRlIGEgcGxhdGZvcm0tYXdhcmUgaG90a2V5IGNoZWNrZXIuXG4gKi9cbnZhciBjcmVhdGUgPSBrZXkgPT4ge1xuICB2YXIgZ2VuZXJpYyA9IEhPVEtFWVNba2V5XTtcbiAgdmFyIGFwcGxlID0gQVBQTEVfSE9US0VZU1trZXldO1xuICB2YXIgd2luZG93cyA9IFdJTkRPV1NfSE9US0VZU1trZXldO1xuICB2YXIgaXNHZW5lcmljID0gZ2VuZXJpYyAmJiBpc0hvdGtleShnZW5lcmljKTtcbiAgdmFyIGlzQXBwbGUgPSBhcHBsZSAmJiBpc0hvdGtleShhcHBsZSk7XG4gIHZhciBpc1dpbmRvd3MgPSB3aW5kb3dzICYmIGlzSG90a2V5KHdpbmRvd3MpO1xuICByZXR1cm4gZXZlbnQgPT4ge1xuICAgIGlmIChpc0dlbmVyaWMgJiYgaXNHZW5lcmljKGV2ZW50KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKElTX0FQUExFICYmIGlzQXBwbGUgJiYgaXNBcHBsZShldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmICghSVNfQVBQTEUgJiYgaXNXaW5kb3dzICYmIGlzV2luZG93cyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn07XG4vKipcbiAqIEhvdGtleXMuXG4gKi9cbnZhciBob3RrZXlzID0ge1xuICBpc0JvbGQ6IGNyZWF0ZSgnYm9sZCcpLFxuICBpc0NvbXBvc2U6IGNyZWF0ZSgnY29tcG9zZScpLFxuICBpc01vdmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlQmFja3dhcmQnKSxcbiAgaXNNb3ZlRm9yd2FyZDogY3JlYXRlKCdtb3ZlRm9yd2FyZCcpLFxuICBpc0RlbGV0ZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUJhY2t3YXJkJyksXG4gIGlzRGVsZXRlRm9yd2FyZDogY3JlYXRlKCdkZWxldGVGb3J3YXJkJyksXG4gIGlzRGVsZXRlTGluZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVGb3J3YXJkJyksXG4gIGlzRGVsZXRlV29yZEJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZVdvcmRGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRGb3J3YXJkJyksXG4gIGlzRXh0ZW5kQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kQmFja3dhcmQnKSxcbiAgaXNFeHRlbmRGb3J3YXJkOiBjcmVhdGUoJ2V4dGVuZEZvcndhcmQnKSxcbiAgaXNFeHRlbmRMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUJhY2t3YXJkJyksXG4gIGlzRXh0ZW5kTGluZUZvcndhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUZvcndhcmQnKSxcbiAgaXNJdGFsaWM6IGNyZWF0ZSgnaXRhbGljJyksXG4gIGlzTW92ZUxpbmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlTGluZUJhY2t3YXJkJyksXG4gIGlzTW92ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ21vdmVMaW5lRm9yd2FyZCcpLFxuICBpc01vdmVXb3JkQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZVdvcmRCYWNrd2FyZCcpLFxuICBpc01vdmVXb3JkRm9yd2FyZDogY3JlYXRlKCdtb3ZlV29yZEZvcndhcmQnKSxcbiAgaXNSZWRvOiBjcmVhdGUoJ3JlZG8nKSxcbiAgaXNTb2Z0QnJlYWs6IGNyZWF0ZSgnaW5zZXJ0U29mdEJyZWFrJyksXG4gIGlzU3BsaXRCbG9jazogY3JlYXRlKCdzcGxpdEJsb2NrJyksXG4gIGlzVHJhbnNwb3NlQ2hhcmFjdGVyOiBjcmVhdGUoJ3RyYW5zcG9zZUNoYXJhY3RlcicpLFxuICBpc1VuZG86IGNyZWF0ZSgndW5kbycpXG59O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcbnZhciBzaGFsbG93Q29tcGFyZSA9IChvYmoxLCBvYmoyKSA9PiBPYmplY3Qua2V5cyhvYmoxKS5sZW5ndGggPT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhvYmoxKS5ldmVyeShrZXkgPT4gb2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9iajFba2V5XSA9PT0gb2JqMltrZXldKTtcbnZhciBpc0RlY29yYXRpb25GbGFnc0VxdWFsID0gKHJhbmdlLCBvdGhlcikgPT4ge1xuICB2YXIgcmFuZ2VPd25Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhyYW5nZSwgX2V4Y2x1ZGVkKTtcbiAgdmFyIG90aGVyT3duUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3RoZXIsIF9leGNsdWRlZDIpO1xuICByZXR1cm4gcmFuZ2VbUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gb3RoZXJbUExBQ0VIT0xERVJfU1lNQk9MXSAmJiBzaGFsbG93Q29tcGFyZShyYW5nZU93blByb3BzLCBvdGhlck93blByb3BzKTtcbn07XG4vKipcbiAqIENoZWNrIGlmIGEgbGlzdCBvZiBkZWNvcmF0b3IgcmFuZ2VzIGFyZSBlcXVhbCB0byBhbm90aGVyLlxuICpcbiAqIFBFUkY6IHRoaXMgcmVxdWlyZXMgdGhlIHR3byBsaXN0cyB0byBhbHNvIGhhdmUgdGhlIHJhbmdlcyBpbnNpZGUgdGhlbSBpbiB0aGVcbiAqIHNhbWUgb3JkZXIsIGJ1dCB0aGlzIGlzIGFuIG9rYXkgY29uc3RyYWludCBmb3IgdXMgc2luY2UgZGVjb3JhdGlvbnMgYXJlXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cbiAqL1xudmFyIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwgPSAobGlzdCwgYW5vdGhlcikgPT4ge1xuICBpZiAobGlzdC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgdmFyIG90aGVyID0gYW5vdGhlcltpXTtcbiAgICBpZiAoIVJhbmdlLmVxdWFscyhyYW5nZSwgb3RoZXIpIHx8ICFpc0RlY29yYXRpb25GbGFnc0VxdWFsKHJhbmdlLCBvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBDaGVjayBpZiBhIGxpc3Qgb2YgZGVjb3JhdG9yIHJhbmdlcyBhcmUgZXF1YWwgdG8gYW5vdGhlci5cbiAqXG4gKiBQRVJGOiB0aGlzIHJlcXVpcmVzIHRoZSB0d28gbGlzdHMgdG8gYWxzbyBoYXZlIHRoZSByYW5nZXMgaW5zaWRlIHRoZW0gaW4gdGhlXG4gKiBzYW1lIG9yZGVyLCBidXQgdGhpcyBpcyBhbiBva2F5IGNvbnN0cmFpbnQgZm9yIHVzIHNpbmNlIGRlY29yYXRpb25zIGFyZVxuICoga2VwdCBpbiBvcmRlciwgYW5kIHRoZSBvZGQgY2FzZSB3aGVyZSB0aGV5IGFyZW4ndCBpcyBva2F5IHRvIHJlLXJlbmRlciBmb3IuXG4gKi9cbnZhciBpc1RleHREZWNvcmF0aW9uc0VxdWFsID0gKGxpc3QsIGFub3RoZXIpID0+IHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmFuZ2UgPSBsaXN0W2ldO1xuICAgIHZhciBvdGhlciA9IGFub3RoZXJbaV07XG4gICAgLy8gY29tcGFyZSBvbmx5IG9mZnNldHMgYmVjYXVzZSBwYXRocyBkb2Vzbid0IG1hdHRlciBmb3IgdGV4dFxuICAgIGlmIChyYW5nZS5hbmNob3Iub2Zmc2V0ICE9PSBvdGhlci5hbmNob3Iub2Zmc2V0IHx8IHJhbmdlLmZvY3VzLm9mZnNldCAhPT0gb3RoZXIuZm9jdXMub2Zmc2V0IHx8ICFpc0RlY29yYXRpb25GbGFnc0VxdWFsKHJhbmdlLCBvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgeyBDQU5fVVNFX0RPTSwgRE9NRWRpdG9yLCBET01FbGVtZW50LCBET01Ob2RlLCBET01SYW5nZSwgRE9NU2VsZWN0aW9uLCBET01TdGF0aWNSYW5nZSwgRE9NVGV4dCwgRURJVE9SX1RPX0VMRU1FTlQsIEVESVRPUl9UT19GT1JDRV9SRU5ERVIsIEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVCwgRURJVE9SX1RPX09OX0NIQU5HRSwgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLCBFRElUT1JfVE9fUEVORElOR19ESUZGUywgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLCBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04sIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULCBFRElUT1JfVE9fU0NIRURVTEVfRkxVU0gsIEVESVRPUl9UT19VU0VSX01BUktTLCBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04sIEVESVRPUl9UT19XSU5ET1csIEVMRU1FTlRfVE9fTk9ERSwgSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JULCBob3RrZXlzIGFzIEhvdGtleXMsIElTX0FORFJPSUQsIElTX0NIUk9NRSwgSVNfQ09NUE9TSU5HLCBJU19GSVJFRk9YLCBJU19GSVJFRk9YX0xFR0FDWSwgSVNfRk9DVVNFRCwgSVNfSU9TLCBJU19OT0RFX01BUF9ESVJUWSwgSVNfUkVBRF9PTkxZLCBJU19VQ19NT0JJTEUsIElTX1dFQktJVCwgSVNfV0VDSEFUQlJPV1NFUiwgS2V5LCBNQVJLX1BMQUNFSE9MREVSX1NZTUJPTCwgTk9ERV9UT19FTEVNRU5ULCBOT0RFX1RPX0lOREVYLCBOT0RFX1RPX0tFWSwgTk9ERV9UT19QQVJFTlQsIFBMQUNFSE9MREVSX1NZTUJPTCwgVFJJUExFX0NMSUNLLCBhcHBseVN0cmluZ0RpZmYsIGdldEFjdGl2ZUVsZW1lbnQsIGdldERlZmF1bHRWaWV3LCBnZXRTZWxlY3Rpb24sIGhhc1NoYWRvd1Jvb3QsIGlzQWZ0ZXIsIGlzQmVmb3JlLCBpc0RPTUVsZW1lbnQsIGlzRE9NTm9kZSwgaXNET01TZWxlY3Rpb24sIGlzRWxlbWVudERlY29yYXRpb25zRXF1YWwsIGlzUGxhaW5UZXh0T25seVBhc3RlLCBpc1RleHREZWNvcmF0aW9uc0VxdWFsLCBpc1RyYWNrZWRNdXRhdGlvbiwgbWVyZ2VTdHJpbmdEaWZmcywgbm9ybWFsaXplRE9NUG9pbnQsIG5vcm1hbGl6ZVBvaW50LCBub3JtYWxpemVSYW5nZSwgbm9ybWFsaXplU3RyaW5nRGlmZiwgdGFyZ2V0UmFuZ2UsIHZlcmlmeURpZmZTdGF0ZSwgd2l0aERPTSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOlsiVHJhbnNmb3JtcyIsIkVsZW1lbnQiLCJFZGl0b3IiLCJTY3J1YmJlciIsIlJhbmdlIiwiTm9kZSIsIlRleHQiLCJQYXRoIiwiUG9pbnQiLCJpc0hvdGtleSIsIkRPTU5vZGUiLCJnbG9iYWxUaGlzIiwiRE9NRWxlbWVudCIsIkRPTVRleHQiLCJET01SYW5nZSIsIkRPTVNlbGVjdGlvbiIsIlNlbGVjdGlvbiIsIkRPTVN0YXRpY1JhbmdlIiwiU3RhdGljUmFuZ2UiLCJnZXREZWZhdWx0VmlldyIsInZhbHVlIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNET01Db21tZW50IiwiaXNET01Ob2RlIiwibm9kZVR5cGUiLCJpc0RPTUVsZW1lbnQiLCJ3aW5kb3ciLCJpc0RPTVNlbGVjdGlvbiIsImFuY2hvck5vZGUiLCJpc0RPTVRleHQiLCJpc1BsYWluVGV4dE9ubHlQYXN0ZSIsImV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsImdldERhdGEiLCJ0eXBlcyIsImxlbmd0aCIsIm5vcm1hbGl6ZURPTVBvaW50IiwiZG9tUG9pbnQiLCJub2RlIiwib2Zmc2V0IiwiY2hpbGROb2RlcyIsImlzTGFzdCIsImluZGV4IiwiZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4IiwiaSIsImdldEVkaXRhYmxlQ2hpbGQiLCJ0ZXh0Q29udGVudCIsImhhc1NoYWRvd1Jvb3QiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwidG9TdHJpbmciLCJkaXJlY3Rpb24iLCJjaGlsZCIsInRyaWVkRm9yd2FyZCIsInRyaWVkQmFja3dhcmQiLCJnZXRBdHRyaWJ1dGUiLCJnZXRQbGFpblRleHQiLCJkb21Ob2RlIiwidGV4dCIsIm5vZGVWYWx1ZSIsImNoaWxkTm9kZSIsIkFycmF5IiwiZnJvbSIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRhZ05hbWUiLCJjYXRjaFNsYXRlRnJhZ21lbnQiLCJnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlIiwiZGF0YVRyYW5zZmVyIiwiaHRtbERhdGEiLCJmcmFnbWVudCIsIm1hdGNoIiwiZ2V0U2VsZWN0aW9uIiwicm9vdCIsImRvY3VtZW50IiwiaXNUcmFja2VkTXV0YXRpb24iLCJlZGl0b3IiLCJtdXRhdGlvbiIsImJhdGNoIiwidGFyZ2V0IiwibWF0Y2hlcyIsIkRPTUVkaXRvciIsImdldFdpbmRvdyIsImNvbnRhaW5zIiwiaGFzRE9NTm9kZSIsImVkaXRhYmxlIiwicGFyZW50TXV0YXRpb24iLCJmaW5kIiwiX3JlZiIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJfbm9kZSIsImdldEFjdGl2ZUVsZW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiX2FjdGl2ZUVsZW1lbnQiLCJzaGFkb3dSb290IiwiX2FjdGl2ZUVsZW1lbnQkc2hhZG93IiwiX2FjdGl2ZUVsZW1lbnQyIiwiaXNCZWZvcmUiLCJvdGhlck5vZGUiLCJCb29sZWFuIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJpc0FmdGVyIiwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIiwiX25hdmlnYXRvciR1c2VyQWdlbnQkIiwiX25hdmlnYXRvciR1c2VyQWdlbnQkMiIsIklTX0lPUyIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJNU1N0cmVhbSIsIklTX0FQUExFIiwiSVNfQU5EUk9JRCIsIklTX0ZJUkVGT1giLCJJU19XRUJLSVQiLCJJU19FREdFX0xFR0FDWSIsIklTX0NIUk9NRSIsIklTX0NIUk9NRV9MRUdBQ1kiLCJJU19BTkRST0lEX0NIUk9NRV9MRUdBQ1kiLCJJU19GSVJFRk9YX0xFR0FDWSIsIklTX1VDX01PQklMRSIsIklTX1dFQ0hBVEJST1dTRVIiLCJDQU5fVVNFX0RPTSIsImNyZWF0ZUVsZW1lbnQiLCJwYXJzZUludCIsIkhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCIsIklucHV0RXZlbnQiLCJwcm90b3R5cGUiLCJnZXRUYXJnZXRSYW5nZXMiLCJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJfdG9QcmltaXRpdmUiLCJpbnB1dCIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3RvUHJvcGVydHlLZXkiLCJhcmciLCJrZXkiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm4iLCJLZXkiLCJpZCIsImNvbmNhdCIsIklTX05PREVfTUFQX0RJUlRZIiwiV2Vha01hcCIsIk5PREVfVE9fSU5ERVgiLCJOT0RFX1RPX1BBUkVOVCIsIkVESVRPUl9UT19XSU5ET1ciLCJFRElUT1JfVE9fRUxFTUVOVCIsIkVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5UIiwiRUxFTUVOVF9UT19OT0RFIiwiTk9ERV9UT19FTEVNRU5UIiwiTk9ERV9UT19LRVkiLCJFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQiLCJJU19SRUFEX09OTFkiLCJJU19GT0NVU0VEIiwiSVNfQ09NUE9TSU5HIiwiRURJVE9SX1RPX1VTRVJfU0VMRUNUSU9OIiwiRURJVE9SX1RPX09OX0NIQU5HRSIsIkVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSCIsIkVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUyIsIkVESVRPUl9UT19VU0VSX01BUktTIiwiRURJVE9SX1RPX1BFTkRJTkdfRElGRlMiLCJFRElUT1JfVE9fUEVORElOR19BQ1RJT04iLCJFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04iLCJFRElUT1JfVE9fRk9SQ0VfUkVOREVSIiwiUExBQ0VIT0xERVJfU1lNQk9MIiwiTUFSS19QTEFDRUhPTERFUl9TWU1CT0wiLCJhbmRyb2lkUGVuZGluZ0RpZmZzIiwiZ2V0IiwiYW5kcm9pZFNjaGVkdWxlRmx1c2giLCJfRURJVE9SX1RPX1NDSEVEVUxFX0YiLCJibHVyIiwiZWwiLCJ0b0RPTU5vZGUiLCJmaW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QiLCJzZXQiLCJkZXNlbGVjdCIsInNlbGVjdGlvbiIsImRvbVNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJyZW1vdmVBbGxSYW5nZXMiLCJnZXRSb290Tm9kZSIsIkRvY3VtZW50IiwiU2hhZG93Um9vdCIsImZpbmRFdmVudFJhbmdlIiwibmF0aXZlRXZlbnQiLCJjbGllbnRYIiwieCIsImNsaWVudFkiLCJ5IiwiRXJyb3IiLCJ0b1NsYXRlTm9kZSIsInBhdGgiLCJmaW5kUGF0aCIsImlzRWxlbWVudCIsImlzVm9pZCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpc1ByZXYiLCJpc0lubGluZSIsImxlZnQiLCJ3aWR0aCIsInRvcCIsImhlaWdodCIsImVkZ2UiLCJwb2ludCIsImJlZm9yZSIsImFmdGVyIiwiX3JhbmdlIiwicmFuZ2UiLCJkb21SYW5nZSIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJwb3NpdGlvbiIsImNhcmV0UG9zaXRpb25Gcm9tUG9pbnQiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0Iiwib2Zmc2V0Tm9kZSIsInNldEVuZCIsInRvU2xhdGVSYW5nZSIsImV4YWN0TWF0Y2giLCJzdXBwcmVzc1Rocm93IiwiZmluZEtleSIsImlzRWRpdG9yIiwidW5zaGlmdCIsInN0cmluZ2lmeSIsImZvY3VzIiwib3B0aW9ucyIsImFyZ3VtZW50cyIsInJldHJpZXMiLCJvcGVyYXRpb25zIiwic2V0VGltZW91dCIsInRvRE9NUmFuZ2UiLCJhZGRSYW5nZSIsInNlbGVjdCIsInN0YXJ0IiwicHJldmVudFNjcm9sbCIsImVkaXRvckVsIiwidGFyZ2V0RWwiLCJwYXJlbnRFbGVtZW50IiwiZXJyIiwibWVzc2FnZSIsImluY2x1ZGVzIiwiY2xvc2VzdCIsImlzQ29udGVudEVkaXRhYmxlIiwiaGFzRWRpdGFibGVUYXJnZXQiLCJoYXNSYW5nZSIsImFuY2hvciIsImhhc1BhdGgiLCJoYXNTZWxlY3RhYmxlVGFyZ2V0IiwiaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQiLCJoYXNUYXJnZXQiLCJpbnNlcnREYXRhIiwiZGF0YSIsImluc2VydEZyYWdtZW50RGF0YSIsImluc2VydFRleHREYXRhIiwiaXNDb21wb3NpbmciLCJpc0ZvY3VzZWQiLCJpc1JlYWRPbmx5Iiwic2xhdGVOb2RlIiwic2V0RnJhZ21lbnREYXRhIiwib3JpZ2luRXZlbnQiLCJLRVlfVE9fRUxFTUVOVCIsInRvRE9NUG9pbnQiLCJ2b2lkIiwiYXQiLCJzZWxlY3RvciIsInRleHRzIiwicXVlcnlTZWxlY3RvckFsbCIsImF0dHIiLCJ0cnVlTGVuZ3RoIiwiZW5kIiwibmV4dFRleHQiLCJoYXNBdHRyaWJ1dGUiLCJfbmV4dFRleHQkdGV4dENvbnRlbnQiLCJkb21UZXh0Iiwic3RhcnRzV2l0aCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJpc0JhY2t3YXJkIiwiZG9tQW5jaG9yIiwiZG9tRm9jdXMiLCJpc0NvbGxhcHNlZCIsInN0YXJ0Tm9kZSIsInN0YXJ0T2Zmc2V0IiwiZW5kTm9kZSIsImVuZE9mZnNldCIsInN0YXJ0RWwiLCJpc1N0YXJ0QXRaZXJvV2lkdGgiLCJlbmRFbCIsImlzRW5kQXRaZXJvV2lkdGgiLCJkb21FbCIsInRvU2xhdGVQb2ludCIsInNlYXJjaERpcmVjdGlvbiIsIm5lYXJlc3ROb2RlIiwibmVhcmVzdE9mZnNldCIsInRleHROb2RlIiwiX2RvbU5vZGUkdGV4dENvbnRlbnQiLCJfZG9tTm9kZSR0ZXh0Q29udGVudDIiLCJwb3RlbnRpYWxWb2lkTm9kZSIsInZvaWROb2RlIiwicG90ZW50aWFsTm9uRWRpdGFibGVOb2RlIiwibm9uRWRpdGFibGVOb2RlIiwibGVhZk5vZGUiLCJjb250ZW50cyIsImNsb25lQ29udGVudHMiLCJyZW1vdmFscyIsInNsaWNlIiwiZm9yRWFjaCIsInRleHRDb250ZXh0IiwicmVtb3ZlQ2hpbGQiLCJsZWFmTm9kZXMiLCJjdXJyZW50IiwiZ2V0TGVhZk5vZGVzIiwiZWxlbWVudE5vZGUiLCJfbGVhZk5vZGVzJGZpbmQiLCJfbGVhZk5vZGVzIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwibGVhZiIsIl9sZWFmTm9kZXMyJGZpbmRMYXN0IiwiX2xlYWZOb2RlczIiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiZmluZExhc3QiLCJlbmRzV2l0aCIsIl9zbGF0ZU5vZGUiLCJfcGF0aCIsIl9vZmZzZXQiLCJxdWVyeVNlbGVjdG9yIiwiX2ZvY3VzTm9kZSR0ZXh0Q29udGVuIiwic3RhcnRDb250YWluZXIiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsImZpcnN0UmFuZ2UiLCJnZXRSYW5nZUF0IiwibGFzdFJhbmdlIiwiSFRNTFRhYmxlUm93RWxlbWVudCIsImdldExhc3RDaGlsZHJlbiIsImVsZW1lbnQiLCJjaGlsZEVsZW1lbnRDb3VudCIsImNoaWxkcmVuIiwiZmlyc3ROb2RlUm93IiwibGFzdE5vZGVSb3ciLCJmaXJzdE5vZGUiLCJsYXN0Tm9kZSIsIkhUTUxFbGVtZW50IiwiaW5uZXJIVE1MIiwiZW5kQ29udGFpbmVyIiwiY29sbGFwc2VkIiwiZm9jdXNCZWZvcmVBbmNob3IiLCJpc0V4cGFuZGVkIiwiaXNGb3J3YXJkIiwibW9kZSIsInVuaGFuZ1JhbmdlIiwidm9pZHMiLCJ2ZXJpZnlEaWZmU3RhdGUiLCJ0ZXh0RGlmZiIsImRpZmYiLCJpc1RleHQiLCJuZXh0UGF0aCIsIm5leHQiLCJuZXh0Tm9kZSIsImFwcGx5U3RyaW5nRGlmZiIsIl9sZW4iLCJkaWZmcyIsIl9rZXkiLCJyZWR1Y2UiLCJsb25nZXN0Q29tbW9uUHJlZml4TGVuZ3RoIiwic3RyIiwiYW5vdGhlciIsImNoYXJBdCIsImxvbmdlc3RDb21tb25TdWZmaXhMZW5ndGgiLCJub3JtYWxpemVTdHJpbmdEaWZmIiwidGFyZ2V0VGV4dCIsInJlbW92ZWRUZXh0IiwicHJlZml4TGVuZ3RoIiwic3VmZml4TGVuZ3RoIiwibm9ybWFsaXplZCIsIm1lcmdlU3RyaW5nRGlmZnMiLCJhIiwiYiIsIm92ZXJsYXAiLCJhcHBsaWVkIiwic2xpY2VFbmQiLCJ0YXJnZXRSYW5nZSIsIm5vcm1hbGl6ZVBvaW50IiwicGFyZW50QmxvY2siLCJhYm92ZSIsImlzQmxvY2siLCJlbnRyeSIsImlzRGVzY2VuZGFudCIsIm5vcm1hbGl6ZVJhbmdlIiwidHJhbnNmb3JtUGVuZGluZ1BvaW50Iiwib3AiLCJwZW5kaW5nRGlmZnMiLCJlcXVhbHMiLCJ0cmFuc2Zvcm0iLCJhZmZpbml0eSIsIl9hbmNob3IiLCJfdHJhbnNmb3JtZWQiLCJ0cmFuc2Zvcm1lZCIsInR5cGUiLCJ0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UiLCJ0cmFuc2Zvcm1UZXh0RGlmZiIsIm5ld1BhdGgiLCJkb1JlY3RzSW50ZXJzZWN0IiwiY29tcGFyZVJlY3QiLCJtaWRkbGUiLCJib3R0b20iLCJhcmVSYW5nZXNTYW1lTGluZSIsInJhbmdlMSIsInJhbmdlMiIsInJlY3QxIiwicmVjdDIiLCJmaW5kQ3VycmVudExpbmVSYW5nZSIsInBhcmVudFJhbmdlIiwicGFyZW50UmFuZ2VCb3VuZGFyeSIsInBvc2l0aW9ucyIsInJpZ2h0IiwiZmxvb3IiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsIndpdGhET00iLCJjbGlwYm9hcmRGb3JtYXRLZXkiLCJvbkNoYW5nZSIsImRlbGV0ZUJhY2t3YXJkIiwiYWRkTWFyayIsInJlbW92ZU1hcmsiLCJfRURJVE9SX1RPX1BFTkRJTkdfREkiLCJkZWxldGUiLCJfRURJVE9SX1RPX1BFTkRJTkdfREkyIiwidW5pdCIsInBhcmVudEJsb2NrRW50cnkiLCJwYXJlbnRCbG9ja1BhdGgiLCJwYXJlbnRFbGVtZW50UmFuZ2UiLCJjdXJyZW50TGluZVJhbmdlIiwicGF0aFJlZk1hdGNoZXMiLCJtYXAiLCJwZW5kaW5nU2VsZWN0aW9uIiwicGVuZGluZ0FjdGlvbiIsImlzUG9pbnQiLCJnZXRNYXRjaGVzIiwiX0VESVRPUl9UT19VU0VSX1NFTEVDIiwidW5yZWYiLCJwcmV2UGF0aCIsInByZXZpb3VzIiwiY29tbW9uUGF0aCIsImNvbW1vbiIsImNoYW5nZWRQYXRoIiwiY2hhbmdlZE5vZGUiLCJjaGFuZ2VkTm9kZUtleSIsImNoYW5nZWRQYXRoUmVmIiwicGF0aFJlZiIsImVkZ2VzIiwic3RhcnRWb2lkIiwiZW5kVm9pZCIsImF0dGFjaCIsInRyaW0iLCJjbG9uZVJhbmdlIiwic2V0RW5kQWZ0ZXIiLCJ6dyIsImlzTmV3bGluZSIsInNwYW4iLCJzdHlsZSIsIndoaXRlU3BhY2UiLCJhcHBlbmRDaGlsZCIsImdldEZyYWdtZW50Iiwic3RyaW5nIiwiSlNPTiIsImVuY29kZWQiLCJidG9hIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2V0QXR0cmlidXRlIiwic2V0RGF0YSIsImRpdiIsImJvZHkiLCJkZWNvZGVkIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiYXRvYiIsInBhcnNlZCIsInBhcnNlIiwiaW5zZXJ0RnJhZ21lbnQiLCJsaW5lcyIsInNwbGl0IiwibGluZSIsInNwbGl0Tm9kZXMiLCJhbHdheXMiLCJpbnNlcnRUZXh0Iiwib25Db250ZXh0Q2hhbmdlIiwicCIsImxldmVscyIsIlRSSVBMRV9DTElDSyIsIkhPVEtFWVMiLCJib2xkIiwiY29tcG9zZSIsIm1vdmVCYWNrd2FyZCIsIm1vdmVGb3J3YXJkIiwibW92ZVdvcmRCYWNrd2FyZCIsIm1vdmVXb3JkRm9yd2FyZCIsImRlbGV0ZUZvcndhcmQiLCJleHRlbmRCYWNrd2FyZCIsImV4dGVuZEZvcndhcmQiLCJpdGFsaWMiLCJpbnNlcnRTb2Z0QnJlYWsiLCJzcGxpdEJsb2NrIiwidW5kbyIsIkFQUExFX0hPVEtFWVMiLCJtb3ZlTGluZUJhY2t3YXJkIiwibW92ZUxpbmVGb3J3YXJkIiwiZGVsZXRlTGluZUJhY2t3YXJkIiwiZGVsZXRlTGluZUZvcndhcmQiLCJkZWxldGVXb3JkQmFja3dhcmQiLCJkZWxldGVXb3JkRm9yd2FyZCIsImV4dGVuZExpbmVCYWNrd2FyZCIsImV4dGVuZExpbmVGb3J3YXJkIiwicmVkbyIsInRyYW5zcG9zZUNoYXJhY3RlciIsIldJTkRPV1NfSE9US0VZUyIsImNyZWF0ZSIsImdlbmVyaWMiLCJhcHBsZSIsIndpbmRvd3MiLCJpc0dlbmVyaWMiLCJpc0FwcGxlIiwiaXNXaW5kb3dzIiwiaG90a2V5cyIsImlzQm9sZCIsImlzQ29tcG9zZSIsImlzTW92ZUJhY2t3YXJkIiwiaXNNb3ZlRm9yd2FyZCIsImlzRGVsZXRlQmFja3dhcmQiLCJpc0RlbGV0ZUZvcndhcmQiLCJpc0RlbGV0ZUxpbmVCYWNrd2FyZCIsImlzRGVsZXRlTGluZUZvcndhcmQiLCJpc0RlbGV0ZVdvcmRCYWNrd2FyZCIsImlzRGVsZXRlV29yZEZvcndhcmQiLCJpc0V4dGVuZEJhY2t3YXJkIiwiaXNFeHRlbmRGb3J3YXJkIiwiaXNFeHRlbmRMaW5lQmFja3dhcmQiLCJpc0V4dGVuZExpbmVGb3J3YXJkIiwiaXNJdGFsaWMiLCJpc01vdmVMaW5lQmFja3dhcmQiLCJpc01vdmVMaW5lRm9yd2FyZCIsImlzTW92ZVdvcmRCYWNrd2FyZCIsImlzTW92ZVdvcmRGb3J3YXJkIiwiaXNSZWRvIiwiaXNTb2Z0QnJlYWsiLCJpc1NwbGl0QmxvY2siLCJpc1RyYW5zcG9zZUNoYXJhY3RlciIsImlzVW5kbyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwiaW5kZXhPZiIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJzaGFsbG93Q29tcGFyZSIsIm9iajEiLCJvYmoyIiwiZXZlcnkiLCJoYXNPd25Qcm9wZXJ0eSIsImlzRGVjb3JhdGlvbkZsYWdzRXF1YWwiLCJvdGhlciIsInJhbmdlT3duUHJvcHMiLCJvdGhlck93blByb3BzIiwiaXNFbGVtZW50RGVjb3JhdGlvbnNFcXVhbCIsImxpc3QiLCJpc1RleHREZWNvcmF0aW9uc0VxdWFsIiwiSG90a2V5cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate-dom/dist/index.es.js\n");

/***/ })

};
;