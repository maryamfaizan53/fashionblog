"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer";
exports.ids = ["vendor-chunks/@lezer"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/ const DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/ class NodeProp {\n    /**\n    Create a new node prop type.\n    */ constructor(config = {}){\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (()=>{\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /**\n    This is meant to be used with\n    [`NodeSet.extend`](#common.NodeSet.extend) or\n    [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    prop values for each node type in the set. Takes a [match\n    object](#common.NodeType^match) or function that returns undefined\n    if the node type doesn't get this prop, and the prop's value if\n    it does.\n    */ add(match) {\n        if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\") match = NodeType.match(match);\n        return (type)=>{\n            let result = match(type);\n            return result === undefined ? null : [\n                this,\n                result\n            ];\n        };\n    }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/ NodeProp.closedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/ NodeProp.openedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/ NodeProp.group = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nAttached to nodes to indicate these should be\n[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)\nin a bidirectional text isolate, so that direction-neutral\ncharacters on their sides don't incorrectly get associated with\nsurrounding text. You'll generally want to set this for nodes\nthat contain arbitrary text, like strings and comments, and for\nnodes that appear _inside_ arbitrary text, like HTML tags. When\nnot given a value, in a grammar declaration, defaults to\n`\"auto\"`.\n*/ NodeProp.isolate = new NodeProp({\n    deserialize: (value)=>{\n        if (value && value != \"rtl\" && value != \"ltr\" && value != \"auto\") throw new RangeError(\"Invalid value for isolate: \" + value);\n        return value || \"auto\";\n    }\n});\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/ NodeProp.contextHash = new NodeProp({\n    perNode: true\n});\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/ NodeProp.lookAhead = new NodeProp({\n    perNode: true\n});\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/ NodeProp.mounted = new NodeProp({\n    perNode: true\n});\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/ class MountedTree {\n    constructor(/**\n    The inner tree.\n    */ tree, /**\n    If this is null, this tree replaces the entire node (it will\n    be included in the regular iteration instead of its host\n    node). If not, only the given ranges are considered to be\n    covered by this tree. This is used for trees that are mixed in\n    a way that isn't strictly hierarchical. Such mounted trees are\n    only entered by [`resolveInner`](#common.Tree.resolveInner)\n    and [`enter`](#common.SyntaxNode.enter).\n    */ overlay, /**\n    The parser used to create this subtree.\n    */ parser){\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n    /**\n    @internal\n    */ static get(tree) {\n        return tree && tree.props && tree.props[NodeProp.mounted.id];\n    }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/ class NodeType {\n    /**\n    @internal\n    */ constructor(/**\n    The name of the node type. Not necessarily unique, but if the\n    grammar was written properly, different node types with the\n    same name within a node set should play the same semantic\n    role.\n    */ name, /**\n    @internal\n    */ props, /**\n    The id of this node in its set. Corresponds to the term ids\n    used in the parser.\n    */ id, /**\n    @internal\n    */ flags = 0){\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /**\n    Define a node type.\n    */ static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */  : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */  : 0) | (spec.error ? 4 /* NodeFlag.Error */  : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */  : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props) for (let src of spec.props){\n            if (!Array.isArray(src)) src = src(type);\n            if (src) {\n                if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n                props[src[0].id] = src[1];\n            }\n        }\n        return type;\n    }\n    /**\n    Retrieves a node prop for this type. Will return `undefined` if\n    the prop isn't present on this node.\n    */ prop(prop) {\n        return this.props[prop.id];\n    }\n    /**\n    True when this is the top node of a grammar.\n    */ get isTop() {\n        return (this.flags & 1 /* NodeFlag.Top */ ) > 0;\n    }\n    /**\n    True when this node is produced by a skip rule.\n    */ get isSkipped() {\n        return (this.flags & 2 /* NodeFlag.Skipped */ ) > 0;\n    }\n    /**\n    Indicates whether this is an error node.\n    */ get isError() {\n        return (this.flags & 4 /* NodeFlag.Error */ ) > 0;\n    }\n    /**\n    When true, this node type doesn't correspond to a user-declared\n    named node, for example because it is used to cache repetition.\n    */ get isAnonymous() {\n        return (this.flags & 8 /* NodeFlag.Anonymous */ ) > 0;\n    }\n    /**\n    Returns true when this node's name or one of its\n    [groups](#common.NodeProp^group) matches the given string.\n    */ is(name) {\n        if (typeof name == \"string\") {\n            if (this.name == name) return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /**\n    Create a function from node types to arbitrary values by\n    specifying an object whose property names are node or\n    [group](#common.NodeProp^group) names. Often useful with\n    [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    names, separated by spaces, in a single property name to map\n    multiple node names to a single value.\n    */ static match(map) {\n        let direct = Object.create(null);\n        for(let prop in map)for (let name of prop.split(\" \"))direct[name] = map[prop];\n        return (node)=>{\n            for(let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++){\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found) return found;\n            }\n        };\n    }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/ NodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */ );\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/ class NodeSet {\n    /**\n    Create a set with the given types. The `id` property of each\n    type should correspond to its position within the array.\n    */ constructor(/**\n    The node types in this set, by id.\n    */ types){\n        this.types = types;\n        for(let i = 0; i < types.length; i++)if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /**\n    Create a copy of this set with some node properties added. The\n    arguments to this method can be created with\n    [`NodeProp.add`](#common.NodeProp.add).\n    */ extend(...props) {\n        let newTypes = [];\n        for (let type of this.types){\n            let newProps = null;\n            for (let source of props){\n                let add = source(type);\n                if (add) {\n                    if (!newProps) newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/ var IterMode;\n(function(IterMode) {\n    /**\n    When enabled, iteration will only visit [`Tree`](#common.Tree)\n    objects, not nodes packed into\n    [`TreeBuffer`](#common.TreeBuffer)s.\n    */ IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /**\n    Enable this to make iteration include anonymous nodes (such as\n    the nodes that wrap repeated grammar constructs into a balanced\n    tree).\n    */ IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /**\n    By default, regular [mounted](#common.NodeProp^mounted) nodes\n    replace their base node in iteration. Enable this to ignore them\n    instead.\n    */ IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /**\n    This option only applies in\n    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    library to not enter mounted overlays if one covers the given\n    position.\n    */ IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/ class Tree {\n    /**\n    Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    */ constructor(/**\n    The type of the top node.\n    */ type, /**\n    This node's child nodes.\n    */ children, /**\n    The positions (offsets relative to the start of this tree) of\n    the children.\n    */ positions, /**\n    The total length of this tree\n    */ length, /**\n    Per-node [node props](#common.NodeProp) to associate with this node.\n    */ props){\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /**\n        @internal\n        */ this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /**\n    @internal\n    */ toString() {\n        let mounted = MountedTree.get(this);\n        if (mounted && !mounted.overlay) return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children){\n            let str = ch.toString();\n            if (str) {\n                if (children) children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    the tree. Mode can be used to [control](#common.IterMode) which\n    nodes the cursor visits.\n    */ cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    at the given position and side (see\n    [`moveTo`](#common.TreeCursor.moveTo).\n    */ cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) object for the top of the\n    tree.\n    */ get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /**\n    Get the [syntax node](#common.SyntaxNode) at the given position.\n    If `side` is -1, this will move into nodes that end at the\n    position. If 1, it'll move into nodes that start at the\n    position. With 0, it'll only enter nodes that cover the position\n    from both sides.\n    \n    Note that this will not enter\n    [overlays](#common.MountedTree.overlay), and you often want\n    [`resolveInner`](#common.Tree.resolveInner) instead.\n    */ resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /**\n    Like [`resolve`](#common.Tree.resolve), but will enter\n    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    pointing into the innermost overlaid tree at the given position\n    (with parent links going through all parent structure, including\n    the host trees).\n    */ resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /**\n    In some situations, it can be useful to iterate through all\n    nodes around a position, including those in overlays that don't\n    directly cover the position. This method gives you an iterator\n    that will produce all nodes, from small to big, around the given\n    position.\n    */ resolveStack(pos, side = 0) {\n        return stackIterator(this, pos, side);\n    }\n    /**\n    Iterate over the tree and its children, calling `enter` for any\n    node that touches the `from`/`to` region (if given) before\n    running over such a node's children, and `leave` (if given) when\n    leaving the node. When `enter` returns `false`, that node will\n    not have its children iterated over (or `leave` called).\n    */ iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for(let c = this.cursor(mode | IterMode.IncludeAnonymous);;){\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild()) continue;\n                entered = true;\n            }\n            for(;;){\n                if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);\n                if (c.nextSibling()) break;\n                if (!c.parent()) return;\n                entered = true;\n            }\n        }\n    }\n    /**\n    Get the value of the given [node prop](#common.NodeProp) for this\n    node. Works with both per-node and per-type props.\n    */ prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /**\n    Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    format that can be passed to the [`Tree`](#common.Tree)\n    constructor.\n    */ get propValues() {\n        let result = [];\n        if (this.props) for(let id in this.props)result.push([\n            +id,\n            this.props[id]\n        ]);\n        return result;\n    }\n    /**\n    Balance the direct children of this tree, producing a copy of\n    which may have children grouped into subtrees with type\n    [`NodeType.none`](#common.NodeType^none).\n    */ balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */  ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length)=>new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length)=>new Tree(NodeType.none, children, positions, length)));\n    }\n    /**\n    Build a tree from a postfix-ordered buffer of node information,\n    or a cursor over such a buffer.\n    */ static build(data) {\n        return buildTree(data);\n    }\n}\n/**\nThe empty tree\n*/ Tree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index){\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() {\n        return this.buffer[this.index - 4];\n    }\n    get start() {\n        return this.buffer[this.index - 3];\n    }\n    get end() {\n        return this.buffer[this.index - 2];\n    }\n    get size() {\n        return this.buffer[this.index - 1];\n    }\n    get pos() {\n        return this.index;\n    }\n    next() {\n        this.index -= 4;\n    }\n    fork() {\n        return new FlatBufferCursor(this.buffer, this.index);\n    }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/ class TreeBuffer {\n    /**\n    Create a tree buffer.\n    */ constructor(/**\n    The buffer's content.\n    */ buffer, /**\n    The total length of the group of nodes in the buffer.\n    */ length, /**\n    The node set used in this buffer.\n    */ set){\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /**\n    @internal\n    */ get type() {\n        return NodeType.none;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = [];\n        for(let index = 0; index < this.buffer.length;){\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /**\n    @internal\n    */ childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index) return result;\n        let children = [];\n        while(index < endIndex){\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /**\n    @internal\n    */ findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for(let i = startIndex; i != endIndex; i = buffer[i + 3]){\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0) break;\n            }\n        }\n        return pick;\n    }\n    /**\n    @internal\n    */ slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for(let i = startI, j = 0; i < endI;){\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch(side){\n        case -2 /* Side.Before */ :\n            return from < pos;\n        case -1 /* Side.AtOrBefore */ :\n            return to >= pos && from < pos;\n        case 0 /* Side.Around */ :\n            return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */ :\n            return from <= pos && to > pos;\n        case 2 /* Side.After */ :\n            return to > pos;\n        case 4 /* Side.DontCare */ :\n            return true;\n    }\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while(node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)){\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent) return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays) for(let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent){\n        if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;\n    }\n    for(;;){\n        let inner = node.enter(pos, side, mode);\n        if (!inner) return node;\n        node = inner;\n    }\n}\nclass BaseNode {\n    cursor(mode = 0) {\n        return new TreeCursor(this, mode);\n    }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    matchContext(context) {\n        return matchNodeContext(this, context);\n    }\n    enterUnfinishedNodesBefore(pos) {\n        let scan = this.childBefore(pos), node = this;\n        while(scan){\n            let last = scan.lastChild;\n            if (!last || last.to != scan.to) break;\n            if (last.type.isError && last.from == last.to) {\n                node = scan;\n                scan = last.prevSibling;\n            } else {\n                scan = last;\n            }\n        }\n        return node;\n    }\n    get node() {\n        return this;\n    }\n    get next() {\n        return this.parent;\n    }\n}\nclass TreeNode extends BaseNode {\n    constructor(_tree, from, // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent){\n        super();\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() {\n        return this._tree.type;\n    }\n    get name() {\n        return this._tree.type.name;\n    }\n    get to() {\n        return this.from + this._tree.length;\n    }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for(let parent = this;;){\n            for(let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir){\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length)) continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers) continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;\n            if (parent.index >= 0) i = parent.index + dir;\n            else i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent) return null;\n        }\n    }\n    get firstChild() {\n        return this.nextChild(0, 1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.nextChild(0, 1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */ );\n    }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay){\n                if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while(val.type.isAnonymous && val._parent)val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get tree() {\n        return this._tree;\n    }\n    toTree() {\n        return this._tree;\n    }\n    /**\n    @internal\n    */ toString() {\n        return this._tree.toString();\n    }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild()) return result;\n    if (before != null) for(let found = false; !found;){\n        found = cur.type.is(before);\n        if (!cur.nextSibling()) return result;\n    }\n    for(;;){\n        if (after != null && cur.type.is(after)) return result;\n        if (cur.type.is(type)) result.push(cur.node);\n        if (!cur.nextSibling()) return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for(let p = node.parent; i >= 0; p = p.parent){\n        if (!p) return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name) return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start){\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode extends BaseNode {\n    get name() {\n        return this.type.name;\n    }\n    get from() {\n        return this.context.start + this.context.buffer.buffer[this.index + 1];\n    }\n    get to() {\n        return this.context.start + this.context.buffer.buffer[this.index + 2];\n    }\n    constructor(context, _parent, index){\n        super();\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() {\n        return this.child(1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.child(-1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.child(1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.child(-1, pos, -2 /* Side.Before */ );\n    }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers) return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */ );\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart) return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n    }\n    get tree() {\n        return null;\n    }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.context.buffer.childString(this.index);\n    }\n}\nfunction iterStack(heads) {\n    if (!heads.length) return null;\n    let pick = 0, picked = heads[0];\n    for(let i = 1; i < heads.length; i++){\n        let node = heads[i];\n        if (node.from > picked.from || node.to < picked.to) {\n            picked = node;\n            pick = i;\n        }\n    }\n    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n    let newHeads = heads.slice();\n    if (next) newHeads[pick] = next;\n    else newHeads.splice(pick, 1);\n    return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n    constructor(heads, node){\n        this.heads = heads;\n        this.node = node;\n    }\n    get next() {\n        return iterStack(this.heads);\n    }\n}\nfunction stackIterator(tree, pos, side) {\n    let inner = tree.resolveInner(pos, side), layers = null;\n    for(let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent){\n        if (scan.index < 0) {\n            let parent = scan.parent;\n            (layers || (layers = [\n                inner\n            ])).push(parent.resolve(pos, side));\n            scan = parent;\n        } else {\n            let mount = MountedTree.get(scan.tree);\n            // Relevant overlay branching off\n            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n                (layers || (layers = [\n                    inner\n                ])).push(resolveNode(root, pos, side, false));\n            }\n        }\n    }\n    return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/ class TreeCursor {\n    /**\n    Shorthand for `.type.name`.\n    */ get name() {\n        return this.type.name;\n    }\n    /**\n    @internal\n    */ constructor(node, /**\n    @internal\n    */ mode = 0){\n        this.mode = mode;\n        /**\n        @internal\n        */ this.buffer = null;\n        this.stack = [];\n        /**\n        @internal\n        */ this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        } else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for(let n = node._parent; n; n = n._parent)this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node) return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    /**\n    @internal\n    */ yield(node) {\n        if (!node) return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /**\n    @internal\n    */ enterChild(dir, pos, side) {\n        if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0) return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /**\n    Move the cursor to this node's first child. When this returns\n    false, the node has no child, and the cursor has not been moved.\n    */ firstChild() {\n        return this.enterChild(1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to this node's last child.\n    */ lastChild() {\n        return this.enterChild(-1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to the first child that ends after `pos`.\n    */ childAfter(pos) {\n        return this.enterChild(1, pos, 2 /* Side.After */ );\n    }\n    /**\n    Move to the last child that starts before `pos`.\n    */ childBefore(pos) {\n        return this.enterChild(-1, pos, -2 /* Side.Before */ );\n    }\n    /**\n    Move the cursor to the child around `pos`. If side is -1 the\n    child may end at that position, when 1 it may start there. This\n    will also enter [overlaid](#common.MountedTree.overlay)\n    [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    set to false.\n    */ enter(pos, side, mode = this.mode) {\n        if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /**\n    Move to the node's parent node, if this isn't the top node.\n    */ parent() {\n        if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n        if (this.stack.length) return this.yieldBuf(this.stack.pop());\n        let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /**\n    @internal\n    */ sibling(dir) {\n        if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n        } else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode)) : false;\n    }\n    /**\n    Move to this node's next sibling, if any.\n    */ nextSibling() {\n        return this.sibling(1);\n    }\n    /**\n    Move to this node's previous sibling, if any.\n    */ prevSibling() {\n        return this.sibling(-1);\n    }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length) return false;\n            } else {\n                for(let i = 0; i < this.index; i++)if (buffer.buffer.buffer[i + 3] < this.index) return false;\n            }\n            ({ index, parent } = buffer);\n        } else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for(; parent; { index, _parent: parent } = parent){\n            if (index > -1) for(let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir){\n                let child = parent._tree.children[i];\n                if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n            }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */ )) return true;\n        for(;;){\n            if (this.sibling(dir)) return true;\n            if (this.atLastNode(dir) || !this.parent()) return false;\n        }\n    }\n    /**\n    Move to the next node in a\n    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    traversal, going from a node to its first child or, if the\n    current node is empty or `enter` is false, its next sibling or\n    the next sibling of the first parent node that has one.\n    */ next(enter = true) {\n        return this.move(1, enter);\n    }\n    /**\n    Move to the next node in a last-to-first pre-order traveral. A\n    node is followed by its last child or, if it has none, its\n    previous sibling or the previous sibling of the first parent\n    node that has one.\n    */ prev(enter = true) {\n        return this.move(-1, enter);\n    }\n    /**\n    Move the cursor to the innermost node that covers `pos`. If\n    `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    it will enter nodes that start at `pos`.\n    */ moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while(this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))if (!this.parent()) break;\n        // Then scan down into child nodes as far as possible\n        while(this.enterChild(1, pos, side)){}\n        return this;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    position.\n    */ get node() {\n        if (!this.buffer) return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for(let index = this.index, d = this.stack.length; d >= 0;){\n                for(let c = cache; c; c = c._parent)if (c.index == index) {\n                    if (index == this.index) return c;\n                    result = c;\n                    depth = d + 1;\n                    break scan;\n                }\n                index = this.stack[--d];\n            }\n        }\n        for(let i = depth; i < this.stack.length; i++)result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /**\n    Get the [tree](#common.Tree) that represents the current node, if\n    any. Will return null when the node is in a [tree\n    buffer](#common.TreeBuffer).\n    */ get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /**\n    Iterate over the current node and all its descendants, calling\n    `enter` when entering a node and `leave`, if given, when leaving\n    one. When `enter` returns `false`, any children of that node are\n    skipped, and `leave` isn't called for it.\n    */ iterate(enter, leave) {\n        for(let depth = 0;;){\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous) mustLeave = true;\n            }\n            for(;;){\n                if (mustLeave && leave) leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (this.nextSibling()) break;\n                if (!depth) return;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /**\n    Test whether the current node matches a given contextâ€”a sequence\n    of direct parent node names. Empty strings in the context array\n    are treated as wildcards.\n    */ matchContext(context) {\n        if (!this.buffer) return matchNodeContext(this.node, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for(let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--){\n            if (d < 0) return matchNodeContext(this.node, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name) return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some((ch)=>ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while(size < 0){\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */ ) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n                contextHash = id;\n                return;\n            } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n                lookAhead = id;\n                return;\n            } else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while(cursor.pos > endPos)index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        } else {\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while(cursor.pos > endPos){\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                } else if (depth > 2500 /* CutOff.Depth */ ) {\n                    takeFlatNode(start, endPos, localChildren, localPositions);\n                } else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            } else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function takeFlatNode(parentStart, minPos, children, positions) {\n        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n        let nodeCount = 0, stopAt = -1;\n        while(cursor.pos > minPos){\n            let { id, start, end, size } = cursor;\n            if (size > 4) {\n                cursor.next();\n            } else if (stopAt > -1 && start < stopAt) {\n                break;\n            } else {\n                if (stopAt < 0) stopAt = end - maxBufferLength;\n                nodes.push(id, start, end);\n                nodeCount++;\n                cursor.next();\n            }\n        }\n        if (nodeCount) {\n            let buffer = new Uint16Array(nodeCount * 4);\n            let start = nodes[nodes.length - 2];\n            for(let i = nodes.length - 3, j = 0; i >= 0; i -= 3){\n                buffer[j++] = nodes[i];\n                buffer[j++] = nodes[i + 1] - start;\n                buffer[j++] = nodes[i + 2] - start;\n                buffer[j++] = j;\n            }\n            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n            positions.push(start - parentStart);\n        }\n    }\n    function makeBalanced(type) {\n        return (children, positions, length)=>{\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length) return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while(children.length > i){\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [\n                NodeProp.contextHash,\n                contextHash\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        if (lookAhead > 25) {\n            let pair = [\n                NodeProp.lookAhead,\n                lookAhead\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = {\n            size: 0,\n            start: 0,\n            skip: 0\n        };\n        scan: for(let minPos = fork.pos - maxSize; fork.pos > minPos;){\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while(fork.pos > startPos){\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */ ) localSkipped += 4;\n                    else break scan;\n                } else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while(cursor.pos > endPos)index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n            contextHash = id;\n        } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while(cursor.pos > 0)takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children){\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(// The type the balanced tree's inner nodes.\nbalanceType, // The direct children and their positions\nchildren, positions, // The index range in children/positions to use\nfrom, to, // The start position of the nodes, relative to their parent.\nstart, // Length of the outer node\nlength, // Function to build the top node of the balanced tree\nmkTop, // Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for(let i = from; i < to; i++)total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */ );\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for(let i = from; i < to;){\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for(; i < to; i++){\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild) break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            } else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/ class NodeWeakMap {\n    constructor(){\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner) this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /**\n    Set the value for this syntax node.\n    */ set(node, value) {\n        if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode) this.map.set(node.tree, value);\n    }\n    /**\n    Retrieve value for this syntax node, if it exists in the map.\n    */ get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /**\n    Set the value for the node that a cursor currently points to.\n    */ cursorSet(cursor, value) {\n        if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else this.map.set(cursor.tree, value);\n    }\n    /**\n    Retrieve the value for the node that a cursor currently points\n    to.\n    */ cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/ class TreeFragment {\n    /**\n    Construct a tree fragment. You'll usually want to use\n    [`addTree`](#common.TreeFragment^addTree) and\n    [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    calling this directly.\n    */ constructor(/**\n    The start of the unchanged range pointed to by this fragment.\n    This refers to an offset in the _updated_ document (as opposed\n    to the original tree).\n    */ from, /**\n    The end of the unchanged range.\n    */ to, /**\n    The tree that this fragment is based on.\n    */ tree, /**\n    The offset between the fragment's tree and the document that\n    this fragment can be used against. Add this when going from\n    document to tree positions, subtract it to go from tree to\n    document positions.\n    */ offset, openStart = false, openEnd = false){\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */  : 0) | (openEnd ? 2 /* Open.End */  : 0);\n    }\n    /**\n    Whether the start of the fragment represents the start of a\n    parse, or the end of a change. (In the second case, it may not\n    be safe to reuse some nodes at the start, depending on the\n    parsing algorithm.)\n    */ get openStart() {\n        return (this.open & 1 /* Open.Start */ ) > 0;\n    }\n    /**\n    Whether the end of the fragment represents the end of a\n    full-document parse, or the start of a change.\n    */ get openEnd() {\n        return (this.open & 2 /* Open.End */ ) > 0;\n    }\n    /**\n    Create a set of fragments from a freshly parsed tree, or update\n    an existing set of fragments by replacing the ones that overlap\n    with a tree with content from the new tree. When `partial` is\n    true, the parse is treated as incomplete, and the resulting\n    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    true.\n    */ static addTree(tree, fragments = [], partial = false) {\n        let result = [\n            new TreeFragment(0, tree.length, tree, 0, false, partial)\n        ];\n        for (let f of fragments)if (f.to > tree.length) result.push(f);\n        return result;\n    }\n    /**\n    Apply a set of edits to an array of fragments, removing or\n    splitting fragments as necessary to remove edited ranges, and\n    adjusting offsets for fragments that moved.\n    */ static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length) return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for(let cI = 0, pos = 0, off = 0;; cI++){\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap) while(nextF && nextF.from < nextPos){\n                let cut = nextF;\n                if (pos >= cut.from || nextPos <= cut.to || off) {\n                    let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                    cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                }\n                if (cut) result.push(cut);\n                if (nextF.to > nextPos) break;\n                nextF = fI < fragments.length ? fragments[fI++] : null;\n            }\n            if (!nextC) break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/**\nA superclass that parsers should extend.\n*/ class Parser {\n    /**\n    Start a parse, returning a [partial parse](#common.PartialParse)\n    object. [`fragments`](#common.TreeFragment) can be passed in to\n    make the parse incremental.\n    \n    By default, the entire input is parsed. You can pass `ranges`,\n    which should be a sorted array of non-empty, non-overlapping\n    ranges, to parse only those ranges. The tree returned in that\n    case will start at `ranges[0].from`.\n    */ startParse(input, fragments, ranges) {\n        if (typeof input == \"string\") input = new StringInput(input);\n        ranges = !ranges ? [\n            new Range(0, input.length)\n        ] : ranges.length ? ranges.map((r)=>new Range(r.from, r.to)) : [\n            new Range(0, 0)\n        ];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /**\n    Run a full parse, returning the resulting tree.\n    */ parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for(;;){\n            let done = parse.advance();\n            if (done) return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string){\n        this.string = string;\n    }\n    get length() {\n        return this.string.length;\n    }\n    chunk(from) {\n        return this.string.slice(from);\n    }\n    get lineChunks() {\n        return false;\n    }\n    read(from, to) {\n        return this.string.slice(from, to);\n    }\n}\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/ function parseMixed(nest) {\n    return (parse, input, fragments, ranges)=>new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, from){\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.from = from;\n    }\n}\nfunction checkRanges(ranges) {\n    if (!ranges.length || ranges.some((r)=>r.from >= r.to)) throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev){\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({\n    perNode: true\n});\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges){\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done) return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null) for (let inner of this.inner)inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([\n                [\n                    stoppedInner,\n                    this.stoppedAt\n                ]\n            ]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse) return 0;\n        let pos = this.input.length;\n        for(let i = this.innerDone; i < this.inner.length; i++){\n            if (this.inner[i].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse) this.baseParse.stopAt(pos);\n        else for(let i = this.innerDone; i < this.inner.length; i++)this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for(let nest, isCovered;;){\n            let enter = true, range;\n            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n                enter = false;\n            } else if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find((m)=>m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match) for (let r of match.mount.overlay){\n                        let from = r.from + match.pos, to = r.to + match.pos;\n                        if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some((r)=>r.from < to && r.to > from)) overlay.ranges.push({\n                            from,\n                            to\n                        });\n                    }\n                }\n                enter = false;\n            } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */ ;\n            } else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) && (cursor.from < cursor.to || !nest.overlay)) {\n                if (!cursor.tree) materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                } else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || (cursor.from < cursor.to ? [\n                        new Range(cursor.from, cursor.to)\n                    ] : []));\n                    if (ranges.length) checkRanges(ranges);\n                    if (ranges.length || !nest.overlay) this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map((r)=>new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n                    if (!nest.overlay) enter = false;\n                    else if (ranges.length) covered = {\n                        ranges,\n                        depth: 0,\n                        prev: covered\n                    };\n                }\n            } else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true) range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to) overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay) overlay.depth++;\n                if (covered) covered.depth++;\n            } else {\n                for(;;){\n                    if (cursor.nextSibling()) break;\n                    if (!cursor.parent()) break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length) {\n                            checkRanges(ranges);\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r)=>new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));\n                        }\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth) covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered){\n        if (range.from >= to) break;\n        if (range.to > from) return range.from <= from && range.to >= to ? 2 /* Cover.Full */  : 1 /* Cover.Partial */ ;\n    }\n    return 0 /* Cover.None */ ;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, stack = [];\n    let buffer = node.context.buffer;\n    // Scan up to the nearest tree\n    do {\n        stack.push(cursor.index);\n        cursor.parent();\n    }while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let base = cursor.tree, i = base.children.indexOf(buffer);\n    let buf = base.children[i], b = buf.buffer, newStack = [\n        i\n    ];\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length, stackPos) {\n        let targetI = stack[stackPos];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n        let from = b[targetI + 1], to = b[targetI + 2];\n        newStack.push(children.length);\n        let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();\n        children.push(child);\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n    // Move the cursor back to the target node\n    for (let index of newStack){\n        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];\n        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n    }\n}\nclass StructureCursor {\n    constructor(root, offset){\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while(!this.done && cursor.from < p){\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false)) this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for(let tree = this.cursor.tree;;){\n                if (tree == cursor.tree) return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];\n                else break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments){\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        } else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while(this.curFrag && node.from >= this.curTo)this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        } else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for(let pos = this.inner.cursor.node; pos; pos = pos.parent){\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for(let i = this.fragI; i < this.fragments.length; i++){\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to) break;\n                        if (frag.tree == this.curFrag.tree) result.push({\n                            frag,\n                            pos: pos.from - frag.offset,\n                            mount\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for(let i = 1, j = 0; i < outer.length; i++){\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for(; j < current.length; j++){\n            let r = current[j];\n            if (r.from >= gapTo) break;\n            if (r.to <= gapFrom) continue;\n            if (!copy) current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            } else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            } else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for(;;){\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end) result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9) break;\n        if (nextA == pos) {\n            if (!inA) inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB) inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts){\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map((r)=>new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for(let i = 0, pos = from;; i++){\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last) break;\n                pos = changes[i].to;\n            }\n        } else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQSxHQUNBLE1BQU1BLHNCQUFzQjtBQUM1QixJQUFJQyxhQUFhO0FBQ2pCLE1BQU1DO0lBQ0ZDLFlBQVlDLElBQUksRUFBRUMsRUFBRSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsRUFBRSxHQUFHQTtJQUNkO0FBQ0o7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTUM7SUFDRjs7SUFFQSxHQUNBSCxZQUFZSSxTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ3JCLElBQUksQ0FBQ0MsRUFBRSxHQUFHUDtRQUNWLElBQUksQ0FBQ1EsT0FBTyxHQUFHLENBQUMsQ0FBQ0YsT0FBT0UsT0FBTztRQUMvQixJQUFJLENBQUNDLFdBQVcsR0FBR0gsT0FBT0csV0FBVyxJQUFLO1lBQ3RDLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7O0lBUUEsR0FDQUMsSUFBSUMsS0FBSyxFQUFFO1FBQ1AsSUFBSSxJQUFJLENBQUNKLE9BQU8sRUFDWixNQUFNLElBQUlLLFdBQVc7UUFDekIsSUFBSSxPQUFPRCxTQUFTLFlBQ2hCQSxRQUFRRSxTQUFTRixLQUFLLENBQUNBO1FBQzNCLE9BQU8sQ0FBQ0c7WUFDSixJQUFJQyxTQUFTSixNQUFNRztZQUNuQixPQUFPQyxXQUFXQyxZQUFZLE9BQU87Z0JBQUMsSUFBSTtnQkFBRUQ7YUFBTztRQUN2RDtJQUNKO0FBQ0o7QUFDQTs7Ozs7QUFLQSxHQUNBWCxTQUFTYSxRQUFRLEdBQUcsSUFBSWIsU0FBUztJQUFFSSxhQUFhVSxDQUFBQSxNQUFPQSxJQUFJQyxLQUFLLENBQUM7QUFBSztBQUN0RTs7OztBQUlBLEdBQ0FmLFNBQVNnQixRQUFRLEdBQUcsSUFBSWhCLFNBQVM7SUFBRUksYUFBYVUsQ0FBQUEsTUFBT0EsSUFBSUMsS0FBSyxDQUFD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cUcsT0FBT3JHLEtBQUt3TixRQUFRMU8sTUFBTSxFQUFFZ0YsTUFBTXVDLE9BQU81SixLQUFLK1EsT0FBTyxDQUFDeE4sRUFBRSxDQUFDeEQsSUFBSTtnQkFDakUsSUFBSXNILE1BQU1sQyxLQUNOdkUsT0FBT3FELElBQUksQ0FBQyxJQUFJcU0sYUFBYW5MLEtBQUtrQyxLQUFLbUUsTUFBTS9KLElBQUksRUFBRSxDQUFDMkwsVUFBVStHLEtBQUtwVSxJQUFJLElBQUlvRixPQUFPZ1AsS0FBSzVELFNBQVMsRUFBRTRELEtBQUtuVSxFQUFFLElBQUlxSCxPQUFPOE0sS0FBSzNELE9BQU87Z0JBQ3BJLElBQUk1RyxNQUNBO2dCQUNKekUsTUFBTTRMLE9BQU8sQ0FBQ3hOLEVBQUUsQ0FBQ3ZELEVBQUU7WUFDdkI7UUFDSixPQUNLO1lBQ0RZLE9BQU9xRCxJQUFJLENBQUMsSUFBSXFNLGFBQWF2USxNQUFNQyxJQUFJd0wsTUFBTS9KLElBQUksRUFBRSxDQUFDMkwsVUFBVStHLEtBQUtwVSxJQUFJLElBQUlxTixZQUFZK0csS0FBSzVELFNBQVMsRUFBRTRELEtBQUtuVSxFQUFFLElBQUl1TixVQUFVNEcsS0FBSzNELE9BQU87UUFDNUk7SUFDSjtJQUNBLE9BQU81UDtBQUNYO0FBRWdLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzP2MxOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5UaGUgZGVmYXVsdCBtYXhpbXVtIGxlbmd0aCBvZiBhIGBUcmVlQnVmZmVyYCBub2RlLlxuKi9cbmNvbnN0IERlZmF1bHRCdWZmZXJMZW5ndGggPSAxMDI0O1xubGV0IG5leHRQcm9wSUQgPSAwO1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59XG4vKipcbkVhY2ggW25vZGUgdHlwZV0oI2NvbW1vbi5Ob2RlVHlwZSkgb3IgW2luZGl2aWR1YWwgdHJlZV0oI2NvbW1vbi5UcmVlKVxuY2FuIGhhdmUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGl0IGluIHByb3BzLiBJbnN0YW5jZXMgb2YgdGhpc1xuY2xhc3MgcmVwcmVzZW50IHByb3AgbmFtZXMuXG4qL1xuY2xhc3MgTm9kZVByb3Age1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBub2RlIHByb3AgdHlwZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0UHJvcElEKys7XG4gICAgICAgIHRoaXMucGVyTm9kZSA9ICEhY29uZmlnLnBlck5vZGU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBjb25maWcuZGVzZXJpYWxpemUgfHwgKCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgZGVmaW5lIGEgZGVzZXJpYWxpemUgZnVuY3Rpb25cIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGlzIGlzIG1lYW50IHRvIGJlIHVzZWQgd2l0aFxuICAgIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuICAgIFtgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLlBhcnNlckNvbmZpZy5wcm9wcykgdG8gY29tcHV0ZVxuICAgIHByb3AgdmFsdWVzIGZvciBlYWNoIG5vZGUgdHlwZSBpbiB0aGUgc2V0LiBUYWtlcyBhIFttYXRjaFxuICAgIG9iamVjdF0oI2NvbW1vbi5Ob2RlVHlwZV5tYXRjaCkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHVuZGVmaW5lZFxuICAgIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICAgIGl0IGRvZXMuXG4gICAgKi9cbiAgICBhZGQobWF0Y2gpIHtcbiAgICAgICAgaWYgKHRoaXMucGVyTm9kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgYWRkIHBlci1ub2RlIHByb3BzIHRvIG5vZGUgdHlwZXNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbWF0Y2ggPSBOb2RlVHlwZS5tYXRjaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IFt0aGlzLCByZXN1bHRdO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuUHJvcCB0aGF0IGlzIHVzZWQgdG8gZGVzY3JpYmUgbWF0Y2hpbmcgZGVsaW1pdGVycy4gRm9yIG9wZW5pbmdcbmRlbGltaXRlcnMsIHRoaXMgaG9sZHMgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lcyAod3JpdHRlbiBhcyBhXG5zcGFjZS1zZXBhcmF0ZWQgc3RyaW5nIHdoZW4gZGVjbGFyaW5nIHRoaXMgcHJvcCBpbiBhIGdyYW1tYXIpXG5mb3IgdGhlIG5vZGUgdHlwZXMgb2YgY2xvc2luZyBkZWxpbWl0ZXJzIHRoYXQgbWF0Y2ggaXQuXG4qL1xuTm9kZVByb3AuY2xvc2VkQnkgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vKipcblRoZSBpbnZlcnNlIG9mIFtgY2xvc2VkQnlgXSgjY29tbW9uLk5vZGVQcm9wXmNsb3NlZEJ5KS4gVGhpcyBpc1xuYXR0YWNoZWQgdG8gY2xvc2luZyBkZWxpbWl0ZXJzLCBob2xkaW5nIGFuIGFycmF5IG9mIG5vZGUgbmFtZXNcbm9mIHR5cGVzIG9mIG1hdGNoaW5nIG9wZW5pbmcgZGVsaW1pdGVycy5cbiovXG5Ob2RlUHJvcC5vcGVuZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVXNlZCB0byBhc3NpZ24gbm9kZSB0eXBlcyB0byBncm91cHMgKGZvciBleGFtcGxlLCBhbGwgbm9kZVxudHlwZXMgdGhhdCByZXByZXNlbnQgYW4gZXhwcmVzc2lvbiBjb3VsZCBiZSB0YWdnZWQgd2l0aCBhblxuYFwiRXhwcmVzc2lvblwiYCBncm91cCkuXG4qL1xuTm9kZVByb3AuZ3JvdXAgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogc3RyID0+IHN0ci5zcGxpdChcIiBcIikgfSk7XG4vKipcbkF0dGFjaGVkIHRvIG5vZGVzIHRvIGluZGljYXRlIHRoZXNlIHNob3VsZCBiZVxuW2Rpc3BsYXllZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4VHJlZSlcbmluIGEgYmlkaXJlY3Rpb25hbCB0ZXh0IGlzb2xhdGUsIHNvIHRoYXQgZGlyZWN0aW9uLW5ldXRyYWxcbmNoYXJhY3RlcnMgb24gdGhlaXIgc2lkZXMgZG9uJ3QgaW5jb3JyZWN0bHkgZ2V0IGFzc29jaWF0ZWQgd2l0aFxuc3Vycm91bmRpbmcgdGV4dC4gWW91J2xsIGdlbmVyYWxseSB3YW50IHRvIHNldCB0aGlzIGZvciBub2Rlc1xudGhhdCBjb250YWluIGFyYml0cmFyeSB0ZXh0LCBsaWtlIHN0cmluZ3MgYW5kIGNvbW1lbnRzLCBhbmQgZm9yXG5ub2RlcyB0aGF0IGFwcGVhciBfaW5zaWRlXyBhcmJpdHJhcnkgdGV4dCwgbGlrZSBIVE1MIHRhZ3MuIFdoZW5cbm5vdCBnaXZlbiBhIHZhbHVlLCBpbiBhIGdyYW1tYXIgZGVjbGFyYXRpb24sIGRlZmF1bHRzIHRvXG5gXCJhdXRvXCJgLlxuKi9cbk5vZGVQcm9wLmlzb2xhdGUgPSBuZXcgTm9kZVByb3AoeyBkZXNlcmlhbGl6ZTogdmFsdWUgPT4ge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT0gXCJydGxcIiAmJiB2YWx1ZSAhPSBcImx0clwiICYmIHZhbHVlICE9IFwiYXV0b1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBpc29sYXRlOiBcIiArIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IFwiYXV0b1wiO1xuICAgIH0gfSk7XG4vKipcblRoZSBoYXNoIG9mIHRoZSBbY29udGV4dF0oI2xyLkNvbnRleHRUcmFja2VyLmNvbnN0cnVjdG9yKVxudGhhdCB0aGUgbm9kZSB3YXMgcGFyc2VkIGluLCBpZiBhbnkuIFVzZWQgdG8gbGltaXQgcmV1c2Ugb2ZcbmNvbnRleHR1YWwgbm9kZXMuXG4qL1xuTm9kZVByb3AuY29udGV4dEhhc2ggPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5UaGUgZGlzdGFuY2UgYmV5b25kIHRoZSBlbmQgb2YgdGhlIG5vZGUgdGhhdCB0aGUgdG9rZW5pemVyXG5sb29rZWQgYWhlYWQgZm9yIGFueSBvZiB0aGUgdG9rZW5zIGluc2lkZSB0aGUgbm9kZS4gKFRoZSBMUlxucGFyc2VyIG9ubHkgc3RvcmVzIHRoaXMgd2hlbiBpdCBpcyBsYXJnZXIgdGhhbiAyNSwgZm9yXG5lZmZpY2llbmN5IHJlYXNvbnMuKVxuKi9cbk5vZGVQcm9wLmxvb2tBaGVhZCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoaXMgcGVyLW5vZGUgcHJvcCBpcyB1c2VkIHRvIHJlcGxhY2UgYSBnaXZlbiBub2RlLCBvciBwYXJ0IG9mIGFcbm5vZGUsIHdpdGggYW5vdGhlciB0cmVlLiBUaGlzIGlzIHVzZWZ1bCB0byBpbmNsdWRlIHRyZWVzIGZyb21cbmRpZmZlcmVudCBsYW5ndWFnZXMgaW4gbWl4ZWQtbGFuZ3VhZ2UgcGFyc2Vycy5cbiovXG5Ob2RlUHJvcC5tb3VudGVkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuQSBtb3VudGVkIHRyZWUsIHdoaWNoIGNhbiBiZSBbc3RvcmVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG9uXG5hIHRyZWUgbm9kZSB0byBpbmRpY2F0ZSB0aGF0IHBhcnRzIG9mIGl0cyBjb250ZW50IGFyZVxucmVwcmVzZW50ZWQgYnkgYW5vdGhlciB0cmVlLlxuKi9cbmNsYXNzIE1vdW50ZWRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgaW5uZXIgdHJlZS5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgbnVsbCwgdGhpcyB0cmVlIHJlcGxhY2VzIHRoZSBlbnRpcmUgbm9kZSAoaXQgd2lsbFxuICAgIGJlIGluY2x1ZGVkIGluIHRoZSByZWd1bGFyIGl0ZXJhdGlvbiBpbnN0ZWFkIG9mIGl0cyBob3N0XG4gICAgbm9kZSkuIElmIG5vdCwgb25seSB0aGUgZ2l2ZW4gcmFuZ2VzIGFyZSBjb25zaWRlcmVkIHRvIGJlXG4gICAgY292ZXJlZCBieSB0aGlzIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgdHJlZXMgdGhhdCBhcmUgbWl4ZWQgaW5cbiAgICBhIHdheSB0aGF0IGlzbid0IHN0cmljdGx5IGhpZXJhcmNoaWNhbC4gU3VjaCBtb3VudGVkIHRyZWVzIGFyZVxuICAgIG9ubHkgZW50ZXJlZCBieSBbYHJlc29sdmVJbm5lcmBdKCNjb21tb24uVHJlZS5yZXNvbHZlSW5uZXIpXG4gICAgYW5kIFtgZW50ZXJgXSgjY29tbW9uLlN5bnRheE5vZGUuZW50ZXIpLlxuICAgICovXG4gICAgb3ZlcmxheSwgXG4gICAgLyoqXG4gICAgVGhlIHBhcnNlciB1c2VkIHRvIGNyZWF0ZSB0aGlzIHN1YnRyZWUuXG4gICAgKi9cbiAgICBwYXJzZXIpIHtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGdldCh0cmVlKSB7XG4gICAgICAgIHJldHVybiB0cmVlICYmIHRyZWUucHJvcHMgJiYgdHJlZS5wcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXTtcbiAgICB9XG59XG5jb25zdCBub1Byb3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuRWFjaCBub2RlIGluIGEgc3ludGF4IHRyZWUgaGFzIGEgbm9kZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiovXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGUgbm9kZSB0eXBlLiBOb3QgbmVjZXNzYXJpbHkgdW5pcXVlLCBidXQgaWYgdGhlXG4gICAgZ3JhbW1hciB3YXMgd3JpdHRlbiBwcm9wZXJseSwgZGlmZmVyZW50IG5vZGUgdHlwZXMgd2l0aCB0aGVcbiAgICBzYW1lIG5hbWUgd2l0aGluIGEgbm9kZSBzZXQgc2hvdWxkIHBsYXkgdGhlIHNhbWUgc2VtYW50aWNcbiAgICByb2xlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwcm9wcywgXG4gICAgLyoqXG4gICAgVGhlIGlkIG9mIHRoaXMgbm9kZSBpbiBpdHMgc2V0LiBDb3JyZXNwb25kcyB0byB0aGUgdGVybSBpZHNcbiAgICB1c2VkIGluIHRoZSBwYXJzZXIuXG4gICAgKi9cbiAgICBpZCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmbGFncyA9IDApIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbm9kZSB0eXBlLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHNwZWMucHJvcHMgJiYgc3BlYy5wcm9wcy5sZW5ndGggPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbm9Qcm9wcztcbiAgICAgICAgbGV0IGZsYWdzID0gKHNwZWMudG9wID8gMSAvKiBOb2RlRmxhZy5Ub3AgKi8gOiAwKSB8IChzcGVjLnNraXBwZWQgPyAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8gOiAwKSB8XG4gICAgICAgICAgICAoc3BlYy5lcnJvciA/IDQgLyogTm9kZUZsYWcuRXJyb3IgKi8gOiAwKSB8IChzcGVjLm5hbWUgPT0gbnVsbCA/IDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovIDogMCk7XG4gICAgICAgIGxldCB0eXBlID0gbmV3IE5vZGVUeXBlKHNwZWMubmFtZSB8fCBcIlwiLCBwcm9wcywgc3BlYy5pZCwgZmxhZ3MpO1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHNyYyBvZiBzcGVjLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYyh0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcmNbMF0ucGVyTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3Qgc3RvcmUgYSBwZXItbm9kZSBwcm9wIG9uIGEgbm9kZSB0eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tzcmNbMF0uaWRdID0gc3JjWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlcyBhIG5vZGUgcHJvcCBmb3IgdGhpcyB0eXBlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBpZlxuICAgIHRoZSBwcm9wIGlzbid0IHByZXNlbnQgb24gdGhpcyBub2RlLlxuICAgICovXG4gICAgcHJvcChwcm9wKSB7IHJldHVybiB0aGlzLnByb3BzW3Byb3AuaWRdOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgICAqL1xuICAgIGdldCBpc1RvcCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBOb2RlRmxhZy5Ub3AgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgcHJvZHVjZWQgYnkgYSBza2lwIHJ1bGUuXG4gICAgKi9cbiAgICBnZXQgaXNTa2lwcGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIE5vZGVGbGFnLlNraXBwZWQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYW4gZXJyb3Igbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc0Vycm9yKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIE5vZGVGbGFnLkVycm9yICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgICBuYW1lZCBub2RlLCBmb3IgZXhhbXBsZSBiZWNhdXNlIGl0IGlzIHVzZWQgdG8gY2FjaGUgcmVwZXRpdGlvbi5cbiAgICAqL1xuICAgIGdldCBpc0Fub255bW91cygpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICAgIFtncm91cHNdKCNjb21tb24uTm9kZVByb3BeZ3JvdXApIG1hdGNoZXMgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGlzKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lID09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSB0aGlzLnByb3AoTm9kZVByb3AuZ3JvdXApO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwID8gZ3JvdXAuaW5kZXhPZihuYW1lKSA+IC0xIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaWQgPT0gbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZnVuY3Rpb24gZnJvbSBub2RlIHR5cGVzIHRvIGFyYml0cmFyeSB2YWx1ZXMgYnlcbiAgICBzcGVjaWZ5aW5nIGFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBuYW1lcyBhcmUgbm9kZSBvclxuICAgIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuIFlvdSBjYW4gcHV0IG11bHRpcGxlXG4gICAgbmFtZXMsIHNlcGFyYXRlZCBieSBzcGFjZXMsIGluIGEgc2luZ2xlIHByb3BlcnR5IG5hbWUgdG8gbWFwXG4gICAgbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaChtYXApIHtcbiAgICAgICAgbGV0IGRpcmVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBkaXJlY3RbbmFtZV0gPSBtYXBbcHJvcF07XG4gICAgICAgIHJldHVybiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXBzID0gbm9kZS5wcm9wKE5vZGVQcm9wLmdyb3VwKSwgaSA9IC0xOyBpIDwgKGdyb3VwcyA/IGdyb3Vwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyZWN0W2kgPCAwID8gbm9kZS5uYW1lIDogZ3JvdXBzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbkFuIGVtcHR5IGR1bW15IG5vZGUgdHlwZSB0byB1c2Ugd2hlbiBubyBhY3R1YWwgdHlwZSBpcyBhdmFpbGFibGUuXG4qL1xuTm9kZVR5cGUubm9uZSA9IG5ldyBOb2RlVHlwZShcIlwiLCBPYmplY3QuY3JlYXRlKG51bGwpLCAwLCA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLyk7XG4vKipcbkEgbm9kZSBzZXQgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIG5vZGUgdHlwZXMuIEl0IGlzIHVzZWQgdG9cbmNvbXBhY3RseSByZXByZXNlbnQgdHJlZXMgYnkgc3RvcmluZyB0aGVpciB0eXBlIGlkcywgcmF0aGVyIHRoYW4gYVxuZnVsbCBwb2ludGVyIHRvIHRoZSB0eXBlIG9iamVjdCwgaW4gYSBudW1lcmljIGFycmF5LiBFYWNoIHBhcnNlclxuW2hhc10oI2xyLkxSUGFyc2VyLm5vZGVTZXQpIGEgbm9kZSBzZXQsIGFuZCBbdHJlZVxuYnVmZmVyc10oI2NvbW1vbi5UcmVlQnVmZmVyKSBjYW4gb25seSBzdG9yZSBjb2xsZWN0aW9ucyBvZiBub2Rlc1xuZnJvbSB0aGUgc2FtZSBzZXQuIEEgc2V0IGNhbiBoYXZlIGEgbWF4aW11bSBvZiAyKioxNiAoNjU1MzYpIG5vZGVcbnR5cGVzIGluIGl0LCBzbyB0aGF0IHRoZSBpZHMgZml0IGludG8gMTYtYml0IHR5cGVkIGFycmF5IHNsb3RzLlxuKi9cbmNsYXNzIE5vZGVTZXQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCB3aXRoIHRoZSBnaXZlbiB0eXBlcy4gVGhlIGBpZGAgcHJvcGVydHkgb2YgZWFjaFxuICAgIHR5cGUgc2hvdWxkIGNvcnJlc3BvbmQgdG8gaXRzIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXJyYXkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSB0eXBlcyBpbiB0aGlzIHNldCwgYnkgaWQuXG4gICAgKi9cbiAgICB0eXBlcykge1xuICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodHlwZXNbaV0uaWQgIT0gaSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vZGUgdHlwZSBpZHMgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYXJyYXkgcG9zaXRpb25zIHdoZW4gY3JlYXRpbmcgYSBub2RlIHNldFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIHNldCB3aXRoIHNvbWUgbm9kZSBwcm9wZXJ0aWVzIGFkZGVkLiBUaGVcbiAgICBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QgY2FuIGJlIGNyZWF0ZWQgd2l0aFxuICAgIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLlxuICAgICovXG4gICAgZXh0ZW5kKC4uLnByb3BzKSB7XG4gICAgICAgIGxldCBuZXdUeXBlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBuZXdQcm9wcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gc291cmNlKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdHlwZS5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzW2FkZFswXS5pZF0gPSBhZGRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VHlwZXMucHVzaChuZXdQcm9wcyA/IG5ldyBOb2RlVHlwZSh0eXBlLm5hbWUsIG5ld1Byb3BzLCB0eXBlLmlkLCB0eXBlLmZsYWdzKSA6IHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNldChuZXdUeXBlcyk7XG4gICAgfVxufVxuY29uc3QgQ2FjaGVkTm9kZSA9IG5ldyBXZWFrTWFwKCksIENhY2hlZElubmVyTm9kZSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbk9wdGlvbnMgdGhhdCBjb250cm9sIGl0ZXJhdGlvbi4gQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGB8YFxub3BlcmF0b3IgdG8gZW5hYmxlIG11bHRpcGxlIG9uZXMuXG4qL1xudmFyIEl0ZXJNb2RlO1xuKGZ1bmN0aW9uIChJdGVyTW9kZSkge1xuICAgIC8qKlxuICAgIFdoZW4gZW5hYmxlZCwgaXRlcmF0aW9uIHdpbGwgb25seSB2aXNpdCBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgb2JqZWN0cywgbm90IG5vZGVzIHBhY2tlZCBpbnRvXG4gICAgW2BUcmVlQnVmZmVyYF0oI2NvbW1vbi5UcmVlQnVmZmVyKXMuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIkV4Y2x1ZGVCdWZmZXJzXCJdID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCI7XG4gICAgLyoqXG4gICAgRW5hYmxlIHRoaXMgdG8gbWFrZSBpdGVyYXRpb24gaW5jbHVkZSBhbm9ueW1vdXMgbm9kZXMgKHN1Y2ggYXNcbiAgICB0aGUgbm9kZXMgdGhhdCB3cmFwIHJlcGVhdGVkIGdyYW1tYXIgY29uc3RydWN0cyBpbnRvIGEgYmFsYW5jZWRcbiAgICB0cmVlKS5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiSW5jbHVkZUFub255bW91c1wiXSA9IDJdID0gXCJJbmNsdWRlQW5vbnltb3VzXCI7XG4gICAgLyoqXG4gICAgQnkgZGVmYXVsdCwgcmVndWxhciBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSBub2Rlc1xuICAgIHJlcGxhY2UgdGhlaXIgYmFzZSBub2RlIGluIGl0ZXJhdGlvbi4gRW5hYmxlIHRoaXMgdG8gaWdub3JlIHRoZW1cbiAgICBpbnN0ZWFkLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVNb3VudHNcIl0gPSA0XSA9IFwiSWdub3JlTW91bnRzXCI7XG4gICAgLyoqXG4gICAgVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIGluXG4gICAgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlciktc3R5bGUgbWV0aG9kcy4gSXQgdGVsbHMgdGhlXG4gICAgbGlicmFyeSB0byBub3QgZW50ZXIgbW91bnRlZCBvdmVybGF5cyBpZiBvbmUgY292ZXJzIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJZ25vcmVPdmVybGF5c1wiXSA9IDhdID0gXCJJZ25vcmVPdmVybGF5c1wiO1xufSkoSXRlck1vZGUgfHwgKEl0ZXJNb2RlID0ge30pKTtcbi8qKlxuQSBwaWVjZSBvZiBzeW50YXggdHJlZS4gVGhlcmUgYXJlIHR3byB3YXlzIHRvIGFwcHJvYWNoIHRoZXNlXG50cmVlczogdGhlIHdheSB0aGV5IGFyZSBhY3R1YWxseSBzdG9yZWQgaW4gbWVtb3J5LCBhbmQgdGhlXG5jb252ZW5pZW50IHdheS5cblxuU3ludGF4IHRyZWVzIGFyZSBzdG9yZWQgYXMgYSB0cmVlIG9mIGBUcmVlYCBhbmQgYFRyZWVCdWZmZXJgXG5vYmplY3RzLiBCeSBwYWNraW5nIGRldGFpbCBpbmZvcm1hdGlvbiBpbnRvIGBUcmVlQnVmZmVyYCBsZWFmXG5ub2RlcywgdGhlIHJlcHJlc2VudGF0aW9uIGlzIG1hZGUgYSBsb3QgbW9yZSBtZW1vcnktZWZmaWNpZW50LlxuXG5Ib3dldmVyLCB3aGVuIHlvdSB3YW50IHRvIGFjdHVhbGx5IHdvcmsgd2l0aCB0cmVlIG5vZGVzLCB0aGlzXG5yZXByZXNlbnRhdGlvbiBpcyB2ZXJ5IGF3a3dhcmQsIHNvIG1vc3QgY2xpZW50IGNvZGUgd2lsbCB3YW50IHRvXG51c2UgdGhlIFtgVHJlZUN1cnNvcmBdKCNjb21tb24uVHJlZUN1cnNvcikgb3JcbltgU3ludGF4Tm9kZWBdKCNjb21tb24uU3ludGF4Tm9kZSkgaW50ZXJmYWNlIGluc3RlYWQsIHdoaWNoIHByb3ZpZGVzXG5hIHZpZXcgb24gc29tZSBwYXJ0IG9mIHRoaXMgZGF0YSBzdHJ1Y3R1cmUsIGFuZCBjYW4gYmUgdXNlZCB0b1xubW92ZSBhcm91bmQgdG8gYWRqYWNlbnQgbm9kZXMuXG4qL1xuY2xhc3MgVHJlZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHRyZWUuIFNlZSBhbHNvIFtgVHJlZS5idWlsZGBdKCNjb21tb24uVHJlZV5idWlsZCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0aGUgdG9wIG5vZGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICAqL1xuICAgIGNoaWxkcmVuLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb25zIChvZmZzZXRzIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGlzIHRyZWUpIG9mXG4gICAgdGhlIGNoaWxkcmVuLlxuICAgICovXG4gICAgcG9zaXRpb25zLCBcbiAgICAvKipcbiAgICBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdHJlZVxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBQZXItbm9kZSBbbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcCkgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBub2RlLlxuICAgICovXG4gICAgcHJvcHMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IG51bGw7XG4gICAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgZm9yIChsZXQgW3Byb3AsIHZhbHVlXSBvZiBwcm9wcylcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzW3R5cGVvZiBwcm9wID09IFwibnVtYmVyXCIgPyBwcm9wIDogcHJvcC5pZF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgbW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldCh0aGlzKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgIHJldHVybiBtb3VudGVkLnRyZWUudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IHN0ciA9IGNoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBcIixcIjtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiArPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLnR5cGUubmFtZSA/IGNoaWxkcmVuIDpcbiAgICAgICAgICAgICgvXFxXLy50ZXN0KHRoaXMudHlwZS5uYW1lKSAmJiAhdGhpcy50eXBlLmlzRXJyb3IgPyBKU09OLnN0cmluZ2lmeSh0aGlzLnR5cGUubmFtZSkgOiB0aGlzLnR5cGUubmFtZSkgK1xuICAgICAgICAgICAgICAgIChjaGlsZHJlbi5sZW5ndGggPyBcIihcIiArIGNoaWxkcmVuICsgXCIpXCIgOiBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3RyZWUgY3Vyc29yXSgjY29tbW9uLlRyZWVDdXJzb3IpIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZlxuICAgIHRoZSB0cmVlLiBNb2RlIGNhbiBiZSB1c2VkIHRvIFtjb250cm9sXSgjY29tbW9uLkl0ZXJNb2RlKSB3aGljaFxuICAgIG5vZGVzIHRoZSBjdXJzb3IgdmlzaXRzLlxuICAgICovXG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLnRvcE5vZGUsIG1vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9pbnRpbmcgaW50byB0aGlzIHRyZWVcbiAgICBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUgKHNlZVxuICAgIFtgbW92ZVRvYF0oI2NvbW1vbi5UcmVlQ3Vyc29yLm1vdmVUbykuXG4gICAgKi9cbiAgICBjdXJzb3JBdChwb3MsIHNpZGUgPSAwLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgc2NvcGUgPSBDYWNoZWROb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGU7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihzY29wZSk7XG4gICAgICAgIGN1cnNvci5tb3ZlVG8ocG9zLCBzaWRlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgY3Vyc29yLl90cmVlKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIG9iamVjdCBmb3IgdGhlIHRvcCBvZiB0aGVcbiAgICB0cmVlLlxuICAgICovXG4gICAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUodGhpcywgMCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICBJZiBgc2lkZWAgaXMgLTEsIHRoaXMgd2lsbCBtb3ZlIGludG8gbm9kZXMgdGhhdCBlbmQgYXQgdGhlXG4gICAgcG9zaXRpb24uIElmIDEsIGl0J2xsIG1vdmUgaW50byBub2RlcyB0aGF0IHN0YXJ0IGF0IHRoZVxuICAgIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgICBmcm9tIGJvdGggc2lkZXMuXG4gICAgXG4gICAgTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZW50ZXJcbiAgICBbb3ZlcmxheXNdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSksIGFuZCB5b3Ugb2Z0ZW4gd2FudFxuICAgIFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcikgaW5zdGVhZC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZSwgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgICAgIENhY2hlZE5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gICAgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpIG5vZGVzLCBwcm9kdWNpbmcgYSBzeW50YXggbm9kZVxuICAgIHBvaW50aW5nIGludG8gdGhlIGlubmVybW9zdCBvdmVybGFpZCB0cmVlIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgICB0aGUgaG9zdCB0cmVlcykuXG4gICAgKi9cbiAgICByZXNvbHZlSW5uZXIocG9zLCBzaWRlID0gMCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJlc29sdmVOb2RlKENhY2hlZElubmVyTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgICAgICBDYWNoZWRJbm5lck5vZGUuc2V0KHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW4gc29tZSBzaXR1YXRpb25zLCBpdCBjYW4gYmUgdXNlZnVsIHRvIGl0ZXJhdGUgdGhyb3VnaCBhbGxcbiAgICBub2RlcyBhcm91bmQgYSBwb3NpdGlvbiwgaW5jbHVkaW5nIHRob3NlIGluIG92ZXJsYXlzIHRoYXQgZG9uJ3RcbiAgICBkaXJlY3RseSBjb3ZlciB0aGUgcG9zaXRpb24uIFRoaXMgbWV0aG9kIGdpdmVzIHlvdSBhbiBpdGVyYXRvclxuICAgIHRoYXQgd2lsbCBwcm9kdWNlIGFsbCBub2RlcywgZnJvbSBzbWFsbCB0byBiaWcsIGFyb3VuZCB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHJlc29sdmVTdGFjayhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiBzdGFja0l0ZXJhdG9yKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBhbmQgaXRzIGNoaWxkcmVuLCBjYWxsaW5nIGBlbnRlcmAgZm9yIGFueVxuICAgIG5vZGUgdGhhdCB0b3VjaGVzIHRoZSBgZnJvbWAvYHRvYCByZWdpb24gKGlmIGdpdmVuKSBiZWZvcmVcbiAgICBydW5uaW5nIG92ZXIgc3VjaCBhIG5vZGUncyBjaGlsZHJlbiwgYW5kIGBsZWF2ZWAgKGlmIGdpdmVuKSB3aGVuXG4gICAgbGVhdmluZyB0aGUgbm9kZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgdGhhdCBub2RlIHdpbGxcbiAgICBub3QgaGF2ZSBpdHMgY2hpbGRyZW4gaXRlcmF0ZWQgb3ZlciAob3IgYGxlYXZlYCBjYWxsZWQpLlxuICAgICovXG4gICAgaXRlcmF0ZShzcGVjKSB7XG4gICAgICAgIGxldCB7IGVudGVyLCBsZWF2ZSwgZnJvbSA9IDAsIHRvID0gdGhpcy5sZW5ndGggfSA9IHNwZWM7XG4gICAgICAgIGxldCBtb2RlID0gc3BlYy5tb2RlIHx8IDAsIGFub24gPSAobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID4gMDtcbiAgICAgICAgZm9yIChsZXQgYyA9IHRoaXMuY3Vyc29yKG1vZGUgfCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKTs7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGMuZnJvbSA8PSB0byAmJiBjLnRvID49IGZyb20gJiYgKCFhbm9uICYmIGMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcihjKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50ZXJlZCAmJiBsZWF2ZSAmJiAoYW5vbiB8fCAhYy50eXBlLmlzQW5vbnltb3VzKSlcbiAgICAgICAgICAgICAgICAgICAgbGVhdmUoYyk7XG4gICAgICAgICAgICAgICAgaWYgKGMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZW50ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gW25vZGUgcHJvcF0oI2NvbW1vbi5Ob2RlUHJvcCkgZm9yIHRoaXNcbiAgICBub2RlLiBXb3JrcyB3aXRoIGJvdGggcGVyLW5vZGUgYW5kIHBlci10eXBlIHByb3BzLlxuICAgICovXG4gICAgcHJvcChwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJvcC5wZXJOb2RlID8gdGhpcy50eXBlLnByb3AocHJvcCkgOiB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1twcm9wLmlkXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgbm9kZSdzIFtwZXItbm9kZSBwcm9wc10oI2NvbW1vbi5Ob2RlUHJvcC5wZXJOb2RlKSBpbiBhXG4gICAgZm9ybWF0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICAgIGNvbnN0cnVjdG9yLlxuICAgICovXG4gICAgZ2V0IHByb3BWYWx1ZXMoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMpXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFsraWQsIHRoaXMucHJvcHNbaWRdXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEJhbGFuY2UgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIHRyZWUsIHByb2R1Y2luZyBhIGNvcHkgb2ZcbiAgICB3aGljaCBtYXkgaGF2ZSBjaGlsZHJlbiBncm91cGVkIGludG8gc3VidHJlZXMgd2l0aCB0eXBlXG4gICAgW2BOb2RlVHlwZS5ub25lYF0oI2NvbW1vbi5Ob2RlVHlwZV5ub25lKS5cbiAgICAqL1xuICAgIGJhbGFuY2UoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IDggLyogQmFsYW5jZS5CcmFuY2hGYWN0b3IgKi8gPyB0aGlzIDpcbiAgICAgICAgICAgIGJhbGFuY2VSYW5nZShOb2RlVHlwZS5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZSh0aGlzLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5wcm9wVmFsdWVzKSwgY29uZmlnLm1ha2VUcmVlIHx8ICgoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgdHJlZSBmcm9tIGEgcG9zdGZpeC1vcmRlcmVkIGJ1ZmZlciBvZiBub2RlIGluZm9ybWF0aW9uLFxuICAgIG9yIGEgY3Vyc29yIG92ZXIgc3VjaCBhIGJ1ZmZlci5cbiAgICAqL1xuICAgIHN0YXRpYyBidWlsZChkYXRhKSB7IHJldHVybiBidWlsZFRyZWUoZGF0YSk7IH1cbn1cbi8qKlxuVGhlIGVtcHR5IHRyZWVcbiovXG5UcmVlLmVtcHR5ID0gbmV3IFRyZWUoTm9kZVR5cGUubm9uZSwgW10sIFtdLCAwKTtcbmNsYXNzIEZsYXRCdWZmZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDRdOyB9XG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDNdOyB9XG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAyXTsgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDFdOyB9XG4gICAgZ2V0IHBvcygpIHsgcmV0dXJuIHRoaXMuaW5kZXg7IH1cbiAgICBuZXh0KCkgeyB0aGlzLmluZGV4IC09IDQ7IH1cbiAgICBmb3JrKCkgeyByZXR1cm4gbmV3IEZsYXRCdWZmZXJDdXJzb3IodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpOyB9XG59XG4vKipcblRyZWUgYnVmZmVycyBjb250YWluICh0eXBlLCBzdGFydCwgZW5kLCBlbmRJbmRleCkgcXVhZHMgZm9yIGVhY2hcbm5vZGUuIEluIHN1Y2ggYSBidWZmZXIsIG5vZGVzIGFyZSBzdG9yZWQgaW4gcHJlZml4IG9yZGVyIChwYXJlbnRzXG5iZWZvcmUgY2hpbGRyZW4sIHdpdGggdGhlIGVuZEluZGV4IG9mIHRoZSBwYXJlbnQgaW5kaWNhdGluZyB3aGljaFxuY2hpbGRyZW4gYmVsb25nIHRvIGl0KS5cbiovXG5jbGFzcyBUcmVlQnVmZmVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0cmVlIGJ1ZmZlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBidWZmZXIncyBjb250ZW50LlxuICAgICovXG4gICAgYnVmZmVyLCBcbiAgICAvKipcbiAgICBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBncm91cCBvZiBub2RlcyBpbiB0aGUgYnVmZmVyLlxuICAgICovXG4gICAgbGVuZ3RoLCBcbiAgICAvKipcbiAgICBUaGUgbm9kZSBzZXQgdXNlZCBpbiB0aGlzIGJ1ZmZlci5cbiAgICAqL1xuICAgIHNldCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gTm9kZVR5cGUubm9uZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYnVmZmVyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5idWZmZXJbaW5kZXggKyAzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCIsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoaWxkU3RyaW5nKGluZGV4KSB7XG4gICAgICAgIGxldCBpZCA9IHRoaXMuYnVmZmVyW2luZGV4XSwgZW5kSW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuc2V0LnR5cGVzW2lkXSwgcmVzdWx0ID0gdHlwZS5uYW1lO1xuICAgICAgICBpZiAoL1xcVy8udGVzdChyZXN1bHQpICYmICF0eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAoZW5kSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBcIihcIiArIGNoaWxkcmVuLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluZENoaWxkKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMsIHBpY2sgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgPSBidWZmZXJbaSArIDNdKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tTaWRlKHNpZGUsIHBvcywgYnVmZmVyW2kgKyAxXSwgYnVmZmVyW2kgKyAyXSkpIHtcbiAgICAgICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2s7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSB7XG4gICAgICAgIGxldCBiID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFVpbnQxNkFycmF5KGVuZEkgLSBzdGFydEkpLCBsZW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJLCBqID0gMDsgaSA8IGVuZEk7KSB7XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK107XG4gICAgICAgICAgICBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgbGV0IHRvID0gY29weVtqKytdID0gYltpKytdIC0gZnJvbTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIHN0YXJ0STtcbiAgICAgICAgICAgIGxlbiA9IE1hdGgubWF4KGxlbiwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUJ1ZmZlcihjb3B5LCBsZW4sIHRoaXMuc2V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NpZGUoc2lkZSwgcG9zLCBmcm9tLCB0bykge1xuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlIC0yIC8qIFNpZGUuQmVmb3JlICovOiByZXR1cm4gZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAtMSAvKiBTaWRlLkF0T3JCZWZvcmUgKi86IHJldHVybiB0byA+PSBwb3MgJiYgZnJvbSA8IHBvcztcbiAgICAgICAgY2FzZSAwIC8qIFNpZGUuQXJvdW5kICovOiByZXR1cm4gZnJvbSA8IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAxIC8qIFNpZGUuQXRPckFmdGVyICovOiByZXR1cm4gZnJvbSA8PSBwb3MgJiYgdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgMiAvKiBTaWRlLkFmdGVyICovOiByZXR1cm4gdG8gPiBwb3M7XG4gICAgICAgIGNhc2UgNCAvKiBTaWRlLkRvbnRDYXJlICovOiByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlTm9kZShub2RlLCBwb3MsIHNpZGUsIG92ZXJsYXlzKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgIHdoaWxlIChub2RlLmZyb20gPT0gbm9kZS50byB8fFxuICAgICAgICAoc2lkZSA8IDEgPyBub2RlLmZyb20gPj0gcG9zIDogbm9kZS5mcm9tID4gcG9zKSB8fFxuICAgICAgICAoc2lkZSA+IC0xID8gbm9kZS50byA8PSBwb3MgOiBub2RlLnRvIDwgcG9zKSkge1xuICAgICAgICBsZXQgcGFyZW50ID0gIW92ZXJsYXlzICYmIG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBub2RlLmluZGV4IDwgMCA/IG51bGwgOiBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgbGV0IG1vZGUgPSBvdmVybGF5cyA/IDAgOiBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cztcbiAgICAvLyBNdXN0IGdvIHVwIG91dCBvZiBvdmVybGF5cyB3aGVuIHRob3NlIGRvIG5vdCBvdmVybGFwIHdpdGggcG9zXG4gICAgaWYgKG92ZXJsYXlzKVxuICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgcGFyZW50ID0gc2Nhbi5wYXJlbnQ7IHBhcmVudDsgc2NhbiA9IHBhcmVudCwgcGFyZW50ID0gc2Nhbi5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChzY2FuIGluc3RhbmNlb2YgVHJlZU5vZGUgJiYgc2Nhbi5pbmRleCA8IDAgJiYgKChfYSA9IHBhcmVudC5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbSkgIT0gc2Nhbi5mcm9tKVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBpbm5lciA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQmFzZU5vZGUge1xuICAgIGN1cnNvcihtb2RlID0gMCkgeyByZXR1cm4gbmV3IFRyZWVDdXJzb3IodGhpcywgbW9kZSk7IH1cbiAgICBnZXRDaGlsZCh0eXBlLCBiZWZvcmUgPSBudWxsLCBhZnRlciA9IG51bGwpIHtcbiAgICAgICAgbGV0IHIgPSBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgcmV0dXJuIHIubGVuZ3RoID8gclswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGRyZW4odGhpcywgdHlwZSwgYmVmb3JlLCBhZnRlcik7XG4gICAgfVxuICAgIHJlc29sdmUocG9zLCBzaWRlID0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZU5vZGUodGhpcywgcG9zLCBzaWRlLCBmYWxzZSk7XG4gICAgfVxuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIHRydWUpO1xuICAgIH1cbiAgICBtYXRjaENvbnRleHQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7XG4gICAgICAgIGxldCBzY2FuID0gdGhpcy5jaGlsZEJlZm9yZShwb3MpLCBub2RlID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHNjYW4pIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gc2Nhbi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGxhc3QudHlwZS5pc0Vycm9yICYmIGxhc3QuZnJvbSA9PSBsYXN0LnRvKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICAgICAgc2NhbiA9IGxhc3QucHJldlNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnBhcmVudDsgfVxufVxuY2xhc3MgVHJlZU5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gICAgY29uc3RydWN0b3IoX3RyZWUsIGZyb20sIFxuICAgIC8vIEluZGV4IGluIHBhcmVudCBub2RlLCBzZXQgdG8gLTEgaWYgdGhlIG5vZGUgaXMgbm90IGEgZGlyZWN0IGNoaWxkIG9mIF9wYXJlbnQubm9kZSAob3ZlcmxheSlcbiAgICBpbmRleCwgX3BhcmVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90cmVlID0gX3RyZWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZS5uYW1lOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5fdHJlZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXM7Oykge1xuICAgICAgICAgICAgZm9yIChsZXQgeyBjaGlsZHJlbiwgcG9zaXRpb25zIH0gPSBwYXJlbnQuX3RyZWUsIGUgPSBkaXIgPiAwID8gY2hpbGRyZW4ubGVuZ3RoIDogLTE7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2ldLCBzdGFydCA9IHBvc2l0aW9uc1tpXSArIHBhcmVudC5mcm9tO1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2tTaWRlKHNpZGUsIHBvcywgc3RhcnQsIHN0YXJ0ICsgbmV4dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU1vdW50cykgJiYgKG1vdW50ZWQgPSBNb3VudGVkVHJlZS5nZXQobmV4dCkpICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhcGFyZW50LnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50LmluZGV4ID49IDApXG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudC5pbmRleCArIGRpcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll9wYXJlbnQuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzKSAmJiAobW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldCh0aGlzLl90cmVlKSkgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgclBvcyA9IHBvcyAtIHRoaXMuZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPiAwID8gZnJvbSA8PSByUG9zIDogZnJvbSA8IHJQb3MpICYmXG4gICAgICAgICAgICAgICAgICAgIChzaWRlIDwgMCA/IHRvID49IHJQb3MgOiB0byA+IHJQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgbW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyB0aGlzLmZyb20sIC0xLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCBzaWRlLCBtb2RlKTtcbiAgICB9XG4gICAgbmV4dFNpZ25pZmljYW50UGFyZW50KCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHZhbC50eXBlLmlzQW5vbnltb3VzICYmIHZhbC5fcGFyZW50KVxuICAgICAgICAgICAgdmFsID0gdmFsLl9wYXJlbnQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4ICsgMSwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50b1N0cmluZygpOyB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlLCB0eXBlLCBiZWZvcmUsIGFmdGVyKSB7XG4gICAgbGV0IGN1ciA9IG5vZGUuY3Vyc29yKCksIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIGZvciAobGV0IGZvdW5kID0gZmFsc2U7ICFmb3VuZDspIHtcbiAgICAgICAgICAgIGZvdW5kID0gY3VyLnR5cGUuaXMoYmVmb3JlKTtcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGFmdGVyICE9IG51bGwgJiYgY3VyLnR5cGUuaXMoYWZ0ZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKGN1ci50eXBlLmlzKHR5cGUpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyLm5vZGUpO1xuICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgcmV0dXJuIGFmdGVyID09IG51bGwgPyByZXN1bHQgOiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXRjaE5vZGVDb250ZXh0KG5vZGUsIGNvbnRleHQsIGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICBmb3IgKGxldCBwID0gbm9kZS5wYXJlbnQ7IGkgPj0gMDsgcCA9IHAucGFyZW50KSB7XG4gICAgICAgIGlmICghcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwLnR5cGUuaXNBbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0W2ldICYmIGNvbnRleHRbaV0gIT0gcC5uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIEJ1ZmZlckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgYnVmZmVyLCBpbmRleCwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy50eXBlLm5hbWU7IH1cbiAgICBnZXQgZnJvbSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTsgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5zdGFydCArIHRoaXMuY29udGV4dC5idWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAyXTsgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIF9wYXJlbnQsIGluZGV4KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy50eXBlID0gY29udGV4dC5idWZmZXIuc2V0LnR5cGVzW2NvbnRleHQuYnVmZmVyLmJ1ZmZlcltpbmRleF1dO1xuICAgIH1cbiAgICBjaGlsZChkaXIsIHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIGRpciwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5jaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGlmIChtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBzaWRlID4gMCA/IDEgOiAtMSwgcG9zIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IG51bGwgOiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCB8fCB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRTaWduaWZpY2FudFBhcmVudCgpO1xuICAgIH1cbiAgICBleHRlcm5hbFNpYmxpbmcoZGlyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyBudWxsIDogdGhpcy5jb250ZXh0LnBhcmVudC5uZXh0Q2hpbGQodGhpcy5jb250ZXh0LmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoYWZ0ZXIgPCAodGhpcy5fcGFyZW50ID8gYnVmZmVyLmJ1ZmZlclt0aGlzLl9wYXJlbnQuaW5kZXggKyAzXSA6IGJ1ZmZlci5idWZmZXIubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlcm5hbFNpYmxpbmcoMSk7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBwYXJlbnRTdGFydCA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pbmRleCArIDQgOiAwO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSBwYXJlbnRTdGFydClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygtMSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZSh0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgIH1cbiAgICBnZXQgdHJlZSgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0b1RyZWUoKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCBzdGFydEkgPSB0aGlzLmluZGV4ICsgNCwgZW5kSSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICBpZiAoZW5kSSA+IHN0YXJ0SSkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVmZmVyLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgdGhpcy50byAtIHRoaXMuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpOyB9XG59XG5mdW5jdGlvbiBpdGVyU3RhY2soaGVhZHMpIHtcbiAgICBpZiAoIWhlYWRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHBpY2sgPSAwLCBwaWNrZWQgPSBoZWFkc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gaGVhZHNbaV07XG4gICAgICAgIGlmIChub2RlLmZyb20gPiBwaWNrZWQuZnJvbSB8fCBub2RlLnRvIDwgcGlja2VkLnRvKSB7XG4gICAgICAgICAgICBwaWNrZWQgPSBub2RlO1xuICAgICAgICAgICAgcGljayA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5leHQgPSBwaWNrZWQgaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBwaWNrZWQuaW5kZXggPCAwID8gbnVsbCA6IHBpY2tlZC5wYXJlbnQ7XG4gICAgbGV0IG5ld0hlYWRzID0gaGVhZHMuc2xpY2UoKTtcbiAgICBpZiAobmV4dClcbiAgICAgICAgbmV3SGVhZHNbcGlja10gPSBuZXh0O1xuICAgIGVsc2VcbiAgICAgICAgbmV3SGVhZHMuc3BsaWNlKHBpY2ssIDEpO1xuICAgIHJldHVybiBuZXcgU3RhY2tJdGVyYXRvcihuZXdIZWFkcywgcGlja2VkKTtcbn1cbmNsYXNzIFN0YWNrSXRlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGhlYWRzLCBub2RlKSB7XG4gICAgICAgIHRoaXMuaGVhZHMgPSBoZWFkcztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiBpdGVyU3RhY2sodGhpcy5oZWFkcyk7IH1cbn1cbmZ1bmN0aW9uIHN0YWNrSXRlcmF0b3IodHJlZSwgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGlubmVyID0gdHJlZS5yZXNvbHZlSW5uZXIocG9zLCBzaWRlKSwgbGF5ZXJzID0gbnVsbDtcbiAgICBmb3IgKGxldCBzY2FuID0gaW5uZXIgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IGlubmVyIDogaW5uZXIuY29udGV4dC5wYXJlbnQ7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudCkge1xuICAgICAgICBpZiAoc2Nhbi5pbmRleCA8IDApIHsgLy8gVGhpcyBpcyBhbiBvdmVybGF5IHJvb3RcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzY2FuLnBhcmVudDtcbiAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHBhcmVudC5yZXNvbHZlKHBvcywgc2lkZSkpO1xuICAgICAgICAgICAgc2NhbiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3VudCA9IE1vdW50ZWRUcmVlLmdldChzY2FuLnRyZWUpO1xuICAgICAgICAgICAgLy8gUmVsZXZhbnQgb3ZlcmxheSBicmFuY2hpbmcgb2ZmXG4gICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQub3ZlcmxheSAmJiBtb3VudC5vdmVybGF5WzBdLmZyb20gPD0gcG9zICYmIG1vdW50Lm92ZXJsYXlbbW91bnQub3ZlcmxheS5sZW5ndGggLSAxXS50byA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdCA9IG5ldyBUcmVlTm9kZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBzY2FuLmZyb20sIC0xLCBzY2FuKTtcbiAgICAgICAgICAgICAgICAobGF5ZXJzIHx8IChsYXllcnMgPSBbaW5uZXJdKSkucHVzaChyZXNvbHZlTm9kZShyb290LCBwb3MsIHNpZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxheWVycyA/IGl0ZXJTdGFjayhsYXllcnMpIDogaW5uZXI7XG59XG4vKipcbkEgdHJlZSBjdXJzb3Igb2JqZWN0IGZvY3VzZXMgb24gYSBnaXZlbiBub2RlIGluIGEgc3ludGF4IHRyZWUsIGFuZFxuYWxsb3dzIHlvdSB0byBtb3ZlIHRvIGFkamFjZW50IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVDdXJzb3Ige1xuICAgIC8qKlxuICAgIFNob3J0aGFuZCBmb3IgYC50eXBlLm5hbWVgLlxuICAgICovXG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RlID0gMCkge1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyZWUgPSBub2RlLmNvbnRleHQucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gbm9kZS5fcGFyZW50OyBuOyBuID0gbi5fcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChuLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHlpZWxkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGU7XG4gICAgICAgIHRoaXMudHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gbm9kZS5mcm9tO1xuICAgICAgICB0aGlzLnRvID0gbm9kZS50bztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHlpZWxkQnVmKGluZGV4LCB0eXBlKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgYnVmZmVyLnNldC50eXBlc1tidWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgICAgIHRoaXMuZnJvbSA9IHN0YXJ0ICsgYnVmZmVyLmJ1ZmZlcltpbmRleCArIDFdO1xuICAgICAgICB0aGlzLnRvID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMl07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHlpZWxkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBub2RlLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG5vZGUuaW5kZXgsIG5vZGUudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHRoaXMuYnVmZmVyLmJ1ZmZlci5jaGlsZFN0cmluZyh0aGlzLmluZGV4KSA6IHRoaXMuX3RyZWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbnRlckNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZCh0aGlzLl90cmVlLm5leHRDaGlsZChkaXIgPCAwID8gdGhpcy5fdHJlZS5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUsIHRoaXMubW9kZSkpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmJ1ZmZlci5zdGFydCwgc2lkZSk7XG4gICAgICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gICAgZmFsc2UsIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgYW5kIHRoZSBjdXJzb3IgaGFzIG5vdCBiZWVuIG1vdmVkLlxuICAgICovXG4gICAgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICAgKi9cbiAgICBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGZpcnN0IGNoaWxkIHRoYXQgZW5kcyBhZnRlciBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGNoaWxkIGFyb3VuZCBgcG9zYC4gSWYgc2lkZSBpcyAtMSB0aGVcbiAgICBjaGlsZCBtYXkgZW5kIGF0IHRoYXQgcG9zaXRpb24sIHdoZW4gMSBpdCBtYXkgc3RhcnQgdGhlcmUuIFRoaXNcbiAgICB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gICAgW21vdW50ZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdHJlZXMgdW5sZXNzIGBvdmVybGF5c2AgaXNcbiAgICBzZXQgdG8gZmFsc2UuXG4gICAgKi9cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSB0aGlzLm1vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUuZW50ZXIocG9zLCBzaWRlLCBtb2RlKSk7XG4gICAgICAgIHJldHVybiBtb2RlICYgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMgPyBmYWxzZSA6IHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBub2RlJ3MgcGFyZW50IG5vZGUsIGlmIHRoaXMgaXNuJ3QgdGhlIHRvcCBub2RlLlxuICAgICovXG4gICAgcGFyZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKCh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYodGhpcy5zdGFjay5wb3AoKSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGROb2RlKHBhcmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2libGluZyhkaXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fdHJlZS5fcGFyZW50ID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChkaXIgPCAwKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50U3RhcnQgPSBkIDwgMCA/IDAgOiB0aGlzLnN0YWNrW2RdICsgNDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ICE9IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKGJ1ZmZlci5maW5kQ2hpbGQocGFyZW50U3RhcnQsIHRoaXMuaW5kZXgsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgICAgICAgICAgaWYgKGFmdGVyIDwgKGQgPCAwID8gYnVmZmVyLmJ1ZmZlci5sZW5ndGggOiBidWZmZXIuYnVmZmVyW3RoaXMuc3RhY2tbZF0gKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGRpciwgZGlyLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8sIHRoaXMubW9kZSkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBuZXh0U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygxKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAgICovXG4gICAgcHJldlNpYmxpbmcoKSB7IHJldHVybiB0aGlzLnNpYmxpbmcoLTEpOyB9XG4gICAgYXRMYXN0Tm9kZShkaXIpIHtcbiAgICAgICAgbGV0IGluZGV4LCBwYXJlbnQsIHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluZGV4IDwgYnVmZmVyLmJ1ZmZlci5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5idWZmZXIuYnVmZmVyW2kgKyAzXSA8IHRoaXMuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoeyBpbmRleCwgcGFyZW50IH0gPSBidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHsgaW5kZXgsIF9wYXJlbnQ6IHBhcmVudCB9ID0gdGhpcy5fdHJlZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IHBhcmVudDsgeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCArIGRpciwgZSA9IGRpciA8IDAgPyAtMSA6IHBhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50Ll90cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFjaGlsZC50eXBlLmlzQW5vbnltb3VzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZChjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtb3ZlKGRpciwgZW50ZXIpIHtcbiAgICAgICAgaWYgKGVudGVyICYmIHRoaXMuZW50ZXJDaGlsZChkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2libGluZyhkaXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShkaXIpIHx8ICF0aGlzLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYVxuICAgIFtwcmUtb3JkZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfdHJhdmVyc2FsI1ByZS1vcmRlcixfTkxSKVxuICAgIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgICBjdXJyZW50IG5vZGUgaXMgZW1wdHkgb3IgYGVudGVyYCBpcyBmYWxzZSwgaXRzIG5leHQgc2libGluZyBvclxuICAgIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGZpcnN0IHBhcmVudCBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIG5leHQoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoMSwgZW50ZXIpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGEgbGFzdC10by1maXJzdCBwcmUtb3JkZXIgdHJhdmVyYWwuIEFcbiAgICBub2RlIGlzIGZvbGxvd2VkIGJ5IGl0cyBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXG4gICAgcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gICAgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgKi9cbiAgICBwcmV2KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xLCBlbnRlcik7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXG4gICAgKi9cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgICBidWZmZXJdKCNjb21tb24uVHJlZUJ1ZmZlcikuXG4gICAgKi9cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUuX3RyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY3VycmVudCBub2RlIGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzLCBjYWxsaW5nXG4gICAgYGVudGVyYCB3aGVuIGVudGVyaW5nIGEgbm9kZSBhbmQgYGxlYXZlYCwgaWYgZ2l2ZW4sIHdoZW4gbGVhdmluZ1xuICAgIG9uZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgYW55IGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcmVcbiAgICBza2lwcGVkLCBhbmQgYGxlYXZlYCBpc24ndCBjYWxsZWQgZm9yIGl0LlxuICAgICovXG4gICAgaXRlcmF0ZShlbnRlciwgbGVhdmUpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIodGhpcykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0aGlzLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBub2RlIG1hdGNoZXMgYSBnaXZlbiBjb250ZXh04oCUYSBzZXF1ZW5jZVxuICAgIG9mIGRpcmVjdCBwYXJlbnQgbm9kZSBuYW1lcy4gRW1wdHkgc3RyaW5ncyBpbiB0aGUgY29udGV4dCBhcnJheVxuICAgIGFyZSB0cmVhdGVkIGFzIHdpbGRjYXJkcy5cbiAgICAqL1xuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUsIGNvbnRleHQpO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuYnVmZmVyLCB7IHR5cGVzIH0gPSBidWZmZXIuc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gY29udGV4dC5sZW5ndGggLSAxLCBkID0gdGhpcy5zdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGQtLSkge1xuICAgICAgICAgICAgaWYgKGQgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZSwgY29udGV4dCwgaSk7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW2J1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXV1dO1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSB0eXBlLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQ2hpbGQodHJlZSkge1xuICAgIHJldHVybiB0cmVlLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8ICFjaC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKGNoKSk7XG59XG5mdW5jdGlvbiBidWlsZFRyZWUoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyBidWZmZXIsIG5vZGVTZXQsIG1heEJ1ZmZlckxlbmd0aCA9IERlZmF1bHRCdWZmZXJMZW5ndGgsIHJldXNlZCA9IFtdLCBtaW5SZXBlYXRUeXBlID0gbm9kZVNldC50eXBlcy5sZW5ndGggfSA9IGRhdGE7XG4gICAgbGV0IGN1cnNvciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKSA/IG5ldyBGbGF0QnVmZmVyQ3Vyc29yKGJ1ZmZlciwgYnVmZmVyLmxlbmd0aCkgOiBidWZmZXI7XG4gICAgbGV0IHR5cGVzID0gbm9kZVNldC50eXBlcztcbiAgICBsZXQgY29udGV4dEhhc2ggPSAwLCBsb29rQWhlYWQgPSAwO1xuICAgIGZ1bmN0aW9uIHRha2VOb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGluUmVwZWF0LCBkZXB0aCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBsZXQgbG9va0FoZWFkQXRTdGFydCA9IGxvb2tBaGVhZDtcbiAgICAgICAgd2hpbGUgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHNpemUgPT0gLTEgLyogU3BlY2lhbFJlY29yZC5SZXVzZSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmV1c2VkW2lkXTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7IC8vIENvbnRleHQgY2hhbmdlXG4gICAgICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVucmVjb2duaXplZCByZWNvcmQgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaWRdLCBub2RlLCBidWZmZXI7XG4gICAgICAgIGxldCBzdGFydFBvcyA9IHN0YXJ0IC0gcGFyZW50U3RhcnQ7XG4gICAgICAgIGlmIChlbmQgLSBzdGFydCA8PSBtYXhCdWZmZXJMZW5ndGggJiYgKGJ1ZmZlciA9IGZpbmRCdWZmZXJTaXplKGN1cnNvci5wb3MgLSBtaW5Qb3MsIGluUmVwZWF0KSkpIHtcbiAgICAgICAgICAgIC8vIFNtYWxsIGVub3VnaCBmb3IgYSBidWZmZXIsIGFuZCBubyByZXVzZWQgbm9kZXMgaW5zaWRlXG4gICAgICAgICAgICBsZXQgZGF0YSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2l6ZSAtIGJ1ZmZlci5za2lwKTtcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gYnVmZmVyLnNpemUsIGluZGV4ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXIuc3RhcnQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgVHJlZUJ1ZmZlcihkYXRhLCBlbmQgLSBidWZmZXIuc3RhcnQsIG5vZGVTZXQpO1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBidWZmZXIuc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gTWFrZSBpdCBhIG5vZGVcbiAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gc2l6ZTtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvY2FsSW5SZXBlYXQgPSBpZCA+PSBtaW5SZXBlYXRUeXBlID8gaWQgOiAtMTtcbiAgICAgICAgICAgIGxldCBsYXN0R3JvdXAgPSAwLCBsYXN0RW5kID0gZW5kO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGN1cnNvci5pZCA9PSBsb2NhbEluUmVwZWF0ICYmIGN1cnNvci5zaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5lbmQgPD0gbGFzdEVuZCAtIG1heEJ1ZmZlckxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIGN1cnNvci5lbmQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdyb3VwID0gbG9jYWxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW5kID0gY3Vyc29yLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA+IDI1MDAgLyogQ3V0T2ZmLkRlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VGbGF0Tm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0KTtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaWYgKGxvY2FsSW5SZXBlYXQgPiAtMSAmJiBsYXN0R3JvdXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ha2UgPSBtYWtlQmFsYW5jZWQodHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGJhbGFuY2VSYW5nZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgMCwgbG9jYWxDaGlsZHJlbi5sZW5ndGgsIDAsIGVuZCAtIHN0YXJ0LCBtYWtlLCBtYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBtYWtlVHJlZSh0eXBlLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgZW5kIC0gc3RhcnQsIGxvb2tBaGVhZEF0U3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFrZUZsYXROb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gW107IC8vIFRlbXBvcmFyeSwgaW52ZXJ0ZWQgYXJyYXkgb2YgbGVhZiBub2RlcyBmb3VuZCwgd2l0aCBhYnNvbHV0ZSBwb3NpdGlvbnNcbiAgICAgICAgbGV0IG5vZGVDb3VudCA9IDAsIHN0b3BBdCA9IC0xO1xuICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IG1pblBvcykge1xuICAgICAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkgeyAvLyBOb3QgYSBsZWFmXG4gICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0b3BBdCA+IC0xICYmIHN0YXJ0IDwgc3RvcEF0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcEF0IDwgMClcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0ID0gZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goaWQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIG5vZGVDb3VudCsrO1xuICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVDb3VudCkge1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShub2RlQ291bnQgKiA0KTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDMsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpICsgMV0gLSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2kgKyAyXSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IFRyZWVCdWZmZXIoYnVmZmVyLCBub2Rlc1syXSAtIHN0YXJ0LCBub2RlU2V0KSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQmFsYW5jZWQodHlwZSkge1xuICAgICAgICByZXR1cm4gKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvb2tBaGVhZCA9IDAsIGxhc3RJID0gY2hpbGRyZW4ubGVuZ3RoIC0gMSwgbGFzdCwgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIGlmIChsYXN0SSA+PSAwICYmIChsYXN0ID0gY2hpbGRyZW5bbGFzdEldKSBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RJICYmIGxhc3QudHlwZSA9PSB0eXBlICYmIGxhc3QubGVuZ3RoID09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tBaGVhZFByb3AgPSBsYXN0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKSlcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gcG9zaXRpb25zW2xhc3RJXSArIGxhc3QubGVuZ3RoICsgbG9va0FoZWFkUHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXBlYXRMZWFmKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGJhc2UsIGksIGZyb20sIHRvLCB0eXBlLCBsb29rQWhlYWQpIHtcbiAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbi5wb3AoKSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5wb3AoKSArIGJhc2UgLSBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUcmVlKG5vZGVTZXQudHlwZXNbdHlwZV0sIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCB0byAtIGZyb20sIGxvb2tBaGVhZCAtIHRvKSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGZyb20gLSBiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQgPSAwLCBwcm9wcykge1xuICAgICAgICBpZiAoY29udGV4dEhhc2gpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmNvbnRleHRIYXNoLCBjb250ZXh0SGFzaF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZCA+IDI1KSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5sb29rQWhlYWQsIGxvb2tBaGVhZF07XG4gICAgICAgICAgICBwcm9wcyA9IHByb3BzID8gW3BhaXJdLmNvbmNhdChwcm9wcykgOiBbcGFpcl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQnVmZmVyU2l6ZShtYXhTaXplLCBpblJlcGVhdCkge1xuICAgICAgICAvLyBTY2FuIHRocm91Z2ggdGhlIGJ1ZmZlciB0byBmaW5kIHByZXZpb3VzIHNpYmxpbmdzIHRoYXQgZml0XG4gICAgICAgIC8vIHRvZ2V0aGVyIGluIGEgVHJlZUJ1ZmZlciwgYW5kIGRvbid0IGNvbnRhaW4gYW55IHJldXNlZCBub2Rlc1xuICAgICAgICAvLyAod2hpY2ggY2FuJ3QgYmUgc3RvcmVkIGluIGEgYnVmZmVyKS5cbiAgICAgICAgLy8gSWYgYGluUmVwZWF0YCBpcyA+IC0xLCBpZ25vcmUgbm9kZSBib3VuZGFyaWVzIG9mIHRoYXQgdHlwZSBmb3JcbiAgICAgICAgLy8gbmVzdGluZywgYnV0IG1ha2Ugc3VyZSB0aGUgZW5kIGZhbGxzIGVpdGhlciBhdCB0aGUgc3RhcnRcbiAgICAgICAgLy8gKGBtYXhTaXplYCkgb3IgYmVmb3JlIHN1Y2ggYSBub2RlLlxuICAgICAgICBsZXQgZm9yayA9IGN1cnNvci5mb3JrKCk7XG4gICAgICAgIGxldCBzaXplID0gMCwgc3RhcnQgPSAwLCBza2lwID0gMCwgbWluU3RhcnQgPSBmb3JrLmVuZCAtIG1heEJ1ZmZlckxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgc2l6ZTogMCwgc3RhcnQ6IDAsIHNraXA6IDAgfTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbWluUG9zID0gZm9yay5wb3MgLSBtYXhTaXplOyBmb3JrLnBvcyA+IG1pblBvczspIHtcbiAgICAgICAgICAgIGxldCBub2RlU2l6ZSA9IGZvcmsuc2l6ZTtcbiAgICAgICAgICAgIC8vIFByZXRlbmQgbmVzdGVkIHJlcGVhdCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGRvbid0IGV4aXN0XG4gICAgICAgICAgICBpZiAoZm9yay5pZCA9PSBpblJlcGVhdCAmJiBub2RlU2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0IHRoYXQgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYSB2YWxpZCByZXR1cm5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICAgICAgICAgIHNraXAgKz0gNDtcbiAgICAgICAgICAgICAgICBzaXplICs9IDQ7XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRQb3MgPSBmb3JrLnBvcyAtIG5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKG5vZGVTaXplIDwgMCB8fCBzdGFydFBvcyA8IG1pblBvcyB8fCBmb3JrLnN0YXJ0IDwgbWluU3RhcnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgbG9jYWxTa2lwcGVkID0gZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlID8gNCA6IDA7XG4gICAgICAgICAgICBsZXQgbm9kZVN0YXJ0ID0gZm9yay5zdGFydDtcbiAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcmsucG9zID4gc3RhcnRQb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yay5zaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JrLmlkID49IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBub2RlU3RhcnQ7XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplO1xuICAgICAgICAgICAgc2tpcCArPSBsb2NhbFNraXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluUmVwZWF0IDwgMCB8fCBzaXplID09IG1heFNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LnNraXAgPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuc2l6ZSA+IDQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoc2l6ZSA+PSAwICYmIGlkIDwgbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmRQb3MgPSBjdXJzb3IucG9zIC0gKHNpemUgLSA0KTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGVuZCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gc3RhcnQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKSB7XG4gICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgIGxvb2tBaGVhZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChjdXJzb3IucG9zID4gMClcbiAgICAgICAgdGFrZU5vZGUoZGF0YS5zdGFydCB8fCAwLCBkYXRhLmJ1ZmZlclN0YXJ0IHx8IDAsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIC0xLCAwKTtcbiAgICBsZXQgbGVuZ3RoID0gKF9hID0gZGF0YS5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChjaGlsZHJlbi5sZW5ndGggPyBwb3NpdGlvbnNbMF0gKyBjaGlsZHJlblswXS5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4gbmV3IFRyZWUodHlwZXNbZGF0YS50b3BJRF0sIGNoaWxkcmVuLnJldmVyc2UoKSwgcG9zaXRpb25zLnJldmVyc2UoKSwgbGVuZ3RoKTtcbn1cbmNvbnN0IG5vZGVTaXplQ2FjaGUgPSBuZXcgV2Vha01hcDtcbmZ1bmN0aW9uIG5vZGVTaXplKGJhbGFuY2VUeXBlLCBub2RlKSB7XG4gICAgaWYgKCFiYWxhbmNlVHlwZS5pc0Fub255bW91cyB8fCBub2RlIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fCBub2RlLnR5cGUgIT0gYmFsYW5jZVR5cGUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBzaXplID0gbm9kZVNpemVDYWNoZS5nZXQobm9kZSk7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT0gYmFsYW5jZVR5cGUgfHwgIShjaGlsZCBpbnN0YW5jZW9mIFRyZWUpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVNpemVDYWNoZS5zZXQobm9kZSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuZnVuY3Rpb24gYmFsYW5jZVJhbmdlKFxuLy8gVGhlIHR5cGUgdGhlIGJhbGFuY2VkIHRyZWUncyBpbm5lciBub2Rlcy5cbmJhbGFuY2VUeXBlLCBcbi8vIFRoZSBkaXJlY3QgY2hpbGRyZW4gYW5kIHRoZWlyIHBvc2l0aW9uc1xuY2hpbGRyZW4sIHBvc2l0aW9ucywgXG4vLyBUaGUgaW5kZXggcmFuZ2UgaW4gY2hpbGRyZW4vcG9zaXRpb25zIHRvIHVzZVxuZnJvbSwgdG8sIFxuLy8gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBub2RlcywgcmVsYXRpdmUgdG8gdGhlaXIgcGFyZW50Llxuc3RhcnQsIFxuLy8gTGVuZ3RoIG9mIHRoZSBvdXRlciBub2RlXG5sZW5ndGgsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgdGhlIHRvcCBub2RlIG9mIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RvcCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCBpbnRlcm5hbCBub2RlcyBmb3IgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVHJlZSkge1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICB0b3RhbCArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgIGxldCBtYXhDaGlsZCA9IE1hdGguY2VpbCgodG90YWwgKiAxLjUpIC8gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyk7XG4gICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOykge1xuICAgICAgICAgICAgbGV0IGdyb3VwRnJvbSA9IGksIGdyb3VwU3RhcnQgPSBwb3NpdGlvbnNbaV0sIGdyb3VwU2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgKyBuZXh0U2l6ZSA+PSBtYXhDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplICs9IG5leHRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT0gZ3JvdXBGcm9tICsgMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPiBtYXhDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25seSA9IGNoaWxkcmVuW2dyb3VwRnJvbV07IC8vIE9ubHkgdHJlZXMgY2FuIGhhdmUgYSBzaXplID4gMVxuICAgICAgICAgICAgICAgICAgICBkaXZpZGUob25seS5jaGlsZHJlbiwgb25seS5wb3NpdGlvbnMsIDAsIG9ubHkuY2hpbGRyZW4ubGVuZ3RoLCBwb3NpdGlvbnNbZ3JvdXBGcm9tXSArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goY2hpbGRyZW5bZ3JvdXBGcm9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gcG9zaXRpb25zW2kgLSAxXSArIGNoaWxkcmVuW2kgLSAxXS5sZW5ndGggLSBncm91cFN0YXJ0O1xuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChiYWxhbmNlUmFuZ2UoYmFsYW5jZVR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGdyb3VwRnJvbSwgaSwgZ3JvdXBTdGFydCwgbGVuZ3RoLCBudWxsLCBta1RyZWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2goZ3JvdXBTdGFydCArIG9mZnNldCAtIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXZpZGUoY2hpbGRyZW4sIHBvc2l0aW9ucywgZnJvbSwgdG8sIDApO1xuICAgIHJldHVybiAobWtUb3AgfHwgbWtUcmVlKShsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbGVuZ3RoKTtcbn1cbi8qKlxuUHJvdmlkZXMgYSB3YXkgdG8gYXNzb2NpYXRlIHZhbHVlcyB3aXRoIHBpZWNlcyBvZiB0cmVlcy4gQXMgbG9uZ1xuYXMgdGhhdCBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJldXNlZCwgdGhlIGFzc29jaWF0ZWQgdmFsdWVzIGNhbiBiZVxucmV0cmlldmVkIGZyb20gYW4gdXBkYXRlZCB0cmVlLlxuKi9cbmNsYXNzIE5vZGVXZWFrTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBzZXRCdWZmZXIoYnVmZmVyLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoYnVmZmVyLCBpbm5lciA9IG5ldyBNYXApO1xuICAgICAgICBpbm5lci5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5tYXAuZ2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBpbm5lciAmJiBpbm5lci5nZXQoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgc2V0KG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSlcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5vZGUudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZSwgaWYgaXQgZXhpc3RzIGluIHRoZSBtYXAuXG4gICAgKi9cbiAgICBnZXQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUgPyB0aGlzLmdldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4KVxuICAgICAgICAgICAgOiBub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUgPyB0aGlzLm1hcC5nZXQobm9kZS50cmVlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzIHRvLlxuICAgICovXG4gICAgY3Vyc29yU2V0KGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnNvci5idWZmZXIpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChjdXJzb3IudHJlZSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50c1xuICAgIHRvLlxuICAgICovXG4gICAgY3Vyc29yR2V0KGN1cnNvcikge1xuICAgICAgICByZXR1cm4gY3Vyc29yLmJ1ZmZlciA/IHRoaXMuZ2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgpIDogdGhpcy5tYXAuZ2V0KGN1cnNvci50cmVlKTtcbiAgICB9XG59XG5cbi8qKlxuVHJlZSBmcmFnbWVudHMgYXJlIHVzZWQgZHVyaW5nIFtpbmNyZW1lbnRhbFxucGFyc2luZ10oI2NvbW1vbi5QYXJzZXIuc3RhcnRQYXJzZSkgdG8gdHJhY2sgcGFydHMgb2Ygb2xkIHRyZWVzXG50aGF0IGNhbiBiZSByZXVzZWQgaW4gYSBuZXcgcGFyc2UuIEFuIGFycmF5IG9mIGZyYWdtZW50cyBpcyB1c2VkXG50byB0cmFjayByZWdpb25zIG9mIGFuIG9sZCB0cmVlIHdob3NlIG5vZGVzIG1pZ2h0IGJlIHJldXNlZCBpbiBuZXdcbnBhcnNlcy4gVXNlIHRoZSBzdGF0aWNcbltgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBtZXRob2QgdG9cbnVwZGF0ZSBmcmFnbWVudHMgZm9yIGRvY3VtZW50IGNoYW5nZXMuXG4qL1xuY2xhc3MgVHJlZUZyYWdtZW50IHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZVxuICAgIFtgYWRkVHJlZWBdKCNjb21tb24uVHJlZUZyYWdtZW50XmFkZFRyZWUpIGFuZFxuICAgIFtgYXBwbHlDaGFuZ2VzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYXBwbHlDaGFuZ2VzKSBpbnN0ZWFkIG9mXG4gICAgY2FsbGluZyB0aGlzIGRpcmVjdGx5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UgcG9pbnRlZCB0byBieSB0aGlzIGZyYWdtZW50LlxuICAgIFRoaXMgcmVmZXJzIHRvIGFuIG9mZnNldCBpbiB0aGUgX3VwZGF0ZWRfIGRvY3VtZW50IChhcyBvcHBvc2VkXG4gICAgdG8gdGhlIG9yaWdpbmFsIHRyZWUpLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSB0cmVlIHRoYXQgdGhpcyBmcmFnbWVudCBpcyBiYXNlZCBvbi5cbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgZnJhZ21lbnQncyB0cmVlIGFuZCB0aGUgZG9jdW1lbnQgdGhhdFxuICAgIHRoaXMgZnJhZ21lbnQgY2FuIGJlIHVzZWQgYWdhaW5zdC4gQWRkIHRoaXMgd2hlbiBnb2luZyBmcm9tXG4gICAgZG9jdW1lbnQgdG8gdHJlZSBwb3NpdGlvbnMsIHN1YnRyYWN0IGl0IHRvIGdvIGZyb20gdHJlZSB0b1xuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIG9mZnNldCwgb3BlblN0YXJ0ID0gZmFsc2UsIG9wZW5FbmQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLm9wZW4gPSAob3BlblN0YXJ0ID8gMSAvKiBPcGVuLlN0YXJ0ICovIDogMCkgfCAob3BlbkVuZCA/IDIgLyogT3Blbi5FbmQgKi8gOiAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIHN0YXJ0IG9mIGFcbiAgICBwYXJzZSwgb3IgdGhlIGVuZCBvZiBhIGNoYW5nZS4gKEluIHRoZSBzZWNvbmQgY2FzZSwgaXQgbWF5IG5vdFxuICAgIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgICBwYXJzaW5nIGFsZ29yaXRobS4pXG4gICAgKi9cbiAgICBnZXQgb3BlblN0YXJ0KCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDEgLyogT3Blbi5TdGFydCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYVxuICAgIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBvcGVuRW5kKCkgeyByZXR1cm4gKHRoaXMub3BlbiAmIDIgLyogT3Blbi5FbmQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICAgIGFuIGV4aXN0aW5nIHNldCBvZiBmcmFnbWVudHMgYnkgcmVwbGFjaW5nIHRoZSBvbmVzIHRoYXQgb3ZlcmxhcFxuICAgIHdpdGggYSB0cmVlIHdpdGggY29udGVudCBmcm9tIHRoZSBuZXcgdHJlZS4gV2hlbiBgcGFydGlhbGAgaXNcbiAgICB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICAgIGZyYWdtZW50IGhhcyBbYG9wZW5FbmRgXSgjY29tbW9uLlRyZWVGcmFnbWVudC5vcGVuRW5kKSBzZXQgdG9cbiAgICB0cnVlLlxuICAgICovXG4gICAgc3RhdGljIGFkZFRyZWUodHJlZSwgZnJhZ21lbnRzID0gW10sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW25ldyBUcmVlRnJhZ21lbnQoMCwgdHJlZS5sZW5ndGgsIHRyZWUsIDAsIGZhbHNlLCBwYXJ0aWFsKV07XG4gICAgICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKVxuICAgICAgICAgICAgaWYgKGYudG8gPiB0cmVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBzZXQgb2YgZWRpdHMgdG8gYW4gYXJyYXkgb2YgZnJhZ21lbnRzLCByZW1vdmluZyBvclxuICAgIHNwbGl0dGluZyBmcmFnbWVudHMgYXMgbmVjZXNzYXJ5IHRvIHJlbW92ZSBlZGl0ZWQgcmFuZ2VzLCBhbmRcbiAgICBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgY2hhbmdlcywgbWluR2FwID0gMTI4KSB7XG4gICAgICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBmSSA9IDEsIG5leHRGID0gZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1swXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNJID0gMCwgcG9zID0gMCwgb2ZmID0gMDs7IGNJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QyA9IGNJIDwgY2hhbmdlcy5sZW5ndGggPyBjaGFuZ2VzW2NJXSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHRDID8gbmV4dEMuZnJvbUEgOiAxZTk7XG4gICAgICAgICAgICBpZiAobmV4dFBvcyAtIHBvcyA+PSBtaW5HYXApXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHRGICYmIG5leHRGLmZyb20gPCBuZXh0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXQgPSBuZXh0RjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBjdXQuZnJvbSB8fCBuZXh0UG9zIDw9IGN1dC50byB8fCBvZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmRnJvbSA9IE1hdGgubWF4KGN1dC5mcm9tLCBwb3MpIC0gb2ZmLCBmVG8gPSBNYXRoLm1pbihjdXQudG8sIG5leHRQb3MpIC0gb2ZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3V0ID0gZkZyb20gPj0gZlRvID8gbnVsbCA6IG5ldyBUcmVlRnJhZ21lbnQoZkZyb20sIGZUbywgY3V0LnRyZWUsIGN1dC5vZmZzZXQgKyBvZmYsIGNJID4gMCwgISFuZXh0Qyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Ri50byA+IG5leHRQb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbmV4dEYgPSBmSSA8IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbZkkrK10gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dEMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0Qy50b0E7XG4gICAgICAgICAgICBvZmYgPSBuZXh0Qy50b0EgLSBuZXh0Qy50b0I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcbkEgc3VwZXJjbGFzcyB0aGF0IHBhcnNlcnMgc2hvdWxkIGV4dGVuZC5cbiovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgIFN0YXJ0IGEgcGFyc2UsIHJldHVybmluZyBhIFtwYXJ0aWFsIHBhcnNlXSgjY29tbW9uLlBhcnRpYWxQYXJzZSlcbiAgICBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgICBtYWtlIHRoZSBwYXJzZSBpbmNyZW1lbnRhbC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICAgIHdoaWNoIHNob3VsZCBiZSBhIHNvcnRlZCBhcnJheSBvZiBub24tZW1wdHksIG5vbi1vdmVybGFwcGluZ1xuICAgIHJhbmdlcywgdG8gcGFyc2Ugb25seSB0aG9zZSByYW5nZXMuIFRoZSB0cmVlIHJldHVybmVkIGluIHRoYXRcbiAgICBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgICAqL1xuICAgIHN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGlucHV0ID0gbmV3IFN0cmluZ0lucHV0KGlucHV0KTtcbiAgICAgICAgcmFuZ2VzID0gIXJhbmdlcyA/IFtuZXcgUmFuZ2UoMCwgaW5wdXQubGVuZ3RoKV0gOiByYW5nZXMubGVuZ3RoID8gcmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20sIHIudG8pKSA6IFtuZXcgUmFuZ2UoMCwgMCldO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzIHx8IFtdLCByYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICovXG4gICAgcGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IHRoaXMuc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU3RyaW5nSW5wdXQge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIGNodW5rKGZyb20pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20pOyB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIHJlYWQoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20sIHRvKTsgfVxufVxuXG4vKipcbkNyZWF0ZSBhIHBhcnNlIHdyYXBwZXIgdGhhdCwgYWZ0ZXIgdGhlIGlubmVyIHBhcnNlIGNvbXBsZXRlcyxcbnNjYW5zIGl0cyB0cmVlIGZvciBtaXhlZCBsYW5ndWFnZSByZWdpb25zIHdpdGggdGhlIGBuZXN0YFxuZnVuY3Rpb24sIHJ1bnMgdGhlIHJlc3VsdGluZyBbaW5uZXIgcGFyc2VzXSgjY29tbW9uLk5lc3RlZFBhcnNlKSxcbmFuZCB0aGVuIFttb3VudHNdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgdGhlaXIgcmVzdWx0cyBvbnRvIHRoZVxudHJlZS5cbiovXG5mdW5jdGlvbiBwYXJzZU1peGVkKG5lc3QpIHtcbiAgICByZXR1cm4gKHBhcnNlLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IG5ldyBNaXhlZFBhcnNlKHBhcnNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xufVxuY2xhc3MgSW5uZXJQYXJzZSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwYXJzZSwgb3ZlcmxheSwgdGFyZ2V0LCBmcm9tKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnBhcnNlID0gcGFyc2U7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUmFuZ2VzKHJhbmdlcykge1xuICAgIGlmICghcmFuZ2VzLmxlbmd0aCB8fCByYW5nZXMuc29tZShyID0+IHIuZnJvbSA+PSByLnRvKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlubmVyIHBhcnNlIHJhbmdlcyBnaXZlbjogXCIgKyBKU09OLnN0cmluZ2lmeShyYW5nZXMpKTtcbn1cbmNsYXNzIEFjdGl2ZU92ZXJsYXkge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcHJlZGljYXRlLCBtb3VudHMsIGluZGV4LCBzdGFydCwgdGFyZ2V0LCBwcmV2KSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy5tb3VudHMgPSBtb3VudHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxufVxuY29uc3Qgc3RvcHBlZElubmVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbmNsYXNzIE1peGVkUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICB0aGlzLm5lc3QgPSBuZXN0O1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbm5lciA9IFtdO1xuICAgICAgICB0aGlzLmlubmVyRG9uZSA9IDA7XG4gICAgICAgIHRoaXMuYmFzZVRyZWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFzZVBhcnNlID0gYmFzZTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKSB7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYmFzZVBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRyZWUgPSBkb25lO1xuICAgICAgICAgICAgdGhpcy5zdGFydElubmVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbm5lciBvZiB0aGlzLmlubmVyKVxuICAgICAgICAgICAgICAgICAgICBpbm5lci5wYXJzZS5zdG9wQXQodGhpcy5zdG9wcGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlubmVyRG9uZSA9PSB0aGlzLmlubmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuYmFzZVRyZWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHJlZShyZXN1bHQudHlwZSwgcmVzdWx0LmNoaWxkcmVuLCByZXN1bHQucG9zaXRpb25zLCByZXN1bHQubGVuZ3RoLCByZXN1bHQucHJvcFZhbHVlcy5jb25jYXQoW1tzdG9wcGVkSW5uZXIsIHRoaXMuc3RvcHBlZEF0XV0pKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIGRvbmUgPSBpbm5lci5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyRG9uZSsrO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNvbWV3aGF0IGRvZGd5IGJ1dCBzdXBlciBoZWxwZnVsIGhhY2sgd2hlcmUgd2VcbiAgICAgICAgICAgIC8vIHBhdGNoIHVwIG5vZGVzIGNyZWF0ZWQgYnkgdGhlIGlubmVyIHBhcnNlIChhbmQgdGh1c1xuICAgICAgICAgICAgLy8gcHJlc3VtYWJseSBub3QgYWxpYXNlZCBhbnl3aGVyZSBlbHNlKSB0byBob2xkIHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYWJvdXQgdGhlIGlubmVyIHBhcnNlLlxuICAgICAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBpbm5lci50YXJnZXQucHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNbTm9kZVByb3AubW91bnRlZC5pZF0gPSBuZXcgTW91bnRlZFRyZWUoZG9uZSwgaW5uZXIub3ZlcmxheSwgaW5uZXIucGFyc2VyKTtcbiAgICAgICAgICAgIGlubmVyLnRhcmdldC5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbm5lcltpXS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHBvcyA9IE1hdGgubWluKHBvcywgdGhpcy5pbm5lcltpXS5wYXJzZS5wYXJzZWRQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHN0b3BBdChwb3MpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBwb3M7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHRoaXMuYmFzZVBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbm5lckRvbmU7IGkgPCB0aGlzLmlubmVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJbaV0ucGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgfVxuICAgIHN0YXJ0SW5uZXIoKSB7XG4gICAgICAgIGxldCBmcmFnbWVudEN1cnNvciA9IG5ldyBGcmFnbWVudEN1cnNvcih0aGlzLmZyYWdtZW50cyk7XG4gICAgICAgIGxldCBvdmVybGF5ID0gbnVsbDtcbiAgICAgICAgbGV0IGNvdmVyZWQgPSBudWxsO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFRyZWVDdXJzb3IobmV3IFRyZWVOb2RlKHRoaXMuYmFzZVRyZWUsIHRoaXMucmFuZ2VzWzBdLmZyb20sIDAsIG51bGwpLCBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgbmVzdCwgaXNDb3ZlcmVkOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlciA9IHRydWUsIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgY3Vyc29yLmZyb20gPj0gdGhpcy5zdG9wcGVkQXQpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJhZ21lbnRDdXJzb3IuaGFzTm9kZShjdXJzb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gb3ZlcmxheS5tb3VudHMuZmluZChtID0+IG0uZnJhZy5mcm9tIDw9IGN1cnNvci5mcm9tICYmIG0uZnJhZy50byA+PSBjdXJzb3IudG8gJiYgbS5tb3VudC5vdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiBtYXRjaC5tb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSByLmZyb20gKyBtYXRjaC5wb3MsIHRvID0gci50byArIG1hdGNoLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjdXJzb3IuZnJvbSAmJiB0byA8PSBjdXJzb3IudG8gJiYgIW92ZXJsYXkucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPCB0byAmJiByLnRvID4gZnJvbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdmVyZWQgJiYgKGlzQ292ZXJlZCA9IGNoZWNrQ292ZXIoY292ZXJlZC5yYW5nZXMsIGN1cnNvci5mcm9tLCBjdXJzb3IudG8pKSkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gaXNDb3ZlcmVkICE9IDIgLyogQ292ZXIuRnVsbCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjdXJzb3IudHlwZS5pc0Fub255bW91cyAmJiAobmVzdCA9IHRoaXMubmVzdChjdXJzb3IsIHRoaXMuaW5wdXQpKSAmJlxuICAgICAgICAgICAgICAgIChjdXJzb3IuZnJvbSA8IGN1cnNvci50byB8fCAhbmVzdC5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnRyZWUpXG4gICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsaXplKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgbGV0IG9sZE1vdW50cyA9IGZyYWdtZW50Q3Vyc29yLmZpbmRNb3VudHMoY3Vyc29yLmZyb20sIG5lc3QucGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5lc3Qub3ZlcmxheSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA9IG5ldyBBY3RpdmVPdmVybGF5KG5lc3QucGFyc2VyLCBuZXN0Lm92ZXJsYXksIG9sZE1vdW50cywgdGhpcy5pbm5lci5sZW5ndGgsIGN1cnNvci5mcm9tLCBjdXJzb3IudHJlZSwgb3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2VzID0gcHVuY2hSYW5nZXModGhpcy5yYW5nZXMsIG5lc3Qub3ZlcmxheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvID8gW25ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKV0gOiBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoIHx8ICFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlubmVyLnB1c2gobmV3IElubmVyUGFyc2UobmVzdC5wYXJzZXIsIHJhbmdlcy5sZW5ndGggPyBuZXN0LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG9sZE1vdW50cywgcmFuZ2VzKSwgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmVzdC5wYXJzZXIuc3RhcnRQYXJzZShcIlwiKSwgbmVzdC5vdmVybGF5ID8gbmVzdC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBjdXJzb3IuZnJvbSwgci50byAtIGN1cnNvci5mcm9tKSkgOiBudWxsLCBjdXJzb3IudHJlZSwgcmFuZ2VzLmxlbmd0aCA/IHJhbmdlc1swXS5mcm9tIDogY3Vyc29yLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXN0Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZCA9IHsgcmFuZ2VzLCBkZXB0aDogMCwgcHJldjogY292ZXJlZCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJsYXkgJiYgKHJhbmdlID0gb3ZlcmxheS5wcmVkaWNhdGUoY3Vyc29yKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tIDwgcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkucmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudGVyICYmIGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5kZXB0aCsrO1xuICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkKVxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLmRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVybGF5ICYmICEtLW92ZXJsYXkuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgb3ZlcmxheS5yYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja1JhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIuc3BsaWNlKG92ZXJsYXkuaW5kZXgsIDAsIG5ldyBJbm5lclBhcnNlKG92ZXJsYXkucGFyc2VyLCBvdmVybGF5LnBhcnNlci5zdGFydFBhcnNlKHRoaXMuaW5wdXQsIGVudGVyRnJhZ21lbnRzKG92ZXJsYXkubW91bnRzLCByYW5nZXMpLCByYW5nZXMpLCBvdmVybGF5LnJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gb3ZlcmxheS5zdGFydCwgci50byAtIG92ZXJsYXkuc3RhcnQpKSwgb3ZlcmxheS50YXJnZXQsIHJhbmdlc1swXS5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gb3ZlcmxheS5wcmV2O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3ZlcmVkICYmICEtLWNvdmVyZWQuZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0gY292ZXJlZC5wcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ292ZXIoY292ZXJlZCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBjb3ZlcmVkKSB7XG4gICAgICAgIGlmIChyYW5nZS5mcm9tID49IHRvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChyYW5nZS50byA+IGZyb20pXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2UuZnJvbSA8PSBmcm9tICYmIHJhbmdlLnRvID49IHRvID8gMiAvKiBDb3Zlci5GdWxsICovIDogMSAvKiBDb3Zlci5QYXJ0aWFsICovO1xuICAgIH1cbiAgICByZXR1cm4gMCAvKiBDb3Zlci5Ob25lICovO1xufVxuLy8gVGFrZSBhIHBpZWNlIG9mIGJ1ZmZlciBhbmQgY29udmVydCBpdCBpbnRvIGEgc3RhbmQtYWxvbmVcbi8vIFRyZWVCdWZmZXIuXG5mdW5jdGlvbiBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgZW5kSSwgbm9kZXMsIHBvc2l0aW9ucywgb2ZmKSB7XG4gICAgaWYgKHN0YXJ0SSA8IGVuZEkpIHtcbiAgICAgICAgbGV0IGZyb20gPSBidWYuYnVmZmVyW3N0YXJ0SSArIDFdO1xuICAgICAgICBub2Rlcy5wdXNoKGJ1Zi5zbGljZShzdGFydEksIGVuZEksIGZyb20pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIG9mZik7XG4gICAgfVxufVxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG5vZGUgdGhhdCdzIGluIGEgYnVmZmVyLCBhbmQgY29udmVydHMgaXQsIGFuZFxuLy8gaXRzIHBhcmVudCBidWZmZXIgbm9kZXMsIGludG8gYSBUcmVlLiBUaGlzIGlzIGFnYWluIGFjdGluZyBvbiB0aGVcbi8vIGFzc3VtcHRpb24gdGhhdCB0aGUgdHJlZXMgYW5kIGJ1ZmZlcnMgaGF2ZSBiZWVuIGNvbnN0cnVjdGVkIGJ5IHRoZVxuLy8gcGFyc2UgdGhhdCB3YXMgcmFuIHZpYSB0aGUgbWl4IHBhcnNlciwgYW5kIHRodXMgYXJlbid0IHNoYXJlZCB3aXRoXG4vLyBhbnkgb3RoZXIgY29kZSwgbWFraW5nIHZpb2xhdGlvbnMgb2YgdGhlIGltbXV0YWJpbGl0eSBzYWZlLlxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoY3Vyc29yKSB7XG4gICAgbGV0IHsgbm9kZSB9ID0gY3Vyc29yLCBzdGFjayA9IFtdO1xuICAgIGxldCBidWZmZXIgPSBub2RlLmNvbnRleHQuYnVmZmVyO1xuICAgIC8vIFNjYW4gdXAgdG8gdGhlIG5lYXJlc3QgdHJlZVxuICAgIGRvIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXJzb3IuaW5kZXgpO1xuICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgfSB3aGlsZSAoIWN1cnNvci50cmVlKTtcbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgYnVmZmVyIGluIHRoYXQgdHJlZVxuICAgIGxldCBiYXNlID0gY3Vyc29yLnRyZWUsIGkgPSBiYXNlLmNoaWxkcmVuLmluZGV4T2YoYnVmZmVyKTtcbiAgICBsZXQgYnVmID0gYmFzZS5jaGlsZHJlbltpXSwgYiA9IGJ1Zi5idWZmZXIsIG5ld1N0YWNrID0gW2ldO1xuICAgIC8vIFNwbGl0IGEgbGV2ZWwgaW4gdGhlIGJ1ZmZlciwgcHV0dGluZyB0aGUgbm9kZXMgYmVmb3JlIGFuZCBhZnRlclxuICAgIC8vIHRoZSBjaGlsZCB0aGF0IGNvbnRhaW5zIGBub2RlYCBpbnRvIG5ldyBidWZmZXJzLlxuICAgIGZ1bmN0aW9uIHNwbGl0KHN0YXJ0SSwgZW5kSSwgdHlwZSwgaW5uZXJPZmZzZXQsIGxlbmd0aCwgc3RhY2tQb3MpIHtcbiAgICAgICAgbGV0IHRhcmdldEkgPSBzdGFja1tzdGFja1Bvc107XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBzdGFydEksIHRhcmdldEksIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgbGV0IGZyb20gPSBiW3RhcmdldEkgKyAxXSwgdG8gPSBiW3RhcmdldEkgKyAyXTtcbiAgICAgICAgbmV3U3RhY2sucHVzaChjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICBsZXQgY2hpbGQgPSBzdGFja1Bvc1xuICAgICAgICAgICAgPyBzcGxpdCh0YXJnZXRJICsgNCwgYlt0YXJnZXRJICsgM10sIGJ1Zi5zZXQudHlwZXNbYlt0YXJnZXRJXV0sIGZyb20sIHRvIC0gZnJvbSwgc3RhY2tQb3MgLSAxKVxuICAgICAgICAgICAgOiBub2RlLnRvVHJlZSgpO1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGlubmVyT2Zmc2V0KTtcbiAgICAgICAgc2xpY2VCdWYoYnVmLCBiW3RhcmdldEkgKyAzXSwgZW5kSSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKTtcbiAgICB9XG4gICAgYmFzZS5jaGlsZHJlbltpXSA9IHNwbGl0KDAsIGIubGVuZ3RoLCBOb2RlVHlwZS5ub25lLCAwLCBidWYubGVuZ3RoLCBzdGFjay5sZW5ndGggLSAxKTtcbiAgICAvLyBNb3ZlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgdGFyZ2V0IG5vZGVcbiAgICBmb3IgKGxldCBpbmRleCBvZiBuZXdTdGFjaykge1xuICAgICAgICBsZXQgdHJlZSA9IGN1cnNvci50cmVlLmNoaWxkcmVuW2luZGV4XSwgcG9zID0gY3Vyc29yLnRyZWUucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgY3Vyc29yLnlpZWxkKG5ldyBUcmVlTm9kZSh0cmVlLCBwb3MgKyBjdXJzb3IuZnJvbSwgaW5kZXgsIGN1cnNvci5fdHJlZSkpO1xuICAgIH1cbn1cbmNsYXNzIFN0cnVjdHVyZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSByb290LmN1cnNvcihJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzIHwgSXRlck1vZGUuSWdub3JlTW91bnRzKTtcbiAgICB9XG4gICAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgICBtb3ZlVG8ocG9zKSB7XG4gICAgICAgIGxldCB7IGN1cnNvciB9ID0gdGhpcywgcCA9IHBvcyAtIHRoaXMub2Zmc2V0O1xuICAgICAgICB3aGlsZSAoIXRoaXMuZG9uZSAmJiBjdXJzb3IuZnJvbSA8IHApIHtcbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPj0gcG9zICYmIGN1cnNvci5lbnRlcihwLCAxLCBJdGVyTW9kZS5JZ25vcmVPdmVybGF5cyB8IEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci5uZXh0KGZhbHNlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc05vZGUoY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubW92ZVRvKGN1cnNvci5mcm9tKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5jdXJzb3IuZnJvbSArIHRoaXMub2Zmc2V0ID09IGN1cnNvci5mcm9tICYmIHRoaXMuY3Vyc29yLnRyZWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHRyZWUgPSB0aGlzLmN1cnNvci50cmVlOzspIHtcbiAgICAgICAgICAgICAgICBpZiAodHJlZSA9PSBjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRyZWUuY2hpbGRyZW4ubGVuZ3RoICYmIHRyZWUucG9zaXRpb25zWzBdID09IDAgJiYgdHJlZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRyZWUpXG4gICAgICAgICAgICAgICAgICAgIHRyZWUgPSB0cmVlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5jdXJUbyA9IDA7XG4gICAgICAgIHRoaXMuZnJhZ0kgPSAwO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5jdXJGcmFnID0gZnJhZ21lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jdXJUbyA9IChfYSA9IGZpcnN0LnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaXJzdC50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZpcnN0LnRyZWUsIC1maXJzdC5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmN1ckZyYWcgJiYgbm9kZS5mcm9tID49IHRoaXMuY3VyVG8pXG4gICAgICAgICAgICB0aGlzLm5leHRGcmFnKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gbm9kZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gbm9kZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUobm9kZSk7XG4gICAgfVxuICAgIG5leHRGcmFnKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ0krKztcbiAgICAgICAgaWYgKHRoaXMuZnJhZ0kgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmcmFnID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZnJhZy50cmVlLnByb3Aoc3RvcHBlZElubmVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnJhZy50bztcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBuZXcgU3RydWN0dXJlQ3Vyc29yKGZyYWcudHJlZSwgLWZyYWcub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kTW91bnRzKHBvcywgcGFyc2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKHBvcywgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLmlubmVyLmN1cnNvci5ub2RlOyBwb3M7IHBvcyA9IHBvcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbW91bnQgPSAoX2EgPSBwb3MudHJlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LnBhcnNlciA9PSBwYXJzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJhZ0k7IGkgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnLmZyb20gPj0gcG9zLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcudHJlZSA9PSB0aGlzLmN1ckZyYWcudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogcG9zLmZyb20gLSBmcmFnLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHB1bmNoUmFuZ2VzKG91dGVyLCByYW5nZXMpIHtcbiAgICBsZXQgY29weSA9IG51bGwsIGN1cnJlbnQgPSByYW5nZXM7XG4gICAgZm9yIChsZXQgaSA9IDEsIGogPSAwOyBpIDwgb3V0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSBvdXRlcltpIC0gMV0udG8sIGdhcFRvID0gb3V0ZXJbaV0uZnJvbTtcbiAgICAgICAgZm9yICg7IGogPCBjdXJyZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgciA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBpZiAoci5mcm9tID49IGdhcFRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHIudG8gPD0gZ2FwRnJvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY29weSA9IHJhbmdlcy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHIuZnJvbSA8IGdhcEZyb20pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2pdID0gbmV3IFJhbmdlKHIuZnJvbSwgZ2FwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHIudG8gPiBnYXBUbylcbiAgICAgICAgICAgICAgICAgICAgY29weS5zcGxpY2UoaiArIDEsIDAsIG5ldyBSYW5nZShnYXBUbywgci50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoci50byA+IGdhcFRvKSB7XG4gICAgICAgICAgICAgICAgY29weVtqLS1dID0gbmV3IFJhbmdlKGdhcFRvLCByLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHkuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBmaW5kQ292ZXJDaGFuZ2VzKGEsIGIsIGZyb20sIHRvKSB7XG4gICAgbGV0IGlBID0gMCwgaUIgPSAwLCBpbkEgPSBmYWxzZSwgaW5CID0gZmFsc2UsIHBvcyA9IC0xZTk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHRBID0gaUEgPT0gYS5sZW5ndGggPyAxZTkgOiBpbkEgPyBhW2lBXS50byA6IGFbaUFdLmZyb207XG4gICAgICAgIGxldCBuZXh0QiA9IGlCID09IGIubGVuZ3RoID8gMWU5IDogaW5CID8gYltpQl0udG8gOiBiW2lCXS5mcm9tO1xuICAgICAgICBpZiAoaW5BICE9IGluQikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4obmV4dEEsIG5leHRCLCB0byk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIpO1xuICAgICAgICBpZiAocG9zID09IDFlOSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAobmV4dEEgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQSlcbiAgICAgICAgICAgICAgICBpbkEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5BID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEIgPT0gcG9zKSB7XG4gICAgICAgICAgICBpZiAoIWluQilcbiAgICAgICAgICAgICAgICBpbkIgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5CID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaUIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gR2l2ZW4gYSBudW1iZXIgb2YgZnJhZ21lbnRzIGZvciB0aGUgb3V0ZXIgdHJlZSwgYW5kIGEgc2V0IG9mIHJhbmdlc1xuLy8gdG8gcGFyc2UsIGZpbmQgZnJhZ21lbnRzIGZvciBpbm5lciB0cmVlcyBtb3VudGVkIGFyb3VuZCB0aG9zZVxuLy8gcmFuZ2VzLCBpZiBhbnkuXG5mdW5jdGlvbiBlbnRlckZyYWdtZW50cyhtb3VudHMsIHJhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IHBvcywgbW91bnQsIGZyYWcgfSBvZiBtb3VudHMpIHtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gcG9zICsgKG1vdW50Lm92ZXJsYXkgPyBtb3VudC5vdmVybGF5WzBdLmZyb20gOiAwKSwgZW5kUG9zID0gc3RhcnRQb3MgKyBtb3VudC50cmVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1heChmcmFnLmZyb20sIHN0YXJ0UG9zKSwgdG8gPSBNYXRoLm1pbihmcmFnLnRvLCBlbmRQb3MpO1xuICAgICAgICBpZiAobW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXkgPSBtb3VudC5vdmVybGF5Lm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gKyBwb3MsIHIudG8gKyBwb3MpKTtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gZmluZENvdmVyQ2hhbmdlcyhyYW5nZXMsIG92ZXJsYXksIGZyb20sIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSBmcm9tOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGNoYW5nZXMubGVuZ3RoLCBlbmQgPSBsYXN0ID8gdG8gOiBjaGFuZ2VzW2ldLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChwb3MsIGVuZCwgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gcG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZCB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcG9zID0gY2hhbmdlc1tpXS50bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUcmVlRnJhZ21lbnQoZnJvbSwgdG8sIG1vdW50LnRyZWUsIC1zdGFydFBvcywgZnJhZy5mcm9tID49IHN0YXJ0UG9zIHx8IGZyYWcub3BlblN0YXJ0LCBmcmFnLnRvIDw9IGVuZFBvcyB8fCBmcmFnLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBJdGVyTW9kZSwgTW91bnRlZFRyZWUsIE5vZGVQcm9wLCBOb2RlU2V0LCBOb2RlVHlwZSwgTm9kZVdlYWtNYXAsIFBhcnNlciwgVHJlZSwgVHJlZUJ1ZmZlciwgVHJlZUN1cnNvciwgVHJlZUZyYWdtZW50LCBwYXJzZU1peGVkIH07XG4iXSwibmFtZXMiOlsiRGVmYXVsdEJ1ZmZlckxlbmd0aCIsIm5leHRQcm9wSUQiLCJSYW5nZSIsImNvbnN0cnVjdG9yIiwiZnJvbSIsInRvIiwiTm9kZVByb3AiLCJjb25maWciLCJpZCIsInBlck5vZGUiLCJkZXNlcmlhbGl6ZSIsIkVycm9yIiwiYWRkIiwibWF0Y2giLCJSYW5nZUVycm9yIiwiTm9kZVR5cGUiLCJ0eXBlIiwicmVzdWx0IiwidW5kZWZpbmVkIiwiY2xvc2VkQnkiLCJzdHIiLCJzcGxpdCIsIm9wZW5lZEJ5IiwiZ3JvdXAiLCJpc29sYXRlIiwidmFsdWUiLCJjb250ZXh0SGFzaCIsImxvb2tBaGVhZCIsIm1vdW50ZWQiLCJNb3VudGVkVHJlZSIsInRyZWUiLCJvdmVybGF5IiwicGFyc2VyIiwiZ2V0IiwicHJvcHMiLCJub1Byb3BzIiwiT2JqZWN0IiwiY3JlYXRlIiwibmFtZSIsImZsYWdzIiwiZGVmaW5lIiwic3BlYyIsImxlbmd0aCIsInRvcCIsInNraXBwZWQiLCJlcnJvciIsInNyYyIsIkFycmF5IiwiaXNBcnJheSIsInByb3AiLCJpc1RvcCIsImlzU2tpcHBlZCIsImlzRXJyb3IiLCJpc0Fub255bW91cyIsImlzIiwiaW5kZXhPZiIsIm1hcCIsImRpcmVjdCIsIm5vZGUiLCJncm91cHMiLCJpIiwiZm91bmQiLCJub25lIiwiTm9kZVNldCIsInR5cGVzIiwiZXh0ZW5kIiwibmV3VHlwZXMiLCJuZXdQcm9wcyIsInNvdXJjZSIsImFzc2lnbiIsInB1c2giLCJDYWNoZWROb2RlIiwiV2Vha01hcCIsIkNhY2hlZElubmVyTm9kZSIsIkl0ZXJNb2RlIiwiVHJlZSIsImNoaWxkcmVuIiwicG9zaXRpb25zIiwidG9TdHJpbmciLCJjaCIsInRlc3QiLCJKU09OIiwic3RyaW5naWZ5IiwiY3Vyc29yIiwibW9kZSIsIlRyZWVDdXJzb3IiLCJ0b3BOb2RlIiwiY3Vyc29yQXQiLCJwb3MiLCJzaWRlIiwic2NvcGUiLCJtb3ZlVG8iLCJzZXQiLCJfdHJlZSIsIlRyZWVOb2RlIiwicmVzb2x2ZSIsInJlc29sdmVOb2RlIiwicmVzb2x2ZUlubmVyIiwicmVzb2x2ZVN0YWNrIiwic3RhY2tJdGVyYXRvciIsIml0ZXJhdGUiLCJlbnRlciIsImxlYXZlIiwiYW5vbiIsIkluY2x1ZGVBbm9ueW1vdXMiLCJjIiwiZW50ZXJlZCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInBhcmVudCIsInByb3BWYWx1ZXMiLCJiYWxhbmNlIiwiYmFsYW5jZVJhbmdlIiwibWFrZVRyZWUiLCJidWlsZCIsImRhdGEiLCJidWlsZFRyZWUiLCJlbXB0eSIsIkZsYXRCdWZmZXJDdXJzb3IiLCJidWZmZXIiLCJpbmRleCIsInN0YXJ0IiwiZW5kIiwic2l6ZSIsIm5leHQiLCJmb3JrIiwiVHJlZUJ1ZmZlciIsImNoaWxkU3RyaW5nIiwiam9pbiIsImVuZEluZGV4IiwiZmluZENoaWxkIiwic3RhcnRJbmRleCIsImRpciIsInBpY2siLCJjaGVja1NpZGUiLCJzbGljZSIsInN0YXJ0SSIsImVuZEkiLCJiIiwiY29weSIsIlVpbnQxNkFycmF5IiwibGVuIiwiaiIsIk1hdGgiLCJtYXgiLCJvdmVybGF5cyIsIl9hIiwiSWdub3JlT3ZlcmxheXMiLCJzY2FuIiwiaW5uZXIiLCJCYXNlTm9kZSIsImdldENoaWxkIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyIiwiZ2V0Q2hpbGRyZW4iLCJtYXRjaENvbnRleHQiLCJjb250ZXh0IiwibWF0Y2hOb2RlQ29udGV4dCIsImVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlIiwiY2hpbGRCZWZvcmUiLCJsYXN0IiwibGFzdENoaWxkIiwicHJldlNpYmxpbmciLCJfcGFyZW50IiwibmV4dENoaWxkIiwiZSIsIkV4Y2x1ZGVCdWZmZXJzIiwiQnVmZmVyTm9kZSIsIkJ1ZmZlckNvbnRleHQiLCJoYXNDaGlsZCIsIklnbm9yZU1vdW50cyIsImNoaWxkQWZ0ZXIiLCJyUG9zIiwibmV4dFNpZ25pZmljYW50UGFyZW50IiwidmFsIiwidG9UcmVlIiwiY3VyIiwicCIsImNoaWxkIiwiZXh0ZXJuYWxTaWJsaW5nIiwicGFyZW50U3RhcnQiLCJpdGVyU3RhY2siLCJoZWFkcyIsInBpY2tlZCIsIm5ld0hlYWRzIiwic3BsaWNlIiwiU3RhY2tJdGVyYXRvciIsImxheWVycyIsIm1vdW50Iiwicm9vdCIsInN0YWNrIiwiYnVmZmVyTm9kZSIsInlpZWxkTm9kZSIsIm4iLCJ1bnNoaWZ0IiwieWllbGRCdWYiLCJ5aWVsZCIsImVudGVyQ2hpbGQiLCJwb3AiLCJzaWJsaW5nIiwiZCIsImF0TGFzdE5vZGUiLCJtb3ZlIiwicHJldiIsImNhY2hlIiwiZGVwdGgiLCJtdXN0TGVhdmUiLCJzb21lIiwibm9kZVNldCIsIm1heEJ1ZmZlckxlbmd0aCIsInJldXNlZCIsIm1pblJlcGVhdFR5cGUiLCJ0YWtlTm9kZSIsIm1pblBvcyIsImluUmVwZWF0IiwibG9va0FoZWFkQXRTdGFydCIsInN0YXJ0UG9zIiwiZmluZEJ1ZmZlclNpemUiLCJza2lwIiwiZW5kUG9zIiwiY29weVRvQnVmZmVyIiwibG9jYWxDaGlsZHJlbiIsImxvY2FsUG9zaXRpb25zIiwibG9jYWxJblJlcGVhdCIsImxhc3RHcm91cCIsImxhc3RFbmQiLCJtYWtlUmVwZWF0TGVhZiIsInRha2VGbGF0Tm9kZSIsInJldmVyc2UiLCJtYWtlIiwibWFrZUJhbGFuY2VkIiwibm9kZXMiLCJub2RlQ291bnQiLCJzdG9wQXQiLCJsYXN0SSIsImxvb2tBaGVhZFByb3AiLCJiYXNlIiwicGFpciIsImNvbmNhdCIsIm1heFNpemUiLCJtaW5TdGFydCIsIm5vZGVTaXplIiwibG9jYWxTa2lwcGVkIiwibm9kZVN0YXJ0IiwiYnVmZmVyU3RhcnQiLCJ0b3BJRCIsIm5vZGVTaXplQ2FjaGUiLCJiYWxhbmNlVHlwZSIsIm1rVG9wIiwibWtUcmVlIiwidG90YWwiLCJtYXhDaGlsZCIsImNlaWwiLCJkaXZpZGUiLCJvZmZzZXQiLCJncm91cEZyb20iLCJncm91cFN0YXJ0IiwiZ3JvdXBTaXplIiwibmV4dFNpemUiLCJvbmx5IiwiTm9kZVdlYWtNYXAiLCJzZXRCdWZmZXIiLCJNYXAiLCJnZXRCdWZmZXIiLCJjdXJzb3JTZXQiLCJjdXJzb3JHZXQiLCJUcmVlRnJhZ21lbnQiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib3BlbiIsImFkZFRyZWUiLCJmcmFnbWVudHMiLCJwYXJ0aWFsIiwiZiIsImFwcGx5Q2hhbmdlcyIsImNoYW5nZXMiLCJtaW5HYXAiLCJmSSIsIm5leHRGIiwiY0kiLCJvZmYiLCJuZXh0QyIsIm5leHRQb3MiLCJmcm9tQSIsImN1dCIsImZGcm9tIiwiZlRvIiwibWluIiwidG9BIiwidG9CIiwiUGFyc2VyIiwic3RhcnRQYXJzZSIsImlucHV0IiwicmFuZ2VzIiwiU3RyaW5nSW5wdXQiLCJjcmVhdGVQYXJzZSIsInBhcnNlIiwiZG9uZSIsImFkdmFuY2UiLCJzdHJpbmciLCJjaHVuayIsImxpbmVDaHVua3MiLCJyZWFkIiwicGFyc2VNaXhlZCIsIm5lc3QiLCJNaXhlZFBhcnNlIiwiSW5uZXJQYXJzZSIsInRhcmdldCIsImNoZWNrUmFuZ2VzIiwiQWN0aXZlT3ZlcmxheSIsInByZWRpY2F0ZSIsIm1vdW50cyIsInN0b3BwZWRJbm5lciIsImlubmVyRG9uZSIsImJhc2VUcmVlIiwic3RvcHBlZEF0IiwiYmFzZVBhcnNlIiwic3RhcnRJbm5lciIsInBhcnNlZFBvcyIsImZyYWdtZW50Q3Vyc29yIiwiRnJhZ21lbnRDdXJzb3IiLCJjb3ZlcmVkIiwiaXNDb3ZlcmVkIiwicmFuZ2UiLCJoYXNOb2RlIiwiZmluZCIsIm0iLCJmcmFnIiwiY2hlY2tDb3ZlciIsIm1hdGVyaWFsaXplIiwib2xkTW91bnRzIiwiZmluZE1vdW50cyIsInB1bmNoUmFuZ2VzIiwiZW50ZXJGcmFnbWVudHMiLCJzbGljZUJ1ZiIsImJ1ZiIsIm5ld1N0YWNrIiwiaW5uZXJPZmZzZXQiLCJzdGFja1BvcyIsInRhcmdldEkiLCJTdHJ1Y3R1cmVDdXJzb3IiLCJjdXJUbyIsImZyYWdJIiwiZmlyc3QiLCJjdXJGcmFnIiwibmV4dEZyYWciLCJvdXRlciIsImN1cnJlbnQiLCJnYXBGcm9tIiwiZ2FwVG8iLCJmaW5kQ292ZXJDaGFuZ2VzIiwiYSIsImlBIiwiaUIiLCJpbkEiLCJpbkIiLCJuZXh0QSIsIm5leHRCIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/ class Tag {\n    /**\n    @internal\n    */ constructor(/**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */ set, /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */ base, /**\n    The modifiers applied to this.base @internal\n    */ modified){\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */ this.id = nextTagID++;\n    }\n    /**\n    Define a new tag. If `parent` is given, the tag is treated as a\n    sub-tag of that parent, and\n    [highlighters](#highlight.tagHighlighter) that don't mention\n    this tag will try to fall back to the parent tag (or grandparent\n    tag, etc).\n    */ static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent) for (let t of parent.set)tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */ static defineModifier() {\n        let mod = new Modifier;\n        return (tag)=>{\n            if (tag.modified.indexOf(mod) > -1) return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b)=>a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor(){\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length) return base;\n        let exists = mods[0].instances.find((t)=>t.base == base && sameArray(mods, t.modified));\n        if (exists) return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)if (!parent.modified.length) for (let config of configs)set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i)=>x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [\n        []\n    ];\n    for(let i = 0; i < array.length; i++){\n        for(let j = 0, e = sets.length; j < e; j++){\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b)=>b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single levelâ€”wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/ function styleTags(spec) {\n    let byName = Object.create(null);\n    for(let prop in spec){\n        let tags = spec[prop];\n        if (!Array.isArray(tags)) tags = [\n            tags\n        ];\n        for (let part of prop.split(\" \"))if (part) {\n            let pieces = [], mode = 2 /* Mode.Normal */ , rest = part;\n            for(let pos = 0;;){\n                if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                    mode = 1 /* Mode.Inherit */ ;\n                    break;\n                }\n                let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                if (!m) throw new RangeError(\"Invalid path: \" + part);\n                pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                pos += m[0].length;\n                if (pos == part.length) break;\n                let next = part[pos++];\n                if (pos == part.length && next == \"!\") {\n                    mode = 0 /* Mode.Opaque */ ;\n                    break;\n                }\n                if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n                rest = part.slice(pos);\n            }\n            let last = pieces.length - 1, inner = pieces[last];\n            if (!inner) throw new RangeError(\"Invalid path: \" + part);\n            let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n            byName[inner] = rule.sort(byName[inner]);\n        }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next){\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() {\n        return this.mode == 0 /* Mode.Opaque */ ;\n    }\n    get inherit() {\n        return this.mode == 1 /* Mode.Inherit */ ;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() {\n        return this.context ? this.context.length : 0;\n    }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */ , null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/ function tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags){\n        if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;\n        else for (let tag of style.tag)map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags)=>{\n            let cls = all;\n            for (let tag of tags){\n                for (let sub of tag.set){\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters){\n        let value = highlighter.style(tags);\n        if (value) result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/ function highlightTree(tree, highlighter, /**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/ putStyle, /**\nThe start of the range to highlight.\n*/ from = 0, /**\nThe end of the range.\n*/ to = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [\n        highlighter\n    ], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/ function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n    let pos = from;\n    function writeTo(p, classes) {\n        if (p <= pos) return;\n        for(let text = code.slice(pos, p), i = 0;;){\n            let nextBreak = text.indexOf(\"\\n\", i);\n            let upto = nextBreak < 0 ? text.length : nextBreak;\n            if (upto > i) putText(text.slice(i, upto), classes);\n            if (nextBreak < 0) break;\n            putBreak();\n            i = nextBreak + 1;\n        }\n        pos = p;\n    }\n    highlightTree(tree, highlighter, (from, to, classes)=>{\n        writeTo(from, \"\");\n        writeTo(to, classes);\n    }, from, to);\n    writeTo(to, \"\");\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span){\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at) this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class) this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from) return;\n        if (type.isTop) highlighters = this.highlighters.filter((h)=>!h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls) cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Mode.Inherit */ ) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque) return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter((h)=>!h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for(let i = 0, pos = start;; i++){\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while(cursor.from < rangeTo){\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n                    }\n                }\n                if (!next || nextPos > to) break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild) cursor.parent();\n        } else if (cursor.firstChild()) {\n            if (mounted) inheritedClass = \"\";\n            do {\n                if (cursor.to <= from) continue;\n                if (cursor.from >= to) break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            }while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/ function getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while(rule && rule.context && !node.matchContext(rule.context))rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an elementâ€”if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/ const tags = {\n    /**\n    A comment.\n    */ comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */ lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */ blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */ docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */ name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */ variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */ typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */ tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */ propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */ attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */ className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */ labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */ namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */ macroName: t(name),\n    /**\n    A literal value.\n    */ literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */ string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */ docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */ character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */ attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */ number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */ integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */ float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */ bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */ regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */ escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */ color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */ url: t(literal),\n    /**\n    A language keyword.\n    */ keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */ self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */ null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */ atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */ unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */ modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */ operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */ controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */ definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */ moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */ operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */ derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */ arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */ logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */ bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */ compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */ updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */ definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */ typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */ controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */ punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */ separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */ bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */ angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */ squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */ content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */ heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */ heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */ heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */ heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */ heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */ heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */ heading6: t(heading),\n    /**\n    A prose separator (such as a horizontal rule).\n    */ contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */ list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */ quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */ emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */ strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */ link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */ monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */ strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */ inserted: t(),\n    /**\n    Deleted text.\n    */ deleted: t(),\n    /**\n    Changed text.\n    */ changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */ invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */ meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */ documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */ annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */ processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */ definition: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */ constant: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */ function: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */ standard: Tag.defineModifier(),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */ local: Tag.defineModifier(),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */ special: Tag.defineModifier()\n};\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/ const classHighlighter = tagHighlighter([\n    {\n        tag: tags.link,\n        class: \"tok-link\"\n    },\n    {\n        tag: tags.heading,\n        class: \"tok-heading\"\n    },\n    {\n        tag: tags.emphasis,\n        class: \"tok-emphasis\"\n    },\n    {\n        tag: tags.strong,\n        class: \"tok-strong\"\n    },\n    {\n        tag: tags.keyword,\n        class: \"tok-keyword\"\n    },\n    {\n        tag: tags.atom,\n        class: \"tok-atom\"\n    },\n    {\n        tag: tags.bool,\n        class: \"tok-bool\"\n    },\n    {\n        tag: tags.url,\n        class: \"tok-url\"\n    },\n    {\n        tag: tags.labelName,\n        class: \"tok-labelName\"\n    },\n    {\n        tag: tags.inserted,\n        class: \"tok-inserted\"\n    },\n    {\n        tag: tags.deleted,\n        class: \"tok-deleted\"\n    },\n    {\n        tag: tags.literal,\n        class: \"tok-literal\"\n    },\n    {\n        tag: tags.string,\n        class: \"tok-string\"\n    },\n    {\n        tag: tags.number,\n        class: \"tok-number\"\n    },\n    {\n        tag: [\n            tags.regexp,\n            tags.escape,\n            tags.special(tags.string)\n        ],\n        class: \"tok-string2\"\n    },\n    {\n        tag: tags.variableName,\n        class: \"tok-variableName\"\n    },\n    {\n        tag: tags.local(tags.variableName),\n        class: \"tok-variableName tok-local\"\n    },\n    {\n        tag: tags.definition(tags.variableName),\n        class: \"tok-variableName tok-definition\"\n    },\n    {\n        tag: tags.special(tags.variableName),\n        class: \"tok-variableName2\"\n    },\n    {\n        tag: tags.definition(tags.propertyName),\n        class: \"tok-propertyName tok-definition\"\n    },\n    {\n        tag: tags.typeName,\n        class: \"tok-typeName\"\n    },\n    {\n        tag: tags.namespace,\n        class: \"tok-namespace\"\n    },\n    {\n        tag: tags.className,\n        class: \"tok-className\"\n    },\n    {\n        tag: tags.macroName,\n        class: \"tok-macroName\"\n    },\n    {\n        tag: tags.propertyName,\n        class: \"tok-propertyName\"\n    },\n    {\n        tag: tags.operator,\n        class: \"tok-operator\"\n    },\n    {\n        tag: tags.comment,\n        class: \"tok-comment\"\n    },\n    {\n        tag: tags.meta,\n        class: \"tok-meta\"\n    },\n    {\n        tag: tags.invalid,\n        class: \"tok-invalid\"\n    },\n    {\n        tag: tags.punctuation,\n        class: \"tok-punctuation\"\n    }\n]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5QztBQUV6QyxJQUFJQyxZQUFZO0FBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0FDLFlBQ0E7OztJQUdBLEdBQ0FDLEdBQUcsRUFDSDs7O0lBR0EsR0FDQUMsSUFBSSxFQUNKOztJQUVBLEdBQ0FDLFFBQVEsQ0FBRTtRQUNOLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQjs7UUFFQSxHQUNBLElBQUksQ0FBQ0MsRUFBRSxHQUFHTjtJQUNkO0lBQ0E7Ozs7OztJQU1BLEdBQ0EsT0FBT08sT0FBT0MsTUFBTSxFQUFFO1FBQ2xCLElBQUlBLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPSixJQUFJLEVBQzNELE1BQU0sSUFBSUssTUFBTTtRQUNwQixJQUFJQyxNQUFNLElBQUlULElBQUksRUFBRSxFQUFFLE1BQU0sRUFBRTtRQUM5QlMsSUFBSVAsR0FBRyxDQUFDUSxJQUFJLENBQUNEO1FBQ2IsSUFBSUYsUUFDQSxLQUFLLElBQUlJLEtBQUtKLE9BQU9MLEdBQUcsQ0FDcEJPLElBQUlQLEdBQUcsQ0FBQ1EsSUFBSSxDQUFDQztRQUNyQixPQUFPRjtJQUNYO0lBQ0E7Ozs7Ozs7Ozs7O0lBV0EsR0FDQSxPQUFPRyxpQkFBaUI7UUFDcEIsSUFBSUMsTUFBTSxJQUFJQztRQUNkLE9BQU8sQ0FBQ0w7WUFDSixJQUFJQSxJQUFJTCxRQUFRLENBQUNXLE9BQU8sQ0FBQ0YsT0FBTyxDQUFDLEdBQzdCLE9BQU9KO1lBQ1gsT0FBT0ssU0FBU0UsR0FBRyxDQUFDUCxJQUFJTixJQUFJLElBQUlNLEtBQUtBLElBQUlMLFFBQVEsQ0FBQ2EsTUFBTSxDQUFDSixLQUFL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c3MtY21zLy4vbm9kZV9tb2R1bGVzL0BsZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcz9mMjlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbmxldCBuZXh0VGFnSUQgPSAwO1xuLyoqXG5IaWdobGlnaHRpbmcgdGFncyBhcmUgbWFya2VycyB0aGF0IGRlbm90ZSBhIGhpZ2hsaWdodGluZyBjYXRlZ29yeS5cblRoZXkgYXJlIFthc3NvY2lhdGVkXSgjaGlnaGxpZ2h0LnN0eWxlVGFncykgd2l0aCBwYXJ0cyBvZiBhIHN5bnRheFxudHJlZSBieSBhIGxhbmd1YWdlIG1vZGUsIGFuZCB0aGVuIG1hcHBlZCB0byBhbiBhY3R1YWwgQ1NTIHN0eWxlIGJ5XG5hIFtoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikuXG5cbkJlY2F1c2Ugc3ludGF4IHRyZWUgbm9kZSB0eXBlcyBhbmQgaGlnaGxpZ2h0IHN0eWxlcyBoYXZlIHRvIGJlXG5hYmxlIHRvIHRhbGsgdGhlIHNhbWUgbGFuZ3VhZ2UsIENvZGVNaXJyb3IgdXNlcyBhIG1vc3RseSBfY2xvc2VkX1xuW3ZvY2FidWxhcnldKCNoaWdobGlnaHQudGFncykgb2Ygc3ludGF4IHRhZ3MgKGFzIG9wcG9zZWQgdG9cbnRyYWRpdGlvbmFsIG9wZW4gc3RyaW5nLWJhc2VkIHN5c3RlbXMsIHdoaWNoIG1ha2UgaXQgaGFyZCBmb3JcbmhpZ2hsaWdodGluZyB0aGVtZXMgdG8gY292ZXIgYWxsIHRoZSB0b2tlbnMgcHJvZHVjZWQgYnkgdGhlXG52YXJpb3VzIGxhbmd1YWdlcykuXG5cbkl0IF9pc18gcG9zc2libGUgdG8gW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSB5b3VyIG93blxuaGlnaGxpZ2h0aW5nIHRhZ3MgZm9yIHN5c3RlbS1pbnRlcm5hbCB1c2UgKHdoZXJlIHlvdSBjb250cm9sIGJvdGhcbnRoZSBsYW5ndWFnZSBwYWNrYWdlIGFuZCB0aGUgaGlnaGxpZ2h0ZXIpLCBidXQgc3VjaCB0YWdzIHdpbGwgbm90XG5iZSBwaWNrZWQgdXAgYnkgcmVndWxhciBoaWdobGlnaHRlcnMgKHRob3VnaCB5b3UgY2FuIGRlcml2ZSB0aGVtXG5mcm9tIHN0YW5kYXJkIHRhZ3MgdG8gYWxsb3cgaGlnaGxpZ2h0ZXJzIHRvIGZhbGwgYmFjayB0byB0aG9zZSkuXG4qL1xuY2xhc3MgVGFnIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzZXQgb2YgdGhpcyB0YWcgYW5kIGFsbCBpdHMgcGFyZW50IHRhZ3MsIHN0YXJ0aW5nIHdpdGhcbiAgICB0aGlzIG9uZSBpdHNlbGYgYW5kIHNvcnRlZCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nIHNwZWNpZmljaXR5LlxuICAgICovXG4gICAgc2V0LCBcbiAgICAvKipcbiAgICBUaGUgYmFzZSB1bm1vZGlmaWVkIHRhZyB0aGF0IHRoaXMgb25lIGlzIGJhc2VkIG9uLCBpZiBpdCdzXG4gICAgbW9kaWZpZWQgQGludGVybmFsXG4gICAgKi9cbiAgICBiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgbW9kaWZpZXJzIGFwcGxpZWQgdG8gdGhpcy5iYXNlIEBpbnRlcm5hbFxuICAgICovXG4gICAgbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dFRhZ0lEKys7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyB0YWcuIElmIGBwYXJlbnRgIGlzIGdpdmVuLCB0aGUgdGFnIGlzIHRyZWF0ZWQgYXMgYVxuICAgIHN1Yi10YWcgb2YgdGhhdCBwYXJlbnQsIGFuZFxuICAgIFtoaWdobGlnaHRlcnNdKCNoaWdobGlnaHQudGFnSGlnaGxpZ2h0ZXIpIHRoYXQgZG9uJ3QgbWVudGlvblxuICAgIHRoaXMgdGFnIHdpbGwgdHJ5IHRvIGZhbGwgYmFjayB0byB0aGUgcGFyZW50IHRhZyAob3IgZ3JhbmRwYXJlbnRcbiAgICB0YWcsIGV0YykuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJhc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgICAgICBsZXQgdGFnID0gbmV3IFRhZyhbXSwgbnVsbCwgW10pO1xuICAgICAgICB0YWcuc2V0LnB1c2godGFnKTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIGZvciAobGV0IHQgb2YgcGFyZW50LnNldClcbiAgICAgICAgICAgICAgICB0YWcuc2V0LnB1c2godCk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHRhZyBfbW9kaWZpZXJfLCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgdGFnLFxuICAgIHdpbGwgcmV0dXJuIGEgdGFnIHRoYXQgaXMgYSBzdWJ0YWcgb2YgdGhlIG9yaWdpbmFsLiBBcHBseWluZyB0aGVcbiAgICBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gICAgPT0gbTEodDEpYCkgYW5kIGFwcGx5aW5nIG11bHRpcGxlIG1vZGlmaWVycyB3aWxsLCByZWdhcmRsZXNzIG9yXG4gICAgb3JkZXIsIHByb2R1Y2UgdGhlIHNhbWUgdGFnIChgbTEobTIodDEpKSA9PSBtMihtMSh0MSkpYCkuXG4gICAgXG4gICAgV2hlbiBtdWx0aXBsZSBtb2RpZmllcnMgYXJlIGFwcGxpZWQgdG8gYSBnaXZlbiBiYXNlIHRhZywgZWFjaFxuICAgIHNtYWxsZXIgc2V0IG9mIG1vZGlmaWVycyBpcyByZWdpc3RlcmVkIGFzIGEgcGFyZW50LCBzbyB0aGF0IGZvclxuICAgIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICAgIGBtMShtMyh0MSlgLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lTW9kaWZpZXIoKSB7XG4gICAgICAgIGxldCBtb2QgPSBuZXcgTW9kaWZpZXI7XG4gICAgICAgIHJldHVybiAodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnLm1vZGlmaWVkLmluZGV4T2YobW9kKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuZ2V0KHRhZy5iYXNlIHx8IHRhZywgdGFnLm1vZGlmaWVkLmNvbmNhdChtb2QpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IG5leHRNb2RpZmllcklEID0gMDtcbmNsYXNzIE1vZGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRNb2RpZmllcklEKys7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQoYmFzZSwgbW9kcykge1xuICAgICAgICBpZiAoIW1vZHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBleGlzdHMgPSBtb2RzWzBdLmluc3RhbmNlcy5maW5kKHQgPT4gdC5iYXNlID09IGJhc2UgJiYgc2FtZUFycmF5KG1vZHMsIHQubW9kaWZpZWQpKTtcbiAgICAgICAgaWYgKGV4aXN0cylcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgICAgIGxldCBzZXQgPSBbXSwgdGFnID0gbmV3IFRhZyhzZXQsIGJhc2UsIG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBtIG9mIG1vZHMpXG4gICAgICAgICAgICBtLmluc3RhbmNlcy5wdXNoKHRhZyk7XG4gICAgICAgIGxldCBjb25maWdzID0gcG93ZXJTZXQobW9kcyk7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCBvZiBiYXNlLnNldClcbiAgICAgICAgICAgIGlmICghcGFyZW50Lm1vZGlmaWVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goTW9kaWZpZXIuZ2V0KHBhcmVudCwgY29uZmlnKSk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoeCwgaSkgPT4geCA9PSBiW2ldKTtcbn1cbmZ1bmN0aW9uIHBvd2VyU2V0KGFycmF5KSB7XG4gICAgbGV0IHNldHMgPSBbW11dO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGUgPSBzZXRzLmxlbmd0aDsgaiA8IGU7IGorKykge1xuICAgICAgICAgICAgc2V0cy5wdXNoKHNldHNbal0uY29uY2F0KGFycmF5W2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG59XG4vKipcblRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxudmlhIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuTFJQYXJzZXIuY29uZmlndXJlKS5cblxuVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbnRhZ3NdKCNoaWdobGlnaHQuVGFnKSBvciBhcnJheXMgb2YgdGFncy5cblxuTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cblN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG5tdWx0aXBsZSBub2RlIG5hbWVzIChvciBgKmAgd2lsZGNhcmRzKSBzZXBhcmF0ZWQgYnkgc2xhc2hcbmNoYXJhY3RlcnMsIGFzIGluIGBcIkJsb2NrL0RlY2xhcmF0aW9uL1ZhcmlhYmxlTmFtZVwiYC4gU3VjaCBhIHBhdGhcbm1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxub3RoZXIgbm9kZXMgbWVudGlvbmVkLiBBIGAqYCBpbiBzdWNoIGEgcGF0aCBtYXRjaGVzIGFueSBwYXJlbnQsXG5idXQgb25seSBhIHNpbmdsZSBsZXZlbOKAlHdpbGRjYXJkcyB0aGF0IG1hdGNoIG11bHRpcGxlIHBhcmVudHNcbmFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxudHJlZXMgbWFrZSBpdCByYXRoZXIgaGFyZCB0byByZWFzb24gYWJvdXQgd2hhdCB0aGV5IHdvdWxkIG1hdGNoLilcblxuQSBwYXRoIGNhbiBiZSBlbmRlZCB3aXRoIGAvLi4uYCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YWcgYXNzaWduZWRcbnRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG5tYXRjaCB0aGVpciBvd24gc3R5bGUgKGJ5IGRlZmF1bHQsIG9ubHkgdGhlIGlubmVybW9zdCBzdHlsZSBpc1xudXNlZCkuXG5cbldoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbmhhcHBlbnMgZm9yIHRoZSBub2RlJ3MgY2hpbGQgbm9kZXMsIGFuZCB0aGUgZW50aXJlIG5vZGUgZ2V0cyB0aGVcbmdpdmVuIHN0eWxlLlxuXG5JbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxubXVzdCBiZSBxdW90ZWQgYXMgSlNPTiBzdHJpbmdzLlxuXG5Gb3IgZXhhbXBsZTpcblxuYGBgamF2YXNjcmlwdFxucGFyc2VyLndpdGhQcm9wcyhcbiAgc3R5bGVUYWdzKHtcbiAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuICAgIFwiTnVtYmVyIEJpZ051bWJlclwiOiB0YWdzLm51bWJlcixcbiAgICAvLyBTdHlsZSBFc2NhcGUgbm9kZXMgd2hvc2UgcGFyZW50IGlzIFN0cmluZ1xuICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbiAgICAvLyBTdHlsZSBhbnl0aGluZyBpbnNpZGUgQXR0cmlidXRlcyBub2Rlc1xuICAgIFwiQXR0cmlidXRlcyFcIjogdGFncy5tZXRhLFxuICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbiAgICBcIkl0YWxpYy8uLi5cIjogdGFncy5lbXBoYXNpcyxcbiAgICAvLyBTdHlsZSBJbnZhbGlkU3RyaW5nIG5vZGVzIGFzIGJvdGggYHN0cmluZ2AgYW5kIGBpbnZhbGlkYFxuICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4gICAgLy8gU3R5bGUgdGhlIG5vZGUgbmFtZWQgXCIvXCIgYXMgcHVuY3R1YXRpb25cbiAgICAnXCIvXCInOiB0YWdzLnB1bmN0dWF0aW9uXG4gIH0pXG4pXG5gYGBcbiovXG5mdW5jdGlvbiBzdHlsZVRhZ3Moc3BlYykge1xuICAgIGxldCBieU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdGFncyA9IHNwZWNbcHJvcF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZXMgPSBbXSwgbW9kZSA9IDIgLyogTW9kZS5Ob3JtYWwgKi8sIHJlc3QgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCA9PSBcIi4uLlwiICYmIHBvcyA+IDAgJiYgcG9zICsgMyA9PSBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDEgLyogTW9kZS5Jbmhlcml0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gXCJcIiA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydFtwb3MrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGggJiYgbmV4dCA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogTW9kZS5PcGFxdWUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFydC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IHBpZWNlcy5sZW5ndGggLSAxLCBpbm5lciA9IHBpZWNlc1tsYXN0XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IG5ldyBSdWxlKHRhZ3MsIG1vZGUsIGxhc3QgPiAwID8gcGllY2VzLnNsaWNlKDAsIGxhc3QpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgYnlOYW1lW2lubmVyXSA9IHJ1bGUuc29ydChieU5hbWVbaW5uZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVOb2RlUHJvcC5hZGQoYnlOYW1lKTtcbn1cbmNvbnN0IHJ1bGVOb2RlUHJvcCA9IG5ldyBOb2RlUHJvcCgpO1xuY2xhc3MgUnVsZSB7XG4gICAgY29uc3RydWN0b3IodGFncywgbW9kZSwgY29udGV4dCwgbmV4dCkge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbiAgICBnZXQgb3BhcXVlKCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDAgLyogTW9kZS5PcGFxdWUgKi87IH1cbiAgICBnZXQgaW5oZXJpdCgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLzsgfVxuICAgIHNvcnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlciB8fCBvdGhlci5kZXB0aCA8IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG90aGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIubmV4dCA9IHRoaXMuc29ydChvdGhlci5uZXh0KTtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQubGVuZ3RoIDogMDsgfVxufVxuUnVsZS5lbXB0eSA9IG5ldyBSdWxlKFtdLCAyIC8qIE1vZGUuTm9ybWFsICovLCBudWxsKTtcbi8qKlxuRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG50YWcvY2xhc3MgcGFpcnMuIENsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIG1vcmUgc3BlY2lmaWMgdGFncyB3aWxsXG50YWtlIHByZWNlZGVuY2UuXG4qL1xuZnVuY3Rpb24gdGFnSGlnaGxpZ2h0ZXIodGFncywgb3B0aW9ucykge1xuICAgIGxldCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHN0eWxlIG9mIHRhZ3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLnRhZykpXG4gICAgICAgICAgICBtYXBbc3R5bGUudGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2Ygc3R5bGUudGFnKVxuICAgICAgICAgICAgICAgIG1hcFt0YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgfVxuICAgIGxldCB7IHNjb3BlLCBhbGwgPSBudWxsIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiAodGFncykgPT4ge1xuICAgICAgICAgICAgbGV0IGNscyA9IGFsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHRhZy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZ0NsYXNzID0gbWFwW3N1Yi5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gY2xzID8gY2xzICsgXCIgXCIgKyB0YWdDbGFzcyA6IHRhZ0NsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9LFxuICAgICAgICBzY29wZVxuICAgIH07XG59XG5mdW5jdGlvbiBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgdGFncykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgdmFsdWUgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG5baGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLiBPZnRlbiwgdGhlIGhpZ2hlci1sZXZlbFxuW2BoaWdobGlnaHRDb2RlYF0oI2hpZ2hsaWdodC5oaWdobGlnaHRDb2RlKSBmdW5jdGlvbiBpcyBlYXNpZXIgdG9cbnVzZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCBcbi8qKlxuQXNzaWduIHN0eWxpbmcgdG8gYSByZWdpb24gb2YgdGhlIHRleHQuIFdpbGwgYmUgY2FsbGVkLCBpbiBvcmRlclxub2YgcG9zaXRpb24sIGZvciBhbnkgcmFuZ2VzIHdoZXJlIG1vcmUgdGhhbiB6ZXJvIGNsYXNzZXMgYXBwbHkuXG5gY2xhc3Nlc2AgaXMgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxuKi9cbnB1dFN0eWxlLCBcbi8qKlxuVGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0byBoaWdobGlnaHQuXG4qL1xuZnJvbSA9IDAsIFxuLyoqXG5UaGUgZW5kIG9mIHRoZSByYW5nZS5cbiovXG50byA9IHRyZWUubGVuZ3RoKSB7XG4gICAgbGV0IGJ1aWxkZXIgPSBuZXcgSGlnaGxpZ2h0QnVpbGRlcihmcm9tLCBBcnJheS5pc0FycmF5KGhpZ2hsaWdodGVyKSA/IGhpZ2hsaWdodGVyIDogW2hpZ2hsaWdodGVyXSwgcHV0U3R5bGUpO1xuICAgIGJ1aWxkZXIuaGlnaGxpZ2h0UmFuZ2UodHJlZS5jdXJzb3IoKSwgZnJvbSwgdG8sIFwiXCIsIGJ1aWxkZXIuaGlnaGxpZ2h0ZXJzKTtcbiAgICBidWlsZGVyLmZsdXNoKHRvKTtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiB0cmVlIHdpdGggdGhlIGdpdmVuIGhpZ2hsaWdodGVyLCBjYWxsaW5nXG5gcHV0VGV4dGAgZm9yIGV2ZXJ5IHBpZWNlIG9mIHRleHQsIGVpdGhlciB3aXRoIGEgc2V0IG9mIGNsYXNzZXMgb3JcbndpdGggdGhlIGVtcHR5IHN0cmluZyB3aGVuIHVuc3R5bGVkLCBhbmQgYHB1dEJyZWFrYCBmb3IgZXZlcnkgbGluZVxuYnJlYWsuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0Q29kZShjb2RlLCB0cmVlLCBoaWdobGlnaHRlciwgcHV0VGV4dCwgcHV0QnJlYWssIGZyb20gPSAwLCB0byA9IGNvZGUubGVuZ3RoKSB7XG4gICAgbGV0IHBvcyA9IGZyb207XG4gICAgZnVuY3Rpb24gd3JpdGVUbyhwLCBjbGFzc2VzKSB7XG4gICAgICAgIGlmIChwIDw9IHBvcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgdGV4dCA9IGNvZGUuc2xpY2UocG9zLCBwKSwgaSA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IHRleHQuaW5kZXhPZihcIlxcblwiLCBpKTtcbiAgICAgICAgICAgIGxldCB1cHRvID0gbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrO1xuICAgICAgICAgICAgaWYgKHVwdG8gPiBpKVxuICAgICAgICAgICAgICAgIHB1dFRleHQodGV4dC5zbGljZShpLCB1cHRvKSwgY2xhc3Nlcyk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHB1dEJyZWFrKCk7XG4gICAgICAgICAgICBpID0gbmV4dEJyZWFrICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBwO1xuICAgIH1cbiAgICBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCAoZnJvbSwgdG8sIGNsYXNzZXMpID0+IHtcbiAgICAgICAgd3JpdGVUbyhmcm9tLCBcIlwiKTtcbiAgICAgICAgd3JpdGVUbyh0bywgY2xhc3Nlcyk7XG4gICAgfSwgZnJvbSwgdG8pO1xuICAgIHdyaXRlVG8odG8sIFwiXCIpO1xufVxuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYXQsIGhpZ2hsaWdodGVycywgc3Bhbikge1xuICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXJzID0gaGlnaGxpZ2h0ZXJzO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLmNsYXNzID0gXCJcIjtcbiAgICB9XG4gICAgc3RhcnRTcGFuKGF0LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdCA+IHRoaXMuYXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCh0bykge1xuICAgICAgICBpZiAodG8gPiB0aGlzLmF0ICYmIHRoaXMuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLnNwYW4odGhpcy5hdCwgdG8sIHRoaXMuY2xhc3MpO1xuICAgIH1cbiAgICBoaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBoaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKHR5cGUpKTtcbiAgICAgICAgbGV0IGNscyA9IGluaGVyaXRlZENsYXNzO1xuICAgICAgICBsZXQgcnVsZSA9IGdldFN0eWxlVGFncyhjdXJzb3IpIHx8IFJ1bGUuZW1wdHk7XG4gICAgICAgIGxldCB0YWdDbHMgPSBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgcnVsZS50YWdzKTtcbiAgICAgICAgaWYgKHRhZ0Nscykge1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XG4gICAgICAgICAgICBjbHMgKz0gdGFnQ2xzO1xuICAgICAgICAgICAgaWYgKHJ1bGUubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLylcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyArPSAoaW5oZXJpdGVkQ2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgdGFnQ2xzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWF4KGZyb20sIHN0YXJ0KSwgY2xzKTtcbiAgICAgICAgaWYgKHJ1bGUub3BhcXVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbW91bnRlZCA9IGN1cnNvci50cmVlICYmIGN1cnNvci50cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gY3Vyc29yLm5vZGUuZW50ZXIobW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyBzdGFydCwgMSk7XG4gICAgICAgICAgICBsZXQgaW5uZXJIaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKG1vdW50ZWQudHJlZS50eXBlKSk7XG4gICAgICAgICAgICBsZXQgaGFzQ2hpbGQgPSBjdXJzb3IuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpIDwgbW91bnRlZC5vdmVybGF5Lmxlbmd0aCA/IG1vdW50ZWQub3ZlcmxheVtpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0ID8gbmV4dC5mcm9tICsgc3RhcnQgOiBlbmQ7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyksIHJhbmdlVG8gPSBNYXRoLm1pbih0bywgbmV4dFBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlRnJvbSA8IHJhbmdlVG8gJiYgaGFzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5mcm9tIDwgcmFuZ2VUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIHJhbmdlRnJvbSwgcmFuZ2VUbywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbihyYW5nZVRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBuZXh0UG9zIHx8ICFjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dFBvcyA+IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShpbm5lci5jdXJzb3IoKSwgTWF0aC5tYXgoZnJvbSwgbmV4dC5mcm9tICsgc3RhcnQpLCBNYXRoLm1pbih0bywgcG9zKSwgXCJcIiwgaW5uZXJIaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgcG9zKSwgY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ2hpbGQpXG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgIGlmIChtb3VudGVkKVxuICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzID0gXCJcIjtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvIDw9IGZyb20pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuTWF0Y2ggYSBzeW50YXggbm9kZSdzIFtoaWdobGlnaHQgcnVsZXNdKCNoaWdobGlnaHQuc3R5bGVUYWdzKS4gSWZcbnRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJuIGl0cyBzZXQgb2YgdGFncywgYW5kIHdoZXRoZXIgaXQgaXNcbm9wYXF1ZSAodXNlcyBhIGAhYCkgb3IgYXBwbGllcyB0byBhbGwgY2hpbGQgbm9kZXMgKGAvLi4uYCkuXG4qL1xuZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKG5vZGUpIHtcbiAgICBsZXQgcnVsZSA9IG5vZGUudHlwZS5wcm9wKHJ1bGVOb2RlUHJvcCk7XG4gICAgd2hpbGUgKHJ1bGUgJiYgcnVsZS5jb250ZXh0ICYmICFub2RlLm1hdGNoQ29udGV4dChydWxlLmNvbnRleHQpKVxuICAgICAgICBydWxlID0gcnVsZS5uZXh0O1xuICAgIHJldHVybiBydWxlIHx8IG51bGw7XG59XG5jb25zdCB0ID0gVGFnLmRlZmluZTtcbmNvbnN0IGNvbW1lbnQgPSB0KCksIG5hbWUgPSB0KCksIHR5cGVOYW1lID0gdChuYW1lKSwgcHJvcGVydHlOYW1lID0gdChuYW1lKSwgbGl0ZXJhbCA9IHQoKSwgc3RyaW5nID0gdChsaXRlcmFsKSwgbnVtYmVyID0gdChsaXRlcmFsKSwgY29udGVudCA9IHQoKSwgaGVhZGluZyA9IHQoY29udGVudCksIGtleXdvcmQgPSB0KCksIG9wZXJhdG9yID0gdCgpLCBwdW5jdHVhdGlvbiA9IHQoKSwgYnJhY2tldCA9IHQocHVuY3R1YXRpb24pLCBtZXRhID0gdCgpO1xuLyoqXG5UaGUgZGVmYXVsdCBzZXQgb2YgaGlnaGxpZ2h0aW5nIFt0YWdzXSgjaGlnaGxpZ2h0LlRhZykuXG5cblRoaXMgY29sbGVjdGlvbiBpcyBoZWF2aWx5IGJpYXNlZCB0b3dhcmRzIHByb2dyYW1taW5nIGxhbmd1YWdlcyxcbmFuZCBuZWNlc3NhcmlseSBpbmNvbXBsZXRlLiBBIGZ1bGwgb250b2xvZ3kgb2Ygc3ludGFjdGljXG5jb25zdHJ1Y3RzIHdvdWxkIGZpbGwgYSBzdGFjayBvZiBib29rcywgYW5kIGJlIGltcHJhY3RpY2FsIHRvXG53cml0ZSB0aGVtZXMgZm9yLiBTbyB0cnkgdG8gbWFrZSBkbyB3aXRoIHRoaXMgc2V0LiBJZiBhbGwgZWxzZVxuZmFpbHMsIFtvcGVuIGFuXG5pc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvY29kZW1pcnJvci5uZXh0KSB0byBwcm9wb3NlIGFcbm5ldyB0YWcsIG9yIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgYSBsb2NhbCBjdXN0b20gdGFnIGZvclxueW91ciB1c2UgY2FzZS5cblxuTm90ZSB0aGF0IGl0IGlzIG5vdCBvYmxpZ2F0b3J5IHRvIGFsd2F5cyBhdHRhY2ggdGhlIG1vc3Qgc3BlY2lmaWNcbnRhZyBwb3NzaWJsZSB0byBhbiBlbGVtZW504oCUaWYgeW91ciBncmFtbWFyIGNhbid0IGVhc2lseVxuZGlzdGluZ3Vpc2ggYSBjZXJ0YWluIHR5cGUgb2YgZWxlbWVudCAoc3VjaCBhcyBhIGxvY2FsIHZhcmlhYmxlKSxcbml0IGlzIG9rYXkgdG8gc3R5bGUgaXQgYXMgaXRzIG1vcmUgZ2VuZXJhbCB2YXJpYW50IChhIHZhcmlhYmxlKS5cblxuRm9yIHRhZ3MgdGhhdCBleHRlbmQgc29tZSBwYXJlbnQgdGFnLCB0aGUgZG9jdW1lbnRhdGlvbiBsaW5rcyB0b1xudGhlIHBhcmVudC5cbiovXG5jb25zdCB0YWdzID0ge1xuICAgIC8qKlxuICAgIEEgY29tbWVudC5cbiAgICAqL1xuICAgIGNvbW1lbnQsXG4gICAgLyoqXG4gICAgQSBsaW5lIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBsaW5lQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGJsb2NrIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBibG9ja0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBkb2NDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEFueSBraW5kIG9mIGlkZW50aWZpZXIuXG4gICAgKi9cbiAgICBuYW1lLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgdmFyaWFibGUuXG4gICAgKi9cbiAgICB2YXJpYWJsZU5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSB0eXBlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgLyoqXG4gICAgQSB0YWcgbmFtZSAoc3VidGFnIG9mIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpKS5cbiAgICAqL1xuICAgIHRhZ05hbWU6IHQodHlwZU5hbWUpLFxuICAgIC8qKlxuICAgIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSBuYW1lIChzdWJ0YWcgb2YgW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSkuXG4gICAgKi9cbiAgICBhdHRyaWJ1dGVOYW1lOiB0KHByb3BlcnR5TmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBjbGFzcy5cbiAgICAqL1xuICAgIGNsYXNzTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxhYmVsIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBsYWJlbE5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBuYW1lc3BhY2UgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIG5hbWVzcGFjZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIG1hY3JvLlxuICAgICovXG4gICAgbWFjcm9OYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbGl0ZXJhbCB2YWx1ZS5cbiAgICAqL1xuICAgIGxpdGVyYWwsXG4gICAgLyoqXG4gICAgQSBzdHJpbmcgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHN0cmluZyxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykuXG4gICAgKi9cbiAgICBkb2NTdHJpbmc6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIGNoYXJhY3RlciBsaXRlcmFsIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgY2hhcmFjdGVyOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQW4gYXR0cmlidXRlIHZhbHVlIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgYXR0cmlidXRlVmFsdWU6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIG51bWJlciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgbnVtYmVyLFxuICAgIC8qKlxuICAgIEFuIGludGVnZXIgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICAqL1xuICAgIGludGVnZXI6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGZsb2F0aW5nLXBvaW50IFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBmbG9hdDogdChudW1iZXIpLFxuICAgIC8qKlxuICAgIEEgYm9vbGVhbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgYm9vbDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHJlZ2V4cDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBbiBlc2NhcGUgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKSwgZm9yIGV4YW1wbGUgYVxuICAgIGJhY2tzbGFzaCBlc2NhcGUgaW4gYSBzdHJpbmcuXG4gICAgKi9cbiAgICBlc2NhcGU6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBjb2xvciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgY29sb3I6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBVUkwgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHVybDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAgKi9cbiAgICBrZXl3b3JkLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciB0aGUgc2VsZiBvciB0aGlzXG4gICAgb2JqZWN0LlxuICAgICovXG4gICAgc2VsZjogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgbnVsbC5cbiAgICAqL1xuICAgIG51bGw6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGRlbm90aW5nIHNvbWUgYXRvbWljIHZhbHVlLlxuICAgICovXG4gICAgYXRvbTogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCByZXByZXNlbnRzIGEgdW5pdC5cbiAgICAqL1xuICAgIHVuaXQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBtb2RpZmllciBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgbW9kaWZpZXI6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgYWN0cyBhcyBhbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgKi9cbiAgICBjb250cm9sS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25LZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSByZWxhdGVkIHRvIGRlZmluaW5nIG9yXG4gICAgaW50ZXJmYWNpbmcgd2l0aCBtb2R1bGVzLlxuICAgICovXG4gICAgbW9kdWxlS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yLFxuICAgIC8qKlxuICAgIEFuIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlcmVmZXJlbmNlcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZXJlZk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBBcml0aG1ldGljLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYXJpdGhtZXRpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBMb2dpY2FsIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGxvZ2ljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIEJpdCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBiaXR3aXNlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbXBhcmlzb24gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29tcGFyZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCB1cGRhdGVzIGl0cyBvcGVyYW5kLlxuICAgICovXG4gICAgdXBkYXRlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVmaW5pdGlvbk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBUeXBlLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgdHlwZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb250cm9sLWZsb3cgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29udHJvbE9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBQcm9ncmFtIG9yIG1hcmt1cCBwdW5jdHVhdGlvbi5cbiAgICAqL1xuICAgIHB1bmN0dWF0aW9uLFxuICAgIC8qKlxuICAgIFtQdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKSB0aGF0IHNlcGFyYXRlc1xuICAgIHRoaW5ncy5cbiAgICAqL1xuICAgIHNlcGFyYXRvcjogdChwdW5jdHVhdGlvbiksXG4gICAgLyoqXG4gICAgQnJhY2tldC1zdHlsZSBbcHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikuXG4gICAgKi9cbiAgICBicmFja2V0LFxuICAgIC8qKlxuICAgIEFuZ2xlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGA8YCBhbmQgYD5gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIGFuZ2xlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBTcXVhcmUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYFtgIGFuZCBgXWBcbiAgICB0b2tlbnMpLlxuICAgICovXG4gICAgc3F1YXJlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBQYXJlbnRoZXNlcyAodXN1YWxseSBgKGAgYW5kIGApYCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgcGFyZW46IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQnJhY2VzICh1c3VhbGx5IGB7YCBhbmQgYH1gIHRva2VucykuIFN1YnRhZyBvZlxuICAgIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgKi9cbiAgICBicmFjZTogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBDb250ZW50LCBmb3IgZXhhbXBsZSBwbGFpbiB0ZXh0IGluIFhNTCBvciBtYXJrdXAgZG9jdW1lbnRzLlxuICAgICovXG4gICAgY29udGVudCxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGhlYWRpbmcuXG4gICAgKi9cbiAgICBoZWFkaW5nLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzE6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAyIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDMgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmczOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNCBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzQ6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA1IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNTogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDYgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc2OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgcHJvc2Ugc2VwYXJhdG9yIChzdWNoIGFzIGEgaG9yaXpvbnRhbCBydWxlKS5cbiAgICAqL1xuICAgIGNvbnRlbnRTZXBhcmF0b3I6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBsaXN0LlxuICAgICovXG4gICAgbGlzdDogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIHF1b3RlLlxuICAgICovXG4gICAgcXVvdGU6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIGVtcGhhc2l6ZWQuXG4gICAgKi9cbiAgICBlbXBoYXNpczogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIHN0cm9uZy5cbiAgICAqL1xuICAgIHN0cm9uZzogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgcGFydCBvZiBhIGxpbmsuXG4gICAgKi9cbiAgICBsaW5rOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgYXMgY29kZSBvclxuICAgIG1vbm9zcGFjZS5cbiAgICAqL1xuICAgIG1vbm9zcGFjZTogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaGFzIGEgc3RyaWtlLXRocm91Z2hcbiAgICBzdHlsZS5cbiAgICAqL1xuICAgIHN0cmlrZXRocm91Z2g6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgSW5zZXJ0ZWQgdGV4dCBpbiBhIGNoYW5nZS10cmFja2luZyBmb3JtYXQuXG4gICAgKi9cbiAgICBpbnNlcnRlZDogdCgpLFxuICAgIC8qKlxuICAgIERlbGV0ZWQgdGV4dC5cbiAgICAqL1xuICAgIGRlbGV0ZWQ6IHQoKSxcbiAgICAvKipcbiAgICBDaGFuZ2VkIHRleHQuXG4gICAgKi9cbiAgICBjaGFuZ2VkOiB0KCksXG4gICAgLyoqXG4gICAgQW4gaW52YWxpZCBvciB1bnN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgaW52YWxpZDogdCgpLFxuICAgIC8qKlxuICAgIE1ldGFkYXRhIG9yIG1ldGEtaW5zdHJ1Y3Rpb24uXG4gICAgKi9cbiAgICBtZXRhLFxuICAgIC8qKlxuICAgIFtNZXRhZGF0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpIHRoYXQgYXBwbGllcyB0byB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2N1bWVudE1ldGE6IHQobWV0YSksXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhbm5vdGF0ZXMgb3IgYWRkc1xuICAgIGF0dHJpYnV0ZXMgdG8gYSBnaXZlbiBzeW50YWN0aWMgZWxlbWVudC5cbiAgICAqL1xuICAgIGFubm90YXRpb246IHQobWV0YSksXG4gICAgLyoqXG4gICAgUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgICBbbWV0YV0oI2hpZ2hsaWdodC50YWdzLm1ldGEpLlxuICAgICovXG4gICAgcHJvY2Vzc2luZ0luc3RydWN0aW9uOiB0KG1ldGEpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXQgYVxuICAgIGdpdmVuIGVsZW1lbnQgaXMgYmVpbmcgZGVmaW5lZC4gRXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoIHRoZVxuICAgIHZhcmlvdXMgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0YWdzLlxuICAgICovXG4gICAgZGVmaW5pdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdFxuICAgIHNvbWV0aGluZyBpcyBjb25zdGFudC4gTW9zdGx5IGV4cGVjdGVkIHRvIGJlIHVzZWQgd2l0aFxuICAgIFt2YXJpYWJsZSBuYW1lc10oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkuXG4gICAgKi9cbiAgICBjb25zdGFudDogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdXNlZCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgYSBbdmFyaWFibGVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIG9yIFtwcm9wZXJ0eVxuICAgIG5hbWVdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpIGlzIGJlaW5nIGNhbGxlZCBvciBkZWZpbmVkXG4gICAgYXMgYSBmdW5jdGlvbi5cbiAgICAqL1xuICAgIGZ1bmN0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdG8gaW5kaWNhdGUgdGhhdCB0aGV5IGJlbG9uZyB0b1xuICAgIHRoZSBsYW5ndWFnZSdzIHN0YW5kYXJkIGVudmlyb25tZW50LlxuICAgICovXG4gICAgc3RhbmRhcmQ6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIGEgZ2l2ZW5cbiAgICBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSBpcyBsb2NhbCB0byBzb21lIHNjb3BlLlxuICAgICovXG4gICAgbG9jYWw6IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIEEgZ2VuZXJpYyB2YXJpYW50IFttb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXRcbiAgICBjYW4gYmUgdXNlZCB0byB0YWcgbGFuZ3VhZ2Utc3BlY2lmaWMgYWx0ZXJuYXRpdmUgdmFyaWFudHMgb2ZcbiAgICBzb21lIGNvbW1vbiB0YWcuIEl0IGlzIHJlY29tbWVuZGVkIGZvciB0aGVtZXMgdG8gZGVmaW5lIHNwZWNpYWxcbiAgICBmb3JtcyBvZiBhdCBsZWFzdCB0aGUgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykgYW5kXG4gICAgW3ZhcmlhYmxlIG5hbWVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIHRhZ3MsIHNpbmNlIHRob3NlXG4gICAgY29tZSB1cCBhIGxvdC5cbiAgICAqL1xuICAgIHNwZWNpYWw6IFRhZy5kZWZpbmVNb2RpZmllcigpXG59O1xuLyoqXG5UaGlzIGlzIGEgaGlnaGxpZ2h0ZXIgdGhhdCBhZGRzIHN0YWJsZSwgcHJlZGljdGFibGUgY2xhc3NlcyB0b1xudG9rZW5zLCBmb3Igc3R5bGluZyB3aXRoIGV4dGVybmFsIENTUy5cblxuVGhlIGZvbGxvd2luZyB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcInRvay1cImBcbihmb3IgZXhhbXBsZSBgXCJ0b2stY29tbWVudFwiYCk6XG5cbiogW2BsaW5rYF0oI2hpZ2hsaWdodC50YWdzLmxpbmspXG4qIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxuKiBbYGVtcGhhc2lzYF0oI2hpZ2hsaWdodC50YWdzLmVtcGhhc2lzKVxuKiBbYHN0cm9uZ2BdKCNoaWdobGlnaHQudGFncy5zdHJvbmcpXG4qIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxuKiBbYGF0b21gXSgjaGlnaGxpZ2h0LnRhZ3MuYXRvbSlcbiogW2Bib29sYF0oI2hpZ2hsaWdodC50YWdzLmJvb2wpXG4qIFtgdXJsYF0oI2hpZ2hsaWdodC50YWdzLnVybClcbiogW2BsYWJlbE5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lKVxuKiBbYGluc2VydGVkYF0oI2hpZ2hsaWdodC50YWdzLmluc2VydGVkKVxuKiBbYGRlbGV0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZClcbiogW2BsaXRlcmFsYF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpXG4qIFtgc3RyaW5nYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbiogW2BudW1iZXJgXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKVxuKiBbYHZhcmlhYmxlTmFtZWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4qIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpXG4qIFtgbmFtZXNwYWNlYF0oI2hpZ2hsaWdodC50YWdzLm5hbWVzcGFjZSlcbiogW2BjbGFzc05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MuY2xhc3NOYW1lKVxuKiBbYG1hY3JvTmFtZWBdKCNoaWdobGlnaHQudGFncy5tYWNyb05hbWUpXG4qIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiogW2BvcGVyYXRvcmBdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcilcbiogW2Bjb21tZW50YF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpXG4qIFtgbWV0YWBdKCNoaWdobGlnaHQudGFncy5tZXRhKVxuKiBbYHB1bmN0dWF0aW9uYF0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKVxuKiBbYGludmFsaWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW52YWxpZClcblxuSW4gYWRkaXRpb24sIHRoZXNlIG1hcHBpbmdzIGFyZSBwcm92aWRlZDpcblxuKiBbYHJlZ2V4cGBdKCNoaWdobGlnaHQudGFncy5yZWdleHApLFxuICBbYGVzY2FwZWBdKCNoaWdobGlnaHQudGFncy5lc2NhcGUpLCBhbmRcbiAgW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2Aoc3RyaW5nKWBdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4gIGFyZSBtYXBwZWQgdG8gYFwidG9rLXN0cmluZzJcImBcbiogW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUyXCJgXG4qIFtgbG9jYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubG9jYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHByb3BlcnR5TmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuICB0byBgXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qL1xuY29uc3QgY2xhc3NIaWdobGlnaHRlciA9IHRhZ0hpZ2hsaWdodGVyKFtcbiAgICB7IHRhZzogdGFncy5saW5rLCBjbGFzczogXCJ0b2stbGlua1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZywgY2xhc3M6IFwidG9rLWhlYWRpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLCBjbGFzczogXCJ0b2stZW1waGFzaXNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZywgY2xhc3M6IFwidG9rLXN0cm9uZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCwgY2xhc3M6IFwidG9rLWtleXdvcmRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmF0b20sIGNsYXNzOiBcInRvay1hdG9tXCIgfSxcbiAgICB7IHRhZzogdGFncy5ib29sLCBjbGFzczogXCJ0b2stYm9vbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudXJsLCBjbGFzczogXCJ0b2stdXJsXCIgfSxcbiAgICB7IHRhZzogdGFncy5sYWJlbE5hbWUsIGNsYXNzOiBcInRvay1sYWJlbE5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmluc2VydGVkLCBjbGFzczogXCJ0b2staW5zZXJ0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlbGV0ZWQsIGNsYXNzOiBcInRvay1kZWxldGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5saXRlcmFsLCBjbGFzczogXCJ0b2stbGl0ZXJhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaW5nLCBjbGFzczogXCJ0b2stc3RyaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5udW1iZXIsIGNsYXNzOiBcInRvay1udW1iZXJcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSwgY2xhc3M6IFwidG9rLXN0cmluZzJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnZhcmlhYmxlTmFtZSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnR5cGVOYW1lLCBjbGFzczogXCJ0b2stdHlwZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm5hbWVzcGFjZSwgY2xhc3M6IFwidG9rLW5hbWVzcGFjZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLCBjbGFzczogXCJ0b2stY2xhc3NOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5tYWNyb05hbWUsIGNsYXNzOiBcInRvay1tYWNyb05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnByb3BlcnR5TmFtZSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mub3BlcmF0b3IsIGNsYXNzOiBcInRvay1vcGVyYXRvclwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCwgY2xhc3M6IFwidG9rLWNvbW1lbnRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1ldGEsIGNsYXNzOiBcInRvay1tZXRhXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLCBjbGFzczogXCJ0b2staW52YWxpZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHVuY3R1YXRpb24sIGNsYXNzOiBcInRvay1wdW5jdHVhdGlvblwiIH1cbl0pO1xuXG5leHBvcnQgeyBUYWcsIGNsYXNzSGlnaGxpZ2h0ZXIsIGdldFN0eWxlVGFncywgaGlnaGxpZ2h0Q29kZSwgaGlnaGxpZ2h0VHJlZSwgc3R5bGVUYWdzLCB0YWdIaWdobGlnaHRlciwgdGFncyB9O1xuIl0sIm5hbWVzIjpbIk5vZGVQcm9wIiwibmV4dFRhZ0lEIiwiVGFnIiwiY29uc3RydWN0b3IiLCJzZXQiLCJiYXNlIiwibW9kaWZpZWQiLCJpZCIsImRlZmluZSIsInBhcmVudCIsIkVycm9yIiwidGFnIiwicHVzaCIsInQiLCJkZWZpbmVNb2RpZmllciIsIm1vZCIsIk1vZGlmaWVyIiwiaW5kZXhPZiIsImdldCIsImNvbmNhdCIsInNvcnQiLCJhIiwiYiIsIm5leHRNb2RpZmllcklEIiwiaW5zdGFuY2VzIiwibW9kcyIsImxlbmd0aCIsImV4aXN0cyIsImZpbmQiLCJzYW1lQXJyYXkiLCJtIiwiY29uZmlncyIsInBvd2VyU2V0IiwiY29uZmlnIiwiZXZlcnkiLCJ4IiwiaSIsImFycmF5Iiwic2V0cyIsImoiLCJlIiwic3R5bGVUYWdzIiwic3BlYyIsImJ5TmFtZSIsIk9iamVjdCIsImNyZWF0ZSIsInByb3AiLCJ0YWdzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFydCIsInNwbGl0IiwicGllY2VzIiwibW9kZSIsInJlc3QiLCJwb3MiLCJleGVjIiwiUmFuZ2VFcnJvciIsIkpTT04iLCJwYXJzZSIsIm5leHQiLCJzbGljZSIsImxhc3QiLCJpbm5lciIsInJ1bGUiLCJSdWxlIiwicnVsZU5vZGVQcm9wIiwiYWRkIiwiY29udGV4dCIsIm9wYXF1ZSIsImluaGVyaXQiLCJvdGhlciIsImRlcHRoIiwiZW1wdHkiLCJ0YWdIaWdobGlnaHRlciIsIm9wdGlvbnMiLCJtYXAiLCJzdHlsZSIsImNsYXNzIiwic2NvcGUiLCJhbGwiLCJjbHMiLCJzdWIiLCJ0YWdDbGFzcyIsImhpZ2hsaWdodFRhZ3MiLCJoaWdobGlnaHRlcnMiLCJyZXN1bHQiLCJoaWdobGlnaHRlciIsInZhbHVlIiwiaGlnaGxpZ2h0VHJlZSIsInRyZWUiLCJwdXRTdHlsZSIsImZyb20iLCJ0byIsImJ1aWxkZXIiLCJIaWdobGlnaHRCdWlsZGVyIiwiaGlnaGxpZ2h0UmFuZ2UiLCJjdXJzb3IiLCJmbHVzaCIsImhpZ2hsaWdodENvZGUiLCJjb2RlIiwicHV0VGV4dCIsInB1dEJyZWFrIiwid3JpdGVUbyIsInAiLCJjbGFzc2VzIiwidGV4dCIsIm5leHRCcmVhayIsInVwdG8iLCJhdCIsInNwYW4iLCJzdGFydFNwYW4iLCJpbmhlcml0ZWRDbGFzcyIsInR5cGUiLCJzdGFydCIsImVuZCIsImlzVG9wIiwiZmlsdGVyIiwiaCIsImdldFN0eWxlVGFncyIsInRhZ0NscyIsIk1hdGgiLCJtYXgiLCJtb3VudGVkIiwib3ZlcmxheSIsIm5vZGUiLCJlbnRlciIsImlubmVySGlnaGxpZ2h0ZXJzIiwiaGFzQ2hpbGQiLCJmaXJzdENoaWxkIiwibmV4dFBvcyIsInJhbmdlRnJvbSIsInJhbmdlVG8iLCJtaW4iLCJuZXh0U2libGluZyIsIm1hdGNoQ29udGV4dCIsImNvbW1lbnQiLCJuYW1lIiwidHlwZU5hbWUiLCJwcm9wZXJ0eU5hbWUiLCJsaXRlcmFsIiwic3RyaW5nIiwibnVtYmVyIiwiY29udGVudCIsImhlYWRpbmciLCJrZXl3b3JkIiwib3BlcmF0b3IiLCJwdW5jdHVhdGlvbiIsImJyYWNrZXQiLCJtZXRhIiwibGluZUNvbW1lbnQiLCJibG9ja0NvbW1lbnQiLCJkb2NDb21tZW50IiwidmFyaWFibGVOYW1lIiwidGFnTmFtZSIsImF0dHJpYnV0ZU5hbWUiLCJjbGFzc05hbWUiLCJsYWJlbE5hbWUiLCJuYW1lc3BhY2UiLCJtYWNyb05hbWUiLCJkb2NTdHJpbmciLCJjaGFyYWN0ZXIiLCJhdHRyaWJ1dGVWYWx1ZSIsImludGVnZXIiLCJmbG9hdCIsImJvb2wiLCJyZWdleHAiLCJlc2NhcGUiLCJjb2xvciIsInVybCIsInNlbGYiLCJudWxsIiwiYXRvbSIsInVuaXQiLCJtb2RpZmllciIsIm9wZXJhdG9yS2V5d29yZCIsImNvbnRyb2xLZXl3b3JkIiwiZGVmaW5pdGlvbktleXdvcmQiLCJtb2R1bGVLZXl3b3JkIiwiZGVyZWZPcGVyYXRvciIsImFyaXRobWV0aWNPcGVyYXRvciIsImxvZ2ljT3BlcmF0b3IiLCJiaXR3aXNlT3BlcmF0b3IiLCJjb21wYXJlT3BlcmF0b3IiLCJ1cGRhdGVPcGVyYXRvciIsImRlZmluaXRpb25PcGVyYXRvciIsInR5cGVPcGVyYXRvciIsImNvbnRyb2xPcGVyYXRvciIsInNlcGFyYXRvciIsImFuZ2xlQnJhY2tldCIsInNxdWFyZUJyYWNrZXQiLCJwYXJlbiIsImJyYWNlIiwiaGVhZGluZzEiLCJoZWFkaW5nMiIsImhlYWRpbmczIiwiaGVhZGluZzQiLCJoZWFkaW5nNSIsImhlYWRpbmc2IiwiY29udGVudFNlcGFyYXRvciIsImxpc3QiLCJxdW90ZSIsImVtcGhhc2lzIiwic3Ryb25nIiwibGluayIsIm1vbm9zcGFjZSIsInN0cmlrZXRocm91Z2giLCJpbnNlcnRlZCIsImRlbGV0ZWQiLCJjaGFuZ2VkIiwiaW52YWxpZCIsImRvY3VtZW50TWV0YSIsImFubm90YXRpb24iLCJwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24iLCJkZWZpbml0aW9uIiwiY29uc3RhbnQiLCJmdW5jdGlvbiIsInN0YW5kYXJkIiwibG9jYWwiLCJzcGVjaWFsIiwiY2xhc3NIaWdobGlnaHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/highlight/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/javascript/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@lezer/javascript/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_lr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/lr */ \"(ssr)/./node_modules/@lezer/lr/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst noSemi = 309, incdec = 1, incdecPrefix = 2, JSXStartTag = 3, insertSemi = 310, spaces = 312, newline = 313, LineComment = 4, BlockComment = 5, Dialect_jsx = 0;\n/* Hand-written tokenizers for JavaScript tokens that can't be\n   expressed by lezer's built-in tokenizer. */ const space = [\n    9,\n    10,\n    11,\n    12,\n    13,\n    32,\n    133,\n    160,\n    5760,\n    8192,\n    8193,\n    8194,\n    8195,\n    8196,\n    8197,\n    8198,\n    8199,\n    8200,\n    8201,\n    8202,\n    8232,\n    8233,\n    8239,\n    8287,\n    12288\n];\nconst braceR = 125, semicolon = 59, slash = 47, star = 42, plus = 43, minus = 45, lt = 60, comma = 44;\nconst trackNewline = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ContextTracker({\n    start: false,\n    shift (context, term) {\n        return term == LineComment || term == BlockComment || term == spaces ? context : term == newline;\n    },\n    strict: false\n});\nconst insertSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    let { next } = input;\n    if (next == braceR || next == -1 || stack.context) input.acceptToken(insertSemi);\n}, {\n    contextual: true,\n    fallback: true\n});\nconst noSemicolon = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    let { next } = input, after;\n    if (space.indexOf(next) > -1) return;\n    if (next == slash && ((after = input.peek(1)) == slash || after == star)) return;\n    if (next != braceR && next != semicolon && next != -1 && !stack.context) input.acceptToken(noSemi);\n}, {\n    contextual: true\n});\nconst incdecToken = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    let { next } = input;\n    if (next == plus || next == minus) {\n        input.advance();\n        if (next == input.next) {\n            input.advance();\n            let mayPostfix = !stack.context && stack.canShift(incdec);\n            input.acceptToken(mayPostfix ? incdec : incdecPrefix);\n        }\n    }\n}, {\n    contextual: true\n});\nfunction identifierChar(ch, start) {\n    return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 || !start && ch >= 48 && ch <= 57;\n}\nconst jsx = new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.ExternalTokenizer((input, stack)=>{\n    if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return;\n    input.advance();\n    if (input.next == slash) return;\n    // Scan for an identifier followed by a comma or 'extends', don't\n    // treat this as a start tag if present.\n    let back = 0;\n    while(space.indexOf(input.next) > -1){\n        input.advance();\n        back++;\n    }\n    if (identifierChar(input.next, true)) {\n        input.advance();\n        back++;\n        while(identifierChar(input.next, false)){\n            input.advance();\n            back++;\n        }\n        while(space.indexOf(input.next) > -1){\n            input.advance();\n            back++;\n        }\n        if (input.next == comma) return;\n        for(let i = 0;; i++){\n            if (i == 7) {\n                if (!identifierChar(input.next, true)) return;\n                break;\n            }\n            if (input.next != \"extends\".charCodeAt(i)) break;\n            input.advance();\n            back++;\n        }\n    }\n    input.acceptToken(JSXStartTag, -back);\n});\nconst jsHighlight = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n    \"get set async static\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n    \"for while do if else switch try catch finally return throw break continue default case\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.controlKeyword,\n    \"in of await yield void typeof delete instanceof\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n    \"let var const using function class extends\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n    \"import export from\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.moduleKeyword,\n    \"with debugger as new\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n    TemplateString: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string),\n    super: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n    BooleanLiteral: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n    this: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.self,\n    null: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.null,\n    Star: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n    VariableName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName,\n    \"CallExpression/VariableName TaggedTemplateExpression/VariableName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n    VariableDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n    Label: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n    PropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName,\n    PrivatePropertyName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n    \"CallExpression/MemberExpression/PropertyName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n    \"FunctionDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName)),\n    \"ClassDeclaration/VariableDefinition\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className),\n    PropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n    PrivatePropertyDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName)),\n    UpdateOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.updateOperator,\n    \"LineComment Hashbang\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.lineComment,\n    BlockComment: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.blockComment,\n    Number: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.number,\n    String: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n    Escape: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n    ArithOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.arithmeticOperator,\n    LogicOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.logicOperator,\n    BitOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bitwiseOperator,\n    CompareOp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.compareOperator,\n    RegExp: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n    Equals: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionOperator,\n    Arrow: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation),\n    \": Spread\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.punctuation,\n    \"( )\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.paren,\n    \"[ ]\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.squareBracket,\n    \"{ }\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace,\n    \"InterpolationStart InterpolationEnd\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.brace),\n    \".\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.derefOperator,\n    \", ;\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.separator,\n    \"@\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n    TypeName: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n    TypeDefinition: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName),\n    \"type enum interface implements namespace module declare\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definitionKeyword,\n    \"abstract global Privacy readonly override\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.modifier,\n    \"is keyof unique infer\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.operatorKeyword,\n    JSXAttributeValue: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeValue,\n    JSXText: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content,\n    \"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.angleBracket,\n    \"JSXIdentifier JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName,\n    \"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.attributeName,\n    \"JSXBuiltin/JSXIdentifier\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.tagName)\n});\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst spec_identifier = {\n    __proto__: null,\n    export: 18,\n    as: 23,\n    from: 31,\n    default: 34,\n    async: 39,\n    function: 40,\n    extends: 52,\n    this: 56,\n    true: 64,\n    false: 64,\n    null: 76,\n    void: 80,\n    typeof: 84,\n    super: 102,\n    new: 136,\n    delete: 152,\n    yield: 161,\n    await: 165,\n    class: 170,\n    public: 227,\n    private: 227,\n    protected: 227,\n    readonly: 229,\n    instanceof: 248,\n    satisfies: 251,\n    in: 252,\n    const: 254,\n    import: 286,\n    keyof: 339,\n    unique: 343,\n    infer: 349,\n    is: 385,\n    abstract: 405,\n    implements: 407,\n    type: 409,\n    let: 412,\n    var: 414,\n    using: 417,\n    interface: 423,\n    enum: 427,\n    namespace: 433,\n    module: 435,\n    declare: 439,\n    global: 443,\n    for: 462,\n    of: 471,\n    while: 474,\n    with: 478,\n    do: 482,\n    if: 486,\n    else: 488,\n    switch: 492,\n    case: 498,\n    try: 504,\n    catch: 508,\n    finally: 512,\n    return: 516,\n    throw: 520,\n    break: 524,\n    continue: 528,\n    debugger: 532\n};\nconst spec_word = {\n    __proto__: null,\n    async: 123,\n    get: 125,\n    set: 127,\n    declare: 187,\n    public: 189,\n    private: 189,\n    protected: 189,\n    static: 191,\n    abstract: 193,\n    override: 195,\n    readonly: 201,\n    accessor: 203,\n    new: 389\n};\nconst spec_LessThan = {\n    __proto__: null,\n    \"<\": 143\n};\nconst parser = _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LRParser.deserialize({\n    version: 14,\n    states: \"$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>jQ08SO1G0{O#>wQ08SO1G0{O#@uQ08SO1G0{O#CuQ(CYO'#ChO#EsQ(CYO1G1^O#EzQ(CYO'#JjO!,lQWO1G1dO#F[Q08SO,5?TOOQ07`-E<g-E<gO#GOQ08SO1G0{OOQ07b1G0{1G0{O#IZQ08SO1G1aO#I}Q&jO,5<TO#JVQ&jO,5<UO#J_Q&jO'#FlO#JvQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#J{Q&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#K^Q(CYO'#JiO#KhQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KmQ`O'#J}OOQ07b,5<a,5<aO#KuQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KzO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LVQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LuQ7[O,5=RO!(SQ7[O'#IpO#MhQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MrQpO'#CqO#NVQpO,5<nO#N^QWO'#KRO9aQWO'#KRO#NlQWO,5<pO!(SQ7[O,5<oO#NqQWO'#GUO#N|QWO,5<oO$ RQpO'#GRO$ `QpO'#KSO$ jQWO'#KSO!&dQ7[O'#KSO$ oQWO,5<sO$ tQ`O'#G^O!4eQ`O'#G^O$!VQWO'#G`O$![QWO'#GbO!3fQWO'#GeO$!aQ07hO'#ImO$!lQ`O,5<wOOQ07f,5<w,5<wO$!sQ`O'#G^O$#RQ`O'#G_O$#ZQ`O'#G_O$#`Q7[O,5=RO$#pQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$$QQWO'#IrO$$]QWO,5?|O$$eQWO,59`O$%UQ7[O,59qOOQ07b,59q,59qO$%wQ7[O,5<fO$&jQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&tQWO,5<qO$&yQ7[O,5<vO$'ZQWO'#JuO!$aQ^O1G1}O$'`QWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'eQ07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)jQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+nQ7[O'#EgOOQ07`,5?{,5?{O$+xQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,ZQWO1G0qO$,`QWO'#ChO$,kQWO'#K[O$,sQWO,5=uO$,xQWO'#K[O$,}QWO'#K[O$-]QWO'#IzO$-kQWO,5@uO$-sQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-zQWO1G3`O$.PQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.UQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.ZQWO1G2|O$.cQ`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.kQ7[O,5=nO9aQWO,5=nO$![QWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.yQWO'#KYO$/UQWO,5=qOOQU1G.j1G.jO$/ZQ07hO1G.jO@bQWO1G.jO$/fQWO1G.jO9kQ07hO1G.jO$1kQrO,5@wO$1{QWO,5@wO9ZQWO,5@wO$2WQ^O,5=xO$2_QWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2dQ^O1G3nO$6hQ^O'#HmOOQU1G3q1G3qO$6uQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6}Q^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;UQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;ZQ(CYO,5:UOOQO,5;[,5;[O$;eQ`O'#I^O$;{QWO,5@WOOQ07b1G/o1G/oO$<TQ`O'#IdO$<_QWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<gQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<nQ07hO1G0iO$<yQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=XQ07hO1G0iOOQO1G0]1G0]O$=mQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=wQpO,5<eO$>PQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>ZQWO1G5qO$>cQWO1G6OO$>kQrO1G6PO9ZQWO,5>}O$>uQ08SO1G5|O%[Q^O1G5|O$?VQ07hO1G5|O$?hQWO1G5{O$?hQWO1G5{O9ZQWO1G5{O$?pQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@UQWO,5?QO$'ZQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@dQWO7+(_O$@oQ7[O7+(_O$@}Q08SO,5=RO$CYQ08SO,5=TO$EeQ08SO,5=RO$GvQ08SO,5=TO$JXQ08SO,59qO$LaQ08SO,5<fO$NlQ08SO,5<hO%!wQ08SO,5<vOOQ07b7+&]7+&]O%%YQ08SO7+&]O%%|Q7[O'#I_O%&WQWO,5@YOOQ07b1G/y1G/yO%&`Q^O'#I`O%&mQWO,5@ZO%&uQrO,5@ZOOQ07b1G0O1G0OO%'PQWO7+&fOOQ07b7+&f7+&fO%'UQ(CYO,5:eO%[Q^O7+&xO%'`Q(CYO,5:]O%'mQ(CYO,5:iO%'wQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%(RQtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(^QWO1G1yOOQ07b1G1{1G1{O%(cQpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(jQ08SO7+'hOOQ07b,5?V,5?VO%)^QpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)|Q7[O,5?YOOQ07b-E<l-E<lO%*oQ7[O,5?[OOQ07b-E<n-E<nO%*yQpO1G2qOOQ07b1G2Y1G2YO%+QQWO'#IjO%+`QWO,5@mO%+`QWO,5@mO%+hQWO,5@mO%+sQWO,5@mOOQO1G2[1G2[O%,RQ7[O1G2ZO!(SQ7[O1G2ZO%,cQ!LQO'#IlO%,sQWO,5@nO!&dQ7[O,5@nO%,{QpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'ZQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-VQWO,5<zOOQ07`,5<|,5<|O$'ZQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-_QWO,5<yO$!VQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%.RQ7[O1G2mO!(SQ7[O'#IpO%.tQ7[O1G2oO%/OQ7[O1G5iO%/YQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/gQWO1G2UO!(SQ7[O1G2]O%/lQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0`QWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0eQpO'#KTO#%sQWO7+(_O%0oQrO7+(_O$@gQWO7+(_O%0vQ08QO'#ChO%1ZQ08QO,5<}O%1{QWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%2QQWO'#IyO%2iQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2iQWO,5@vO%2qQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2vQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2{Q08QO7+(gO!&dQ7[O7+(gO%3VQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3^QWO'#KXO%3iQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4xQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%5PQWO1G3YO%5[Q7[O1G3YO9kQ07hO1G3[O$![QWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5jQWO'#IxO%6OQWO,5@tO%6WQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6cQWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6hQ07hO1G6cO%6rQ^O1G3dO%6yQWO1G3dO%7OQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7VQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7dQWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7iQ`O1G5sO%7}Q(CYO1G0vO%8XQWO1G0vOOQO1G/p1G/pO%8dQ(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=mQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8nQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8yQ07hO7+&TO%9XQ08SO7++hO%[Q^O7++hO%9iQWO7++gO%9iQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9qQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0oQrO<<KyO%:PQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:XQWO<<KyO%:dQ08SO,5?YO%<oQ08SO,5?[O%>zQ08SO1G2ZO%A]Q08SO1G2mO%ChQ08SO1G2oO%EsQ7[O,5>yOOQO-E<]-E<]O%E}QrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FXQWO1G5uOOQ07b<<JQ<<JQO%FaQ(CYO1G0qO%HkQ(CYO1G0{O%HrQ(CYO1G0{O%JvQ(CYO1G0{O%J}Q(CYO1G0{O%LrQ(CYO1G0{O%MYQ(CYO1G0{O& mQ(CYO1G0{O& tQ(CYO1G0{O&#rQ(CYO1G0{O&$PQ(CYO1G0{O&%}Q(CYO1G0{O&&bQ08SO<<JdO&'gQ(CYO1G0{O&)]Q(CYO'#JdO&+`Q(CYO1G1aO&+mQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+wQWO1G1qO&+|Q(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&,WQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,fQWO1G6XO&,fQWO1G6XO&,nQWO1G6XO&,yQ7[O7+'uO&-ZQpO,5?WO&-eQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-jQpO1G6YO&-tQWO1G6YOOQ07`1G2e1G2eO$'ZQWO1G2eOOQ07`1G2d1G2dO&-|QWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&.RQWO1G2fO&.ZQWO1G2eO&.}Q7[O,5?YOOQ07b-E<m-E<mO&/pQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/zQWO1G/_OOQ07b7+'p7+'pO&0PQ7[O7+'wO&0aQ08SO<<KTOOQ07b<<KT<<KTO&1TQWO1G0vO!&dQ7[O'#IsO&1YQWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1bQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&2UQWO,5?eO&2ZQWO,5?eOOQO-E<w-E<wO&2iQWO1G6bO&2iQWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2qQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2{Q08QO<<LROOQU<<LS<<LSO%3VQpO<<LSO&2vQ`O'#IuO&3RQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&3ZQ^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3eQ`O,5=oOOQU,5=o,5=oO&3lQ`O'#EcO&4QQWO7+(tO&4VQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4_QWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$![QWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4jQWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4uQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4}QWO7++}O&5SQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&5XQWO7+)OO&5^Q^O7+)OO&5eQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5jQWO,5>YOOQU,5>[,5>[O&5oQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5tQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=mQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&6OQ07hO<<IoO&6ZQ08SO<= SO&6kQWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6sQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0oQrOANAeO%[Q^OANAeO&6{Q08SO7+'uO&9^Q08SO,5?YO&;iQ08SO,5?[O&=tQ08SO7+'wO&@VQrO1G4fO&@aQ(CYO7+&]O&BeQ(CYO,5=RO&DlQ(CYO,5=TO&D|Q(CYO,5=RO&E^Q(CYO,5=TO&EnQ(CYO,59qO&GqQ(CYO,5<fO&ItQ(CYO,5<hO&KwQ(CYO,5<vO&MmQ(CYO7+'hO&MzQ(CYO7+'iO&NXQWO,5<YOOQO7+']7+']O&N^Q7[O<<KwOOQO1G4p1G4pO&NeQWO1G4pO&NpQWO1G4pO' OQWO7++sO' OQWO7++sO!&dQ7[O1G4rO' WQpO1G4rO' bQWO7++tOOQ07`7+(P7+(PO$'ZQWO7+(QO' jQpO7+(QOOQ07`7+(O7+(OO$'ZQWO7+(PO' qQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' vQ7[O<<NoOOQ07b7+$y7+$yO'!QQpO,5?_OOQO-E<q-E<qO'![Q08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!lQWO1G5PO'!qQWO7++|O'!qQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!yQWO,5?aOOQO-E<s-E<sO'#UQ(CYO1G6_O'%fQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&3ZQ^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&4QQWO<<L`O'%pQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$![QWO<<LbO9UQWO<<LbO'%xQ`O1G5OO'&TQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&]QWO<= iO'&bQWO<= jOOQU<<Lj<<LjO'&gQWO<<LjO'&lQ^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&sQWO<<I|O''OQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=mQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO''YQWOG27PO%0oQrOG27PO''bQ(CYO<<JdO''oQ(CYO1G2ZO')eQ(CYO,5?YO'+hQ(CYO,5?[O'-kQ(CYO1G2mO'/nQ(CYO1G2oO'1qQ(CYO<<KTO'2OQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2]QWO7+*[O'2hQWO<= _O'2pQpO7+*^OOQ07`<<Kl<<KlO$'ZQWO<<KlOOQ07`<<Kk<<KkO'2zQpO<<KlO$'ZQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'3RQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'3ZQWO7++yO&4QQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3cQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$![QWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3kQWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=mQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3pQWOLD,kO'3xQ(CYO7+'uO'5nQ(CYO,5?YO'7qQ(CYO,5?[O'9tQ(CYO7+'wO';jQ7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'ZQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';zQ(CYO7+*gOOQUG27fG27fO&4QQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO'<UQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<`Q08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&4QQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>qQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@gQrO'#JiO!*fQ^O'#DqO'@nQ^O'#D}O'@uQrO'#ChO'C]QrO'#ChO!*fQ^O'#EPO'CmQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EpQWO,5<eO'ExQ7[O,5;aO'GcQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ExQ7[O'#GgO!&dQ7[O'#GiO'ExQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ExQ7[O'#FzO!&dQ7[O'#F|O'ExQ7[O'#F|O!&dQ7[O'#G[O'ExQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CmQ^O1G0qO'GjQ(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O,5<oO'ExQ7[O,5<oO'CmQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ExQ7[O1G2ZO!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O1G2]O'ExQ7[O1G2]O'CmQ^O7+'iO'CmQ^O7+&]O!&dQ7[OANAcO'ExQ7[OANAcO'GtQWO'#EkO'GyQWO'#EkO'HRQWO'#FZO'HWQWO'#EuO'H]QWO'#JyO'HhQWO'#JwO'HsQWO,5;VO'HxQ7[O,5<bO'IPQWO'#GTO'IUQWO'#GTO'IZQWO,5<cO'IcQWO,5;VO'IkQ(CYO1G1^O'IrQWO,5<oO'IwQWO,5<oO'I|QWO,5<qO'JRQWO,5<qO'JWQWO1G1}O'J]QWO1G0qO'JbQ7[O<<KwO'JiQ7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*yQpO1G2qO%*yQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V\",\n    stateData: \"'Km~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO(p#}O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii(o#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v$VO~P#9lO#v#ii~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v#ii(o#ii(p#ii~P#<^O#v$VO(o#|O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?UOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AoOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#C|O#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#C|O!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#L^O(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#MPO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$jO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%`O|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$&RO#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'pOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*ZO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/qO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#C|Oo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#L^O#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#MPO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$jO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%`O#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$&RO#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#C|O#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)eO|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*WO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-jO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.]Of(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3nOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#C|O#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#C|O`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)eO#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*WO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-jO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.]Of'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#C|OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FnO#j:lO~P%FnOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HyOn:nO~P%HyOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KUOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KUOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO(p#}O#x#ii#y#ii#|#ii(h#ii(o#ii!Y#ii!Z#ii~O#v:sO~P%MpO#v#ii~P%MpOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O#v#ii(o#ii(p#ii~P& {O#v:sO(o#|O(p#}O~P& {OP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$^O`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&'UO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#C|O#|!qi!Z!qi~P$'pO!Z6|O~O!Y']a!Z']a~P#C|O!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.fO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&/XO!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3nOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#C|O`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.fO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&/XO#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#C|O(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@nO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BuOj<gO|)zO!P){O(p%PO~P&@nOj<gO|)zO!P){O(o$}O~P&BuO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&'UO#|$jq!Y$jq!Z$jq~P#C|O#|$kq!Y$kq!Z$kq~P#C|O!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#C|OP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#`O![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#C|O!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#C|OP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&'UO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#C|O#|#_y!Y#_y!Z#_y~P#C|O!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&'UO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&'UOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#C|O!Y#d!Z!Z#d!Z~P#C|O#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&'UOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#`OP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'ASOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ExO!Z[X!ZeX~P'ASO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#C|O#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~\",\n    goto: \"$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AqPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!b$Uc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:r)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!f$Wc#X%n'|(S(n(u)T)U)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:t)Z)l-O.t2W2Z3_3f3g3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z\",\n    nodeNames: \"âš  ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem\",\n    maxTerm: 371,\n    context: trackNewline,\n    nodeProps: [\n        [\n            \"isolate\",\n            -8,\n            4,\n            5,\n            13,\n            33,\n            35,\n            48,\n            50,\n            52,\n            \"\"\n        ],\n        [\n            \"group\",\n            -26,\n            8,\n            16,\n            18,\n            65,\n            201,\n            205,\n            209,\n            210,\n            212,\n            215,\n            218,\n            228,\n            230,\n            236,\n            238,\n            240,\n            242,\n            245,\n            251,\n            257,\n            259,\n            261,\n            263,\n            265,\n            267,\n            268,\n            \"Statement\",\n            -32,\n            12,\n            13,\n            28,\n            31,\n            32,\n            38,\n            48,\n            51,\n            52,\n            54,\n            59,\n            67,\n            75,\n            79,\n            81,\n            83,\n            84,\n            106,\n            107,\n            116,\n            117,\n            134,\n            137,\n            139,\n            140,\n            141,\n            142,\n            144,\n            145,\n            164,\n            165,\n            167,\n            \"Expression\",\n            -23,\n            27,\n            29,\n            33,\n            37,\n            39,\n            41,\n            168,\n            170,\n            172,\n            173,\n            175,\n            176,\n            177,\n            179,\n            180,\n            181,\n            183,\n            184,\n            185,\n            195,\n            197,\n            199,\n            200,\n            \"Type\",\n            -3,\n            87,\n            99,\n            105,\n            \"ClassItem\"\n        ],\n        [\n            \"openedBy\",\n            22,\n            \"<\",\n            34,\n            \"InterpolationStart\",\n            53,\n            \"[\",\n            57,\n            \"{\",\n            72,\n            \"(\",\n            157,\n            \"JSXStartCloseTag\"\n        ],\n        [\n            \"closedBy\",\n            23,\n            \">\",\n            36,\n            \"InterpolationEnd\",\n            47,\n            \"]\",\n            58,\n            \"}\",\n            73,\n            \")\",\n            162,\n            \"JSXEndTag\"\n        ]\n    ],\n    propSources: [\n        jsHighlight\n    ],\n    skippedNodes: [\n        0,\n        4,\n        5,\n        271\n    ],\n    repeatNodeCount: 37,\n    tokenData: \"$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr\",\n    tokenizers: [\n        noSemicolon,\n        incdecToken,\n        jsx,\n        2,\n        3,\n        4,\n        5,\n        6,\n        7,\n        8,\n        9,\n        10,\n        11,\n        12,\n        13,\n        insertSemicolon,\n        new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~\", 141, 332),\n        new _lezer_lr__WEBPACK_IMPORTED_MODULE_0__.LocalTokenGroup(\"j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~\", 25, 315)\n    ],\n    topRules: {\n        \"Script\": [\n            0,\n            6\n        ],\n        \"SingleExpression\": [\n            1,\n            269\n        ],\n        \"SingleClassItem\": [\n            2,\n            270\n        ]\n    },\n    dialects: {\n        jsx: 0,\n        ts: 14614\n    },\n    dynamicPrecedences: {\n        \"69\": 1,\n        \"79\": 1,\n        \"81\": 1,\n        \"165\": 1,\n        \"193\": 1\n    },\n    specialized: [\n        {\n            term: 319,\n            get: (value)=>spec_identifier[value] || -1\n        },\n        {\n            term: 334,\n            get: (value)=>spec_word[value] || -1\n        },\n        {\n            term: 70,\n            get: (value)=>spec_LessThan[value] || -1\n        }\n    ],\n    tokenPrec: 14638\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2phdmFzY3JpcHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUY7QUFDdEM7QUFFbkQsOEVBQThFO0FBQzlFLE1BQU1NLFNBQVMsS0FDYkMsU0FBUyxHQUNUQyxlQUFlLEdBQ2ZDLGNBQWMsR0FDZEMsYUFBYSxLQUNiQyxTQUFTLEtBQ1RDLFVBQVUsS0FDVkMsY0FBYyxHQUNkQyxlQUFlLEdBQ2ZDLGNBQWM7QUFFaEI7NENBQzRDLEdBRTVDLE1BQU1DLFFBQVE7SUFBQztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQUs7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFDdkY7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07Q0FBTTtBQUV6RCxNQUFNQyxTQUFTLEtBQUtDLFlBQVksSUFBSUMsUUFBUSxJQUFJQyxPQUFPLElBQUlDLE9BQU8sSUFBSUMsUUFBUSxJQUFJQyxLQUFLLElBQUlDLFFBQVE7QUFFbkcsTUFBTUMsZUFBZSxJQUFJekIscURBQWNBLENBQUM7SUFDdEMwQixPQUFPO0lBQ1BDLE9BQU1DLE9BQU8sRUFBRUMsSUFBSTtRQUNqQixPQUFPQSxRQUFRaEIsZUFBZWdCLFFBQVFmLGdCQUFnQmUsUUFBUWxCLFNBQVNpQixVQUFVQyxRQUFRakI7SUFDM0Y7SUFDQWtCLFFBQVE7QUFDVjtBQUVBLE1BQU1DLGtCQUFrQixJQUFJOUIsd0RBQWlCQSxDQUFDLENBQUMrQixPQUFPQztJQUNwRCxJQUFJLEVBQUNDLElBQUksRUFBQyxHQUFHRjtJQUNiLElBQUlFLFFBQVFqQixVQUFVaUIsUUFBUSxDQUFDLEtBQUtELE1BQU1MLE9BQU8sRUFDL0NJLE1BQU1HLFdBQVcsQ0FBQ3pCO0FBQ3RCLEdBQUc7SUFBQzBCLFlBQVk7SUFBTUMsVUFBVTtBQUFJO0FBRXBDLE1BQU1DLGNBQWMsSUFBSXJDLHdEQUFpQkEsQ0FBQyxDQUFDK0Is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O1lBQUkySixLQUFLLENBQUN5QixRQUFVcEIsYUFBYSxDQUFDb0IsTUFBTSxJQUFJLENBQUM7UUFBQztLQUFFO0lBQ25MQyxXQUFXO0FBQ2I7QUFFa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvamF2YXNjcmlwdC9kaXN0L2luZGV4LmpzPzEyY2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29udGV4dFRyYWNrZXIsIEV4dGVybmFsVG9rZW5pemVyLCBMUlBhcnNlciwgTG9jYWxUb2tlbkdyb3VwIH0gZnJvbSAnQGxlemVyL2xyJztcbmltcG9ydCB7IHN0eWxlVGFncywgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsZXplci1nZW5lcmF0b3IuIFlvdSBwcm9iYWJseSBzaG91bGRuJ3QgZWRpdCBpdC5cbmNvbnN0IG5vU2VtaSA9IDMwOSxcbiAgaW5jZGVjID0gMSxcbiAgaW5jZGVjUHJlZml4ID0gMixcbiAgSlNYU3RhcnRUYWcgPSAzLFxuICBpbnNlcnRTZW1pID0gMzEwLFxuICBzcGFjZXMgPSAzMTIsXG4gIG5ld2xpbmUgPSAzMTMsXG4gIExpbmVDb21tZW50ID0gNCxcbiAgQmxvY2tDb21tZW50ID0gNSxcbiAgRGlhbGVjdF9qc3ggPSAwO1xuXG4vKiBIYW5kLXdyaXR0ZW4gdG9rZW5pemVycyBmb3IgSmF2YVNjcmlwdCB0b2tlbnMgdGhhdCBjYW4ndCBiZVxuICAgZXhwcmVzc2VkIGJ5IGxlemVyJ3MgYnVpbHQtaW4gdG9rZW5pemVyLiAqL1xuXG5jb25zdCBzcGFjZSA9IFs5LCAxMCwgMTEsIDEyLCAxMywgMzIsIDEzMywgMTYwLCA1NzYwLCA4MTkyLCA4MTkzLCA4MTk0LCA4MTk1LCA4MTk2LCA4MTk3LCA4MTk4LCA4MTk5LCA4MjAwLFxuICAgICAgICAgICAgICAgODIwMSwgODIwMiwgODIzMiwgODIzMywgODIzOSwgODI4NywgMTIyODhdO1xuXG5jb25zdCBicmFjZVIgPSAxMjUsIHNlbWljb2xvbiA9IDU5LCBzbGFzaCA9IDQ3LCBzdGFyID0gNDIsIHBsdXMgPSA0MywgbWludXMgPSA0NSwgbHQgPSA2MCwgY29tbWEgPSA0NDtcblxuY29uc3QgdHJhY2tOZXdsaW5lID0gbmV3IENvbnRleHRUcmFja2VyKHtcbiAgc3RhcnQ6IGZhbHNlLFxuICBzaGlmdChjb250ZXh0LCB0ZXJtKSB7XG4gICAgcmV0dXJuIHRlcm0gPT0gTGluZUNvbW1lbnQgfHwgdGVybSA9PSBCbG9ja0NvbW1lbnQgfHwgdGVybSA9PSBzcGFjZXMgPyBjb250ZXh0IDogdGVybSA9PSBuZXdsaW5lXG4gIH0sXG4gIHN0cmljdDogZmFsc2Vcbn0pO1xuXG5jb25zdCBpbnNlcnRTZW1pY29sb24gPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBsZXQge25leHR9ID0gaW5wdXQ7XG4gIGlmIChuZXh0ID09IGJyYWNlUiB8fCBuZXh0ID09IC0xIHx8IHN0YWNrLmNvbnRleHQpXG4gICAgaW5wdXQuYWNjZXB0VG9rZW4oaW5zZXJ0U2VtaSk7XG59LCB7Y29udGV4dHVhbDogdHJ1ZSwgZmFsbGJhY2s6IHRydWV9KTtcblxuY29uc3Qgbm9TZW1pY29sb24gPSBuZXcgRXh0ZXJuYWxUb2tlbml6ZXIoKGlucHV0LCBzdGFjaykgPT4ge1xuICBsZXQge25leHR9ID0gaW5wdXQsIGFmdGVyO1xuICBpZiAoc3BhY2UuaW5kZXhPZihuZXh0KSA+IC0xKSByZXR1cm5cbiAgaWYgKG5leHQgPT0gc2xhc2ggJiYgKChhZnRlciA9IGlucHV0LnBlZWsoMSkpID09IHNsYXNoIHx8IGFmdGVyID09IHN0YXIpKSByZXR1cm5cbiAgaWYgKG5leHQgIT0gYnJhY2VSICYmIG5leHQgIT0gc2VtaWNvbG9uICYmIG5leHQgIT0gLTEgJiYgIXN0YWNrLmNvbnRleHQpXG4gICAgaW5wdXQuYWNjZXB0VG9rZW4obm9TZW1pKTtcbn0sIHtjb250ZXh0dWFsOiB0cnVlfSk7XG5cbmNvbnN0IGluY2RlY1Rva2VuID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgbGV0IHtuZXh0fSA9IGlucHV0O1xuICBpZiAobmV4dCA9PSBwbHVzIHx8IG5leHQgPT0gbWludXMpIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgaWYgKG5leHQgPT0gaW5wdXQubmV4dCkge1xuICAgICAgaW5wdXQuYWR2YW5jZSgpO1xuICAgICAgbGV0IG1heVBvc3RmaXggPSAhc3RhY2suY29udGV4dCAmJiBzdGFjay5jYW5TaGlmdChpbmNkZWMpO1xuICAgICAgaW5wdXQuYWNjZXB0VG9rZW4obWF5UG9zdGZpeCA/IGluY2RlYyA6IGluY2RlY1ByZWZpeCk7XG4gICAgfVxuICB9XG59LCB7Y29udGV4dHVhbDogdHJ1ZX0pO1xuXG5mdW5jdGlvbiBpZGVudGlmaWVyQ2hhcihjaCwgc3RhcnQpIHtcbiAgcmV0dXJuIGNoID49IDY1ICYmIGNoIDw9IDkwIHx8IGNoID49IDk3ICYmIGNoIDw9IDEyMiB8fCBjaCA9PSA5NSB8fCBjaCA+PSAxOTIgfHxcbiAgICAhc3RhcnQgJiYgY2ggPj0gNDggJiYgY2ggPD0gNTdcbn1cblxuY29uc3QganN4ID0gbmV3IEV4dGVybmFsVG9rZW5pemVyKChpbnB1dCwgc3RhY2spID0+IHtcbiAgaWYgKGlucHV0Lm5leHQgIT0gbHQgfHwgIXN0YWNrLmRpYWxlY3RFbmFibGVkKERpYWxlY3RfanN4KSkgcmV0dXJuXG4gIGlucHV0LmFkdmFuY2UoKTtcbiAgaWYgKGlucHV0Lm5leHQgPT0gc2xhc2gpIHJldHVyblxuICAvLyBTY2FuIGZvciBhbiBpZGVudGlmaWVyIGZvbGxvd2VkIGJ5IGEgY29tbWEgb3IgJ2V4dGVuZHMnLCBkb24ndFxuICAvLyB0cmVhdCB0aGlzIGFzIGEgc3RhcnQgdGFnIGlmIHByZXNlbnQuXG4gIGxldCBiYWNrID0gMDtcbiAgd2hpbGUgKHNwYWNlLmluZGV4T2YoaW5wdXQubmV4dCkgPiAtMSkgeyBpbnB1dC5hZHZhbmNlKCk7IGJhY2srKzsgfVxuICBpZiAoaWRlbnRpZmllckNoYXIoaW5wdXQubmV4dCwgdHJ1ZSkpIHtcbiAgICBpbnB1dC5hZHZhbmNlKCk7XG4gICAgYmFjaysrO1xuICAgIHdoaWxlIChpZGVudGlmaWVyQ2hhcihpbnB1dC5uZXh0LCBmYWxzZSkpIHsgaW5wdXQuYWR2YW5jZSgpOyBiYWNrKys7IH1cbiAgICB3aGlsZSAoc3BhY2UuaW5kZXhPZihpbnB1dC5uZXh0KSA+IC0xKSB7IGlucHV0LmFkdmFuY2UoKTsgYmFjaysrOyB9XG4gICAgaWYgKGlucHV0Lm5leHQgPT0gY29tbWEpIHJldHVyblxuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICBpZiAoaSA9PSA3KSB7XG4gICAgICAgIGlmICghaWRlbnRpZmllckNoYXIoaW5wdXQubmV4dCwgdHJ1ZSkpIHJldHVyblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0Lm5leHQgIT0gXCJleHRlbmRzXCIuY2hhckNvZGVBdChpKSkgYnJlYWtcbiAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgIGJhY2srKztcbiAgICB9XG4gIH1cbiAgaW5wdXQuYWNjZXB0VG9rZW4oSlNYU3RhcnRUYWcsIC1iYWNrKTtcbn0pO1xuXG5jb25zdCBqc0hpZ2hsaWdodCA9IHN0eWxlVGFncyh7XG4gIFwiZ2V0IHNldCBhc3luYyBzdGF0aWNcIjogdGFncy5tb2RpZmllcixcbiAgXCJmb3Igd2hpbGUgZG8gaWYgZWxzZSBzd2l0Y2ggdHJ5IGNhdGNoIGZpbmFsbHkgcmV0dXJuIHRocm93IGJyZWFrIGNvbnRpbnVlIGRlZmF1bHQgY2FzZVwiOiB0YWdzLmNvbnRyb2xLZXl3b3JkLFxuICBcImluIG9mIGF3YWl0IHlpZWxkIHZvaWQgdHlwZW9mIGRlbGV0ZSBpbnN0YW5jZW9mXCI6IHRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuICBcImxldCB2YXIgY29uc3QgdXNpbmcgZnVuY3Rpb24gY2xhc3MgZXh0ZW5kc1wiOiB0YWdzLmRlZmluaXRpb25LZXl3b3JkLFxuICBcImltcG9ydCBleHBvcnQgZnJvbVwiOiB0YWdzLm1vZHVsZUtleXdvcmQsXG4gIFwid2l0aCBkZWJ1Z2dlciBhcyBuZXdcIjogdGFncy5rZXl3b3JkLFxuICBUZW1wbGF0ZVN0cmluZzogdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKSxcbiAgc3VwZXI6IHRhZ3MuYXRvbSxcbiAgQm9vbGVhbkxpdGVyYWw6IHRhZ3MuYm9vbCxcbiAgdGhpczogdGFncy5zZWxmLFxuICBudWxsOiB0YWdzLm51bGwsXG4gIFN0YXI6IHRhZ3MubW9kaWZpZXIsXG4gIFZhcmlhYmxlTmFtZTogdGFncy52YXJpYWJsZU5hbWUsXG4gIFwiQ2FsbEV4cHJlc3Npb24vVmFyaWFibGVOYW1lIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbi9WYXJpYWJsZU5hbWVcIjogdGFncy5mdW5jdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gIFZhcmlhYmxlRGVmaW5pdGlvbjogdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgTGFiZWw6IHRhZ3MubGFiZWxOYW1lLFxuICBQcm9wZXJ0eU5hbWU6IHRhZ3MucHJvcGVydHlOYW1lLFxuICBQcml2YXRlUHJvcGVydHlOYW1lOiB0YWdzLnNwZWNpYWwodGFncy5wcm9wZXJ0eU5hbWUpLFxuICBcIkNhbGxFeHByZXNzaW9uL01lbWJlckV4cHJlc3Npb24vUHJvcGVydHlOYW1lXCI6IHRhZ3MuZnVuY3Rpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICBcIkZ1bmN0aW9uRGVjbGFyYXRpb24vVmFyaWFibGVEZWZpbml0aW9uXCI6IHRhZ3MuZnVuY3Rpb24odGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSksXG4gIFwiQ2xhc3NEZWNsYXJhdGlvbi9WYXJpYWJsZURlZmluaXRpb25cIjogdGFncy5kZWZpbml0aW9uKHRhZ3MuY2xhc3NOYW1lKSxcbiAgUHJvcGVydHlEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICBQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy5zcGVjaWFsKHRhZ3MucHJvcGVydHlOYW1lKSksXG4gIFVwZGF0ZU9wOiB0YWdzLnVwZGF0ZU9wZXJhdG9yLFxuICBcIkxpbmVDb21tZW50IEhhc2hiYW5nXCI6IHRhZ3MubGluZUNvbW1lbnQsXG4gIEJsb2NrQ29tbWVudDogdGFncy5ibG9ja0NvbW1lbnQsXG4gIE51bWJlcjogdGFncy5udW1iZXIsXG4gIFN0cmluZzogdGFncy5zdHJpbmcsXG4gIEVzY2FwZTogdGFncy5lc2NhcGUsXG4gIEFyaXRoT3A6IHRhZ3MuYXJpdGhtZXRpY09wZXJhdG9yLFxuICBMb2dpY09wOiB0YWdzLmxvZ2ljT3BlcmF0b3IsXG4gIEJpdE9wOiB0YWdzLmJpdHdpc2VPcGVyYXRvcixcbiAgQ29tcGFyZU9wOiB0YWdzLmNvbXBhcmVPcGVyYXRvcixcbiAgUmVnRXhwOiB0YWdzLnJlZ2V4cCxcbiAgRXF1YWxzOiB0YWdzLmRlZmluaXRpb25PcGVyYXRvcixcbiAgQXJyb3c6IHRhZ3MuZnVuY3Rpb24odGFncy5wdW5jdHVhdGlvbiksXG4gIFwiOiBTcHJlYWRcIjogdGFncy5wdW5jdHVhdGlvbixcbiAgXCIoIClcIjogdGFncy5wYXJlbixcbiAgXCJbIF1cIjogdGFncy5zcXVhcmVCcmFja2V0LFxuICBcInsgfVwiOiB0YWdzLmJyYWNlLFxuICBcIkludGVycG9sYXRpb25TdGFydCBJbnRlcnBvbGF0aW9uRW5kXCI6IHRhZ3Muc3BlY2lhbCh0YWdzLmJyYWNlKSxcbiAgXCIuXCI6IHRhZ3MuZGVyZWZPcGVyYXRvcixcbiAgXCIsIDtcIjogdGFncy5zZXBhcmF0b3IsXG4gIFwiQFwiOiB0YWdzLm1ldGEsXG5cbiAgVHlwZU5hbWU6IHRhZ3MudHlwZU5hbWUsXG4gIFR5cGVEZWZpbml0aW9uOiB0YWdzLmRlZmluaXRpb24odGFncy50eXBlTmFtZSksXG4gIFwidHlwZSBlbnVtIGludGVyZmFjZSBpbXBsZW1lbnRzIG5hbWVzcGFjZSBtb2R1bGUgZGVjbGFyZVwiOiB0YWdzLmRlZmluaXRpb25LZXl3b3JkLFxuICBcImFic3RyYWN0IGdsb2JhbCBQcml2YWN5IHJlYWRvbmx5IG92ZXJyaWRlXCI6IHRhZ3MubW9kaWZpZXIsXG4gIFwiaXMga2V5b2YgdW5pcXVlIGluZmVyXCI6IHRhZ3Mub3BlcmF0b3JLZXl3b3JkLFxuXG4gIEpTWEF0dHJpYnV0ZVZhbHVlOiB0YWdzLmF0dHJpYnV0ZVZhbHVlLFxuICBKU1hUZXh0OiB0YWdzLmNvbnRlbnQsXG4gIFwiSlNYU3RhcnRUYWcgSlNYU3RhcnRDbG9zZVRhZyBKU1hTZWxmQ2xvc2VFbmRUYWcgSlNYRW5kVGFnXCI6IHRhZ3MuYW5nbGVCcmFja2V0LFxuICBcIkpTWElkZW50aWZpZXIgSlNYTmFtZVNwYWNlZE5hbWVcIjogdGFncy50YWdOYW1lLFxuICBcIkpTWEF0dHJpYnV0ZS9KU1hJZGVudGlmaWVyIEpTWEF0dHJpYnV0ZS9KU1hOYW1lU3BhY2VkTmFtZVwiOiB0YWdzLmF0dHJpYnV0ZU5hbWUsXG4gIFwiSlNYQnVpbHRpbi9KU1hJZGVudGlmaWVyXCI6IHRhZ3Muc3RhbmRhcmQodGFncy50YWdOYW1lKVxufSk7XG5cbi8vIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxlemVyLWdlbmVyYXRvci4gWW91IHByb2JhYmx5IHNob3VsZG4ndCBlZGl0IGl0LlxuY29uc3Qgc3BlY19pZGVudGlmaWVyID0ge19fcHJvdG9fXzpudWxsLGV4cG9ydDoxOCwgYXM6MjMsIGZyb206MzEsIGRlZmF1bHQ6MzQsIGFzeW5jOjM5LCBmdW5jdGlvbjo0MCwgZXh0ZW5kczo1MiwgdGhpczo1NiwgdHJ1ZTo2NCwgZmFsc2U6NjQsIG51bGw6NzYsIHZvaWQ6ODAsIHR5cGVvZjo4NCwgc3VwZXI6MTAyLCBuZXc6MTM2LCBkZWxldGU6MTUyLCB5aWVsZDoxNjEsIGF3YWl0OjE2NSwgY2xhc3M6MTcwLCBwdWJsaWM6MjI3LCBwcml2YXRlOjIyNywgcHJvdGVjdGVkOjIyNywgcmVhZG9ubHk6MjI5LCBpbnN0YW5jZW9mOjI0OCwgc2F0aXNmaWVzOjI1MSwgaW46MjUyLCBjb25zdDoyNTQsIGltcG9ydDoyODYsIGtleW9mOjMzOSwgdW5pcXVlOjM0MywgaW5mZXI6MzQ5LCBpczozODUsIGFic3RyYWN0OjQwNSwgaW1wbGVtZW50czo0MDcsIHR5cGU6NDA5LCBsZXQ6NDEyLCB2YXI6NDE0LCB1c2luZzo0MTcsIGludGVyZmFjZTo0MjMsIGVudW06NDI3LCBuYW1lc3BhY2U6NDMzLCBtb2R1bGU6NDM1LCBkZWNsYXJlOjQzOSwgZ2xvYmFsOjQ0MywgZm9yOjQ2Miwgb2Y6NDcxLCB3aGlsZTo0NzQsIHdpdGg6NDc4LCBkbzo0ODIsIGlmOjQ4NiwgZWxzZTo0ODgsIHN3aXRjaDo0OTIsIGNhc2U6NDk4LCB0cnk6NTA0LCBjYXRjaDo1MDgsIGZpbmFsbHk6NTEyLCByZXR1cm46NTE2LCB0aHJvdzo1MjAsIGJyZWFrOjUyNCwgY29udGludWU6NTI4LCBkZWJ1Z2dlcjo1MzJ9O1xuY29uc3Qgc3BlY193b3JkID0ge19fcHJvdG9fXzpudWxsLGFzeW5jOjEyMywgZ2V0OjEyNSwgc2V0OjEyNywgZGVjbGFyZToxODcsIHB1YmxpYzoxODksIHByaXZhdGU6MTg5LCBwcm90ZWN0ZWQ6MTg5LCBzdGF0aWM6MTkxLCBhYnN0cmFjdDoxOTMsIG92ZXJyaWRlOjE5NSwgcmVhZG9ubHk6MjAxLCBhY2Nlc3NvcjoyMDMsIG5ldzozODl9O1xuY29uc3Qgc3BlY19MZXNzVGhhbiA9IHtfX3Byb3RvX186bnVsbCxcIjxcIjoxNDN9O1xuY29uc3QgcGFyc2VyID0gTFJQYXJzZXIuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxNCxcbiAgc3RhdGVzOiBcIiQ8VU8lVFFeT09PJVtRXk9PTydfUWBPT1AobE9XT09PKnpRMDhTTycjQ2hPK1JPIWJPJyNDaU8rYU8jdE8nI0NpTytvTz9NcE8nI0ReTy5RUV5PJyNEZE8uYlFeTycjRG9PJVtRXk8nI0R5TzBmUV5PJyNFUk9PUTA3YicjRVonI0VaTzFQUVdPJyNFV09PUU8nI0VsJyNFbE9PUU8nI0llJyNJZU8xWFFXTycjR21PMWRRV08nI0VrTzFpUVdPJyNFa08za1EwOFNPJyNKaU82W1EwOFNPJyNKak82eFFXTycjRlpPNn1RJmpPJyNGcU9PUTA3YicjRmMnI0ZjTzdZTyxZTycjRmNPN2hRN1tPJyNGeE85VVFXTycjRndPT1EwN2InI0pqJyNKak9PUTA3YCcjSmknI0ppTzlaUVdPJyNHcU9PUVUnI0tVJyNLVU85ZlFXTycjSVJPOWtRMDdoTycjSVNPT1FVJyNKVycjSldPT1FVJyNJVycjSVdRYFFeT09PYFFeT09PJVtRXk8nI0RxTzlzUV5PJyNEfU85elFeTycjRVBPOWFRV08nI0dtTzpSUTdbTycjQ25POmFRV08nI0VqTzpsUVdPJyNFdU86cVE3W08nI0ZiTztgUVdPJyNHbU9PUU8nI0tWJyNLVk87ZVFXTycjS1ZPO3NRV08nI0d1TztzUVdPJyNHdk87c1FXTycjR3hPOWFRV08nI0d7TzxqUVdPJyNIT08+UlFXTycjQ2RPPmNRV08nI0hbTz5rUVdPJyNIYk8+a1FXTycjSGRPYFFeTycjSGZPPmtRV08nI0hoTz5rUVdPJyNIa08+cFFXTycjSHFPPnVRMDdpTycjSHdPJVtRXk8nI0h5Tz9RUTA3aU8nI0h7Tz9dUTA3aU8nI0h9TzlrUTA3aE8nI0lQTz9oUTA4U08nI0NoT0BqUWBPJyNEaVFPUVdPT08lW1FeTycjRVBPQVFRV08nI0VTTzpSUTdbTycjRWpPQV1RV08nI0VqT0FoUXBPJyNGYk9PUVUnI0NmJyNDZk9PUTA3YCcjRG4nI0RuT09RMDdgJyNKbScjSm1PJVtRXk8nI0ptT09RTycjSnEnI0pxT09RTycjSWInI0liT0JoUWBPJyNFY09PUTA3YCcjRWInI0ViT0NkUTA3cE8nI0VjT0NuUWBPJyNFVk9PUU8nI0pwJyNKcE9EU1FgTycjSnFPRWFRYE8nI0VWT0NuUWBPJyNFY1BFbk8hMExiTycjQ2FQT09PKUNEdSlDRHVPT09PJyNJWCcjSVhPRXlPIWJPLDU5VE9PUTA3Yiw1OVQsNTlUT09PTycjSVknI0lZT0ZYTyN0Tyw1OVRPJVtRXk8nI0RgT09PTycjSVsnI0lbT0ZnTz9NcE8sNTl4T09RMDdiLDU5eCw1OXhPRnVRXk8nI0ldT0dZUVdPJyNKa09JW1FyTycjSmtPK31RXk8nI0prT0ljUVdPLDU6T09JeVFXTycjRWxPSldRV08nI0p5T0pjUVdPJyNKeE9KY1FXTycjSnhPSmtRV08sNTtZT0pwUVdPJyNKd09PUTA3Ziw1OlosNTpaT0p3UV5PLDU6Wk9MeFEwOFNPLDU6ZU9NaVFXTyw1Om1PTlNRMDdoTycjSnZPTlpRV08nI0p1TzlaUVdPJyNKdU9Ob1FXTycjSnVPTndRV08sNTtYT058UVdPJyNKdU8hI1VRck8nI0pqT09RMDdiJyNDaCcjQ2hPJVtRXk8nI0VSTyEjdFFwTyw1OnJPT1FPJyNKcicjSnJPT1FPLUU8Yy1FPGNPOWFRV08sNT1YTyEkW1FXTyw1PVhPISRhUV5PLDU7Vk8hJmRRN1tPJyNFZ08hJ31RV08sNTtWTyEpbVE3W08nI0RzTyEpdFFeTycjRHhPISpPUWBPLDU7YE8hKldRYE8sNTtgTyVbUV5PLDU7YE9PUVUnI0ZSJyNGUk9PUVUnI0ZUJyNGVE8lW1FeTyw1O2FPJVtRXk8sNTthTyVbUV5PLDU7YU8lW1FeTyw1O2FPJVtRXk8sNTthTyVbUV5PLDU7YU8lW1FeTyw1O2FPJVtRXk8sNTthTyVbUV5PLDU7YU8lW1FeTyw1O2FPJVtRXk8sNTthT09RVScjRlgnI0ZYTyEqZlFeTyw1O3JPT1EwN2IsNTt3LDU7d09PUTA3Yiw1O3gsNTt4TyEsaVFXTyw1O3hPT1EwN2IsNTt5LDU7eU8lW1FeTycjSWlPISxxUTA3aE8sNTxlTyEmZFE3W08sNTthTyEtYFE3W08sNTthTyVbUV5PLDU7dU8hLWdRJmpPJyNGZ08hLmRRJmpPJyNKfU8hLk9RJmpPJyNKfU8hLmtRJmpPJyNKfU9PUU8nI0p9JyNKfU8hL1BRJmpPLDU8UE9PT1MsNTxdLDU8XU8hL2JRXk8nI0ZzT09PUycjSWgnI0loTzdZTyxZTyw1O31PIS9pUSZqTycjRnVPT1EwN2IsNTt9LDU7fU8hMFlRTWhPJyNDdU9PUTA3YicjQ3knI0N5TyEwbVFXTycjQ3lPITByTz9NcE8nI0N9TyExYFE3W08sNTxiTyExZ1FXTyw1PGRPITNTUSFMUU8nI0dTTyEzYVFXTycjR1RPITNmUVdPJyNHVE8hM2tRIUxRTycjR1hPITRqUWBPJyNHXU9PUU8nI0doJyNHaE8hKFNRN1tPJyNHZ09PUU8nI0dqJyNHak8hKFNRN1tPJyNHaU8hNV1RTWhPJyNKZE9PUTA3YicjSmQnI0pkTyE1Z1FXTycjSmNPITV1UVdPJyNKYk8hNX1RV08nI0N0T09RMDdiJyNDdycjQ3dPT1EwN2InI0RSJyNEUk9PUTA3YicjRFQnI0RUTzFTUVdPJyNEVk8hKFNRN1tPJyNGek8hKFNRN1tPJyNGfE8hNlZRV08nI0dPTyE2W1FXTycjR1BPITNmUVdPJyNHVk8hKFNRN1tPJyNHW08hNmFRV08nI0VtTyE3T1FXTyw1PGNPT1EwN2AnI0NxJyNDcU8hN1dRV08nI0VuTyE4UVFgTycjRW9PT1EwN2AnI0p3JyNKd08hOFhRMDdoTycjS1dPOWtRMDdoTyw1PV1PYFFeTyw1Pm1PT1FVJyNKYCcjSmBPT1FVLDU+biw1Pm5PT1FVLUU8VS1FPFVPITpaUTA4U08sNTpdTyE8d1EwOFNPLDU6aU8lW1FeTyw1OmlPIT9iUTA4U08sNTprT09RTyw1QHEsNUBxTyFAUlE3W08sNT1YTyFAYVEwN2hPJyNKYU85VVFXTycjSmFPIUByUTA3aE8sNTlZTyFAfVFgTyw1OVlPIUFWUTdbTyw1OVlPOlJRN1tPLDU5WU8hQWJRV08sNTtWTyFBalFXTycjSFpPIUJPUVdPJyNLWk8lW1FeTyw1O3pPITd7UWBPLDU7fE8hQldRV08sNT10TyFCXVFXTyw1PXRPIUJiUVdPLDU9dE85a1EwN2hPLDU9dE87c1FXTyw1PWRPT1FPJyNDdScjQ3VPIUJwUWBPLDU9YU8hQnhRN1tPLDU9Yk8hQ1RRV08sNT1kTyFDWVFwTyw1PWdPIUNiUVdPJyNLVk8+cFFXTycjSFFPOWFRV08nI0hTTyFDZ1FXTycjSFNPOlJRN1tPJyNIVU8hQ2xRV08nI0hVT09RVSw1PWosNT1qTyFDcVFXTycjSFZPIURTUVdPJyNDbk8hRFhRV08sNTlPTyFEY1FXTyw1OU9PIUZoUV5PLDU5T09PUVUsNTlPLDU5T08hRnhRMDdoTyw1OU9PJVtRXk8sNTlPTyFJVFFeTycjSF5PT1FVJyNIXycjSF9PT1FVJyNIYCcjSGBPYFFeTyw1PXZPIUlrUVdPLDU9dk9gUV5PLDU9fE9gUV5PLDU+T08hSXBRV08sNT5RT2BRXk8sNT5TTyFJdVFXTyw1PlZPIUl6UV5PLDU+XU9PUVUsNT5jLDU+Y08lW1FeTyw1PmNPOWtRMDdoTyw1PmVPT1FVLDU+Zyw1PmdPIU5VUVdPLDU+Z09PUVUsNT5pLDU+aU8hTlVRV08sNT5pT09RVSw1PmssNT5rTyFOWlFgTycjRFtPJVtRXk8nI0ptTyFOeFFgTycjSm1PIyBnUWBPJyNEak8jIHhRYE8nI0RqTyMkWlFeTycjRGpPIyRiUVdPJyNKbE8jJGpRV08sNTpUTyMkb1FXTycjRXBPIyR9UVdPJyNKek8jJVZRV08sNTtaTyMlW1FgTycjRGpPIyVpUWBPJyNFVU9PUTA3Yiw1Om4sNTpuTyVbUV5PLDU6bk8jJXBRV08sNTpuTz5wUVdPLDU7VU8hQH1RYE8sNTtVTyFBVlE3W08sNTtVTzpSUTdbTyw1O1VPIyV4UVdPLDVAWE8jJX1RJElTTyw1OnJPT1FPLUU8YC1FPGBPIydUUTA3cE8sNTp9T0NuUWBPLDU6cU8jJ19RYE8sNTpxT0NuUWBPLDU6fU8hQHJRMDdoTyw1OnFPT1EwN2AnI0VmJyNFZk9PUU8sNTp9LDU6fU8lW1FeTyw1On1PIydsUTA3aE8sNTp9TyMnd1EwN2hPLDU6fU8hQH1RYE8sNTpxT09RTyw1O1QsNTtUTyMoVlEwN2hPLDU6fVBPT08nI0lWJyNJVlAjKGtPITBMYk8sNTh7UE9PTyw1OHssNTh7T09PTy1FPFYtRTxWT09RMDdiMUcubzFHLm9PT09PLUU8Vy1FPFdPIyh2UXBPLDU5ek9PT08tRTxZLUU8WU9PUTA3YjFHL2QxRy9kTyMoe1FyTyw1PndPK31RXk8sNT53T09RTyw1Pn0sNT59TyMpVlFeTycjSV1PT1FPLUU8Wi1FPFpPIylkUVdPLDVAVk8jKWxRck8sNUBWTyMpc1FXTyw1QGRPT1EwN2IxRy9qMUcvak8lW1FeTyw1QGVPIyl7UVdPJyNJY09PUU8tRTxhLUU8YU8jKXNRV08sNUBkT09RMDdgMUcwdDFHMHRPT1EwN2YxRy91MUcvdU9PUTA3ZjFHMFgxRzBYTyVbUV5PLDVAYk8jKmFRMDdoTyw1QGJPIypyUTA3aE8sNUBiTyMqeVFXTyw1QGFPOVpRV08sNUBhTyMrUlFXTyw1QGFPIythUVdPJyNJZk8jKnlRV08sNUBhT09RMDdgMUcwczFHMHNPISpPUWBPLDU6dE8hKlpRYE8sNTp0T09RTyw1OnYsNTp2TyMsUlFXTyw1OnZPIyxaUTdbTzFHMnNPOWFRV08xRzJzT09RMDdiMUcwcTFHMHFPIyxpUTA4U08xRzBxTyMtblEwOFFPLDU7Uk9PUTA3YicjR1InI0dSTyMuW1EwOFNPJyNKZE8hJGFRXk8xRzBxTyMwZFE3W08nI0puTyMwblFXTyw1Ol9PIzBzUXJPJyNKb08lW1FeTycjSm9PIzB9UVdPLDU6ZE9PUTA3YicjRFsnI0RbT09RMDdiMUcwejFHMHpPJVtRXk8xRzB6T09RMDdiMUcxZDFHMWRPIzFTUVdPMUcwek8jM2tRMDhTTzFHMHtPIzNyUTA4U08xRzB7TyM2XVEwOFNPMUcwe08jNmRRMDhTTzFHMHtPIzhuUTA4U08xRzB7TyM5VVEwOFNPMUcwe08jPE9RMDhTTzFHMHtPIzxWUTA4U08xRzB7TyM+alEwOFNPMUcwe08jPndRMDhTTzFHMHtPI0B1UTA4U08xRzB7TyNDdVEoQ1lPJyNDaE8jRXNRKENZTzFHMV5PI0V6UShDWU8nI0pqTyEsbFFXTzFHMWRPI0ZbUTA4U08sNT9UT09RMDdgLUU8Zy1FPGdPI0dPUTA4U08xRzB7T09RMDdiMUcwezFHMHtPI0laUTA4U08xRzFhTyNJfVEmak8sNTxUTyNKVlEmak8sNTxVTyNKX1Emak8nI0ZsTyNKdlFXTycjRmtPT1FPJyNLTycjS09PT1FPJyNJZycjSWdPI0p7USZqTzFHMWtPT1EwN2IxRzFrMUcxa09PT1MxRzF2MUcxdk8jS15RKENZTycjSmlPI0toUVdPLDU8X08hKmZRXk8sNTxfT09PUy1FPGYtRTxmT09RMDdiMUcxaTFHMWlPI0ttUWBPJyNKfU9PUTA3Yiw1PGEsNTxhTyNLdVFgTyw1PGFPT1EwN2IsNTllLDU5ZU8hJmRRN1tPJyNEUE9PT08nI0laJyNJWk8jS3pPP01wTyw1OWlPT1EwN2IsNTlpLDU5aU8lW1FeTzFHMXxPITZbUVdPJyNJa08jTFZRN1tPLDU8dU9PUTA3Yiw1PHIsNTxyTyEoU1E3W08nI0luTyNMdVE3W08sNT1STyEoU1E3W08nI0lwTyNNaFE3W08sNT1UTyEmZFE3W08sNT1WT09RTzFHMk8xRzJPTyNNclFwTycjQ3FPI05WUXBPLDU8bk8jTl5RV08nI0tSTzlhUVdPJyNLUk8jTmxRV08sNTxwTyEoU1E3W08sNTxvTyNOcVFXTycjR1VPI058UVdPLDU8b08kIFJRcE8nI0dSTyQgYFFwTycjS1NPJCBqUVdPJyNLU08hJmRRN1tPJyNLU08kIG9RV08sNTxzTyQgdFFgTycjR15PITRlUWBPJyNHXk8kIVZRV08nI0dgTyQhW1FXTycjR2JPITNmUVdPJyNHZU8kIWFRMDdoTycjSW1PJCFsUWBPLDU8d09PUTA3Ziw1PHcsNTx3TyQhc1FgTycjR15PJCNSUWBPJyNHX08kI1pRYE8nI0dfTyQjYFE3W08sNT1STyQjcFE3W08sNT1UT09RMDdiLDU9Vyw1PVdPIShTUTdbTyw1P31PIShTUTdbTyw1P31PJCRRUVdPJyNJck8kJF1RV08sNT98TyQkZVFXTyw1OWBPJCVVUTdbTyw1OXFPT1EwN2IsNTlxLDU5cU8kJXdRN1tPLDU8Zk8kJmpRN1tPLDU8aE9AYlFXTyw1PGpPT1EwN2IsNTxrLDU8a08kJnRRV08sNTxxTyQmeVE3W08sNTx2TyQnWlFXTycjSnVPISRhUV5PMUcxfU8kJ2BRV08xRzF9TzlaUVdPJyNKeE85WlFXTycjRXBPJVtRXk8nI0VwTzlaUVdPJyNJdE8kJ2VRMDdoTyw1QHJPT1FVMUcydzFHMndPT1FVMUc0WDFHNFhPT1EwN2IxRy93MUcvd08hLGlRV08xRy93TyQpalEwOFNPMUcwVE9PUVUxRzJzMUcyc08hJmRRN1tPMUcyc08lW1FeTzFHMnNPIyxeUVdPMUcyc08kK25RN1tPJyNFZ09PUTA3YCw1P3ssNT97TyQreFEwN2hPLDU/e09PUVUxRy50MUcudE8hQHJRMDdoTzFHLnRPIUB9UWBPMUcudE8hQVZRN1tPMUcudE8kLFpRV08xRzBxTyQsYFFXTycjQ2hPJCxrUVdPJyNLW08kLHNRV08sNT11TyQseFFXTycjS1tPJCx9UVdPJyNLW08kLV1RV08nI0l6TyQta1FXTyw1QHVPJC1zUXJPMUcxZk9PUTA3YjFHMWgxRzFoTzlhUVdPMUczYE9AYlFXTzFHM2BPJC16UVdPMUczYE8kLlBRV08xRzNgT09RVTFHM2AxRzNgTyFDVFFXTzFHM09PISZkUTdbTzFHMntPJC5VUVdPMUcye09PUVUxRzJ8MUcyfE8hJmRRN1tPMUcyfE8kLlpRV08xRzJ8TyQuY1FgTycjR3pPT1FVMUczTzFHM09PITRlUWBPJyNJdk8hQ1lRcE8xRzNST09RVTFHM1IxRzNST09RVSw1PWwsNT1sTyQua1E3W08sNT1uTzlhUVdPLDU9bk8kIVtRV08sNT1wTzlVUVdPLDU9cE8hQH1RYE8sNT1wTyFBVlE3W08sNT1wTzpSUTdbTyw1PXBPJC55UVdPJyNLWU8kL1VRV08sNT1xT09RVTFHLmoxRy5qTyQvWlEwN2hPMUcuak9AYlFXTzFHLmpPJC9mUVdPMUcuak85a1EwN2hPMUcuak8kMWtRck8sNUB3TyQxe1FXTyw1QHdPOVpRV08sNUB3TyQyV1FeTyw1PXhPJDJfUVdPLDU9eE9PUVUxRzNiMUczYk9gUV5PMUczYk9PUVUxRzNoMUczaE9PUVUxRzNqMUczak8+a1FXTzFHM2xPJDJkUV5PMUczbk8kNmhRXk8nI0htT09RVTFHM3ExRzNxTyQ2dVFXTycjSHNPPnBRV08nI0h1T09RVTFHM3cxRzN3TyQ2fVFeTzFHM3dPOWtRMDdoTzFHM31PT1FVMUc0UDFHNFBPT1EwN2AnI0dZJyNHWU85a1EwN2hPMUc0Uk85a1EwN2hPMUc0VE8kO1VRV08sNUBYTyEqZlFeTyw1O1tPOVpRV08sNTtbTz5wUVdPLDU6VU8hKmZRXk8sNTpVTyFAfVFgTyw1OlVPJDtaUShDWU8sNTpVT09RTyw1O1ssNTtbTyQ7ZVFgTycjSV5PJDt7UVdPLDVAV09PUTA3YjFHL28xRy9vTyQ8VFFgTycjSWRPJDxfUVdPLDVAZk9PUTA3YDFHMHUxRzB1TyMgeFFgTyw1OlVPT1FPJyNJYScjSWFPJDxnUWBPLDU6cE9PUTA3Ziw1OnAsNTpwTyMlc1FXTzFHMFlPT1EwN2IxRzBZMUcwWU8lW1FeTzFHMFlPT1EwN2IxRzBwMUcwcE8+cFFXTzFHMHBPIUB9UWBPMUcwcE8hQVZRN1tPMUcwcE9PUTA3YDFHNXMxRzVzTyFAclEwN2hPMUcwXU9PUU8xRzBpMUcwaU8lW1FeTzFHMGlPJDxuUTA3aE8xRzBpTyQ8eVEwN2hPMUcwaU8hQH1RYE8xRzBdT0NuUWBPMUcwXU8kPVhRMDdoTzFHMGlPT1FPMUcwXTFHMF1PJD1tUTA4U08xRzBpUE9PTy1FPFQtRTxUUE9PTzFHLmcxRy5nT09PTzFHL2YxRy9mTyQ9d1FwTyw1PGVPJD5QUXJPMUc0Y09PUU8xRzRpMUc0aU8lW1FeTyw1PndPJD5aUVdPMUc1cU8kPmNRV08xRzZPTyQ+a1FyTzFHNlBPOVpRV08sNT59TyQ+dVEwOFNPMUc1fE8lW1FeTzFHNXxPJD9WUTA3aE8xRzV8TyQ/aFFXTzFHNXtPJD9oUVdPMUc1e085WlFXTzFHNXtPJD9wUVdPLDU/UU85WlFXTyw1P1FPT1FPLDU/USw1P1FPJEBVUVdPLDU/UU8kJ1pRV08sNT9RT09RTy1FPGQtRTxkT09RTzFHMGAxRzBgT09RTzFHMGIxRzBiTyEsbFFXTzFHMGJPT1FVNysoXzcrKF9PISZkUTdbTzcrKF9PJVtRXk83KyhfTyRAZFFXTzcrKF9PJEBvUTdbTzcrKF9PJEB9UTA4U08sNT1STyRDWVEwOFNPLDU9VE8kRWVRMDhTTyw1PVJPJEd2UTA4U08sNT1UTyRKWFEwOFNPLDU5cU8kTGFRMDhTTyw1PGZPJE5sUTA4U08sNTxoTyUhd1EwOFNPLDU8dk9PUTA3YjcrJl03KyZdTyUlWVEwOFNPNysmXU8lJXxRN1tPJyNJX08lJldRV08sNUBZT09RMDdiMUcveTFHL3lPJSZgUV5PJyNJYE8lJm1RV08sNUBaTyUmdVFyTyw1QFpPT1EwN2IxRzBPMUcwT08lJ1BRV083KyZmT09RMDdiNysmZjcrJmZPJSdVUShDWU8sNTplTyVbUV5PNysmeE8lJ2BRKENZTyw1Ol1PJSdtUShDWU8sNTppTyUnd1EoQ1lPLDU6a09PUTA3YjcrJ083KydPT09RTzFHMW8xRzFvT09RTzFHMXAxRzFwTyUoUlF0Tyw1PFdPISpmUV5PLDU8Vk9PUU8tRTxlLUU8ZU9PUTA3YjcrJ1Y3KydWT09PUzcrJ2I3KydiT09PUzFHMXkxRzF5TyUoXlFXTzFHMXlPT1EwN2IxRzF7MUcxe08lKGNRcE8sNTlrT09PTy1FPFgtRTxYT09RMDdiMUcvVDFHL1RPJShqUTA4U083KydoT09RMDdiLDU/Viw1P1ZPJSleUXBPLDU/Vk9PUTA3YjFHMmExRzJhUCEmZFE3W08nI0lrUE9RMDdiLUU8aS1FPGlPJSl8UTdbTyw1P1lPT1EwN2ItRTxsLUU8bE8lKm9RN1tPLDU/W09PUTA3Yi1FPG4tRTxuTyUqeVFwTzFHMnFPT1EwN2IxRzJZMUcyWU8lK1FRV08nI0lqTyUrYFFXTyw1QG1PJStgUVdPLDVAbU8lK2hRV08sNUBtTyUrc1FXTyw1QG1PT1FPMUcyWzFHMltPJSxSUTdbTzFHMlpPIShTUTdbTzFHMlpPJSxjUSFMUU8nI0lsTyUsc1FXTyw1QG5PISZkUTdbTyw1QG5PJSx7UXBPLDVAbk9PUTA3YjFHMl8xRzJfT09RMDdgLDU8eCw1PHhPT1EwN2AsNTx5LDU8eU8kJ1pRV08sNTx5T0NfUVdPLDU8eU8hQH1RYE8sNTx4T09RTycjR2EnI0dhTyUtVlFXTyw1PHpPT1EwN2AsNTx8LDU8fE8kJ1pRV08sNT1QT09RTyw1P1gsNT9YT09RTy1FPGstRTxrT09RMDdmMUcyYzFHMmNPITRlUWBPLDU8eE8lLV9RV08sNTx5TyQhVlFXTyw1PHpPITRlUWBPLDU8eU8hKFNRN1tPJyNJbk8lLlJRN1tPMUcybU8hKFNRN1tPJyNJcE8lLnRRN1tPMUcyb08lL09RN1tPMUc1aU8lL1lRN1tPMUc1aU9PUU8sNT9eLDU/Xk9PUU8tRTxwLUU8cE9PUU8xRy56MUcuek8hN3tRYE8sNTlzTyVbUV5PLDU5c08lL2dRV08xRzJVTyEoU1E3W08xRzJdTyUvbFEwOFNPNysnaU9PUTA3YjcrJ2k3KydpTyEkYVFeTzcrJ2lPJTBgUVdPLDU7W09PUTA3YCw1P2AsNT9gT09RMDdgLUU8ci1FPHJPT1EwN2I3KyVjNyslY08lMGVRcE8nI0tUTyMlc1FXTzcrKF9PJTBvUXJPNysoX08kQGdRV083KyhfTyUwdlEwOFFPJyNDaE8lMVpRMDhRTyw1PH1PJTF7UVdPLDU8fU9PUTA3YDFHNWcxRzVnT09RVTcrJGA3KyRgTyFAclEwN2hPNyskYE8hQH1RYE83KyRgTyEkYVFeTzcrJl1PJTJRUVdPJyNJeU8lMmlRV08sNUB2T09RTzFHM2ExRzNhTzlhUVdPLDVAdk8lMmlRV08sNUB2TyUycVFXTyw1QHZPT1FPLDU/Ziw1P2ZPT1FPLUU8eC1FPHhPT1EwN2I3KydRNysnUU8lMnZRV083Kyh6TzlrUTA3aE83Kyh6TzlhUVdPNysoek9AYlFXTzcrKHpPT1FVNysoajcrKGpPJTJ7UTA4UU83KyhnTyEmZFE3W083KyhnTyUzVlFwTzcrKGhPT1FVNysoaDcrKGhPISZkUTdbTzcrKGhPJTNeUVdPJyNLWE8lM2lRV08sNT1mT09RTyw1P2IsNT9iT09RTy1FPHQtRTx0T09RVTcrKG03KyhtTyU0eFFgTycjSFRPT1FVMUczWTFHM1lPISZkUTdbTzFHM1lPJVtRXk8xRzNZTyU1UFFXTzFHM1lPJTVbUTdbTzFHM1lPOWtRMDdoTzFHM1tPJCFbUVdPMUczW085VVFXTzFHM1tPIUB9UWBPMUczW08hQVZRN1tPMUczW08lNWpRV08nI0l4TyU2T1FXTyw1QHRPJTZXUWBPLDVAdE9PUTA3YDFHM10xRzNdT09RVTcrJFU3KyRVT0BiUVdPNyskVU85a1EwN2hPNyskVU8lNmNRV083KyRVTyVbUV5PMUc2Y08lW1FeTzFHNmRPJTZoUTA3aE8xRzZjTyU2clFeTzFHM2RPJTZ5UVdPMUczZE8lN09RXk8xRzNkT09RVTcrKHw3Kyh8TzlrUTA3aE83KylXT2BRXk83KylZT09RVScjS18nI0tfT09RVScjSXsnI0l7TyU3VlFeTyw1PlhPT1FVLDU+WCw1PlhPJVtRXk8nI0huTyU3ZFFXTycjSHBPT1FVLDU+Xyw1Pl9POVpRV08sNT5fT09RVSw1PmEsNT5hT09RVTcrKWM3KyljT09RVTcrKWk3KylpT09RVTcrKW03KyltT09RVTcrKW83KylvTyU3aVFgTzFHNXNPJTd9UShDWU8xRzB2TyU4WFFXTzFHMHZPT1FPMUcvcDFHL3BPJThkUShDWU8xRy9wTz5wUVdPMUcvcE8hKmZRXk8nI0RqT09RTyw1PngsNT54T09RTy1FPFstRTxbT09RTyw1P08sNT9PT09RTy1FPGItRTxiTyFAfVFgTzFHL3BPT1FPLUU8Xy1FPF9PT1EwN2YxRzBbMUcwW09PUTA3YjcrJXQ3KyV0TyMlc1FXTzcrJXRPT1EwN2I3KyZbNysmW08+cFFXTzcrJltPIUB9UWBPNysmW09PUU83KyV3Nysld08kPW1RMDhTTzcrJlRPT1FPNysmVDcrJlRPJVtRXk83KyZUTyU4blEwN2hPNysmVE8hQHJRMDdoTzcrJXdPIUB9UWBPNysld08lOHlRMDdoTzcrJlRPJTlYUTA4U083KytoTyVbUV5PNysraE8lOWlRV083KytnTyU5aVFXTzcrK2dPT1FPMUc0bDFHNGxPOVpRV08xRzRsTyU5cVFXTzFHNGxPT1FPNyslfDcrJXxPIyVzUVdPPDxLeU8lMG9Rck88PEt5TyU6UFFXTzw8S3lPT1FVPDxLeTw8S3lPISZkUTdbTzw8S3lPJVtRXk88PEt5TyU6WFFXTzw8S3lPJTpkUTA4U08sNT9ZTyU8b1EwOFNPLDU/W08lPnpRMDhTTzFHMlpPJUFdUTA4U08xRzJtTyVDaFEwOFNPMUcyb08lRXNRN1tPLDU+eU9PUU8tRTxdLUU8XU8lRX1Rck8sNT56TyVbUV5PLDU+ek9PUU8tRTxeLUU8Xk8lRlhRV08xRzV1T09RMDdiPDxKUTw8SlFPJUZhUShDWU8xRzBxTyVIa1EoQ1lPMUcwe08lSHJRKENZTzFHMHtPJUp2UShDWU8xRzB7TyVKfVEoQ1lPMUcwe08lTHJRKENZTzFHMHtPJU1ZUShDWU8xRzB7TyYgbVEoQ1lPMUcwe08mIHRRKENZTzFHMHtPJiNyUShDWU8xRzB7TyYkUFEoQ1lPMUcwe08mJX1RKENZTzFHMHtPJiZiUTA4U088PEpkTyYnZ1EoQ1lPMUcwe08mKV1RKENZTycjSmRPJitgUShDWU8xRzFhTyYrbVEoQ1lPMUcwVE8hKmZRXk8nI0ZuT09RTycjS1AnI0tQT09RTzFHMXIxRzFyTyYrd1FXTzFHMXFPJit8UShDWU8sNT9UT09PUzcrJ2U3KydlT09PTzFHL1YxRy9WT09RMDdiMUc0cTFHNHFPIShTUTdbTzcrKF1PJixXUVdPLDU/VU85YVFXTyw1P1VPT1FPLUU8aC1FPGhPJixmUVdPMUc2WE8mLGZRV08xRzZYTyYsblFXTzFHNlhPJix5UTdbTzcrJ3VPJi1aUXBPLDU/V08mLWVRV08sNT9XTyEmZFE3W08sNT9XT09RTy1FPGotRTxqTyYtalFwTzFHNllPJi10UVdPMUc2WU9PUTA3YDFHMmUxRzJlTyQnWlFXTzFHMmVPT1EwN2AxRzJkMUcyZE8mLXxRV08xRzJmTyEmZFE3W08xRzJmT09RMDdgMUcyazFHMmtPIUB9UWBPMUcyZE9DX1FXTzFHMmVPJi5SUVdPMUcyZk8mLlpRV08xRzJlTyYufVE3W08sNT9ZT09RMDdiLUU8bS1FPG1PJi9wUTdbTyw1P1tPT1EwN2ItRTxvLUU8b08hKFNRN1tPNysrVE9PUTA3YjFHL18xRy9fTyYvelFXTzFHL19PT1EwN2I3KydwNysncE8mMFBRN1tPNysnd08mMGFRMDhTTzw8S1RPT1EwN2I8PEtUPDxLVE8mMVRRV08xRzB2TyEmZFE3W08nI0lzTyYxWVFXTyw1QG9PISZkUTdbTzFHMmlPT1FVPDxHejw8R3pPIUByUTA3aE88PEd6TyYxYlEwOFNPPDxJd09PUTA3Yjw8SXc8PEl3T09RTyw1P2UsNT9lTyYyVVFXTyw1P2VPJjJaUVdPLDU/ZU9PUU8tRTx3LUU8d08mMmlRV08xRzZiTyYyaVFXTzFHNmJPOWFRV08xRzZiT0BiUVdPPDxMZk9PUVU8PExmPDxMZk8mMnFRV088PExmTzlrUTA3aE88PExmT09RVTw8TFI8PExSTyUye1EwOFFPPDxMUk9PUVU8PExTPDxMU08lM1ZRcE88PExTTyYydlFgTycjSXVPJjNSUVdPLDVAc08hKmZRXk8sNUBzT09RVTFHM1ExRzNRTyYzWlFeTycjSm1PT1FPJyNJdycjSXdPOWtRMDdoTycjSXdPJjNlUWBPLDU9b09PUVUsNT1vLDU9b08mM2xRYE8nI0VjTyY0UVFXTzcrKHRPJjRWUVdPNysodE9PUVU3Kyh0NysodE8hJmRRN1tPNysodE8lW1FeTzcrKHRPJjRfUVdPNysodE9PUVU3Kyh2Nysodk85a1EwN2hPNysodk8kIVtRV083Kyh2TzlVUVdPNysodk8hQH1RYE83Kyh2TyY0alFXTyw1P2RPT1FPLUU8di1FPHZPT1FPJyNIVycjSFdPJjR1UVdPMUc2YE85a1EwN2hPPDxHcE9PUVU8PEdwPDxHcE9AYlFXTzw8R3BPJjR9UVdPNysrfU8mNVNRV083KyxPTyVbUV5PNysrfU8lW1FeTzcrLE9PT1FVNyspTzcrKU9PJjVYUVdPNyspT08mNV5RXk83KylPTyY1ZVFXTzcrKU9PT1FVPDxMcjw8THJPT1FVPDxMdDw8THRPT1FVLUU8eS1FPHlPT1FVMUczczFHM3NPJjVqUVdPLDU+WU9PUVUsNT5bLDU+W08mNW9RV08xRzN5TzlaUVdPNysmYk8hKmZRXk83KyZiT09RTzcrJVs3KyVbTyY1dFEoQ1lPMUc2UE8+cFFXTzcrJVtPT1EwN2I8PElgPDxJYE9PUTA3Yjw8SXY8PEl2Tz5wUVdPPDxJdk9PUU88PElvPDxJb08kPW1RMDhTTzw8SW9PJVtRXk88PElvT09RTzw8SWM8PEljTyFAclEwN2hPPDxJY08mNk9RMDdoTzw8SW9PJjZaUTA4U088PSBTTyY2a1FXTzw9IFJPT1FPNysqVzcrKldPOVpRV083KypXT09RVUFOQWVBTkFlTyY2c1FXT0FOQWVPISZkUTdbT0FOQWVPIyVzUVdPQU5BZU8lMG9Rck9BTkFlTyVbUV5PQU5BZU8mNntRMDhTTzcrJ3VPJjleUTA4U08sNT9ZTyY7aVEwOFNPLDU/W08mPXRRMDhTTzcrJ3dPJkBWUXJPMUc0Zk8mQGFRKENZTzcrJl1PJkJlUShDWU8sNT1STyZEbFEoQ1lPLDU9VE8mRHxRKENZTyw1PVJPJkVeUShDWU8sNT1UTyZFblEoQ1lPLDU5cU8mR3FRKENZTyw1PGZPJkl0UShDWU8sNTxoTyZLd1EoQ1lPLDU8dk8mTW1RKENZTzcrJ2hPJk16UShDWU83KydpTyZOWFFXTyw1PFlPT1FPNysnXTcrJ11PJk5eUTdbTzw8S3dPT1FPMUc0cDFHNHBPJk5lUVdPMUc0cE8mTnBRV08xRzRwTycgT1FXTzcrK3NPJyBPUVdPNysrc08hJmRRN1tPMUc0ck8nIFdRcE8xRzRyTycgYlFXTzcrK3RPT1EwN2A3KyhQNysoUE8kJ1pRV083KyhRTycgalFwTzcrKFFPT1EwN2A3KyhPNysoT08kJ1pRV083KyhQTycgcVFXTzcrKFFPISZkUTdbTzcrKFFPQ19RV083KyhQTycgdlE3W088PE5vT09RMDdiNyskeTcrJHlPJyFRUXBPLDU/X09PUU8tRTxxLUU8cU8nIVtRMDhRTzcrKFRPT1FVQU49ZkFOPWZPOWFRV08xRzVQT09RTzFHNVAxRzVQTychbFFXTzFHNVBPJyFxUVdPNysrfE8nIXFRV083Kyt8TzlrUTA3aE9BTkJRT0BiUVdPQU5CUU9PUVVBTkJRQU5CUU9PUVVBTkFtQU5BbU9PUVVBTkFuQU5Bbk8nIXlRV08sNT9hT09RTy1FPHMtRTxzTycjVVEoQ1lPMUc2X08nJWZRck8nI0NoT09RTyw1P2MsNT9jT09RTy1FPHUtRTx1T09RVTFHM1oxRzNaTyYzWlFeTyw1PHpPT1FVPDxMYDw8TGBPISZkUTdbTzw8TGBPJjRRUVdPPDxMYE8nJXBRV088PExgTyVbUV5PPDxMYE9PUVU8PExiPDxMYk85a1EwN2hPPDxMYk8kIVtRV088PExiTzlVUVdPPDxMYk8nJXhRYE8xRzVPTycmVFFXTzcrK3pPT1FVQU49W0FOPVtPOWtRMDdoT0FOPVtPT1FVPD0gaTw9IGlPT1FVPD0gajw9IGpPJyZdUVdPPD0gaU8nJmJRV088PSBqT09RVTw8TGo8PExqTycmZ1FXTzw8TGpPJyZsUV5PPDxMak9PUVUxRzN0MUczdE8+cFFXTzcrKWVPJyZzUVdPPDxJfE8nJ09RKENZTzw8SXxPT1FPPDxIdjw8SHZPT1EwN2JBTj9iQU4/Yk9PUU9BTj9aQU4/Wk8kPW1RMDhTT0FOP1pPT1FPQU4+fUFOPn1PJVtRXk9BTj9aT09RTzw8TXI8PE1yT09RVUcyN1BHMjdQTyEmZFE3W09HMjdQTyMlc1FXT0cyN1BPJydZUVdPRzI3UE8lMG9Rck9HMjdQTycnYlEoQ1lPPDxKZE8nJ29RKENZTzFHMlpPJyllUShDWU8sNT9ZTycraFEoQ1lPLDU/W08nLWtRKENZTzFHMm1PJy9uUShDWU8xRzJvTycxcVEoQ1lPPDxLVE8nMk9RKENZTzw8SXdPT1FPMUcxdDFHMXRPIShTUTdbT0FOQWNPT1FPNysqWzcrKltPJzJdUVdPNysqW08nMmhRV088PSBfTycycFFwTzcrKl5PT1EwN2A8PEtsPDxLbE8kJ1pRV088PEtsT09RMDdgPDxLazw8S2tPJzJ6UXBPPDxLbE8kJ1pRV088PEtrT09RTzcrKms3KyprTzlhUVdPNysqa08nM1JRV088PSBoT09RVUcyN2xHMjdsTzlrUTA3aE9HMjdsTyEqZlFeTzFHNHtPJzNaUVdPNysreU8mNFFRV09BTkF6T09RVUFOQXpBTkF6TyEmZFE3W09BTkF6TyczY1FXT0FOQXpPT1FVQU5BfEFOQXxPOWtRMDdoT0FOQXxPJCFbUVdPQU5BfE9PUU8nI0hYJyNIWE9PUU83KypqNysqak9PUVVHMjJ2RzIydk9PUVVBTkVUQU5FVE9PUVVBTkVVQU5FVU9PUVVBTkJVQU5CVU8nM2tRV09BTkJVT09RVTw8TVA8PE1QTyEqZlFeT0FOP2hPT1FPRzI0dUcyNHVPJD1tUTA4U09HMjR1TyMlc1FXT0xELGtPT1FVTEQsa0xELGtPISZkUTdbT0xELGtPJzNwUVdPTEQsa08nM3hRKENZTzcrJ3VPJzVuUShDWU8sNT9ZTyc3cVEoQ1lPLDU/W08nOXRRKENZTzcrJ3dPJztqUTdbT0cyNn1PT1FPPDxNdjw8TXZPT1EwN2BBTkFXQU5BV08kJ1pRV09BTkFXT09RMDdgQU5BVkFOQVZPT1FPPDxOVjw8TlZPT1FVTEQtV0xELVdPJzt6UShDWU83KypnT09RVUcyN2ZHMjdmTyY0UVFXT0cyN2ZPISZkUTdbT0cyN2ZPT1FVRzI3aEcyN2hPOWtRMDdoT0cyN2hPT1FVRzI3cEcyN3BPJzxVUShDWU9HMjVTT09RT0xEKmFMRCphT09RVSEkKCFWISQoIVZPIyVzUVdPISQoIVZPISZkUTdbTyEkKCFWTyc8YFEwOFNPRzI2fU9PUTA3YEcyNnJHMjZyT09RVUxELVFMRC1RTyY0UVFXT0xELVFPT1FVTEQtU0xELVNPT1FVISk5RXEhKTlFcU8jJXNRV08hKTlFcU9PUVUhJCghbCEkKCFsT09RVSEuSztdIS5LO11PJz5xUShDWU9HMjZ9TyEqZlFeTycjRHlPMVBRV08nI0VXTydAZ1FyTycjSmlPISpmUV5PJyNEcU8nQG5RXk8nI0R9TydAdVFyTycjQ2hPJ0NdUXJPJyNDaE8hKmZRXk8nI0VQTydDbVFeTyw1O1ZPISpmUV5PLDU7YU8hKmZRXk8sNTthTyEqZlFeTyw1O2FPISpmUV5PLDU7YU8hKmZRXk8sNTthTyEqZlFeTyw1O2FPISpmUV5PLDU7YU8hKmZRXk8sNTthTyEqZlFeTyw1O2FPISpmUV5PLDU7YU8hKmZRXk8sNTthTyEqZlFeTycjSWlPJ0VwUVdPLDU8ZU8nRXhRN1tPLDU7YU8nR2NRN1tPLDU7YU8hKmZRXk8sNTt1TyEmZFE3W08nI0dnTydFeFE3W08nI0dnTyEmZFE3W08nI0dpTydFeFE3W08nI0dpTzFTUVdPJyNEVk8xU1FXTycjRFZPISZkUTdbTycjRnpPJ0V4UTdbTycjRnpPISZkUTdbTycjRnxPJ0V4UTdbTycjRnxPISZkUTdbTycjR1tPJ0V4UTdbTycjR1tPISpmUV5PLDU6aU8hKmZRXk8sNUBlTydDbVFeTzFHMHFPJ0dqUShDWU8nI0NoTyEqZlFeTzFHMXxPISZkUTdbTycjSW5PJ0V4UTdbTycjSW5PISZkUTdbTycjSXBPJ0V4UTdbTycjSXBPISZkUTdbTyw1PG9PJ0V4UTdbTyw1PG9PJ0NtUV5PMUcxfU8hKmZRXk83KyZ4TyEmZFE3W08xRzJaTydFeFE3W08xRzJaTyEmZFE3W08nI0luTydFeFE3W08nI0luTyEmZFE3W08nI0lwTydFeFE3W08nI0lwTyEmZFE3W08xRzJdTydFeFE3W08xRzJdTydDbVFeTzcrJ2lPJ0NtUV5PNysmXU8hJmRRN1tPQU5BY08nRXhRN1tPQU5BY08nR3RRV08nI0VrTydHeVFXTycjRWtPJ0hSUVdPJyNGWk8nSFdRV08nI0V1TydIXVFXTycjSnlPJ0hoUVdPJyNKd08nSHNRV08sNTtWTydIeFE3W08sNTxiTydJUFFXTycjR1RPJ0lVUVdPJyNHVE8nSVpRV08sNTxjTydJY1FXTyw1O1ZPJ0lrUShDWU8xRzFeTydJclFXTyw1PG9PJ0l3UVdPLDU8b08nSXxRV08sNTxxTydKUlFXTyw1PHFPJ0pXUVdPMUcxfU8nSl1RV08xRzBxTydKYlE3W088PEt3TydKaVE3W088PEt3TzdoUTdbTycjRnhPOVVRV08nI0Z3T0FdUVdPJyNFak8hKmZRXk8sNTtyTyEzZlFXTycjR1RPITNmUVdPJyNHVE8hM2ZRV08nI0dWTyEzZlFXTycjR1ZPIShTUTdbTzcrKF1PIShTUTdbTzcrKF1PJSp5UXBPMUcycU8lKnlRcE8xRzJxTyEmZFE3W08sNT1WTyEmZFE3W08sNT1WXCIsXG4gIHN0YXRlRGF0YTogXCInS21+Tyd0T1MndU9TU09TJ3ZSUX5PUFlPUVlPUmZPWCFWT2BxT2N6T2R5T2xrT25ZT29rT3BrT3ZrT3hZT3pZTyFQV08hVGtPIVVrTyFbWE8hZnVPIWtaTyFuWU8hb1lPIXBZTyFydk8hdHdPIXd4TyF7XU8jcyFQTyRUfE8lYn1PJWQhUU8lZiFPTyVnIU9PJWghT08layFSTyVtIVNPJXAhVE8lcSFUTyVzIVVPJlAhV08mViFYTyZYIVlPJlohWk8mXSFbTyZgIV1PJmYhXk8mbCFfTyZuIWBPJnAhYU8mciFiTyZ0IWNPJ3tTTyd9VE8oUVVPKFhWTyhnW08odGlPfk9WdE9+UGBPUFlPUVlPUmZPYyFqT2QhaU9sa09uWU9va09wa092a094WU96WU8hUFdPIVRrTyFVa08hWyFlTyFmdU8ha1pPIW5ZTyFvWU8hcFlPIXJ2TyF0IWdPIXchaE8kVCFrTyd7IWRPJ31UTyhRVU8oWFZPKGdbTyh0aU9+T2Ahdk9vIW5PIVAhb08hXyF4TyFgIXVPIWEhdU8hezpkTyNQIXBPI1EhcE8jUiF3TyNTIXBPI1QhcE8jVyF5TyNYIXlPJ3whbE8nfVRPKFFVTyhbIW1PKGchc09+Tyd2IXpPfk9QW1haW1hgW1huW1h8W1h9W1ghUFtYIVlbWCFoW1ghaVtYIWtbWCFvW1gjW1tYI2dlWCNqW1gja1tYI2xbWCNtW1gjbltYI29bWCNwW1gjcVtYI3JbWCN0W1gjdltYI3hbWCN5W1gkT1tYJ3JbWChYW1goaFtYKG9bWChwW1h+TyFkJHxYflAocU9eIXxPJ30jT08oTyF8TyhQI09Pfk9eI1BPKFAjT08oUSNPTyhSI1BPfk90I1JPIVIjU08oWSNTTyhaI1VPfk9QWU9RWU9SZk9jIWpPZCFpT2xrT25ZT29rT3BrT3ZrT3hZT3pZTyFQV08hVGtPIVVrTyFbIWVPIWZ1TyFrWk8hbllPIW9ZTyFwWU8hcnZPIXQhZ08hdyFoTyRUIWtPJ3s6aE8nfVRPKFFVTyhYVk8oZ1tPKHRpT35PIVgjWU8hWSNWTyFWKF9QIVYobFB+UCt9TyFaI2JPflBgT1BZT1FZT1JmT2Mhak9kIWlPbllPb2tPcGtPdmtPeFlPellPIVBXTyFUa08hVWtPIVshZU8hZnVPIWtaTyFuWU8hb1lPIXBZTyFydk8hdCFnTyF3IWhPJFQha08nfVRPKFFVTyhYVk8oZ1tPKHRpT35PbCNsTyFYI2hPIXtdTyNlI2tPI2YjaE8nezppTyFqKGlQflAuaU8hayNuTyd7I21Pfk8hdyNyTyF7XU8lYiNzT35PI2cjdE9+TyFkI3VPI2cjdE9+T1AkXU9aJGRPbiRRT3wjeU99I3pPIVAje08hWSRhTyFoJFNPIWkjd08hayN4TyFvJF1PI2okT08jayRQTyNsJFBPI20kUE8jbiRSTyNvJFNPI3AkU08jcSRjTyNyJFNPI3QkVE8jdiRWTyN4JFhPI3kkWU8oWFZPKGgkWk8obyN8TyhwI31Pfk9gKF1YJ3IoXVgncChdWCFqKF1YIVYoXVghWyhdWCVjKF1YIWQoXVh+UDFxTyNbJGVPJE8kZU9QKF5YWiheWG4oXlh8KF5YfSheWCFQKF5YIVkoXlghaCheWCFrKF5YIW8oXlgjaiheWCNrKF5YI2woXlgjbSheWCNuKF5YI28oXlgjcCheWCNxKF5YI3IoXlgjdCheWCN2KF5YI3goXlgjeSheWChYKF5YKGgoXlgobyheWChwKF5YIVsoXlglYyheWH5PYCheWCFpKF5YJ3IoXlgncCheWCFWKF5YIWooXlhyKF5YIWQoXlh+UDRYTyNbJGVPfk8kWSRnTyRbJGZPJGMkbE9+T1JmTyFbJG1PJGYkbk8kaCRwT35PZyVWT2wlV09uJHRPbyRzT3Akc092JVhPeCVZT3olWk8hUCR7TyFbJHxPIWYlYE8hayR4TyNmJWFPJFQlXk8kbyVbTyRxJV1PJHQlX08neyRyTyd9VE8oUVVPKFgkdU8obyR9TyhwJVBPZihVUH5PIWslYk9+TyFQJWVPIVslZk8neyVkT35PIWQlak9+T2Ala08nciVrT35PJ3whbE9+UCVbTyVoJXJPflAlW09nJVZPIWslYk8neyVkTyd8IWxPfk9kJXlPIWslYk8neyVkT35PI3IkU09+T3wmT08hWyV7TyFrJX1PJWQmUk8neyVkTyd8IWxPJ31UTyhRVU9fKH1Qfk8hdyNyT35PJW0mVE8hUCh5WCFbKHlYJ3soeVh+Tyd7JlVPfk8hdCZaTyNzIVBPJWQhUU8lZiFPTyVnIU9PJWghT08layFSTyVtIVNPJXAhVE8lcSFUT35PYyZgT2QmX08hdyZdTyViJl5PJXUmW09+UDt4T2MmY09keU8hWyZiTyF0JlpPIXd4TyF7XU8jcyFQTyVifU8lZiFPTyVnIU9PJWghT08layFSTyVtIVNPJXAhVE8lcSFUTyVzIVVPfk9hJmZPI1smaU8lZCZkTyd8IWxPflA8fU8hayZqTyF0Jm5Pfk8hayNuT35PIVtYT35PYCVrTydxJnZPJ3Ila09+T2Ala08ncSZ5TydyJWtPfk9gJWtPJ3Eme08nciVrT35PJ3BbWCFWW1hyW1ghaltYJlRbWCFbW1glY1tYIWRbWH5QKHFPIV8nWU8hYCdSTyFhJ1JPJ3whbE8nfVRPKFFVT35PbydQTyFQJ09PIVgnU08oWyZ9TyFaKGBQIVooblB+UEBVT2onXU8hWydaTyd7JWRPfk9kJ2JPIWslYk8neyVkT35PfCZPTyFrJX1Pfk9vIW5PIVAhb08hezpkTyNQIXBPI1EhcE8jUyFwTyNUIXBPJ3whbE8nfVRPKFFVTyhbIW1PKGchc09+TyFfJ2hPIWAnZ08hYSdnTyNSIXBPI1cnaU8jWCdpT35QQXBPYCVrT2clVk8hZCN1TyFrJWJPJ3Ila08oaCdrT35PIW8nb08jWydtT35QQ09PbyFuTyFQIW9PJ31UTyhRVU8oWyFtTyhnIXNPfk8hW1hPbyhlWCFQKGVYIV8oZVghYChlWCFhKGVYIXsoZVgjUChlWCNRKGVYI1IoZVgjUyhlWCNUKGVYI1coZVgjWChlWCd8KGVYJ30oZVgoUShlWChbKGVYKGcoZVh+TyFgJ2dPIWEnZ08nfCFsT35QQ25PJ3cnc08neCdzTyd5J3VPfk9eIXxPJ30nd08oTyF8TyhQJ3dPfk9eI1BPKFAnd08oUSd3TyhSI1BPfk90I1JPIVIjU08oWSNTTyhaJ3tPfk8hWCd9TyFWJ1BYIVYnVlghWSdQWCFZJ1ZYflArfU8hWShQTyFWKF9Yfk9QJF1PWiRkT24kUU98I3lPfSN6TyFQI3tPIVkoUE8haCRTTyFpI3dPIWsjeE8hbyRdTyNqJE9PI2skUE8jbCRQTyNtJFBPI24kUk8jbyRTTyNwJFNPI3EkY08jciRTTyN0JFRPI3YkVk8jeCRYTyN5JFlPKFhWTyhoJFpPKG8jfE8ocCN9T35PIVYoX1h+UEdiTyFWKFVPfk8hVihrWCFZKGtYIWQoa1ghaihrWChoKGtYfk8jWyhrWCNnI2BYIVooa1h+UEloTyNbKFZPIVYobVghWShtWH5PIVkoV08hVihsWH5PIVYoWk9+TyNbJGVPflBJaE8hWihbT35QYE98I3lPfSN6TyFQI3tPIWkjd08hayN4TyhYVk9QIW1hWiFtYW4hbWEhWSFtYSFoIW1hIW8hbWEjaiFtYSNrIW1hI2whbWEjbSFtYSNuIW1hI28hbWEjcCFtYSNxIW1hI3IhbWEjdCFtYSN2IW1hI3ghbWEjeSFtYShoIW1hKG8hbWEocCFtYX5PYCFtYSdyIW1hJ3AhbWEhViFtYSFqIW1hciFtYSFbIW1hJWMhbWEhZCFtYX5QS09PIWooXU9+TyFkI3VPI1soXk8oaCdrTyFZKGpYYChqWCdyKGpYfk8haihqWH5QTW5PIVAlZU8hWyVmTyF7XU8jZShjTyNmKGJPJ3slZE9+TyFZKGRPIWooaVh+TyFqKGZPfk8hUCVlTyFbJWZPI2YoYk8neyVkT35PUCheWFooXlhuKF5YfCheWH0oXlghUCheWCFZKF5YIWgoXlghaSheWCFrKF5YIW8oXlgjaiheWCNrKF5YI2woXlgjbSheWCNuKF5YI28oXlgjcCheWCNxKF5YI3IoXlgjdCheWCN2KF5YI3goXlgjeSheWChYKF5YKGgoXlgobyheWChwKF5Yfk8hZCN1TyFqKF5YflAhIFtPfChnT30oaE8haSN3TyFrI3hPIXshemEhUCF6YX5PIXchemElYiF6YSFbIXphI2UhemEjZiF6YSd7IXphflAhI2BPIXcobE9+T1BZT1FZT1JmT2Mhak9kIWlPbGtPbllPb2tPcGtPdmtPeFlPellPIVBXTyFUa08hVWtPIVtYTyFmdU8ha1pPIW5ZTyFvWU8hcFlPIXJ2TyF0IWdPIXchaE8kVCFrTyd7IWRPJ31UTyhRVU8oWFZPKGdbTyh0aU9+T2clVk9sJVdPbiR0T28kc09wJHNPdiVYT3glWU96O1FPIVAke08hWyR8TyFmPGBPIWskeE8jZjtXTyRUJV5PJG87U08kcTtVTyR0JV9PJ3socE8nfVRPKFFVTyhYJHVPKG8kfU8ocCVQT35PI2cock9+T2clVk9sJVdPbiR0T28kc09wJHNPdiVYT3glWU96JVpPIVAke08hWyR8TyFmJWBPIWskeE8jZiVhTyRUJV5PJG8lW08kcSVdTyR0JV9PJ3socE8nfVRPKFFVTyhYJHVPKG8kfU8ocCVQT35PZihiUH5QIShTTyFYKHZPIWooY1B+UCVbTyhbKHhPKGdbT35PIVAoek8hayN4TyhbKHhPKGdbT35PUDpjT1E6Y09SZk9jPFtPZCFpT2xrT246Y09va09wa092a094OmNPejpjTyFQV08hVGtPIVVrTyFbIWVPIWY6Zk8ha1pPIW46Y08hbzpjTyFwOmNPIXI6Z08hdDpqTyF3IWhPJFQha08neylZTyd9VE8oUVVPKFhWTyhnW08odDxZT35PfSldTyFrI3hPfk8hWSRhT2AkbWEnciRtYSdwJG1hIWokbWEhViRtYSFbJG1hJWMkbWEhZCRtYX5PI3MpYU9+UCEmZE98KWRPIWQpY08hWyRaWCRXJFpYJFkkWlgkWyRaWCRjJFpYfk8hZCljTyFbKHFYJFcocVgkWShxWCRbKHFYJGMocVh+T3wpZE9+UCEuT098KWRPIVsocVgkVyhxWCRZKHFYJFsocVgkYyhxWH5PIVspZk8kVylqTyRZKWVPJFspZU8kYylrT35PIVgpbk9+UCEqZk8kWSRnTyRbJGZPJGMpck9+T2okdVh8JHVYIVAkdVghaSR1WChvJHVYKHAkdVh+T2ZpWGYkdVhqaVghWWlYI1tpWH5QIS90T28pdE9+T3QpdU8oWSl2TyhaKXhPfk9qKlJPfCl6TyFQKXtPKG8kfU8ocCVQT35PZil5T35QITB9T2YqU09+T2clVk9sJVdPbiR0T28kc09wJHNPdiVYT3glWU96O1FPIVAke08hWyR8TyFmPGBPIWskeE8jZjtXTyRUJV5PJG87U08kcTtVTyR0JV9PJ31UTyhRVU8oWCR1TyhvJH1PKHAlUE9+TyFYKldPJ3sqVE8haih1UH5QITFsTyNnKllPfk8haypaT35PIVgqYE8neypdTyFWKHZQflAhMWxPbipsTyFQKmRPIV8qak8hYCpjTyFhKmNPIWsqWk8jVyprTyVZKmZPJ3whbE8oWyFtT35PIVoqaU9+UCEzeE8haSN3T2ooV1h8KFdYIVAoV1gobyhXWChwKFdYIVkoV1gjWyhXWH5PZihXWCN8KFdYflAhNHFPaipxTyNbKnBPZihWWCFZKFZYfk8hWSpyT2YoVVh+Tyd7JlVPZihVUH5PIWsqeU9+Tyd7KHBPfk9sKn1PIVAlZU8hWCNoTyFbJWZPIXtdTyNlI2tPI2YjaE8neyVkTyFqKGlQfk8hZCN1TyNnK09Pfk8hUCVlTyFYK1FPIVkoV08hWyVmTyd7JWRPIVYobFB+T28nVk8hUCtTTyFYK1JPJ31UTyhRVU8oWyh4T35PIVooblB+UCE3bE8hWStUT2Aoelgncih6WH5PUCRdT1okZE9uJFFPfCN5T30jek8hUCN7TyFoJFNPIWkjd08hayN4TyFvJF1PI2okT08jayRQTyNsJFBPI20kUE8jbiRSTyNvJFNPI3AkU08jcSRjTyNyJFNPI3QkVE8jdiRWTyN4JFhPI3kkWU8oWFZPKGgkWk8obyN8TyhwI31Pfk9gIWVhIVkhZWEnciFlYSdwIWVhIVYhZWEhaiFlYXIhZWEhWyFlYSVjIWVhIWQhZWF+UCE4ZE98I3lPfSN6TyFQI3tPIWkjd08hayN4TyhYVk9QIXFhWiFxYW4hcWEhWSFxYSFoIXFhIW8hcWEjaiFxYSNrIXFhI2whcWEjbSFxYSNuIXFhI28hcWEjcCFxYSNxIXFhI3IhcWEjdCFxYSN2IXFhI3ghcWEjeSFxYShoIXFhKG8hcWEocCFxYX5PYCFxYSdyIXFhJ3AhcWEhViFxYSFqIXFhciFxYSFbIXFhJWMhcWEhZCFxYX5QITp9T3wjeU99I3pPIVAje08haSN3TyFrI3hPKFhWT1Ahc2FaIXNhbiFzYSFZIXNhIWghc2EhbyFzYSNqIXNhI2shc2EjbCFzYSNtIXNhI24hc2EjbyFzYSNwIXNhI3Ehc2EjciFzYSN0IXNhI3Yhc2EjeCFzYSN5IXNhKGghc2EobyFzYShwIXNhfk9gIXNhJ3Ihc2EncCFzYSFWIXNhIWohc2FyIXNhIVshc2ElYyFzYSFkIXNhflAhPWhPZyVWT2orXk8hWydaTyVjK11Pfk8hZCtgT2AoVFghWyhUWCdyKFRYIVkoVFh+T2Ala08hW1hPJ3Ila09+T2clVk8hayViT35PZyVWTyFrJWJPJ3slZE9+TyFkI3VPI2cock9+T2Era08lZCtsTyd7K2hPJ31UTyhRVU8hWilPUH5PIVkrbU9fKH1Yfk9aK3FPfk9fK3JPfk8hWyV7Tyd7JWRPJ3whbE9fKH1Qfk9nJVZPI1srd09+T2clVk9qK3pPIVskfE9+TyFbK3xPfk98LE9PIVtYT35PJWglck9+TyF3LFRPfk9kLFlPfk9hLFpPJ3sjbU8nfVRPKFFVTyFaKHxQfk9kJXlPfk8lZCFRTyd7JlVPflA8fU9aLGBPXyxfT35PUFlPUVlPUmZPY3pPZHlPbGtPbllPb2tPcGtPdmtPeFlPellPIVBXTyFUa08hVWtPIWZ1TyFrWk8hbllPIW9ZTyFwWU8hcnZPIXd4TyF7XU8lYn1PJ31UTyhRVU8oWFZPKGdbTyh0aU9+TyFbIWVPIXQhZ08kVCFrTyd7IWRPflAhRGtPXyxfT2Ala08nciVrT35PUFlPUVlPUmZPYyFqT2QhaU9sa09uWU9va09wa092a094WU96WU8hUFdPIVRrTyFVa08hWyFlTyFmdU8ha1pPIW5ZTyFvWU8hcFlPIXJ2TyF3IWhPJFQha08neyFkTyd9VE8oUVVPKFhWTyhnW08odGlPfk9gLGVPIXR3TyNzIU9PJWYhT08lZyFPTyVoIU9PflAhR1RPIWsmak9+TyZWLGtPfk8hWyxtT35PJmgsb08maixwT1AmZWFRJmVhUiZlYVgmZWFgJmVhYyZlYWQmZWFsJmVhbiZlYW8mZWFwJmVhdiZlYXgmZWF6JmVhIVAmZWEhVCZlYSFVJmVhIVsmZWEhZiZlYSFrJmVhIW4mZWEhbyZlYSFwJmVhIXImZWEhdCZlYSF3JmVhIXsmZWEjcyZlYSRUJmVhJWImZWElZCZlYSVmJmVhJWcmZWElaCZlYSVrJmVhJW0mZWElcCZlYSVxJmVhJXMmZWEmUCZlYSZWJmVhJlgmZWEmWiZlYSZdJmVhJmAmZWEmZiZlYSZsJmVhJm4mZWEmcCZlYSZyJmVhJnQmZWEncCZlYSd7JmVhJ30mZWEoUSZlYShYJmVhKGcmZWEodCZlYSFaJmVhJl4mZWFhJmVhJmMmZWF+Tyd7LHVPfk9nIWJYIVkhT1ghWSFiWCFaIU9YIVohYlghZCFPWCFkIWJYIWshYlgjWyFPWH5PIWQsek8jWyx5T2coYVghWSNkWCFZKGFYIVojZFghWihhWCFkKGFYIWsoYVh+T2clVk8hZCx8TyFrJWJPIVkhXlghWiFeWH5PbyFuTyFQIW9PJ31UTyhRVU8oWyFtT35PUDpjT1E6Y09SZk9jPFtPZCFpT2xrT246Y09va09wa092a094OmNPejpjTyFQV08hVGtPIVVrTyFbIWVPIWY6Zk8ha1pPIW46Y08hbzpjTyFwOmNPIXI6Z08hdDpqTyF3IWhPJFQha08nfVRPKFFVTyhYVk8oZ1tPKHQ8WU9+Tyd7O11PflAjIVpPIVktUU8hWihgWH5PIVotU09+TyFkLHpPI1sseU8hWSNkWCFaI2RYfk8hWS1UTyFaKG5Yfk8hWi1WT35PIWAtV08hYS1XTyd8IWxPflAjIHhPIVotWk9+UCdfT2otXk8hWydaT35PIVYtY09+T28hemEhXyF6YSFgIXphIWEhemEjUCF6YSNRIXphI1IhemEjUyF6YSNUIXphI1chemEjWCF6YSd8IXphJ30hemEoUSF6YShbIXphKGchemF+UCEjYE8hby1oTyNbLWZPflBDT08hYC1qTyFhLWpPJ3whbE9+UENuT2Ala08jWy1mTydyJWtPfk9gJWtPIWQjdU8jWy1mTydyJWtPfk9gJWtPIWQjdU8hby1oTyNbLWZPJ3Ila08oaCdrT35PJ3cnc08neCdzTyd5LW9Pfk9yLXBPfk8hVidQYSFZJ1BhflAhOGRPIVgtdE8hVidQWCFZJ1BYflAlW08hWShQTyFWKF9hfk8hVihfYX5QR2JPIVkoV08hVihsYX5PIVAlZU8hWC14TyFbJWZPJ3slZE8hVidWWCFZJ1ZYfk8jWy16TyFZKGphIWooamFgKGphJ3IoamF+TyFkI3VPflAjKmFPIVkoZE8haihpYX5PIVAlZU8hWyVmTyNmLk9PJ3slZE9+T2wuVE8hUCVlTyFYLlFPIVslZk8he11PI2UuU08jZi5RTyd7JWRPIVknWVghaidZWH5PfS5YTyFrI3hPfk9nJVZPai5bTyFbJ1pPJWMuWk9+T2AjX2khWSNfaSdyI19pJ3AjX2khViNfaSFqI19pciNfaSFbI19pJWMjX2khZCNfaX5QIThkT2o8Zk98KXpPIVApe08obyR9TyhwJVBPfk8jZyNaYWAjWmEjWyNaYSdyI1phIVkjWmEhaiNaYSFbI1phIVYjWmF+UCMtXU8jZyhXWFAoV1haKFdYYChXWG4oV1h9KFdYIWgoV1ghayhXWCFvKFdYI2ooV1gjayhXWCNsKFdYI20oV1gjbihXWCNvKFdYI3AoV1gjcShXWCNyKFdYI3QoV1gjdihXWCN4KFdYI3koV1gncihXWChYKFdYKGgoV1ghaihXWCFWKFdYJ3AoV1hyKFdYIVsoV1glYyhXWCFkKFdYflAhNHFPIVkuaU9mKGJYflAhMH1PZi5rT35PIVkubE8haihjWH5QIThkTyFqLm9Pfk8hVi5xT35PUCRdT3wjeU99I3pPIVAje08haSN3TyFrI3hPIW8kXU8oWFZPWiNpaWAjaWluI2lpIVkjaWkhaCNpaSNrI2lpI2wjaWkjbSNpaSNuI2lpI28jaWkjcCNpaSNxI2lpI3IjaWkjdCNpaSN2I2lpI3gjaWkjeSNpaSdyI2lpKGgjaWkobyNpaShwI2lpJ3AjaWkhViNpaSFqI2lpciNpaSFbI2lpJWMjaWkhZCNpaX5PI2ojaWl+UCMxWE8jaiRPT35QIzFYT1AkXU98I3lPfSN6TyFQI3tPIWkjd08hayN4TyFvJF1PI2okT08jayRQTyNsJFBPI20kUE8oWFZPWiNpaWAjaWkhWSNpaSFoI2lpI24jaWkjbyNpaSNwI2lpI3EjaWkjciNpaSN0I2lpI3YjaWkjeCNpaSN5I2lpJ3IjaWkoaCNpaShvI2lpKHAjaWkncCNpaSFWI2lpIWojaWlyI2lpIVsjaWklYyNpaSFkI2lpfk9uI2lpflAjM3lPbiRRT35QIzN5T1AkXU9uJFFPfCN5T30jek8hUCN7TyFpI3dPIWsjeE8hbyRdTyNqJE9PI2skUE8jbCRQTyNtJFBPI24kUk8oWFZPYCNpaSFZI2lpI3QjaWkjdiNpaSN4I2lpI3kjaWknciNpaShoI2lpKG8jaWkocCNpaSdwI2lpIVYjaWkhaiNpaXIjaWkhWyNpaSVjI2lpIWQjaWl+T1ojaWkhaCNpaSNvI2lpI3AjaWkjcSNpaSNyI2lpflAjNmtPWiRkTyFoJFNPI28kU08jcCRTTyNxJGNPI3IkU09+UCM2a09QJF1PWiRkT24kUU98I3lPfSN6TyFQI3tPIWgkU08haSN3TyFrI3hPIW8kXU8jaiRPTyNrJFBPI2wkUE8jbSRQTyNuJFJPI28kU08jcCRTTyNxJGNPI3IkU08jdCRUTyhYVk8ocCN9T2AjaWkhWSNpaSN4I2lpI3kjaWknciNpaShoI2lpKG8jaWkncCNpaSFWI2lpIWojaWlyI2lpIVsjaWklYyNpaSFkI2lpfk8jdiRWT35QIzlsTyN2I2lpflAjOWxPUCRdT1okZE9uJFFPfCN5T30jek8hUCN7TyFoJFNPIWkjd08hayN4TyFvJF1PI2okT08jayRQTyNsJFBPI20kUE8jbiRSTyNvJFNPI3AkU08jcSRjTyNyJFNPI3QkVE8oWFZPYCNpaSFZI2lpI3gjaWkjeSNpaSdyI2lpKGgjaWkncCNpaSFWI2lpIWojaWlyI2lpIVsjaWklYyNpaSFkI2lpfk8jdiNpaShvI2lpKHAjaWl+UCM8Xk8jdiRWTyhvI3xPKHAjfU9+UCM8Xk9QJF1PWiRkT24kUU98I3lPfSN6TyFQI3tPIWgkU08haSN3TyFrI3hPIW8kXU8jaiRPTyNrJFBPI2wkUE8jbSRQTyNuJFJPI28kU08jcCRTTyNxJGNPI3IkU08jdCRUTyN2JFZPI3gkWE8oWFZPKG8jfE8ocCN9T35PYCNpaSFZI2lpI3kjaWknciNpaShoI2lpJ3AjaWkhViNpaSFqI2lpciNpaSFbI2lpJWMjaWkhZCNpaX5QIz9VT1BbWFpbWG5bWHxbWH1bWCFQW1ghaFtYIWlbWCFrW1ghb1tYI1tbWCNnZVgjaltYI2tbWCNsW1gjbVtYI25bWCNvW1gjcFtYI3FbWCNyW1gjdFtYI3ZbWCN4W1gjeVtYJE9bWChYW1goaFtYKG9bWChwW1ghWVtYIVpbWH5PI3xbWH5QI0FvT1AkXU9aOnpPbjpuT3wjeU99I3pPIVAje08haDpwTyFpI3dPIWsjeE8hbyRdTyNqOmxPI2s6bU8jbDptTyNtOm1PI246b08jbzpwTyNwOnBPI3E6eU8jcjpwTyN0OnFPI3Y6c08jeDp1TyN5OnZPKFhWTyhoJFpPKG8jfE8ocCN9T35PI3wuc09+UCNDfE8jWzp7TyRPOntPI3woXlghWiheWH5QISBbT2AnXWEhWSddYSdyJ11hJ3AnXWEhaiddYSFWJ11hciddYSFbJ11hJWMnXWEhZCddYX5QIThkT1AjaWlaI2lpYCNpaW4jaWl9I2lpIVkjaWkhaCNpaSFpI2lpIWsjaWkhbyNpaSNqI2lpI2sjaWkjbCNpaSNtI2lpI24jaWkjbyNpaSNwI2lpI3EjaWkjciNpaSN0I2lpI3YjaWkjeCNpaSN5I2lpJ3IjaWkoWCNpaShoI2lpJ3AjaWkhViNpaSFqI2lpciNpaSFbI2lpJWMjaWkhZCNpaX5QIy1dT2AjfWkhWSN9aSdyI31pJ3AjfWkhViN9aSFqI31pciN9aSFbI31pJWMjfWkhZCN9aX5QIThkTyRZLnhPJFsueE9+TyRZLnlPJFsueU9+TyFkKWNPI1suek8hWyRgWCRXJGBYJFkkYFgkWyRgWCRjJGBYfk8hWC57T35PIVspZk8kVy59TyRZKWVPJFspZU8kYy9PT35PIVk6d08hWihdWH5QI0N8TyFaL1BPfk8hZCljTyRjKHFYfk8kYy9ST35PdCl1TyhZKXZPKFovVU9+TyFWL1lPflAhJmRPKG8kfU9qJVphfCVaYSFQJVphKHAlWmEhWSVaYSNbJVphfk9mJVphI3wlWmF+UCNMXk8ocCVQT2olXWF8JV1hIVAlXWEobyVdYSFZJV1hI1slXWF+T2YlXWEjfCVdYX5QI01QTyFZZVghZGVYIWplWCFqJHVYKGhlWH5QIS90TyFqL2JPflAjLV1PIVkvY08hZCN1TyhoJ2tPIWoodVh+TyFqL2hPfk8hWCpXTyd7JWRPIWoodVB+TyNnL2pPfk8hViR1WCFZJHVYIWQkfFh+UCEvdE8hWS9rTyFWKHZYflAjLV1PIWQvbU9+TyFWL29Pfk9nJVZPbi9zTyFkI3VPIWslYk8oaCdrT35PJ3svdU9+TyFkK2BPfk9gJWtPIVkveU8nciVrT35PIVove09+UCEzeE8hYC98TyFhL3xPJ3whbE8oWyFtT35PIVAwT08oWyFtT35PI1cwUE9+T2YlWmEhWSVaYSNbJVphI3wlWmF+UCEwfU9mJV1hIVklXWEjWyVdYSN8JV1hflAhMH1PJ3smVU9mJ2ZYIVknZlh+TyFZKnJPZihVYX5PZjBZT35PfDBaT30wWk8hUDBbT2p5YShveWEocHlhIVl5YSNbeWF+T2Z5YSN8eWF+UCQkak98KXpPIVApe09qJG5hKG8kbmEocCRuYSFZJG5hI1skbmF+T2YkbmEjfCRuYX5QJCVgT3wpek8hUCl7T2okcGEobyRwYShwJHBhIVkkcGEjWyRwYX5PZiRwYSN8JHBhflAkJlJPI2cwXk9+T2YlT2EhWSVPYSNbJU9hI3wlT2F+UCEwfU8hZCN1T35PI2cwYU9+TyFZK1RPYCh6YSdyKHphfk98I3lPfSN6TyFQI3tPIWkjd08hayN4TyhYVk9QIXFpWiFxaW4hcWkhWSFxaSFoIXFpIW8hcWkjaiFxaSNrIXFpI2whcWkjbSFxaSNuIXFpI28hcWkjcCFxaSNxIXFpI3IhcWkjdCFxaSN2IXFpI3ghcWkjeSFxaShoIXFpKG8hcWkocCFxaX5PYCFxaSdyIXFpJ3AhcWkhViFxaSFqIXFpciFxaSFbIXFpJWMhcWkhZCFxaX5QJCdwT2clVk9uJHRPbyRzT3Akc092JVhPeCVZT3o7UU8hUCR7TyFbJHxPIWY8YE8hayR4TyNmO1dPJFQlXk8kbztTTyRxO1VPJHQlX08nfVRPKFFVTyhYJHVPKG8kfU8ocCVQT35PbDBrTyd7MGpPflAkKlpPIWQrYE9gKFRhIVsoVGEncihUYSFZKFRhfk8jZzBxT35PWltYIVllWCFaZVh+TyFZMHJPIVopT1h+TyFaMHRPfk9aMHVPfk9hMHdPJ3sraE8nfVRPKFFVT35PIVsle08neyVkT18nblghWSduWH5PIVkrbU9fKH1hfk8hajB6T35QIThkT1owfU9+T18xT09+TyNbMVJPfk9qMVVPIVskfE9+TyhbKHhPIVooe1B+T2clVk9qMV9PIVsxW08lYzFeT35PWjFpTyFZMWdPIVoofFh+TyFaMWpPfk9fMWxPYCVrTydyJWtPfk8neyNtTyd9VE8oUVVPfk8jWyRlTyRPJGVPUCheWFooXlhuKF5YfCheWH0oXlghUCheWCFZKF5YIWgoXlghayheWCFvKF5YI2ooXlgjayheWCNsKF5YI20oXlgjbiheWCNvKF5YI3AoXlgjcSheWCN0KF5YI3YoXlgjeCheWCN5KF5YKFgoXlgoaCheWChvKF5YKHAoXlh+TyNyMW9PJlQxcE9gKF5YIWkoXlh+UCQvcU8jWyRlTyNyMW9PJlQxcE9+T2Axck9+UCVbT2AxdE9+TyZeMXdPUCZbaVEmW2lSJltpWCZbaWAmW2ljJltpZCZbaWwmW2luJltpbyZbaXAmW2l2JltpeCZbaXomW2khUCZbaSFUJltpIVUmW2khWyZbaSFmJltpIWsmW2khbiZbaSFvJltpIXAmW2khciZbaSF0JltpIXcmW2kheyZbaSNzJltpJFQmW2klYiZbaSVkJltpJWYmW2klZyZbaSVoJltpJWsmW2klbSZbaSVwJltpJXEmW2klcyZbaSZQJltpJlYmW2kmWCZbaSZaJltpJl0mW2kmYCZbaSZmJltpJmwmW2kmbiZbaSZwJltpJnImW2kmdCZbaSdwJltpJ3smW2knfSZbaShRJltpKFgmW2koZyZbaSh0JltpIVomW2lhJltpJmMmW2l+T2ExfU8hWjF7TyZjMXxPflBgTyFbWE8hazJQT35PJmoscE9QJmVpUSZlaVImZWlYJmVpYCZlaWMmZWlkJmVpbCZlaW4mZWlvJmVpcCZlaXYmZWl4JmVpeiZlaSFQJmVpIVQmZWkhVSZlaSFbJmVpIWYmZWkhayZlaSFuJmVpIW8mZWkhcCZlaSFyJmVpIXQmZWkhdyZlaSF7JmVpI3MmZWkkVCZlaSViJmVpJWQmZWklZiZlaSVnJmVpJWgmZWklayZlaSVtJmVpJXAmZWklcSZlaSVzJmVpJlAmZWkmViZlaSZYJmVpJlomZWkmXSZlaSZgJmVpJmYmZWkmbCZlaSZuJmVpJnAmZWkmciZlaSZ0JmVpJ3AmZWkneyZlaSd9JmVpKFEmZWkoWCZlaShnJmVpKHQmZWkhWiZlaSZeJmVpYSZlaSZjJmVpfk8hVjJWT35PIVkhXmEhWiFeYX5QI0N8T28hbk8hUCFvTyFYMl1PKFshbU8hWSdRWCFaJ1FYflBAVU8hWS1RTyFaKGBhfk8hWSdXWCFaJ1dYflAhN2xPIVktVE8hWihuYX5PIVoyZE9+UCdfT2Ala08jWzJtTydyJWtPfk9gJWtPIWQjdU8jWzJtTydyJWtPfk9gJWtPIWQjdU8hbzJxTyNbMm1PJ3Ila08oaCdrT35PYCVrTydyJWtPflAhOGRPIVkkYU9yJG1hfk8hVidQaSFZJ1BpflAhOGRPIVkoUE8hVihfaX5PIVkoV08hVihsaX5PIVYobWkhWShtaX5QIThkTyFZKGppIWooamlgKGppJ3Ioaml+UCE4ZE8jWzJzTyFZKGppIWooamlgKGppJ3Ioaml+TyFZKGRPIWooaWl+TyFQJWVPIVslZk8he11PI2UyeE8jZjJ3Tyd7JWRPfk8hUCVlTyFbJWZPI2Yyd08neyVkT35PajNQTyFbJ1pPJWMzT09+T2clVk9qM1BPIVsnWk8lYzNPT35PI2clWmFQJVphWiVaYWAlWmFuJVphfSVaYSFoJVphIWklWmEhayVaYSFvJVphI2olWmEjayVaYSNsJVphI20lWmEjbiVaYSNvJVphI3AlWmEjcSVaYSNyJVphI3QlWmEjdiVaYSN4JVphI3klWmEnciVaYShYJVphKGglWmEhaiVaYSFWJVphJ3AlWmFyJVphIVslWmElYyVaYSFkJVphflAjTF5PI2clXWFQJV1hWiVdYWAlXWFuJV1hfSVdYSFoJV1hIWklXWEhayVdYSFvJV1hI2olXWEjayVdYSNsJV1hI20lXWEjbiVdYSNvJV1hI3AlXWEjcSVdYSNyJV1hI3QlXWEjdiVdYSN4JV1hI3klXWEnciVdYShYJV1hKGglXWEhaiVdYSFWJV1hJ3AlXWFyJV1hIVslXWElYyVdYSFkJV1hflAjTVBPI2clWmFQJVphWiVaYWAlWmFuJVphfSVaYSFZJVphIWglWmEhaSVaYSFrJVphIW8lWmEjaiVaYSNrJVphI2wlWmEjbSVaYSNuJVphI28lWmEjcCVaYSNxJVphI3IlWmEjdCVaYSN2JVphI3glWmEjeSVaYSdyJVphKFglWmEoaCVaYSFqJVphIVYlWmEncCVaYSNbJVphciVaYSFbJVphJWMlWmEhZCVaYX5QIy1dTyNnJV1hUCVdYVolXWFgJV1hbiVdYX0lXWEhWSVdYSFoJV1hIWklXWEhayVdYSFvJV1hI2olXWEjayVdYSNsJV1hI20lXWEjbiVdYSNvJV1hI3AlXWEjcSVdYSNyJV1hI3QlXWEjdiVdYSN4JV1hI3klXWEnciVdYShYJV1hKGglXWEhaiVdYSFWJV1hJ3AlXWEjWyVdYXIlXWEhWyVdYSVjJV1hIWQlXWF+UCMtXU8jZ3lhUHlhWnlhYHlhbnlhIWh5YSFpeWEha3lhIW95YSNqeWEja3lhI2x5YSNteWEjbnlhI295YSNweWEjcXlhI3J5YSN0eWEjdnlhI3h5YSN5eWEncnlhKFh5YShoeWEhanlhIVZ5YSdweWFyeWEhW3lhJWN5YSFkeWF+UCQkak8jZyRuYVAkbmFaJG5hYCRuYW4kbmF9JG5hIWgkbmEhaSRuYSFrJG5hIW8kbmEjaiRuYSNrJG5hI2wkbmEjbSRuYSNuJG5hI28kbmEjcCRuYSNxJG5hI3IkbmEjdCRuYSN2JG5hI3gkbmEjeSRuYSdyJG5hKFgkbmEoaCRuYSFqJG5hIVYkbmEncCRuYXIkbmEhWyRuYSVjJG5hIWQkbmF+UCQlYE8jZyRwYVAkcGFaJHBhYCRwYW4kcGF9JHBhIWgkcGEhaSRwYSFrJHBhIW8kcGEjaiRwYSNrJHBhI2wkcGEjbSRwYSNuJHBhI28kcGEjcCRwYSNxJHBhI3IkcGEjdCRwYSN2JHBhI3gkcGEjeSRwYSdyJHBhKFgkcGEoaCRwYSFqJHBhIVYkcGEncCRwYXIkcGEhWyRwYSVjJHBhIWQkcGF+UCQmUk8jZyVPYVAlT2FaJU9hYCVPYW4lT2F9JU9hIVklT2EhaCVPYSFpJU9hIWslT2EhbyVPYSNqJU9hI2slT2EjbCVPYSNtJU9hI24lT2EjbyVPYSNwJU9hI3ElT2EjciVPYSN0JU9hI3YlT2EjeCVPYSN5JU9hJ3IlT2EoWCVPYShoJU9hIWolT2EhViVPYSdwJU9hI1slT2FyJU9hIVslT2ElYyVPYSFkJU9hflAjLV1PYCNfcSFZI19xJ3IjX3EncCNfcSFWI19xIWojX3FyI19xIVsjX3ElYyNfcSFkI19xflAhOGRPZidSWCFZJ1JYflAhKFNPIVkuaU9mKGJhfk8hWDNaTyFZJ1NYIWonU1h+UCVbTyFZLmxPIWooY2F+TyFZLmxPIWooY2F+UCE4ZE8hVjNeT35PI3whbWEhWiFtYX5QS09PI3whZWEhWSFlYSFaIWVhflAjQ3xPI3whcWEhWiFxYX5QITp9TyN8IXNhIVohc2F+UCE9aE9SZk8hWzNwTyRhM3FPfk8hWjN1T35PcjN2T35QIy1dT2AkanEhWSRqcSdyJGpxJ3AkanEhViRqcSFqJGpxciRqcSFbJGpxJWMkanEhZCRqcX5QIThkTyFWM3dPflAjLV1PfCl6TyFQKXtPKHAlUE9qJ2JhKG8nYmEhWSdiYSNbJ2Jhfk9mJ2JhI3wnYmF+UCUpZU98KXpPIVApe09qJ2RhKG8nZGEocCdkYSFZJ2RhI1snZGF+T2YnZGEjfCdkYX5QJSpXTyhoJFpPflAjLV1PIVgzek8neyVkTyFZJ15YIWonXlh+TyFZL2NPIWoodWF+TyFZL2NPIWQjdU8haih1YX5PIVkvY08hZCN1TyhoJ2tPIWoodWF+T2Ykd2khWSR3aSNbJHdpI3wkd2l+UCEwfU8hWDRTTyd7Kl1PIVYnYFghWSdgWH5QITFsTyFZL2tPIVYodmF+TyFZL2tPIVYodmF+UCMtXU8hZCN1TyNyNFtPfk9uNF9PIWQjdU8oaCdrT35PKG8kfU9qJVppfCVaaSFQJVppKHAlWmkhWSVaaSNbJVppfk9mJVppI3wlWml+UCUtak8ocCVQT2olXWl8JV1pIVAlXWkobyVdaSFZJV1pI1slXWl+T2YlXWkjfCVdaX5QJS5dT2YoVmkhWShWaX5QITB9TyNbNGZPZihWaSFZKFZpflAhMH1PIWo0aU9+T2Aka3EhWSRrcSdyJGtxJ3Aka3EhViRrcSFqJGtxciRrcSFbJGtxJWMka3EhZCRrcX5QIThkTyFWNG1Pfk8hWTRuTyFbKHdYflAjLV1PIWkjd09+UDRYT2AkdVghWyR1WCVXW1gnciR1WCFZJHVYflAhL3RPJVc0cE9ga1hqa1h8a1ghUGtYIVtrWCdya1gob2tYKHBrWCFZa1h+TyVXNHBPfk9hNHZPJWQ0d08neytoTyd9VE8oUVVPIVknbVghWidtWH5PIVkwck8hWilPYX5PWjR7T35PXzR8T35PYCVrTydyJWtPflAjLV1PIVskfE9+UCMtXU8hWTVVTyNbNVdPIVooe1h+TyFaNVhPfk9vIW5PIVA1WU8hXyF4TyFgIXVPIWEhdU8hezpkTyNQIXBPI1EhcE8jUiFwTyNTIXBPI1QhcE8jVzVfTyNYIXlPJ3whbE8nfVRPKFFVTyhbIW1PKGchc09+TyFaNV5PflAlM25PajVkTyFbMVtPJWM1Y09+T2clVk9qNWRPIVsxW08lYzVjT35PYTVrTyd7I21PJ31UTyhRVU8hWSdsWCFaJ2xYfk8hWTFnTyFaKHxhfk8nfVRPKFFVTyhbNW1Pfk9fNXFPfk8jcjV0TyZUNXVPflBNbk8hajV2T35QJVtPYDV4T35PYDV4T35QJVtPYTF9TyFaNX1PJmMxfE9+UGBPIWQ2UE9+TyFkNlJPZyhhaSFZKGFpIVooYWkhZChhaSFrKGFpfk8hWSNkaSFaI2RpflAjQ3xPI1s2U08hWSNkaSFaI2Rpfk8hWSFeaSFaIV5pflAjQ3xPYCVrTyNbNl1PJ3Ila09+T2Ala08hZCN1TyNbNl1PJ3Ila09+TyFZKGpxIWooanFgKGpxJ3IoanF+UCE4ZE8hWShkTyFqKGlxfk8hUCVlTyFbJWZPI2Y2ZE8neyVkT35PIVsnWk8lYzZnT35PajZqTyFbJ1pPJWM2Z09+TyNnJ2JhUCdiYVonYmFgJ2JhbidiYX0nYmEhaCdiYSFpJ2JhIWsnYmEhbydiYSNqJ2JhI2snYmEjbCdiYSNtJ2JhI24nYmEjbydiYSNwJ2JhI3EnYmEjcidiYSN0J2JhI3YnYmEjeCdiYSN5J2JhJ3InYmEoWCdiYShoJ2JhIWonYmEhVidiYSdwJ2JhcidiYSFbJ2JhJWMnYmEhZCdiYX5QJSllTyNnJ2RhUCdkYVonZGFgJ2RhbidkYX0nZGEhaCdkYSFpJ2RhIWsnZGEhbydkYSNqJ2RhI2snZGEjbCdkYSNtJ2RhI24nZGEjbydkYSNwJ2RhI3EnZGEjcidkYSN0J2RhI3YnZGEjeCdkYSN5J2RhJ3InZGEoWCdkYShoJ2RhIWonZGEhVidkYSdwJ2RhcidkYSFbJ2RhJWMnZGEhZCdkYX5QJSpXTyNnJHdpUCR3aVokd2lgJHdpbiR3aX0kd2khWSR3aSFoJHdpIWkkd2khayR3aSFvJHdpI2okd2kjayR3aSNsJHdpI20kd2kjbiR3aSNvJHdpI3Akd2kjcSR3aSNyJHdpI3Qkd2kjdiR3aSN4JHdpI3kkd2knciR3aShYJHdpKGgkd2khaiR3aSFWJHdpJ3Akd2kjWyR3aXIkd2khWyR3aSVjJHdpIWQkd2l+UCMtXU8jZyVaaVAlWmlaJVppYCVaaW4lWml9JVppIWglWmkhaSVaaSFrJVppIW8lWmkjaiVaaSNrJVppI2wlWmkjbSVaaSNuJVppI28lWmkjcCVaaSNxJVppI3IlWmkjdCVaaSN2JVppI3glWmkjeSVaaSdyJVppKFglWmkoaCVaaSFqJVppIVYlWmkncCVaaXIlWmkhWyVaaSVjJVppIWQlWml+UCUtak8jZyVdaVAlXWlaJV1pYCVdaW4lXWl9JV1pIWglXWkhaSVdaSFrJV1pIW8lXWkjaiVdaSNrJV1pI2wlXWkjbSVdaSNuJV1pI28lXWkjcCVdaSNxJV1pI3IlXWkjdCVdaSN2JV1pI3glXWkjeSVdaSdyJV1pKFglXWkoaCVdaSFqJV1pIVYlXWkncCVdaXIlXWkhWyVdaSVjJV1pIWQlXWl+UCUuXU9mJ1JhIVknUmF+UCEwfU8hWSdTYSFqJ1NhflAhOGRPIVkubE8haihjaX5PI3wjX2khWSNfaSFaI19pflAjQ3xPUCRdT3wjeU99I3pPIVAje08haSN3TyFrI3hPIW8kXU8oWFZPWiNpaW4jaWkhaCNpaSNrI2lpI2wjaWkjbSNpaSNuI2lpI28jaWkjcCNpaSNxI2lpI3IjaWkjdCNpaSN2I2lpI3gjaWkjeSNpaSN8I2lpKGgjaWkobyNpaShwI2lpIVkjaWkhWiNpaX5PI2ojaWl+UCVGbk8jajpsT35QJUZuT1AkXU98I3lPfSN6TyFQI3tPIWkjd08hayN4TyFvJF1PI2o6bE8jazptTyNsOm1PI206bU8oWFZPWiNpaSFoI2lpI24jaWkjbyNpaSNwI2lpI3EjaWkjciNpaSN0I2lpI3YjaWkjeCNpaSN5I2lpI3wjaWkoaCNpaShvI2lpKHAjaWkhWSNpaSFaI2lpfk9uI2lpflAlSHlPbjpuT35QJUh5T1AkXU9uOm5PfCN5T30jek8hUCN7TyFpI3dPIWsjeE8hbyRdTyNqOmxPI2s6bU8jbDptTyNtOm1PI246b08oWFZPI3QjaWkjdiNpaSN4I2lpI3kjaWkjfCNpaShoI2lpKG8jaWkocCNpaSFZI2lpIVojaWl+T1ojaWkhaCNpaSNvI2lpI3AjaWkjcSNpaSNyI2lpflAlS1VPWjp6TyFoOnBPI286cE8jcDpwTyNxOnlPI3I6cE9+UCVLVU9QJF1PWjp6T246bk98I3lPfSN6TyFQI3tPIWg6cE8haSN3TyFrI3hPIW8kXU8jajpsTyNrOm1PI2w6bU8jbTptTyNuOm9PI286cE8jcDpwTyNxOnlPI3I6cE8jdDpxTyhYVk8ocCN9TyN4I2lpI3kjaWkjfCNpaShoI2lpKG8jaWkhWSNpaSFaI2lpfk8jdjpzT35QJU1wTyN2I2lpflAlTXBPUCRdT1o6ek9uOm5PfCN5T30jek8hUCN7TyFoOnBPIWkjd08hayN4TyFvJF1PI2o6bE8jazptTyNsOm1PI206bU8jbjpvTyNvOnBPI3A6cE8jcTp5TyNyOnBPI3Q6cU8oWFZPI3gjaWkjeSNpaSN8I2lpKGgjaWkhWSNpaSFaI2lpfk8jdiNpaShvI2lpKHAjaWl+UCYge08jdjpzTyhvI3xPKHAjfU9+UCYge09QJF1PWjp6T246bk98I3lPfSN6TyFQI3tPIWg6cE8haSN3TyFrI3hPIW8kXU8jajpsTyNrOm1PI2w6bU8jbTptTyNuOm9PI286cE8jcDpwTyNxOnlPI3I6cE8jdDpxTyN2OnNPI3g6dU8oWFZPKG8jfE8ocCN9T35PI3kjaWkjfCNpaShoI2lpIVkjaWkhWiNpaX5QJiReT2AjenkhWSN6eSdyI3p5J3AjenkhViN6eSFqI3p5ciN6eSFbI3p5JWMjenkhZCN6eX5QIThkT2o8Z098KXpPIVApe08obyR9TyhwJVBPfk9QI2lpWiNpaW4jaWl9I2lpIWgjaWkhaSNpaSFrI2lpIW8jaWkjaiNpaSNrI2lpI2wjaWkjbSNpaSNuI2lpI28jaWkjcCNpaSNxI2lpI3IjaWkjdCNpaSN2I2lpI3gjaWkjeSNpaSN8I2lpKFgjaWkoaCNpaSFZI2lpIVojaWl+UCYnVU8haSN3T1AoV1haKFdYaihXWG4oV1h8KFdYfShXWCFQKFdYIWgoV1ghayhXWCFvKFdYI2ooV1gjayhXWCNsKFdYI20oV1gjbihXWCNvKFdYI3AoV1gjcShXWCNyKFdYI3QoV1gjdihXWCN4KFdYI3koV1gjfChXWChYKFdYKGgoV1gobyhXWChwKFdYIVkoV1ghWihXWH5PI3wjfWkhWSN9aSFaI31pflAjQ3xPI3whcWkhWiFxaX5QJCdwTyFaNnxPfk8hWSddYSFaJ11hflAjQ3xPIWQjdU8oaCdrTyFZJ15hIWonXmF+TyFZL2NPIWoodWl+TyFZL2NPIWQjdU8haih1aX5PZiR3cSFZJHdxI1skd3EjfCR3cX5QITB9TyFWJ2BhIVknYGF+UCMtXU8hZDdUT35PIVkva08hVih2aX5QIy1dTyFZL2tPIVYodml+TyFWN1hPfk8hZCN1TyNyN15Pfk9uN19PIWQjdU8oaCdrT35PfCl6TyFQKXtPKHAlUE9qJ2NhKG8nY2EhWSdjYSNbJ2Nhfk9mJ2NhI3wnY2F+UCYuZk98KXpPIVApe09qJ2VhKG8nZWEocCdlYSFZJ2VhI1snZWF+T2YnZWEjfCdlYX5QJi9YTyFWN2FPfk9mJHlxIVkkeXEjWyR5cSN8JHlxflAhMH1PYCRreSFZJGt5J3Ika3kncCRreSFWJGt5IWoka3lyJGt5IVska3klYyRreSFkJGt5flAhOGRPIWQ2Uk9+TyFZNG5PIVsod2F+T2AjX3khWSNfeSdyI195J3AjX3khViNfeSFqI195ciNfeSFbI195JWMjX3khZCNfeX5QIThkT1o3Zk9+T2E3aE8neytoTyd9VE8oUVVPfk8hWTByTyFaKU9pfk9fN2xPfk8oWyh4TyFZJ2lYIVonaVh+TyFZNVVPIVooe2F+T2xrTyd7N3NPflAuaU8hWjd2T35QJTNuT28hbk8hUDd3Tyd9VE8oUVVPKFshbU8oZyFzT35PIVsxW09+TyFbMVtPJWM3eU9+T2o3fE8hWzFbTyVjN3lPfk9aOFJPIVknbGEhWidsYX5PIVkxZ08hWih8aX5PIWo4Vk9+TyFqOFdPfk8hajhaT35PIWo4Wk9+UCVbT2A4XU9+TyFkOF5Pfk8hajhfT35PIVkobWkhWihtaX5QI0N8T2Ala08jWzhnTydyJWtPfk8hWShqeSFqKGp5YChqeSdyKGp5flAhOGRPIVkoZE8haihpeX5PIVsnWk8lYzhqT35PI2ckd3FQJHdxWiR3cWAkd3FuJHdxfSR3cSFZJHdxIWgkd3EhaSR3cSFrJHdxIW8kd3EjaiR3cSNrJHdxI2wkd3EjbSR3cSNuJHdxI28kd3EjcCR3cSNxJHdxI3Ikd3EjdCR3cSN2JHdxI3gkd3EjeSR3cSdyJHdxKFgkd3EoaCR3cSFqJHdxIVYkd3EncCR3cSNbJHdxciR3cSFbJHdxJWMkd3EhZCR3cX5QIy1dTyNnJ2NhUCdjYVonY2FgJ2NhbidjYX0nY2EhaCdjYSFpJ2NhIWsnY2EhbydjYSNqJ2NhI2snY2EjbCdjYSNtJ2NhI24nY2EjbydjYSNwJ2NhI3EnY2EjcidjYSN0J2NhI3YnY2EjeCdjYSN5J2NhJ3InY2EoWCdjYShoJ2NhIWonY2EhVidjYSdwJ2NhcidjYSFbJ2NhJWMnY2EhZCdjYX5QJi5mTyNnJ2VhUCdlYVonZWFgJ2VhbidlYX0nZWEhaCdlYSFpJ2VhIWsnZWEhbydlYSNqJ2VhI2snZWEjbCdlYSNtJ2VhI24nZWEjbydlYSNwJ2VhI3EnZWEjcidlYSN0J2VhI3YnZWEjeCdlYSN5J2VhJ3InZWEoWCdlYShoJ2VhIWonZWEhVidlYSdwJ2VhcidlYSFbJ2VhJWMnZWEhZCdlYX5QJi9YTyNnJHlxUCR5cVokeXFgJHlxbiR5cX0keXEhWSR5cSFoJHlxIWkkeXEhayR5cSFvJHlxI2okeXEjayR5cSNsJHlxI20keXEjbiR5cSNvJHlxI3AkeXEjcSR5cSNyJHlxI3QkeXEjdiR5cSN4JHlxI3kkeXEnciR5cShYJHlxKGgkeXEhaiR5cSFWJHlxJ3AkeXEjWyR5cXIkeXEhWyR5cSVjJHlxIWQkeXF+UCMtXU8hWSdTaSFqJ1NpflAhOGRPI3wjX3EhWSNfcSFaI19xflAjQ3xPKG8kfU9QJVphWiVaYW4lWmF9JVphIWglWmEhaSVaYSFrJVphIW8lWmEjaiVaYSNrJVphI2wlWmEjbSVaYSNuJVphI28lWmEjcCVaYSNxJVphI3IlWmEjdCVaYSN2JVphI3glWmEjeSVaYSN8JVphKFglWmEoaCVaYSFZJVphIVolWmF+T2olWmF8JVphIVAlWmEocCVaYX5QJkBuTyhwJVBPUCVdYVolXWFuJV1hfSVdYSFoJV1hIWklXWEhayVdYSFvJV1hI2olXWEjayVdYSNsJV1hI20lXWEjbiVdYSNvJV1hI3AlXWEjcSVdYSNyJV1hI3QlXWEjdiVdYSN4JV1hI3klXWEjfCVdYShYJV1hKGglXWEhWSVdYSFaJV1hfk9qJV1hfCVdYSFQJV1hKG8lXWF+UCZCdU9qPGdPfCl6TyFQKXtPKHAlUE9+UCZAbk9qPGdPfCl6TyFQKXtPKG8kfU9+UCZCdU98MFpPfTBaTyFQMFtPUHlhWnlhanlhbnlhIWh5YSFpeWEha3lhIW95YSNqeWEja3lhI2x5YSNteWEjbnlhI295YSNweWEjcXlhI3J5YSN0eWEjdnlhI3h5YSN5eWEjfHlhKFh5YShoeWEob3lhKHB5YSFZeWEhWnlhfk98KXpPIVApe09QJG5hWiRuYWokbmFuJG5hfSRuYSFoJG5hIWkkbmEhayRuYSFvJG5hI2okbmEjayRuYSNsJG5hI20kbmEjbiRuYSNvJG5hI3AkbmEjcSRuYSNyJG5hI3QkbmEjdiRuYSN4JG5hI3kkbmEjfCRuYShYJG5hKGgkbmEobyRuYShwJG5hIVkkbmEhWiRuYX5PfCl6TyFQKXtPUCRwYVokcGFqJHBhbiRwYX0kcGEhaCRwYSFpJHBhIWskcGEhbyRwYSNqJHBhI2skcGEjbCRwYSNtJHBhI24kcGEjbyRwYSNwJHBhI3EkcGEjciRwYSN0JHBhI3YkcGEjeCRwYSN5JHBhI3wkcGEoWCRwYShoJHBhKG8kcGEocCRwYSFZJHBhIVokcGF+T1AlT2FaJU9hbiVPYX0lT2EhaCVPYSFpJU9hIWslT2EhbyVPYSNqJU9hI2slT2EjbCVPYSNtJU9hI24lT2EjbyVPYSNwJU9hI3ElT2EjciVPYSN0JU9hI3YlT2EjeCVPYSN5JU9hI3wlT2EoWCVPYShoJU9hIVklT2EhWiVPYX5QJidVTyN8JGpxIVkkanEhWiRqcX5QI0N8TyN8JGtxIVkka3EhWiRrcX5QI0N8TyFaOHZPfk8jfDh3T35QITB9TyFkI3VPIVknXmkhaideaX5PIWQjdU8oaCdrTyFZJ15pIWonXml+TyFZL2NPIWoodXF+TyFWJ2BpIVknYGl+UCMtXU8hWS9rTyFWKHZxfk8hVjh9T35QIy1dTyFWOH1Pfk9mKFZ5IVkoVnl+UCEwfU8hWSdnYSFbJ2dhflAjLV1PYCVWcSFbJVZxJ3IlVnEhWSVWcX5QIy1dT1o5U09+TyFZMHJPIVopT3F+TyNbOVdPIVknaWEhWidpYX5PIVk1VU8hWih7aX5QI0N8T1BbWFpbWG5bWHxbWH1bWCFQW1ghVltYIVlbWCFoW1ghaVtYIWtbWCFvW1gjW1tYI2dlWCNqW1gja1tYI2xbWCNtW1gjbltYI29bWCNwW1gjcVtYI3JbWCN0W1gjdltYI3hbWCN5W1gkT1tYKFhbWChoW1gob1tYKHBbWH5PIWQlVFgjciVUWH5QJyNgTyFbMVtPJWM5W09+Tyd9VE8oUVVPKFs5YU9+TyFZMWdPIVoofHF+TyFqOWRPfk8hajllT35PIWo5Zk9+TyFqOWZPflAlW08jWzlpTyFZI2R5IVojZHl+TyFZI2R5IVojZHl+UCNDfE8hWydaTyVjOW5Pfk8jfCN6eSFZI3p5IVojenl+UCNDfE9QJHdpWiR3aW4kd2l9JHdpIWgkd2khaSR3aSFrJHdpIW8kd2kjaiR3aSNrJHdpI2wkd2kjbSR3aSNuJHdpI28kd2kjcCR3aSNxJHdpI3Ikd2kjdCR3aSN2JHdpI3gkd2kjeSR3aSN8JHdpKFgkd2koaCR3aSFZJHdpIVokd2l+UCYnVU98KXpPIVApe08ocCVQT1AnYmFaJ2JhaidiYW4nYmF9J2JhIWgnYmEhaSdiYSFrJ2JhIW8nYmEjaidiYSNrJ2JhI2wnYmEjbSdiYSNuJ2JhI28nYmEjcCdiYSNxJ2JhI3InYmEjdCdiYSN2J2JhI3gnYmEjeSdiYSN8J2JhKFgnYmEoaCdiYShvJ2JhIVknYmEhWidiYX5PfCl6TyFQKXtPUCdkYVonZGFqJ2RhbidkYX0nZGEhaCdkYSFpJ2RhIWsnZGEhbydkYSNqJ2RhI2snZGEjbCdkYSNtJ2RhI24nZGEjbydkYSNwJ2RhI3EnZGEjcidkYSN0J2RhI3YnZGEjeCdkYSN5J2RhI3wnZGEoWCdkYShoJ2RhKG8nZGEocCdkYSFZJ2RhIVonZGF+TyhvJH1PUCVaaVolWmlqJVppbiVaaXwlWml9JVppIVAlWmkhaCVaaSFpJVppIWslWmkhbyVaaSNqJVppI2slWmkjbCVaaSNtJVppI24lWmkjbyVaaSNwJVppI3ElWmkjciVaaSN0JVppI3YlWmkjeCVaaSN5JVppI3wlWmkoWCVaaShoJVppKHAlWmkhWSVaaSFaJVppfk8ocCVQT1AlXWlaJV1paiVdaW4lXWl8JV1pfSVdaSFQJV1pIWglXWkhaSVdaSFrJV1pIW8lXWkjaiVdaSNrJV1pI2wlXWkjbSVdaSNuJV1pI28lXWkjcCVdaSNxJV1pI3IlXWkjdCVdaSN2JV1pI3glXWkjeSVdaSN8JV1pKFglXWkoaCVdaShvJV1pIVklXWkhWiVdaX5PI3wka3khWSRreSFaJGt5flAjQ3xPI3wjX3khWSNfeSFaI195flAjQ3xPIWQjdU8hWSdecSFqJ15xfk8hWS9jTyFqKHV5fk8hVidgcSFZJ2BxflAjLV1PIVY5d09+UCMtXU8hWTByTyFaKU95fk8hWTVVTyFaKHtxfk8hWzFbTyVjOk9Pfk8hajpST35PIVsnWk8lYzpXT35PUCR3cVokd3FuJHdxfSR3cSFoJHdxIWkkd3EhayR3cSFvJHdxI2okd3EjayR3cSNsJHdxI20kd3EjbiR3cSNvJHdxI3Akd3EjcSR3cSNyJHdxI3Qkd3EjdiR3cSN4JHdxI3kkd3EjfCR3cShYJHdxKGgkd3EhWSR3cSFaJHdxflAmJ1VPfCl6TyFQKXtPKHAlUE9QJ2NhWidjYWonY2FuJ2NhfSdjYSFoJ2NhIWknY2EhaydjYSFvJ2NhI2onY2EjaydjYSNsJ2NhI20nY2EjbidjYSNvJ2NhI3AnY2EjcSdjYSNyJ2NhI3QnY2EjdidjYSN4J2NhI3knY2EjfCdjYShYJ2NhKGgnY2EobydjYSFZJ2NhIVonY2F+T3wpek8hUCl7T1AnZWFaJ2VhaidlYW4nZWF9J2VhIWgnZWEhaSdlYSFrJ2VhIW8nZWEjaidlYSNrJ2VhI2wnZWEjbSdlYSNuJ2VhI28nZWEjcCdlYSNxJ2VhI3InZWEjdCdlYSN2J2VhI3gnZWEjeSdlYSN8J2VhKFgnZWEoaCdlYShvJ2VhKHAnZWEhWSdlYSFaJ2Vhfk9QJHlxWiR5cW4keXF9JHlxIWgkeXEhaSR5cSFrJHlxIW8keXEjaiR5cSNrJHlxI2wkeXEjbSR5cSNuJHlxI28keXEjcCR5cSNxJHlxI3IkeXEjdCR5cSN2JHlxI3gkeXEjeSR5cSN8JHlxKFgkeXEoaCR5cSFZJHlxIVokeXF+UCYnVU9mJV8hWiFZJV8hWiNbJV8hWiN8JV8hWn5QITB9TyFZJ2lxIVonaXF+UCNDfE8hWSNkIVohWiNkIVp+UCNDfE8jZyVfIVpQJV8hWlolXyFaYCVfIVpuJV8hWn0lXyFaIVklXyFaIWglXyFaIWklXyFaIWslXyFaIW8lXyFaI2olXyFaI2slXyFaI2wlXyFaI20lXyFaI24lXyFaI28lXyFaI3AlXyFaI3ElXyFaI3IlXyFaI3QlXyFaI3YlXyFaI3glXyFaI3klXyFaJ3IlXyFaKFglXyFaKGglXyFaIWolXyFaIVYlXyFaJ3AlXyFaI1slXyFaciVfIVohWyVfIVolYyVfIVohZCVfIVp+UCMtXU9QJV8hWlolXyFabiVfIVp9JV8hWiFoJV8hWiFpJV8hWiFrJV8hWiFvJV8hWiNqJV8hWiNrJV8hWiNsJV8hWiNtJV8hWiNuJV8hWiNvJV8hWiNwJV8hWiNxJV8hWiNyJV8hWiN0JV8hWiN2JV8hWiN4JV8hWiN5JV8hWiN8JV8hWihYJV8hWihoJV8hWiFZJV8hWiFaJV8hWn5QJidVT3IoXVh+UDFxTyd8IWxPflAhKmZPIVZlWCFZZVgjW2VYflAnI2BPUFtYWltYbltYfFtYfVtYIVBbWCFZW1ghWWVYIWhbWCFpW1gha1tYIW9bWCNbW1gjW2VYI2dlWCNqW1gja1tYI2xbWCNtW1gjbltYI29bWCNwW1gjcVtYI3JbWCN0W1gjdltYI3hbWCN5W1gkT1tYKFhbWChoW1gob1tYKHBbWH5PIWRlWCFqW1ghamVYKGhlWH5QJ0FTT1A6Y09ROmNPUmZPYzxbT2QhaU9sa09uOmNPb2tPcGtPdmtPeDpjT3o6Y08hUFdPIVRrTyFVa08hW1hPIWY6Zk8ha1pPIW46Y08hbzpjTyFwOmNPIXI6Z08hdDpqTyF3IWhPJFQha08neylZTyd9VE8oUVVPKFhWTyhnW08odDxZT35PIVk6d08hWiRtYX5PZyVWT2wlV09uJHRPbyRzT3Akc092JVhPeCVZT3o7Uk8hUCR7TyFbJHxPIWY8YU8hayR4TyNmO1hPJFQlXk8kbztUTyRxO1ZPJHQlX08neyhwTyd9VE8oUVVPKFgkdU8obyR9TyhwJVBPfk8jcylhT35QJ0V4TyFaW1ghWmVYflAnQVNPI2c6a09+TyFkI3VPI2c6a09+TyNbOntPfk8jcjpwT35PI1s7Wk8hWShtWCFaKG1Yfk8jWzp7TyFZKGtYIVooa1h+TyNnO1tPfk9mO15PflAhMH1PI2c7Y09+TyNnO2RPfk8hZCN1TyNnO2VPfk8hZCN1TyNnO1tPfk8jfDtmT35QI0N8TyNnO2dPfk8jZztoT35PI2c7bU9+TyNnO25Pfk8jZztvT35PI2c7cE9+TyN8O3FPflAhMH1PI3w7ck9+UCEwfU8haSNQI1EjUyNUI1cjZSNmI3EodCRvJHEkdCVXJWIlYyVkJWslbSVwJXElcyV1fid2UyNrIVUndCd8I2xvI2ojbW58J3UkWSd1J3skWyhbflwiLFxuICBnb3RvOiBcIiQycClTUFBQUFApVFBQKVdQKWlQKngufFBQUFA1cFBQNldQUDxTP2dQP3pQP3pQUFA/elBBeFA/elA/elA/elBBfFBQQlJQQmxQR2RQUFBHaFBQUFBHaEppUFBQSm9LalBHaFBNeFBQUFAhIVdHaFBQUEdoUEdoUCEkZkdoUCEneiEofCEpVlAhKXkhKX0hKXlQUFBQUCEtWSEofFBQIS12IS5wUCExZEdoR2ghMWkhNHMhOVkhOVkhPU9QUFAhPVZHaFBQUFBQUFBQUFBQIUBkUCFBcVBQR2ghQ1NQR2hQR2hHaEdoR2hQR2ghRGZQIUduUCFKclAhSnYhS1EhS1UhS1VQIUdrUCFLWSFLWVAhTl5QIU5iR2hHaCFOaCMjaz96UD96UD96P3pQIyR2P3o/eiMnTz96IylrP3ojK20/ej96IyxbIy5mIy5mIy5qIy5yIy5mIy56UCMuZlA/eiMvZD96IzNSP3o/ejVwUFBQIzZ2UFBQIzdhIzdhUCM3YVAjN3cjN2FQUCM3fVAjN3RQIzd0IzhiIzd0Izh8IzlTNW0pVyM5VilXUCM5XiM5XiM5XlApV1ApV1ApV1ApV1BQKVdQIzlkIzlnUCM5ZylXUCM5a1AjOW5QKVdQKVdQKVdQKVdQKVdQKVcpV1BQIzl0Izl6IzpWIzpdIzpjIzppIzpvIzp9IztUIztaIztlIztrIzt1IzxVIzxbIzx8Iz1gIz1mIz1sIz16Iz5hI0BPI0BeI0BkI0F4I0JXI0NyI0RRI0RXI0ReI0RkI0RuI0R0I0R6I0VVI0VoI0VuUFBQUFBQUFBQUCNFdFBQUFBQUFAjRmkjSXAjS1AjS1cjS2BQUFBQJCFkJCVaJCtyJCt1JCt4JCxxJCx0JCx3JC1PJC1XUFAkLV4kLWIkLlkkL1gkL10kL3FQUCQvdSQveyQwUFAkMFMkMFckMFokMVAkMWgkMlAkMlQkMlckMlokMmEkMmQkMmgkMmxSIXtSb3FPWHN0IVojYyVqJm0mbyZwJnIsaCxtMXcxelkhdVEnWi1ZMVs1XVElcHZRJXh5USZQfFEmZSFWUydSIWUtUVEnYSFpUydnIXIheFMqYyR8KmhRK2YleVErcyZSUSxYJl9RLVcnWVEtYidiUS1qJ2hRL3wqalExZixZUjtZOmclT2RPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkYSRlJWolcCV9JmYmaSZtJm8mcCZyJnYnTyddJ20nfShQKFYoXihyKHYoeil5K08rUyxlLGgsbS1eLWYtdC16LmwuczBbMGEwcTFfMW8xcDFyMXQxdzF6MXwybTJzM1o1WTVkNXQ1dTV4Nl03dzd8OF04Z1MjcF06ZCFyKVskWyRtJ1Mpbix5LHwuezJdM3A1VzZTOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XVEqdSVaUStrJXtRLFomYlEsYiZqUS5jO1FRMGgrXlEwbCtgUTB3K2xRMW4sYFEyey5bUTR2MHJRNWsxZ1E2aTNQUTZ1O1JRN2g0d1I4bTZqJnxrT1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJFskYSRlJG0laiVwJX0mZiZpJmombSZvJnAmciZ2J08nUyddJ20nfShQKFYoXihyKHYoeiluKXkrTytTK14sZSxoLG0seSx8LV4tZi10LXouWy5sLnMuezBbMGEwcTFfMW8xcDFyMXQxdzF6MXwyXTJtMnMzUDNaM3A1VzVZNWQ1dDV1NXg2UzZdNmo3dzd8OF04ZzlXOWk6YzpmOmc6ajprOmw6bTpuOm86cDpxOnI6czp0OnU6djp3Ons7WTtaO1s7XjtlO2Y7bztwPF10IW5RIXIhdSF4IXknUidZJ1onZydoJ2ktUS1XLVktajFbNV01XyR2JHNpI3UjdyRjJGQkeCR7JU8lUSVbJV0lYSl1KXspfSpQKlIqWSpgKnAqcStdK2Ardyt6LlouaS9aL2ovay9tMFEwUzBeMVIxVTFeM08zeDRTNFs0ZjRuNHA1YzZnN1Q3Xjd5OGo4dzlbOW46TzpXOnk6ejp8On07TztQO1M7VDtVO1Y7VztYO187YDthO2I7YztkO2c7aDtpO2o7aztsO207bjtxO3I8WTxiPGM8ZjxnUSZTfFEnUCFlUydWJWYtVFErayV7USxaJmJRMF0qeVEwdytsUTB8K3JRMW0sX1ExbixgUTR2MHJRNVAxT1E1azFnUTVuMWlRNW8xbFE3aDR3UTdrNHxROFU1cVE5VjdsUjliOFJybk9Yc3QhViFaI2MlaiZkJm0mbyZwJnIsaCxtMXcxelIsXSZmJnZeT1BYWXN0dXZ3eiFaIWAhZyFqIW8jUiNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJFskYSRlJG0laiVwJX0mZiZpJmombSZvJnAmciZ2J08nXSdtKFAoViheKHIodih6KW4peStPK1MrXixlLGgsbSx5LHwtXi1mLXQtei5bLmwucy57MFswYTBxMV8xbzFwMXIxdDF3MXoxfDJdMm0yczNQM1ozcDVXNVk1ZDV0NXU1eDZTNl02ajd3N3w4XThnOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8WzxdWyNbV1ojViNZJ1MnfSFTJWdtI2cjaCNrJWIlZShXKGIoYyhkK1ErUitULGQsei14Lk8uUC5RLlMyUDJ3Mng2UjZkUSVzeFEld3lTJXx8JlJRJlkhVFEnXiFoUSdgIWlRKGsjclMqViR4KlpTK2UleCV5UStpJXtRLFMmXVEsVyZfUy1hJ2EnYlEuXihsUS9nKldRMHArZlEwditsUTB4K21RMHsrcVExYSxUUzFlLFgsWVEyaS1iUTN5L2NRNHUwclE0eTB1UTVPMH1RNWoxZlE3UTN6UTdnNHdRN2o0e1E5UjdmUjl5OVMhTyR6aSN3JU8lUSVbJV0lYSl9KlAqWSpwKnEuaS9qMFEwUzBeM3g0Zjh3PFk8YjxjIVMldXkhaSF0JXcleCV5J1EnYCdhJ2InZidwKmIrZStmLH0tYS1iLWkvdDBwMmIyaTJwNF5RK18lc1EreCZWUSt7JldRLFYmX1EuXShrUTFgLFNVMWQsVyxYLFlRM1EuXlE1ZTFhUzVpMWUxZlE4UTVqI1c8XiN1JGMkZCR4JHspdSl7KlIqYCtdK2Ardyt6LlovWi9rL20xUjFVMV4zTzRTNFs0bjRwNWM2ZzdUN143eThqOVs5bjpPOlc6fDtPO1M7VTtXO187YTtjO2c7aTtrO207cTxmPGdvPF86eTp6On07UDtUO1Y7WDtgO2I7ZDtoO2o7bDtuO3JXJVRpJVYqcjxZUyZWIVEmZFEmVyFSUSZYIVNSK3YmVCR3JVNpI3UjdyRjJGQkeCR7JU8lUSVbJV0lYSl1KXspfSpQKlIqWSpgKnAqcStdK2Ardyt6LlouaS9aL2ovay9tMFEwUzBeMVIxVTFeM08zeDRTNFs0ZjRuNHA1YzZnN1Q3Xjd5OGo4dzlbOW46TzpXOnk6ejp8On07TztQO1M7VDtVO1Y7VztYO187YDthO2I7YztkO2c7aDtpO2o7aztsO207bjtxO3I8WTxiPGM8ZjxnVCl2JHUpd1YqdiVaO1E7UlUnViFlJWYtVFMoeSN5I3pRK3AmT1MuVihnKGhRMVYrfFE0ZzBaUjdwNVUmfGtPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkWyRhJGUkbSVqJXAlfSZmJmkmaiZtJm8mcCZyJnYnTydTJ10nbSd9KFAoViheKHIodih6KW4peStPK1MrXixlLGgsbSx5LHwtXi1mLXQtei5bLmwucy57MFswYTBxMV8xbzFwMXIxdDF3MXoxfDJdMm0yczNQM1ozcDVXNVk1ZDV0NXU1eDZTNl02ajd3N3w4XThnOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XSRpJGBjI1gjZCVuJW8lcSd8KFMobih1KH0pTylQKVEpUilTKVQpVSlWKVcpWClaKV4pYilsK1orby1PLW0tci13LXkuaC5uLnIudC51LnYvVjBfMlcyWjJrMnIzWTNfM2AzYTNiM2MzZDNlM2YzZzNoM2kzajNrM24zbzN0NGs0czZVNls2YTZvNnA2eTZ6N3I4YThlOG44dDh1OWs5ezpTOmU8UFQjU1YjVCZ9a09QV1hZWnN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRbJGEkZSRtJWolcCV9JmYmaSZqJm0mbyZwJnImdidPJ1MnXSdtJ30oUChWKF4ocih2KHopbil5K08rUyteLGUsaCxtLHksfC1eLWYtdC16LlsubC5zLnswWzBhMHExXzFvMXAxcjF0MXcxejF8Ml0ybTJzM1AzWjNwNVc1WTVkNXQ1dTV4NlM2XTZqN3c3fDhdOGc5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdUSdUIWVSMl4tUXYhblEhZSFyIXUheCF5J1InWSdaJ2cnaCdpLVEtVy1ZLWoxWzVdNV9TKmIkfCpoUy90KmMqalEvfSprUTFYLE9RNF4vfFI0YTBQbnFPWHN0IVojYyVqJm0mbyZwJnIsaCxtMXcxelEmdCFeUSdxIXdTKG0jdDprUStjJXZRLFEmWVEsUiZbUS1fJ19RLWwnalMuZyhyO1tTMGArTztlUTBuK2RRMVosUFEyTyxvUTJRLHBRMlkse1EyZy1gUTJqLWRTNGwwYTtvUTRxMG9TNHQwcTtwUTZUMltRNlgyaFE2XjJvUTdlNHJROGI2VlE4YzZZUThmNl9SOWg4XyRkJF9jI1gjZCVvJXEnfChTKG4odSh9KU8pUClRKVIpUylUKVUpVilXKVgpWileKWIpbCtaK28tTy1tLXItdy15Lmgubi5yLnUudi9WMF8yVzJaMmsycjNZM18zYDNhM2IzYzNkM2UzZjNnM2gzaTNqM2szbjNvM3Q0azRzNlU2WzZhNm82cDZ5Nno3cjhhOGU4bjh0OHU5azl7OlM6ZTxQUyhqI28nZFUqbyVSKHEzbVMrWSVuLnRRMnwwaFE2ZjJ7UThsNmlSOW84bSRkJF5jI1gjZCVvJXEnfChTKG4odSh9KU8pUClRKVIpUylUKVUpVilXKVgpWileKWIpbCtaK28tTy1tLXItdy15Lmgubi5yLnUudi9WMF8yVzJaMmsycjNZM18zYDNhM2IzYzNkM2UzZjNnM2gzaTNqM2szbjNvM3Q0azRzNlU2WzZhNm82cDZ5Nno3cjhhOGU4bjh0OHU5azl7OlM6ZTxQUyhpI28nZFMoeyN6JF9TK1glbi50Uy5XKGgoalEudyldUTBlK1lSMnkuWCZ8a09QV1hZWnN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRbJGEkZSRtJWolcCV9JmYmaSZqJm0mbyZwJnImdidPJ1MnXSdtJ30oUChWKF4ocih2KHopbil5K08rUyteLGUsaCxtLHksfC1eLWYtdC16LlsubC5zLnswWzBhMHExXzFvMXAxcjF0MXcxejF8Ml0ybTJzM1AzWjNwNVc1WTVkNXQ1dTV4NlM2XTZqN3c3fDhdOGc5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdUyNwXTpkUSZvIVhRJnAhWVEmciFbUSZzIV1SMXYsa1EnWyFoUStbJXNRLV0nXlMuWShrK19RMmUtW1cyfS5dLl4wZzBpUTZXMmZVNmUyejJ8M1FTOGk2ZjZoUzltOGs4bFM6VTlsOW9ROl46VlI6YTpfVSF2USdaLVlUNVoxWzVdIVFfT1haYHN0IVYhWiNjI2clYiVqJmQmZiZtJm8mcCZyKGQsaCxtLlAxdzF6XSFwUSFyJ1otWTFbNV1UI3BdOmQlWXtPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkYSRlJWolcCV9JmYmaSZqJm0mbyZwJnImdidPJ10nbSd9KFAoViheKHIodih6KXkrTytTK14sZSxoLG0tXi1mLXQtei5bLmwuczBbMGEwcTFfMW8xcDFyMXQxdzF6MXwybTJzM1AzWjVZNWQ1dDV1NXg2XTZqN3c3fDhdOGdTKHkjeSN6Uy5WKGcoaCFzO3YkWyRtJ1Mpbix5LHwuezJdM3A1VzZTOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XVkhdFEnWi1ZMVs1XVEnZiFyUydwIXUheFMnciF5NV9TLWknZydoUS1rJ2lSMnAtalEnbyF0UyhgI2YxcVMtaCdmJ3JRL2YqVlEvcipiUTJxLWtRNE8vZ1M0WC9zL31RN1AzeVM3WzRfNGFROHk3UVI5UTdfUSN2YlEnbiF0UyhfI2YxcVMoYSNsKn1RK1AlY1ErYSV0UStnJXpVLWcnZidvJ3JRLXsoYFEvZSpWUS9xKmJRL3cqZVEwbStiUTFiLFVTMm4taC1rUTJ2LlRTM30vZi9nUzRXL3IvfVE0Wi92UTRdL3hRNWcxY1E2YDJxUTdPM3lRN1M0T1M3VzRYNGFRN100YFE4TzVoUzh4N1A3UVE4fDdYUTlPN1tROV84UFE5dTh5UTl2OH1ROXg5UVE6UTlgUTpZOXdRO3k7dFE8VTt9UjxWPE9WIXZRJ1otWSVZYU9QV1hZWnN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRhJGUlaiVwJX0mZiZpJmombSZvJnAmciZ2J08nXSdtJ30oUChWKF4ocih2KHopeStPK1MrXixlLGgsbS1eLWYtdC16LlsubC5zMFswYTBxMV8xbzFwMXIxdDF3MXoxfDJtMnMzUDNaNVk1ZDV0NXU1eDZdNmo3dzd8OF04Z1MjdnohaiFyO3MkWyRtJ1Mpbix5LHwuezJdM3A1VzZTOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XVI7eTxbJVliT1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJGEkZSVqJXAlfSZmJmkmaiZtJm8mcCZyJnYnTyddJ20nfShQKFYoXihyKHYoeil5K08rUyteLGUsaCxtLV4tZi10LXouWy5sLnMwWzBhMHExXzFvMXAxcjF0MXcxejF8Mm0yczNQM1o1WTVkNXQ1dTV4Nl02ajd3N3w4XThnUSVjaiFTJXR5IWkhdCV3JXgleSdRJ2AnYSdiJ2YncCpiK2UrZix9LWEtYi1pL3QwcDJiMmkycDReUyV6eiFqUStiJXVRLFUmX1cxYyxWLFcsWCxZVTVoMWQxZTFmUzhQNWk1alE5YDhRIXI7dCRbJG0nUyluLHksfC57Ml0zcDVXNlM5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdUTt9PFpSPE88WyR8ZU9QWFlzdHV2dyFaIWAhZyFvI1IjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRhJGUlaiVwJX0mZiZpJm0mbyZwJnImdidPJ10nbShQKFYoXihyKHYoeil5K08rUyteLGUsaCxtLV4tZi10LXouWy5sLnMwWzBhMHExXzFvMXAxcjF0MXcxejF8Mm0yczNQM1o1WTVkNXQ1dTV4Nl02ajd3N3w4XThnWSNhV1ojViNZJ30hUyVnbSNnI2gjayViJWUoVyhiKGMoZCtRK1IrVCxkLHoteC5PLlAuUS5TMlAydzJ4NlI2ZFEsYyZqIXA7dSRbJG0pbix5LHwuezJdM3A1VzZTOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XVI7eCdTUydXIWUlZlIyYC1UJU9kT1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJGEkZSVqJXAlfSZmJmkmbSZvJnAmciZ2J08nXSdtJ30oUChWKF4ocih2KHopeStPK1MsZSxoLG0tXi1mLXQtei5sLnMwWzBhMHExXzFvMXAxcjF0MXcxejF8Mm0yczNaNVk1ZDV0NXU1eDZdN3c3fDhdOGchcilbJFskbSdTKW4seSx8LnsyXTNwNVc2UzlXOWk6YzpmOmc6ajprOmw6bTpuOm86cDpxOnI6czp0OnU6djp3Ons7WTtaO1s7XjtlO2Y7bztwPF1RLGImalEwaCteUTJ7LltRNmkzUFI4bTZqIWIkVWMjWCVuJ3woUyhuKHUpVylYKV4pYitvLW0tci13LXkuaC5uL1YwXzJrMnIzWTNrNGs0czZbNmE2bzhlOWs6ZSFQOnIpWilsLU8udDJXMlozXzNpM2ozbjN0NlU2cDZ5Nno3cjhhOG44dDh1OXs6UzxQIWYkV2MjWCVuJ3woUyhuKHUpVClVKVcpWCleKWIrby1tLXItdy15Lmgubi9WMF8yazJyM1kzazRrNHM2WzZhNm84ZTlrOmUhVDp0KVopbC1PLnQyVzJaM18zZjNnM2kzajNuM3Q2VTZwNnk2ejdyOGE4bjh0OHU5ezpTPFAhXiRbYyNYJW4nfChTKG4odSleKWIrby1tLXItdy15Lmgubi9WMF8yazJyM1kzazRrNHM2WzZhNm84ZTlrOmVRM3gvYXo8XSlaKWwtTy50MlcyWjNfM24zdDZVNnA2eTZ6N3I4YThuOHQ4dTl7OlM8UFE8YjxkUjxjPGUmfGtPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkWyRhJGUkbSVqJXAlfSZmJmkmaiZtJm8mcCZyJnYnTydTJ10nbSd9KFAoViheKHIodih6KW4peStPK1MrXixlLGgsbSx5LHwtXi1mLXQtei5bLmwucy57MFswYTBxMV8xbzFwMXIxdDF3MXoxfDJdMm0yczNQM1ozcDVXNVk1ZDV0NXU1eDZTNl02ajd3N3w4XThnOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XVMkbmgkb1IzcS56J1RnT1BXWFlaaHN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRbJGEkZSRtJG8laiVwJX0mZiZpJmombSZvJnAmciZ2J08nUyddJ20nfShQKFYoXihyKHYoeiluKXkrTytTK14sZSxoLG0seSx8LV4tZi10LXouWy5sLnMuei57MFswYTBxMV8xbzFwMXIxdDF3MXoxfDJdMm0yczNQM1ozcDVXNVk1ZDV0NXU1eDZTNl02ajd3N3w4XThnOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XVQkamYkcFEkaGZTKWUkaylpUilxJHBUJGlmJHBUKWckaylpJ1RoT1BXWFlaaHN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRbJGEkZSRtJG8laiVwJX0mZiZpJmombSZvJnAmciZ2J08nUyddJ20nfShQKFYoXihyKHYoeiluKXkrTytTK14sZSxoLG0seSx8LV4tZi10LXouWy5sLnMuei57MFswYTBxMV8xbzFwMXIxdDF3MXoxfDJdMm0yczNQM1ozcDVXNVk1ZDV0NXU1eDZTNl02ajd3N3w4XThnOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XVQkbmgkb1EkcWhSKXAkbyVZak9QV1hZWnN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRhJGUlaiVwJX0mZiZpJmombSZvJnAmciZ2J08nXSdtJ30oUChWKF4ocih2KHopeStPK1MrXixlLGgsbS1eLWYtdC16LlsubC5zMFswYTBxMV8xbzFwMXIxdDF3MXoxfDJtMnMzUDNaNVk1ZDV0NXU1eDZdNmo3dzd8OF04ZyFzPFokWyRtJ1Mpbix5LHwuezJdM3A1VzZTOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XSNjbE9QWFpzdCFaIWAhbyNSI2MjbiN7JG0laiZmJmkmaiZtJm8mcCZyJnYnTyddKHopbitTK14sZSxoLG0tXi5bLnswWzFfMW8xcDFyMXQxdzF6MXwzUDNwNVk1ZDV0NXU1eDZqN3c3fDhdIU8lUmkjdyVPJVElWyVdJWEpfSpQKlkqcCpxLmkvajBRMFMwXjN4NGY4dzxZPGI8YyNXKHEjdSRjJGQkeCR7KXUpeypSKmArXStgK3crei5aL1ovay9tMVIxVTFeM080UzRbNG40cDVjNmc3VDdeN3k4ajlbOW46TzpXOnw7TztTO1U7VztfO2E7YztnO2k7azttO3E8ZjxnUSp6JV9RL1cpem8zbTp5Ono6fTtQO1Q7VjtYO2A7YjtkO2g7ajtsO247ciFPJHlpI3clTyVRJVslXSVhKX0qUCpZKnAqcS5pL2owUTBTMF4zeDRmOHc8WTxiPGNRKlskelMqZSR8KmhRKnslYFEveCpmI1c7eyN1JGMkZCR4JHspdSl7KlIqYCtdK2Ardyt6LlovWi9rL20xUjFVMV4zTzRTNFs0bjRwNWM2ZzdUN143eThqOVs5bjpPOlc6fDtPO1M7VTtXO187YTtjO2c7aTtrO207cTxmPGduO3w6eTp6On07UDtUO1Y7WDtgO2I7ZDtoO2o7bDtuO3JRPFE8XlE8UjxfUTxTPGBSPFQ8YSFPJVJpI3clTyVRJVslXSVhKX0qUCpZKnAqcS5pL2owUTBTMF4zeDRmOHc8WTxiPGMjVyhxI3UkYyRkJHgkeyl1KXsqUipgK10rYCt3K3ouWi9aL2svbTFSMVUxXjNPNFM0WzRuNHA1YzZnN1Q3Xjd5OGo5WzluOk86Vzp8O087UztVO1c7XzthO2M7ZztpO2s7bTtxPGY8Z28zbTp5Ono6fTtQO1Q7VjtYO2A7YjtkO2g7ajtsO247cm5vT1hzdCFaI2MlaiZtJm8mcCZyLGgsbTF3MXpRKl8ke1EsdiZ5USx3JntSNFIvayR2JVNpI3UjdyRjJGQkeCR7JU8lUSVbJV0lYSl1KXspfSpQKlIqWSpgKnAqcStdK2Ardyt6LlouaS9aL2ovay9tMFEwUzBeMVIxVTFeM08zeDRTNFs0ZjRuNHA1YzZnN1Q3Xjd5OGo4dzlbOW46TzpXOnk6ejp8On07TztQO1M7VDtVO1Y7VztYO187YDthO2I7YztkO2c7aDtpO2o7aztsO207bjtxO3I8WTxiPGM8ZjxnUSt5JldRMVQre1E1UzFTUjdvNVRUKmckfCpoUypnJHwqaFQ1WzFbNV1TL3YqZDVZVDRgME83d1ErYSV0US93KmVRMG0rYlExYixVUTVnMWNROE81aFE5XzhQUjpROWAhTyVPaSN3JU8lUSVbJV0lYSl9KlAqWSpwKnEuaS9qMFEwUzBeM3g0Zjh3PFk8Yjxjcil9JHYocypPKm4qfC9pMFUwVjNXNFA0ajZ9N2A5dDt6PFc8WFMwUSptMFIjVzp8I3UkYyRkJHgkeyl1KXsqUipgK10rYCt3K3ouWi9aL2svbTFSMVUxXjNPNFM0WzRuNHA1YzZnN1Q3Xjd5OGo5WzluOk86Vzp8O087UztVO1c7XzthO2M7ZztpO2s7bTtxPGY8Z246fTp5Ono6fTtQO1Q7VjtYO2A7YjtkO2g7ajtsO247ciFeO18obylgKlUqXi5fLmIuZi9TL1gvYS9uMGYxUTFTM1Q0UTRVNVI1VDZrNm43VTdZN2I3ZDh7OVA6WDxkPGVgO2AzbDZxNnQ2eDhvOXA5czpiUztpLmEzVVQ7ajZzOHIhTyVRaSN3JU8lUSVbJV0lYSl9KlAqWSpwKnEuaS9qMFEwUzBeM3g0Zjh3PFk8YjxjdipQJHYocypRKm0qfC9dL2kwVTBWM1c0UDRiNGo2fTdgOXQ7ejxXPFhTMFMqbjBUI1c7TyN1JGMkZCR4JHspdSl7KlIqYCtdK2Ardyt6LlovWi9rL20xUjFVMV4zTzRTNFs0bjRwNWM2ZzdUN143eThqOVs5bjpPOlc6fDtPO1M7VTtXO187YTtjO2c7aTtrO207cTxmPGduO1A6eTp6On07UDtUO1Y7WDtgO2I7ZDtoO2o7bDtuO3IhYjthKG8pYCpVKl4uYC5hLmYvUy9YL2EvbjBmMVExUzNSM1Q0UTRVNVI1VDZrNmw2bjdVN1k3YjdkOHs5UDpYPGQ8ZWQ7YjNsNnI2czZ4OG84cDlwOXE5czpiUztrLmIzVlQ7bDZ0OHNybk9Yc3QhViFaI2MlaiZkJm0mbyZwJnIsaCxtMXcxelEmYSFVUixlJmpybk9Yc3QhViFaI2MlaiZkJm0mbyZwJnIsaCxtMXcxelImYSFVUSt9JlhSMVArdnNuT1hzdCFWIVojYyVqJmQmbSZvJnAmcixoLG0xdzF6UTFdLFNTNWIxYDFhVTd4NWA1YTVlUzlaN3o3e1M5fDlZOV1ROlo5fVI6YDpbUSZoIVZSLF4mZFI1bjFpUyV8fCZSUjB4K21RJm0hV1IsaCZuUixuJnNUMXgsbTF6UixyJnRRLHEmdFIyUixyUSd0IXpSLW4ndFNzT3RRI2NYVCVtcyNjUSF9VFIndiF9USNRVVIneCNRUSl3JHVSL1Qpd1EjVFZSJ3ojVFEjV1dVKFEjVyhSLXVRKFIjWFItdShTUS1SJ1RSMl8tUlEuaihzUjNYLmpRLm0odVMzWy5tM11SM10ublEtWSdaUjJjLVlZIXJRJ1otWTFbNV1SJ2UhclMjXlclZVUoWCNeKFktdlEoWSNfUi12KFRRLVUnV1IyYS1VdGBPWHN0IVYhWiNjJWomZCZmJm0mbyZwJnIsaCxtMXcxelMjZ1olYlUjcWAjZy5QUi5QKGRRKGUjaVEtfChhVy5VKGUtfDJ0NmJRMnQtfVI2YjJ1USlpJGtSLnwpaVEkb2hSKW8kb1EkYmNVKV8kYi1xOnhRLXE6ZVI6eClsUS9kKlZXM3svZDN8N1I4elUzfC9lL2YvZ1M3UjN9NE9SOHo3UyRYKXwkdihvKHMpYCpVKl4qbSpuKncqeCp8LmEuYi5kLmUuZi9TL1gvXS9fL2EvaS9uMFUwVjBmMVExUzNSM1MzVDNXM2w0UDRRNFU0YjRkNGo1UjVUNms2bDZtNm42czZ0NnY2dzZ4Nn03VTdZN2A3YjdkOG84cDhxOHs5UDlwOXE5cjlzOXQ6WDpiO3o8VzxYPGQ8ZVEvbCpeVTRUL2w0VjdWUTRWL25SN1Y0VVEqaCR8Ui96KmhyKk8kdihzKm0qbip8L2kwVTBWM1c0UDRqNn03YDl0O3o8VzxYIV4uXyhvKWAqVSpeLmEuYi5mL1MvWC9hL24wZjFRMVMzVDRRNFU1UjVUNms2bjdVN1k3YjdkOHs5UDpYPGQ8ZVUvXipPLl82cWE2cTNsNnM2dDZ4OG85cDlzOmJRMFIqbVEzVS5hVTRjMFIzVThyUjhyNnN2KlEkdihzKm0qbip8L10vaTBVMFYzVzRQNGI0ajZ9N2A5dDt6PFc8WCFiLmAobylgKlUqXi5hLmIuZi9TL1gvYS9uMGYxUTFTM1IzVDRRNFU1UjVUNms2bDZuN1U3WTdiN2Q4ezlQOlg8ZDxlVS9gKlEuYDZyZTZyM2w2czZ0Nng4bzhwOXA5cTlzOmJRMFQqblEzVi5iVTRlMFQzVjhzUjhzNnRRKnMlVVIwWCpzUTRvMGZSN2M0b1ErVSVoUjBkK1VRNVYxVlM3cTVWOVhSOVg3clEsUCZZUjFZLFBRNV0xW1I3dTVdUTFoLFpTNWwxaDhTUjhTNW5RMHMraVc0eDBzNHo3aTlUUTR6MHZRN2k0eVI5VDdqUStuJXxSMHkrblExeixtUjV8MXpZck9Yc3QjY1EmcSFaUStXJWpRLGcmbVEsaSZvUSxqJnBRLGwmclExdSxoUzF4LG0xelI1ezF3USVscFEmdSFfUSZ4IWFRJnohYlEmfCFjUSdsIXRRK1YlaVErYyV2USt1JlNRLF0maFEsdCZ3Vy1lJ2YnbidvJ3JRLWwnalEveSpnUTBuK2RTMWssXixhUTJTLHNRMlQsdlEyVSx3UTJqLWRXMmwtZy1oLWstbVE0cTBvUTR9MHxRNVExUVE1ZjFiUTVwMW1RNXoxdlU2WjJrMm4ycVE2XjJvUTdlNHJRN201UFE3bjVSUTd0NVtRN301Z1E4VDVvUzhkNls2YFE4ZjZfUTlVN2tROV44T1E5YzhVUTlqOGVROXo5VlE6UDlfUTpUOWtSOl06UVEldnlRJ18haVEnaiF0VStkJXcleCV5USx7J1FVLWAnYCdhJ2JTLWQnZidwUS9wKmJTMG8rZStmUTJbLH1TMmgtYS1iUTJvLWlRNFkvdFE0cjBwUTZWMmJRNlkyaVE2XzJwUjdaNF5TJHdpPFlSKnQlVlUlVWklVjxZUjBXKnJRJHZpUyhvI3UrYFEocyN3UylgJGMkZFEqVSR4USpeJHtRKm0lT1EqbiVRUSp3JVtRKnglXVEqfCVhUS5hOnxRLmI7T1EuZDtTUS5lO1VRLmY7V1EvUyl1Uy9YKXsvWlEvXSl9US9fKlBRL2EqUlEvaSpZUS9uKmBRMFUqcFEwVipxaDBmK10uWjFeM081YzZnN3k4ajlbOW46TzpXUTFRK3dRMVMrelEzUjtfUTNTO2FRM1Q7Y1EzVy5pUzNsOnk6elE0UC9qUTRRL2tRNFUvbVE0YjBRUTRkMFNRNGowXlE1UjFSUTVUMVVRNms7Z1E2bDtpUTZtO2tRNm47bVE2czp9UTZ0O1BRNnY7VFE2dztWUTZ4O1hRNn0zeFE3VTRTUTdZNFtRN2A0ZlE3YjRuUTdkNHBROG87ZFE4cDtgUThxO2JROHs3VFE5UDdeUTlwO2hROXE7alE5cjtsUTlzO25ROXQ4d1E6WDtxUTpiO3JRO3o8WVE8VzxiUTxYPGNRPGQ8ZlI8ZTxnbnBPWHN0IVojYyVqJm0mbyZwJnIsaCxtMXcxelEhZlBTI2VaI25RJnchYFUnYyFvNVk3d1EneSNSUSh8I3tRKW0kbVMsYSZmJmlRLGYmalEscyZ2USx4J09RLVsnXVEucCh6US9RKW5RMGIrU1EwaSteUTFzLGVRMmYtXlEyfC5bUTNzLntRNGgwW1E1YTFfUTVyMW9RNXMxcFE1dzFyUTV5MXRRNk8xfFE2ZjNQUTZ7M3BRN3s1ZFE4WDV0UThZNXVROFs1eFE4bDZqUTldN3xSOWc4XSNXY09QWFpzdCFaIWAhbyNjI24jeyVqJmYmaSZqJm0mbyZwJnImdidPJ10oeitTK14sZSxoLG0tXi5bMFsxXzFvMXAxcjF0MXcxejF8M1A1WTVkNXQ1dTV4Nmo3dzd8OF1RI1hXUSNkWVElbnVRJW92UyVxdyFnUyd8I1YoUFEoUyNZUShuI3RRKHUjeFEofSRPUSlPJFBRKVAkUVEpUSRSUSlSJFNRKVMkVFEpVCRVUSlVJFZRKVYkV1EpVyRYUSlYJFlRKVokW1EpXiRhUSliJGVXKWwkbSluLnszcFErWiVwUStvJX1TLU8nUzJdUS1tJ21TLXInfS10US13KFZRLXkoXlEuaChyUS5uKHZRLnI6Y1EudDpmUS51OmdRLnY6alEvVil5UTBfK09RMlcseVEyWix8UTJrLWZRMnItelEzWS5sUTNfOmtRM2A6bFEzYTptUTNiOm5RM2M6b1EzZDpwUTNlOnFRM2Y6clEzZzpzUTNoOnRRM2k6dVEzajp2UTNrLnNRM246e1EzbztZUTN0OndRNGswYVE0czBxUTZVO1pRNlsybVE2YTJzUTZvM1pRNnA7W1E2eTteUTZ6O2VRN3I1V1E4YTZTUThlNl1ROG47ZlE4dDtvUTh1O3BROWs4Z1E5ezlXUTpTOWlROmUjUlI8UDxdUiNaV1InVSFlWSF0USdaLVkxWzVdUydRIWUtUVEnZiFyUydwIXUheFMnciF5NV9TLH0nUidZUy1pJ2cnaFEtaydpUTJiLVdSMnAtalIodCN3Uih3I3hRIWZRVC1YJ1otWV0hcVEhcidaLVkxWzVdUSNvXVInZDpkVCNqWiViUyNpWiViUyVobSxkVShhI2cjaCNrUy19KGIoY1EuUihkUTBjK1RRMnUuT1Uydi5QLlEuU1M2YzJ3MnhSOGg2ZGAjXVcjViNZJWUnfShXK1EteHIjZlptI2cjaCNrJWIoYihjKGQrVC5PLlAuUS5TMncyeDZkUTFxLGRRMlgselE2UTJQUThgNlJUO3cnUytSVCNgVyVlUyNfVyVlUyhPI1YoV1MoVCNZK1FTLVAnUytSVC1zJ30teFQnWCFlJWZRJGtmUilzJHBUKWgkaylpUjNyLnpUKlgkeCpaUiphJHtRMGcrXVEyei5aUTVgMV5RNmgzT1E3ejVjUThrNmdROVk3eVE5bDhqUTl9OVtROlY5blE6WzpPUjpfOlducU9Yc3QhWiNjJWombSZvJnAmcixoLG0xdzF6USZnIVZSLF0mZHRtT1hzdCFVIVYhWiNjJWomZCZtJm8mcCZyLGgsbTF3MXpSLGQmalQlaW0sZFIxVyt8UixbJmJRJlF8Uit0JlJSK2ole1QmayFXJm5UJmwhVyZuVDF5LG0xelwiLFxuICBub2RlTmFtZXM6IFwi4pqgIEFyaXRoT3AgQXJpdGhPcCBKU1hTdGFydFRhZyBMaW5lQ29tbWVudCBCbG9ja0NvbW1lbnQgU2NyaXB0IEhhc2hiYW5nIEV4cG9ydERlY2xhcmF0aW9uIGV4cG9ydCBTdGFyIGFzIFZhcmlhYmxlTmFtZSBTdHJpbmcgRXNjYXBlIGZyb20gOyBkZWZhdWx0IEZ1bmN0aW9uRGVjbGFyYXRpb24gYXN5bmMgZnVuY3Rpb24gVmFyaWFibGVEZWZpbml0aW9uID4gPCBUeXBlUGFyYW1MaXN0IFR5cGVEZWZpbml0aW9uIGV4dGVuZHMgVGhpc1R5cGUgdGhpcyBMaXRlcmFsVHlwZSBBcml0aE9wIE51bWJlciBCb29sZWFuTGl0ZXJhbCBUZW1wbGF0ZVR5cGUgSW50ZXJwb2xhdGlvbkVuZCBJbnRlcnBvbGF0aW9uIEludGVycG9sYXRpb25TdGFydCBOdWxsVHlwZSBudWxsIFZvaWRUeXBlIHZvaWQgVHlwZW9mVHlwZSB0eXBlb2YgTWVtYmVyRXhwcmVzc2lvbiAuID8uIFByb3BlcnR5TmFtZSBbIFRlbXBsYXRlU3RyaW5nIEVzY2FwZSBJbnRlcnBvbGF0aW9uIHN1cGVyIFJlZ0V4cCBdIEFycmF5RXhwcmVzc2lvbiBTcHJlYWQgLCB9IHsgT2JqZWN0RXhwcmVzc2lvbiBQcm9wZXJ0eSBhc3luYyBnZXQgc2V0IFByb3BlcnR5RGVmaW5pdGlvbiBCbG9jayA6IE5ld0V4cHJlc3Npb24gbmV3IFR5cGVBcmdMaXN0IENvbXBhcmVPcCA8ICkgKCBBcmdMaXN0IFVuYXJ5RXhwcmVzc2lvbiBkZWxldGUgTG9naWNPcCBCaXRPcCBZaWVsZEV4cHJlc3Npb24geWllbGQgQXdhaXRFeHByZXNzaW9uIGF3YWl0IFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIENsYXNzRXhwcmVzc2lvbiBjbGFzcyBDbGFzc0JvZHkgTWV0aG9kRGVjbGFyYXRpb24gRGVjb3JhdG9yIEAgTWVtYmVyRXhwcmVzc2lvbiBQcml2YXRlUHJvcGVydHlOYW1lIENhbGxFeHByZXNzaW9uIGRlY2xhcmUgUHJpdmFjeSBzdGF0aWMgYWJzdHJhY3Qgb3ZlcnJpZGUgUHJpdmF0ZVByb3BlcnR5RGVmaW5pdGlvbiBQcm9wZXJ0eURlY2xhcmF0aW9uIHJlYWRvbmx5IGFjY2Vzc29yIE9wdGlvbmFsIFR5cGVBbm5vdGF0aW9uIEVxdWFscyBTdGF0aWNCbG9jayBGdW5jdGlvbkV4cHJlc3Npb24gQXJyb3dGdW5jdGlvbiBQYXJhbUxpc3QgUGFyYW1MaXN0IEFycmF5UGF0dGVybiBPYmplY3RQYXR0ZXJuIFBhdHRlcm5Qcm9wZXJ0eSBQcml2YWN5IHJlYWRvbmx5IEFycm93IE1lbWJlckV4cHJlc3Npb24gQmluYXJ5RXhwcmVzc2lvbiBBcml0aE9wIEFyaXRoT3AgQXJpdGhPcCBBcml0aE9wIEJpdE9wIENvbXBhcmVPcCBpbnN0YW5jZW9mIHNhdGlzZmllcyBpbiBjb25zdCBDb21wYXJlT3AgQml0T3AgQml0T3AgQml0T3AgTG9naWNPcCBMb2dpY09wIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBMb2dpY09wIExvZ2ljT3AgQXNzaWdubWVudEV4cHJlc3Npb24gVXBkYXRlT3AgUG9zdGZpeEV4cHJlc3Npb24gQ2FsbEV4cHJlc3Npb24gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uIER5bmFtaWNJbXBvcnQgaW1wb3J0IEltcG9ydE1ldGEgSlNYRWxlbWVudCBKU1hTZWxmQ2xvc2VFbmRUYWcgSlNYU2VsZkNsb3NpbmdUYWcgSlNYSWRlbnRpZmllciBKU1hCdWlsdGluIEpTWElkZW50aWZpZXIgSlNYTmFtZXNwYWNlZE5hbWUgSlNYTWVtYmVyRXhwcmVzc2lvbiBKU1hTcHJlYWRBdHRyaWJ1dGUgSlNYQXR0cmlidXRlIEpTWEF0dHJpYnV0ZVZhbHVlIEpTWEVzY2FwZSBKU1hFbmRUYWcgSlNYT3BlblRhZyBKU1hGcmFnbWVudFRhZyBKU1hUZXh0IEpTWEVzY2FwZSBKU1hTdGFydENsb3NlVGFnIEpTWENsb3NlVGFnIFByZWZpeENhc3QgQXJyb3dGdW5jdGlvbiBUeXBlUGFyYW1MaXN0IFNlcXVlbmNlRXhwcmVzc2lvbiBLZXlvZlR5cGUga2V5b2YgVW5pcXVlVHlwZSB1bmlxdWUgSW1wb3J0VHlwZSBJbmZlcnJlZFR5cGUgaW5mZXIgVHlwZU5hbWUgUGFyZW50aGVzaXplZFR5cGUgRnVuY3Rpb25TaWduYXR1cmUgUGFyYW1MaXN0IE5ld1NpZ25hdHVyZSBJbmRleGVkVHlwZSBUdXBsZVR5cGUgTGFiZWwgQXJyYXlUeXBlIFJlYWRvbmx5VHlwZSBPYmplY3RUeXBlIE1ldGhvZFR5cGUgUHJvcGVydHlUeXBlIEluZGV4U2lnbmF0dXJlIFByb3BlcnR5RGVmaW5pdGlvbiBDYWxsU2lnbmF0dXJlIFR5cGVQcmVkaWNhdGUgaXMgTmV3U2lnbmF0dXJlIG5ldyBVbmlvblR5cGUgTG9naWNPcCBJbnRlcnNlY3Rpb25UeXBlIExvZ2ljT3AgQ29uZGl0aW9uYWxUeXBlIFBhcmFtZXRlcml6ZWRUeXBlIENsYXNzRGVjbGFyYXRpb24gYWJzdHJhY3QgaW1wbGVtZW50cyB0eXBlIFZhcmlhYmxlRGVjbGFyYXRpb24gbGV0IHZhciB1c2luZyBUeXBlQWxpYXNEZWNsYXJhdGlvbiBJbnRlcmZhY2VEZWNsYXJhdGlvbiBpbnRlcmZhY2UgRW51bURlY2xhcmF0aW9uIGVudW0gRW51bUJvZHkgTmFtZXNwYWNlRGVjbGFyYXRpb24gbmFtZXNwYWNlIG1vZHVsZSBBbWJpZW50RGVjbGFyYXRpb24gZGVjbGFyZSBHbG9iYWxEZWNsYXJhdGlvbiBnbG9iYWwgQ2xhc3NEZWNsYXJhdGlvbiBDbGFzc0JvZHkgQW1iaWVudEZ1bmN0aW9uRGVjbGFyYXRpb24gRXhwb3J0R3JvdXAgVmFyaWFibGVOYW1lIFZhcmlhYmxlTmFtZSBJbXBvcnREZWNsYXJhdGlvbiBJbXBvcnRHcm91cCBGb3JTdGF0ZW1lbnQgZm9yIEZvclNwZWMgRm9ySW5TcGVjIEZvck9mU3BlYyBvZiBXaGlsZVN0YXRlbWVudCB3aGlsZSBXaXRoU3RhdGVtZW50IHdpdGggRG9TdGF0ZW1lbnQgZG8gSWZTdGF0ZW1lbnQgaWYgZWxzZSBTd2l0Y2hTdGF0ZW1lbnQgc3dpdGNoIFN3aXRjaEJvZHkgQ2FzZUxhYmVsIGNhc2UgRGVmYXVsdExhYmVsIFRyeVN0YXRlbWVudCB0cnkgQ2F0Y2hDbGF1c2UgY2F0Y2ggRmluYWxseUNsYXVzZSBmaW5hbGx5IFJldHVyblN0YXRlbWVudCByZXR1cm4gVGhyb3dTdGF0ZW1lbnQgdGhyb3cgQnJlYWtTdGF0ZW1lbnQgYnJlYWsgQ29udGludWVTdGF0ZW1lbnQgY29udGludWUgRGVidWdnZXJTdGF0ZW1lbnQgZGVidWdnZXIgTGFiZWxlZFN0YXRlbWVudCBFeHByZXNzaW9uU3RhdGVtZW50IFNpbmdsZUV4cHJlc3Npb24gU2luZ2xlQ2xhc3NJdGVtXCIsXG4gIG1heFRlcm06IDM3MSxcbiAgY29udGV4dDogdHJhY2tOZXdsaW5lLFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJpc29sYXRlXCIsIC04LDQsNSwxMywzMywzNSw0OCw1MCw1MixcIlwiXSxcbiAgICBbXCJncm91cFwiLCAtMjYsOCwxNiwxOCw2NSwyMDEsMjA1LDIwOSwyMTAsMjEyLDIxNSwyMTgsMjI4LDIzMCwyMzYsMjM4LDI0MCwyNDIsMjQ1LDI1MSwyNTcsMjU5LDI2MSwyNjMsMjY1LDI2NywyNjgsXCJTdGF0ZW1lbnRcIiwtMzIsMTIsMTMsMjgsMzEsMzIsMzgsNDgsNTEsNTIsNTQsNTksNjcsNzUsNzksODEsODMsODQsMTA2LDEwNywxMTYsMTE3LDEzNCwxMzcsMTM5LDE0MCwxNDEsMTQyLDE0NCwxNDUsMTY0LDE2NSwxNjcsXCJFeHByZXNzaW9uXCIsLTIzLDI3LDI5LDMzLDM3LDM5LDQxLDE2OCwxNzAsMTcyLDE3MywxNzUsMTc2LDE3NywxNzksMTgwLDE4MSwxODMsMTg0LDE4NSwxOTUsMTk3LDE5OSwyMDAsXCJUeXBlXCIsLTMsODcsOTksMTA1LFwiQ2xhc3NJdGVtXCJdLFxuICAgIFtcIm9wZW5lZEJ5XCIsIDIyLFwiPFwiLDM0LFwiSW50ZXJwb2xhdGlvblN0YXJ0XCIsNTMsXCJbXCIsNTcsXCJ7XCIsNzIsXCIoXCIsMTU3LFwiSlNYU3RhcnRDbG9zZVRhZ1wiXSxcbiAgICBbXCJjbG9zZWRCeVwiLCAyMyxcIj5cIiwzNixcIkludGVycG9sYXRpb25FbmRcIiw0NyxcIl1cIiw1OCxcIn1cIiw3MyxcIilcIiwxNjIsXCJKU1hFbmRUYWdcIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtqc0hpZ2hsaWdodF0sXG4gIHNraXBwZWROb2RlczogWzAsNCw1LDI3MV0sXG4gIHJlcGVhdE5vZGVDb3VudDogMzcsXG4gIHRva2VuRGF0YTogXCIkRmooQ1NSIWJPWCVaWFkrZ1laLXlaWytnW10lWl1eLmNecCVacHErZ3FyL21yczNjc3Q6X3R1RXJ1dkpTdndMa3d4ISBZeHkhJ2l5eiEoc3p7ISl9e3whLHF8fSEuT30hTyEscSFPIVAhL1khUCFRITlqIVEhUiM4ZyFSIVsjOnYhWyFdI0d2IV0hXiNJUyFeIV8jSl4hXyFgI05zIWAhYSQjXyFhIWIkKGwhYiFjJCxrIWMhfUVyIX0jTyQtdSNPI1AkL1AjUCNRJDRoI1EjUiQ1ciNSI1NFciNTI1QkN1AjVCNvJDhaI28jcCQ8ayNwI3EkPWEjcSNyJD5xI3IjcyQ/fSNzJGYlWiRmJGcrZyRnI0JZRXIjQlkjQlokQVgjQlokSVNFciRJUyRJXyRBWCRJXyRJfEVyJEl8JEl9JERkJEl9JEpPJERkJEpPJEpURXIkSlQkSlUkQVgkSlUkS1ZFciRLViRLVyRBWCRLVyZGVUVyJkZVJkZWJEFYJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFYP0hVT0VyKG4lZF8kZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJmomaFQkZiZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMmaiZ6UDs9YDwlbCZjJ3wnVV0kZiZqKFIhYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFiKFNVKFIhYk9ZJ31adyd9eCNPJ30jUDsnUyd9OydTOz1gKGY8JWxPJ30hYihpUDs9YDwlbCd9J3wob1A7PWA8JWwmfSdbKHldJGYmaihPcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocnApd1UoT3BPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylycCpeUDs9YDwlbClyJ1sqZFA7PWA8JWwociNTKm5YKE9wKFIhYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcjUyteUDs9YDwlbCpnKG4rZFA7PWA8JWwlWihDUytycSRmJmooT3AoUiFiJ3QoO2RPWCVaWFkrZ1laJmNaWytnW3AlWnBxK2dxciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcCRmJVokZiRnK2ckZyNCWSVaI0JZI0JaK2cjQlokSVMlWiRJUyRJXytnJElfJEpUJVokSlQkSlUrZyRKVSRLViVaJEtWJEtXK2ckS1cmRlUlWiZGVSZGVitnJkZWOydTJVo7J1M7PWArYTwlbD9IVCVaP0hUP0hVK2c/SFVPJVooQ1MuU1QoUCNTJGYmaid1KDtkTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMoQ1Mubl8kZiZqKE9wKFIhYid1KDtkT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI2AveGAkZiZqIW8kSXAoT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMHohYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MxVmAjdCRJZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMlghYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MyZF8jdCRJZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL3wzbF8nfSQobiRmJmooUiFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsoXjRyXyRmJmooUiFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsmejV2WCRmJmpPcjVxcnM2Y3MhXjVxIV4hXzZ5IV8jbzVxI28jcDZ5I3A7J1M1cTsnUzs9YDdoPCVsTzVxJno2alQkYWAkZiZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmNgNnxUT3I2eXJzN11zOydTNnk7J1M7PWA3YjwlbE82eWA3Yk8kYWBgN2VQOz1gPCVsNnkmejdrUDs9YDwlbDVxKF43d10kYWAkZiZqKFIhYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFyOHVaKFIhYk9ZOHBZWjZ5WnI4cHJzOWhzdzhwd3g2eXgjTzhwI08jUDZ5I1A7J1M4cDsnUzs9YDpSPCVsTzhwIXI5b1UkYWAoUiFiT1knfVp3J314I08nfSNQOydTJ307J1M7PWAoZjwlbE8nfSFyOlVQOz1gPCVsOHAoXjpbUDs9YDwlbDRrIyV8OmhoJGYmaihPcChSIWJPWSVaWVomY1pxJVpxcjxTcnMmfXN0JVp0dUNydXclWnd4KHJ4IV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DcihyPF9fVlMkZiZqKE9wKFIhYk9ZPFNZWiZjWnI8U3JzPV5zdzxTd3hAbnghXjxTIV4hX0JtIV8jTzxTI08jUD5gI1AjbzxTI28jcEJtI3A7J1M8UzsnUzs9YENsPCVsTzxTKFE9Z11WUyRmJmooUiFiT1k9XllaJmNadz1ed3g+YHghXj1eIV4hXz9xIV8jTz1eI08jUD5gI1Ajbz1eI28jcD9xI3A7J1M9XjsnUzs9YEBoPCVsTz1eJm4+Z1hWUyRmJmpPWT5gWVomY1ohXj5gIV4hXz9TIV8jbz5gI28jcD9TI3A7J1M+YDsnUzs9YD9rPCVsTz5gUz9YU1ZTT1k/U1o7J1M/UzsnUzs9YD9lPCVsTz9TUz9oUDs9YDwlbD9TJm4/blA7PWA8JWw+YCFmP3hXVlMoUiFiT1k/cVp3P3F3eD9TeCNPP3EjTyNQP1MjUDsnUz9xOydTOz1gQGI8JWxPP3EhZkBlUDs9YDwlbD9xKFFAa1A7PWA8JWw9XidgQHddVlMkZiZqKE9wT1lAbllaJmNackBucnM+YHMhXkBuIV4hX0FwIV8jT0BuI08jUD5gI1Ajb0BuI28jcEFwI3A7J1NAbjsnUzs9YEJnPCVsT0BudEF3V1ZTKE9wT1lBcFpyQXBycz9TcyNPQXAjTyNQP1MjUDsnU0FwOydTOz1gQmE8JWxPQXB0QmRQOz1gPCVsQXAnYEJqUDs9YDwlbEBuI1dCdllWUyhPcChSIWJPWUJtWnJCbXJzP3Fzd0Jtd3hBcHgjT0JtI08jUD9TI1A7J1NCbTsnUzs9YENmPCVsT0JtI1dDaVA7PWA8JWxCbShyQ29QOz1gPCVsPFMjJXxDfWkkZiZqKGchTF4oT3AoUiFiT1klWllaJmNaciVacnMmfXN0JVp0dUNydXclWnd4KHJ4IVElWiFRIVtDciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DciMlfEVvUDs9YDwlbENyKENTRlJrJGYmaihPcChSIWIkWSN0J3smO2QoWyFMWU9ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyK2RIUmskZiZqKE9wKFIhYiRZI3RPWSVaWVomY1pyJVpycyZ9c3QlWnR1R3Z1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtHdiFbIV4lWiFeIV8qZyFfIWMlWiFjIX1HdiF9I08lWiNPI1AmYyNQI1IlWiNSI1NHdiNTI1QlWiNUI29HdiNvI3AqZyNwJGclWiRnOydTR3Y7J1M7PWBJdjwlbE9HditkSXlQOz1gPCVsR3YoQ1NKUFA7PWA8JWxFciUjU0pfYCRmJmooT3AoUiFiI2wkSWRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjU0tsXyRmJmokTyRJZChPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiZDT0x2YShwJjtgJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3YlWnZ3TXt3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1NOV2AkZiZqI3gkSWQoT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL3whIGNfKFEkKWAkZiZqKE9wT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWInbCEhaV8kZiZqKE9wT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWImeiEjbVgkZiZqT3chI2h3eDZjeCFeISNoIV4hXyEkWSFfI28hI2gjbyNwISRZI3A7J1MhI2g7J1M7PWAhJHI8JWxPISNoYCEkXVRPdyEkWXd4N114OydTISRZOydTOz1gISRsPCVsTyEkWWAhJG9QOz1gPCVsISRZJnohJHVQOz1gPCVsISNoJ2whJVJdJGFgJGYmaihPcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ociFRISZQWihPcE9ZISV6WVohJFlaciElenJzISRZc3chJXp3eCEmcngjTyEleiNPI1AhJFkjUDsnUyElejsnUzs9YCEnXTwlbE8hJXohUSEmeVUkYWAoT3BPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylyIVEhJ2BQOz1gPCVsISV6J2whJ2ZQOz1gPCVsISFiKCpRISd0XyFrKCFiJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiEnbCEpT18hak18JGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWicraCEqW2IkZiZqKE9wKFIhYid8IylkI20kSWRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4eiVaenshK2R7IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyErb2AkZiZqKE9wKFIhYiNqJElkT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVomLU8hLHxgJGYmaihPcChSIWJuJiVgT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVomQ1shLlpfIVkmO2wkZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKENTIS9lYyRmJmooT3AoUiFifCc8bk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEwcCFQIVElWiFRIVshM1khWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVohJ2QhMHlhJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhMk8hUCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVohJ2QhMlpfIVhNdCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2whM2VnJGYmaihPcChSIWJvJCd8T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbITNZIVshXiVaIV4hXypnIV8hZyVaIWchaCE0fCFoI08lWiNPI1AmYyNQI1IlWiNSI1MhM1kjUyNYJVojWCNZITR8I1kjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sITVWZyRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeHslWnt8ITZufH0lWn0hTyE2biFPIVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sITZ3YyRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbIThTIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyE4UyNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCE4X2MkZiZqKE9wKFIhYm8kJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKENTITl1ZiRmJmooT3AoUiFiI2skSWRPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFLcHh6ITtaensjLGZ7IVAhO1ohUCFRIy17IVEhXiE7WiFeIV8jJ1ohXyFgIzVrIWAhYSM3USFhIX0hO1ohfSNPIyp9I08jUCFEaiNQI28hO1ojbyNwIydaI3A7J1MhO1o7J1M7PWAjLGA8JWxPITtaKHIhO2ZiJGYmaihPcChSIWIhVVNPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFLcHghUCE7WiFQIVEjJVohUSFeITtaIV4hXyMnWiFfIX0hO1ohfSNPIyp9I08jUCFEaiNQI28hO1ojbyNwIydaI3A7J1MhO1o7J1M7PWAjLGA8JWxPITtaKFEhPHdgJGYmaihSIWIhVVNPWSE8bllaJmNadyE8bnd4IT15eCFQITxuIVAhUSFFYiFRIV4hPG4hXiFfIUdZIV8hfSE8biF9I08hSmEjTyNQIURqI1AjbyE8biNvI3AhR1kjcDsnUyE8bjsnUzs9YCFLajwlbE8hPG4mbiE+UV4kZiZqIVVTT1khPXlZWiZjWiFQIT15IVAhUSE+fCFRIV4hPXkhXiFfIUBZIV8hfSE9eSF9I08hQncjTyNQIURqI1AjbyE9eSNvI3AhQFkjcDsnUyE9eTsnUzs9YCFFWzwlbE8hPXkmbiE/VGEkZiZqIVVTTyFeJmMhXyNaJmMjWiNbIT58I1sjXSZjI10jXiE+fCNeI2EmYyNhI2IhPnwjYiNnJmMjZyNoIT58I2gjaSZjI2kjaiE+fCNqI20mYyNtI24hPnwjbiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmNTIUBfWCFVU09ZIUBZWiFQIUBZIVAhUSFAeiFRIX0hQFkhfSNPIUFjI08jUCFCYiNQOydTIUBZOydTOz1gIUJxPCVsTyFAWVMhQVBVIVVTI1ojWyFAeiNdI14hQHojYSNiIUB6I2cjaCFAeiNpI2ohQHojbSNuIUB6UyFBZlZPWSFBY1ojTyFBYyNPI1AhQXsjUCNRIUBZI1E7J1MhQWM7J1M7PWAhQls8JWxPIUFjUyFCT1NPWSFBY1o7J1MhQWM7J1M7PWAhQls8JWxPIUFjUyFCX1A7PWA8JWwhQWNTIUJlU09ZIUBZWjsnUyFAWTsnUzs9YCFCcTwlbE8hQFlTIUJ0UDs9YDwlbCFAWSZuIUJ8WyRmJmpPWSFCd1laJmNaIV4hQnchXiFfIUFjIV8jTyFCdyNPI1AhQ3IjUCNRIT15I1EjbyFCdyNvI3AhQWMjcDsnUyFCdzsnUzs9YCFEZDwlbE8hQncmbiFDd1gkZiZqT1khQndZWiZjWiFeIUJ3IV4hXyFBYyFfI28hQncjbyNwIUFjI3A7J1MhQnc7J1M7PWAhRGQ8JWxPIUJ3Jm4hRGdQOz1gPCVsIUJ3Jm4hRG9YJGYmak9ZIT15WVomY1ohXiE9eSFeIV8hQFkhXyNvIT15I28jcCFAWSNwOydTIT15OydTOz1gIUVbPCVsTyE9eSZuIUVfUDs9YDwlbCE9eShRIUVraSRmJmooUiFiIVVTT1kmfVlaJmNadyZ9d3gmY3ghXiZ9IV4hXyd9IV8jTyZ9I08jUCZjI1AjWiZ9I1ojWyFFYiNbI10mfSNdI14hRWIjXiNhJn0jYSNiIUViI2IjZyZ9I2cjaCFFYiNoI2kmfSNpI2ohRWIjaiNtJn0jbSNuIUViI24jbyZ9I28jcCd9I3A7J1MmfTsnUzs9YChsPCVsTyZ9IWYhR2FaKFIhYiFVU09ZIUdZWnchR1l3eCFAWXghUCFHWSFQIVEhSFMhUSF9IUdZIX0jTyFJYyNPI1AhQmIjUDsnUyFHWTsnUzs9YCFKWjwlbE8hR1khZiFIWmIoUiFiIVVTT1knfVp3J314I08nfSNQI1onfSNaI1shSFMjWyNdJ30jXSNeIUhTI14jYSd9I2EjYiFIUyNiI2cnfSNnI2ghSFMjaCNpJ30jaSNqIUhTI2ojbSd9I20jbiFIUyNuOydTJ307J1M7PWAoZjwlbE8nfSFmIUloWChSIWJPWSFJY1p3IUljd3ghQWN4I08hSWMjTyNQIUF7I1AjUSFHWSNROydTIUljOydTOz1gIUpUPCVsTyFJYyFmIUpXUDs9YDwlbCFJYyFmIUpeUDs9YDwlbCFHWShRIUpoXiRmJmooUiFiT1khSmFZWiZjWnchSmF3eCFCd3ghXiFKYSFeIV8hSWMhXyNPIUphI08jUCFDciNQI1EhPG4jUSNvIUphI28jcCFJYyNwOydTIUphOydTOz1gIUtkPCVsTyFKYShRIUtnUDs9YDwlbCFKYShRIUttUDs9YDwlbCE8bidgIUt5YCRmJmooT3AhVVNPWSFLcFlaJmNaciFLcHJzIT15cyFQIUtwIVAhUSFMeyFRIV4hS3AhXiFfIU5zIV8hfSFLcCF9I08jI3ojTyNQIURqI1AjbyFLcCNvI3AhTnMjcDsnUyFLcDsnUzs9YCMlVDwlbE8hS3AnYCFNVWkkZiZqKE9wIVVTT1kocllaJmNacihycnMmY3MhXihyIV4hXylyIV8jTyhyI08jUCZjI1AjWihyI1ojWyFMeyNbI10ociNdI14hTHsjXiNhKHIjYSNiIUx7I2IjZyhyI2cjaCFMeyNoI2kociNpI2ohTHsjaiNtKHIjbSNuIUx7I24jbyhyI28jcClyI3A7J1MocjsnUzs9YCphPCVsTyhydCFOelooT3AhVVNPWSFOc1pyIU5zcnMhQFlzIVAhTnMhUCFRIyBtIVEhfSFOcyF9I08jIXwjTyNQIUJiI1A7J1MhTnM7J1M7PWAjI3Q8JWxPIU5zdCMgdGIoT3AhVVNPWSlyWnIpcnMjTylyI1AjWilyI1ojWyMgbSNbI10pciNdI14jIG0jXiNhKXIjYSNiIyBtI2IjZylyI2cjaCMgbSNoI2kpciNpI2ojIG0jaiNtKXIjbSNuIyBtI247J1MpcjsnUzs9YCpaPCVsTylydCMjUlgoT3BPWSMhfFpyIyF8cnMhQWNzI08jIXwjTyNQIUF7I1AjUSFOcyNROydTIyF8OydTOz1gIyNuPCVsTyMhfHQjI3FQOz1gPCVsIyF8dCMjd1A7PWA8JWwhTnMnYCMkUl4kZiZqKE9wT1kjI3pZWiZjWnIjI3pycyFCd3MhXiMjeiFeIV8jIXwhXyNPIyN6I08jUCFDciNQI1EhS3AjUSNvIyN6I28jcCMhfCNwOydTIyN6OydTOz1gIyR9PCVsTyMjeidgIyVRUDs9YDwlbCMjeidgIyVXUDs9YDwlbCFLcChyIyVmayRmJmooT3AoUiFiIVVTT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNaJVojWiNbIyVaI1sjXSVaI10jXiMlWiNeI2ElWiNhI2IjJVojYiNnJVojZyNoIyVaI2gjaSVaI2kjaiMlWiNqI20lWiNtI24jJVojbiNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVojVyMnZF0oT3AoUiFiIVVTT1kjJ1paciMnWnJzIUdZc3cjJ1p3eCFOc3ghUCMnWiFQIVEjKF0hUSF9IydaIX0jTyMpdyNPI1AhQmIjUDsnUyMnWjsnUzs9YCMqdzwlbE8jJ1ojVyMoZmUoT3AoUiFiIVVTT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQI1oqZyNaI1sjKF0jWyNdKmcjXSNeIyhdI14jYSpnI2EjYiMoXSNiI2cqZyNnI2gjKF0jaCNpKmcjaSNqIyhdI2ojbSpnI20jbiMoXSNuOydTKmc7J1M7PWArWjwlbE8qZyNXIypPWihPcChSIWJPWSMpd1pyIyl3cnMhSWNzdyMpd3d4IyF8eCNPIyl3I08jUCFBeyNQI1EjJ1ojUTsnUyMpdzsnUzs9YCMqcTwlbE8jKXcjVyMqdFA7PWA8JWwjKXcjVyMqelA7PWA8JWwjJ1oociMrV2AkZiZqKE9wKFIhYk9ZIyp9WVomY1pyIyp9cnMhSmFzdyMqfXd4IyN6eCFeIyp9IV4hXyMpdyFfI08jKn0jTyNQIUNyI1AjUSE7WiNRI28jKn0jbyNwIyl3I3A7J1MjKn07J1M7PWAjLFk8JWxPIyp9KHIjLF1QOz1gPCVsIyp9KHIjLGNQOz1gPCVsITtaKENTIyxzYiRmJmooT3AoUiFiJ3YoO2QhVVNPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFLcHghUCE7WiFQIVEjJVohUSFeITtaIV4hXyMnWiFfIX0hO1ohfSNPIyp9I08jUCFEaiNQI28hO1ojbyNwIydaI3A7J1MhO1o7J1M7PWAjLGA8JWxPITtaKENTIy5XXyRmJmooT3AoUiFiUyg7ZE9ZIy17WVomY1pyIy17cnMjL1ZzdyMte3d4IzJneCFeIy17IV4hXyM0ZiFfI08jLXsjTyNQIzBYI1AjbyMteyNvI3AjNGYjcDsnUyMtezsnUzs9YCM1ZTwlbE8jLXsoQmIjL2BdJGYmaihSIWJTKDtkT1kjL1ZZWiZjWncjL1Z3eCMwWHghXiMvViFeIV8jMWohXyNPIy9WI08jUCMwWCNQI28jL1YjbyNwIzFqI3A7J1MjL1Y7J1M7PWAjMmE8JWxPIy9WKEFPIzBgWCRmJmpTKDtkT1kjMFhZWiZjWiFeIzBYIV4hXyMweyFfI28jMFgjbyNwIzB7I3A7J1MjMFg7J1M7PWAjMWQ8JWxPIzBYKDtkIzFRU1MoO2RPWSMwe1o7J1MjMHs7J1M7PWAjMV48JWxPIzB7KDtkIzFhUDs9YDwlbCMweyhBTyMxZ1A7PWA8JWwjMFgoPHYjMXFXKFIhYlMoO2RPWSMxalp3IzFqd3gjMHt4I08jMWojTyNQIzB7I1A7J1MjMWo7J1M7PWAjMlo8JWxPIzFqKDx2IzJeUDs9YDwlbCMxaihCYiMyZFA7PWA8JWwjL1YoQXAjMnBdJGYmaihPcFMoO2RPWSMyZ1laJmNaciMyZ3JzIzBYcyFeIzJnIV4hXyMzaSFfI08jMmcjTyNQIzBYI1AjbyMyZyNvI3AjM2kjcDsnUyMyZzsnUzs9YCM0YDwlbE8jMmcoPFUjM3BXKE9wUyg7ZE9ZIzNpWnIjM2lycyMwe3MjTyMzaSNPI1AjMHsjUDsnUyMzaTsnUzs9YCM0WTwlbE8jM2koPFUjNF1QOz1gPCVsIzNpKEFwIzRjUDs9YDwlbCMyZyg9aCM0b1koT3AoUiFiUyg7ZE9ZIzRmWnIjNGZycyMxanN3IzRmd3gjM2l4I08jNGYjTyNQIzB7I1A7J1MjNGY7J1M7PWAjNV88JWxPIzRmKD1oIzViUDs9YDwlbCM0ZihDUyM1aFA7PWA8JWwjLXslI1cjNXhiJGYmaiRPJElkKE9wKFIhYiFVU09ZITtaWVomY1pyITtacnMhPG5zdyE7Wnd4IUtweCFQITtaIVAhUSMlWiFRIV4hO1ohXiFfIydaIV8hfSE7WiF9I08jKn0jTyNQIURqI1AjbyE7WiNvI3AjJ1ojcDsnUyE7WjsnUzs9YCMsYDwlbE8hO1oraCM3X2IkVyN0JGYmaihPcChSIWIhVVNPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFLcHghUCE7WiFQIVEjJVohUSFeITtaIV4hXyMnWiFfIX0hO1ohfSNPIyp9I08jUCFEaiNQI28hO1ojbyNwIydaI3A7J1MhO1o7J1M7PWAjLGA8JWxPITtaJC9sIzhycCRmJmooT3AoUiFibyQnfE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEzWSFQIVElWiFRIVsjOnYhWyFeJVohXiFfKmchXyFnJVohZyFoITR8IWgjTyVaI08jUCZjI1AjUiVaI1IjUyM6diNTI1UlWiNVI1YjPlEjViNYJVojWCNZITR8I1kjYiVaI2IjYyM8diNjI2QjQVkjZCNsJVojbCNtI0RbI20jbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sIztSayRmJmooT3AoUiFibyQnfE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEzWSFQIVElWiFRIVsjOnYhWyFeJVohXiFfKmchXyFnJVohZyFoITR8IWgjTyVaI08jUCZjI1AjUiVaI1IjUyM6diNTI1glWiNYI1khNHwjWSNiJVojYiNjIzx2I2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sIz1SXyRmJmooT3AoUiFibyQnfE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sIz5aZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFSIz9pIVIhUyM/aSFTIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjP2kjUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2wjP3RmJGYmaihPcChSIWJvJCd8T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFSIz9pIVIhUyM/aSFTIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjP2kjUyNiJVojYiNjIzx2I2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sI0FjYyRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFZI0JuIVkhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNCbiNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCNCeWUkZiZqKE9wKFIhYm8kJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVkjQm4hWSFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTI0JuI1MjYiVaI2IjYyM8diNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCNEZWckZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyNFfCFbIV4lWiFeIV8qZyFfIWMlWiFjIWkjRXwhaSNPJVojTyNQJmMjUCNSJVojUiNTI0V8I1MjVCVaI1QjWiNFfCNaI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCNGWGkkZiZqKE9wKFIhYm8kJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVsjRXwhWyFeJVohXiFfKmchXyFjJVohYyFpI0V8IWkjTyVaI08jUCZjI1AjUiVaI1IjUyNFfCNTI1QlWiNUI1ojRXwjWiNiJVojYiNjIzx2I2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJUdoI0hUXyFkJGIkZiZqI3wlPGYoT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVopWyNJX19gbCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooQF4jSmteZyEqdiFoJy5yKE9wKFIhYih0U09ZKmdacipncnMnfXN3Kmd3eClyeCFQKmchUCFRI0tnIVEhXipnIV4hXyNMXSFfIWAjTX0hYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcobiNLcFgkaCZqKE9wKFIhYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmckS2gjTGZaI24kSWQoT3AoUiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4IV8qZyFfIWAjTVghYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmckS2gjTWJYJE8kSWQoT3AoUiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyRLaCNOV1gjbyRJZChPcChSIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnJUdoJCBPYSNbJT94JGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAweiFgIWEkIVQhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1ckIWBfI2ckSWgkZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJUdoJCNuYWZCZiNvJElkJGMjfCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgJCRzIWAhYSQlfSFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyQlT18jbyRJZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MkJllhI24kSWQkZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAhYSQnXyFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyQnamAjbiRJZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonK2gkKHdjKGgkSXAkZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCQqUyFQIV4lWiFeIV8qZyFfIWElWiFhIWIkK14hYiNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonK2AkKl9ffScjcCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MkK2lgJGYmaiN5JElkKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaIyZeJCx2XyF7IUxuJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihAXiQuUV8hUCg4biRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoobiQvVVokZiZqTyFeJC93IV4hXyQwXyFfI2kkL3cjaSNqJDBkI2ojbCQvdyNsI20kMlYjbSNvJC93I28jcCQwXyNwOydTJC93OydTOz1gJDRiPCVsTyQvdyhuJDBPVF4jUyRmJmpPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyNTJDBkT14jUyhuJDBpWyRmJmpPIVEmYyFRIVskMV8hWyFeJmMhXyFjJmMhYyFpJDFfIWkjVCZjI1QjWiQxXyNaI28mYyNvI3AkM3UjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQxZFokZiZqTyFRJmMhUSFbJDJWIVshXiZjIV8hYyZjIWMhaSQyViFpI1QmYyNUI1okMlYjWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQyW1okZiZqTyFRJmMhUSFbJDJ9IVshXiZjIV8hYyZjIWMhaSQyfSFpI1QmYyNUI1okMn0jWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQzU1okZiZqTyFRJmMhUSFbJC93IVshXiZjIV8hYyZjIWMhaSQvdyFpI1QmYyNUI1okL3cjWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMjUyQzeFIhUSFbJDRSIWMhaSQ0UiNUI1okNFIjUyQ0VVMhUSFbJDRSIWMhaSQ0UiNUI1okNFIjcSNyJDBfKG4kNGVQOz1gPCVsJC93ITJyJDRzXyFWIStTJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyQ1fWAjdiRJZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVomLHYkN1tfJGYmaihPcChSIWIoWCYlV09ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKENTJDhqayRmJmooT3AoUiFiJ3smO2QkWyN0KFshTFlPWSVaWVomY1pyJVpycyZ9c3QlWnR1JDhadXclWnd4KHJ4fSVafSFPJDpfIU8hUSVaIVEhWyQ4WiFbIV4lWiFeIV8qZyFfIWMlWiFjIX0kOFohfSNPJVojTyNQJmMjUCNSJVojUiNTJDhaI1MjVCVaI1QjbyQ4WiNvI3AqZyNwJGclWiRnOydTJDhaOydTOz1gJDxlPCVsTyQ4WitkJDpqayRmJmooT3AoUiFiJFsjdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHUkOl91dyVad3gocnh9JVp9IU8kOl8hTyFRJVohUSFbJDpfIVshXiVaIV4hXypnIV8hYyVaIWMhfSQ6XyF9I08lWiNPI1AmYyNQI1IlWiNSI1MkOl8jUyNUJVojVCNvJDpfI28jcCpnI3AkZyVaJGc7J1MkOl87J1M7PWAkPF88JWxPJDpfK2QkPGJQOz1gPCVsJDpfKENTJDxoUDs9YDwlbCQ4WiE1cCQ8dFghWyEzbChPcChSIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnJkNPJD1sYShvJjtgJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwI3EkK14jcTsnUyVaOydTOz1gK2E8JWxPJVolI2AkP09fIVokSWByYCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoociRAWV8hcFMkZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKENTJEFqfCRmJmooT3AoUiFiJ3QoO2QkWSN0J3smO2QoWyFMWU9YJVpYWStnWVomY1pbK2dbcCVacHErZ3FyJVpycyZ9c3QlWnR1RXJ1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtFciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1FciF9I08lWiNPI1AmYyNQI1IlWiNSI1NFciNTI1QlWiNUI29FciNvI3AqZyNwJGYlWiRmJGcrZyRnI0JZRXIjQlkjQlokQVgjQlokSVNFciRJUyRJXyRBWCRJXyRKVEVyJEpUJEpVJEFYJEpVJEtWRXIkS1YkS1ckQVgkS1cmRlVFciZGVSZGViRBWCZGVjsnU0VyOydTOz1gSXw8JWw/SFRFcj9IVD9IVSRBWD9IVU9FcihDUyREdWskZiZqKE9wKFIhYid1KDtkJFkjdCd7JjtkKFshTFlPWSVaWVomY1pyJVpycyZ9c3QlWnR1RXJ1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtFciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1FciF9I08lWiNPI1AmYyNQI1IlWiNSI1NFciNTI1QlWiNUI29FciNvI3AqZyNwJGclWiRnOydTRXI7J1M7PWBJfDwlbE9FclwiLFxuICB0b2tlbml6ZXJzOiBbbm9TZW1pY29sb24sIGluY2RlY1Rva2VuLCBqc3gsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCBpbnNlcnRTZW1pY29sb24sIG5ldyBMb2NhbFRva2VuR3JvdXAoXCIkU35SUnR1WyNPI1BnI1MjVCN8fl9QI28jcGJ+Z090fn5qVk8jaSFQI2kjaiFVI2ojbCFQI2wjbSFxI207J1MhUDsnUzs9YCN2PCVsTyFQfiFVTyFSfn4hWFMhUSFbIWUhYyFpIWUjVCNaIWUjbyNwI1p+IWhSIVEhWyFxIWMhaSFxI1QjWiFxfiF0UiFRIVshfSFjIWkhfSNUI1ohfX4jUVIhUSFbIVAhYyFpIVAjVCNaIVB+I15SIVEhWyNnIWMhaSNnI1QjWiNnfiNqUyFRIVsjZyFjIWkjZyNUI1ojZyNxI3IhUH4jeVA7PWA8JWwhUH4kUk8oWn5+XCIsIDE0MSwgMzMyKSwgbmV3IExvY2FsVG9rZW5Hcm91cChcImp+UlFZWlh6e15+Xk8neH5+YVAhUCFRZH5pTyd5fn5cIiwgMjUsIDMxNSldLFxuICB0b3BSdWxlczoge1wiU2NyaXB0XCI6WzAsNl0sXCJTaW5nbGVFeHByZXNzaW9uXCI6WzEsMjY5XSxcIlNpbmdsZUNsYXNzSXRlbVwiOlsyLDI3MF19LFxuICBkaWFsZWN0czoge2pzeDogMCwgdHM6IDE0NjE0fSxcbiAgZHluYW1pY1ByZWNlZGVuY2VzOiB7XCI2OVwiOjEsXCI3OVwiOjEsXCI4MVwiOjEsXCIxNjVcIjoxLFwiMTkzXCI6MX0sXG4gIHNwZWNpYWxpemVkOiBbe3Rlcm06IDMxOSwgZ2V0OiAodmFsdWUpID0+IHNwZWNfaWRlbnRpZmllclt2YWx1ZV0gfHwgLTF9LHt0ZXJtOiAzMzQsIGdldDogKHZhbHVlKSA9PiBzcGVjX3dvcmRbdmFsdWVdIHx8IC0xfSx7dGVybTogNzAsIGdldDogKHZhbHVlKSA9PiBzcGVjX0xlc3NUaGFuW3ZhbHVlXSB8fCAtMX1dLFxuICB0b2tlblByZWM6IDE0NjM4XG59KTtcblxuZXhwb3J0IHsgcGFyc2VyIH07XG4iXSwibmFtZXMiOlsiQ29udGV4dFRyYWNrZXIiLCJFeHRlcm5hbFRva2VuaXplciIsIkxSUGFyc2VyIiwiTG9jYWxUb2tlbkdyb3VwIiwic3R5bGVUYWdzIiwidGFncyIsIm5vU2VtaSIsImluY2RlYyIsImluY2RlY1ByZWZpeCIsIkpTWFN0YXJ0VGFnIiwiaW5zZXJ0U2VtaSIsInNwYWNlcyIsIm5ld2xpbmUiLCJMaW5lQ29tbWVudCIsIkJsb2NrQ29tbWVudCIsIkRpYWxlY3RfanN4Iiwic3BhY2UiLCJicmFjZVIiLCJzZW1pY29sb24iLCJzbGFzaCIsInN0YXIiLCJwbHVzIiwibWludXMiLCJsdCIsImNvbW1hIiwidHJhY2tOZXdsaW5lIiwic3RhcnQiLCJzaGlmdCIsImNvbnRleHQiLCJ0ZXJtIiwic3RyaWN0IiwiaW5zZXJ0U2VtaWNvbG9uIiwiaW5wdXQiLCJzdGFjayIsIm5leHQiLCJhY2NlcHRUb2tlbiIsImNvbnRleHR1YWwiLCJmYWxsYmFjayIsIm5vU2VtaWNvbG9uIiwiYWZ0ZXIiLCJpbmRleE9mIiwicGVlayIsImluY2RlY1Rva2VuIiwiYWR2YW5jZSIsIm1heVBvc3RmaXgiLCJjYW5TaGlmdCIsImlkZW50aWZpZXJDaGFyIiwiY2giLCJqc3giLCJkaWFsZWN0RW5hYmxlZCIsImJhY2siLCJpIiwiY2hhckNvZGVBdCIsImpzSGlnaGxpZ2h0IiwibW9kaWZpZXIiLCJjb250cm9sS2V5d29yZCIsIm9wZXJhdG9yS2V5d29yZCIsImRlZmluaXRpb25LZXl3b3JkIiwibW9kdWxlS2V5d29yZCIsImtleXdvcmQiLCJUZW1wbGF0ZVN0cmluZyIsInNwZWNpYWwiLCJzdHJpbmciLCJzdXBlciIsImF0b20iLCJCb29sZWFuTGl0ZXJhbCIsImJvb2wiLCJ0aGlzIiwic2VsZiIsIm51bGwiLCJTdGFyIiwiVmFyaWFibGVOYW1lIiwidmFyaWFibGVOYW1lIiwiZnVuY3Rpb24iLCJWYXJpYWJsZURlZmluaXRpb24iLCJkZWZpbml0aW9uIiwiTGFiZWwiLCJsYWJlbE5hbWUiLCJQcm9wZXJ0eU5hbWUiLCJwcm9wZXJ0eU5hbWUiLCJQcml2YXRlUHJvcGVydHlOYW1lIiwiY2xhc3NOYW1lIiwiUHJvcGVydHlEZWZpbml0aW9uIiwiUHJpdmF0ZVByb3BlcnR5RGVmaW5pdGlvbiIsIlVwZGF0ZU9wIiwidXBkYXRlT3BlcmF0b3IiLCJsaW5lQ29tbWVudCIsImJsb2NrQ29tbWVudCIsIk51bWJlciIsIm51bWJlciIsIlN0cmluZyIsIkVzY2FwZSIsImVzY2FwZSIsIkFyaXRoT3AiLCJhcml0aG1ldGljT3BlcmF0b3IiLCJMb2dpY09wIiwibG9naWNPcGVyYXRvciIsIkJpdE9wIiwiYml0d2lzZU9wZXJhdG9yIiwiQ29tcGFyZU9wIiwiY29tcGFyZU9wZXJhdG9yIiwiUmVnRXhwIiwicmVnZXhwIiwiRXF1YWxzIiwiZGVmaW5pdGlvbk9wZXJhdG9yIiwiQXJyb3ciLCJwdW5jdHVhdGlvbiIsInBhcmVuIiwic3F1YXJlQnJhY2tldCIsImJyYWNlIiwiZGVyZWZPcGVyYXRvciIsInNlcGFyYXRvciIsIm1ldGEiLCJUeXBlTmFtZSIsInR5cGVOYW1lIiwiVHlwZURlZmluaXRpb24iLCJKU1hBdHRyaWJ1dGVWYWx1ZSIsImF0dHJpYnV0ZVZhbHVlIiwiSlNYVGV4dCIsImNvbnRlbnQiLCJhbmdsZUJyYWNrZXQiLCJ0YWdOYW1lIiwiYXR0cmlidXRlTmFtZSIsInN0YW5kYXJkIiwic3BlY19pZGVudGlmaWVyIiwiX19wcm90b19fIiwiZXhwb3J0IiwiYXMiLCJmcm9tIiwiZGVmYXVsdCIsImFzeW5jIiwiZXh0ZW5kcyIsInRydWUiLCJmYWxzZSIsInZvaWQiLCJ0eXBlb2YiLCJuZXciLCJkZWxldGUiLCJ5aWVsZCIsImF3YWl0IiwiY2xhc3MiLCJwdWJsaWMiLCJwcml2YXRlIiwicHJvdGVjdGVkIiwicmVhZG9ubHkiLCJpbnN0YW5jZW9mIiwic2F0aXNmaWVzIiwiaW4iLCJjb25zdCIsImltcG9ydCIsImtleW9mIiwidW5pcXVlIiwiaW5mZXIiLCJpcyIsImFic3RyYWN0IiwiaW1wbGVtZW50cyIsInR5cGUiLCJsZXQiLCJ2YXIiLCJ1c2luZyIsImludGVyZmFjZSIsImVudW0iLCJuYW1lc3BhY2UiLCJtb2R1bGUiLCJkZWNsYXJlIiwiZ2xvYmFsIiwiZm9yIiwib2YiLCJ3aGlsZSIsIndpdGgiLCJkbyIsImlmIiwiZWxzZSIsInN3aXRjaCIsImNhc2UiLCJ0cnkiLCJjYXRjaCIsImZpbmFsbHkiLCJyZXR1cm4iLCJ0aHJvdyIsImJyZWFrIiwiY29udGludWUiLCJkZWJ1Z2dlciIsInNwZWNfd29yZCIsImdldCIsInNldCIsInN0YXRpYyIsIm92ZXJyaWRlIiwiYWNjZXNzb3IiLCJzcGVjX0xlc3NUaGFuIiwicGFyc2VyIiwiZGVzZXJpYWxpemUiLCJ2ZXJzaW9uIiwic3RhdGVzIiwic3RhdGVEYXRhIiwiZ290byIsIm5vZGVOYW1lcyIsIm1heFRlcm0iLCJub2RlUHJvcHMiLCJwcm9wU291cmNlcyIsInNraXBwZWROb2RlcyIsInJlcGVhdE5vZGVDb3VudCIsInRva2VuRGF0YSIsInRva2VuaXplcnMiLCJ0b3BSdWxlcyIsImRpYWxlY3RzIiwidHMiLCJkeW5hbWljUHJlY2VkZW5jZXMiLCJzcGVjaWFsaXplZCIsInZhbHVlIiwidG9rZW5QcmVjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/javascript/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/lr/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@lezer/lr/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextTracker: () => (/* binding */ ContextTracker),\n/* harmony export */   ExternalTokenizer: () => (/* binding */ ExternalTokenizer),\n/* harmony export */   InputStream: () => (/* binding */ InputStream),\n/* harmony export */   LRParser: () => (/* binding */ LRParser),\n/* harmony export */   LocalTokenGroup: () => (/* binding */ LocalTokenGroup),\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/ class Stack {\n    /**\n    @internal\n    */ constructor(/**\n    The parse that this stack is part of @internal\n    */ p, /**\n    Holds state, input pos, buffer index triplets for all but the\n    top state @internal\n    */ stack, /**\n    The current parse state @internal\n    */ state, // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /**\n    @internal\n    */ reducePos, /**\n    The input position up to which this stack has parsed.\n    */ pos, /**\n    The dynamic score of the stack, including dynamic precedence\n    and error-recovery penalties\n    @internal\n    */ score, // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /**\n    @internal\n    */ buffer, // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /**\n    @internal\n    */ bufferBase, /**\n    @internal\n    */ curContext, /**\n    @internal\n    */ lookAhead = 0, // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /**\n    @internal\n    */ parent){\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /**\n    @internal\n    */ toString() {\n        return `[${this.stack.filter((_, i)=>i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /**\n    @internal\n    */ static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /**\n    The stack's current [context](#lr.ContextTracker) value, if\n    any. Its type will depend on the context tracker's type\n    parameter, or it will be `null` if there is no context\n    tracker.\n    */ get context() {\n        return this.curContext ? this.curContext.context : null;\n    }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /**\n    @internal\n    */ pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /**\n    @internal\n    */ reduce(action) {\n        var _a;\n        let depth = action >> 19 /* Action.ReduceDepthShift */ , type = action & 65535 /* Action.ValueMask */ ;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec) this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special caseâ€”they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - (depth - 1) * 3 - (action & 262144 /* Action.StayFlag */  ? 6 : 0);\n        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;\n        // This is a kludge to try and detect overly deep left-associative\n        // trees, which will not increase the parse stack depth and thus\n        // won't be caught by the regular stack-depth limit check.\n        if (size >= 2000 /* Recover.MinBigReduction */  && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n            if (start == this.p.lastBigReductionStart) {\n                this.p.bigReductionCount++;\n                this.p.lastBigReductionSize = size;\n            } else if (this.p.lastBigReductionSize < size) {\n                this.p.bigReductionCount = 1;\n                this.p.lastBigReductionStart = start;\n                this.p.lastBigReductionSize = size;\n            }\n        }\n        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || action & 131072 /* Action.RepeatFlag */ ) {\n            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */ ) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* Action.StayFlag */ ) {\n            this.state = this.stack[base];\n        } else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while(this.stack.length > base)this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /**\n    @internal\n    */ storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Term.Err */  && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n            // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */  && cur.buffer[top - 1] > -1) {\n                if (start == end) return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) {\n            this.buffer.push(term, start, end, size);\n        } else {\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */ ) while(index > 0 && this.buffer[index - 2] > end){\n                // Move this record forward\n                this.buffer[index] = this.buffer[index - 4];\n                this.buffer[index + 1] = this.buffer[index - 3];\n                this.buffer[index + 2] = this.buffer[index - 2];\n                this.buffer[index + 3] = this.buffer[index - 1];\n                index -= 4;\n                if (size > 4) size -= 4;\n            }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /**\n    @internal\n    */ shift(action, type, start, end) {\n        if (action & 131072 /* Action.GotoFlag */ ) {\n            this.pushState(action & 65535 /* Action.ValueMask */ , this.pos);\n        } else if ((action & 262144 /* Action.StayFlag */ ) == 0) {\n            let nextState = action, { parser } = this.p;\n            if (end > this.pos || type <= parser.maxNode) {\n                this.pos = end;\n                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */ )) this.reducePos = end;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(type, start);\n            if (type <= parser.maxNode) this.buffer.push(type, start, end, 4);\n        } else {\n            this.pos = end;\n            this.shiftContext(type, start);\n            if (type <= this.p.parser.maxNode) this.buffer.push(type, start, end, 4);\n        }\n    }\n    // Apply an action\n    /**\n    @internal\n    */ apply(action, next, nextStart, nextEnd) {\n        if (action & 65536 /* Action.ReduceFlag */ ) this.reduce(action);\n        else this.shift(action, next, nextStart, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /**\n    @internal\n    */ useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */ );\n        if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /**\n    @internal\n    */ split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while(off > 0 && parent.buffer[off - 2] > parent.reducePos)off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while(parent && base == parent.bufferBase)parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /**\n    @internal\n    */ recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode) this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Term.Err */ , this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Recover.Delete */ ;\n    }\n    /**\n    Check if the given term would be able to be shifted (optionally\n    after some reductions) on this stack. This can be useful for\n    external tokenizers that want to make sure they only provide a\n    given token when it applies.\n    */ canShift(term) {\n        for(let sim = new SimulatedStack(this);;){\n            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */ ) || this.p.parser.hasAction(sim.state, term);\n            if (action == 0) return false;\n            if ((action & 65536 /* Action.ReduceFlag */ ) == 0) return true;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /**\n    @internal\n    */ recoverByInsert(next) {\n        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */ ) return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* Recover.MaxNext */  << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */ ) {\n            let best = [];\n            for(let i = 0, s; i < nextStates.length; i += 2){\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */ ) for(let i = 0; best.length < 4 /* Recover.MaxNext */  << 1 && i < nextStates.length; i += 2){\n                let s = nextStates[i + 1];\n                if (!best.some((v, i)=>i & 1 && v == s)) best.push(nextStates[i], s);\n            }\n            nextStates = best;\n        }\n        let result = [];\n        for(let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */ ; i += 2){\n            let s = nextStates[i + 1];\n            if (s == this.state) continue;\n            let stack = this.split();\n            stack.pushState(s, this.pos);\n            stack.storeNode(0 /* Term.Err */ , stack.pos, stack.pos, 4, true);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.reducePos = this.pos;\n            stack.score -= 200 /* Recover.Insert */ ;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /**\n    @internal\n    */ forceReduce() {\n        let { parser } = this.p;\n        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */ );\n        if ((reduce & 65536 /* Action.ReduceFlag */ ) == 0) return false;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* Action.ReduceDepthShift */ , term = reduce & 65535 /* Action.ValueMask */ ;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n                let backup = this.findForcedReduction();\n                if (backup == null) return false;\n                reduce = backup;\n            }\n            this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n            this.score -= 100 /* Recover.Reduce */ ;\n        }\n        this.reducePos = this.pos;\n        this.reduce(reduce);\n        return true;\n    }\n    /**\n    Try to scan through the automaton to find some kind of reduction\n    that can be applied. Used when the regular ForcedReduce field\n    isn't a valid action. @internal\n    */ findForcedReduction() {\n        let { parser } = this.p, seen = [];\n        let explore = (state, depth)=>{\n            if (seen.includes(state)) return;\n            seen.push(state);\n            return parser.allActions(state, (action)=>{\n                if (action & (262144 /* Action.StayFlag */  | 131072 /* Action.GotoFlag */ )) ;\n                else if (action & 65536 /* Action.ReduceFlag */ ) {\n                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */ ) - depth;\n                    if (rDepth > 1) {\n                        let term = action & 65535 /* Action.ValueMask */ , target = this.stack.length - rDepth * 3;\n                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0) return rDepth << 19 /* Action.ReduceDepthShift */  | 65536 /* Action.ReduceFlag */  | term;\n                    }\n                } else {\n                    let found = explore(action, depth + 1);\n                    if (found != null) return found;\n                }\n            });\n        };\n        return explore(this.state, 0);\n    }\n    /**\n    @internal\n    */ forceAll() {\n        while(!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */ )){\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /**\n    Check whether this state has no further actions (assumed to be a direct descendant of the\n    top state, since any other states must be able to continue\n    somehow). @internal\n    */ get deadEnd() {\n        if (this.stack.length != 3) return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */ )] == 65535 /* Seq.End */  && !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */ );\n    }\n    /**\n    Restart the stack (put it back in its start state). Only safe\n    when this.stack.length == 3 (state is directly below the top\n    state). @internal\n    */ restart() {\n        this.storeNode(0 /* Term.Err */ , this.pos, this.pos, 4, true);\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /**\n    @internal\n    */ sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length) return false;\n        for(let i = 0; i < this.stack.length; i += 3)if (this.stack[i] != other.stack[i]) return false;\n        return true;\n    }\n    /**\n    Get the parser used by this stack.\n    */ get parser() {\n        return this.p.parser;\n    }\n    /**\n    Test whether a given dialect (by numeric ID, as exported from\n    the terms file) is enabled.\n    */ dialectEnabled(dialectID) {\n        return this.p.parser.dialect.flags[dialectID];\n    }\n    shiftContext(term, start) {\n        if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /**\n    @internal\n    */ emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n    }\n    /**\n    @internal\n    */ emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash) this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /**\n    @internal\n    */ setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /**\n    @internal\n    */ close() {\n        if (this.curContext && this.curContext.tracker.strict) this.emitContext();\n        if (this.lookAhead > 0) this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context){\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start){\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* Action.ValueMask */ , depth = action >> 19 /* Action.ReduceDepthShift */ ;\n        if (depth == 0) {\n            if (this.stack == this.start.stack) this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        } else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index){\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0) this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() {\n        return this.buffer[this.index - 4];\n    }\n    get start() {\n        return this.buffer[this.index - 3];\n    }\n    get end() {\n        return this.buffer[this.index - 2];\n    }\n    get size() {\n        return this.buffer[this.index - 1];\n    }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0) this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\") return input;\n    let array = null;\n    for(let pos = 0, out = 0; pos < input.length;){\n        let value = 0;\n        for(;;){\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* Encode.BigValCode */ ) {\n                value = 65535 /* Encode.BigVal */ ;\n                break;\n            }\n            if (next >= 92 /* Encode.Gap2 */ ) next--;\n            if (next >= 34 /* Encode.Gap1 */ ) next--;\n            let digit = next - 32 /* Encode.Start */ ;\n            if (digit >= 46 /* Encode.Base */ ) {\n                digit -= 46 /* Encode.Base */ ;\n                stop = true;\n            }\n            value += digit;\n            if (stop) break;\n            value *= 46 /* Encode.Base */ ;\n        }\n        if (array) array[out++] = value;\n        else array = new Type(value);\n    }\n    return array;\n}\nclass CachedToken {\n    constructor(){\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/ class InputStream {\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ input, /**\n    @internal\n    */ ranges){\n        this.input = input;\n        this.ranges = ranges;\n        /**\n        @internal\n        */ this.chunk = \"\";\n        /**\n        @internal\n        */ this.chunkOff = 0;\n        /**\n        Backup chunk\n        */ this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /**\n        The character code of the next code unit in the input, or -1\n        when the stream is at the end of the input.\n        */ this.next = -1;\n        /**\n        @internal\n        */ this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    /**\n    @internal\n    */ resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while(pos < range.from){\n            if (!index) return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while(assoc < 0 ? pos > range.to : pos >= range.to){\n            if (index == this.ranges.length - 1) return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /**\n    @internal\n    */ clipPos(pos) {\n        if (pos >= this.range.from && pos < this.range.to) return pos;\n        for (let range of this.ranges)if (range.to > pos) return Math.max(pos, range.from);\n        return this.end;\n    }\n    /**\n    Look at a code unit near the stream position. `.peek(0)` equals\n    `.next`, `.peek(-1)` gives you the previous character, and so\n    on.\n    \n    Note that looking around during tokenizing creates dependencies\n    on potentially far-away content, which may reduce the\n    effectiveness incremental parsingâ€”when looking forwardâ€”or even\n    cause invalid reparses when looking backward more than 25 code\n    units, since the library does not track lookbehind.\n    */ peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        } else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null) return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            } else {\n                let i = this.rangeIndex, range = this.range;\n                while(range.to <= pos)range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /**\n    Accept a token. By default, the end of the token is set to the\n    current stream position, but you can pass an offset (relative to\n    the stream position) to change that.\n    */ acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start) throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    /**\n    Accept a token ending at a specific given position.\n    */ acceptTokenTo(token, endPos) {\n        this.token.value = token;\n        this.token.end = endPos;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        } else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length) return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /**\n    Move the stream forward N (defaults to 1) code units. Returns\n    the new value of [`next`](#lr.InputStream.next).\n    */ advance(n = 1) {\n        this.chunkOff += n;\n        while(this.pos + n >= this.range.to){\n            if (this.rangeIndex == this.ranges.length - 1) return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /**\n    @internal\n    */ reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        } else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while(pos < this.range.from)this.range = this.ranges[--this.rangeIndex];\n            while(pos >= this.range.to)this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            } else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /**\n    @internal\n    */ read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges){\n            if (r.from >= to) break;\n            if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/**\n@internal\n*/ class TokenGroup {\n    constructor(data, id){\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) {\n        let { parser } = stack.p;\n        readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n    }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/ class LocalTokenGroup {\n    constructor(data, precTable, elseToken){\n        this.precTable = precTable;\n        this.elseToken = elseToken;\n        this.data = typeof data == \"string\" ? decodeArray(data) : data;\n    }\n    token(input, stack) {\n        let start = input.pos, skipped = 0;\n        for(;;){\n            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);\n            readToken(this.data, input, stack, 0, this.data, this.precTable);\n            if (input.token.value > -1) break;\n            if (this.elseToken == null) return;\n            if (!atEof) skipped++;\n            if (nextPos == null) break;\n            input.reset(nextPos, input.token);\n        }\n        if (skipped) {\n            input.reset(start, input.token);\n            input.acceptToken(this.elseToken, skipped);\n        }\n    }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/ class ExternalTokenizer {\n    /**\n    Create a tokenizer. The first argument is the function that,\n    given an input stream, scans for the types of tokens it\n    recognizes at the stream's position, and calls\n    [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    one.\n    */ constructor(/**\n    @internal\n    */ token, options = {}){\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;\n    scan: for(;;){\n        if ((groupMask & data[state]) == 0) break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for(let i = state + 3; i < accEnd; i += 2)if ((data[i + 1] & groupMask) > 0) {\n            let term = data[i];\n            if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {\n                input.acceptToken(term);\n                break;\n            }\n        }\n        let next = input.next, low = 0, high = data[state + 2];\n        // Special case for EOF\n        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */ ) {\n            state = data[accEnd + high * 3 - 1];\n            continue scan;\n        }\n        // Do a binary search on the state's edges\n        for(; low < high;){\n            let mid = low + high >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1] || 0x10000;\n            if (next < from) high = mid;\n            else if (next >= to) low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\nfunction findOffset(data, start, term) {\n    for(let i = start, next; (next = data[i]) != 65535 /* Seq.End */ ; i++)if (next == term) return i - start;\n    return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n    let iPrev = findOffset(tableData, tableOffset, prev);\n    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.IncludeAnonymous);\n    cursor.moveTo(pos);\n    for(;;){\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for(;;){\n            if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Safety.Margin */ )) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Safety.Margin */ ));\n            if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;\n            if (!cursor.parent()) return side < 0 ? 0 : tree.length;\n        }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet){\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while(this.trees.length){\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        } else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart) return null;\n        while(this.fragment && this.safeTo <= pos)this.nextFragment();\n        if (!this.fragment) return null;\n        for(;;){\n            let last = this.trees.length - 1;\n            if (last < 0) {\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom) return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to) return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) {\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            } else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream){\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map((_)=>new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */ );\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for(let i = 0; i < tokenizers.length; i++){\n            if ((1 << i & mask) == 0) continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback) continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Safety.Margin */ ) lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Term.Err */ ) {\n                let startIndex = actionIndex;\n                if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex) break;\n                }\n            }\n        }\n        while(this.actions.length > actionIndex)this.actions.pop();\n        if (lookAhead) stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken) return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */ ;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        let start = this.stream.clipPos(stack.pos);\n        tokenizer.token(this.stream.reset(start, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for(let i = 0; i < parser.specialized.length; i++)if (parser.specialized[i] == token.value) {\n                let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                    if ((result & 1) == 0 /* Specialize.Specialize */ ) token.value = result >> 1;\n                    else token.extended = result >> 1;\n                    break;\n                }\n            }\n        } else {\n            token.value = 0 /* Term.Err */ ;\n            token.end = this.stream.clipPos(start + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for(let i = 0; i < index; i += 3)if (this.actions[i] == action) return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for(let set = 0; set < 2; set++){\n            for(let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */  : 1 /* ParseState.Actions */ );; i += 3){\n                if (data[i] == 65535 /* Seq.End */ ) {\n                    if (data[i + 1] == 1 /* Seq.Next */ ) {\n                        i = pair(data, i + 2);\n                    } else {\n                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */ ) index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nclass Parse {\n    constructor(parser, input, fragments, ranges){\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // â™”, â™•, â™–, â™—, â™˜, â™™, â™ , â™¡, â™¢, â™£, â™¤, â™¥, â™¦, â™§\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.lastBigReductionStart = -1;\n        this.lastBigReductionSize = 0;\n        this.bigReductionCount = 0;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [\n            Stack.start(this, parser.top[0], from)\n        ];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // If a large amount of reductions happened with the same start\n        // position, force the stack out of that production in order to\n        // avoid creating a tree too deep to recurse through.\n        // (This is an ugly kludge, because unfortunately there is no\n        // straightforward, cheap way to check for this happening, due to\n        // the history of reductions only being available in an\n        // expensive-to-access format in the stack buffers.)\n        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */  && stacks.length == 1) {\n            let [s] = stacks;\n            while(s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart){}\n            this.bigReductionCount = this.lastBigReductionSize = 0;\n        }\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for(let i = 0; i < stacks.length; i++){\n            let stack = stacks[i];\n            for(;;){\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                } else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                } else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished) {\n                if (verbose) console.log(\"Finish with \" + this.stackID(finished));\n                return this.stackToTree(finished);\n            }\n            if (this.parser.strict) {\n                if (verbose && stopped) console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering) this.recovering = 5 /* Rec.Distance */ ;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished) {\n                if (verbose) console.log(\"Force-finish \" + this.stackID(finished));\n                return this.stackToTree(finished.forceAll());\n            }\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */ ;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b)=>b.score - a.score);\n                while(newStacks.length > maxRemaining)newStacks.pop();\n            }\n            if (newStacks.some((s)=>s.reducePos > pos)) this.recovering--;\n        } else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for(let i = 0; i < newStacks.length - 1; i++){\n                let stack = newStacks[i];\n                for(let j = i + 1; j < newStacks.length; j++){\n                    let other = newStacks[j];\n                    if (stack.sameState(other) || stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */  && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */ ) {\n                        if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {\n                            newStacks.splice(j--, 1);\n                        } else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n            if (newStacks.length > 12 /* Rec.MaxStackCount */ ) newStacks.splice(12 /* Rec.MaxStackCount */ , newStacks.length - 12 /* Rec.MaxStackCount */ );\n        }\n        this.minStackPos = newStacks[0].pos;\n        for(let i = 1; i < newStacks.length; i++)if (newStacks[i].pos < this.minStackPos) this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for(let cached = this.fragments.nodeAt(start); cached;){\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;\n                let inner = cached.children[0];\n                if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0) cached = inner;\n                else break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */ );\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose) console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */ )})`);\n            return true;\n        }\n        if (stack.stack.length >= 8400 /* Rec.CutDepth */ ) {\n            while(stack.stack.length > 6000 /* Rec.CutTo */  && stack.forceReduce()){}\n        }\n        let actions = this.tokens.getActions(stack);\n        for(let i = 0; i < actions.length;){\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            let main = this.tokens.mainToken;\n            localStack.apply(action, term, main ? main.start : localStack.pos, end);\n            if (verbose) console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */ ) == 0 ? \"shift\" : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */ )}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last) return true;\n            else if (localStack.pos > start) stacks.push(localStack);\n            else split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for(;;){\n            if (!this.advanceStack(stack, null, null)) return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for(let i = 0; i < stacks.length; i++){\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted) continue;\n                restarted = true;\n                stack.restart();\n                if (verbose) console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done) continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for(let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */ ; j++){\n                if (verbose) console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done) break;\n                if (verbose) forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)){\n                if (verbose) console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Term.Err */ ;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            } else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm\n        });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for(let i = 0; i < newStacks.length; i++){\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score) newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled){\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) {\n        return !this.disabled || this.disabled[term] == 0;\n    }\n}\nconst id = (x)=>x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/ class ContextTracker {\n    /**\n    Define a context tracker.\n    */ constructor(spec){\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (()=>0);\n        this.strict = spec.strict !== false;\n    }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/ class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /**\n    @internal\n    */ constructor(spec){\n        super();\n        /**\n        @internal\n        */ this.wrappers = [];\n        if (spec.version != 14 /* File.Version */ ) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */ })`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for(let i = 0; i < spec.repeatNodeCount; i++)nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map((r)=>spec.topRules[r][1]);\n        let nodeProps = [];\n        for(let i = 0; i < nodeNames.length; i++)nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([\n                prop,\n                prop.deserialize(String(value))\n            ]);\n        }\n        if (spec.nodeProps) for (let propSpec of spec.nodeProps){\n            let prop = propSpec[0];\n            if (typeof prop == \"string\") prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp[prop];\n            for(let i = 1; i < propSpec.length;){\n                let next = propSpec[i++];\n                if (next >= 0) {\n                    setProp(next, prop, propSpec[i++]);\n                } else {\n                    let value = propSpec[i + -next];\n                    for(let j = -next; j > 0; j--)setProp(propSpec[i++], prop, value);\n                    i++;\n                }\n            }\n        }\n        this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i)=>_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n                name: i >= this.minRepeatTerm ? undefined : name,\n                id: i,\n                props: nodeProps[i],\n                top: topTerms.indexOf(i) > -1,\n                error: i == 0,\n                skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n            })));\n        if (spec.propSources) this.nodeSet = this.nodeSet.extend(...spec.propSources);\n        this.strict = false;\n        this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specializerSpecs = spec.specialized || [];\n        this.specialized = new Uint16Array(this.specializerSpecs.length);\n        for(let i = 0; i < this.specializerSpecs.length; i++)this.specialized[i] = this.specializerSpecs[i].term;\n        this.specializers = this.specializerSpecs.map(getSpecializer);\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map((value)=>typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Get a goto table entry @internal\n    */ getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0]) return -1;\n        for(let pos = table[term + 1];;){\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose) return target;\n            for(let end = pos + (groupTag >> 1); pos < end; pos++)if (table[pos] == state) return target;\n            if (last) return -1;\n        }\n    }\n    /**\n    Check if this state has an action for a given terminal @internal\n    */ hasAction(state, terminal) {\n        let data = this.data;\n        for(let set = 0; set < 2; set++){\n            for(let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */  : 1 /* ParseState.Actions */ ), next;; i += 3){\n                if ((next = data[i]) == 65535 /* Seq.End */ ) {\n                    if (data[i + 1] == 1 /* Seq.Next */ ) next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Seq.Other */ ) return pair(data, i + 2);\n                    else break;\n                }\n                if (next == terminal || next == 0 /* Term.Err */ ) return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /**\n    @internal\n    */ stateSlot(state, slot) {\n        return this.states[state * 6 /* ParseState.Size */  + slot];\n    }\n    /**\n    @internal\n    */ stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* ParseState.Flags */ ) & flag) > 0;\n    }\n    /**\n    @internal\n    */ validAction(state, action) {\n        return !!this.allActions(state, (a)=>a == action ? true : null);\n    }\n    /**\n    @internal\n    */ allActions(state, action) {\n        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */ );\n        let result = deflt ? action(deflt) : undefined;\n        for(let i = this.stateSlot(state, 1 /* ParseState.Actions */ ); result == null; i += 3){\n            if (this.data[i] == 65535 /* Seq.End */ ) {\n                if (this.data[i + 1] == 1 /* Seq.Next */ ) i = pair(this.data, i + 2);\n                else break;\n            }\n            result = action(pair(this.data, i + 1));\n        }\n        return result;\n    }\n    /**\n    Get the states that can follow this one through shift actions or\n    goto jumps. @internal\n    */ nextStates(state) {\n        let result = [];\n        for(let i = this.stateSlot(state, 1 /* ParseState.Actions */ );; i += 3){\n            if (this.data[i] == 65535 /* Seq.End */ ) {\n                if (this.data[i + 1] == 1 /* Seq.Next */ ) i = pair(this.data, i + 2);\n                else break;\n            }\n            if ((this.data[i + 2] & 65536 /* Action.ReduceFlag */  >> 16) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i)=>i & 1 && v == value)) result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /**\n    Configure the parser. Returns a new parser instance that has the\n    given settings modified. Settings not provided in `config` are\n    kept from the original parser.\n    */ configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info) throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers) copy.tokenizers = this.tokenizers.map((t)=>{\n            let found = config.tokenizers.find((r)=>r.from == t);\n            return found ? found.to : t;\n        });\n        if (config.specializers) {\n            copy.specializers = this.specializers.slice();\n            copy.specializerSpecs = this.specializerSpecs.map((s, i)=>{\n                let found = config.specializers.find((r)=>r.from == s.external);\n                if (!found) return s;\n                let spec = Object.assign(Object.assign({}, s), {\n                    external: found.to\n                });\n                copy.specializers[i] = getSpecializer(spec);\n                return spec;\n            });\n        }\n        if (config.contextTracker) copy.context = config.contextTracker;\n        if (config.dialect) copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null) copy.strict = config.strict;\n        if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null) copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /**\n    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n    are registered for this parser.\n    */ hasWrappers() {\n        return this.wrappers.length > 0;\n    }\n    /**\n    Returns the name associated with a given term. This will only\n    work for all terms when the parser was generated with the\n    `--names` option. By default, only the names of tagged terms are\n    stored.\n    */ getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /**\n    The eof term id is always allocated directly after the node\n    types. @internal\n    */ get eofTerm() {\n        return this.maxNode + 1;\n    }\n    /**\n    The type of top node produced by the parser.\n    */ get topNode() {\n        return this.nodeSet.types[this.top[1]];\n    }\n    /**\n    @internal\n    */ dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /**\n    @internal\n    */ parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(()=>false);\n        if (dialect) for (let part of dialect.split(\" \")){\n            let id = values.indexOf(part);\n            if (id >= 0) flags[id] = true;\n        }\n        let disabled = null;\n        for(let i = 0; i < values.length; i++)if (!flags[i]) {\n            for(let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */ ;)(disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n        }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /**\n    Used by the output of the parser generator. Not available to\n    user code. @hide\n    */ static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) {\n    return data[off] | data[off + 1] << 16;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks){\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */ ) && (!best || best.score < stack.score)) best = stack;\n    }\n    return best;\n}\nfunction getSpecializer(spec) {\n    if (spec.external) {\n        let mask = spec.extend ? 1 /* Specialize.Extend */  : 0 /* Specialize.Specialize */ ;\n        return (value, stack)=>spec.external(value, stack) << 1 | mask;\n    }\n    return spec.get;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2xyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5RztBQUV6Rzs7Ozs7QUFLQSxHQUNBLE1BQU1PO0lBQ0Y7O0lBRUEsR0FDQUMsWUFDQTs7SUFFQSxHQUNBQyxDQUFDLEVBQ0Q7OztJQUdBLEdBQ0FDLEtBQUssRUFDTDs7SUFFQSxHQUNBQyxLQUFLLEVBQ0wsZ0VBQWdFO0lBQ2hFLGlFQUFpRTtJQUNqRSxnRUFBZ0U7SUFDaEUsYUFBYTtJQUNiOztJQUVBLEdBQ0FDLFNBQVMsRUFDVDs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7Ozs7SUFJQSxHQUNBQyxLQUFLLEVBQ0wsMERBQTBEO0lBQzFELDREQUE0RDtJQUM1RCx1REFBdUQ7SUFDdkQ7O0lBRUEsR0FDQUMsTUFBTSxFQUNOLGtFQUFrRTtJQUNsRSwyREFBMkQ7SUFDM0QsNERBQTREO0lBQzVELGlFQUFpRTtJQUNqRSxrQkFBa0I7SUFDbEI7O0lBRUEsR0FDQUMsVUFBVSxFQUNWOztJQUVBLEdBQ0FDLFVBQVUsRUFDVjs7SUFFQSxHQUNBQyxZQUFZLENBQUMsRUFDYixnRUFBZ0U7SUFDaEUsMkRBQTJEO0lBQzNELDREQUE0RDtJQUM1RCxnQkFBZ0I7SUFDaEI7O0lBRUEsR0FDQUMsTUFBTSxDQUFFO1FBQ0osSUFBSSxDQUFDVixDQUFDLEdBQUdBO1FBQ1QsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtJ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TSxLQUN6RW5RLE1BQU1ELENBQUMsQ0FBQ2tCLE1BQU0sQ0FBQzRCLFNBQVMsQ0FBQzdDLE1BQU1DLEtBQUssRUFBRSxFQUFFLHVCQUF1QixRQUM5RCxFQUFDaUYsUUFBUUEsS0FBSzlFLEtBQUssR0FBR0osTUFBTUksS0FBSyxHQUNsQzhFLE9BQU9sRjtJQUNmO0lBQ0EsT0FBT2tGO0FBQ1g7QUFDQSxTQUFTNlAsZUFBZTFCLElBQUk7SUFDeEIsSUFBSUEsS0FBS3FELFFBQVEsRUFBRTtRQUNmLElBQUlyTyxPQUFPZ0wsS0FBS3ZJLE1BQU0sR0FBRyxFQUFFLHFCQUFxQixNQUFLLEVBQUUseUJBQXlCO1FBQ2hGLE9BQU8sQ0FBQy9HLE9BQU8vRCxRQUFVLEtBQU0wVyxRQUFRLENBQUMzUyxPQUFPL0QsVUFBVSxJQUFLcUk7SUFDbEU7SUFDQSxPQUFPZ0wsS0FBS1IsR0FBRztBQUNuQjtBQUU0RiIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL0BsZXplci9sci9kaXN0L2luZGV4LmpzP2RkMGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFyc2VyLCBOb2RlUHJvcCwgTm9kZVNldCwgTm9kZVR5cGUsIERlZmF1bHRCdWZmZXJMZW5ndGgsIFRyZWUsIEl0ZXJNb2RlIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8qKlxuQSBwYXJzZSBzdGFjay4gVGhlc2UgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgcGFyc2VyIHRvIHRyYWNrXG5wYXJzaW5nIHByb2dyZXNzLiBUaGV5IGFsc28gcHJvdmlkZSBzb21lIHByb3BlcnRpZXMgYW5kIG1ldGhvZHNcbnRoYXQgZXh0ZXJuYWwgY29kZSBzdWNoIGFzIGEgdG9rZW5pemVyIGNhbiB1c2UgdG8gZ2V0IGluZm9ybWF0aW9uXG5hYm91dCB0aGUgcGFyc2Ugc3RhdGUuXG4qL1xuY2xhc3MgU3RhY2sge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBhcnNlIHRoYXQgdGhpcyBzdGFjayBpcyBwYXJ0IG9mIEBpbnRlcm5hbFxuICAgICovXG4gICAgcCwgXG4gICAgLyoqXG4gICAgSG9sZHMgc3RhdGUsIGlucHV0IHBvcywgYnVmZmVyIGluZGV4IHRyaXBsZXRzIGZvciBhbGwgYnV0IHRoZVxuICAgIHRvcCBzdGF0ZSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YWNrLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBwYXJzZSBzdGF0ZSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvLyBUaGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIG5leHQgcmVkdWNlIHNob3VsZCB0YWtlIHBsYWNlLiBUaGlzXG4gICAgLy8gY2FuIGJlIGxlc3MgdGhhbiBgdGhpcy5wb3NgIHdoZW4gc2tpcHBlZCBleHByZXNzaW9ucyBoYXZlIGJlZW5cbiAgICAvLyBhZGRlZCB0byB0aGUgc3RhY2sgKHdoaWNoIHNob3VsZCBiZSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBuZXh0XG4gICAgLy8gcmVkdWN0aW9uKVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVkdWNlUG9zLCBcbiAgICAvKipcbiAgICBUaGUgaW5wdXQgcG9zaXRpb24gdXAgdG8gd2hpY2ggdGhpcyBzdGFjayBoYXMgcGFyc2VkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgZHluYW1pYyBzY29yZSBvZiB0aGUgc3RhY2ssIGluY2x1ZGluZyBkeW5hbWljIHByZWNlZGVuY2VcbiAgICBhbmQgZXJyb3ItcmVjb3ZlcnkgcGVuYWx0aWVzXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzY29yZSwgXG4gICAgLy8gVGhlIG91dHB1dCBidWZmZXIuIEhvbGRzICh0eXBlLCBzdGFydCwgZW5kLCBzaXplKSBxdWFkc1xuICAgIC8vIHJlcHJlc2VudGluZyBub2RlcyBjcmVhdGVkIGJ5IHRoZSBwYXJzZXIsIHdoZXJlIGBzaXplYCBpc1xuICAgIC8vIGFtb3VudCBvZiBidWZmZXIgYXJyYXkgZW50cmllcyBjb3ZlcmVkIGJ5IHRoaXMgbm9kZS5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJ1ZmZlciwgXG4gICAgLy8gVGhlIGJhc2Ugb2Zmc2V0IG9mIHRoZSBidWZmZXIuIFdoZW4gc3RhY2tzIGFyZSBzcGxpdCwgdGhlIHNwbGl0XG4gICAgLy8gaW5zdGFuY2Ugc2hhcmVkIHRoZSBidWZmZXIgaGlzdG9yeSB3aXRoIGl0cyBwYXJlbnQgdXAgdG9cbiAgICAvLyBgYnVmZmVyQmFzZWAsIHdoaWNoIGlzIHRoZSBhYnNvbHV0ZSBvZmZzZXQgKGluY2x1ZGluZyB0aGVcbiAgICAvLyBvZmZzZXQgb2YgcHJldmlvdXMgc3BsaXRzKSBpbnRvIHRoZSBidWZmZXIgYXQgd2hpY2ggdGhpcyBzdGFja1xuICAgIC8vIHN0YXJ0cyB3cml0aW5nLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYnVmZmVyQmFzZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjdXJDb250ZXh0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvb2tBaGVhZCA9IDAsIFxuICAgIC8vIEEgcGFyZW50IHN0YWNrIGZyb20gd2hpY2ggdGhpcyB3YXMgc3BsaXQgb2ZmLCBpZiBhbnkuIFRoaXMgaXNcbiAgICAvLyBzZXQgdXAgc28gdGhhdCBpdCBhbHdheXMgcG9pbnRzIHRvIGEgc3RhY2sgdGhhdCBoYXMgc29tZVxuICAgIC8vIGFkZGl0aW9uYWwgYnVmZmVyIGNvbnRlbnQsIG5ldmVyIHRvIGEgc3RhY2sgd2l0aCBhbiBlcXVhbFxuICAgIC8vIGBidWZmZXJCYXNlYC5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHBhcmVudCkge1xuICAgICAgICB0aGlzLnAgPSBwO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5yZWR1Y2VQb3MgPSByZWR1Y2VQb3M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnNjb3JlID0gc2NvcmU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlckJhc2UgPSBidWZmZXJCYXNlO1xuICAgICAgICB0aGlzLmN1ckNvbnRleHQgPSBjdXJDb250ZXh0O1xuICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5zdGFjay5maWx0ZXIoKF8sIGkpID0+IGkgJSAzID09IDApLmNvbmNhdCh0aGlzLnN0YXRlKX1dQCR7dGhpcy5wb3N9JHt0aGlzLnNjb3JlID8gXCIhXCIgKyB0aGlzLnNjb3JlIDogXCJcIn1gO1xuICAgIH1cbiAgICAvLyBTdGFydCBhbiBlbXB0eSBzdGFja1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHN0YXJ0KHAsIHN0YXRlLCBwb3MgPSAwKSB7XG4gICAgICAgIGxldCBjeCA9IHAucGFyc2VyLmNvbnRleHQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2socCwgW10sIHN0YXRlLCBwb3MsIHBvcywgMCwgW10sIDAsIGN4ID8gbmV3IFN0YWNrQ29udGV4dChjeCwgY3guc3RhcnQpIDogbnVsbCwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFjaydzIGN1cnJlbnQgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlcikgdmFsdWUsIGlmXG4gICAgYW55LiBJdHMgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgY29udGV4dCB0cmFja2VyJ3MgdHlwZVxuICAgIHBhcmFtZXRlciwgb3IgaXQgd2lsbCBiZSBgbnVsbGAgaWYgdGhlcmUgaXMgbm8gY29udGV4dFxuICAgIHRyYWNrZXIuXG4gICAgKi9cbiAgICBnZXQgY29udGV4dCgpIHsgcmV0dXJuIHRoaXMuY3VyQ29udGV4dCA/IHRoaXMuY3VyQ29udGV4dC5jb250ZXh0IDogbnVsbDsgfVxuICAgIC8vIFB1c2ggYSBzdGF0ZSBvbnRvIHRoZSBzdGFjaywgdHJhY2tpbmcgaXRzIHN0YXJ0IHBvc2l0aW9uIGFzIHdlbGxcbiAgICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHB1c2hTdGF0ZShzdGF0ZSwgc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIHN0YXJ0LCB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIC8vIEFwcGx5IGEgcmVkdWNlIGFjdGlvblxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBkZXB0aCA9IGFjdGlvbiA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLywgdHlwZSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi87XG4gICAgICAgIGxldCB7IHBhcnNlciB9ID0gdGhpcy5wO1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwYXJzZXIuZ2V0R290byh0aGlzLnN0YXRlLCB0eXBlLCB0cnVlKSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8gPyA2IDogMCk7XG4gICAgICAgIGxldCBzdGFydCA9IGJhc2UgPyB0aGlzLnN0YWNrW2Jhc2UgLSAyXSA6IHRoaXMucC5yYW5nZXNbMF0uZnJvbSwgc2l6ZSA9IHRoaXMucmVkdWNlUG9zIC0gc3RhcnQ7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBrbHVkZ2UgdG8gdHJ5IGFuZCBkZXRlY3Qgb3Zlcmx5IGRlZXAgbGVmdC1hc3NvY2lhdGl2ZVxuICAgICAgICAvLyB0cmVlcywgd2hpY2ggd2lsbCBub3QgaW5jcmVhc2UgdGhlIHBhcnNlIHN0YWNrIGRlcHRoIGFuZCB0aHVzXG4gICAgICAgIC8vIHdvbid0IGJlIGNhdWdodCBieSB0aGUgcmVndWxhciBzdGFjay1kZXB0aCBsaW1pdCBjaGVjay5cbiAgICAgICAgaWYgKHNpemUgPj0gMjAwMCAvKiBSZWNvdmVyLk1pbkJpZ1JlZHVjdGlvbiAqLyAmJiAhKChfYSA9IHRoaXMucC5wYXJzZXIubm9kZVNldC50eXBlc1t0eXBlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQW5vbnltb3VzKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplIDwgc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucC5iaWdSZWR1Y3Rpb25Db3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZmZlckJhc2UgPSBiYXNlID8gdGhpcy5zdGFja1tiYXNlIC0gMV0gOiAwLCBjb3VudCA9IHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlckJhc2U7XG4gICAgICAgIC8vIFN0b3JlIG5vcm1hbCB0ZXJtcyBvciBgUiAtPiBSIFJgIHJlcGVhdCByZWR1Y3Rpb25zXG4gICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0gfHwgKGFjdGlvbiAmIDEzMTA3MiAvKiBBY3Rpb24uUmVwZWF0RmxhZyAqLykpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDEgLyogU3RhdGVGbGFnLlNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrW2Jhc2VdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJhc2VTdGF0ZUlEID0gdGhpcy5zdGFja1tiYXNlIC0gM107XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gcGFyc2VyLmdldEdvdG8oYmFzZVN0YXRlSUQsIHR5cGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IGJhc2UpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgIH1cbiAgICAvLyBTaGlmdCBhIHZhbHVlIGludG8gdGhlIGJ1ZmZlclxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBpc1JlZHVjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogVGVybS5FcnIgKi8gJiZcbiAgICAgICAgICAgICghdGhpcy5zdGFjay5sZW5ndGggfHwgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdIDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5idWZmZXJCYXNlKSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG9taXQvbWVyZ2UgYWRqYWNlbnQgZXJyb3Igbm9kZXNcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLCB0b3AgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9wID09IDAgJiYgY3VyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGN1ci5idWZmZXJCYXNlIC0gY3VyLnBhcmVudC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gMCAmJiBjdXIuYnVmZmVyW3RvcCAtIDRdID09IDAgLyogVGVybS5FcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZHVjZSB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogVGVybS5FcnIgKi8pXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhpcyByZWNvcmQgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gdGhpcy5idWZmZXJbaW5kZXggLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGVybTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhIHNoaWZ0IGFjdGlvblxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2hpZnQoYWN0aW9uLCB0eXBlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiAxMzEwNzIgLyogQWN0aW9uLkdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pID09IDApIHsgLy8gUmVndWxhciBzaGlmdFxuICAgICAgICAgICAgbGV0IG5leHRTdGF0ZSA9IGFjdGlvbiwgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0aGlzLnBvcyB8fCB0eXBlIDw9IHBhcnNlci5tYXhOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuc3RhdGVGbGFnKG5leHRTdGF0ZSwgMSAvKiBTdGF0ZUZsYWcuU2tpcHBlZCAqLykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkdWNlUG9zID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgICAgICAgICBpZiAodHlwZSA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHR5cGUsIHN0YXJ0LCBlbmQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBTaGlmdC1hbmQtc3RheSwgd2hpY2ggbWVhbnMgdGhpcyBpcyBhIHNraXBwZWQgdG9rZW5cbiAgICAgICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godHlwZSwgc3RhcnQsIGVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseShhY3Rpb24sIG5leHQsIG5leHRTdGFydCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pXG4gICAgICAgICAgICB0aGlzLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dFN0YXJ0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgKHJldXNlZCkgbm9kZSBpbnRvIHRoZSBidWZmZXIuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1c2VOb2RlKHZhbHVlLCBuZXh0KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucC5yZXVzZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLnAucmV1c2VkW2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wLnJldXNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3MgPSBzdGFydCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dCwgc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGluZGV4LCBzdGFydCwgdGhpcy5yZWR1Y2VQb3MsIC0xIC8qIHNpemUgPT0gLTEgbWVhbnMgdGhpcyBpcyBhIHJldXNlZCB2YWx1ZSAqLyk7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmV1c2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHZhbHVlLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHRoaXMucG9zIC0gdmFsdWUubGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLyBTcGxpdCB0aGUgc3RhY2suIER1ZSB0byB0aGUgYnVmZmVyIHNoYXJpbmcgYW5kIHRoZSBmYWN0XG4gICAgLy8gdGhhdCBgdGhpcy5zdGFja2AgdGVuZHMgdG8gc3RheSBxdWl0ZSBzaGFsbG93LCB0aGlzIGlzbid0IHZlcnlcbiAgICAvLyBleHBlbnNpdmUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzcGxpdCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgIGxldCBvZmYgPSBwYXJlbnQuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgdG9wIG9mIHRoZSBidWZmZXIgKGFmdGVyIHRoaXMucG9zKSBtYXkgYmUgbXV0YXRlZFxuICAgICAgICAvLyB0byByZW9yZGVyIHJlZHVjdGlvbnMgYW5kIHNraXBwZWQgdG9rZW5zLCBhbmQgc2hhcmVkIGJ1ZmZlcnNcbiAgICAgICAgLy8gc2hvdWxkIGJlIGltbXV0YWJsZSwgdGhpcyBjb3BpZXMgYW55IG91dHN0YW5kaW5nIHNraXBwZWQgdG9rZW5zXG4gICAgICAgIC8vIHRvIHRoZSBuZXcgYnVmZmVyLCBhbmQgcHV0cyB0aGUgYmFzZSBwb2ludGVyIGJlZm9yZSB0aGVtLlxuICAgICAgICB3aGlsZSAob2ZmID4gMCAmJiBwYXJlbnQuYnVmZmVyW29mZiAtIDJdID4gcGFyZW50LnJlZHVjZVBvcylcbiAgICAgICAgICAgIG9mZiAtPSA0O1xuICAgICAgICBsZXQgYnVmZmVyID0gcGFyZW50LmJ1ZmZlci5zbGljZShvZmYpLCBiYXNlID0gcGFyZW50LmJ1ZmZlckJhc2UgKyBvZmY7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBwYXJlbnQgcG9pbnRzIHRvIGFuIGFjdHVhbCBwYXJlbnQgd2l0aCBjb250ZW50LCBpZiB0aGVyZSBpcyBzdWNoIGEgcGFyZW50LlxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIGJhc2UgPT0gcGFyZW50LmJ1ZmZlckJhc2UpXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHRoaXMucCwgdGhpcy5zdGFjay5zbGljZSgpLCB0aGlzLnN0YXRlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5wb3MsIHRoaXMuc2NvcmUsIGJ1ZmZlciwgYmFzZSwgdGhpcy5jdXJDb250ZXh0LCB0aGlzLmxvb2tBaGVhZCwgcGFyZW50KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHJlY292ZXIgZnJvbSBhbiBlcnJvciBieSAnZGVsZXRpbmcnIChpZ25vcmluZykgb25lIHRva2VuLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgbmV4dEVuZCwgaXNOb2RlID8gOCA6IDQpO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgdGhpcy5zY29yZSAtPSAxOTAgLyogUmVjb3Zlci5EZWxldGUgKi87XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIGFmdGVyIHNvbWUgcmVkdWN0aW9ucykgb24gdGhpcyBzdGFjay4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxuICAgIGV4dGVybmFsIHRva2VuaXplcnMgdGhhdCB3YW50IHRvIG1ha2Ugc3VyZSB0aGV5IG9ubHkgcHJvdmlkZSBhXG4gICAgZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgICovXG4gICAgY2FuU2hpZnQodGVybSkge1xuICAgICAgICBmb3IgKGxldCBzaW0gPSBuZXcgU2ltdWxhdGVkU3RhY2sodGhpcyk7Oykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMucC5wYXJzZXIuc3RhdGVTbG90KHNpbS5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pIHx8IHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHNpbS5zdGF0ZSwgdGVybSk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNpbS5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSB1cCB0byBSZWNvdmVyLk1heE5leHQgcmVjb3ZlcnkgYWN0aW9ucyB0aGF0IGNvbmNlcHR1YWxseVxuICAgIC8vIGluc2VydHMgc29tZSBtaXNzaW5nIHRva2VuIG9yIHJ1bGUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIFJlY292ZXIuTWF4SW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IG5leHRTdGF0ZXMgPSB0aGlzLnAucGFyc2VyLm5leHRTdGF0ZXModGhpcy5zdGF0ZSk7XG4gICAgICAgIGlmIChuZXh0U3RhdGVzLmxlbmd0aCA+IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovIDw8IDEgfHwgdGhpcy5zdGFjay5sZW5ndGggPj0gMTIwIC8qIFJlY292ZXIuRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICgocyA9IG5leHRTdGF0ZXNbaSArIDFdKSAhPSB0aGlzLnN0YXRlICYmIHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHMsIG5leHQpKVxuICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogUmVjb3Zlci5EYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBiZXN0Lmxlbmd0aCA8IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovIDw8IDEgJiYgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZXN0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0U3RhdGVzID0gYmVzdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICBpZiAocyA9PSB0aGlzLnN0YXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaFN0YXRlKHMsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCBzdGFjay5wb3MsIHN0YWNrLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFjay5zaGlmdENvbnRleHQobmV4dFN0YXRlc1tpXSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICBzdGFjay5zY29yZSAtPSAyMDAgLyogUmVjb3Zlci5JbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3JjZVJlZHVjZSgpIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCByZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDUgLyogUGFyc2VTdGF0ZS5Gb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSByZWR1Y2UgPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHRlcm0gPSByZWR1Y2UgJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gZGVwdGggKiAzO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA8IDAgfHwgcGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0YXJnZXRdLCB0ZXJtLCBmYWxzZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhY2t1cCA9IHRoaXMuZmluZEZvcmNlZFJlZHVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChiYWNrdXAgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlZHVjZSA9IGJhY2t1cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjb3JlIC09IDEwMCAvKiBSZWNvdmVyLlJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIHNjYW4gdGhyb3VnaCB0aGUgYXV0b21hdG9uIHRvIGZpbmQgc29tZSBraW5kIG9mIHJlZHVjdGlvblxuICAgIHRoYXQgY2FuIGJlIGFwcGxpZWQuIFVzZWQgd2hlbiB0aGUgcmVndWxhciBGb3JjZWRSZWR1Y2UgZmllbGRcbiAgICBpc24ndCBhIHZhbGlkIGFjdGlvbi4gQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kRm9yY2VkUmVkdWN0aW9uKCkge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucCwgc2VlbiA9IFtdO1xuICAgICAgICBsZXQgZXhwbG9yZSA9IChzdGF0ZSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluY2x1ZGVzKHN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWVuLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5hbGxBY3Rpb25zKHN0YXRlLCAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAmICgyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovIHwgMTMxMDcyIC8qIEFjdGlvbi5Hb3RvRmxhZyAqLykpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgckRlcHRoID0gKGFjdGlvbiA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLykgLSBkZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJEZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSByRGVwdGggKiAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA+PSAwICYmIHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyRGVwdGggPDwgMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8pIHwgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8gfCB0ZXJtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBleHBsb3JlKGFjdGlvbiwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHBsb3JlKHRoaXMuc3RhdGUsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMucC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogU3RhdGVGbGFnLkFjY2VwdGluZyAqLykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JjZVJlZHVjZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICB0b3Agc3RhdGUsIHNpbmNlIGFueSBvdGhlciBzdGF0ZXMgbXVzdCBiZSBhYmxlIHRvIGNvbnRpbnVlXG4gICAgc29tZWhvdykuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5kYXRhW3BhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovICYmXG4gICAgICAgICAgICAhcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICB3aGVuIHRoaXMuc3RhY2subGVuZ3RoID09IDMgKHN0YXRlIGlzIGRpcmVjdGx5IGJlbG93IHRoZSB0b3BcbiAgICBzdGF0ZSkuIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzYW1lU3RhdGUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gb3RoZXIuc3RhdGUgfHwgdGhpcy5zdGFjay5sZW5ndGggIT0gb3RoZXIuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja1tpXSAhPSBvdGhlci5zdGFja1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgKi9cbiAgICBnZXQgcGFyc2VyKCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlcjsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgICB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICAqL1xuICAgIGRpYWxlY3RFbmFibGVkKGRpYWxlY3RJRCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlci5kaWFsZWN0LmZsYWdzW2RpYWxlY3RJRF07IH1cbiAgICBzaGlmdENvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zaGlmdCh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgcmVkdWNlQ29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJlZHVjZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbWl0Q29udGV4dCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTMpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnBvcywgdGhpcy5wb3MsIC0zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbWl0TG9va0FoZWFkKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtNClcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5sb29rQWhlYWQsIHRoaXMucG9zLCB0aGlzLnBvcywgLTQpO1xuICAgIH1cbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgIT0gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQpIHtcbiAgICAgICAgICAgIGxldCBuZXdDeCA9IG5ldyBTdGFja0NvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG5ld0N4Lmhhc2ggIT0gdGhpcy5jdXJDb250ZXh0Lmhhc2gpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gbmV3Q3g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXRMb29rQWhlYWQobG9va0FoZWFkKSB7XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiB0aGlzLmxvb2tBaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YXJ0LnN0YWNrO1xuICAgICAgICB0aGlzLmJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB9XG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2sgPT0gdGhpcy5zdGFydC5zdGFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iYXNlICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFydC5wLnBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGhpcy5iYXNlIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaywgcG9zID0gc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgcG9zLCBwb3MgLSBzdGFjay5idWZmZXJCYXNlKTtcbiAgICB9XG4gICAgbWF5YmVOZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RhY2sucGFyZW50O1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5idWZmZXJCYXNlIC0gbmV4dC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5leHQuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgICAgICAgdGhpcy5wb3MgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3IodGhpcy5zdGFjaywgdGhpcy5wb3MsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogRW5jb2RlLkJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEVuY29kZS5CaWdWYWwgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+PSA5MiAvKiBFbmNvZGUuR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBFbmNvZGUuR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogRW5jb2RlLlN0YXJ0ICovO1xuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IDQ2IC8qIEVuY29kZS5CYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5KVxuICAgICAgICAgICAgYXJyYXlbb3V0KytdID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmNsYXNzIENhY2hlZFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSAwO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAwO1xuICAgIH1cbn1cbmNvbnN0IG51bGxUb2tlbiA9IG5ldyBDYWNoZWRUb2tlbjtcbi8qKlxuW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbnRocm91Z2ggdGhpcyBpbnRlcmZhY2UuIEl0IHByZXNlbnRzIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZlxuY2hhcmFjdGVycywgdHJhY2tpbmcgbG9va2FoZWFkIGFuZCBoaWRpbmcgdGhlIGNvbXBsZXhpdHkgb2ZcbltyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbiovXG5jbGFzcyBJbnB1dFN0cmVhbSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmdlcykge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgQmFja3VwIGNodW5rXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsyID0gXCJcIjtcbiAgICAgICAgdGhpcy5jaHVuazJQb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGNoYXJhY3RlciBjb2RlIG9mIHRoZSBuZXh0IGNvZGUgdW5pdCBpbiB0aGUgaW5wdXQsIG9yIC0xXG4gICAgICAgIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVPZmZzZXQob2Zmc2V0LCBhc3NvYykge1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJhbmdlLCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICB3aGlsZSAocG9zIDwgcmFuZ2UuZnJvbSkge1xuICAgICAgICAgICAgaWYgKCFpbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbLS1pbmRleF07XG4gICAgICAgICAgICBwb3MgLT0gcmFuZ2UuZnJvbSAtIG5leHQudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFzc29jIDwgMCA/IHBvcyA+IHJhbmdlLnRvIDogcG9zID49IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbKytpbmRleF07XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5mcm9tIC0gcmFuZ2UudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjbGlwUG9zKHBvcykge1xuICAgICAgICBpZiAocG9zID49IHRoaXMucmFuZ2UuZnJvbSAmJiBwb3MgPCB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG4gICAgICAgICAgICBpZiAocmFuZ2UudG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHBvcywgcmFuZ2UuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBhdCBhIGNvZGUgdW5pdCBuZWFyIHRoZSBzdHJlYW0gcG9zaXRpb24uIGAucGVlaygwKWAgZXF1YWxzXG4gICAgYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIG9uLlxuICAgIFxuICAgIE5vdGUgdGhhdCBsb29raW5nIGFyb3VuZCBkdXJpbmcgdG9rZW5pemluZyBjcmVhdGVzIGRlcGVuZGVuY2llc1xuICAgIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgZWZmZWN0aXZlbmVzcyBpbmNyZW1lbnRhbCBwYXJzaW5n4oCUd2hlbiBsb29raW5nIGZvcndhcmTigJRvciBldmVuXG4gICAgY2F1c2UgaW52YWxpZCByZXBhcnNlcyB3aGVuIGxvb2tpbmcgYmFja3dhcmQgbW9yZSB0aGFuIDI1IGNvZGVcbiAgICB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICAqL1xuICAgIHBlZWsob2Zmc2V0KSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmNodW5rT2ZmICsgb2Zmc2V0LCBwb3MsIHJlc3VsdDtcbiAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlT2Zmc2V0KG9mZnNldCwgMSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBwb3MgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgcG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KHBvcyAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdGhpcy5yYW5nZUluZGV4LCByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlLnRvIDw9IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlc1srK2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLmNodW5rMlBvcyA9IHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCA+IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bmsyLnNsaWNlKDAsIHJhbmdlLnRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuLiBCeSBkZWZhdWx0LCB0aGUgZW5kIG9mIHRoZSB0b2tlbiBpcyBzZXQgdG8gdGhlXG4gICAgY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIHRoZSBzdHJlYW0gcG9zaXRpb24pIHRvIGNoYW5nZSB0aGF0LlxuICAgICovXG4gICAgYWNjZXB0VG9rZW4odG9rZW4sIGVuZE9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGVuZCA9IGVuZE9mZnNldCA/IHRoaXMucmVzb2x2ZU9mZnNldChlbmRPZmZzZXQsIC0xKSA6IHRoaXMucG9zO1xuICAgICAgICBpZiAoZW5kID09IG51bGwgfHwgZW5kIDwgdGhpcy50b2tlbi5zdGFydClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9rZW4gZW5kIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuIGVuZGluZyBhdCBhIHNwZWNpZmljIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgYWNjZXB0VG9rZW5Ubyh0b2tlbiwgZW5kUG9zKSB7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmRQb3M7XG4gICAgfVxuICAgIGdldENodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgdGhpcy5wb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgY2h1bmssIGNodW5rUG9zIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IHRoaXMuY2h1bmsyO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMuY2h1bmsyUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSBjaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gY2h1bmtQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gdGhpcy5wb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgbGV0IG5leHRDaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5wb3MpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucG9zICsgbmV4dENodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBlbmQgPiB0aGlzLnJhbmdlLnRvID8gbmV4dENodW5rLnNsaWNlKDAsIHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcykgOiBuZXh0Q2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPj0gdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID09IHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KHRoaXMuY2h1bmtPZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgdGhlIG5ldyB2YWx1ZSBvZiBbYG5leHRgXSgjbHIuSW5wdXRTdHJlYW0ubmV4dCkuXG4gICAgKi9cbiAgICBhZHZhbmNlKG4gPSAxKSB7XG4gICAgICAgIHRoaXMuY2h1bmtPZmYgKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zICsgbiA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgbiAtPSB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJhbmdlLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIHNldERvbmUoKSB7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHRoaXMuZW5kO1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4ID0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQocG9zLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgdG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4uZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zICE9IHBvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgICAgICBpZiAocG9zID09IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5yYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1stLXRoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVua1BvcyAmJiBwb3MgPCB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gcG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgdGhpcy5pZCwgcGFyc2VyLmRhdGEsIHBhcnNlci50b2tlblByZWNUYWJsZSk7XG4gICAgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vKipcbkBoaWRlXG4qL1xuY2xhc3MgTG9jYWxUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwcmVjVGFibGUsIGVsc2VUb2tlbikge1xuICAgICAgICB0aGlzLnByZWNUYWJsZSA9IHByZWNUYWJsZTtcbiAgICAgICAgdGhpcy5lbHNlVG9rZW4gPSBlbHNlVG9rZW47XG4gICAgICAgIHRoaXMuZGF0YSA9IHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgPyBkZWNvZGVBcnJheShkYXRhKSA6IGRhdGE7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgc3RhcnQgPSBpbnB1dC5wb3MsIHNraXBwZWQgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYXRFb2YgPSBpbnB1dC5uZXh0IDwgMCwgbmV4dFBvcyA9IGlucHV0LnJlc29sdmVPZmZzZXQoMSwgMSk7XG4gICAgICAgICAgICByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgc3RhY2ssIDAsIHRoaXMuZGF0YSwgdGhpcy5wcmVjVGFibGUpO1xuICAgICAgICAgICAgaWYgKGlucHV0LnRva2VuLnZhbHVlID4gLTEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5lbHNlVG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWF0RW9mKVxuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgIGlmIChuZXh0UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpbnB1dC5yZXNldChuZXh0UG9zLCBpbnB1dC50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnJlc2V0KHN0YXJ0LCBpbnB1dC50b2tlbik7XG4gICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0aGlzLmVsc2VUb2tlbiwgc2tpcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Mb2NhbFRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLyoqXG5gQGV4dGVybmFsIHRva2Vuc2AgZGVjbGFyYXRpb25zIGluIHRoZSBncmFtbWFyIHNob3VsZCByZXNvbHZlIHRvXG5hbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuKi9cbmNsYXNzIEV4dGVybmFsVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgcmVjb2duaXplcyBhdCB0aGUgc3RyZWFtJ3MgcG9zaXRpb24sIGFuZCBjYWxsc1xuICAgIFtgYWNjZXB0VG9rZW5gXSgjbHIuSW5wdXRTdHJlYW0uYWNjZXB0VG9rZW4pIHdoZW4gaXQgZmluZHNcbiAgICBvbmUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGBpbnB1dC50b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCwgcHJlY1RhYmxlLCBwcmVjT2Zmc2V0KSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgeyBkaWFsZWN0IH0gPSBzdGFjay5wLnBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlLCBwcmVjVGFibGUsIHByZWNPZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGlucHV0Lm5leHQsIGxvdyA9IDAsIGhpZ2ggPSBkYXRhW3N0YXRlICsgMl07XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgRU9GXG4gICAgICAgIGlmIChpbnB1dC5uZXh0IDwgMCAmJiBoaWdoID4gbG93ICYmIGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAzXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAoOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdIHx8IDB4MTAwMDA7XG4gICAgICAgICAgICBpZiAobmV4dCA8IGZyb20pXG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gdG8pXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogU2VxLkVuZCAqLzsgaSsrKVxuICAgICAgICBpZiAobmV4dCA9PSB0ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIGkgLSBzdGFydDtcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBvdmVycmlkZXModG9rZW4sIHByZXYsIHRhYmxlRGF0YSwgdGFibGVPZmZzZXQpIHtcbiAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRhYmxlRGF0YSwgdGFibGVPZmZzZXQsIHByZXYpO1xuICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0YWJsZURhdGEsIHRhYmxlT2Zmc2V0LCB0b2tlbikgPCBpUHJldjtcbn1cblxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIFNhZmV0eS5NYXJnaW4gKi8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbih0cmVlLmxlbmd0aCwgTWF0aC5tYXgoY3Vyc29yLmZyb20gKyAxLCBwb3MgKyAyNSAvKiBTYWZldHkuTWFyZ2luICovKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IDAgOiB0cmVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzLCBub2RlU2V0KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYWZlRnJvbSA9IC0xO1xuICAgICAgICB0aGlzLnNhZmVUbyA9IC0xO1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBuZXh0RnJhZ21lbnQoKSB7XG4gICAgICAgIGxldCBmciA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICAgICAgaWYgKGZyKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVGcm9tID0gZnIub3BlblN0YXJ0ID8gY3V0QXQoZnIudHJlZSwgZnIuZnJvbSArIGZyLm9mZnNldCwgMSkgLSBmci5vZmZzZXQgOiBmci5mcm9tO1xuICAgICAgICAgICAgdGhpcy5zYWZlVG8gPSBmci5vcGVuRW5kID8gY3V0QXQoZnIudHJlZSwgZnIudG8gKyBmci5vZmZzZXQsIC0xKSAtIGZyLm9mZnNldCA6IGZyLnRvO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHJlZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2goZnIudHJlZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goLWZyLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHRoaXMuc2FmZUZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IDFlOTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBgcG9zYCBtdXN0IGJlID49IGFueSBwcmV2aW91c2x5IGdpdmVuIGBwb3NgIGZvciB0aGlzIGN1cnNvclxuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2FmZVRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJlZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgeyAvLyBFbmQgb2YgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50cmVlc1tsYXN0XSwgaW5kZXggPSB0aGlzLmluZGV4W2xhc3RdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRvcC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnRbbGFzdF0gKyB0b3AucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHRoaXMuc2FmZUZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSBuZXh0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9va0FoZWFkIHx8IGVuZCArIGxvb2tBaGVhZCA8IHRoaXMuZnJhZ21lbnQudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIHBvcykpIHsgLy8gRW50ZXIgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrKSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IHRva2VuaXplcnMgfSA9IHBhcnNlcjtcbiAgICAgICAgbGV0IG1hc2sgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCAzIC8qIFBhcnNlU3RhdGUuVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3RhY2suY3VyQ29udGV4dCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgIGxldCBsb29rQWhlYWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKDEgPDwgaSkgJiBtYXNrKSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRva2VuaXplciA9IHRva2VuaXplcnNbaV0sIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAobWFpbiAmJiAhdG9rZW5pemVyLmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRva2VuaXplci5jb250ZXh0dWFsIHx8IHRva2VuLnN0YXJ0ICE9IHN0YWNrLnBvcyB8fCB0b2tlbi5tYXNrICE9IG1hc2sgfHwgdG9rZW4uY29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgdG9rZW4ubWFzayA9IG1hc2s7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4ubG9va0FoZWFkID4gdG9rZW4uZW5kICsgMjUgLyogU2FmZXR5Lk1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBNYXRoLm1heCh0b2tlbi5sb29rQWhlYWQsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgIT0gMCAvKiBUZXJtLkVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmIChsb29rQWhlYWQpXG4gICAgICAgICAgICBzdGFjay5zZXRMb29rQWhlYWQobG9va0FoZWFkKTtcbiAgICAgICAgaWYgKCFtYWluICYmIHN0YWNrLnBvcyA9PSB0aGlzLnN0cmVhbS5lbmQpIHtcbiAgICAgICAgICAgIG1haW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4gICAgICAgICAgICBtYWluLnZhbHVlID0gc3RhY2sucC5wYXJzZXIuZW9mVGVybTtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBtYWluLmVuZCA9IHN0YWNrLnBvcztcbiAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCBtYWluLnZhbHVlLCBtYWluLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgZ2V0TWFpblRva2VuKHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW5Ub2tlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW5Ub2tlbjtcbiAgICAgICAgbGV0IG1haW4gPSBuZXcgQ2FjaGVkVG9rZW4sIHsgcG9zLCBwIH0gPSBzdGFjaztcbiAgICAgICAgbWFpbi5zdGFydCA9IHBvcztcbiAgICAgICAgbWFpbi5lbmQgPSBNYXRoLm1pbihwb3MgKyAxLCBwLnN0cmVhbS5lbmQpO1xuICAgICAgICBtYWluLnZhbHVlID0gcG9zID09IHAuc3RyZWFtLmVuZCA/IHAucGFyc2VyLmVvZlRlcm0gOiAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhzdGFjay5wb3MpO1xuICAgICAgICB0b2tlbml6ZXIudG9rZW4odGhpcy5zdHJlYW0ucmVzZXQoc3RhcnQsIHRva2VuKSwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZXIuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zcGVjaWFsaXplZFtpXSA9PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VyLnNwZWNpYWxpemVyc1tpXSh0aGlzLnN0cmVhbS5yZWFkKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPj0gMCAmJiBzdGFjay5wLnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICB0b2tlbi5lbmQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBTZXEuT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAyKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0OyAvLyDimZQsIOKZlSwg4pmWLCDimZcsIOKZmCwg4pmZLCDimaAsIOKZoSwg4pmiLCDimaMsIOKZpCwg4pmlLCDimaYsIOKZp1xuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gMDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMDtcbiAgICAgICAgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBJZiBhIGxhcmdlIGFtb3VudCBvZiByZWR1Y3Rpb25zIGhhcHBlbmVkIHdpdGggdGhlIHNhbWUgc3RhcnRcbiAgICAgICAgLy8gcG9zaXRpb24sIGZvcmNlIHRoZSBzdGFjayBvdXQgb2YgdGhhdCBwcm9kdWN0aW9uIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGF2b2lkIGNyZWF0aW5nIGEgdHJlZSB0b28gZGVlcCB0byByZWN1cnNlIHRocm91Z2guXG4gICAgICAgIC8vIChUaGlzIGlzIGFuIHVnbHkga2x1ZGdlLCBiZWNhdXNlIHVuZm9ydHVuYXRlbHkgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gc3RyYWlnaHRmb3J3YXJkLCBjaGVhcCB3YXkgdG8gY2hlY2sgZm9yIHRoaXMgaGFwcGVuaW5nLCBkdWUgdG9cbiAgICAgICAgLy8gdGhlIGhpc3Rvcnkgb2YgcmVkdWN0aW9ucyBvbmx5IGJlaW5nIGF2YWlsYWJsZSBpbiBhblxuICAgICAgICAvLyBleHBlbnNpdmUtdG8tYWNjZXNzIGZvcm1hdCBpbiB0aGUgc3RhY2sgYnVmZmVycy4pXG4gICAgICAgIGlmICh0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID4gMzAwIC8qIFJlYy5NYXhMZWZ0QXNzb2NpYXRpdmVSZWR1Y3Rpb25Db3VudCAqLyAmJiBzdGFja3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBbc10gPSBzdGFja3M7XG4gICAgICAgICAgICB3aGlsZSAocy5mb3JjZVJlZHVjZSgpICYmIHMuc3RhY2subGVuZ3RoICYmIHMuc3RhY2tbcy5zdGFjay5sZW5ndGggLSAyXSA+PSB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCkgeyB9XG4gICAgICAgICAgICB0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID0gdGhpcy5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCBhZHZhbmNpbmcgYW55IHN0YWNrcyBhdCBgcG9zYCB1bnRpbCB0aGV5IGVpdGhlciBtb3ZlXG4gICAgICAgIC8vIGZvcndhcmQgb3IgY2FuJ3QgYmUgYWR2YW5jZWQuIEdhdGhlciBzdGFja3MgdGhhdCBjYW4ndCBiZVxuICAgICAgICAvLyBhZHZhbmNlZCBmdXJ0aGVyIGluIGBzdG9wcGVkYC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLmdldE1haW5Ub2tlbihzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmluaXNoIHdpdGggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgJiYgc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdHVjayB3aXRoIHRva2VuIFwiICsgKHRoaXMudG9rZW5zLm1haW5Ub2tlbiA/IHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSA6IFwibm9uZVwiKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBSZWMuRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0b3BwZWRbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBzdG9wcGVkWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3JjZS1maW5pc2ggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBSZWMuTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8gJiYgb3RoZXIuYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8pXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZSgxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLywgbmV3U3RhY2tzLmxlbmd0aCAtIDEyIC8qIFJlYy5NYXhTdGFja0NvdW50ICovKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzWzBdLnBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnBvcyA8IHRoaXMubWluU3RhY2tQb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RhcnQgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5mb3JjZVJlZHVjZSgpID8gc3RhY2sgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBzdHJpY3RDeCA9IHN0YWNrLmN1ckNvbnRleHQgJiYgc3RhY2suY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgY3hIYXNoID0gc3RyaWN0Q3ggPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGggJiYgKCFzdHJpY3RDeCB8fCAoY2FjaGVkLnByb3AoTm9kZVByb3AuY29udGV4dEhhc2gpIHx8IDApID09IGN4SGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBUcmVlKSB8fCBjYWNoZWQuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgY2FjaGVkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNhY2hlZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIgaW5zdGFuY2VvZiBUcmVlICYmIGNhY2hlZC5wb3NpdGlvbnNbMF0gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgaWYgKGRlZmF1bHRSZWR1Y2UgPiAwKSB7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2UoZGVmYXVsdFJlZHVjZSk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSBhbHdheXMtcmVkdWNlICR7cGFyc2VyLmdldE5hbWUoZGVmYXVsdFJlZHVjZSAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5zdGFjay5sZW5ndGggPj0gODQwMCAvKiBSZWMuQ3V0RGVwdGggKi8pIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5zdGFjay5sZW5ndGggPiA2MDAwIC8qIFJlYy5DdXRUbyAqLyAmJiBzdGFjay5mb3JjZVJlZHVjZSgpKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2spO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNbaSsrXSwgdGVybSA9IGFjdGlvbnNbaSsrXSwgZW5kID0gYWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGFjdGlvbnMubGVuZ3RoIHx8ICFzcGxpdDtcbiAgICAgICAgICAgIGxldCBsb2NhbFN0YWNrID0gbGFzdCA/IHN0YWNrIDogc3RhY2suc3BsaXQoKTtcbiAgICAgICAgICAgIGxldCBtYWluID0gdGhpcy50b2tlbnMubWFpblRva2VuO1xuICAgICAgICAgICAgbG9jYWxTdGFjay5hcHBseShhY3Rpb24sIHRlcm0sIG1haW4gPyBtYWluLnN0YXJ0IDogbG9jYWxTdGFjay5wb3MsIGVuZCk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGxvY2FsU3RhY2spICsgYCAodmlhICR7KGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwID8gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgIDogYHJlZHVjZSBvZiAke3BhcnNlci5nZXROYW1lKGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8pfWB9IGZvciAke3BhcnNlci5nZXROYW1lKHRlcm0pfSBAICR7c3RhcnR9JHtsb2NhbFN0YWNrID09IHN0YWNrID8gXCJcIiA6IFwiLCBzcGxpdFwifSlgKTtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxTdGFjay5wb3MgPiBzdGFydClcbiAgICAgICAgICAgICAgICBzdGFja3MucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzcGxpdC5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWR2YW5jZSBhIGdpdmVuIHN0YWNrIGZvcndhcmQgYXMgZmFyIGFzIGl0IHdpbGwgZ28uIFJldHVybnMgdGhlXG4gICAgLy8gKHBvc3NpYmx5IHVwZGF0ZWQpIHN0YWNrIGlmIGl0IGdvdCBzdHVjaywgb3IgbnVsbCBpZiBpdCBtb3ZlZFxuICAgIC8vIGZvcndhcmQgYW5kIHdhcyBnaXZlbiB0byBgcHVzaFN0YWNrRGVkdXBgLlxuICAgIGFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBwb3MgPSBzdGFjay5wb3M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG51bGwsIG51bGwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5SZWNvdmVyeShzdGFja3MsIHRva2VucywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBmaW5pc2hlZCA9IG51bGwsIHJlc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCB0b2tlbiA9IHRva2Vuc1tpIDw8IDFdLCB0b2tlbkVuZCA9IHRva2Vuc1soaSA8PCAxKSArIDFdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChzdGFjay5kZWFkRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmVzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFjay5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgKHJlc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBzdGFjay5zcGxpdCgpLCBmb3JjZUJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGZvcmNlLmZvcmNlUmVkdWNlKCkgJiYgaiA8IDEwIC8qIFJlYy5Gb3JjZVJlZHVjZUxpbWl0ICovOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm9yY2VCYXNlICsgdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiICh2aWEgZm9yY2UtcmVkdWNlKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KGZvcmNlLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VCYXNlID0gdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiIC0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaW5zZXJ0IG9mIHN0YWNrLnJlY292ZXJCeUluc2VydCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChpbnNlcnQpICsgXCIgKHZpYSByZWNvdmVyLWluc2VydClcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlRnVsbHkoaW5zZXJ0LCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmVuZCA+IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkVuZCA9PSBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFjay5yZWNvdmVyQnlEZWxldGUodG9rZW4sIHRva2VuRW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmVjb3Zlci1kZWxldGUgJHt0aGlzLnBhcnNlci5nZXROYW1lKHRva2VuKX0pYCk7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluaXNoZWQgfHwgZmluaXNoZWQuc2NvcmUgPCBzdGFjay5zY29yZSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBzdGFjaydzIGJ1ZmZlciB0byBhIHN5bnRheCB0cmVlLlxuICAgIHN0YWNrVG9UcmVlKHN0YWNrKSB7XG4gICAgICAgIHN0YWNrLmNsb3NlKCk7XG4gICAgICAgIHJldHVybiBUcmVlLmJ1aWxkKHsgYnVmZmVyOiBTdGFja0J1ZmZlckN1cnNvci5jcmVhdGUoc3RhY2spLFxuICAgICAgICAgICAgbm9kZVNldDogdGhpcy5wYXJzZXIubm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiB0aGlzLnRvcFRlcm0sXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IHRoaXMucGFyc2VyLmJ1ZmZlckxlbmd0aCxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5yZXVzZWQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgICAgICAgIGxlbmd0aDogc3RhY2sucG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgICAgICAgIG1pblJlcGVhdFR5cGU6IHRoaXMucGFyc2VyLm1pblJlcGVhdFRlcm0gfSk7XG4gICAgfVxuICAgIHN0YWNrSUQoc3RhY2spIHtcbiAgICAgICAgbGV0IGlkID0gKHN0YWNrSURzIHx8IChzdGFja0lEcyA9IG5ldyBXZWFrTWFwKSkuZ2V0KHN0YWNrKTtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHN0YWNrSURzLnNldChzdGFjaywgaWQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLm5leHRTdGFja0lEKyspKTtcbiAgICAgICAgcmV0dXJuIGlkICsgc3RhY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA9PSBzdGFjay5wb3MgJiYgb3RoZXIuc2FtZVN0YXRlKHN0YWNrKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgIG5ld1N0YWNrc1tpXSA9IHN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbn1cbmNsYXNzIERpYWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZmxhZ3MsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgYWxsb3dzKHRlcm0pIHsgcmV0dXJuICF0aGlzLmRpc2FibGVkIHx8IHRoaXMuZGlzYWJsZWRbdGVybV0gPT0gMDsgfVxufVxuY29uc3QgaWQgPSB4ID0+IHg7XG4vKipcbkNvbnRleHQgdHJhY2tlcnMgYXJlIHVzZWQgdG8gdHJhY2sgc3RhdGVmdWwgY29udGV4dCAoc3VjaCBhc1xuaW5kZW50YXRpb24gaW4gdGhlIFB5dGhvbiBncmFtbWFyLCBvciBwYXJlbnQgZWxlbWVudHMgaW4gdGhlIFhNTFxuZ3JhbW1hcikgbmVlZGVkIGJ5IGV4dGVybmFsIHRva2VuaXplcnMuIFlvdSBkZWNsYXJlIHRoZW0gaW4gYVxuZ3JhbW1hciBmaWxlIGFzIGBAY29udGV4dCBleHBvcnROYW1lIGZyb20gXCJtb2R1bGVcImAuXG5cbkNvbnRleHQgdmFsdWVzIHNob3VsZCBiZSBpbW11dGFibGUsIGFuZCBjYW4gYmUgdXBkYXRlZCAocmVwbGFjZWQpXG5vbiBzaGlmdCBvciByZWR1Y2UgYWN0aW9ucy5cblxuVGhlIGV4cG9ydCB1c2VkIGluIGEgYEBjb250ZXh0YCBkZWNsYXJhdGlvbiBzaG91bGQgYmUgb2YgdGhpc1xudHlwZS5cbiovXG5jbGFzcyBDb250ZXh0VHJhY2tlciB7XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgY29udGV4dCB0cmFja2VyLlxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3BlYy5zdGFydDtcbiAgICAgICAgdGhpcy5zaGlmdCA9IHNwZWMuc2hpZnQgfHwgaWQ7XG4gICAgICAgIHRoaXMucmVkdWNlID0gc3BlYy5yZWR1Y2UgfHwgaWQ7XG4gICAgICAgIHRoaXMucmV1c2UgPSBzcGVjLnJldXNlIHx8IGlkO1xuICAgICAgICB0aGlzLmhhc2ggPSBzcGVjLmhhc2ggfHwgKCgpID0+IDApO1xuICAgICAgICB0aGlzLnN0cmljdCA9IHNwZWMuc3RyaWN0ICE9PSBmYWxzZTtcbiAgICB9XG59XG4vKipcbkhvbGRzIHRoZSBwYXJzZSB0YWJsZXMgZm9yIGEgZ2l2ZW4gZ3JhbW1hciwgYXMgZ2VuZXJhdGVkIGJ5XG5gbGV6ZXItZ2VuZXJhdG9yYCwgYW5kIHByb3ZpZGVzIFttZXRob2RzXSgjY29tbW9uLlBhcnNlcikgdG8gcGFyc2VcbmNvbnRlbnQgd2l0aC5cbiovXG5jbGFzcyBMUlBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwcGVycyA9IFtdO1xuICAgICAgICBpZiAoc3BlYy52ZXJzaW9uICE9IDE0IC8qIEZpbGUuVmVyc2lvbiAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQYXJzZXIgdmVyc2lvbiAoJHtzcGVjLnZlcnNpb259KSBkb2Vzbid0IG1hdGNoIHJ1bnRpbWUgdmVyc2lvbiAoJHsxNCAvKiBGaWxlLlZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgbm9kZU5hbWVzID0gc3BlYy5ub2RlTmFtZXMuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLm1pblJlcGVhdFRlcm0gPSBub2RlTmFtZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMucmVwZWF0Tm9kZUNvdW50OyBpKyspXG4gICAgICAgICAgICBub2RlTmFtZXMucHVzaChcIlwiKTtcbiAgICAgICAgbGV0IHRvcFRlcm1zID0gT2JqZWN0LmtleXMoc3BlYy50b3BSdWxlcykubWFwKHIgPT4gc3BlYy50b3BSdWxlc1tyXVsxXSk7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IE5vZGVQcm9wW3Byb3BdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcFNwZWMubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHByb3BTcGVjW2krK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AobmV4dCwgcHJvcCwgcHJvcFNwZWNbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wU3BlY1tpICsgLW5leHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC1uZXh0OyBqID4gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AocHJvcFNwZWNbaSsrXSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVTZXQgPSBuZXcgTm9kZVNldChub2RlTmFtZXMubWFwKChuYW1lLCBpKSA9PiBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICAgICAgbmFtZTogaSA+PSB0aGlzLm1pblJlcGVhdFRlcm0gPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICBwcm9wczogbm9kZVByb3BzW2ldLFxuICAgICAgICAgICAgdG9wOiB0b3BUZXJtcy5pbmRleE9mKGkpID4gLTEsXG4gICAgICAgICAgICBlcnJvcjogaSA9PSAwLFxuICAgICAgICAgICAgc2tpcHBlZDogc3BlYy5za2lwcGVkTm9kZXMgJiYgc3BlYy5za2lwcGVkTm9kZXMuaW5kZXhPZihpKSA+IC0xXG4gICAgICAgIH0pKSk7XG4gICAgICAgIGlmIChzcGVjLnByb3BTb3VyY2VzKVxuICAgICAgICAgICAgdGhpcy5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5zcGVjLnByb3BTb3VyY2VzKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgdG9rZW5BcnJheSA9IGRlY29kZUFycmF5KHNwZWMudG9rZW5EYXRhKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gc3BlYy5jb250ZXh0O1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVyU3BlY3MgPSBzcGVjLnNwZWNpYWxpemVkIHx8IFtdO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVkID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZWRbaV0gPSB0aGlzLnNwZWNpYWxpemVyU3BlY3NbaV0udGVybTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplcnMgPSB0aGlzLnNwZWNpYWxpemVyU3BlY3MubWFwKGdldFNwZWNpYWxpemVyKTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlcywgVWludDMyQXJyYXkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlRGF0YSk7XG4gICAgICAgIHRoaXMuZ290byA9IGRlY29kZUFycmF5KHNwZWMuZ290byk7XG4gICAgICAgIHRoaXMubWF4VGVybSA9IHNwZWMubWF4VGVybTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXJzID0gc3BlYy50b2tlbml6ZXJzLm1hcCh2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IG5ldyBUb2tlbkdyb3VwKHRva2VuQXJyYXksIHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgdGhpcy50b3BSdWxlcyA9IHNwZWMudG9wUnVsZXM7XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSBzcGVjLmRpYWxlY3RzIHx8IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcyA9IHNwZWMuZHluYW1pY1ByZWNlZGVuY2VzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5QcmVjVGFibGUgPSBzcGVjLnRva2VuUHJlYztcbiAgICAgICAgdGhpcy50ZXJtTmFtZXMgPSBzcGVjLnRlcm1OYW1lcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm1heE5vZGUgPSB0aGlzLm5vZGVTZXQudHlwZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcFJ1bGVzW09iamVjdC5rZXlzKHRoaXMudG9wUnVsZXMpWzBdXTtcbiAgICB9XG4gICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IG5ldyBQYXJzZSh0aGlzLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCB3IG9mIHRoaXMud3JhcHBlcnMpXG4gICAgICAgICAgICBwYXJzZSA9IHcocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIHJldHVybiBwYXJzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEdvdG8oc3RhdGUsIHRlcm0sIGxvb3NlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5nb3RvO1xuICAgICAgICBpZiAodGVybSA+PSB0YWJsZVswXSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGFibGVbdGVybSArIDFdOzspIHtcbiAgICAgICAgICAgIGxldCBncm91cFRhZyA9IHRhYmxlW3BvcysrXSwgbGFzdCA9IGdyb3VwVGFnICYgMTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0YWJsZVtwb3MrK107XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsb29zZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgZW5kID0gcG9zICsgKGdyb3VwVGFnID4+IDEpOyBwb3MgPCBlbmQ7IHBvcysrKVxuICAgICAgICAgICAgICAgIGlmICh0YWJsZVtwb3NdID09IHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIGlmIHRoaXMgc3RhdGUgaGFzIGFuIGFjdGlvbiBmb3IgYSBnaXZlbiB0ZXJtaW5hbCBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pLCBuZXh0OzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXh0ID0gZGF0YVtpXSkgPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogU2VxLk90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gdGVybWluYWwgfHwgbmV4dCA9PSAwIC8qIFRlcm0uRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGVTbG90KHN0YXRlLCBzbG90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1soc3RhdGUgKiA2IC8qIFBhcnNlU3RhdGUuU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZUZsYWcoc3RhdGUsIGZsYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMCAvKiBQYXJzZVN0YXRlLkZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB2YWxpZEFjdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYWxsQWN0aW9ucyhzdGF0ZSwgYSA9PiBhID09IGFjdGlvbiA/IHRydWUgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhbGxBY3Rpb25zKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlZmx0ID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGRlZmx0ID8gYWN0aW9uKGRlZmx0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7IHJlc3VsdCA9PSBudWxsOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBhY3Rpb24ocGFpcih0aGlzLmRhdGEsIGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIGdvdG8ganVtcHMuIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmV4dFN0YXRlcyhzdGF0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmRhdGFbaSArIDJdICYgKDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIGdpdmVuIHNldHRpbmdzIG1vZGlmaWVkLiBTZXR0aW5ncyBub3QgcHJvdmlkZWQgaW4gYGNvbmZpZ2AgYXJlXG4gICAga2VwdCBmcm9tIHRoZSBvcmlnaW5hbCBwYXJzZXIuXG4gICAgKi9cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zcGVjaWFsaXplcnMpIHtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJTcGVjcyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoKHMsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcuc3BlY2lhbGl6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gcy5leHRlcm5hbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgbGV0IHNwZWMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHMpLCB7IGV4dGVybmFsOiBmb3VuZC50byB9KTtcbiAgICAgICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyc1tpXSA9IGdldFNwZWNpYWxpemVyKHNwZWMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgYW55IFtwYXJzZSB3cmFwcGVyc10oI2xyLlBhcnNlckNvbmZpZy53cmFwKVxuICAgIGFyZSByZWdpc3RlcmVkIGZvciB0aGlzIHBhcnNlci5cbiAgICAqL1xuICAgIGhhc1dyYXBwZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBuYW1lIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlcm0uIFRoaXMgd2lsbCBvbmx5XG4gICAgd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgYC0tbmFtZXNgIG9wdGlvbi4gQnkgZGVmYXVsdCwgb25seSB0aGUgbmFtZXMgb2YgdGFnZ2VkIHRlcm1zIGFyZVxuICAgIHN0b3JlZC5cbiAgICAqL1xuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgICB0eXBlcy4gQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0b3Agbm9kZSBwcm9kdWNlZCBieSB0aGUgcGFyc2VyLlxuICAgICovXG4gICAgZ2V0IHRvcE5vZGUoKSB7IHJldHVybiB0aGlzLm5vZGVTZXQudHlwZXNbdGhpcy50b3BbMV1dOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkeW5hbWljUHJlY2VkZW5jZSh0ZXJtKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5keW5hbWljUHJlY2VkZW5jZXM7XG4gICAgICAgIHJldHVybiBwcmVjID09IG51bGwgPyAwIDogcHJlY1t0ZXJtXSB8fCAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogU2VxLkVuZCAqLzspXG4gICAgICAgICAgICAgICAgICAgIChkaXNhYmxlZCB8fCAoZGlzYWJsZWQgPSBuZXcgVWludDhBcnJheSh0aGlzLm1heFRlcm0gKyAxKSkpW2lkXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGlhbGVjdChkaWFsZWN0LCBmbGFncywgZGlzYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGJ5IHRoZSBvdXRwdXQgb2YgdGhlIHBhcnNlciBnZW5lcmF0b3IuIE5vdCBhdmFpbGFibGUgdG9cbiAgICB1c2VyIGNvZGUuIEBoaWRlXG4gICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExSUGFyc2VyKHNwZWMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhaXIoZGF0YSwgb2ZmKSB7IHJldHVybiBkYXRhW29mZl0gfCAoZGF0YVtvZmYgKyAxXSA8PCAxNik7IH1cbmZ1bmN0aW9uIGZpbmRGaW5pc2hlZChzdGFja3MpIHtcbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGxldCBzdG9wcGVkID0gc3RhY2sucC5zdG9wcGVkQXQ7XG4gICAgICAgIGlmICgoc3RhY2sucG9zID09IHN0YWNrLnAuc3RyZWFtLmVuZCB8fCBzdG9wcGVkICE9IG51bGwgJiYgc3RhY2sucG9zID4gc3RvcHBlZCkgJiZcbiAgICAgICAgICAgIHN0YWNrLnAucGFyc2VyLnN0YXRlRmxhZyhzdGFjay5zdGF0ZSwgMiAvKiBTdGF0ZUZsYWcuQWNjZXB0aW5nICovKSAmJlxuICAgICAgICAgICAgKCFiZXN0IHx8IGJlc3Quc2NvcmUgPCBzdGFjay5zY29yZSkpXG4gICAgICAgICAgICBiZXN0ID0gc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBiZXN0O1xufVxuZnVuY3Rpb24gZ2V0U3BlY2lhbGl6ZXIoc3BlYykge1xuICAgIGlmIChzcGVjLmV4dGVybmFsKSB7XG4gICAgICAgIGxldCBtYXNrID0gc3BlYy5leHRlbmQgPyAxIC8qIFNwZWNpYWxpemUuRXh0ZW5kICovIDogMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi87XG4gICAgICAgIHJldHVybiAodmFsdWUsIHN0YWNrKSA9PiAoc3BlYy5leHRlcm5hbCh2YWx1ZSwgc3RhY2spIDw8IDEpIHwgbWFzaztcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMuZ2V0O1xufVxuXG5leHBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIElucHV0U3RyZWFtLCBMUlBhcnNlciwgTG9jYWxUb2tlbkdyb3VwLCBTdGFjayB9O1xuIl0sIm5hbWVzIjpbIlBhcnNlciIsIk5vZGVQcm9wIiwiTm9kZVNldCIsIk5vZGVUeXBlIiwiRGVmYXVsdEJ1ZmZlckxlbmd0aCIsIlRyZWUiLCJJdGVyTW9kZSIsIlN0YWNrIiwiY29uc3RydWN0b3IiLCJwIiwic3RhY2siLCJzdGF0ZSIsInJlZHVjZVBvcyIsInBvcyIsInNjb3JlIiwiYnVmZmVyIiwiYnVmZmVyQmFzZSIsImN1ckNvbnRleHQiLCJsb29rQWhlYWQiLCJwYXJlbnQiLCJ0b1N0cmluZyIsImZpbHRlciIsIl8iLCJpIiwiY29uY2F0Iiwic3RhcnQiLCJjeCIsInBhcnNlciIsImNvbnRleHQiLCJTdGFja0NvbnRleHQiLCJwdXNoU3RhdGUiLCJwdXNoIiwibGVuZ3RoIiwicmVkdWNlIiwiYWN0aW9uIiwiX2EiLCJkZXB0aCIsInR5cGUiLCJkUHJlYyIsImR5bmFtaWNQcmVjZWRlbmNlIiwiZ2V0R290byIsIm1pblJlcGVhdFRlcm0iLCJzdG9yZU5vZGUiLCJyZWR1Y2VDb250ZXh0IiwiYmFzZSIsInJhbmdlcyIsImZyb20iLCJzaXplIiwibm9kZVNldCIsInR5cGVzIiwiaXNBbm9ueW1vdXMiLCJsYXN0QmlnUmVkdWN0aW9uU3RhcnQiLCJiaWdSZWR1Y3Rpb25Db3VudCIsImxhc3RCaWdSZWR1Y3Rpb25TaXplIiwiY291bnQiLCJzdGF0ZUZsYWciLCJiYXNlU3RhdGVJRCIsInBvcCIsInRlcm0iLCJlbmQiLCJpc1JlZHVjZSIsImN1ciIsInRvcCIsImluZGV4Iiwic2hpZnQiLCJuZXh0U3RhdGUiLCJtYXhOb2RlIiwic2hpZnRDb250ZXh0IiwiYXBwbHkiLCJuZXh0IiwibmV4dFN0YXJ0IiwibmV4dEVuZCIsInVzZU5vZGUiLCJ2YWx1ZSIsInJldXNlZCIsInVwZGF0ZUNvbnRleHQiLCJ0cmFja2VyIiwicmV1c2UiLCJzdHJlYW0iLCJyZXNldCIsInNwbGl0Iiwib2ZmIiwic2xpY2UiLCJyZWNvdmVyQnlEZWxldGUiLCJpc05vZGUiLCJjYW5TaGlmdCIsInNpbSIsIlNpbXVsYXRlZFN0YWNrIiwic3RhdGVTbG90IiwiaGFzQWN0aW9uIiwicmVjb3ZlckJ5SW5zZXJ0IiwibmV4dFN0YXRlcyIsImJlc3QiLCJzIiwic29tZSIsInYiLCJyZXN1bHQiLCJmb3JjZVJlZHVjZSIsInZhbGlkQWN0aW9uIiwidGFyZ2V0IiwiYmFja3VwIiwiZmluZEZvcmNlZFJlZHVjdGlvbiIsInNlZW4iLCJleHBsb3JlIiwiaW5jbHVkZXMiLCJhbGxBY3Rpb25zIiwickRlcHRoIiwiZm91bmQiLCJmb3JjZUFsbCIsImRlYWRFbmQiLCJkYXRhIiwicmVzdGFydCIsInNhbWVTdGF0ZSIsIm90aGVyIiwiZGlhbGVjdEVuYWJsZWQiLCJkaWFsZWN0SUQiLCJkaWFsZWN0IiwiZmxhZ3MiLCJlbWl0Q29udGV4dCIsImxhc3QiLCJoYXNoIiwiZW1pdExvb2tBaGVhZCIsIm5ld0N4Iiwic2V0TG9va0FoZWFkIiwiY2xvc2UiLCJzdHJpY3QiLCJnb3RvIiwiU3RhY2tCdWZmZXJDdXJzb3IiLCJtYXliZU5leHQiLCJjcmVhdGUiLCJpZCIsImZvcmsiLCJkZWNvZGVBcnJheSIsImlucHV0IiwiVHlwZSIsIlVpbnQxNkFycmF5IiwiYXJyYXkiLCJvdXQiLCJjaGFyQ29kZUF0Iiwic3RvcCIsImRpZ2l0IiwiQ2FjaGVkVG9rZW4iLCJleHRlbmRlZCIsIm1hc2siLCJudWxsVG9rZW4iLCJJbnB1dFN0cmVhbSIsImNodW5rIiwiY2h1bmtPZmYiLCJjaHVuazIiLCJjaHVuazJQb3MiLCJ0b2tlbiIsInJhbmdlSW5kZXgiLCJjaHVua1BvcyIsInJhbmdlIiwidG8iLCJyZWFkTmV4dCIsInJlc29sdmVPZmZzZXQiLCJvZmZzZXQiLCJhc3NvYyIsImNsaXBQb3MiLCJNYXRoIiwibWF4IiwicGVlayIsImlkeCIsInJlc29sdmVkIiwiYWNjZXB0VG9rZW4iLCJlbmRPZmZzZXQiLCJSYW5nZUVycm9yIiwiYWNjZXB0VG9rZW5UbyIsImVuZFBvcyIsImdldENodW5rIiwibmV4dENodW5rIiwiYWR2YW5jZSIsIm4iLCJzZXREb25lIiwicmVhZCIsInIiLCJtaW4iLCJUb2tlbkdyb3VwIiwicmVhZFRva2VuIiwidG9rZW5QcmVjVGFibGUiLCJwcm90b3R5cGUiLCJjb250ZXh0dWFsIiwiZmFsbGJhY2siLCJleHRlbmQiLCJMb2NhbFRva2VuR3JvdXAiLCJwcmVjVGFibGUiLCJlbHNlVG9rZW4iLCJza2lwcGVkIiwiYXRFb2YiLCJuZXh0UG9zIiwiRXh0ZXJuYWxUb2tlbml6ZXIiLCJvcHRpb25zIiwiZ3JvdXAiLCJwcmVjT2Zmc2V0IiwiZ3JvdXBNYXNrIiwic2NhbiIsImFjY0VuZCIsImFsbG93cyIsIm92ZXJyaWRlcyIsImxvdyIsImhpZ2giLCJtaWQiLCJmaW5kT2Zmc2V0IiwicHJldiIsInRhYmxlRGF0YSIsInRhYmxlT2Zmc2V0IiwiaVByZXYiLCJ2ZXJib3NlIiwicHJvY2VzcyIsImVudiIsInRlc3QiLCJMT0ciLCJzdGFja0lEcyIsImN1dEF0IiwidHJlZSIsInNpZGUiLCJjdXJzb3IiLCJJbmNsdWRlQW5vbnltb3VzIiwibW92ZVRvIiwiY2hpbGRCZWZvcmUiLCJjaGlsZEFmdGVyIiwiaXNFcnJvciIsInByZXZTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJGcmFnbWVudEN1cnNvciIsImZyYWdtZW50cyIsImZyYWdtZW50Iiwic2FmZUZyb20iLCJzYWZlVG8iLCJ0cmVlcyIsIm5leHRGcmFnbWVudCIsImZyIiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsIm5vZGVBdCIsImNoaWxkcmVuIiwicG9zaXRpb25zIiwicHJvcCIsIlRva2VuQ2FjaGUiLCJ0b2tlbnMiLCJtYWluVG9rZW4iLCJhY3Rpb25zIiwidG9rZW5pemVycyIsIm1hcCIsImdldEFjdGlvbnMiLCJhY3Rpb25JbmRleCIsIm1haW4iLCJ0b2tlbml6ZXIiLCJ1cGRhdGVDYWNoZWRUb2tlbiIsInN0YXJ0SW5kZXgiLCJhZGRBY3Rpb25zIiwiZW9mVGVybSIsImdldE1haW5Ub2tlbiIsInNwZWNpYWxpemVkIiwic3BlY2lhbGl6ZXJzIiwicHV0QWN0aW9uIiwic2V0IiwicGFpciIsIlBhcnNlIiwicmVjb3ZlcmluZyIsIm5leHRTdGFja0lEIiwibWluU3RhY2tQb3MiLCJzdG9wcGVkQXQiLCJ0b3BUZXJtIiwic3RhY2tzIiwiYnVmZmVyTGVuZ3RoIiwicGFyc2VkUG9zIiwibmV3U3RhY2tzIiwic3RvcHBlZCIsInN0b3BwZWRUb2tlbnMiLCJhZHZhbmNlU3RhY2siLCJ0b2siLCJmaW5pc2hlZCIsImZpbmRGaW5pc2hlZCIsImNvbnNvbGUiLCJsb2ciLCJzdGFja0lEIiwic3RhY2tUb1RyZWUiLCJnZXROYW1lIiwiU3ludGF4RXJyb3IiLCJydW5SZWNvdmVyeSIsIm1heFJlbWFpbmluZyIsInNvcnQiLCJhIiwiYiIsIm91dGVyIiwiaiIsInNwbGljZSIsInN0b3BBdCIsInN0cmljdEN4IiwiY3hIYXNoIiwiY2FjaGVkIiwibWF0Y2giLCJjb250ZXh0SGFzaCIsImlubmVyIiwiZGVmYXVsdFJlZHVjZSIsImxvY2FsU3RhY2siLCJhZHZhbmNlRnVsbHkiLCJwdXNoU3RhY2tEZWR1cCIsInJlc3RhcnRlZCIsInRva2VuRW5kIiwiZG9uZSIsImZvcmNlIiwiZm9yY2VCYXNlIiwiaW5zZXJ0IiwiYnVpbGQiLCJ0b3BJRCIsIm1heEJ1ZmZlckxlbmd0aCIsIm1pblJlcGVhdFR5cGUiLCJXZWFrTWFwIiwiZ2V0IiwiU3RyaW5nIiwiZnJvbUNvZGVQb2ludCIsIkRpYWxlY3QiLCJzb3VyY2UiLCJkaXNhYmxlZCIsIngiLCJDb250ZXh0VHJhY2tlciIsInNwZWMiLCJMUlBhcnNlciIsIndyYXBwZXJzIiwidmVyc2lvbiIsIm5vZGVOYW1lcyIsInJlcGVhdE5vZGVDb3VudCIsInRvcFRlcm1zIiwiT2JqZWN0Iiwia2V5cyIsInRvcFJ1bGVzIiwibm9kZVByb3BzIiwic2V0UHJvcCIsIm5vZGVJRCIsImRlc2VyaWFsaXplIiwicHJvcFNwZWMiLCJuYW1lIiwiZGVmaW5lIiwidW5kZWZpbmVkIiwicHJvcHMiLCJpbmRleE9mIiwiZXJyb3IiLCJza2lwcGVkTm9kZXMiLCJwcm9wU291cmNlcyIsInRva2VuQXJyYXkiLCJ0b2tlbkRhdGEiLCJzcGVjaWFsaXplclNwZWNzIiwiZ2V0U3BlY2lhbGl6ZXIiLCJzdGF0ZXMiLCJVaW50MzJBcnJheSIsInN0YXRlRGF0YSIsIm1heFRlcm0iLCJkaWFsZWN0cyIsImR5bmFtaWNQcmVjZWRlbmNlcyIsInRva2VuUHJlYyIsInRlcm1OYW1lcyIsInBhcnNlRGlhbGVjdCIsImNyZWF0ZVBhcnNlIiwicGFyc2UiLCJ3IiwibG9vc2UiLCJ0YWJsZSIsImdyb3VwVGFnIiwidGVybWluYWwiLCJzbG90IiwiZmxhZyIsImRlZmx0IiwiY29uZmlndXJlIiwiY29uZmlnIiwiY29weSIsImFzc2lnbiIsImluZm8iLCJ0IiwiZmluZCIsImV4dGVybmFsIiwiY29udGV4dFRyYWNrZXIiLCJ3cmFwIiwiaGFzV3JhcHBlcnMiLCJ0b3BOb2RlIiwicHJlYyIsInZhbHVlcyIsInBhcnQiLCJVaW50OEFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/lr/dist/index.js\n");

/***/ })

};
;