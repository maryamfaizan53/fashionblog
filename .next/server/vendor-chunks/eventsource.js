"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/eventsource";
exports.ids = ["vendor-chunks/eventsource"];
exports.modules = {

/***/ "(ssr)/./node_modules/eventsource/lib/eventsource.js":
/*!*****************************************************!*\
  !*** ./node_modules/eventsource/lib/eventsource.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar parse = (__webpack_require__(/*! url */ \"url\").parse);\nvar events = __webpack_require__(/*! events */ \"events\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar httpsOptions = [\n    \"pfx\",\n    \"key\",\n    \"passphrase\",\n    \"cert\",\n    \"ca\",\n    \"ciphers\",\n    \"rejectUnauthorized\",\n    \"secureProtocol\",\n    \"servername\",\n    \"checkServerIdentity\"\n];\nvar bom = [\n    239,\n    187,\n    191\n];\nvar colon = 58;\nvar space = 32;\nvar lineFeed = 10;\nvar carriageReturn = 13;\n// Beyond 256KB we could not observe any gain in performance\nvar maxBufferAheadAllocation = 1024 * 256;\n// Headers matching the pattern should be removed when redirecting to different origin\nvar reUnsafeHeader = /^(cookie|authorization)$/i;\nfunction hasBom(buf) {\n    return bom.every(function(charCode, index) {\n        return buf[index] === charCode;\n    });\n}\n/**\n * Creates a new EventSource object\n *\n * @param {String} url the URL to which to connect\n * @param {Object} [eventSourceInitDict] extra init params. See README for details.\n * @api public\n **/ function EventSource(url, eventSourceInitDict) {\n    var readyState = EventSource.CONNECTING;\n    var headers = eventSourceInitDict && eventSourceInitDict.headers;\n    var hasNewOrigin = false;\n    Object.defineProperty(this, \"readyState\", {\n        get: function() {\n            return readyState;\n        }\n    });\n    Object.defineProperty(this, \"url\", {\n        get: function() {\n            return url;\n        }\n    });\n    var self = this;\n    self.reconnectInterval = 1000;\n    self.connectionInProgress = false;\n    function onConnectionClosed(message) {\n        if (readyState === EventSource.CLOSED) return;\n        readyState = EventSource.CONNECTING;\n        _emit(\"error\", new Event(\"error\", {\n            message: message\n        }));\n        // The url may have been changed by a temporary redirect. If that's the case,\n        // revert it now, and flag that we are no longer pointing to a new origin\n        if (reconnectUrl) {\n            url = reconnectUrl;\n            reconnectUrl = null;\n            hasNewOrigin = false;\n        }\n        setTimeout(function() {\n            if (readyState !== EventSource.CONNECTING || self.connectionInProgress) {\n                return;\n            }\n            self.connectionInProgress = true;\n            connect();\n        }, self.reconnectInterval);\n    }\n    var req;\n    var lastEventId = \"\";\n    if (headers && headers[\"Last-Event-ID\"]) {\n        lastEventId = headers[\"Last-Event-ID\"];\n        delete headers[\"Last-Event-ID\"];\n    }\n    var discardTrailingNewline = false;\n    var data = \"\";\n    var eventName = \"\";\n    var reconnectUrl = null;\n    function connect() {\n        var options = parse(url);\n        var isSecure = options.protocol === \"https:\";\n        options.headers = {\n            \"Cache-Control\": \"no-cache\",\n            \"Accept\": \"text/event-stream\"\n        };\n        if (lastEventId) options.headers[\"Last-Event-ID\"] = lastEventId;\n        if (headers) {\n            var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;\n            for(var i in reqHeaders){\n                var header = reqHeaders[i];\n                if (header) {\n                    options.headers[i] = header;\n                }\n            }\n        }\n        // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,\n        // but for now exists as a backwards-compatibility layer\n        options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);\n        if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {\n            options.createConnection = eventSourceInitDict.createConnection;\n        }\n        // If specify http proxy, make the request to sent to the proxy server,\n        // and include the original url in path and Host headers\n        var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;\n        if (useProxy) {\n            var proxy = parse(eventSourceInitDict.proxy);\n            isSecure = proxy.protocol === \"https:\";\n            options.protocol = isSecure ? \"https:\" : \"http:\";\n            options.path = url;\n            options.headers.Host = options.host;\n            options.hostname = proxy.hostname;\n            options.host = proxy.host;\n            options.port = proxy.port;\n        }\n        // If https options are specified, merge them into the request options\n        if (eventSourceInitDict && eventSourceInitDict.https) {\n            for(var optName in eventSourceInitDict.https){\n                if (httpsOptions.indexOf(optName) === -1) {\n                    continue;\n                }\n                var option = eventSourceInitDict.https[optName];\n                if (option !== undefined) {\n                    options[optName] = option;\n                }\n            }\n        }\n        // Pass this on to the XHR\n        if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {\n            options.withCredentials = eventSourceInitDict.withCredentials;\n        }\n        req = (isSecure ? https : http).request(options, function(res) {\n            self.connectionInProgress = false;\n            // Handle HTTP errors\n            if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {\n                _emit(\"error\", new Event(\"error\", {\n                    status: res.statusCode,\n                    message: res.statusMessage\n                }));\n                onConnectionClosed();\n                return;\n            }\n            // Handle HTTP redirects\n            if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                var location = res.headers.location;\n                if (!location) {\n                    // Server sent redirect response without Location header.\n                    _emit(\"error\", new Event(\"error\", {\n                        status: res.statusCode,\n                        message: res.statusMessage\n                    }));\n                    return;\n                }\n                var prevOrigin = new URL(url).origin;\n                var nextOrigin = new URL(location).origin;\n                hasNewOrigin = prevOrigin !== nextOrigin;\n                if (res.statusCode === 307) reconnectUrl = url;\n                url = location;\n                process.nextTick(connect);\n                return;\n            }\n            if (res.statusCode !== 200) {\n                _emit(\"error\", new Event(\"error\", {\n                    status: res.statusCode,\n                    message: res.statusMessage\n                }));\n                return self.close();\n            }\n            readyState = EventSource.OPEN;\n            res.on(\"close\", function() {\n                res.removeAllListeners(\"close\");\n                res.removeAllListeners(\"end\");\n                onConnectionClosed();\n            });\n            res.on(\"end\", function() {\n                res.removeAllListeners(\"close\");\n                res.removeAllListeners(\"end\");\n                onConnectionClosed();\n            });\n            _emit(\"open\", new Event(\"open\"));\n            // text/event-stream parser adapted from webkit's\n            // Source/WebCore/page/EventSource.cpp\n            var buf;\n            var newBuffer;\n            var startingPos = 0;\n            var startingFieldLength = -1;\n            var newBufferSize = 0;\n            var bytesUsed = 0;\n            res.on(\"data\", function(chunk) {\n                if (!buf) {\n                    buf = chunk;\n                    if (hasBom(buf)) {\n                        buf = buf.slice(bom.length);\n                    }\n                    bytesUsed = buf.length;\n                } else {\n                    if (chunk.length > buf.length - bytesUsed) {\n                        newBufferSize = buf.length * 2 + chunk.length;\n                        if (newBufferSize > maxBufferAheadAllocation) {\n                            newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation;\n                        }\n                        newBuffer = Buffer.alloc(newBufferSize);\n                        buf.copy(newBuffer, 0, 0, bytesUsed);\n                        buf = newBuffer;\n                    }\n                    chunk.copy(buf, bytesUsed);\n                    bytesUsed += chunk.length;\n                }\n                var pos = 0;\n                var length = bytesUsed;\n                while(pos < length){\n                    if (discardTrailingNewline) {\n                        if (buf[pos] === lineFeed) {\n                            ++pos;\n                        }\n                        discardTrailingNewline = false;\n                    }\n                    var lineLength = -1;\n                    var fieldLength = startingFieldLength;\n                    var c;\n                    for(var i = startingPos; lineLength < 0 && i < length; ++i){\n                        c = buf[i];\n                        if (c === colon) {\n                            if (fieldLength < 0) {\n                                fieldLength = i - pos;\n                            }\n                        } else if (c === carriageReturn) {\n                            discardTrailingNewline = true;\n                            lineLength = i - pos;\n                        } else if (c === lineFeed) {\n                            lineLength = i - pos;\n                        }\n                    }\n                    if (lineLength < 0) {\n                        startingPos = length - pos;\n                        startingFieldLength = fieldLength;\n                        break;\n                    } else {\n                        startingPos = 0;\n                        startingFieldLength = -1;\n                    }\n                    parseEventStreamLine(buf, pos, fieldLength, lineLength);\n                    pos += lineLength + 1;\n                }\n                if (pos === length) {\n                    buf = void 0;\n                    bytesUsed = 0;\n                } else if (pos > 0) {\n                    buf = buf.slice(pos, bytesUsed);\n                    bytesUsed = buf.length;\n                }\n            });\n        });\n        req.on(\"error\", function(err) {\n            self.connectionInProgress = false;\n            onConnectionClosed(err.message);\n        });\n        if (req.setNoDelay) req.setNoDelay(true);\n        req.end();\n    }\n    connect();\n    function _emit() {\n        if (self.listeners(arguments[0]).length > 0) {\n            self.emit.apply(self, arguments);\n        }\n    }\n    this._close = function() {\n        if (readyState === EventSource.CLOSED) return;\n        readyState = EventSource.CLOSED;\n        if (req.abort) req.abort();\n        if (req.xhr && req.xhr.abort) req.xhr.abort();\n    };\n    function parseEventStreamLine(buf, pos, fieldLength, lineLength) {\n        if (lineLength === 0) {\n            if (data.length > 0) {\n                var type = eventName || \"message\";\n                _emit(type, new MessageEvent(type, {\n                    data: data.slice(0, -1),\n                    lastEventId: lastEventId,\n                    origin: new URL(url).origin\n                }));\n                data = \"\";\n            }\n            eventName = void 0;\n        } else if (fieldLength > 0) {\n            var noValue = fieldLength < 0;\n            var step = 0;\n            var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();\n            if (noValue) {\n                step = lineLength;\n            } else if (buf[pos + fieldLength + 1] !== space) {\n                step = fieldLength + 1;\n            } else {\n                step = fieldLength + 2;\n            }\n            pos += step;\n            var valueLength = lineLength - step;\n            var value = buf.slice(pos, pos + valueLength).toString();\n            if (field === \"data\") {\n                data += value + \"\\n\";\n            } else if (field === \"event\") {\n                eventName = value;\n            } else if (field === \"id\") {\n                lastEventId = value;\n            } else if (field === \"retry\") {\n                var retry = parseInt(value, 10);\n                if (!Number.isNaN(retry)) {\n                    self.reconnectInterval = retry;\n                }\n            }\n        }\n    }\n}\nmodule.exports = EventSource;\nutil.inherits(EventSource, events.EventEmitter);\nEventSource.prototype.constructor = EventSource; // make stacktraces readable\n[\n    \"open\",\n    \"error\",\n    \"message\"\n].forEach(function(method) {\n    Object.defineProperty(EventSource.prototype, \"on\" + method, {\n        /**\n     * Returns the current listener\n     *\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */ get: function get() {\n            var listener = this.listeners(method)[0];\n            return listener ? listener._listener ? listener._listener : listener : undefined;\n        },\n        /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */ set: function set(listener) {\n            this.removeAllListeners(method);\n            this.addEventListener(method, listener);\n        }\n    });\n});\n/**\n * Ready states\n */ Object.defineProperty(EventSource, \"CONNECTING\", {\n    enumerable: true,\n    value: 0\n});\nObject.defineProperty(EventSource, \"OPEN\", {\n    enumerable: true,\n    value: 1\n});\nObject.defineProperty(EventSource, \"CLOSED\", {\n    enumerable: true,\n    value: 2\n});\nEventSource.prototype.CONNECTING = 0;\nEventSource.prototype.OPEN = 1;\nEventSource.prototype.CLOSED = 2;\n/**\n * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close\n * @api public\n */ EventSource.prototype.close = function() {\n    this._close();\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @param {String} type A string representing the event type to listen out for\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */ EventSource.prototype.addEventListener = function addEventListener(type, listener) {\n    if (typeof listener === \"function\") {\n        // store a reference so we can return the original function again\n        listener._listener = listener;\n        this.on(type, listener);\n    }\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using dispatchEvent.\n *\n * @param {Event} event An event to be dispatched\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent\n * @api public\n */ EventSource.prototype.dispatchEvent = function dispatchEvent(event) {\n    if (!event.type) {\n        throw new Error(\"UNSPECIFIED_EVENT_TYPE_ERR\");\n    }\n    // if event is instance of an CustomEvent (or has 'details' property),\n    // send the detail object as the payload for the event\n    this.emit(event.type, event.detail);\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using removeEventListener.\n *\n * @param {String} type A string representing the event type to remove\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.removeEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */ EventSource.prototype.removeEventListener = function removeEventListener(type, listener) {\n    if (typeof listener === \"function\") {\n        listener._listener = undefined;\n        this.removeListener(type, listener);\n    }\n};\n/**\n * W3C Event\n *\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event\n * @api private\n */ function Event(type, optionalProperties) {\n    Object.defineProperty(this, \"type\", {\n        writable: false,\n        value: type,\n        enumerable: true\n    });\n    if (optionalProperties) {\n        for(var f in optionalProperties){\n            if (optionalProperties.hasOwnProperty(f)) {\n                Object.defineProperty(this, f, {\n                    writable: false,\n                    value: optionalProperties[f],\n                    enumerable: true\n                });\n            }\n        }\n    }\n}\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/webmessaging/#event-definitions\n * @api private\n */ function MessageEvent(type, eventInitDict) {\n    Object.defineProperty(this, \"type\", {\n        writable: false,\n        value: type,\n        enumerable: true\n    });\n    for(var f in eventInitDict){\n        if (eventInitDict.hasOwnProperty(f)) {\n            Object.defineProperty(this, f, {\n                writable: false,\n                value: eventInitDict[f],\n                enumerable: true\n            });\n        }\n    }\n}\n/**\n * Returns a new object of headers that does not include any authorization and cookie headers\n *\n * @param {Object} headers An object of headers ({[headerName]: headerValue})\n * @return {Object} a new object of headers\n * @api private\n */ function removeUnsafeHeaders(headers) {\n    var safe = {};\n    for(var key in headers){\n        if (reUnsafeHeader.test(key)) {\n            continue;\n        }\n        safe[key] = headers[key];\n    }\n    return safe;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXZlbnRzb3VyY2UvbGliL2V2ZW50c291cmNlLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJQSxRQUFRQyw2Q0FBb0I7QUFDaEMsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDckIsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUcsT0FBT0gsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUksT0FBT0osbUJBQU9BLENBQUM7QUFFbkIsSUFBSUssZUFBZTtJQUNqQjtJQUFPO0lBQU87SUFBYztJQUFRO0lBQU07SUFDMUM7SUFBc0I7SUFBa0I7SUFBYztDQUN2RDtBQUVELElBQUlDLE1BQU07SUFBQztJQUFLO0lBQUs7Q0FBSTtBQUN6QixJQUFJQyxRQUFRO0FBQ1osSUFBSUMsUUFBUTtBQUNaLElBQUlDLFdBQVc7QUFDZixJQUFJQyxpQkFBaUI7QUFDckIsNERBQTREO0FBQzVELElBQUlDLDJCQUEyQixPQUFPO0FBQ3RDLHNGQUFzRjtBQUN0RixJQUFJQyxpQkFBaUI7QUFFckIsU0FBU0MsT0FBUUMsR0FBRztJQUNsQixPQUFPUixJQUFJUyxLQUFLLENBQUMsU0FBVUMsUUFBUSxFQUFFQyxLQUFLO1FBQ3hDLE9BQU9ILEdBQUcsQ0FBQ0csTUFBTSxLQUFLRDtJQUN4QjtBQUNGO0FBRUE7Ozs7OztFQU1FLEdBQ0YsU0FBU0UsWUFBYUMsR0FBRyxFQUFFQyxtQkFBbUI7SUFDNUMsSUFBSUMsYUFBYUgsWUFBWUksVUFBVTtJQUN2QyxJQUFJQyxVQUFVSCx1QkFBdUJBLG9CQUFvQkcsT0FBTztJQUNoRSxJQUFJQyxlQUFlO0lBQ25CQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7UUFDeENDLEtBQUs7WUFDSCxPQUFPTjtRQUNUO0lBQ0Y7SUFFQUksT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxPQUFPO1FBQ2pDQyxLQUFLO1lBQ0gsT0FBT1I7UUFDVDtJQUNGO0lBRUEsSUFBSVMsT0FBTyxJQUFJO0lBQ2ZB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UUFBRWlILFVBQVU7UUFBT3pCLE9BQU9QO1FBQU13QixZQUFZO0lBQUs7SUFDckYsSUFBSyxJQUFJUyxLQUFLRSxjQUFlO1FBQzNCLElBQUlBLGNBQWNELGNBQWMsQ0FBQ0QsSUFBSTtZQUNuQ25ILE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUVrSCxHQUFHO2dCQUFFRCxVQUFVO2dCQUFPekIsT0FBTzRCLGFBQWEsQ0FBQ0YsRUFBRTtnQkFBRVQsWUFBWTtZQUFLO1FBQzlGO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNuRixvQkFBcUJ6QixPQUFPO0lBQ25DLElBQUl3SCxPQUFPLENBQUM7SUFDWixJQUFLLElBQUlDLE9BQU96SCxRQUFTO1FBQ3ZCLElBQUlYLGVBQWVxSSxJQUFJLENBQUNELE1BQU07WUFDNUI7UUFDRjtRQUVBRCxJQUFJLENBQUNDLElBQUksR0FBR3pILE9BQU8sQ0FBQ3lILElBQUk7SUFDMUI7SUFFQSxPQUFPRDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMvZXZlbnRzb3VyY2UvbGliL2V2ZW50c291cmNlLmpzP2RkMmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBhcnNlID0gcmVxdWlyZSgndXJsJykucGFyc2VcbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKVxudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbnZhciBodHRwc09wdGlvbnMgPSBbXG4gICdwZngnLCAna2V5JywgJ3Bhc3NwaHJhc2UnLCAnY2VydCcsICdjYScsICdjaXBoZXJzJyxcbiAgJ3JlamVjdFVuYXV0aG9yaXplZCcsICdzZWN1cmVQcm90b2NvbCcsICdzZXJ2ZXJuYW1lJywgJ2NoZWNrU2VydmVySWRlbnRpdHknXG5dXG5cbnZhciBib20gPSBbMjM5LCAxODcsIDE5MV1cbnZhciBjb2xvbiA9IDU4XG52YXIgc3BhY2UgPSAzMlxudmFyIGxpbmVGZWVkID0gMTBcbnZhciBjYXJyaWFnZVJldHVybiA9IDEzXG4vLyBCZXlvbmQgMjU2S0Igd2UgY291bGQgbm90IG9ic2VydmUgYW55IGdhaW4gaW4gcGVyZm9ybWFuY2VcbnZhciBtYXhCdWZmZXJBaGVhZEFsbG9jYXRpb24gPSAxMDI0ICogMjU2XG4vLyBIZWFkZXJzIG1hdGNoaW5nIHRoZSBwYXR0ZXJuIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gcmVkaXJlY3RpbmcgdG8gZGlmZmVyZW50IG9yaWdpblxudmFyIHJlVW5zYWZlSGVhZGVyID0gL14oY29va2llfGF1dGhvcml6YXRpb24pJC9pXG5cbmZ1bmN0aW9uIGhhc0JvbSAoYnVmKSB7XG4gIHJldHVybiBib20uZXZlcnkoZnVuY3Rpb24gKGNoYXJDb2RlLCBpbmRleCkge1xuICAgIHJldHVybiBidWZbaW5kZXhdID09PSBjaGFyQ29kZVxuICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgRXZlbnRTb3VyY2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCB0aGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRTb3VyY2VJbml0RGljdF0gZXh0cmEgaW5pdCBwYXJhbXMuIFNlZSBSRUFETUUgZm9yIGRldGFpbHMuXG4gKiBAYXBpIHB1YmxpY1xuICoqL1xuZnVuY3Rpb24gRXZlbnRTb3VyY2UgKHVybCwgZXZlbnRTb3VyY2VJbml0RGljdCkge1xuICB2YXIgcmVhZHlTdGF0ZSA9IEV2ZW50U291cmNlLkNPTk5FQ1RJTkdcbiAgdmFyIGhlYWRlcnMgPSBldmVudFNvdXJjZUluaXREaWN0ICYmIGV2ZW50U291cmNlSW5pdERpY3QuaGVhZGVyc1xuICB2YXIgaGFzTmV3T3JpZ2luID0gZmFsc2VcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWFkeVN0YXRlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlYWR5U3RhdGVcbiAgICB9XG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd1cmwnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdXJsXG4gICAgfVxuICB9KVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLnJlY29ubmVjdEludGVydmFsID0gMTAwMFxuICBzZWxmLmNvbm5lY3Rpb25JblByb2dyZXNzID0gZmFsc2VcblxuICBmdW5jdGlvbiBvbkNvbm5lY3Rpb25DbG9zZWQgKG1lc3NhZ2UpIHtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gRXZlbnRTb3VyY2UuQ0xPU0VEKSByZXR1cm5cbiAgICByZWFkeVN0YXRlID0gRXZlbnRTb3VyY2UuQ09OTkVDVElOR1xuICAgIF9lbWl0KCdlcnJvcicsIG5ldyBFdmVudCgnZXJyb3InLCB7bWVzc2FnZTogbWVzc2FnZX0pKVxuXG4gICAgLy8gVGhlIHVybCBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgYnkgYSB0ZW1wb3JhcnkgcmVkaXJlY3QuIElmIHRoYXQncyB0aGUgY2FzZSxcbiAgICAvLyByZXZlcnQgaXQgbm93LCBhbmQgZmxhZyB0aGF0IHdlIGFyZSBubyBsb25nZXIgcG9pbnRpbmcgdG8gYSBuZXcgb3JpZ2luXG4gICAgaWYgKHJlY29ubmVjdFVybCkge1xuICAgICAgdXJsID0gcmVjb25uZWN0VXJsXG4gICAgICByZWNvbm5lY3RVcmwgPSBudWxsXG4gICAgICBoYXNOZXdPcmlnaW4gPSBmYWxzZVxuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyZWFkeVN0YXRlICE9PSBFdmVudFNvdXJjZS5DT05ORUNUSU5HIHx8IHNlbGYuY29ubmVjdGlvbkluUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzZWxmLmNvbm5lY3Rpb25JblByb2dyZXNzID0gdHJ1ZVxuICAgICAgY29ubmVjdCgpXG4gICAgfSwgc2VsZi5yZWNvbm5lY3RJbnRlcnZhbClcbiAgfVxuXG4gIHZhciByZXFcbiAgdmFyIGxhc3RFdmVudElkID0gJydcbiAgaWYgKGhlYWRlcnMgJiYgaGVhZGVyc1snTGFzdC1FdmVudC1JRCddKSB7XG4gICAgbGFzdEV2ZW50SWQgPSBoZWFkZXJzWydMYXN0LUV2ZW50LUlEJ11cbiAgICBkZWxldGUgaGVhZGVyc1snTGFzdC1FdmVudC1JRCddXG4gIH1cblxuICB2YXIgZGlzY2FyZFRyYWlsaW5nTmV3bGluZSA9IGZhbHNlXG4gIHZhciBkYXRhID0gJydcbiAgdmFyIGV2ZW50TmFtZSA9ICcnXG5cbiAgdmFyIHJlY29ubmVjdFVybCA9IG51bGxcblxuICBmdW5jdGlvbiBjb25uZWN0ICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHBhcnNlKHVybClcbiAgICB2YXIgaXNTZWN1cmUgPSBvcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6J1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IHsgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLCAnQWNjZXB0JzogJ3RleHQvZXZlbnQtc3RyZWFtJyB9XG4gICAgaWYgKGxhc3RFdmVudElkKSBvcHRpb25zLmhlYWRlcnNbJ0xhc3QtRXZlbnQtSUQnXSA9IGxhc3RFdmVudElkXG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIHZhciByZXFIZWFkZXJzID0gaGFzTmV3T3JpZ2luID8gcmVtb3ZlVW5zYWZlSGVhZGVycyhoZWFkZXJzKSA6IGhlYWRlcnNcbiAgICAgIGZvciAodmFyIGkgaW4gcmVxSGVhZGVycykge1xuICAgICAgICB2YXIgaGVhZGVyID0gcmVxSGVhZGVyc1tpXVxuICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2ldID0gaGVhZGVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMZWdhY3k6IHRoaXMgc2hvdWxkIGJlIHNwZWNpZmllZCBhcyBgZXZlbnRTb3VyY2VJbml0RGljdC5odHRwcy5yZWplY3RVbmF1dGhvcml6ZWRgLFxuICAgIC8vIGJ1dCBmb3Igbm93IGV4aXN0cyBhcyBhIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGxheWVyXG4gICAgb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgPSAhKGV2ZW50U291cmNlSW5pdERpY3QgJiYgIWV2ZW50U291cmNlSW5pdERpY3QucmVqZWN0VW5hdXRob3JpemVkKVxuXG4gICAgaWYgKGV2ZW50U291cmNlSW5pdERpY3QgJiYgZXZlbnRTb3VyY2VJbml0RGljdC5jcmVhdGVDb25uZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuY3JlYXRlQ29ubmVjdGlvbiA9IGV2ZW50U291cmNlSW5pdERpY3QuY3JlYXRlQ29ubmVjdGlvblxuICAgIH1cblxuICAgIC8vIElmIHNwZWNpZnkgaHR0cCBwcm94eSwgbWFrZSB0aGUgcmVxdWVzdCB0byBzZW50IHRvIHRoZSBwcm94eSBzZXJ2ZXIsXG4gICAgLy8gYW5kIGluY2x1ZGUgdGhlIG9yaWdpbmFsIHVybCBpbiBwYXRoIGFuZCBIb3N0IGhlYWRlcnNcbiAgICB2YXIgdXNlUHJveHkgPSBldmVudFNvdXJjZUluaXREaWN0ICYmIGV2ZW50U291cmNlSW5pdERpY3QucHJveHlcbiAgICBpZiAodXNlUHJveHkpIHtcbiAgICAgIHZhciBwcm94eSA9IHBhcnNlKGV2ZW50U291cmNlSW5pdERpY3QucHJveHkpXG4gICAgICBpc1NlY3VyZSA9IHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6J1xuXG4gICAgICBvcHRpb25zLnByb3RvY29sID0gaXNTZWN1cmUgPyAnaHR0cHM6JyA6ICdodHRwOidcbiAgICAgIG9wdGlvbnMucGF0aCA9IHVybFxuICAgICAgb3B0aW9ucy5oZWFkZXJzLkhvc3QgPSBvcHRpb25zLmhvc3RcbiAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBwcm94eS5ob3N0bmFtZVxuICAgICAgb3B0aW9ucy5ob3N0ID0gcHJveHkuaG9zdFxuICAgICAgb3B0aW9ucy5wb3J0ID0gcHJveHkucG9ydFxuICAgIH1cblxuICAgIC8vIElmIGh0dHBzIG9wdGlvbnMgYXJlIHNwZWNpZmllZCwgbWVyZ2UgdGhlbSBpbnRvIHRoZSByZXF1ZXN0IG9wdGlvbnNcbiAgICBpZiAoZXZlbnRTb3VyY2VJbml0RGljdCAmJiBldmVudFNvdXJjZUluaXREaWN0Lmh0dHBzKSB7XG4gICAgICBmb3IgKHZhciBvcHROYW1lIGluIGV2ZW50U291cmNlSW5pdERpY3QuaHR0cHMpIHtcbiAgICAgICAgaWYgKGh0dHBzT3B0aW9ucy5pbmRleE9mKG9wdE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9uID0gZXZlbnRTb3VyY2VJbml0RGljdC5odHRwc1tvcHROYW1lXVxuICAgICAgICBpZiAob3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zW29wdE5hbWVdID0gb3B0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXNzIHRoaXMgb24gdG8gdGhlIFhIUlxuICAgIGlmIChldmVudFNvdXJjZUluaXREaWN0ICYmIGV2ZW50U291cmNlSW5pdERpY3Qud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMud2l0aENyZWRlbnRpYWxzID0gZXZlbnRTb3VyY2VJbml0RGljdC53aXRoQ3JlZGVudGlhbHNcbiAgICB9XG5cbiAgICByZXEgPSAoaXNTZWN1cmUgPyBodHRwcyA6IGh0dHApLnJlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24gKHJlcykge1xuICAgICAgc2VsZi5jb25uZWN0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlXG4gICAgICAvLyBIYW5kbGUgSFRUUCBlcnJvcnNcbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gNTAwIHx8IHJlcy5zdGF0dXNDb2RlID09PSA1MDIgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDUwMyB8fCByZXMuc3RhdHVzQ29kZSA9PT0gNTA0KSB7XG4gICAgICAgIF9lbWl0KCdlcnJvcicsIG5ldyBFdmVudCgnZXJyb3InLCB7c3RhdHVzOiByZXMuc3RhdHVzQ29kZSwgbWVzc2FnZTogcmVzLnN0YXR1c01lc3NhZ2V9KSlcbiAgICAgICAgb25Db25uZWN0aW9uQ2xvc2VkKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBIVFRQIHJlZGlyZWN0c1xuICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwMiB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMzA3KSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uXG4gICAgICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgICAgICAvLyBTZXJ2ZXIgc2VudCByZWRpcmVjdCByZXNwb25zZSB3aXRob3V0IExvY2F0aW9uIGhlYWRlci5cbiAgICAgICAgICBfZW1pdCgnZXJyb3InLCBuZXcgRXZlbnQoJ2Vycm9yJywge3N0YXR1czogcmVzLnN0YXR1c0NvZGUsIG1lc3NhZ2U6IHJlcy5zdGF0dXNNZXNzYWdlfSkpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZPcmlnaW4gPSBuZXcgVVJMKHVybCkub3JpZ2luXG4gICAgICAgIHZhciBuZXh0T3JpZ2luID0gbmV3IFVSTChsb2NhdGlvbikub3JpZ2luXG4gICAgICAgIGhhc05ld09yaWdpbiA9IHByZXZPcmlnaW4gIT09IG5leHRPcmlnaW5cbiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAzMDcpIHJlY29ubmVjdFVybCA9IHVybFxuICAgICAgICB1cmwgPSBsb2NhdGlvblxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNvbm5lY3QpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAocmVzLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICBfZW1pdCgnZXJyb3InLCBuZXcgRXZlbnQoJ2Vycm9yJywge3N0YXR1czogcmVzLnN0YXR1c0NvZGUsIG1lc3NhZ2U6IHJlcy5zdGF0dXNNZXNzYWdlfSkpXG4gICAgICAgIHJldHVybiBzZWxmLmNsb3NlKClcbiAgICAgIH1cblxuICAgICAgcmVhZHlTdGF0ZSA9IEV2ZW50U291cmNlLk9QRU5cbiAgICAgIHJlcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJylcbiAgICAgICAgcmVzLnJlbW92ZUFsbExpc3RlbmVycygnZW5kJylcbiAgICAgICAgb25Db25uZWN0aW9uQ2xvc2VkKClcbiAgICAgIH0pXG5cbiAgICAgIHJlcy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpXG4gICAgICAgIHJlcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpXG4gICAgICAgIG9uQ29ubmVjdGlvbkNsb3NlZCgpXG4gICAgICB9KVxuICAgICAgX2VtaXQoJ29wZW4nLCBuZXcgRXZlbnQoJ29wZW4nKSlcblxuICAgICAgLy8gdGV4dC9ldmVudC1zdHJlYW0gcGFyc2VyIGFkYXB0ZWQgZnJvbSB3ZWJraXQnc1xuICAgICAgLy8gU291cmNlL1dlYkNvcmUvcGFnZS9FdmVudFNvdXJjZS5jcHBcbiAgICAgIHZhciBidWZcbiAgICAgIHZhciBuZXdCdWZmZXJcbiAgICAgIHZhciBzdGFydGluZ1BvcyA9IDBcbiAgICAgIHZhciBzdGFydGluZ0ZpZWxkTGVuZ3RoID0gLTFcbiAgICAgIHZhciBuZXdCdWZmZXJTaXplID0gMFxuICAgICAgdmFyIGJ5dGVzVXNlZCA9IDBcblxuICAgICAgcmVzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIGlmICghYnVmKSB7XG4gICAgICAgICAgYnVmID0gY2h1bmtcbiAgICAgICAgICBpZiAoaGFzQm9tKGJ1ZikpIHtcbiAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZShib20ubGVuZ3RoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBieXRlc1VzZWQgPSBidWYubGVuZ3RoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA+IGJ1Zi5sZW5ndGggLSBieXRlc1VzZWQpIHtcbiAgICAgICAgICAgIG5ld0J1ZmZlclNpemUgPSAoYnVmLmxlbmd0aCAqIDIpICsgY2h1bmsubGVuZ3RoXG4gICAgICAgICAgICBpZiAobmV3QnVmZmVyU2l6ZSA+IG1heEJ1ZmZlckFoZWFkQWxsb2NhdGlvbikge1xuICAgICAgICAgICAgICBuZXdCdWZmZXJTaXplID0gYnVmLmxlbmd0aCArIGNodW5rLmxlbmd0aCArIG1heEJ1ZmZlckFoZWFkQWxsb2NhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QnVmZmVyID0gQnVmZmVyLmFsbG9jKG5ld0J1ZmZlclNpemUpXG4gICAgICAgICAgICBidWYuY29weShuZXdCdWZmZXIsIDAsIDAsIGJ5dGVzVXNlZClcbiAgICAgICAgICAgIGJ1ZiA9IG5ld0J1ZmZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBjaHVuay5jb3B5KGJ1ZiwgYnl0ZXNVc2VkKVxuICAgICAgICAgIGJ5dGVzVXNlZCArPSBjaHVuay5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSAwXG4gICAgICAgIHZhciBsZW5ndGggPSBieXRlc1VzZWRcblxuICAgICAgICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGRpc2NhcmRUcmFpbGluZ05ld2xpbmUpIHtcbiAgICAgICAgICAgIGlmIChidWZbcG9zXSA9PT0gbGluZUZlZWQpIHtcbiAgICAgICAgICAgICAgKytwb3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gLTFcbiAgICAgICAgICB2YXIgZmllbGRMZW5ndGggPSBzdGFydGluZ0ZpZWxkTGVuZ3RoXG4gICAgICAgICAgdmFyIGNcblxuICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydGluZ1BvczsgbGluZUxlbmd0aCA8IDAgJiYgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjID0gYnVmW2ldXG4gICAgICAgICAgICBpZiAoYyA9PT0gY29sb24pIHtcbiAgICAgICAgICAgICAgaWYgKGZpZWxkTGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgICAgIGZpZWxkTGVuZ3RoID0gaSAtIHBvc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IGNhcnJpYWdlUmV0dXJuKSB7XG4gICAgICAgICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSB0cnVlXG4gICAgICAgICAgICAgIGxpbmVMZW5ndGggPSBpIC0gcG9zXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IGxpbmVGZWVkKSB7XG4gICAgICAgICAgICAgIGxpbmVMZW5ndGggPSBpIC0gcG9zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxpbmVMZW5ndGggPCAwKSB7XG4gICAgICAgICAgICBzdGFydGluZ1BvcyA9IGxlbmd0aCAtIHBvc1xuICAgICAgICAgICAgc3RhcnRpbmdGaWVsZExlbmd0aCA9IGZpZWxkTGVuZ3RoXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydGluZ1BvcyA9IDBcbiAgICAgICAgICAgIHN0YXJ0aW5nRmllbGRMZW5ndGggPSAtMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnNlRXZlbnRTdHJlYW1MaW5lKGJ1ZiwgcG9zLCBmaWVsZExlbmd0aCwgbGluZUxlbmd0aClcblxuICAgICAgICAgIHBvcyArPSBsaW5lTGVuZ3RoICsgMVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvcyA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgYnVmID0gdm9pZCAwXG4gICAgICAgICAgYnl0ZXNVc2VkID0gMFxuICAgICAgICB9IGVsc2UgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgICBidWYgPSBidWYuc2xpY2UocG9zLCBieXRlc1VzZWQpXG4gICAgICAgICAgYnl0ZXNVc2VkID0gYnVmLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgc2VsZi5jb25uZWN0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlXG4gICAgICBvbkNvbm5lY3Rpb25DbG9zZWQoZXJyLm1lc3NhZ2UpXG4gICAgfSlcblxuICAgIGlmIChyZXEuc2V0Tm9EZWxheSkgcmVxLnNldE5vRGVsYXkodHJ1ZSlcbiAgICByZXEuZW5kKClcbiAgfVxuXG4gIGNvbm5lY3QoKVxuXG4gIGZ1bmN0aW9uIF9lbWl0ICgpIHtcbiAgICBpZiAoc2VsZi5saXN0ZW5lcnMoYXJndW1lbnRzWzBdKS5sZW5ndGggPiAwKSB7XG4gICAgICBzZWxmLmVtaXQuYXBwbHkoc2VsZiwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZWFkeVN0YXRlID09PSBFdmVudFNvdXJjZS5DTE9TRUQpIHJldHVyblxuICAgIHJlYWR5U3RhdGUgPSBFdmVudFNvdXJjZS5DTE9TRURcbiAgICBpZiAocmVxLmFib3J0KSByZXEuYWJvcnQoKVxuICAgIGlmIChyZXEueGhyICYmIHJlcS54aHIuYWJvcnQpIHJlcS54aHIuYWJvcnQoKVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFdmVudFN0cmVhbUxpbmUgKGJ1ZiwgcG9zLCBmaWVsZExlbmd0aCwgbGluZUxlbmd0aCkge1xuICAgIGlmIChsaW5lTGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0eXBlID0gZXZlbnROYW1lIHx8ICdtZXNzYWdlJ1xuICAgICAgICBfZW1pdCh0eXBlLCBuZXcgTWVzc2FnZUV2ZW50KHR5cGUsIHtcbiAgICAgICAgICBkYXRhOiBkYXRhLnNsaWNlKDAsIC0xKSwgLy8gcmVtb3ZlIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgICAgICBsYXN0RXZlbnRJZDogbGFzdEV2ZW50SWQsXG4gICAgICAgICAgb3JpZ2luOiBuZXcgVVJMKHVybCkub3JpZ2luXG4gICAgICAgIH0pKVxuICAgICAgICBkYXRhID0gJydcbiAgICAgIH1cbiAgICAgIGV2ZW50TmFtZSA9IHZvaWQgMFxuICAgIH0gZWxzZSBpZiAoZmllbGRMZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbm9WYWx1ZSA9IGZpZWxkTGVuZ3RoIDwgMFxuICAgICAgdmFyIHN0ZXAgPSAwXG4gICAgICB2YXIgZmllbGQgPSBidWYuc2xpY2UocG9zLCBwb3MgKyAobm9WYWx1ZSA/IGxpbmVMZW5ndGggOiBmaWVsZExlbmd0aCkpLnRvU3RyaW5nKClcblxuICAgICAgaWYgKG5vVmFsdWUpIHtcbiAgICAgICAgc3RlcCA9IGxpbmVMZW5ndGhcbiAgICAgIH0gZWxzZSBpZiAoYnVmW3BvcyArIGZpZWxkTGVuZ3RoICsgMV0gIT09IHNwYWNlKSB7XG4gICAgICAgIHN0ZXAgPSBmaWVsZExlbmd0aCArIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAgPSBmaWVsZExlbmd0aCArIDJcbiAgICAgIH1cbiAgICAgIHBvcyArPSBzdGVwXG5cbiAgICAgIHZhciB2YWx1ZUxlbmd0aCA9IGxpbmVMZW5ndGggLSBzdGVwXG4gICAgICB2YXIgdmFsdWUgPSBidWYuc2xpY2UocG9zLCBwb3MgKyB2YWx1ZUxlbmd0aCkudG9TdHJpbmcoKVxuXG4gICAgICBpZiAoZmllbGQgPT09ICdkYXRhJykge1xuICAgICAgICBkYXRhICs9IHZhbHVlICsgJ1xcbidcbiAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdldmVudCcpIHtcbiAgICAgICAgZXZlbnROYW1lID0gdmFsdWVcbiAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdpZCcpIHtcbiAgICAgICAgbGFzdEV2ZW50SWQgPSB2YWx1ZVxuICAgICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gJ3JldHJ5Jykge1xuICAgICAgICB2YXIgcmV0cnkgPSBwYXJzZUludCh2YWx1ZSwgMTApXG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHJldHJ5KSkge1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0SW50ZXJ2YWwgPSByZXRyeVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VcblxudXRpbC5pbmhlcml0cyhFdmVudFNvdXJjZSwgZXZlbnRzLkV2ZW50RW1pdHRlcilcbkV2ZW50U291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50U291cmNlOyAvLyBtYWtlIHN0YWNrdHJhY2VzIHJlYWRhYmxlXG5cblsnb3BlbicsICdlcnJvcicsICdtZXNzYWdlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZS5wcm90b3R5cGUsICdvbicgKyBtZXRob2QsIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxpc3RlbmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNaXhlZH0gdGhlIHNldCBmdW5jdGlvbiBvciB1bmRlZmluZWRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmxpc3RlbmVycyhtZXRob2QpWzBdXG4gICAgICByZXR1cm4gbGlzdGVuZXIgPyAobGlzdGVuZXIuX2xpc3RlbmVyID8gbGlzdGVuZXIuX2xpc3RlbmVyIDogbGlzdGVuZXIpIDogdW5kZWZpbmVkXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtNaXhlZH0gdGhlIHNldCBmdW5jdGlvbiBvciB1bmRlZmluZWRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCAobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG1ldGhvZClcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKVxuICAgIH1cbiAgfSlcbn0pXG5cbi8qKlxuICogUmVhZHkgc3RhdGVzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZSwgJ0NPTk5FQ1RJTkcnLCB7ZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IDB9KVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50U291cmNlLCAnT1BFTicsIHtlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogMX0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRTb3VyY2UsICdDTE9TRUQnLCB7ZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IDJ9KVxuXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuQ09OTkVDVElORyA9IDBcbkV2ZW50U291cmNlLnByb3RvdHlwZS5PUEVOID0gMVxuRXZlbnRTb3VyY2UucHJvdG90eXBlLkNMT1NFRCA9IDJcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24sIGlmIG9uZSBpcyBtYWRlLCBhbmQgc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gMiAoY2xvc2VkKVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL2Nsb3NlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2Nsb3NlKClcbn1cblxuLyoqXG4gKiBFbXVsYXRlcyB0aGUgVzNDIEJyb3dzZXIgYmFzZWQgV2ViU29ja2V0IGludGVyZmFjZSB1c2luZyBhZGRFdmVudExpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gb3V0IGZvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgY2FsbGJhY2tcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lclxuICogQHNlZSBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRTb3VyY2UucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyICh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gc3RvcmUgYSByZWZlcmVuY2Ugc28gd2UgY2FuIHJldHVybiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYWdhaW5cbiAgICBsaXN0ZW5lci5fbGlzdGVuZXIgPSBsaXN0ZW5lclxuICAgIHRoaXMub24odHlwZSwgbGlzdGVuZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBFbXVsYXRlcyB0aGUgVzNDIEJyb3dzZXIgYmFzZWQgV2ViU29ja2V0IGludGVyZmFjZSB1c2luZyBkaXNwYXRjaEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEFuIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWRcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2Rpc3BhdGNoRXZlbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50U291cmNlLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCAoZXZlbnQpIHtcbiAgaWYgKCFldmVudC50eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVTlNQRUNJRklFRF9FVkVOVF9UWVBFX0VSUicpXG4gIH1cbiAgLy8gaWYgZXZlbnQgaXMgaW5zdGFuY2Ugb2YgYW4gQ3VzdG9tRXZlbnQgKG9yIGhhcyAnZGV0YWlscycgcHJvcGVydHkpLFxuICAvLyBzZW5kIHRoZSBkZXRhaWwgb2JqZWN0IGFzIHRoZSBwYXlsb2FkIGZvciB0aGUgZXZlbnRcbiAgdGhpcy5lbWl0KGV2ZW50LnR5cGUsIGV2ZW50LmRldGFpbClcbn1cblxuLyoqXG4gKiBFbXVsYXRlcyB0aGUgVzNDIEJyb3dzZXIgYmFzZWQgV2ViU29ja2V0IGludGVyZmFjZSB1c2luZyByZW1vdmVFdmVudExpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIGNhbGxiYWNrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXJcbiAqIEBzZWUgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lciAodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3RlbmVyLl9saXN0ZW5lciA9IHVuZGVmaW5lZFxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBXM0MgRXZlbnRcbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jaW50ZXJmYWNlLUV2ZW50XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnQgKHR5cGUsIG9wdGlvbmFsUHJvcGVydGllcykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IHRydWUgfSlcbiAgaWYgKG9wdGlvbmFsUHJvcGVydGllcykge1xuICAgIGZvciAodmFyIGYgaW4gb3B0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAob3B0aW9uYWxQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGYpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBmLCB7IHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IG9wdGlvbmFsUHJvcGVydGllc1tmXSwgZW51bWVyYWJsZTogdHJ1ZSB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFczQyBNZXNzYWdlRXZlbnRcbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3dlYm1lc3NhZ2luZy8jZXZlbnQtZGVmaW5pdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBNZXNzYWdlRXZlbnQgKHR5cGUsIGV2ZW50SW5pdERpY3QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywgeyB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlIH0pXG4gIGZvciAodmFyIGYgaW4gZXZlbnRJbml0RGljdCkge1xuICAgIGlmIChldmVudEluaXREaWN0Lmhhc093blByb3BlcnR5KGYpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgZiwgeyB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBldmVudEluaXREaWN0W2ZdLCBlbnVtZXJhYmxlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvYmplY3Qgb2YgaGVhZGVycyB0aGF0IGRvZXMgbm90IGluY2x1ZGUgYW55IGF1dGhvcml6YXRpb24gYW5kIGNvb2tpZSBoZWFkZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgQW4gb2JqZWN0IG9mIGhlYWRlcnMgKHtbaGVhZGVyTmFtZV06IGhlYWRlclZhbHVlfSlcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IG9mIGhlYWRlcnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVVbnNhZmVIZWFkZXJzIChoZWFkZXJzKSB7XG4gIHZhciBzYWZlID0ge31cbiAgZm9yICh2YXIga2V5IGluIGhlYWRlcnMpIHtcbiAgICBpZiAocmVVbnNhZmVIZWFkZXIudGVzdChrZXkpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHNhZmVba2V5XSA9IGhlYWRlcnNba2V5XVxuICB9XG5cbiAgcmV0dXJuIHNhZmVcbn1cbiJdLCJuYW1lcyI6WyJwYXJzZSIsInJlcXVpcmUiLCJldmVudHMiLCJodHRwcyIsImh0dHAiLCJ1dGlsIiwiaHR0cHNPcHRpb25zIiwiYm9tIiwiY29sb24iLCJzcGFjZSIsImxpbmVGZWVkIiwiY2FycmlhZ2VSZXR1cm4iLCJtYXhCdWZmZXJBaGVhZEFsbG9jYXRpb24iLCJyZVVuc2FmZUhlYWRlciIsImhhc0JvbSIsImJ1ZiIsImV2ZXJ5IiwiY2hhckNvZGUiLCJpbmRleCIsIkV2ZW50U291cmNlIiwidXJsIiwiZXZlbnRTb3VyY2VJbml0RGljdCIsInJlYWR5U3RhdGUiLCJDT05ORUNUSU5HIiwiaGVhZGVycyIsImhhc05ld09yaWdpbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic2VsZiIsInJlY29ubmVjdEludGVydmFsIiwiY29ubmVjdGlvbkluUHJvZ3Jlc3MiLCJvbkNvbm5lY3Rpb25DbG9zZWQiLCJtZXNzYWdlIiwiQ0xPU0VEIiwiX2VtaXQiLCJFdmVudCIsInJlY29ubmVjdFVybCIsInNldFRpbWVvdXQiLCJjb25uZWN0IiwicmVxIiwibGFzdEV2ZW50SWQiLCJkaXNjYXJkVHJhaWxpbmdOZXdsaW5lIiwiZGF0YSIsImV2ZW50TmFtZSIsIm9wdGlvbnMiLCJpc1NlY3VyZSIsInByb3RvY29sIiwicmVxSGVhZGVycyIsInJlbW92ZVVuc2FmZUhlYWRlcnMiLCJpIiwiaGVhZGVyIiwicmVqZWN0VW5hdXRob3JpemVkIiwiY3JlYXRlQ29ubmVjdGlvbiIsInVuZGVmaW5lZCIsInVzZVByb3h5IiwicHJveHkiLCJwYXRoIiwiSG9zdCIsImhvc3QiLCJob3N0bmFtZSIsInBvcnQiLCJvcHROYW1lIiwiaW5kZXhPZiIsIm9wdGlvbiIsIndpdGhDcmVkZW50aWFscyIsInJlcXVlc3QiLCJyZXMiLCJzdGF0dXNDb2RlIiwic3RhdHVzIiwic3RhdHVzTWVzc2FnZSIsImxvY2F0aW9uIiwicHJldk9yaWdpbiIsIlVSTCIsIm9yaWdpbiIsIm5leHRPcmlnaW4iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjbG9zZSIsIk9QRU4iLCJvbiIsInJlbW92ZUFsbExpc3RlbmVycyIsIm5ld0J1ZmZlciIsInN0YXJ0aW5nUG9zIiwic3RhcnRpbmdGaWVsZExlbmd0aCIsIm5ld0J1ZmZlclNpemUiLCJieXRlc1VzZWQiLCJjaHVuayIsInNsaWNlIiwibGVuZ3RoIiwiQnVmZmVyIiwiYWxsb2MiLCJjb3B5IiwicG9zIiwibGluZUxlbmd0aCIsImZpZWxkTGVuZ3RoIiwiYyIsInBhcnNlRXZlbnRTdHJlYW1MaW5lIiwiZXJyIiwic2V0Tm9EZWxheSIsImVuZCIsImxpc3RlbmVycyIsImFyZ3VtZW50cyIsImVtaXQiLCJhcHBseSIsIl9jbG9zZSIsImFib3J0IiwieGhyIiwidHlwZSIsIk1lc3NhZ2VFdmVudCIsIm5vVmFsdWUiLCJzdGVwIiwiZmllbGQiLCJ0b1N0cmluZyIsInZhbHVlTGVuZ3RoIiwidmFsdWUiLCJyZXRyeSIsInBhcnNlSW50IiwiTnVtYmVyIiwiaXNOYU4iLCJtb2R1bGUiLCJleHBvcnRzIiwiaW5oZXJpdHMiLCJFdmVudEVtaXR0ZXIiLCJwcm90b3R5cGUiLCJjb25zdHJ1Y3RvciIsImZvckVhY2giLCJtZXRob2QiLCJsaXN0ZW5lciIsIl9saXN0ZW5lciIsInNldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlbnVtZXJhYmxlIiwiZGlzcGF0Y2hFdmVudCIsImV2ZW50IiwiRXJyb3IiLCJkZXRhaWwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJvcHRpb25hbFByb3BlcnRpZXMiLCJ3cml0YWJsZSIsImYiLCJoYXNPd25Qcm9wZXJ0eSIsImV2ZW50SW5pdERpY3QiLCJzYWZlIiwia2V5IiwidGVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/eventsource/lib/eventsource.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/eventsource/lib/eventsource.js":
/*!*****************************************************!*\
  !*** ./node_modules/eventsource/lib/eventsource.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar parse = (__webpack_require__(/*! url */ \"url\").parse);\nvar events = __webpack_require__(/*! events */ \"events\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar httpsOptions = [\n    \"pfx\",\n    \"key\",\n    \"passphrase\",\n    \"cert\",\n    \"ca\",\n    \"ciphers\",\n    \"rejectUnauthorized\",\n    \"secureProtocol\",\n    \"servername\",\n    \"checkServerIdentity\"\n];\nvar bom = [\n    239,\n    187,\n    191\n];\nvar colon = 58;\nvar space = 32;\nvar lineFeed = 10;\nvar carriageReturn = 13;\n// Beyond 256KB we could not observe any gain in performance\nvar maxBufferAheadAllocation = 1024 * 256;\n// Headers matching the pattern should be removed when redirecting to different origin\nvar reUnsafeHeader = /^(cookie|authorization)$/i;\nfunction hasBom(buf) {\n    return bom.every(function(charCode, index) {\n        return buf[index] === charCode;\n    });\n}\n/**\n * Creates a new EventSource object\n *\n * @param {String} url the URL to which to connect\n * @param {Object} [eventSourceInitDict] extra init params. See README for details.\n * @api public\n **/ function EventSource(url, eventSourceInitDict) {\n    var readyState = EventSource.CONNECTING;\n    var headers = eventSourceInitDict && eventSourceInitDict.headers;\n    var hasNewOrigin = false;\n    Object.defineProperty(this, \"readyState\", {\n        get: function() {\n            return readyState;\n        }\n    });\n    Object.defineProperty(this, \"url\", {\n        get: function() {\n            return url;\n        }\n    });\n    var self = this;\n    self.reconnectInterval = 1000;\n    self.connectionInProgress = false;\n    function onConnectionClosed(message) {\n        if (readyState === EventSource.CLOSED) return;\n        readyState = EventSource.CONNECTING;\n        _emit(\"error\", new Event(\"error\", {\n            message: message\n        }));\n        // The url may have been changed by a temporary redirect. If that's the case,\n        // revert it now, and flag that we are no longer pointing to a new origin\n        if (reconnectUrl) {\n            url = reconnectUrl;\n            reconnectUrl = null;\n            hasNewOrigin = false;\n        }\n        setTimeout(function() {\n            if (readyState !== EventSource.CONNECTING || self.connectionInProgress) {\n                return;\n            }\n            self.connectionInProgress = true;\n            connect();\n        }, self.reconnectInterval);\n    }\n    var req;\n    var lastEventId = \"\";\n    if (headers && headers[\"Last-Event-ID\"]) {\n        lastEventId = headers[\"Last-Event-ID\"];\n        delete headers[\"Last-Event-ID\"];\n    }\n    var discardTrailingNewline = false;\n    var data = \"\";\n    var eventName = \"\";\n    var reconnectUrl = null;\n    function connect() {\n        var options = parse(url);\n        var isSecure = options.protocol === \"https:\";\n        options.headers = {\n            \"Cache-Control\": \"no-cache\",\n            \"Accept\": \"text/event-stream\"\n        };\n        if (lastEventId) options.headers[\"Last-Event-ID\"] = lastEventId;\n        if (headers) {\n            var reqHeaders = hasNewOrigin ? removeUnsafeHeaders(headers) : headers;\n            for(var i in reqHeaders){\n                var header = reqHeaders[i];\n                if (header) {\n                    options.headers[i] = header;\n                }\n            }\n        }\n        // Legacy: this should be specified as `eventSourceInitDict.https.rejectUnauthorized`,\n        // but for now exists as a backwards-compatibility layer\n        options.rejectUnauthorized = !(eventSourceInitDict && !eventSourceInitDict.rejectUnauthorized);\n        if (eventSourceInitDict && eventSourceInitDict.createConnection !== undefined) {\n            options.createConnection = eventSourceInitDict.createConnection;\n        }\n        // If specify http proxy, make the request to sent to the proxy server,\n        // and include the original url in path and Host headers\n        var useProxy = eventSourceInitDict && eventSourceInitDict.proxy;\n        if (useProxy) {\n            var proxy = parse(eventSourceInitDict.proxy);\n            isSecure = proxy.protocol === \"https:\";\n            options.protocol = isSecure ? \"https:\" : \"http:\";\n            options.path = url;\n            options.headers.Host = options.host;\n            options.hostname = proxy.hostname;\n            options.host = proxy.host;\n            options.port = proxy.port;\n        }\n        // If https options are specified, merge them into the request options\n        if (eventSourceInitDict && eventSourceInitDict.https) {\n            for(var optName in eventSourceInitDict.https){\n                if (httpsOptions.indexOf(optName) === -1) {\n                    continue;\n                }\n                var option = eventSourceInitDict.https[optName];\n                if (option !== undefined) {\n                    options[optName] = option;\n                }\n            }\n        }\n        // Pass this on to the XHR\n        if (eventSourceInitDict && eventSourceInitDict.withCredentials !== undefined) {\n            options.withCredentials = eventSourceInitDict.withCredentials;\n        }\n        req = (isSecure ? https : http).request(options, function(res) {\n            self.connectionInProgress = false;\n            // Handle HTTP errors\n            if (res.statusCode === 500 || res.statusCode === 502 || res.statusCode === 503 || res.statusCode === 504) {\n                _emit(\"error\", new Event(\"error\", {\n                    status: res.statusCode,\n                    message: res.statusMessage\n                }));\n                onConnectionClosed();\n                return;\n            }\n            // Handle HTTP redirects\n            if (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) {\n                var location = res.headers.location;\n                if (!location) {\n                    // Server sent redirect response without Location header.\n                    _emit(\"error\", new Event(\"error\", {\n                        status: res.statusCode,\n                        message: res.statusMessage\n                    }));\n                    return;\n                }\n                var prevOrigin = new URL(url).origin;\n                var nextOrigin = new URL(location).origin;\n                hasNewOrigin = prevOrigin !== nextOrigin;\n                if (res.statusCode === 307) reconnectUrl = url;\n                url = location;\n                process.nextTick(connect);\n                return;\n            }\n            if (res.statusCode !== 200) {\n                _emit(\"error\", new Event(\"error\", {\n                    status: res.statusCode,\n                    message: res.statusMessage\n                }));\n                return self.close();\n            }\n            readyState = EventSource.OPEN;\n            res.on(\"close\", function() {\n                res.removeAllListeners(\"close\");\n                res.removeAllListeners(\"end\");\n                onConnectionClosed();\n            });\n            res.on(\"end\", function() {\n                res.removeAllListeners(\"close\");\n                res.removeAllListeners(\"end\");\n                onConnectionClosed();\n            });\n            _emit(\"open\", new Event(\"open\"));\n            // text/event-stream parser adapted from webkit's\n            // Source/WebCore/page/EventSource.cpp\n            var buf;\n            var newBuffer;\n            var startingPos = 0;\n            var startingFieldLength = -1;\n            var newBufferSize = 0;\n            var bytesUsed = 0;\n            res.on(\"data\", function(chunk) {\n                if (!buf) {\n                    buf = chunk;\n                    if (hasBom(buf)) {\n                        buf = buf.slice(bom.length);\n                    }\n                    bytesUsed = buf.length;\n                } else {\n                    if (chunk.length > buf.length - bytesUsed) {\n                        newBufferSize = buf.length * 2 + chunk.length;\n                        if (newBufferSize > maxBufferAheadAllocation) {\n                            newBufferSize = buf.length + chunk.length + maxBufferAheadAllocation;\n                        }\n                        newBuffer = Buffer.alloc(newBufferSize);\n                        buf.copy(newBuffer, 0, 0, bytesUsed);\n                        buf = newBuffer;\n                    }\n                    chunk.copy(buf, bytesUsed);\n                    bytesUsed += chunk.length;\n                }\n                var pos = 0;\n                var length = bytesUsed;\n                while(pos < length){\n                    if (discardTrailingNewline) {\n                        if (buf[pos] === lineFeed) {\n                            ++pos;\n                        }\n                        discardTrailingNewline = false;\n                    }\n                    var lineLength = -1;\n                    var fieldLength = startingFieldLength;\n                    var c;\n                    for(var i = startingPos; lineLength < 0 && i < length; ++i){\n                        c = buf[i];\n                        if (c === colon) {\n                            if (fieldLength < 0) {\n                                fieldLength = i - pos;\n                            }\n                        } else if (c === carriageReturn) {\n                            discardTrailingNewline = true;\n                            lineLength = i - pos;\n                        } else if (c === lineFeed) {\n                            lineLength = i - pos;\n                        }\n                    }\n                    if (lineLength < 0) {\n                        startingPos = length - pos;\n                        startingFieldLength = fieldLength;\n                        break;\n                    } else {\n                        startingPos = 0;\n                        startingFieldLength = -1;\n                    }\n                    parseEventStreamLine(buf, pos, fieldLength, lineLength);\n                    pos += lineLength + 1;\n                }\n                if (pos === length) {\n                    buf = void 0;\n                    bytesUsed = 0;\n                } else if (pos > 0) {\n                    buf = buf.slice(pos, bytesUsed);\n                    bytesUsed = buf.length;\n                }\n            });\n        });\n        req.on(\"error\", function(err) {\n            self.connectionInProgress = false;\n            onConnectionClosed(err.message);\n        });\n        if (req.setNoDelay) req.setNoDelay(true);\n        req.end();\n    }\n    connect();\n    function _emit() {\n        if (self.listeners(arguments[0]).length > 0) {\n            self.emit.apply(self, arguments);\n        }\n    }\n    this._close = function() {\n        if (readyState === EventSource.CLOSED) return;\n        readyState = EventSource.CLOSED;\n        if (req.abort) req.abort();\n        if (req.xhr && req.xhr.abort) req.xhr.abort();\n    };\n    function parseEventStreamLine(buf, pos, fieldLength, lineLength) {\n        if (lineLength === 0) {\n            if (data.length > 0) {\n                var type = eventName || \"message\";\n                _emit(type, new MessageEvent(type, {\n                    data: data.slice(0, -1),\n                    lastEventId: lastEventId,\n                    origin: new URL(url).origin\n                }));\n                data = \"\";\n            }\n            eventName = void 0;\n        } else if (fieldLength > 0) {\n            var noValue = fieldLength < 0;\n            var step = 0;\n            var field = buf.slice(pos, pos + (noValue ? lineLength : fieldLength)).toString();\n            if (noValue) {\n                step = lineLength;\n            } else if (buf[pos + fieldLength + 1] !== space) {\n                step = fieldLength + 1;\n            } else {\n                step = fieldLength + 2;\n            }\n            pos += step;\n            var valueLength = lineLength - step;\n            var value = buf.slice(pos, pos + valueLength).toString();\n            if (field === \"data\") {\n                data += value + \"\\n\";\n            } else if (field === \"event\") {\n                eventName = value;\n            } else if (field === \"id\") {\n                lastEventId = value;\n            } else if (field === \"retry\") {\n                var retry = parseInt(value, 10);\n                if (!Number.isNaN(retry)) {\n                    self.reconnectInterval = retry;\n                }\n            }\n        }\n    }\n}\nmodule.exports = EventSource;\nutil.inherits(EventSource, events.EventEmitter);\nEventSource.prototype.constructor = EventSource; // make stacktraces readable\n[\n    \"open\",\n    \"error\",\n    \"message\"\n].forEach(function(method) {\n    Object.defineProperty(EventSource.prototype, \"on\" + method, {\n        /**\n     * Returns the current listener\n     *\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */ get: function get() {\n            var listener = this.listeners(method)[0];\n            return listener ? listener._listener ? listener._listener : listener : undefined;\n        },\n        /**\n     * Start listening for events\n     *\n     * @param {Function} listener the listener\n     * @return {Mixed} the set function or undefined\n     * @api private\n     */ set: function set(listener) {\n            this.removeAllListeners(method);\n            this.addEventListener(method, listener);\n        }\n    });\n});\n/**\n * Ready states\n */ Object.defineProperty(EventSource, \"CONNECTING\", {\n    enumerable: true,\n    value: 0\n});\nObject.defineProperty(EventSource, \"OPEN\", {\n    enumerable: true,\n    value: 1\n});\nObject.defineProperty(EventSource, \"CLOSED\", {\n    enumerable: true,\n    value: 2\n});\nEventSource.prototype.CONNECTING = 0;\nEventSource.prototype.OPEN = 1;\nEventSource.prototype.CLOSED = 2;\n/**\n * Closes the connection, if one is made, and sets the readyState attribute to 2 (closed)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close\n * @api public\n */ EventSource.prototype.close = function() {\n    this._close();\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using addEventListener.\n *\n * @param {String} type A string representing the event type to listen out for\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.addEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */ EventSource.prototype.addEventListener = function addEventListener(type, listener) {\n    if (typeof listener === \"function\") {\n        // store a reference so we can return the original function again\n        listener._listener = listener;\n        this.on(type, listener);\n    }\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using dispatchEvent.\n *\n * @param {Event} event An event to be dispatched\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent\n * @api public\n */ EventSource.prototype.dispatchEvent = function dispatchEvent(event) {\n    if (!event.type) {\n        throw new Error(\"UNSPECIFIED_EVENT_TYPE_ERR\");\n    }\n    // if event is instance of an CustomEvent (or has 'details' property),\n    // send the detail object as the payload for the event\n    this.emit(event.type, event.detail);\n};\n/**\n * Emulates the W3C Browser based WebSocket interface using removeEventListener.\n *\n * @param {String} type A string representing the event type to remove\n * @param {Function} listener callback\n * @see https://developer.mozilla.org/en/DOM/element.removeEventListener\n * @see http://dev.w3.org/html5/websockets/#the-websocket-interface\n * @api public\n */ EventSource.prototype.removeEventListener = function removeEventListener(type, listener) {\n    if (typeof listener === \"function\") {\n        listener._listener = undefined;\n        this.removeListener(type, listener);\n    }\n};\n/**\n * W3C Event\n *\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#interface-Event\n * @api private\n */ function Event(type, optionalProperties) {\n    Object.defineProperty(this, \"type\", {\n        writable: false,\n        value: type,\n        enumerable: true\n    });\n    if (optionalProperties) {\n        for(var f in optionalProperties){\n            if (optionalProperties.hasOwnProperty(f)) {\n                Object.defineProperty(this, f, {\n                    writable: false,\n                    value: optionalProperties[f],\n                    enumerable: true\n                });\n            }\n        }\n    }\n}\n/**\n * W3C MessageEvent\n *\n * @see http://www.w3.org/TR/webmessaging/#event-definitions\n * @api private\n */ function MessageEvent(type, eventInitDict) {\n    Object.defineProperty(this, \"type\", {\n        writable: false,\n        value: type,\n        enumerable: true\n    });\n    for(var f in eventInitDict){\n        if (eventInitDict.hasOwnProperty(f)) {\n            Object.defineProperty(this, f, {\n                writable: false,\n                value: eventInitDict[f],\n                enumerable: true\n            });\n        }\n    }\n}\n/**\n * Returns a new object of headers that does not include any authorization and cookie headers\n *\n * @param {Object} headers An object of headers ({[headerName]: headerValue})\n * @return {Object} a new object of headers\n * @api private\n */ function removeUnsafeHeaders(headers) {\n    var safe = {};\n    for(var key in headers){\n        if (reUnsafeHeader.test(key)) {\n            continue;\n        }\n        safe[key] = headers[key];\n    }\n    return safe;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXZlbnRzb3VyY2UvbGliL2V2ZW50c291cmNlLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJQSxRQUFRQyw2Q0FBb0I7QUFDaEMsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDckIsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUcsT0FBT0gsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUksT0FBT0osbUJBQU9BLENBQUM7QUFFbkIsSUFBSUssZUFBZTtJQUNqQjtJQUFPO0lBQU87SUFBYztJQUFRO0lBQU07SUFDMUM7SUFBc0I7SUFBa0I7SUFBYztDQUN2RDtBQUVELElBQUlDLE1BQU07SUFBQztJQUFLO0lBQUs7Q0FBSTtBQUN6QixJQUFJQyxRQUFRO0FBQ1osSUFBSUMsUUFBUTtBQUNaLElBQUlDLFdBQVc7QUFDZixJQUFJQyxpQkFBaUI7QUFDckIsNERBQTREO0FBQzVELElBQUlDLDJCQUEyQixPQUFPO0FBQ3RDLHNGQUFzRjtBQUN0RixJQUFJQyxpQkFBaUI7QUFFckIsU0FBU0MsT0FBUUMsR0FBRztJQUNsQixPQUFPUixJQUFJUyxLQUFLLENBQUMsU0FBVUMsUUFBUSxFQUFFQyxLQUFLO1FBQ3hDLE9BQU9ILEdBQUcsQ0FBQ0csTUFBTSxLQUFLRDtJQUN4QjtBQUNGO0FBRUE7Ozs7OztFQU1FLEdBQ0YsU0FBU0UsWUFBYUMsR0FBRyxFQUFFQyxtQkFBbUI7SUFDNUMsSUFBSUMsYUFBYUgsWUFBWUksVUFBVTtJQUN2QyxJQUFJQyxVQUFVSCx1QkFBdUJBLG9CQUFvQkcsT0FBTztJQUNoRSxJQUFJQyxlQUFlO0lBQ25CQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7UUFDeENDLEtBQUs7WUFDSCxPQUFPTjtRQUNUO0lBQ0Y7SUFFQUksT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxPQUFPO1FBQ2pDQyxLQUFLO1lBQ0gsT0FBT1I7UUFDVDtJQUNGO0lBRUEsSUFBSVMsT0FBTyxJQUFJO0lBQ2ZB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UUFBRWlILFVBQVU7UUFBT3pCLE9BQU9QO1FBQU13QixZQUFZO0lBQUs7SUFDckYsSUFBSyxJQUFJUyxLQUFLRSxjQUFlO1FBQzNCLElBQUlBLGNBQWNELGNBQWMsQ0FBQ0QsSUFBSTtZQUNuQ25ILE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUVrSCxHQUFHO2dCQUFFRCxVQUFVO2dCQUFPekIsT0FBTzRCLGFBQWEsQ0FBQ0YsRUFBRTtnQkFBRVQsWUFBWTtZQUFLO1FBQzlGO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNuRixvQkFBcUJ6QixPQUFPO0lBQ25DLElBQUl3SCxPQUFPLENBQUM7SUFDWixJQUFLLElBQUlDLE9BQU96SCxRQUFTO1FBQ3ZCLElBQUlYLGVBQWVxSSxJQUFJLENBQUNELE1BQU07WUFDNUI7UUFDRjtRQUVBRCxJQUFJLENBQUNDLElBQUksR0FBR3pILE9BQU8sQ0FBQ3lILElBQUk7SUFDMUI7SUFFQSxPQUFPRDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMvZXZlbnRzb3VyY2UvbGliL2V2ZW50c291cmNlLmpzP2RkMmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBhcnNlID0gcmVxdWlyZSgndXJsJykucGFyc2VcbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKVxudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbnZhciBodHRwc09wdGlvbnMgPSBbXG4gICdwZngnLCAna2V5JywgJ3Bhc3NwaHJhc2UnLCAnY2VydCcsICdjYScsICdjaXBoZXJzJyxcbiAgJ3JlamVjdFVuYXV0aG9yaXplZCcsICdzZWN1cmVQcm90b2NvbCcsICdzZXJ2ZXJuYW1lJywgJ2NoZWNrU2VydmVySWRlbnRpdHknXG5dXG5cbnZhciBib20gPSBbMjM5LCAxODcsIDE5MV1cbnZhciBjb2xvbiA9IDU4XG52YXIgc3BhY2UgPSAzMlxudmFyIGxpbmVGZWVkID0gMTBcbnZhciBjYXJyaWFnZVJldHVybiA9IDEzXG4vLyBCZXlvbmQgMjU2S0Igd2UgY291bGQgbm90IG9ic2VydmUgYW55IGdhaW4gaW4gcGVyZm9ybWFuY2VcbnZhciBtYXhCdWZmZXJBaGVhZEFsbG9jYXRpb24gPSAxMDI0ICogMjU2XG4vLyBIZWFkZXJzIG1hdGNoaW5nIHRoZSBwYXR0ZXJuIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gcmVkaXJlY3RpbmcgdG8gZGlmZmVyZW50IG9yaWdpblxudmFyIHJlVW5zYWZlSGVhZGVyID0gL14oY29va2llfGF1dGhvcml6YXRpb24pJC9pXG5cbmZ1bmN0aW9uIGhhc0JvbSAoYnVmKSB7XG4gIHJldHVybiBib20uZXZlcnkoZnVuY3Rpb24gKGNoYXJDb2RlLCBpbmRleCkge1xuICAgIHJldHVybiBidWZbaW5kZXhdID09PSBjaGFyQ29kZVxuICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgRXZlbnRTb3VyY2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCB0aGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRTb3VyY2VJbml0RGljdF0gZXh0cmEgaW5pdCBwYXJhbXMuIFNlZSBSRUFETUUgZm9yIGRldGFpbHMuXG4gKiBAYXBpIHB1YmxpY1xuICoqL1xuZnVuY3Rpb24gRXZlbnRTb3VyY2UgKHVybCwgZXZlbnRTb3VyY2VJbml0RGljdCkge1xuICB2YXIgcmVhZHlTdGF0ZSA9IEV2ZW50U291cmNlLkNPTk5FQ1RJTkdcbiAgdmFyIGhlYWRlcnMgPSBldmVudFNvdXJjZUluaXREaWN0ICYmIGV2ZW50U291cmNlSW5pdERpY3QuaGVhZGVyc1xuICB2YXIgaGFzTmV3T3JpZ2luID0gZmFsc2VcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWFkeVN0YXRlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlYWR5U3RhdGVcbiAgICB9XG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd1cmwnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdXJsXG4gICAgfVxuICB9KVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLnJlY29ubmVjdEludGVydmFsID0gMTAwMFxuICBzZWxmLmNvbm5lY3Rpb25JblByb2dyZXNzID0gZmFsc2VcblxuICBmdW5jdGlvbiBvbkNvbm5lY3Rpb25DbG9zZWQgKG1lc3NhZ2UpIHtcbiAgICBpZiAocmVhZHlTdGF0ZSA9PT0gRXZlbnRTb3VyY2UuQ0xPU0VEKSByZXR1cm5cbiAgICByZWFkeVN0YXRlID0gRXZlbnRTb3VyY2UuQ09OTkVDVElOR1xuICAgIF9lbWl0KCdlcnJvcicsIG5ldyBFdmVudCgnZXJyb3InLCB7bWVzc2FnZTogbWVzc2FnZX0pKVxuXG4gICAgLy8gVGhlIHVybCBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgYnkgYSB0ZW1wb3JhcnkgcmVkaXJlY3QuIElmIHRoYXQncyB0aGUgY2FzZSxcbiAgICAvLyByZXZlcnQgaXQgbm93LCBhbmQgZmxhZyB0aGF0IHdlIGFyZSBubyBsb25nZXIgcG9pbnRpbmcgdG8gYSBuZXcgb3JpZ2luXG4gICAgaWYgKHJlY29ubmVjdFVybCkge1xuICAgICAgdXJsID0gcmVjb25uZWN0VXJsXG4gICAgICByZWNvbm5lY3RVcmwgPSBudWxsXG4gICAgICBoYXNOZXdPcmlnaW4gPSBmYWxzZVxuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChyZWFkeVN0YXRlICE9PSBFdmVudFNvdXJjZS5DT05ORUNUSU5HIHx8IHNlbGYuY29ubmVjdGlvbkluUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzZWxmLmNvbm5lY3Rpb25JblByb2dyZXNzID0gdHJ1ZVxuICAgICAgY29ubmVjdCgpXG4gICAgfSwgc2VsZi5yZWNvbm5lY3RJbnRlcnZhbClcbiAgfVxuXG4gIHZhciByZXFcbiAgdmFyIGxhc3RFdmVudElkID0gJydcbiAgaWYgKGhlYWRlcnMgJiYgaGVhZGVyc1snTGFzdC1FdmVudC1JRCddKSB7XG4gICAgbGFzdEV2ZW50SWQgPSBoZWFkZXJzWydMYXN0LUV2ZW50LUlEJ11cbiAgICBkZWxldGUgaGVhZGVyc1snTGFzdC1FdmVudC1JRCddXG4gIH1cblxuICB2YXIgZGlzY2FyZFRyYWlsaW5nTmV3bGluZSA9IGZhbHNlXG4gIHZhciBkYXRhID0gJydcbiAgdmFyIGV2ZW50TmFtZSA9ICcnXG5cbiAgdmFyIHJlY29ubmVjdFVybCA9IG51bGxcblxuICBmdW5jdGlvbiBjb25uZWN0ICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHBhcnNlKHVybClcbiAgICB2YXIgaXNTZWN1cmUgPSBvcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6J1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IHsgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLCAnQWNjZXB0JzogJ3RleHQvZXZlbnQtc3RyZWFtJyB9XG4gICAgaWYgKGxhc3RFdmVudElkKSBvcHRpb25zLmhlYWRlcnNbJ0xhc3QtRXZlbnQtSUQnXSA9IGxhc3RFdmVudElkXG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIHZhciByZXFIZWFkZXJzID0gaGFzTmV3T3JpZ2luID8gcmVtb3ZlVW5zYWZlSGVhZGVycyhoZWFkZXJzKSA6IGhlYWRlcnNcbiAgICAgIGZvciAodmFyIGkgaW4gcmVxSGVhZGVycykge1xuICAgICAgICB2YXIgaGVhZGVyID0gcmVxSGVhZGVyc1tpXVxuICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2ldID0gaGVhZGVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMZWdhY3k6IHRoaXMgc2hvdWxkIGJlIHNwZWNpZmllZCBhcyBgZXZlbnRTb3VyY2VJbml0RGljdC5odHRwcy5yZWplY3RVbmF1dGhvcml6ZWRgLFxuICAgIC8vIGJ1dCBmb3Igbm93IGV4aXN0cyBhcyBhIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGxheWVyXG4gICAgb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgPSAhKGV2ZW50U291cmNlSW5pdERpY3QgJiYgIWV2ZW50U291cmNlSW5pdERpY3QucmVqZWN0VW5hdXRob3JpemVkKVxuXG4gICAgaWYgKGV2ZW50U291cmNlSW5pdERpY3QgJiYgZXZlbnRTb3VyY2VJbml0RGljdC5jcmVhdGVDb25uZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuY3JlYXRlQ29ubmVjdGlvbiA9IGV2ZW50U291cmNlSW5pdERpY3QuY3JlYXRlQ29ubmVjdGlvblxuICAgIH1cblxuICAgIC8vIElmIHNwZWNpZnkgaHR0cCBwcm94eSwgbWFrZSB0aGUgcmVxdWVzdCB0byBzZW50IHRvIHRoZSBwcm94eSBzZXJ2ZXIsXG4gICAgLy8gYW5kIGluY2x1ZGUgdGhlIG9yaWdpbmFsIHVybCBpbiBwYXRoIGFuZCBIb3N0IGhlYWRlcnNcbiAgICB2YXIgdXNlUHJveHkgPSBldmVudFNvdXJjZUluaXREaWN0ICYmIGV2ZW50U291cmNlSW5pdERpY3QucHJveHlcbiAgICBpZiAodXNlUHJveHkpIHtcbiAgICAgIHZhciBwcm94eSA9IHBhcnNlKGV2ZW50U291cmNlSW5pdERpY3QucHJveHkpXG4gICAgICBpc1NlY3VyZSA9IHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6J1xuXG4gICAgICBvcHRpb25zLnByb3RvY29sID0gaXNTZWN1cmUgPyAnaHR0cHM6JyA6ICdodHRwOidcbiAgICAgIG9wdGlvbnMucGF0aCA9IHVybFxuICAgICAgb3B0aW9ucy5oZWFkZXJzLkhvc3QgPSBvcHRpb25zLmhvc3RcbiAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBwcm94eS5ob3N0bmFtZVxuICAgICAgb3B0aW9ucy5ob3N0ID0gcHJveHkuaG9zdFxuICAgICAgb3B0aW9ucy5wb3J0ID0gcHJveHkucG9ydFxuICAgIH1cblxuICAgIC8vIElmIGh0dHBzIG9wdGlvbnMgYXJlIHNwZWNpZmllZCwgbWVyZ2UgdGhlbSBpbnRvIHRoZSByZXF1ZXN0IG9wdGlvbnNcbiAgICBpZiAoZXZlbnRTb3VyY2VJbml0RGljdCAmJiBldmVudFNvdXJjZUluaXREaWN0Lmh0dHBzKSB7XG4gICAgICBmb3IgKHZhciBvcHROYW1lIGluIGV2ZW50U291cmNlSW5pdERpY3QuaHR0cHMpIHtcbiAgICAgICAgaWYgKGh0dHBzT3B0aW9ucy5pbmRleE9mKG9wdE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9uID0gZXZlbnRTb3VyY2VJbml0RGljdC5odHRwc1tvcHROYW1lXVxuICAgICAgICBpZiAob3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zW29wdE5hbWVdID0gb3B0aW9uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXNzIHRoaXMgb24gdG8gdGhlIFhIUlxuICAgIGlmIChldmVudFNvdXJjZUluaXREaWN0ICYmIGV2ZW50U291cmNlSW5pdERpY3Qud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMud2l0aENyZWRlbnRpYWxzID0gZXZlbnRTb3VyY2VJbml0RGljdC53aXRoQ3JlZGVudGlhbHNcbiAgICB9XG5cbiAgICByZXEgPSAoaXNTZWN1cmUgPyBodHRwcyA6IGh0dHApLnJlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24gKHJlcykge1xuICAgICAgc2VsZi5jb25uZWN0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlXG4gICAgICAvLyBIYW5kbGUgSFRUUCBlcnJvcnNcbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gNTAwIHx8IHJlcy5zdGF0dXNDb2RlID09PSA1MDIgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDUwMyB8fCByZXMuc3RhdHVzQ29kZSA9PT0gNTA0KSB7XG4gICAgICAgIF9lbWl0KCdlcnJvcicsIG5ldyBFdmVudCgnZXJyb3InLCB7c3RhdHVzOiByZXMuc3RhdHVzQ29kZSwgbWVzc2FnZTogcmVzLnN0YXR1c01lc3NhZ2V9KSlcbiAgICAgICAgb25Db25uZWN0aW9uQ2xvc2VkKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBIVFRQIHJlZGlyZWN0c1xuICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwMiB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMzA3KSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uXG4gICAgICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgICAgICAvLyBTZXJ2ZXIgc2VudCByZWRpcmVjdCByZXNwb25zZSB3aXRob3V0IExvY2F0aW9uIGhlYWRlci5cbiAgICAgICAgICBfZW1pdCgnZXJyb3InLCBuZXcgRXZlbnQoJ2Vycm9yJywge3N0YXR1czogcmVzLnN0YXR1c0NvZGUsIG1lc3NhZ2U6IHJlcy5zdGF0dXNNZXNzYWdlfSkpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZPcmlnaW4gPSBuZXcgVVJMKHVybCkub3JpZ2luXG4gICAgICAgIHZhciBuZXh0T3JpZ2luID0gbmV3IFVSTChsb2NhdGlvbikub3JpZ2luXG4gICAgICAgIGhhc05ld09yaWdpbiA9IHByZXZPcmlnaW4gIT09IG5leHRPcmlnaW5cbiAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAzMDcpIHJlY29ubmVjdFVybCA9IHVybFxuICAgICAgICB1cmwgPSBsb2NhdGlvblxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNvbm5lY3QpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAocmVzLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICBfZW1pdCgnZXJyb3InLCBuZXcgRXZlbnQoJ2Vycm9yJywge3N0YXR1czogcmVzLnN0YXR1c0NvZGUsIG1lc3NhZ2U6IHJlcy5zdGF0dXNNZXNzYWdlfSkpXG4gICAgICAgIHJldHVybiBzZWxmLmNsb3NlKClcbiAgICAgIH1cblxuICAgICAgcmVhZHlTdGF0ZSA9IEV2ZW50U291cmNlLk9QRU5cbiAgICAgIHJlcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJylcbiAgICAgICAgcmVzLnJlbW92ZUFsbExpc3RlbmVycygnZW5kJylcbiAgICAgICAgb25Db25uZWN0aW9uQ2xvc2VkKClcbiAgICAgIH0pXG5cbiAgICAgIHJlcy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpXG4gICAgICAgIHJlcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpXG4gICAgICAgIG9uQ29ubmVjdGlvbkNsb3NlZCgpXG4gICAgICB9KVxuICAgICAgX2VtaXQoJ29wZW4nLCBuZXcgRXZlbnQoJ29wZW4nKSlcblxuICAgICAgLy8gdGV4dC9ldmVudC1zdHJlYW0gcGFyc2VyIGFkYXB0ZWQgZnJvbSB3ZWJraXQnc1xuICAgICAgLy8gU291cmNlL1dlYkNvcmUvcGFnZS9FdmVudFNvdXJjZS5jcHBcbiAgICAgIHZhciBidWZcbiAgICAgIHZhciBuZXdCdWZmZXJcbiAgICAgIHZhciBzdGFydGluZ1BvcyA9IDBcbiAgICAgIHZhciBzdGFydGluZ0ZpZWxkTGVuZ3RoID0gLTFcbiAgICAgIHZhciBuZXdCdWZmZXJTaXplID0gMFxuICAgICAgdmFyIGJ5dGVzVXNlZCA9IDBcblxuICAgICAgcmVzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIGlmICghYnVmKSB7XG4gICAgICAgICAgYnVmID0gY2h1bmtcbiAgICAgICAgICBpZiAoaGFzQm9tKGJ1ZikpIHtcbiAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZShib20ubGVuZ3RoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBieXRlc1VzZWQgPSBidWYubGVuZ3RoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNodW5rLmxlbmd0aCA+IGJ1Zi5sZW5ndGggLSBieXRlc1VzZWQpIHtcbiAgICAgICAgICAgIG5ld0J1ZmZlclNpemUgPSAoYnVmLmxlbmd0aCAqIDIpICsgY2h1bmsubGVuZ3RoXG4gICAgICAgICAgICBpZiAobmV3QnVmZmVyU2l6ZSA+IG1heEJ1ZmZlckFoZWFkQWxsb2NhdGlvbikge1xuICAgICAgICAgICAgICBuZXdCdWZmZXJTaXplID0gYnVmLmxlbmd0aCArIGNodW5rLmxlbmd0aCArIG1heEJ1ZmZlckFoZWFkQWxsb2NhdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QnVmZmVyID0gQnVmZmVyLmFsbG9jKG5ld0J1ZmZlclNpemUpXG4gICAgICAgICAgICBidWYuY29weShuZXdCdWZmZXIsIDAsIDAsIGJ5dGVzVXNlZClcbiAgICAgICAgICAgIGJ1ZiA9IG5ld0J1ZmZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBjaHVuay5jb3B5KGJ1ZiwgYnl0ZXNVc2VkKVxuICAgICAgICAgIGJ5dGVzVXNlZCArPSBjaHVuay5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3MgPSAwXG4gICAgICAgIHZhciBsZW5ndGggPSBieXRlc1VzZWRcblxuICAgICAgICB3aGlsZSAocG9zIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGRpc2NhcmRUcmFpbGluZ05ld2xpbmUpIHtcbiAgICAgICAgICAgIGlmIChidWZbcG9zXSA9PT0gbGluZUZlZWQpIHtcbiAgICAgICAgICAgICAgKytwb3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gLTFcbiAgICAgICAgICB2YXIgZmllbGRMZW5ndGggPSBzdGFydGluZ0ZpZWxkTGVuZ3RoXG4gICAgICAgICAgdmFyIGNcblxuICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydGluZ1BvczsgbGluZUxlbmd0aCA8IDAgJiYgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjID0gYnVmW2ldXG4gICAgICAgICAgICBpZiAoYyA9PT0gY29sb24pIHtcbiAgICAgICAgICAgICAgaWYgKGZpZWxkTGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgICAgIGZpZWxkTGVuZ3RoID0gaSAtIHBvc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IGNhcnJpYWdlUmV0dXJuKSB7XG4gICAgICAgICAgICAgIGRpc2NhcmRUcmFpbGluZ05ld2xpbmUgPSB0cnVlXG4gICAgICAgICAgICAgIGxpbmVMZW5ndGggPSBpIC0gcG9zXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09IGxpbmVGZWVkKSB7XG4gICAgICAgICAgICAgIGxpbmVMZW5ndGggPSBpIC0gcG9zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxpbmVMZW5ndGggPCAwKSB7XG4gICAgICAgICAgICBzdGFydGluZ1BvcyA9IGxlbmd0aCAtIHBvc1xuICAgICAgICAgICAgc3RhcnRpbmdGaWVsZExlbmd0aCA9IGZpZWxkTGVuZ3RoXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydGluZ1BvcyA9IDBcbiAgICAgICAgICAgIHN0YXJ0aW5nRmllbGRMZW5ndGggPSAtMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnNlRXZlbnRTdHJlYW1MaW5lKGJ1ZiwgcG9zLCBmaWVsZExlbmd0aCwgbGluZUxlbmd0aClcblxuICAgICAgICAgIHBvcyArPSBsaW5lTGVuZ3RoICsgMVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvcyA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgYnVmID0gdm9pZCAwXG4gICAgICAgICAgYnl0ZXNVc2VkID0gMFxuICAgICAgICB9IGVsc2UgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgICBidWYgPSBidWYuc2xpY2UocG9zLCBieXRlc1VzZWQpXG4gICAgICAgICAgYnl0ZXNVc2VkID0gYnVmLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgc2VsZi5jb25uZWN0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlXG4gICAgICBvbkNvbm5lY3Rpb25DbG9zZWQoZXJyLm1lc3NhZ2UpXG4gICAgfSlcblxuICAgIGlmIChyZXEuc2V0Tm9EZWxheSkgcmVxLnNldE5vRGVsYXkodHJ1ZSlcbiAgICByZXEuZW5kKClcbiAgfVxuXG4gIGNvbm5lY3QoKVxuXG4gIGZ1bmN0aW9uIF9lbWl0ICgpIHtcbiAgICBpZiAoc2VsZi5saXN0ZW5lcnMoYXJndW1lbnRzWzBdKS5sZW5ndGggPiAwKSB7XG4gICAgICBzZWxmLmVtaXQuYXBwbHkoc2VsZiwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZWFkeVN0YXRlID09PSBFdmVudFNvdXJjZS5DTE9TRUQpIHJldHVyblxuICAgIHJlYWR5U3RhdGUgPSBFdmVudFNvdXJjZS5DTE9TRURcbiAgICBpZiAocmVxLmFib3J0KSByZXEuYWJvcnQoKVxuICAgIGlmIChyZXEueGhyICYmIHJlcS54aHIuYWJvcnQpIHJlcS54aHIuYWJvcnQoKVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFdmVudFN0cmVhbUxpbmUgKGJ1ZiwgcG9zLCBmaWVsZExlbmd0aCwgbGluZUxlbmd0aCkge1xuICAgIGlmIChsaW5lTGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0eXBlID0gZXZlbnROYW1lIHx8ICdtZXNzYWdlJ1xuICAgICAgICBfZW1pdCh0eXBlLCBuZXcgTWVzc2FnZUV2ZW50KHR5cGUsIHtcbiAgICAgICAgICBkYXRhOiBkYXRhLnNsaWNlKDAsIC0xKSwgLy8gcmVtb3ZlIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgICAgICBsYXN0RXZlbnRJZDogbGFzdEV2ZW50SWQsXG4gICAgICAgICAgb3JpZ2luOiBuZXcgVVJMKHVybCkub3JpZ2luXG4gICAgICAgIH0pKVxuICAgICAgICBkYXRhID0gJydcbiAgICAgIH1cbiAgICAgIGV2ZW50TmFtZSA9IHZvaWQgMFxuICAgIH0gZWxzZSBpZiAoZmllbGRMZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbm9WYWx1ZSA9IGZpZWxkTGVuZ3RoIDwgMFxuICAgICAgdmFyIHN0ZXAgPSAwXG4gICAgICB2YXIgZmllbGQgPSBidWYuc2xpY2UocG9zLCBwb3MgKyAobm9WYWx1ZSA/IGxpbmVMZW5ndGggOiBmaWVsZExlbmd0aCkpLnRvU3RyaW5nKClcblxuICAgICAgaWYgKG5vVmFsdWUpIHtcbiAgICAgICAgc3RlcCA9IGxpbmVMZW5ndGhcbiAgICAgIH0gZWxzZSBpZiAoYnVmW3BvcyArIGZpZWxkTGVuZ3RoICsgMV0gIT09IHNwYWNlKSB7XG4gICAgICAgIHN0ZXAgPSBmaWVsZExlbmd0aCArIDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAgPSBmaWVsZExlbmd0aCArIDJcbiAgICAgIH1cbiAgICAgIHBvcyArPSBzdGVwXG5cbiAgICAgIHZhciB2YWx1ZUxlbmd0aCA9IGxpbmVMZW5ndGggLSBzdGVwXG4gICAgICB2YXIgdmFsdWUgPSBidWYuc2xpY2UocG9zLCBwb3MgKyB2YWx1ZUxlbmd0aCkudG9TdHJpbmcoKVxuXG4gICAgICBpZiAoZmllbGQgPT09ICdkYXRhJykge1xuICAgICAgICBkYXRhICs9IHZhbHVlICsgJ1xcbidcbiAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdldmVudCcpIHtcbiAgICAgICAgZXZlbnROYW1lID0gdmFsdWVcbiAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdpZCcpIHtcbiAgICAgICAgbGFzdEV2ZW50SWQgPSB2YWx1ZVxuICAgICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gJ3JldHJ5Jykge1xuICAgICAgICB2YXIgcmV0cnkgPSBwYXJzZUludCh2YWx1ZSwgMTApXG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHJldHJ5KSkge1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0SW50ZXJ2YWwgPSByZXRyeVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VcblxudXRpbC5pbmhlcml0cyhFdmVudFNvdXJjZSwgZXZlbnRzLkV2ZW50RW1pdHRlcilcbkV2ZW50U291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50U291cmNlOyAvLyBtYWtlIHN0YWNrdHJhY2VzIHJlYWRhYmxlXG5cblsnb3BlbicsICdlcnJvcicsICdtZXNzYWdlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZS5wcm90b3R5cGUsICdvbicgKyBtZXRob2QsIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxpc3RlbmVyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNaXhlZH0gdGhlIHNldCBmdW5jdGlvbiBvciB1bmRlZmluZWRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmxpc3RlbmVycyhtZXRob2QpWzBdXG4gICAgICByZXR1cm4gbGlzdGVuZXIgPyAobGlzdGVuZXIuX2xpc3RlbmVyID8gbGlzdGVuZXIuX2xpc3RlbmVyIDogbGlzdGVuZXIpIDogdW5kZWZpbmVkXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtNaXhlZH0gdGhlIHNldCBmdW5jdGlvbiBvciB1bmRlZmluZWRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCAobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKG1ldGhvZClcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKVxuICAgIH1cbiAgfSlcbn0pXG5cbi8qKlxuICogUmVhZHkgc3RhdGVzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZSwgJ0NPTk5FQ1RJTkcnLCB7ZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IDB9KVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50U291cmNlLCAnT1BFTicsIHtlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogMX0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRTb3VyY2UsICdDTE9TRUQnLCB7ZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IDJ9KVxuXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuQ09OTkVDVElORyA9IDBcbkV2ZW50U291cmNlLnByb3RvdHlwZS5PUEVOID0gMVxuRXZlbnRTb3VyY2UucHJvdG90eXBlLkNMT1NFRCA9IDJcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24sIGlmIG9uZSBpcyBtYWRlLCBhbmQgc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gMiAoY2xvc2VkKVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50U291cmNlL2Nsb3NlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5FdmVudFNvdXJjZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2Nsb3NlKClcbn1cblxuLyoqXG4gKiBFbXVsYXRlcyB0aGUgVzNDIEJyb3dzZXIgYmFzZWQgV2ViU29ja2V0IGludGVyZmFjZSB1c2luZyBhZGRFdmVudExpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gb3V0IGZvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgY2FsbGJhY2tcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lclxuICogQHNlZSBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuRXZlbnRTb3VyY2UucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyICh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gc3RvcmUgYSByZWZlcmVuY2Ugc28gd2UgY2FuIHJldHVybiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gYWdhaW5cbiAgICBsaXN0ZW5lci5fbGlzdGVuZXIgPSBsaXN0ZW5lclxuICAgIHRoaXMub24odHlwZSwgbGlzdGVuZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBFbXVsYXRlcyB0aGUgVzNDIEJyb3dzZXIgYmFzZWQgV2ViU29ja2V0IGludGVyZmFjZSB1c2luZyBkaXNwYXRjaEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEFuIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWRcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2Rpc3BhdGNoRXZlbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50U291cmNlLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCAoZXZlbnQpIHtcbiAgaWYgKCFldmVudC50eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVTlNQRUNJRklFRF9FVkVOVF9UWVBFX0VSUicpXG4gIH1cbiAgLy8gaWYgZXZlbnQgaXMgaW5zdGFuY2Ugb2YgYW4gQ3VzdG9tRXZlbnQgKG9yIGhhcyAnZGV0YWlscycgcHJvcGVydHkpLFxuICAvLyBzZW5kIHRoZSBkZXRhaWwgb2JqZWN0IGFzIHRoZSBwYXlsb2FkIGZvciB0aGUgZXZlbnRcbiAgdGhpcy5lbWl0KGV2ZW50LnR5cGUsIGV2ZW50LmRldGFpbClcbn1cblxuLyoqXG4gKiBFbXVsYXRlcyB0aGUgVzNDIEJyb3dzZXIgYmFzZWQgV2ViU29ja2V0IGludGVyZmFjZSB1c2luZyByZW1vdmVFdmVudExpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIGNhbGxiYWNrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXJcbiAqIEBzZWUgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cbkV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lciAodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3RlbmVyLl9saXN0ZW5lciA9IHVuZGVmaW5lZFxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBXM0MgRXZlbnRcbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jaW50ZXJmYWNlLUV2ZW50XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnQgKHR5cGUsIG9wdGlvbmFsUHJvcGVydGllcykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7IHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IHRydWUgfSlcbiAgaWYgKG9wdGlvbmFsUHJvcGVydGllcykge1xuICAgIGZvciAodmFyIGYgaW4gb3B0aW9uYWxQcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAob3B0aW9uYWxQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGYpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBmLCB7IHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IG9wdGlvbmFsUHJvcGVydGllc1tmXSwgZW51bWVyYWJsZTogdHJ1ZSB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFczQyBNZXNzYWdlRXZlbnRcbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3dlYm1lc3NhZ2luZy8jZXZlbnQtZGVmaW5pdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBNZXNzYWdlRXZlbnQgKHR5cGUsIGV2ZW50SW5pdERpY3QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywgeyB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiB0cnVlIH0pXG4gIGZvciAodmFyIGYgaW4gZXZlbnRJbml0RGljdCkge1xuICAgIGlmIChldmVudEluaXREaWN0Lmhhc093blByb3BlcnR5KGYpKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgZiwgeyB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBldmVudEluaXREaWN0W2ZdLCBlbnVtZXJhYmxlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvYmplY3Qgb2YgaGVhZGVycyB0aGF0IGRvZXMgbm90IGluY2x1ZGUgYW55IGF1dGhvcml6YXRpb24gYW5kIGNvb2tpZSBoZWFkZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgQW4gb2JqZWN0IG9mIGhlYWRlcnMgKHtbaGVhZGVyTmFtZV06IGhlYWRlclZhbHVlfSlcbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IG9mIGhlYWRlcnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVVbnNhZmVIZWFkZXJzIChoZWFkZXJzKSB7XG4gIHZhciBzYWZlID0ge31cbiAgZm9yICh2YXIga2V5IGluIGhlYWRlcnMpIHtcbiAgICBpZiAocmVVbnNhZmVIZWFkZXIudGVzdChrZXkpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHNhZmVba2V5XSA9IGhlYWRlcnNba2V5XVxuICB9XG5cbiAgcmV0dXJuIHNhZmVcbn1cbiJdLCJuYW1lcyI6WyJwYXJzZSIsInJlcXVpcmUiLCJldmVudHMiLCJodHRwcyIsImh0dHAiLCJ1dGlsIiwiaHR0cHNPcHRpb25zIiwiYm9tIiwiY29sb24iLCJzcGFjZSIsImxpbmVGZWVkIiwiY2FycmlhZ2VSZXR1cm4iLCJtYXhCdWZmZXJBaGVhZEFsbG9jYXRpb24iLCJyZVVuc2FmZUhlYWRlciIsImhhc0JvbSIsImJ1ZiIsImV2ZXJ5IiwiY2hhckNvZGUiLCJpbmRleCIsIkV2ZW50U291cmNlIiwidXJsIiwiZXZlbnRTb3VyY2VJbml0RGljdCIsInJlYWR5U3RhdGUiLCJDT05ORUNUSU5HIiwiaGVhZGVycyIsImhhc05ld09yaWdpbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic2VsZiIsInJlY29ubmVjdEludGVydmFsIiwiY29ubmVjdGlvbkluUHJvZ3Jlc3MiLCJvbkNvbm5lY3Rpb25DbG9zZWQiLCJtZXNzYWdlIiwiQ0xPU0VEIiwiX2VtaXQiLCJFdmVudCIsInJlY29ubmVjdFVybCIsInNldFRpbWVvdXQiLCJjb25uZWN0IiwicmVxIiwibGFzdEV2ZW50SWQiLCJkaXNjYXJkVHJhaWxpbmdOZXdsaW5lIiwiZGF0YSIsImV2ZW50TmFtZSIsIm9wdGlvbnMiLCJpc1NlY3VyZSIsInByb3RvY29sIiwicmVxSGVhZGVycyIsInJlbW92ZVVuc2FmZUhlYWRlcnMiLCJpIiwiaGVhZGVyIiwicmVqZWN0VW5hdXRob3JpemVkIiwiY3JlYXRlQ29ubmVjdGlvbiIsInVuZGVmaW5lZCIsInVzZVByb3h5IiwicHJveHkiLCJwYXRoIiwiSG9zdCIsImhvc3QiLCJob3N0bmFtZSIsInBvcnQiLCJvcHROYW1lIiwiaW5kZXhPZiIsIm9wdGlvbiIsIndpdGhDcmVkZW50aWFscyIsInJlcXVlc3QiLCJyZXMiLCJzdGF0dXNDb2RlIiwic3RhdHVzIiwic3RhdHVzTWVzc2FnZSIsImxvY2F0aW9uIiwicHJldk9yaWdpbiIsIlVSTCIsIm9yaWdpbiIsIm5leHRPcmlnaW4iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjbG9zZSIsIk9QRU4iLCJvbiIsInJlbW92ZUFsbExpc3RlbmVycyIsIm5ld0J1ZmZlciIsInN0YXJ0aW5nUG9zIiwic3RhcnRpbmdGaWVsZExlbmd0aCIsIm5ld0J1ZmZlclNpemUiLCJieXRlc1VzZWQiLCJjaHVuayIsInNsaWNlIiwibGVuZ3RoIiwiQnVmZmVyIiwiYWxsb2MiLCJjb3B5IiwicG9zIiwibGluZUxlbmd0aCIsImZpZWxkTGVuZ3RoIiwiYyIsInBhcnNlRXZlbnRTdHJlYW1MaW5lIiwiZXJyIiwic2V0Tm9EZWxheSIsImVuZCIsImxpc3RlbmVycyIsImFyZ3VtZW50cyIsImVtaXQiLCJhcHBseSIsIl9jbG9zZSIsImFib3J0IiwieGhyIiwidHlwZSIsIk1lc3NhZ2VFdmVudCIsIm5vVmFsdWUiLCJzdGVwIiwiZmllbGQiLCJ0b1N0cmluZyIsInZhbHVlTGVuZ3RoIiwidmFsdWUiLCJyZXRyeSIsInBhcnNlSW50IiwiTnVtYmVyIiwiaXNOYU4iLCJtb2R1bGUiLCJleHBvcnRzIiwiaW5oZXJpdHMiLCJFdmVudEVtaXR0ZXIiLCJwcm90b3R5cGUiLCJjb25zdHJ1Y3RvciIsImZvckVhY2giLCJtZXRob2QiLCJsaXN0ZW5lciIsIl9saXN0ZW5lciIsInNldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlbnVtZXJhYmxlIiwiZGlzcGF0Y2hFdmVudCIsImV2ZW50IiwiRXJyb3IiLCJkZXRhaWwiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJvcHRpb25hbFByb3BlcnRpZXMiLCJ3cml0YWJsZSIsImYiLCJoYXNPd25Qcm9wZXJ0eSIsImV2ZW50SW5pdERpY3QiLCJzYWZlIiwia2V5IiwidGVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/eventsource/lib/eventsource.js\n");

/***/ })

};
;