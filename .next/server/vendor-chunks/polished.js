"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polished";
exports.ids = ["vendor-chunks/polished"];
exports.modules = {

/***/ "(ssr)/./node_modules/polished/dist/polished.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/polished/dist/polished.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adjustHue: () => (/* binding */ curriedAdjustHue$1),\n/* harmony export */   animation: () => (/* binding */ animation),\n/* harmony export */   backgroundImages: () => (/* binding */ backgroundImages),\n/* harmony export */   backgrounds: () => (/* binding */ backgrounds),\n/* harmony export */   between: () => (/* binding */ between),\n/* harmony export */   border: () => (/* binding */ border),\n/* harmony export */   borderColor: () => (/* binding */ borderColor),\n/* harmony export */   borderRadius: () => (/* binding */ borderRadius),\n/* harmony export */   borderStyle: () => (/* binding */ borderStyle),\n/* harmony export */   borderWidth: () => (/* binding */ borderWidth),\n/* harmony export */   buttons: () => (/* binding */ buttons),\n/* harmony export */   clearFix: () => (/* binding */ clearFix),\n/* harmony export */   complement: () => (/* binding */ complement),\n/* harmony export */   cover: () => (/* binding */ cover),\n/* harmony export */   cssVar: () => (/* binding */ cssVar),\n/* harmony export */   darken: () => (/* binding */ curriedDarken$1),\n/* harmony export */   desaturate: () => (/* binding */ curriedDesaturate$1),\n/* harmony export */   directionalProperty: () => (/* binding */ directionalProperty),\n/* harmony export */   easeIn: () => (/* binding */ easeIn),\n/* harmony export */   easeInOut: () => (/* binding */ easeInOut),\n/* harmony export */   easeOut: () => (/* binding */ easeOut),\n/* harmony export */   ellipsis: () => (/* binding */ ellipsis),\n/* harmony export */   em: () => (/* binding */ em$1),\n/* harmony export */   fluidRange: () => (/* binding */ fluidRange),\n/* harmony export */   fontFace: () => (/* binding */ fontFace),\n/* harmony export */   getContrast: () => (/* binding */ getContrast),\n/* harmony export */   getLuminance: () => (/* binding */ getLuminance),\n/* harmony export */   getValueAndUnit: () => (/* binding */ getValueAndUnit),\n/* harmony export */   grayscale: () => (/* binding */ grayscale),\n/* harmony export */   hiDPI: () => (/* binding */ hiDPI),\n/* harmony export */   hideText: () => (/* binding */ hideText),\n/* harmony export */   hideVisually: () => (/* binding */ hideVisually),\n/* harmony export */   hsl: () => (/* binding */ hsl),\n/* harmony export */   hslToColorString: () => (/* binding */ hslToColorString),\n/* harmony export */   hsla: () => (/* binding */ hsla),\n/* harmony export */   important: () => (/* binding */ important),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   lighten: () => (/* binding */ curriedLighten$1),\n/* harmony export */   linearGradient: () => (/* binding */ linearGradient),\n/* harmony export */   margin: () => (/* binding */ margin),\n/* harmony export */   math: () => (/* binding */ math),\n/* harmony export */   meetsContrastGuidelines: () => (/* binding */ meetsContrastGuidelines),\n/* harmony export */   mix: () => (/* binding */ mix$1),\n/* harmony export */   modularScale: () => (/* binding */ modularScale),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   opacify: () => (/* binding */ curriedOpacify$1),\n/* harmony export */   padding: () => (/* binding */ padding),\n/* harmony export */   parseToHsl: () => (/* binding */ parseToHsl),\n/* harmony export */   parseToRgb: () => (/* binding */ parseToRgb),\n/* harmony export */   position: () => (/* binding */ position),\n/* harmony export */   radialGradient: () => (/* binding */ radialGradient),\n/* harmony export */   readableColor: () => (/* binding */ readableColor),\n/* harmony export */   rem: () => (/* binding */ rem$1),\n/* harmony export */   remToPx: () => (/* binding */ remToPx),\n/* harmony export */   retinaImage: () => (/* binding */ retinaImage),\n/* harmony export */   rgb: () => (/* binding */ rgb),\n/* harmony export */   rgbToColorString: () => (/* binding */ rgbToColorString),\n/* harmony export */   rgba: () => (/* binding */ rgba),\n/* harmony export */   saturate: () => (/* binding */ curriedSaturate$1),\n/* harmony export */   setHue: () => (/* binding */ curriedSetHue$1),\n/* harmony export */   setLightness: () => (/* binding */ curriedSetLightness$1),\n/* harmony export */   setSaturation: () => (/* binding */ curriedSetSaturation$1),\n/* harmony export */   shade: () => (/* binding */ curriedShade$1),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   stripUnit: () => (/* binding */ stripUnit),\n/* harmony export */   textInputs: () => (/* binding */ textInputs),\n/* harmony export */   timingFunctions: () => (/* binding */ timingFunctions),\n/* harmony export */   tint: () => (/* binding */ curriedTint$1),\n/* harmony export */   toColorString: () => (/* binding */ toColorString),\n/* harmony export */   transitions: () => (/* binding */ transitions),\n/* harmony export */   transparentize: () => (/* binding */ curriedTransparentize$1),\n/* harmony export */   triangle: () => (/* binding */ triangle),\n/* harmony export */   wordWrap: () => (/* binding */ wordWrap)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/wrapNativeSuper */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/taggedTemplateLiteralLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js\");\n\n\n\n\n\nfunction last() {\n    var _ref;\n    return _ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref];\n}\nfunction negation(a) {\n    return -a;\n}\nfunction addition(a, b) {\n    return a + b;\n}\nfunction subtraction(a, b) {\n    return a - b;\n}\nfunction multiplication(a, b) {\n    return a * b;\n}\nfunction division(a, b) {\n    return a / b;\n}\nfunction max() {\n    return Math.max.apply(Math, arguments);\n}\nfunction min() {\n    return Math.min.apply(Math, arguments);\n}\nfunction comma() {\n    return Array.of.apply(Array, arguments);\n}\nvar defaultSymbols = {\n    symbols: {\n        \"*\": {\n            infix: {\n                symbol: \"*\",\n                f: multiplication,\n                notation: \"infix\",\n                precedence: 4,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \"*\",\n            regSymbol: \"\\\\*\"\n        },\n        \"/\": {\n            infix: {\n                symbol: \"/\",\n                f: division,\n                notation: \"infix\",\n                precedence: 4,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \"/\",\n            regSymbol: \"/\"\n        },\n        \"+\": {\n            infix: {\n                symbol: \"+\",\n                f: addition,\n                notation: \"infix\",\n                precedence: 2,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            prefix: {\n                symbol: \"+\",\n                f: last,\n                notation: \"prefix\",\n                precedence: 3,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"+\",\n            regSymbol: \"\\\\+\"\n        },\n        \"-\": {\n            infix: {\n                symbol: \"-\",\n                f: subtraction,\n                notation: \"infix\",\n                precedence: 2,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            prefix: {\n                symbol: \"-\",\n                f: negation,\n                notation: \"prefix\",\n                precedence: 3,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"-\",\n            regSymbol: \"-\"\n        },\n        \",\": {\n            infix: {\n                symbol: \",\",\n                f: comma,\n                notation: \"infix\",\n                precedence: 1,\n                rightToLeft: 0,\n                argCount: 2\n            },\n            symbol: \",\",\n            regSymbol: \",\"\n        },\n        \"(\": {\n            prefix: {\n                symbol: \"(\",\n                f: last,\n                notation: \"prefix\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"(\",\n            regSymbol: \"\\\\(\"\n        },\n        \")\": {\n            postfix: {\n                symbol: \")\",\n                f: undefined,\n                notation: \"postfix\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \")\",\n            regSymbol: \"\\\\)\"\n        },\n        min: {\n            func: {\n                symbol: \"min\",\n                f: min,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"min\",\n            regSymbol: \"min\\\\b\"\n        },\n        max: {\n            func: {\n                symbol: \"max\",\n                f: max,\n                notation: \"func\",\n                precedence: 0,\n                rightToLeft: 0,\n                argCount: 1\n            },\n            symbol: \"max\",\n            regSymbol: \"max\\\\b\"\n        }\n    }\n};\nvar defaultSymbolMap = defaultSymbols;\n// based on https://github.com/styled-components/styled-components/blob/fcf6f3804c57a14dd7984dfab7bc06ee2edca044/src/utils/error.js\n/**\n * Parse errors.md and turn it into a simple hash of code: message\n * @private\n */ var ERRORS = {\n    \"1\": \"Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\\n\\n\",\n    \"2\": \"Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\\n\\n\",\n    \"3\": \"Passed an incorrect argument to a color function, please pass a string representation of a color.\\n\\n\",\n    \"4\": \"Couldn't generate valid rgb string from %s, it returned %s.\\n\\n\",\n    \"5\": \"Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\\n\\n\",\n    \"6\": \"Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\\n\\n\",\n    \"7\": \"Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\\n\\n\",\n    \"8\": \"Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\\n\\n\",\n    \"9\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n    \"10\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n    \"11\": 'Invalid value passed as base to modularScale, expected number or em string but got \"%s\"\\n\\n',\n    \"12\": 'Expected a string ending in \"px\" or a number passed as the first argument to %s(), got \"%s\" instead.\\n\\n',\n    \"13\": 'Expected a string ending in \"px\" or a number passed as the second argument to %s(), got \"%s\" instead.\\n\\n',\n    \"14\": 'Passed invalid pixel value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"15\": 'Passed invalid base value (\"%s\") to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"16\": \"You must provide a template to this method.\\n\\n\",\n    \"17\": \"You passed an unsupported selector state to this method.\\n\\n\",\n    \"18\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n    \"19\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n    \"20\": \"expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n    \"21\": \"expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n    \"22\": \"expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\\n\\n\",\n    \"23\": \"fontFace expects a name of a font-family.\\n\\n\",\n    \"24\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n    \"25\": \"fontFace expects localFonts to be an array.\\n\\n\",\n    \"26\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n    \"27\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"28\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n    \"29\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n    \"30\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n    \"31\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\\n\\n\",\n    \"32\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\\n\\n\",\n    \"33\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\\n\\n\",\n    \"34\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n    \"35\": 'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n    \"36\": \"Property must be a string value.\\n\\n\",\n    \"37\": \"Syntax Error at %s.\\n\\n\",\n    \"38\": \"Formula contains a function that needs parentheses at %s.\\n\\n\",\n    \"39\": \"Formula is missing closing parenthesis at %s.\\n\\n\",\n    \"40\": \"Formula has too many closing parentheses at %s.\\n\\n\",\n    \"41\": \"All values in a formula must have the same unit or be unitless.\\n\\n\",\n    \"42\": \"Please provide a number of steps to the modularScale helper.\\n\\n\",\n    \"43\": \"Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\\n\\n\",\n    \"44\": \"Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\\n\\n\",\n    \"45\": \"Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\\n\\n\",\n    \"46\": \"Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\\n\\n\",\n    \"47\": \"minScreen and maxScreen must be provided as stringified numbers with the same units.\\n\\n\",\n    \"48\": \"fromSize and toSize must be provided as stringified numbers with the same units.\\n\\n\",\n    \"49\": \"Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\\n\\n\",\n    \"50\": \"Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\\n\\n\",\n    \"51\": \"Expects the first argument object to have the properties prop, fromSize, and toSize.\\n\\n\",\n    \"52\": \"fontFace expects either the path to the font file(s) or a name of a local copy.\\n\\n\",\n    \"53\": \"fontFace expects localFonts to be an array.\\n\\n\",\n    \"54\": \"fontFace expects fileFormats to be an array.\\n\\n\",\n    \"55\": \"fontFace expects a name of a font-family.\\n\\n\",\n    \"56\": \"linearGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"57\": \"radialGradient requries at least 2 color-stops to properly render.\\n\\n\",\n    \"58\": \"Please supply a filename to retinaImage() as the first argument.\\n\\n\",\n    \"59\": \"Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\\n\\n\",\n    \"60\": \"Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\\n\\n\",\n    \"61\": \"Property must be a string value.\\n\\n\",\n    \"62\": \"borderRadius expects a radius value as a string or number as the second argument.\\n\\n\",\n    \"63\": 'borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.\\n\\n',\n    \"64\": \"The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n    \"65\": \"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\\n\\n\",\n    \"66\": \"The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\\n\\n\",\n    \"67\": \"You must provide a template to this method.\\n\\n\",\n    \"68\": \"You passed an unsupported selector state to this method.\\n\\n\",\n    \"69\": 'Expected a string ending in \"px\" or a number passed as the first argument to %s(), got %s instead.\\n\\n',\n    \"70\": 'Expected a string ending in \"px\" or a number passed as the second argument to %s(), got %s instead.\\n\\n',\n    \"71\": 'Passed invalid pixel value %s to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"72\": 'Passed invalid base value %s to %s(), please pass a value like \"12px\" or 12.\\n\\n',\n    \"73\": \"Please provide a valid CSS variable.\\n\\n\",\n    \"74\": \"CSS variable not found and no default was provided.\\n\\n\",\n    \"75\": \"important requires a valid style object, got a %s instead.\\n\\n\",\n    \"76\": \"fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\\n\\n\",\n    \"77\": 'remToPx expects a value in \"rem\" but you provided it in \"%s\".\\n\\n',\n    \"78\": 'base must be set in \"px\" or \"%\" but you set it in \"%s\".\\n'\n};\n/**\n * super basic version of sprintf\n * @private\n */ function format() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    var a = args[0];\n    var b = [];\n    var c;\n    for(c = 1; c < args.length; c += 1){\n        b.push(args[c]);\n    }\n    b.forEach(function(d) {\n        a = a.replace(/%[a-z]/, d);\n    });\n    return a;\n}\n/**\n * Create an error file out of errors.md for development and a simple web link to the full errors\n * in production mode.\n * @private\n */ var PolishedError = /*#__PURE__*/ function(_Error) {\n    (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(PolishedError, _Error);\n    function PolishedError(code) {\n        var _this;\n        if (false) {} else {\n            for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                args[_key2 - 1] = arguments[_key2];\n            }\n            _this = _Error.call(this, format.apply(void 0, [\n                ERRORS[code]\n            ].concat(args))) || this;\n        }\n        return (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this);\n    }\n    return PolishedError;\n}(/*#__PURE__*/ (0,_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(Error));\nvar unitRegExp = /((?!\\w)a|na|hc|mc|dg|me[r]?|xe|ni(?![a-zA-Z])|mm|cp|tp|xp|q(?!s)|hv|xamv|nimv|wv|sm|s(?!\\D|$)|ged|darg?|nrut)/g;\n// Merges additional math functionality into the defaults.\nfunction mergeSymbolMaps(additionalSymbols) {\n    var symbolMap = {};\n    symbolMap.symbols = additionalSymbols ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultSymbolMap.symbols, additionalSymbols.symbols) : (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, defaultSymbolMap.symbols);\n    return symbolMap;\n}\nfunction exec(operators, values) {\n    var _ref;\n    var op = operators.pop();\n    values.push(op.f.apply(op, (_ref = []).concat.apply(_ref, values.splice(-op.argCount))));\n    return op.precedence;\n}\nfunction calculate(expression, additionalSymbols) {\n    var symbolMap = mergeSymbolMaps(additionalSymbols);\n    var match;\n    var operators = [\n        symbolMap.symbols[\"(\"].prefix\n    ];\n    var values = [];\n    var pattern = new RegExp(\"\\\\d+(?:\\\\.\\\\d+)?|\" + // ...and patterns for individual operators/function names\n    Object.keys(symbolMap.symbols).map(function(key) {\n        return symbolMap.symbols[key];\n    })// longer symbols should be listed first\n    // $FlowFixMe\n    .sort(function(a, b) {\n        return b.symbol.length - a.symbol.length;\n    })// $FlowFixMe\n    .map(function(val) {\n        return val.regSymbol;\n    }).join(\"|\") + \"|(\\\\S)\", \"g\");\n    pattern.lastIndex = 0; // Reset regular expression object\n    var afterValue = false;\n    do {\n        match = pattern.exec(expression);\n        var _ref2 = match || [\n            \")\",\n            undefined\n        ], token = _ref2[0], bad = _ref2[1];\n        var notNumber = symbolMap.symbols[token];\n        var notNewValue = notNumber && !notNumber.prefix && !notNumber.func;\n        var notAfterValue = !notNumber || !notNumber.postfix && !notNumber.infix;\n        // Check for syntax errors:\n        if (bad || (afterValue ? notAfterValue : notNewValue)) {\n            throw new PolishedError(37, match ? match.index : expression.length, expression);\n        }\n        if (afterValue) {\n            // We either have an infix or postfix operator (they should be mutually exclusive)\n            var curr = notNumber.postfix || notNumber.infix;\n            do {\n                var prev = operators[operators.length - 1];\n                if ((curr.precedence - prev.precedence || prev.rightToLeft) > 0) break;\n            // Apply previous operator, since it has precedence over current one\n            }while (exec(operators, values)); // Exit loop after executing an opening parenthesis or function\n            afterValue = curr.notation === \"postfix\";\n            if (curr.symbol !== \")\") {\n                operators.push(curr);\n                // Postfix always has precedence over any operator that follows after it\n                if (afterValue) exec(operators, values);\n            }\n        } else if (notNumber) {\n            // prefix operator or function\n            operators.push(notNumber.prefix || notNumber.func);\n            if (notNumber.func) {\n                // Require an opening parenthesis\n                match = pattern.exec(expression);\n                if (!match || match[0] !== \"(\") {\n                    throw new PolishedError(38, match ? match.index : expression.length, expression);\n                }\n            }\n        } else {\n            // number\n            values.push(+token);\n            afterValue = true;\n        }\n    }while (match && operators.length);\n    if (operators.length) {\n        throw new PolishedError(39, match ? match.index : expression.length, expression);\n    } else if (match) {\n        throw new PolishedError(40, match ? match.index : expression.length, expression);\n    } else {\n        return values.pop();\n    }\n}\nfunction reverseString(str) {\n    return str.split(\"\").reverse().join(\"\");\n}\n/**\n * Helper for doing math with CSS Units. Accepts a formula as a string. All values in the formula must have the same unit (or be unitless). Supports complex formulas utliziing addition, subtraction, multiplication, division, square root, powers, factorial, min, max, as well as parentheses for order of operation.\n *\n *In cases where you need to do calculations with mixed units where one unit is a [relative length unit](https://developer.mozilla.org/en-US/docs/Web/CSS/length#Relative_length_units), you will want to use [CSS Calc](https://developer.mozilla.org/en-US/docs/Web/CSS/calc).\n *\n * *warning* While we've done everything possible to ensure math safely evalutes formulas expressed as strings, you should always use extreme caution when passing `math` user provided values.\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: math('12rem + 8rem'),\n *   fontSize: math('(12px + 2px) * 3'),\n *   fontSize: math('3px^2 + sqrt(4)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${math('12rem + 8rem')};\n *   fontSize: ${math('(12px + 2px) * 3')};\n *   fontSize: ${math('3px^2 + sqrt(4)')};\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   fontSize: '20rem',\n *   fontSize: '42px',\n *   fontSize: '11px',\n * }\n */ function math(formula, additionalSymbols) {\n    var reversedFormula = reverseString(formula);\n    var formulaMatch = reversedFormula.match(unitRegExp);\n    // Check that all units are the same\n    if (formulaMatch && !formulaMatch.every(function(unit) {\n        return unit === formulaMatch[0];\n    })) {\n        throw new PolishedError(41);\n    }\n    var cleanFormula = reverseString(reversedFormula.replace(unitRegExp, \"\"));\n    return \"\" + calculate(cleanFormula, additionalSymbols) + (formulaMatch ? reverseString(formulaMatch[0]) : \"\");\n}\nvar cssVariableRegex = /--[\\S]*/g;\n/**\n * Fetches the value of a passed CSS Variable in the :root scope, or otherwise returns a defaultValue if provided.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'background': cssVar('--background-color'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${cssVar('--background-color')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'background': 'red'\n * }\n */ function cssVar(cssVariable, defaultValue) {\n    if (!cssVariable || !cssVariable.match(cssVariableRegex)) {\n        throw new PolishedError(73);\n    }\n    var variableValue;\n    /* eslint-disable */ /* istanbul ignore next */ if (typeof document !== \"undefined\" && document.documentElement !== null) {\n        variableValue = getComputedStyle(document.documentElement).getPropertyValue(cssVariable);\n    }\n    /* eslint-enable */ if (variableValue) {\n        return variableValue.trim();\n    } else if (defaultValue) {\n        return defaultValue;\n    }\n    throw new PolishedError(74);\n}\n// @private\nfunction capitalizeString(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nvar positionMap$1 = [\n    \"Top\",\n    \"Right\",\n    \"Bottom\",\n    \"Left\"\n];\nfunction generateProperty(property, position) {\n    if (!property) return position.toLowerCase();\n    var splitProperty = property.split(\"-\");\n    if (splitProperty.length > 1) {\n        splitProperty.splice(1, 0, position);\n        return splitProperty.reduce(function(acc, val) {\n            return \"\" + acc + capitalizeString(val);\n        });\n    }\n    var joinedProperty = property.replace(/([a-z])([A-Z])/g, \"$1\" + position + \"$2\");\n    return property === joinedProperty ? \"\" + property + position : joinedProperty;\n}\nfunction generateStyles(property, valuesWithDefaults) {\n    var styles = {};\n    for(var i = 0; i < valuesWithDefaults.length; i += 1){\n        if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {\n            styles[generateProperty(property, positionMap$1[i])] = valuesWithDefaults[i];\n        }\n    }\n    return styles;\n}\n/**\n * Enables shorthand for direction-based properties. It accepts a property (hyphenated or camelCased) and up to four values that map to top, right, bottom, and left, respectively. You can optionally pass an empty string to get only the directional values as properties. You can also optionally pass a null argument for a directional value to ignore it.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...directionalProperty('padding', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${directionalProperty('padding', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */ function directionalProperty(property) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    //  prettier-ignore\n    var firstValue = values[0], _values$ = values[1], secondValue = _values$ === void 0 ? firstValue : _values$, _values$2 = values[2], thirdValue = _values$2 === void 0 ? firstValue : _values$2, _values$3 = values[3], fourthValue = _values$3 === void 0 ? secondValue : _values$3;\n    var valuesWithDefaults = [\n        firstValue,\n        secondValue,\n        thirdValue,\n        fourthValue\n    ];\n    return generateStyles(property, valuesWithDefaults);\n}\n/**\n * Check if a string ends with something\n * @private\n */ function endsWith(string, suffix) {\n    return string.substr(-suffix.length) === suffix;\n}\nvar cssRegex$1 = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n/**\n * Returns a given CSS value minus its unit of measure.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': stripUnit('100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${stripUnit('100px')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100\n * }\n */ function stripUnit(value) {\n    if (typeof value !== \"string\") return value;\n    var matchedValue = value.match(cssRegex$1);\n    return matchedValue ? parseFloat(value) : value;\n}\n/**\n * Factory function that creates pixel-to-x converters\n * @private\n */ var pxtoFactory = function pxtoFactory(to) {\n    return function(pxval, base) {\n        if (base === void 0) {\n            base = \"16px\";\n        }\n        var newPxval = pxval;\n        var newBase = base;\n        if (typeof pxval === \"string\") {\n            if (!endsWith(pxval, \"px\")) {\n                throw new PolishedError(69, to, pxval);\n            }\n            newPxval = stripUnit(pxval);\n        }\n        if (typeof base === \"string\") {\n            if (!endsWith(base, \"px\")) {\n                throw new PolishedError(70, to, base);\n            }\n            newBase = stripUnit(base);\n        }\n        if (typeof newPxval === \"string\") {\n            throw new PolishedError(71, pxval, to);\n        }\n        if (typeof newBase === \"string\") {\n            throw new PolishedError(72, base, to);\n        }\n        return \"\" + newPxval / newBase + to;\n    };\n};\nvar pixelsto = pxtoFactory;\n/**\n * Convert pixel value to ems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': em('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${em('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1em'\n * }\n */ var em = pixelsto(\"em\");\nvar em$1 = em;\nvar cssRegex = /^([+-]?(?:\\d+|\\d*\\.\\d+))([a-z]*|%)$/;\n/**\n * Returns a given CSS value and its unit as elements of an array.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': getValueAndUnit('100px')[0],\n *   '--unit': getValueAndUnit('100px')[1],\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${getValueAndUnit('100px')[0]};\n *   --unit: ${getValueAndUnit('100px')[1]};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100,\n *   '--unit': 'px',\n * }\n */ function getValueAndUnit(value) {\n    if (typeof value !== \"string\") return [\n        value,\n        \"\"\n    ];\n    var matchedValue = value.match(cssRegex);\n    if (matchedValue) return [\n        parseFloat(value),\n        matchedValue[2]\n    ];\n    return [\n        value,\n        undefined\n    ];\n}\n/**\n * Helper for targeting rules in a style block generated by polished modules that need !important-level specificity. Can optionally specify a rule (or rules) to target specific rules.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...important(cover())\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${important(cover())}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'position': 'absolute !important',\n *   'top': '0 !important',\n *   'right: '0 !important',\n *   'bottom': '0 !important',\n *   'left: '0 !important'\n * }\n */ function important(styleBlock, rules) {\n    if (typeof styleBlock !== \"object\" || styleBlock === null) {\n        throw new PolishedError(75, typeof styleBlock);\n    }\n    var newStyleBlock = {};\n    Object.keys(styleBlock).forEach(function(key) {\n        if (typeof styleBlock[key] === \"object\" && styleBlock[key] !== null) {\n            newStyleBlock[key] = important(styleBlock[key], rules);\n        } else if (!rules || rules && (rules === key || rules.indexOf(key) >= 0)) {\n            newStyleBlock[key] = styleBlock[key] + \" !important\";\n        } else {\n            newStyleBlock[key] = styleBlock[key];\n        }\n    });\n    return newStyleBlock;\n}\nvar ratioNames = {\n    minorSecond: 1.067,\n    majorSecond: 1.125,\n    minorThird: 1.2,\n    majorThird: 1.25,\n    perfectFourth: 1.333,\n    augFourth: 1.414,\n    perfectFifth: 1.5,\n    minorSixth: 1.6,\n    goldenSection: 1.618,\n    majorSixth: 1.667,\n    minorSeventh: 1.778,\n    majorSeventh: 1.875,\n    octave: 2,\n    majorTenth: 2.5,\n    majorEleventh: 2.667,\n    majorTwelfth: 3,\n    doubleOctave: 4\n};\nfunction getRatio(ratioName) {\n    return ratioNames[ratioName];\n}\n/**\n * Establish consistent measurements and spacial relationships throughout your projects by incrementing an em or rem value up or down a defined scale. We provide a list of commonly used scales as pre-defined variables.\n * @example\n * // Styles as object usage\n * const styles = {\n *    // Increment two steps up the default scale\n *   'fontSize': modularScale(2)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *    // Increment two steps up the default scale\n *   fontSize: ${modularScale(2)}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'fontSize': '1.77689em'\n * }\n */ function modularScale(steps, base, ratio) {\n    if (base === void 0) {\n        base = \"1em\";\n    }\n    if (ratio === void 0) {\n        ratio = 1.333;\n    }\n    if (typeof steps !== \"number\") {\n        throw new PolishedError(42);\n    }\n    if (typeof ratio === \"string\" && !ratioNames[ratio]) {\n        throw new PolishedError(43);\n    }\n    var _ref = typeof base === \"string\" ? getValueAndUnit(base) : [\n        base,\n        \"\"\n    ], realBase = _ref[0], unit = _ref[1];\n    var realRatio = typeof ratio === \"string\" ? getRatio(ratio) : ratio;\n    if (typeof realBase === \"string\") {\n        throw new PolishedError(44, base);\n    }\n    return \"\" + realBase * Math.pow(realRatio, steps) + (unit || \"\");\n}\n/**\n * Convert pixel value to rems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': rem('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${rem('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1rem'\n * }\n */ var rem = pixelsto(\"rem\");\nvar rem$1 = rem;\nvar defaultFontSize = 16;\nfunction convertBase(base) {\n    var deconstructedValue = getValueAndUnit(base);\n    if (deconstructedValue[1] === \"px\") {\n        return parseFloat(base);\n    }\n    if (deconstructedValue[1] === \"%\") {\n        return parseFloat(base) / 100 * defaultFontSize;\n    }\n    throw new PolishedError(78, deconstructedValue[1]);\n}\nfunction getBaseFromDoc() {\n    /* eslint-disable */ /* istanbul ignore next */ if (typeof document !== \"undefined\" && document.documentElement !== null) {\n        var rootFontSize = getComputedStyle(document.documentElement).fontSize;\n        return rootFontSize ? convertBase(rootFontSize) : defaultFontSize;\n    }\n    /* eslint-enable */ /* istanbul ignore next */ return defaultFontSize;\n}\n/**\n * Convert rem values to px. By default, the base value is pulled from the font-size property on the root element (if it is set in % or px). It defaults to 16px if not found on the root. You can also override the base value by providing your own base in % or px.\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': remToPx('1.6rem')\n *   'height': remToPx('1.6rem', '10px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${remToPx('1.6rem')}\n *   height: ${remToPx('1.6rem', '10px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '25.6px',\n *   'height': '16px',\n * }\n */ function remToPx(value, base) {\n    var deconstructedValue = getValueAndUnit(value);\n    if (deconstructedValue[1] !== \"rem\" && deconstructedValue[1] !== \"\") {\n        throw new PolishedError(77, deconstructedValue[1]);\n    }\n    var newBase = base ? convertBase(base) : getBaseFromDoc();\n    return deconstructedValue[0] * newBase + \"px\";\n}\nvar functionsMap$3 = {\n    back: \"cubic-bezier(0.600, -0.280, 0.735, 0.045)\",\n    circ: \"cubic-bezier(0.600,  0.040, 0.980, 0.335)\",\n    cubic: \"cubic-bezier(0.550,  0.055, 0.675, 0.190)\",\n    expo: \"cubic-bezier(0.950,  0.050, 0.795, 0.035)\",\n    quad: \"cubic-bezier(0.550,  0.085, 0.680, 0.530)\",\n    quart: \"cubic-bezier(0.895,  0.030, 0.685, 0.220)\",\n    quint: \"cubic-bezier(0.755,  0.050, 0.855, 0.060)\",\n    sine: \"cubic-bezier(0.470,  0.000, 0.745, 0.715)\"\n};\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeIn('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeIn('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */ function easeIn(functionName) {\n    return functionsMap$3[functionName.toLowerCase().trim()];\n}\nvar functionsMap$2 = {\n    back: \"cubic-bezier(0.680, -0.550, 0.265, 1.550)\",\n    circ: \"cubic-bezier(0.785,  0.135, 0.150, 0.860)\",\n    cubic: \"cubic-bezier(0.645,  0.045, 0.355, 1.000)\",\n    expo: \"cubic-bezier(1.000,  0.000, 0.000, 1.000)\",\n    quad: \"cubic-bezier(0.455,  0.030, 0.515, 0.955)\",\n    quart: \"cubic-bezier(0.770,  0.000, 0.175, 1.000)\",\n    quint: \"cubic-bezier(0.860,  0.000, 0.070, 1.000)\",\n    sine: \"cubic-bezier(0.445,  0.050, 0.550, 0.950)\"\n};\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeInOut('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeInOut('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.455,  0.030, 0.515, 0.955)',\n * }\n */ function easeInOut(functionName) {\n    return functionsMap$2[functionName.toLowerCase().trim()];\n}\nvar functionsMap$1 = {\n    back: \"cubic-bezier(0.175,  0.885, 0.320, 1.275)\",\n    cubic: \"cubic-bezier(0.215,  0.610, 0.355, 1.000)\",\n    circ: \"cubic-bezier(0.075,  0.820, 0.165, 1.000)\",\n    expo: \"cubic-bezier(0.190,  1.000, 0.220, 1.000)\",\n    quad: \"cubic-bezier(0.250,  0.460, 0.450, 0.940)\",\n    quart: \"cubic-bezier(0.165,  0.840, 0.440, 1.000)\",\n    quint: \"cubic-bezier(0.230,  1.000, 0.320, 1.000)\",\n    sine: \"cubic-bezier(0.390,  0.575, 0.565, 1.000)\"\n};\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': easeOut('quad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${easeOut('quad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.250,  0.460, 0.450, 0.940)',\n * }\n */ function easeOut(functionName) {\n    return functionsMap$1[functionName.toLowerCase().trim()];\n}\n/**\n * Returns a CSS calc formula for linear interpolation of a property between two values. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px').\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   fontSize: between('20px', '100px', '400px', '1000px'),\n *   fontSize: between('20px', '100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   fontSize: ${between('20px', '100px', '400px', '1000px')};\n *   fontSize: ${between('20px', '100px')}\n * `\n *\n * // CSS as JS Output\n *\n * h1: {\n *   'fontSize': 'calc(-33.33333333333334px + 13.333333333333334vw)',\n *   'fontSize': 'calc(-9.090909090909093px + 9.090909090909092vw)'\n * }\n */ function between(fromSize, toSize, minScreen, maxScreen) {\n    if (minScreen === void 0) {\n        minScreen = \"320px\";\n    }\n    if (maxScreen === void 0) {\n        maxScreen = \"1200px\";\n    }\n    var _getValueAndUnit = getValueAndUnit(fromSize), unitlessFromSize = _getValueAndUnit[0], fromSizeUnit = _getValueAndUnit[1];\n    var _getValueAndUnit2 = getValueAndUnit(toSize), unitlessToSize = _getValueAndUnit2[0], toSizeUnit = _getValueAndUnit2[1];\n    var _getValueAndUnit3 = getValueAndUnit(minScreen), unitlessMinScreen = _getValueAndUnit3[0], minScreenUnit = _getValueAndUnit3[1];\n    var _getValueAndUnit4 = getValueAndUnit(maxScreen), unitlessMaxScreen = _getValueAndUnit4[0], maxScreenUnit = _getValueAndUnit4[1];\n    if (typeof unitlessMinScreen !== \"number\" || typeof unitlessMaxScreen !== \"number\" || !minScreenUnit || !maxScreenUnit || minScreenUnit !== maxScreenUnit) {\n        throw new PolishedError(47);\n    }\n    if (typeof unitlessFromSize !== \"number\" || typeof unitlessToSize !== \"number\" || fromSizeUnit !== toSizeUnit) {\n        throw new PolishedError(48);\n    }\n    if (fromSizeUnit !== minScreenUnit || toSizeUnit !== maxScreenUnit) {\n        throw new PolishedError(76);\n    }\n    var slope = (unitlessFromSize - unitlessToSize) / (unitlessMinScreen - unitlessMaxScreen);\n    var base = unitlessToSize - slope * unitlessMaxScreen;\n    return \"calc(\" + base.toFixed(2) + (fromSizeUnit || \"\") + \" + \" + (100 * slope).toFixed(2) + \"vw)\";\n}\n/**\n * CSS to contain a float (credit to CSSMojo).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...clearFix(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${clearFix()}\n * `\n *\n * // CSS as JS Output\n *\n * '&::after': {\n *   'clear': 'both',\n *   'content': '\"\"',\n *   'display': 'table'\n * }\n */ function clearFix(parent) {\n    var _ref;\n    if (parent === void 0) {\n        parent = \"&\";\n    }\n    var pseudoSelector = parent + \"::after\";\n    return _ref = {}, _ref[pseudoSelector] = {\n        clear: \"both\",\n        content: '\"\"',\n        display: \"table\"\n    }, _ref;\n}\n/**\n * CSS to fully cover an area. Can optionally be passed an offset to act as a \"padding\".\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...cover()\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${cover()}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'position': 'absolute',\n *   'top': '0',\n *   'right: '0',\n *   'bottom': '0',\n *   'left: '0'\n * }\n */ function cover(offset) {\n    if (offset === void 0) {\n        offset = 0;\n    }\n    return {\n        position: \"absolute\",\n        top: offset,\n        right: offset,\n        bottom: offset,\n        left: offset\n    };\n}\n/**\n * CSS to represent truncated text with an ellipsis. You can optionally pass a max-width and number of lines before truncating.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...ellipsis('250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${ellipsis('250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'display': 'inline-block',\n *   'maxWidth': '250px',\n *   'overflow': 'hidden',\n *   'textOverflow': 'ellipsis',\n *   'whiteSpace': 'nowrap',\n *   'wordWrap': 'normal'\n * }\n */ function ellipsis(width, lines) {\n    if (lines === void 0) {\n        lines = 1;\n    }\n    var styles = {\n        display: \"inline-block\",\n        maxWidth: width || \"100%\",\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n    };\n    return lines > 1 ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, styles, {\n        WebkitBoxOrient: \"vertical\",\n        WebkitLineClamp: lines,\n        display: \"-webkit-box\",\n        whiteSpace: \"normal\"\n    }) : styles;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\n/**\n * Returns a set of media queries that resizes a property (or set of properties) between a provided fromSize and toSize. Accepts optional minScreen (defaults to '320px') and maxScreen (defaults to '1200px') to constrain the interpolation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...fluidRange(\n *    {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${fluidRange(\n *      {\n *        prop: 'padding',\n *        fromSize: '20px',\n *        toSize: '100px',\n *      },\n *      '400px',\n *      '1000px',\n *    )}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   \"@media (min-width: 1000px)\": Object {\n *     \"padding\": \"100px\",\n *   },\n *   \"@media (min-width: 400px)\": Object {\n *     \"padding\": \"calc(-33.33333333333334px + 13.333333333333334vw)\",\n *   },\n *   \"padding\": \"20px\",\n * }\n */ function fluidRange(cssProp, minScreen, maxScreen) {\n    if (minScreen === void 0) {\n        minScreen = \"320px\";\n    }\n    if (maxScreen === void 0) {\n        maxScreen = \"1200px\";\n    }\n    if (!Array.isArray(cssProp) && typeof cssProp !== \"object\" || cssProp === null) {\n        throw new PolishedError(49);\n    }\n    if (Array.isArray(cssProp)) {\n        var mediaQueries = {};\n        var fallbacks = {};\n        for(var _iterator = _createForOfIteratorHelperLoose(cssProp), _step; !(_step = _iterator()).done;){\n            var _extends2, _extends3;\n            var obj = _step.value;\n            if (!obj.prop || !obj.fromSize || !obj.toSize) {\n                throw new PolishedError(50);\n            }\n            fallbacks[obj.prop] = obj.fromSize;\n            mediaQueries[\"@media (min-width: \" + minScreen + \")\"] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, mediaQueries[\"@media (min-width: \" + minScreen + \")\"], (_extends2 = {}, _extends2[obj.prop] = between(obj.fromSize, obj.toSize, minScreen, maxScreen), _extends2));\n            mediaQueries[\"@media (min-width: \" + maxScreen + \")\"] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, mediaQueries[\"@media (min-width: \" + maxScreen + \")\"], (_extends3 = {}, _extends3[obj.prop] = obj.toSize, _extends3));\n        }\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, fallbacks, mediaQueries);\n    } else {\n        var _ref, _ref2, _ref3;\n        if (!cssProp.prop || !cssProp.fromSize || !cssProp.toSize) {\n            throw new PolishedError(51);\n        }\n        return _ref3 = {}, _ref3[cssProp.prop] = cssProp.fromSize, _ref3[\"@media (min-width: \" + minScreen + \")\"] = (_ref = {}, _ref[cssProp.prop] = between(cssProp.fromSize, cssProp.toSize, minScreen, maxScreen), _ref), _ref3[\"@media (min-width: \" + maxScreen + \")\"] = (_ref2 = {}, _ref2[cssProp.prop] = cssProp.toSize, _ref2), _ref3;\n    }\n}\nvar dataURIRegex = /^\\s*data:([a-z]+\\/[a-z-]+(;[a-z-]+=[a-z-]+)?)?(;charset=[a-z0-9-]+)?(;base64)?,[a-z0-9!$&',()*+,;=\\-._~:@/?%\\s]*\\s*$/i;\nvar formatHintMap = {\n    woff: \"woff\",\n    woff2: \"woff2\",\n    ttf: \"truetype\",\n    otf: \"opentype\",\n    eot: \"embedded-opentype\",\n    svg: \"svg\",\n    svgz: \"svg\"\n};\nfunction generateFormatHint(format, formatHint) {\n    if (!formatHint) return \"\";\n    return ' format(\"' + formatHintMap[format] + '\")';\n}\nfunction isDataURI(fontFilePath) {\n    return !!fontFilePath.replace(/\\s+/g, \" \").match(dataURIRegex);\n}\nfunction generateFileReferences(fontFilePath, fileFormats, formatHint) {\n    if (isDataURI(fontFilePath)) {\n        return 'url(\"' + fontFilePath + '\")' + generateFormatHint(fileFormats[0], formatHint);\n    }\n    var fileFontReferences = fileFormats.map(function(format) {\n        return 'url(\"' + fontFilePath + \".\" + format + '\")' + generateFormatHint(format, formatHint);\n    });\n    return fileFontReferences.join(\", \");\n}\nfunction generateLocalReferences(localFonts) {\n    var localFontReferences = localFonts.map(function(font) {\n        return 'local(\"' + font + '\")';\n    });\n    return localFontReferences.join(\", \");\n}\nfunction generateSources(fontFilePath, localFonts, fileFormats, formatHint) {\n    var fontReferences = [];\n    if (localFonts) fontReferences.push(generateLocalReferences(localFonts));\n    if (fontFilePath) {\n        fontReferences.push(generateFileReferences(fontFilePath, fileFormats, formatHint));\n    }\n    return fontReferences.join(\", \");\n}\n/**\n * CSS for a @font-face declaration. Defaults to check for local copies of the font on the user's machine. You can disable this by passing `null` to localFonts.\n *\n * @example\n * // Styles as object basic usage\n * const styles = {\n *    ...fontFace({\n *      'fontFamily': 'Sans-Pro',\n *      'fontFilePath': 'path/to/file'\n *    })\n * }\n *\n * // styled-components basic usage\n * const GlobalStyle = createGlobalStyle`${\n *   fontFace({\n *     'fontFamily': 'Sans-Pro',\n *     'fontFilePath': 'path/to/file'\n *   }\n * )}`\n *\n * // CSS as JS Output\n *\n * '@font-face': {\n *   'fontFamily': 'Sans-Pro',\n *   'src': 'url(\"path/to/file.eot\"), url(\"path/to/file.woff2\"), url(\"path/to/file.woff\"), url(\"path/to/file.ttf\"), url(\"path/to/file.svg\")',\n * }\n */ function fontFace(_ref) {\n    var fontFamily = _ref.fontFamily, fontFilePath = _ref.fontFilePath, fontStretch = _ref.fontStretch, fontStyle = _ref.fontStyle, fontVariant = _ref.fontVariant, fontWeight = _ref.fontWeight, _ref$fileFormats = _ref.fileFormats, fileFormats = _ref$fileFormats === void 0 ? [\n        \"eot\",\n        \"woff2\",\n        \"woff\",\n        \"ttf\",\n        \"svg\"\n    ] : _ref$fileFormats, _ref$formatHint = _ref.formatHint, formatHint = _ref$formatHint === void 0 ? false : _ref$formatHint, _ref$localFonts = _ref.localFonts, localFonts = _ref$localFonts === void 0 ? [\n        fontFamily\n    ] : _ref$localFonts, unicodeRange = _ref.unicodeRange, fontDisplay = _ref.fontDisplay, fontVariationSettings = _ref.fontVariationSettings, fontFeatureSettings = _ref.fontFeatureSettings;\n    // Error Handling\n    if (!fontFamily) throw new PolishedError(55);\n    if (!fontFilePath && !localFonts) {\n        throw new PolishedError(52);\n    }\n    if (localFonts && !Array.isArray(localFonts)) {\n        throw new PolishedError(53);\n    }\n    if (!Array.isArray(fileFormats)) {\n        throw new PolishedError(54);\n    }\n    var fontFaceDeclaration = {\n        \"@font-face\": {\n            fontFamily: fontFamily,\n            src: generateSources(fontFilePath, localFonts, fileFormats, formatHint),\n            unicodeRange: unicodeRange,\n            fontStretch: fontStretch,\n            fontStyle: fontStyle,\n            fontVariant: fontVariant,\n            fontWeight: fontWeight,\n            fontDisplay: fontDisplay,\n            fontVariationSettings: fontVariationSettings,\n            fontFeatureSettings: fontFeatureSettings\n        }\n    };\n    // Removes undefined fields for cleaner css object.\n    return JSON.parse(JSON.stringify(fontFaceDeclaration));\n}\n/**\n * CSS to hide text to show a background image in a SEO-friendly way.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'backgroundImage': 'url(logo.png)',\n *   ...hideText(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   backgroundImage: url(logo.png);\n *   ${hideText()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'backgroundImage': 'url(logo.png)',\n *   'textIndent': '101%',\n *   'overflow': 'hidden',\n *   'whiteSpace': 'nowrap',\n * }\n */ function hideText() {\n    return {\n        textIndent: \"101%\",\n        overflow: \"hidden\",\n        whiteSpace: \"nowrap\"\n    };\n}\n/**\n * CSS to hide content visually but remain accessible to screen readers.\n * from [HTML5 Boilerplate](https://github.com/h5bp/html5-boilerplate/blob/9a176f57af1cfe8ec70300da4621fb9b07e5fa31/src/css/main.css#L121)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...hideVisually(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hideVisually()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'border': '0',\n *   'clip': 'rect(0 0 0 0)',\n *   'height': '1px',\n *   'margin': '-1px',\n *   'overflow': 'hidden',\n *   'padding': '0',\n *   'position': 'absolute',\n *   'whiteSpace': 'nowrap',\n *   'width': '1px',\n * }\n */ function hideVisually() {\n    return {\n        border: \"0\",\n        clip: \"rect(0 0 0 0)\",\n        height: \"1px\",\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        padding: \"0\",\n        position: \"absolute\",\n        whiteSpace: \"nowrap\",\n        width: \"1px\"\n    };\n}\n/**\n * Generates a media query to target HiDPI devices.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  [hiDPI(1.5)]: {\n *    width: 200px;\n *  }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hiDPI(1.5)} {\n *     width: 200px;\n *   }\n * `\n *\n * // CSS as JS Output\n *\n * '@media only screen and (-webkit-min-device-pixel-ratio: 1.5),\n *  only screen and (min--moz-device-pixel-ratio: 1.5),\n *  only screen and (-o-min-device-pixel-ratio: 1.5/1),\n *  only screen and (min-resolution: 144dpi),\n *  only screen and (min-resolution: 1.5dppx)': {\n *   'width': '200px',\n * }\n */ function hiDPI(ratio) {\n    if (ratio === void 0) {\n        ratio = 1.3;\n    }\n    return \"\\n    @media only screen and (-webkit-min-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (min--moz-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (-o-min-device-pixel-ratio: \" + ratio + \"/1),\\n    only screen and (min-resolution: \" + Math.round(ratio * 96) + \"dpi),\\n    only screen and (min-resolution: \" + ratio + \"dppx)\\n  \";\n}\nfunction constructGradientValue(literals) {\n    var template = \"\";\n    for(var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        substitutions[_key - 1] = arguments[_key];\n    }\n    for(var i = 0; i < literals.length; i += 1){\n        template += literals[i];\n        if (i === substitutions.length - 1 && substitutions[i]) {\n            var definedValues = substitutions.filter(function(substitute) {\n                return !!substitute;\n            });\n            // Adds leading coma if properties preceed color-stops\n            if (definedValues.length > 1) {\n                template = template.slice(0, -1);\n                template += \", \" + substitutions[i];\n            // No trailing space if color-stops is the only param provided\n            } else if (definedValues.length === 1) {\n                template += \"\" + substitutions[i];\n            }\n        } else if (substitutions[i]) {\n            template += substitutions[i] + \" \";\n        }\n    }\n    return template.trim();\n}\nvar _templateObject$1;\n/**\n * CSS for declaring a linear gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${linearGradient({\n        colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n        toDirection: 'to top right',\n        fallback: '#FFF',\n      })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#FFF',\n *   'backgroundImage': 'linear-gradient(to top right, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */ function linearGradient(_ref) {\n    var colorStops = _ref.colorStops, fallback = _ref.fallback, _ref$toDirection = _ref.toDirection, toDirection = _ref$toDirection === void 0 ? \"\" : _ref$toDirection;\n    if (!colorStops || colorStops.length < 2) {\n        throw new PolishedError(56);\n    }\n    return {\n        backgroundColor: fallback || colorStops[0].replace(/,\\s+/g, \",\").split(\" \")[0].replace(/,(?=\\S)/g, \", \"),\n        backgroundImage: constructGradientValue(_templateObject$1 || (_templateObject$1 = (0,_babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n            \"linear-gradient(\",\n            \"\",\n            \")\"\n        ])), toDirection, colorStops.join(\", \").replace(/,(?=\\S)/g, \", \"))\n    };\n}\n/**\n * CSS to normalize abnormalities across browsers (normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...normalize(),\n * }\n *\n * // styled-components usage\n * const GlobalStyle = createGlobalStyle`${normalize()}`\n *\n * // CSS as JS Output\n *\n * html {\n *   lineHeight: 1.15,\n *   textSizeAdjust: 100%,\n * } ...\n */ function normalize() {\n    var _ref;\n    return [\n        (_ref = {\n            html: {\n                lineHeight: \"1.15\",\n                textSizeAdjust: \"100%\"\n            },\n            body: {\n                margin: \"0\"\n            },\n            main: {\n                display: \"block\"\n            },\n            h1: {\n                fontSize: \"2em\",\n                margin: \"0.67em 0\"\n            },\n            hr: {\n                boxSizing: \"content-box\",\n                height: \"0\",\n                overflow: \"visible\"\n            },\n            pre: {\n                fontFamily: \"monospace, monospace\",\n                fontSize: \"1em\"\n            },\n            a: {\n                backgroundColor: \"transparent\"\n            },\n            \"abbr[title]\": {\n                borderBottom: \"none\",\n                textDecoration: \"underline\"\n            }\n        }, _ref[\"b,\\n    strong\"] = {\n            fontWeight: \"bolder\"\n        }, _ref[\"code,\\n    kbd,\\n    samp\"] = {\n            fontFamily: \"monospace, monospace\",\n            fontSize: \"1em\"\n        }, _ref.small = {\n            fontSize: \"80%\"\n        }, _ref[\"sub,\\n    sup\"] = {\n            fontSize: \"75%\",\n            lineHeight: \"0\",\n            position: \"relative\",\n            verticalAlign: \"baseline\"\n        }, _ref.sub = {\n            bottom: \"-0.25em\"\n        }, _ref.sup = {\n            top: \"-0.5em\"\n        }, _ref.img = {\n            borderStyle: \"none\"\n        }, _ref[\"button,\\n    input,\\n    optgroup,\\n    select,\\n    textarea\"] = {\n            fontFamily: \"inherit\",\n            fontSize: \"100%\",\n            lineHeight: \"1.15\",\n            margin: \"0\"\n        }, _ref[\"button,\\n    input\"] = {\n            overflow: \"visible\"\n        }, _ref[\"button,\\n    select\"] = {\n            textTransform: \"none\"\n        }, _ref['button,\\n    html [type=\"button\"],\\n    [type=\"reset\"],\\n    [type=\"submit\"]'] = {\n            WebkitAppearance: \"button\"\n        }, _ref['button::-moz-focus-inner,\\n    [type=\"button\"]::-moz-focus-inner,\\n    [type=\"reset\"]::-moz-focus-inner,\\n    [type=\"submit\"]::-moz-focus-inner'] = {\n            borderStyle: \"none\",\n            padding: \"0\"\n        }, _ref['button:-moz-focusring,\\n    [type=\"button\"]:-moz-focusring,\\n    [type=\"reset\"]:-moz-focusring,\\n    [type=\"submit\"]:-moz-focusring'] = {\n            outline: \"1px dotted ButtonText\"\n        }, _ref.fieldset = {\n            padding: \"0.35em 0.625em 0.75em\"\n        }, _ref.legend = {\n            boxSizing: \"border-box\",\n            color: \"inherit\",\n            display: \"table\",\n            maxWidth: \"100%\",\n            padding: \"0\",\n            whiteSpace: \"normal\"\n        }, _ref.progress = {\n            verticalAlign: \"baseline\"\n        }, _ref.textarea = {\n            overflow: \"auto\"\n        }, _ref['[type=\"checkbox\"],\\n    [type=\"radio\"]'] = {\n            boxSizing: \"border-box\",\n            padding: \"0\"\n        }, _ref['[type=\"number\"]::-webkit-inner-spin-button,\\n    [type=\"number\"]::-webkit-outer-spin-button'] = {\n            height: \"auto\"\n        }, _ref['[type=\"search\"]'] = {\n            WebkitAppearance: \"textfield\",\n            outlineOffset: \"-2px\"\n        }, _ref['[type=\"search\"]::-webkit-search-decoration'] = {\n            WebkitAppearance: \"none\"\n        }, _ref[\"::-webkit-file-upload-button\"] = {\n            WebkitAppearance: \"button\",\n            font: \"inherit\"\n        }, _ref.details = {\n            display: \"block\"\n        }, _ref.summary = {\n            display: \"list-item\"\n        }, _ref.template = {\n            display: \"none\"\n        }, _ref[\"[hidden]\"] = {\n            display: \"none\"\n        }, _ref),\n        {\n            \"abbr[title]\": {\n                textDecoration: \"underline dotted\"\n            }\n        }\n    ];\n}\nvar _templateObject;\n/**\n * CSS for declaring a radial gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#00FFFF',\n *   'backgroundImage': 'radial-gradient(center ellipse farthest-corner at 45px 45px, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */ function radialGradient(_ref) {\n    var colorStops = _ref.colorStops, _ref$extent = _ref.extent, extent = _ref$extent === void 0 ? \"\" : _ref$extent, fallback = _ref.fallback, _ref$position = _ref.position, position = _ref$position === void 0 ? \"\" : _ref$position, _ref$shape = _ref.shape, shape = _ref$shape === void 0 ? \"\" : _ref$shape;\n    if (!colorStops || colorStops.length < 2) {\n        throw new PolishedError(57);\n    }\n    return {\n        backgroundColor: fallback || colorStops[0].split(\" \")[0],\n        backgroundImage: constructGradientValue(_templateObject || (_templateObject = (0,_babel_runtime_helpers_esm_taggedTemplateLiteralLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])([\n            \"radial-gradient(\",\n            \"\",\n            \"\",\n            \"\",\n            \")\"\n        ])), position, shape, extent, colorStops.join(\", \"))\n    };\n}\n/**\n * A helper to generate a retina background image and non-retina\n * background image. The retina background image will output to a HiDPI media query. The mixin uses\n * a _2x.png filename suffix by default.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  ...retinaImage('my-img')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${retinaImage('my-img')}\n * `\n *\n * // CSS as JS Output\n * div {\n *   backgroundImage: 'url(my-img.png)',\n *   '@media only screen and (-webkit-min-device-pixel-ratio: 1.3),\n *    only screen and (min--moz-device-pixel-ratio: 1.3),\n *    only screen and (-o-min-device-pixel-ratio: 1.3/1),\n *    only screen and (min-resolution: 144dpi),\n *    only screen and (min-resolution: 1.5dppx)': {\n *     backgroundImage: 'url(my-img_2x.png)',\n *   }\n * }\n */ function retinaImage(filename, backgroundSize, extension, retinaFilename, retinaSuffix) {\n    var _ref;\n    if (extension === void 0) {\n        extension = \"png\";\n    }\n    if (retinaSuffix === void 0) {\n        retinaSuffix = \"_2x\";\n    }\n    if (!filename) {\n        throw new PolishedError(58);\n    }\n    // Replace the dot at the beginning of the passed extension if one exists\n    var ext = extension.replace(/^\\./, \"\");\n    var rFilename = retinaFilename ? retinaFilename + \".\" + ext : \"\" + filename + retinaSuffix + \".\" + ext;\n    return _ref = {\n        backgroundImage: \"url(\" + filename + \".\" + ext + \")\"\n    }, _ref[hiDPI()] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        backgroundImage: \"url(\" + rFilename + \")\"\n    }, backgroundSize ? {\n        backgroundSize: backgroundSize\n    } : {}), _ref;\n}\n/* eslint-disable key-spacing */ var functionsMap = {\n    easeInBack: \"cubic-bezier(0.600, -0.280, 0.735, 0.045)\",\n    easeInCirc: \"cubic-bezier(0.600,  0.040, 0.980, 0.335)\",\n    easeInCubic: \"cubic-bezier(0.550,  0.055, 0.675, 0.190)\",\n    easeInExpo: \"cubic-bezier(0.950,  0.050, 0.795, 0.035)\",\n    easeInQuad: \"cubic-bezier(0.550,  0.085, 0.680, 0.530)\",\n    easeInQuart: \"cubic-bezier(0.895,  0.030, 0.685, 0.220)\",\n    easeInQuint: \"cubic-bezier(0.755,  0.050, 0.855, 0.060)\",\n    easeInSine: \"cubic-bezier(0.470,  0.000, 0.745, 0.715)\",\n    easeOutBack: \"cubic-bezier(0.175,  0.885, 0.320, 1.275)\",\n    easeOutCubic: \"cubic-bezier(0.215,  0.610, 0.355, 1.000)\",\n    easeOutCirc: \"cubic-bezier(0.075,  0.820, 0.165, 1.000)\",\n    easeOutExpo: \"cubic-bezier(0.190,  1.000, 0.220, 1.000)\",\n    easeOutQuad: \"cubic-bezier(0.250,  0.460, 0.450, 0.940)\",\n    easeOutQuart: \"cubic-bezier(0.165,  0.840, 0.440, 1.000)\",\n    easeOutQuint: \"cubic-bezier(0.230,  1.000, 0.320, 1.000)\",\n    easeOutSine: \"cubic-bezier(0.390,  0.575, 0.565, 1.000)\",\n    easeInOutBack: \"cubic-bezier(0.680, -0.550, 0.265, 1.550)\",\n    easeInOutCirc: \"cubic-bezier(0.785,  0.135, 0.150, 0.860)\",\n    easeInOutCubic: \"cubic-bezier(0.645,  0.045, 0.355, 1.000)\",\n    easeInOutExpo: \"cubic-bezier(1.000,  0.000, 0.000, 1.000)\",\n    easeInOutQuad: \"cubic-bezier(0.455,  0.030, 0.515, 0.955)\",\n    easeInOutQuart: \"cubic-bezier(0.770,  0.000, 0.175, 1.000)\",\n    easeInOutQuint: \"cubic-bezier(0.860,  0.000, 0.070, 1.000)\",\n    easeInOutSine: \"cubic-bezier(0.445,  0.050, 0.550, 0.950)\"\n};\n/* eslint-enable key-spacing */ function getTimingFunction(functionName) {\n    return functionsMap[functionName];\n}\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @deprecated - This will be deprecated in v5 in favor of `easeIn`, `easeOut`, `easeInOut`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': timingFunctions('easeInQuad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${timingFunctions('easeInQuad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */ function timingFunctions(timingFunction) {\n    return getTimingFunction(timingFunction);\n}\nvar getBorderWidth = function getBorderWidth(pointingDirection, height, width) {\n    var fullWidth = \"\" + width[0] + (width[1] || \"\");\n    var halfWidth = \"\" + width[0] / 2 + (width[1] || \"\");\n    var fullHeight = \"\" + height[0] + (height[1] || \"\");\n    var halfHeight = \"\" + height[0] / 2 + (height[1] || \"\");\n    switch(pointingDirection){\n        case \"top\":\n            return \"0 \" + halfWidth + \" \" + fullHeight + \" \" + halfWidth;\n        case \"topLeft\":\n            return fullWidth + \" \" + fullHeight + \" 0 0\";\n        case \"left\":\n            return halfHeight + \" \" + fullWidth + \" \" + halfHeight + \" 0\";\n        case \"bottomLeft\":\n            return fullWidth + \" 0 0 \" + fullHeight;\n        case \"bottom\":\n            return fullHeight + \" \" + halfWidth + \" 0 \" + halfWidth;\n        case \"bottomRight\":\n            return \"0 0 \" + fullWidth + \" \" + fullHeight;\n        case \"right\":\n            return halfHeight + \" 0 \" + halfHeight + \" \" + fullWidth;\n        case \"topRight\":\n        default:\n            return \"0 \" + fullWidth + \" \" + fullHeight + \" 0\";\n    }\n};\nvar getBorderColor = function getBorderColor(pointingDirection, foregroundColor) {\n    switch(pointingDirection){\n        case \"top\":\n        case \"bottomRight\":\n            return {\n                borderBottomColor: foregroundColor\n            };\n        case \"right\":\n        case \"bottomLeft\":\n            return {\n                borderLeftColor: foregroundColor\n            };\n        case \"bottom\":\n        case \"topLeft\":\n            return {\n                borderTopColor: foregroundColor\n            };\n        case \"left\":\n        case \"topRight\":\n            return {\n                borderRightColor: foregroundColor\n            };\n        default:\n            throw new PolishedError(59);\n    }\n};\n/**\n * CSS to represent triangle with any pointing direction with an optional background color.\n *\n * @example\n * // Styles as object usage\n *\n * const styles = {\n *   ...triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })\n * }\n *\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })}\n *\n *\n * // CSS as JS Output\n *\n * div: {\n *  'borderColor': 'transparent transparent transparent red',\n *  'borderStyle': 'solid',\n *  'borderWidth': '50px 0 50px 100px',\n *  'height': '0',\n *  'width': '0',\n * }\n */ function triangle(_ref) {\n    var pointingDirection = _ref.pointingDirection, height = _ref.height, width = _ref.width, foregroundColor = _ref.foregroundColor, _ref$backgroundColor = _ref.backgroundColor, backgroundColor = _ref$backgroundColor === void 0 ? \"transparent\" : _ref$backgroundColor;\n    var widthAndUnit = getValueAndUnit(width);\n    var heightAndUnit = getValueAndUnit(height);\n    if (isNaN(heightAndUnit[0]) || isNaN(widthAndUnit[0])) {\n        throw new PolishedError(60);\n    }\n    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        width: \"0\",\n        height: \"0\",\n        borderColor: backgroundColor\n    }, getBorderColor(pointingDirection, foregroundColor), {\n        borderStyle: \"solid\",\n        borderWidth: getBorderWidth(pointingDirection, heightAndUnit, widthAndUnit)\n    });\n}\n/**\n * Provides an easy way to change the `wordWrap` property.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...wordWrap('break-word')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${wordWrap('break-word')}\n * `\n *\n * // CSS as JS Output\n *\n * const styles = {\n *   overflowWrap: 'break-word',\n *   wordWrap: 'break-word',\n *   wordBreak: 'break-all',\n * }\n */ function wordWrap(wrap) {\n    if (wrap === void 0) {\n        wrap = \"break-word\";\n    }\n    var wordBreak = wrap === \"break-word\" ? \"break-all\" : wrap;\n    return {\n        overflowWrap: wrap,\n        wordWrap: wrap,\n        wordBreak: wordBreak\n    };\n}\nfunction colorToInt(color) {\n    return Math.round(color * 255);\n}\nfunction convertToInt(red, green, blue) {\n    return colorToInt(red) + \",\" + colorToInt(green) + \",\" + colorToInt(blue);\n}\nfunction hslToRgb(hue, saturation, lightness, convert) {\n    if (convert === void 0) {\n        convert = convertToInt;\n    }\n    if (saturation === 0) {\n        // achromatic\n        return convert(lightness, lightness, lightness);\n    }\n    // formulae from https://en.wikipedia.org/wiki/HSL_and_HSV\n    var huePrime = (hue % 360 + 360) % 360 / 60;\n    var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;\n    var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));\n    var red = 0;\n    var green = 0;\n    var blue = 0;\n    if (huePrime >= 0 && huePrime < 1) {\n        red = chroma;\n        green = secondComponent;\n    } else if (huePrime >= 1 && huePrime < 2) {\n        red = secondComponent;\n        green = chroma;\n    } else if (huePrime >= 2 && huePrime < 3) {\n        green = chroma;\n        blue = secondComponent;\n    } else if (huePrime >= 3 && huePrime < 4) {\n        green = secondComponent;\n        blue = chroma;\n    } else if (huePrime >= 4 && huePrime < 5) {\n        red = secondComponent;\n        blue = chroma;\n    } else if (huePrime >= 5 && huePrime < 6) {\n        red = chroma;\n        blue = secondComponent;\n    }\n    var lightnessModification = lightness - chroma / 2;\n    var finalRed = red + lightnessModification;\n    var finalGreen = green + lightnessModification;\n    var finalBlue = blue + lightnessModification;\n    return convert(finalRed, finalGreen, finalBlue);\n}\nvar namedColorMap = {\n    aliceblue: \"f0f8ff\",\n    antiquewhite: \"faebd7\",\n    aqua: \"00ffff\",\n    aquamarine: \"7fffd4\",\n    azure: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"000\",\n    blanchedalmond: \"ffebcd\",\n    blue: \"0000ff\",\n    blueviolet: \"8a2be2\",\n    brown: \"a52a2a\",\n    burlywood: \"deb887\",\n    cadetblue: \"5f9ea0\",\n    chartreuse: \"7fff00\",\n    chocolate: \"d2691e\",\n    coral: \"ff7f50\",\n    cornflowerblue: \"6495ed\",\n    cornsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"00ffff\",\n    darkblue: \"00008b\",\n    darkcyan: \"008b8b\",\n    darkgoldenrod: \"b8860b\",\n    darkgray: \"a9a9a9\",\n    darkgreen: \"006400\",\n    darkgrey: \"a9a9a9\",\n    darkkhaki: \"bdb76b\",\n    darkmagenta: \"8b008b\",\n    darkolivegreen: \"556b2f\",\n    darkorange: \"ff8c00\",\n    darkorchid: \"9932cc\",\n    darkred: \"8b0000\",\n    darksalmon: \"e9967a\",\n    darkseagreen: \"8fbc8f\",\n    darkslateblue: \"483d8b\",\n    darkslategray: \"2f4f4f\",\n    darkslategrey: \"2f4f4f\",\n    darkturquoise: \"00ced1\",\n    darkviolet: \"9400d3\",\n    deeppink: \"ff1493\",\n    deepskyblue: \"00bfff\",\n    dimgray: \"696969\",\n    dimgrey: \"696969\",\n    dodgerblue: \"1e90ff\",\n    firebrick: \"b22222\",\n    floralwhite: \"fffaf0\",\n    forestgreen: \"228b22\",\n    fuchsia: \"ff00ff\",\n    gainsboro: \"dcdcdc\",\n    ghostwhite: \"f8f8ff\",\n    gold: \"ffd700\",\n    goldenrod: \"daa520\",\n    gray: \"808080\",\n    green: \"008000\",\n    greenyellow: \"adff2f\",\n    grey: \"808080\",\n    honeydew: \"f0fff0\",\n    hotpink: \"ff69b4\",\n    indianred: \"cd5c5c\",\n    indigo: \"4b0082\",\n    ivory: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavender: \"e6e6fa\",\n    lavenderblush: \"fff0f5\",\n    lawngreen: \"7cfc00\",\n    lemonchiffon: \"fffacd\",\n    lightblue: \"add8e6\",\n    lightcoral: \"f08080\",\n    lightcyan: \"e0ffff\",\n    lightgoldenrodyellow: \"fafad2\",\n    lightgray: \"d3d3d3\",\n    lightgreen: \"90ee90\",\n    lightgrey: \"d3d3d3\",\n    lightpink: \"ffb6c1\",\n    lightsalmon: \"ffa07a\",\n    lightseagreen: \"20b2aa\",\n    lightskyblue: \"87cefa\",\n    lightslategray: \"789\",\n    lightslategrey: \"789\",\n    lightsteelblue: \"b0c4de\",\n    lightyellow: \"ffffe0\",\n    lime: \"0f0\",\n    limegreen: \"32cd32\",\n    linen: \"faf0e6\",\n    magenta: \"f0f\",\n    maroon: \"800000\",\n    mediumaquamarine: \"66cdaa\",\n    mediumblue: \"0000cd\",\n    mediumorchid: \"ba55d3\",\n    mediumpurple: \"9370db\",\n    mediumseagreen: \"3cb371\",\n    mediumslateblue: \"7b68ee\",\n    mediumspringgreen: \"00fa9a\",\n    mediumturquoise: \"48d1cc\",\n    mediumvioletred: \"c71585\",\n    midnightblue: \"191970\",\n    mintcream: \"f5fffa\",\n    mistyrose: \"ffe4e1\",\n    moccasin: \"ffe4b5\",\n    navajowhite: \"ffdead\",\n    navy: \"000080\",\n    oldlace: \"fdf5e6\",\n    olive: \"808000\",\n    olivedrab: \"6b8e23\",\n    orange: \"ffa500\",\n    orangered: \"ff4500\",\n    orchid: \"da70d6\",\n    palegoldenrod: \"eee8aa\",\n    palegreen: \"98fb98\",\n    paleturquoise: \"afeeee\",\n    palevioletred: \"db7093\",\n    papayawhip: \"ffefd5\",\n    peachpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pink: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powderblue: \"b0e0e6\",\n    purple: \"800080\",\n    rebeccapurple: \"639\",\n    red: \"f00\",\n    rosybrown: \"bc8f8f\",\n    royalblue: \"4169e1\",\n    saddlebrown: \"8b4513\",\n    salmon: \"fa8072\",\n    sandybrown: \"f4a460\",\n    seagreen: \"2e8b57\",\n    seashell: \"fff5ee\",\n    sienna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyblue: \"87ceeb\",\n    slateblue: \"6a5acd\",\n    slategray: \"708090\",\n    slategrey: \"708090\",\n    snow: \"fffafa\",\n    springgreen: \"00ff7f\",\n    steelblue: \"4682b4\",\n    tan: \"d2b48c\",\n    teal: \"008080\",\n    thistle: \"d8bfd8\",\n    tomato: \"ff6347\",\n    turquoise: \"40e0d0\",\n    violet: \"ee82ee\",\n    wheat: \"f5deb3\",\n    white: \"fff\",\n    whitesmoke: \"f5f5f5\",\n    yellow: \"ff0\",\n    yellowgreen: \"9acd32\"\n};\n/**\n * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.\n * @private\n */ function nameToHex(color) {\n    if (typeof color !== \"string\") return color;\n    var normalizedColorName = color.toLowerCase();\n    return namedColorMap[normalizedColorName] ? \"#\" + namedColorMap[normalizedColorName] : color;\n}\nvar hexRegex = /^#[a-fA-F0-9]{6}$/;\nvar hexRgbaRegex = /^#[a-fA-F0-9]{8}$/;\nvar reducedHexRegex = /^#[a-fA-F0-9]{3}$/;\nvar reducedRgbaHexRegex = /^#[a-fA-F0-9]{4}$/;\nvar rgbRegex = /^rgb\\(\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*\\)$/i;\nvar rgbaRegex = /^rgb(?:a)?\\(\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,)?\\s*(\\d{1,3})\\s*(?:,|\\/)\\s*([-+]?\\d*[.]?\\d+[%]?)\\s*\\)$/i;\nvar hslRegex = /^hsl\\(\\s*(\\d{0,3}[.]?[0-9]+(?:deg)?)\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*\\)$/i;\nvar hslaRegex = /^hsl(?:a)?\\(\\s*(\\d{0,3}[.]?[0-9]+(?:deg)?)\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,)?\\s*(\\d{1,3}[.]?[0-9]?)%\\s*(?:,|\\/)\\s*([-+]?\\d*[.]?\\d+[%]?)\\s*\\)$/i;\n/**\n * Returns an RgbColor or RgbaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a RgbColor or RgbaColor object back to a string.\n *\n * @example\n * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1\n * const color1 = parseToRgb('rgb(255, 0, 0)');\n * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2\n * const color2 = parseToRgb('hsla(210, 10%, 40%, 0.75)');\n */ function parseToRgb(color) {\n    if (typeof color !== \"string\") {\n        throw new PolishedError(3);\n    }\n    var normalizedColor = nameToHex(color);\n    if (normalizedColor.match(hexRegex)) {\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n            green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n            blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16)\n        };\n    }\n    if (normalizedColor.match(hexRgbaRegex)) {\n        var alpha = parseFloat((parseInt(\"\" + normalizedColor[7] + normalizedColor[8], 16) / 255).toFixed(2));\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[2], 16),\n            green: parseInt(\"\" + normalizedColor[3] + normalizedColor[4], 16),\n            blue: parseInt(\"\" + normalizedColor[5] + normalizedColor[6], 16),\n            alpha: alpha\n        };\n    }\n    if (normalizedColor.match(reducedHexRegex)) {\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n            green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n            blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16)\n        };\n    }\n    if (normalizedColor.match(reducedRgbaHexRegex)) {\n        var _alpha = parseFloat((parseInt(\"\" + normalizedColor[4] + normalizedColor[4], 16) / 255).toFixed(2));\n        return {\n            red: parseInt(\"\" + normalizedColor[1] + normalizedColor[1], 16),\n            green: parseInt(\"\" + normalizedColor[2] + normalizedColor[2], 16),\n            blue: parseInt(\"\" + normalizedColor[3] + normalizedColor[3], 16),\n            alpha: _alpha\n        };\n    }\n    var rgbMatched = rgbRegex.exec(normalizedColor);\n    if (rgbMatched) {\n        return {\n            red: parseInt(\"\" + rgbMatched[1], 10),\n            green: parseInt(\"\" + rgbMatched[2], 10),\n            blue: parseInt(\"\" + rgbMatched[3], 10)\n        };\n    }\n    var rgbaMatched = rgbaRegex.exec(normalizedColor.substring(0, 50));\n    if (rgbaMatched) {\n        return {\n            red: parseInt(\"\" + rgbaMatched[1], 10),\n            green: parseInt(\"\" + rgbaMatched[2], 10),\n            blue: parseInt(\"\" + rgbaMatched[3], 10),\n            alpha: parseFloat(\"\" + rgbaMatched[4]) > 1 ? parseFloat(\"\" + rgbaMatched[4]) / 100 : parseFloat(\"\" + rgbaMatched[4])\n        };\n    }\n    var hslMatched = hslRegex.exec(normalizedColor);\n    if (hslMatched) {\n        var hue = parseInt(\"\" + hslMatched[1], 10);\n        var saturation = parseInt(\"\" + hslMatched[2], 10) / 100;\n        var lightness = parseInt(\"\" + hslMatched[3], 10) / 100;\n        var rgbColorString = \"rgb(\" + hslToRgb(hue, saturation, lightness) + \")\";\n        var hslRgbMatched = rgbRegex.exec(rgbColorString);\n        if (!hslRgbMatched) {\n            throw new PolishedError(4, normalizedColor, rgbColorString);\n        }\n        return {\n            red: parseInt(\"\" + hslRgbMatched[1], 10),\n            green: parseInt(\"\" + hslRgbMatched[2], 10),\n            blue: parseInt(\"\" + hslRgbMatched[3], 10)\n        };\n    }\n    var hslaMatched = hslaRegex.exec(normalizedColor.substring(0, 50));\n    if (hslaMatched) {\n        var _hue = parseInt(\"\" + hslaMatched[1], 10);\n        var _saturation = parseInt(\"\" + hslaMatched[2], 10) / 100;\n        var _lightness = parseInt(\"\" + hslaMatched[3], 10) / 100;\n        var _rgbColorString = \"rgb(\" + hslToRgb(_hue, _saturation, _lightness) + \")\";\n        var _hslRgbMatched = rgbRegex.exec(_rgbColorString);\n        if (!_hslRgbMatched) {\n            throw new PolishedError(4, normalizedColor, _rgbColorString);\n        }\n        return {\n            red: parseInt(\"\" + _hslRgbMatched[1], 10),\n            green: parseInt(\"\" + _hslRgbMatched[2], 10),\n            blue: parseInt(\"\" + _hslRgbMatched[3], 10),\n            alpha: parseFloat(\"\" + hslaMatched[4]) > 1 ? parseFloat(\"\" + hslaMatched[4]) / 100 : parseFloat(\"\" + hslaMatched[4])\n        };\n    }\n    throw new PolishedError(5);\n}\nfunction rgbToHsl(color) {\n    // make sure rgb are contained in a set of [0, 255]\n    var red = color.red / 255;\n    var green = color.green / 255;\n    var blue = color.blue / 255;\n    var max = Math.max(red, green, blue);\n    var min = Math.min(red, green, blue);\n    var lightness = (max + min) / 2;\n    if (max === min) {\n        // achromatic\n        if (color.alpha !== undefined) {\n            return {\n                hue: 0,\n                saturation: 0,\n                lightness: lightness,\n                alpha: color.alpha\n            };\n        } else {\n            return {\n                hue: 0,\n                saturation: 0,\n                lightness: lightness\n            };\n        }\n    }\n    var hue;\n    var delta = max - min;\n    var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n    switch(max){\n        case red:\n            hue = (green - blue) / delta + (green < blue ? 6 : 0);\n            break;\n        case green:\n            hue = (blue - red) / delta + 2;\n            break;\n        default:\n            // blue case\n            hue = (red - green) / delta + 4;\n            break;\n    }\n    hue *= 60;\n    if (color.alpha !== undefined) {\n        return {\n            hue: hue,\n            saturation: saturation,\n            lightness: lightness,\n            alpha: color.alpha\n        };\n    }\n    return {\n        hue: hue,\n        saturation: saturation,\n        lightness: lightness\n    };\n}\n/**\n * Returns an HslColor or HslaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a HslColor or HslaColor object back to a string.\n *\n * @example\n * // Assigns `{ hue: 0, saturation: 1, lightness: 0.5 }` to color1\n * const color1 = parseToHsl('rgb(255, 0, 0)');\n * // Assigns `{ hue: 128, saturation: 1, lightness: 0.5, alpha: 0.75 }` to color2\n * const color2 = parseToHsl('hsla(128, 100%, 50%, 0.75)');\n */ function parseToHsl(color) {\n    // Note: At a later stage we can optimize this function as right now a hsl\n    // color would be parsed converted to rgb values and converted back to hsl.\n    return rgbToHsl(parseToRgb(color));\n}\n/**\n * Reduces hex values if possible e.g. #ff8866 to #f86\n * @private\n */ var reduceHexValue = function reduceHexValue(value) {\n    if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {\n        return \"#\" + value[1] + value[3] + value[5];\n    }\n    return value;\n};\nvar reduceHexValue$1 = reduceHexValue;\nfunction numberToHex(value) {\n    var hex = value.toString(16);\n    return hex.length === 1 ? \"0\" + hex : hex;\n}\nfunction colorToHex(color) {\n    return numberToHex(Math.round(color * 255));\n}\nfunction convertToHex(red, green, blue) {\n    return reduceHexValue$1(\"#\" + colorToHex(red) + colorToHex(green) + colorToHex(blue));\n}\nfunction hslToHex(hue, saturation, lightness) {\n    return hslToRgb(hue, saturation, lightness, convertToHex);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsl(359, 0.75, 0.4),\n *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsl(359, 0.75, 0.4)};\n *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#b3191c\";\n *   background: \"#b3191c\";\n * }\n */ function hsl(value, saturation, lightness) {\n    if (typeof value === \"number\" && typeof saturation === \"number\" && typeof lightness === \"number\") {\n        return hslToHex(value, saturation, lightness);\n    } else if (typeof value === \"object\" && saturation === undefined && lightness === undefined) {\n        return hslToHex(value.hue, value.saturation, value.lightness);\n    }\n    throw new PolishedError(1);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsla(359, 0.75, 0.4, 0.7),\n *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),\n *   background: hsla(359, 0.75, 0.4, 1),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsla(359, 0.75, 0.4, 0.7)};\n *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};\n *   background: ${hsla(359, 0.75, 0.4, 1)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"#b3191c\";\n * }\n */ function hsla(value, saturation, lightness, alpha) {\n    if (typeof value === \"number\" && typeof saturation === \"number\" && typeof lightness === \"number\" && typeof alpha === \"number\") {\n        return alpha >= 1 ? hslToHex(value, saturation, lightness) : \"rgba(\" + hslToRgb(value, saturation, lightness) + \",\" + alpha + \")\";\n    } else if (typeof value === \"object\" && saturation === undefined && lightness === undefined && alpha === undefined) {\n        return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : \"rgba(\" + hslToRgb(value.hue, value.saturation, value.lightness) + \",\" + value.alpha + \")\";\n    }\n    throw new PolishedError(2);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgb(255, 205, 100),\n *   background: rgb({ red: 255, green: 205, blue: 100 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgb(255, 205, 100)};\n *   background: ${rgb({ red: 255, green: 205, blue: 100 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffcd64\";\n *   background: \"#ffcd64\";\n * }\n */ function rgb(value, green, blue) {\n    if (typeof value === \"number\" && typeof green === \"number\" && typeof blue === \"number\") {\n        return reduceHexValue$1(\"#\" + numberToHex(value) + numberToHex(green) + numberToHex(blue));\n    } else if (typeof value === \"object\" && green === undefined && blue === undefined) {\n        return reduceHexValue$1(\"#\" + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));\n    }\n    throw new PolishedError(6);\n}\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgba(255, 205, 100, 0.7),\n *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),\n *   background: rgba(255, 205, 100, 1),\n *   background: rgba('#ffffff', 0.4),\n *   background: rgba('black', 0.7),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgba(255, 205, 100, 0.7)};\n *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};\n *   background: ${rgba(255, 205, 100, 1)};\n *   background: ${rgba('#ffffff', 0.4)};\n *   background: ${rgba('black', 0.7)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,255,255,0.4)\";\n *   background: \"rgba(0,0,0,0.7)\";\n * }\n */ function rgba(firstValue, secondValue, thirdValue, fourthValue) {\n    if (typeof firstValue === \"string\" && typeof secondValue === \"number\") {\n        var rgbValue = parseToRgb(firstValue);\n        return \"rgba(\" + rgbValue.red + \",\" + rgbValue.green + \",\" + rgbValue.blue + \",\" + secondValue + \")\";\n    } else if (typeof firstValue === \"number\" && typeof secondValue === \"number\" && typeof thirdValue === \"number\" && typeof fourthValue === \"number\") {\n        return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : \"rgba(\" + firstValue + \",\" + secondValue + \",\" + thirdValue + \",\" + fourthValue + \")\";\n    } else if (typeof firstValue === \"object\" && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {\n        return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : \"rgba(\" + firstValue.red + \",\" + firstValue.green + \",\" + firstValue.blue + \",\" + firstValue.alpha + \")\";\n    }\n    throw new PolishedError(7);\n}\nvar isRgb = function isRgb(color) {\n    return typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\" && (typeof color.alpha !== \"number\" || typeof color.alpha === \"undefined\");\n};\nvar isRgba = function isRgba(color) {\n    return typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\" && typeof color.alpha === \"number\";\n};\nvar isHsl = function isHsl(color) {\n    return typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\" && (typeof color.alpha !== \"number\" || typeof color.alpha === \"undefined\");\n};\nvar isHsla = function isHsla(color) {\n    return typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\" && typeof color.alpha === \"number\";\n};\n/**\n * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: toColorString({ red: 255, green: 205, blue: 100 }),\n *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */ function toColorString(color) {\n    if (typeof color !== \"object\") throw new PolishedError(8);\n    if (isRgba(color)) return rgba(color);\n    if (isRgb(color)) return rgb(color);\n    if (isHsla(color)) return hsla(color);\n    if (isHsl(color)) return hsl(color);\n    throw new PolishedError(8);\n}\n// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-unused-vars\n// eslint-disable-next-line no-redeclare\nfunction curried(f, length, acc) {\n    return function fn() {\n        // eslint-disable-next-line prefer-rest-params\n        var combined = acc.concat(Array.prototype.slice.call(arguments));\n        return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);\n    };\n}\n// eslint-disable-next-line no-redeclare\nfunction curry(f) {\n    // eslint-disable-line no-redeclare\n    return curried(f, f.length, []);\n}\n/**\n * Changes the hue of the color. Hue is a number between 0 to 360. The first\n * argument for adjustHue is the amount of degrees the color is rotated around\n * the color wheel, always producing a positive hue value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: adjustHue(180, '#448'),\n *   background: adjustHue('180', 'rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${adjustHue(180, '#448')};\n *   background: ${adjustHue('180', 'rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#888844\";\n *   background: \"rgba(136,136,68,0.7)\";\n * }\n */ function adjustHue(degree, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        hue: hslColor.hue + parseFloat(degree)\n    }));\n}\n// prettier-ignore\nvar curriedAdjustHue = curry /* ::<number | string, string, string> */ (adjustHue);\nvar curriedAdjustHue$1 = curriedAdjustHue;\n/**\n * Returns the complement of the provided color. This is identical to adjustHue(180, <color>).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: complement('#448'),\n *   background: complement('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${complement('#448')};\n *   background: ${complement('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#884\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */ function complement(color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        hue: (hslColor.hue + 180) % 360\n    }));\n}\nfunction guard(lowerBoundary, upperBoundary, value) {\n    return Math.max(lowerBoundary, Math.min(upperBoundary, value));\n}\n/**\n * Returns a string value for the darkened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: darken(0.2, '#FFCD64'),\n *   background: darken('0.2', 'rgba(255,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${darken(0.2, '#FFCD64')};\n *   background: ${darken('0.2', 'rgba(255,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffbd31\";\n *   background: \"rgba(255,189,49,0.7)\";\n * }\n */ function darken(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        lightness: guard(0, 1, hslColor.lightness - parseFloat(amount))\n    }));\n}\n// prettier-ignore\nvar curriedDarken = curry /* ::<number | string, string, string> */ (darken);\nvar curriedDarken$1 = curriedDarken;\n/**\n * Decreases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the desaturate function is the amount by how much the color\n * intensity should be decreased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: desaturate(0.2, '#CCCD64'),\n *   background: desaturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${desaturate(0.2, '#CCCD64')};\n *   background: ${desaturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#b8b979\";\n *   background: \"rgba(184,185,121,0.7)\";\n * }\n */ function desaturate(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        saturation: guard(0, 1, hslColor.saturation - parseFloat(amount))\n    }));\n}\n// prettier-ignore\nvar curriedDesaturate = curry /* ::<number | string, string, string> */ (desaturate);\nvar curriedDesaturate$1 = curriedDesaturate;\n/**\n * Returns a number (float) representing the luminance of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff',\n *   background: getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)',\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff'};\n *   background: ${getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)'};\n *\n * // CSS in JS Output\n *\n * div {\n *   background: \"#CCCD64\";\n *   background: \"rgba(58, 133, 255, 1)\";\n * }\n */ function getLuminance(color) {\n    if (color === \"transparent\") return 0;\n    var rgbColor = parseToRgb(color);\n    var _Object$keys$map = Object.keys(rgbColor).map(function(key) {\n        var channel = rgbColor[key] / 255;\n        return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);\n    }), r = _Object$keys$map[0], g = _Object$keys$map[1], b = _Object$keys$map[2];\n    return parseFloat((0.2126 * r + 0.7152 * g + 0.0722 * b).toFixed(3));\n}\n/**\n * Returns the contrast ratio between two colors based on\n * [W3's recommended equation for calculating contrast](http://www.w3.org/TR/WCAG20/#contrast-ratiodef).\n *\n * @example\n * const contrastRatio = getContrast('#444', '#fff');\n */ function getContrast(color1, color2) {\n    var luminance1 = getLuminance(color1);\n    var luminance2 = getLuminance(color2);\n    return parseFloat((luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05)).toFixed(2));\n}\n/**\n * Converts the color to a grayscale, by reducing its saturation to 0.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: grayscale('#CCCD64'),\n *   background: grayscale('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${grayscale('#CCCD64')};\n *   background: ${grayscale('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#999\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */ function grayscale(color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        saturation: 0\n    }));\n}\n/**\n * Converts a HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hslToColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${hslToColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */ function hslToColorString(color) {\n    if (typeof color === \"object\" && typeof color.hue === \"number\" && typeof color.saturation === \"number\" && typeof color.lightness === \"number\") {\n        if (color.alpha && typeof color.alpha === \"number\") {\n            return hsla({\n                hue: color.hue,\n                saturation: color.saturation,\n                lightness: color.lightness,\n                alpha: color.alpha\n            });\n        }\n        return hsl({\n            hue: color.hue,\n            saturation: color.saturation,\n            lightness: color.lightness\n        });\n    }\n    throw new PolishedError(45);\n}\n/**\n * Inverts the red, green and blue values of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: invert('#CCCD64'),\n *   background: invert('rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${invert('#CCCD64')};\n *   background: ${invert('rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#33329b\";\n *   background: \"rgba(154,155,50,0.7)\";\n * }\n */ function invert(color) {\n    if (color === \"transparent\") return color;\n    // parse color string to rgb\n    var value = parseToRgb(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, value, {\n        red: 255 - value.red,\n        green: 255 - value.green,\n        blue: 255 - value.blue\n    }));\n}\n/**\n * Returns a string value for the lightened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: lighten(0.2, '#CCCD64'),\n *   background: lighten('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${lighten(0.2, '#FFCD64')};\n *   background: ${lighten('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e5e6b1\";\n *   background: \"rgba(229,230,177,0.7)\";\n * }\n */ function lighten(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        lightness: guard(0, 1, hslColor.lightness + parseFloat(amount))\n    }));\n}\n// prettier-ignore\nvar curriedLighten = curry /* ::<number | string, string, string> */ (lighten);\nvar curriedLighten$1 = curriedLighten;\n/**\n * Determines which contrast guidelines have been met for two colors.\n * Based on the [contrast calculations recommended by W3](https://www.w3.org/WAI/WCAG21/Understanding/contrast-enhanced.html).\n *\n * @example\n * const scores = meetsContrastGuidelines('#444', '#fff');\n */ function meetsContrastGuidelines(color1, color2) {\n    var contrastRatio = getContrast(color1, color2);\n    return {\n        AA: contrastRatio >= 4.5,\n        AALarge: contrastRatio >= 3,\n        AAA: contrastRatio >= 7,\n        AAALarge: contrastRatio >= 4.5\n    };\n}\n/**\n * Mixes the two provided colors together by calculating the average of each of the RGB components weighted to the first color by the provided weight.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: mix(0.5, '#f00', '#00f')\n *   background: mix(0.25, '#f00', '#00f')\n *   background: mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${mix(0.5, '#f00', '#00f')};\n *   background: ${mix(0.25, '#f00', '#00f')};\n *   background: ${mix('0.5', 'rgba(255, 0, 0, 0.5)', '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#7f007f\";\n *   background: \"#3f00bf\";\n *   background: \"rgba(63, 0, 191, 0.75)\";\n * }\n */ function mix(weight, color, otherColor) {\n    if (color === \"transparent\") return otherColor;\n    if (otherColor === \"transparent\") return color;\n    if (weight === 0) return otherColor;\n    var parsedColor1 = parseToRgb(color);\n    var color1 = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor1, {\n        alpha: typeof parsedColor1.alpha === \"number\" ? parsedColor1.alpha : 1\n    });\n    var parsedColor2 = parseToRgb(otherColor);\n    var color2 = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor2, {\n        alpha: typeof parsedColor2.alpha === \"number\" ? parsedColor2.alpha : 1\n    });\n    // The formula is copied from the original Sass implementation:\n    // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method\n    var alphaDelta = color1.alpha - color2.alpha;\n    var x = parseFloat(weight) * 2 - 1;\n    var y = x * alphaDelta === -1 ? x : x + alphaDelta;\n    var z = 1 + x * alphaDelta;\n    var weight1 = (y / z + 1) / 2.0;\n    var weight2 = 1 - weight1;\n    var mixedColor = {\n        red: Math.floor(color1.red * weight1 + color2.red * weight2),\n        green: Math.floor(color1.green * weight1 + color2.green * weight2),\n        blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),\n        alpha: color1.alpha * parseFloat(weight) + color2.alpha * (1 - parseFloat(weight))\n    };\n    return rgba(mixedColor);\n}\n// prettier-ignore\nvar curriedMix = curry /* ::<number | string, string, string, string> */ (mix);\nvar mix$1 = curriedMix;\n/**\n * Increases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');\n *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),\n *   background: opacify('0.5', 'rgba(255, 0, 0, 0.2)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};\n *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},\n *   background: ${opacify('0.5', 'rgba(255, 0, 0, 0.2)')},\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#fff\";\n *   background: \"rgba(255,255,255,0.7)\";\n *   background: \"rgba(255,0,0,0.7)\";\n * }\n */ function opacify(amount, color) {\n    if (color === \"transparent\") return color;\n    var parsedColor = parseToRgb(color);\n    var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : 1;\n    var colorWithAlpha = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor, {\n        alpha: guard(0, 1, (alpha * 100 + parseFloat(amount) * 100) / 100)\n    });\n    return rgba(colorWithAlpha);\n}\n// prettier-ignore\nvar curriedOpacify = curry /* ::<number | string, string, string> */ (opacify);\nvar curriedOpacify$1 = curriedOpacify;\nvar defaultReturnIfLightColor = \"#000\";\nvar defaultReturnIfDarkColor = \"#fff\";\n/**\n * Returns black or white (or optional passed colors) for best\n * contrast depending on the luminosity of the given color.\n * When passing custom return colors, strict mode ensures that the\n * return color always meets or exceeds WCAG level AA or greater. If this test\n * fails, the default return color (black or white) is returned in place of the\n * custom return color. You can optionally turn off strict mode.\n *\n * Follows [W3C specs for readability](https://www.w3.org/TR/WCAG20-TECHS/G18.html).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   color: readableColor('#000'),\n *   color: readableColor('black', '#001', '#ff8'),\n *   color: readableColor('white', '#001', '#ff8'),\n *   color: readableColor('red', '#333', '#ddd', true)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   color: ${readableColor('#000')};\n *   color: ${readableColor('black', '#001', '#ff8')};\n *   color: ${readableColor('white', '#001', '#ff8')};\n *   color: ${readableColor('red', '#333', '#ddd', true)};\n * `\n *\n * // CSS in JS Output\n * element {\n *   color: \"#fff\";\n *   color: \"#ff8\";\n *   color: \"#001\";\n *   color: \"#000\";\n * }\n */ function readableColor(color, returnIfLightColor, returnIfDarkColor, strict) {\n    if (returnIfLightColor === void 0) {\n        returnIfLightColor = defaultReturnIfLightColor;\n    }\n    if (returnIfDarkColor === void 0) {\n        returnIfDarkColor = defaultReturnIfDarkColor;\n    }\n    if (strict === void 0) {\n        strict = true;\n    }\n    var isColorLight = getLuminance(color) > 0.179;\n    var preferredReturnColor = isColorLight ? returnIfLightColor : returnIfDarkColor;\n    if (!strict || getContrast(color, preferredReturnColor) >= 4.5) {\n        return preferredReturnColor;\n    }\n    return isColorLight ? defaultReturnIfLightColor : defaultReturnIfDarkColor;\n}\n/**\n * Converts a RgbColor or RgbaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb` or `rgba`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100 }),\n *   background: rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${rgbToColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n * }\n */ function rgbToColorString(color) {\n    if (typeof color === \"object\" && typeof color.red === \"number\" && typeof color.green === \"number\" && typeof color.blue === \"number\") {\n        if (typeof color.alpha === \"number\") {\n            return rgba({\n                red: color.red,\n                green: color.green,\n                blue: color.blue,\n                alpha: color.alpha\n            });\n        }\n        return rgb({\n            red: color.red,\n            green: color.green,\n            blue: color.blue\n        });\n    }\n    throw new PolishedError(46);\n}\n/**\n * Increases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the saturate function is the amount by how much the color\n * intensity should be increased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: saturate(0.2, '#CCCD64'),\n *   background: saturate('0.2', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${saturate(0.2, '#FFCD64')};\n *   background: ${saturate('0.2', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e0e250\";\n *   background: \"rgba(224,226,80,0.7)\";\n * }\n */ function saturate(amount, color) {\n    if (color === \"transparent\") return color;\n    var hslColor = parseToHsl(color);\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, hslColor, {\n        saturation: guard(0, 1, hslColor.saturation + parseFloat(amount))\n    }));\n}\n// prettier-ignore\nvar curriedSaturate = curry /* ::<number | string, string, string> */ (saturate);\nvar curriedSaturate$1 = curriedSaturate;\n/**\n * Sets the hue of a color to the provided value. The hue range can be\n * from 0 and 359.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setHue(42, '#CCCD64'),\n *   background: setHue('244', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setHue(42, '#CCCD64')};\n *   background: ${setHue('244', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#cdae64\";\n *   background: \"rgba(107,100,205,0.7)\";\n * }\n */ function setHue(hue, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        hue: parseFloat(hue)\n    }));\n}\n// prettier-ignore\nvar curriedSetHue = curry /* ::<number | string, string, string> */ (setHue);\nvar curriedSetHue$1 = curriedSetHue;\n/**\n * Sets the lightness of a color to the provided value. The lightness range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setLightness(0.2, '#CCCD64'),\n *   background: setLightness('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setLightness(0.2, '#CCCD64')};\n *   background: ${setLightness('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#4d4d19\";\n *   background: \"rgba(223,224,159,0.7)\";\n * }\n */ function setLightness(lightness, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        lightness: parseFloat(lightness)\n    }));\n}\n// prettier-ignore\nvar curriedSetLightness = curry /* ::<number | string, string, string> */ (setLightness);\nvar curriedSetLightness$1 = curriedSetLightness;\n/**\n * Sets the saturation of a color to the provided value. The saturation range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setSaturation(0.2, '#CCCD64'),\n *   background: setSaturation('0.75', 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setSaturation(0.2, '#CCCD64')};\n *   background: ${setSaturation('0.75', 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#adad84\";\n *   background: \"rgba(228,229,76,0.7)\";\n * }\n */ function setSaturation(saturation, color) {\n    if (color === \"transparent\") return color;\n    return toColorString((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parseToHsl(color), {\n        saturation: parseFloat(saturation)\n    }));\n}\n// prettier-ignore\nvar curriedSetSaturation = curry /* ::<number | string, string, string> */ (setSaturation);\nvar curriedSetSaturation$1 = curriedSetSaturation;\n/**\n * Shades a color by mixing it with black. `shade` can produce\n * hue shifts, where as `darken` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: shade(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${shade(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#00003f\";\n * }\n */ function shade(percentage, color) {\n    if (color === \"transparent\") return color;\n    return mix$1(parseFloat(percentage), \"rgb(0, 0, 0)\", color);\n}\n// prettier-ignore\nvar curriedShade = curry /* ::<number | string, string, string> */ (shade);\nvar curriedShade$1 = curriedShade;\n/**\n * Tints a color by mixing it with white. `tint` can produce\n * hue shifts, where as `lighten` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: tint(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${tint(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#bfbfff\";\n * }\n */ function tint(percentage, color) {\n    if (color === \"transparent\") return color;\n    return mix$1(parseFloat(percentage), \"rgb(255, 255, 255)\", color);\n}\n// prettier-ignore\nvar curriedTint = curry /* ::<number | string, string, string> */ (tint);\nvar curriedTint$1 = curriedTint;\n/**\n * Decreases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: transparentize(0.1, '#fff'),\n *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),\n *   background: transparentize('0.5', 'rgba(255, 0, 0, 0.8)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${transparentize(0.1, '#fff')};\n *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')};\n *   background: ${transparentize('0.5', 'rgba(255, 0, 0, 0.8)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,255,255,0.9)\";\n *   background: \"rgba(255,255,255,0.8)\";\n *   background: \"rgba(255,0,0,0.3)\";\n * }\n */ function transparentize(amount, color) {\n    if (color === \"transparent\") return color;\n    var parsedColor = parseToRgb(color);\n    var alpha = typeof parsedColor.alpha === \"number\" ? parsedColor.alpha : 1;\n    var colorWithAlpha = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, parsedColor, {\n        alpha: guard(0, 1, +(alpha * 100 - parseFloat(amount) * 100).toFixed(2) / 100)\n    });\n    return rgba(colorWithAlpha);\n}\n// prettier-ignore\nvar curriedTransparentize = curry /* ::<number | string, string, string> */ (transparentize);\nvar curriedTransparentize$1 = curriedTransparentize;\n/**\n * Shorthand for easily setting the animation property. Allows either multiple arrays with animations\n * or a single animation spread over the arguments.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out, colorchange 2s'\n * }\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation('rotate', '1s', 'ease-in-out')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation('rotate', '1s', 'ease-in-out')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out'\n * }\n */ function animation() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    // Allow single or multiple animations passed\n    var multiMode = Array.isArray(args[0]);\n    if (!multiMode && args.length > 8) {\n        throw new PolishedError(64);\n    }\n    var code = args.map(function(arg) {\n        if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {\n            throw new PolishedError(65);\n        }\n        if (Array.isArray(arg) && arg.length > 8) {\n            throw new PolishedError(66);\n        }\n        return Array.isArray(arg) ? arg.join(\" \") : arg;\n    }).join(\", \");\n    return {\n        animation: code\n    };\n}\n/**\n * Shorthand that accepts any number of backgroundImage values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'backgroundImage': 'url(\"/image/background.jpg\"), linear-gradient(red, green)'\n * }\n */ function backgroundImages() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    return {\n        backgroundImage: properties.join(\", \")\n    };\n}\n/**\n * Shorthand that accepts any number of background values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'background': 'url(\"/image/background.jpg\"), linear-gradient(red, green), center no-repeat'\n * }\n */ function backgrounds() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    return {\n        background: properties.join(\", \")\n    };\n}\nvar sideMap = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\n/**\n * Shorthand for the border property that splits out individual properties for use with tools like Fela and Styletron. A side keyword can optionally be passed to target only one side's border properties.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...border('1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderColor': 'red',\n *   'borderStyle': 'solid',\n *   'borderWidth': `1px`,\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...border('top', '1px', 'solid', 'red')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${border('top', '1px', 'solid', 'red')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderTopStyle': 'solid',\n *   'borderTopWidth': `1px`,\n * }\n */ function border(sideKeyword) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    if (typeof sideKeyword === \"string\" && sideMap.indexOf(sideKeyword) >= 0) {\n        var _ref;\n        return _ref = {}, _ref[\"border\" + capitalizeString(sideKeyword) + \"Width\"] = values[0], _ref[\"border\" + capitalizeString(sideKeyword) + \"Style\"] = values[1], _ref[\"border\" + capitalizeString(sideKeyword) + \"Color\"] = values[2], _ref;\n    } else {\n        values.unshift(sideKeyword);\n        return {\n            borderWidth: values[0],\n            borderStyle: values[1],\n            borderColor: values[2]\n        };\n    }\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderColor('red', 'green', 'blue', 'yellow')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderColor('red', 'green', 'blue', 'yellow')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderRightColor': 'green',\n *   'borderBottomColor': 'blue',\n *   'borderLeftColor': 'yellow'\n * }\n */ function borderColor() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderColor\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts a value for side and a value for radius and applies the radius value to both corners of the side.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderRadius('top', '5px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderRadius('top', '5px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopRightRadius': '5px',\n *   'borderTopLeftRadius': '5px',\n * }\n */ function borderRadius(side, radius) {\n    var uppercaseSide = capitalizeString(side);\n    if (!radius && radius !== 0) {\n        throw new PolishedError(62);\n    }\n    if (uppercaseSide === \"Top\" || uppercaseSide === \"Bottom\") {\n        var _ref;\n        return _ref = {}, _ref[\"border\" + uppercaseSide + \"RightRadius\"] = radius, _ref[\"border\" + uppercaseSide + \"LeftRadius\"] = radius, _ref;\n    }\n    if (uppercaseSide === \"Left\" || uppercaseSide === \"Right\") {\n        var _ref2;\n        return _ref2 = {}, _ref2[\"borderTop\" + uppercaseSide + \"Radius\"] = radius, _ref2[\"borderBottom\" + uppercaseSide + \"Radius\"] = radius, _ref2;\n    }\n    throw new PolishedError(63);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderStyle('solid', 'dashed', 'dotted', 'double')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderStyle('solid', 'dashed', 'dotted', 'double')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopStyle': 'solid',\n *   'borderRightStyle': 'dashed',\n *   'borderBottomStyle': 'dotted',\n *   'borderLeftStyle': 'double'\n * }\n */ function borderStyle() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderStyle\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderWidth('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderWidth('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopWidth': '12px',\n *   'borderRightWidth': '24px',\n *   'borderBottomWidth': '36px',\n *   'borderLeftWidth': '48px'\n * }\n */ function borderWidth() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"borderWidth\"\n    ].concat(values));\n}\nfunction generateSelectors(template, state) {\n    var stateSuffix = state ? \":\" + state : \"\";\n    return template(stateSuffix);\n}\n/**\n * Function helper that adds an array of states to a template of selectors. Used in textInputs and buttons.\n * @private\n */ function statefulSelectors(states, template, stateMap) {\n    if (!template) throw new PolishedError(67);\n    if (states.length === 0) return generateSelectors(template, null);\n    var selectors = [];\n    for(var i = 0; i < states.length; i += 1){\n        if (stateMap && stateMap.indexOf(states[i]) < 0) {\n            throw new PolishedError(68);\n        }\n        selectors.push(generateSelectors(template, states[i]));\n    }\n    selectors = selectors.join(\",\");\n    return selectors;\n}\nvar stateMap$1 = [\n    undefined,\n    null,\n    \"active\",\n    \"focus\",\n    \"hover\"\n];\nfunction template$1(state) {\n    return \"button\" + state + ',\\n  input[type=\"button\"]' + state + ',\\n  input[type=\"reset\"]' + state + ',\\n  input[type=\"submit\"]' + state;\n}\n/**\n * Populates selectors that target all buttons. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [buttons('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${buttons('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'button:active,\n *  'input[type=\"button\"]:active,\n *  'input[type=\\\"reset\\\"]:active,\n *  'input[type=\\\"submit\\\"]:active: {\n *   'border': 'none'\n * }\n */ function buttons() {\n    for(var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++){\n        states[_key] = arguments[_key];\n    }\n    return statefulSelectors(states, template$1, stateMap$1);\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...margin('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${margin('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'marginTop': '12px',\n *   'marginRight': '24px',\n *   'marginBottom': '36px',\n *   'marginLeft': '48px'\n * }\n */ function margin() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"margin\"\n    ].concat(values));\n}\n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...padding('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${padding('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */ function padding() {\n    for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n        values[_key] = arguments[_key];\n    }\n    return directionalProperty.apply(void 0, [\n        \"padding\"\n    ].concat(values));\n}\nvar positionMap = [\n    \"absolute\",\n    \"fixed\",\n    \"relative\",\n    \"static\",\n    \"sticky\"\n];\n/**\n * Shorthand accepts up to five values, including null to skip a value, and maps them to their respective directions. The first value can optionally be a position keyword.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...position('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...position('absolute', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('absolute', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'position': 'absolute',\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n */ function position(firstValue) {\n    for(var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        values[_key - 1] = arguments[_key];\n    }\n    if (positionMap.indexOf(firstValue) >= 0 && firstValue) {\n        return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, directionalProperty.apply(void 0, [\n            \"\"\n        ].concat(values)), {\n            position: firstValue\n        });\n    } else {\n        return directionalProperty.apply(void 0, [\n            \"\",\n            firstValue\n        ].concat(values));\n    }\n}\n/**\n * Shorthand to set the height and width properties in a single statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...size('300px', '250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${size('300px', '250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'height': '300px',\n *   'width': '250px',\n * }\n */ function size(height, width) {\n    if (width === void 0) {\n        width = height;\n    }\n    return {\n        height: height,\n        width: width\n    };\n}\nvar stateMap = [\n    undefined,\n    null,\n    \"active\",\n    \"focus\",\n    \"hover\"\n];\nfunction template(state) {\n    return 'input[type=\"color\"]' + state + ',\\n    input[type=\"date\"]' + state + ',\\n    input[type=\"datetime\"]' + state + ',\\n    input[type=\"datetime-local\"]' + state + ',\\n    input[type=\"email\"]' + state + ',\\n    input[type=\"month\"]' + state + ',\\n    input[type=\"number\"]' + state + ',\\n    input[type=\"password\"]' + state + ',\\n    input[type=\"search\"]' + state + ',\\n    input[type=\"tel\"]' + state + ',\\n    input[type=\"text\"]' + state + ',\\n    input[type=\"time\"]' + state + ',\\n    input[type=\"url\"]' + state + ',\\n    input[type=\"week\"]' + state + \",\\n    input:not([type])\" + state + \",\\n    textarea\" + state;\n}\n/**\n * Populates selectors that target all text inputs. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [textInputs('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${textInputs('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'input[type=\"color\"]:active,\n *  input[type=\"date\"]:active,\n *  input[type=\"datetime\"]:active,\n *  input[type=\"datetime-local\"]:active,\n *  input[type=\"email\"]:active,\n *  input[type=\"month\"]:active,\n *  input[type=\"number\"]:active,\n *  input[type=\"password\"]:active,\n *  input[type=\"search\"]:active,\n *  input[type=\"tel\"]:active,\n *  input[type=\"text\"]:active,\n *  input[type=\"time\"]:active,\n *  input[type=\"url\"]:active,\n *  input[type=\"week\"]:active,\n *  input:not([type]):active,\n *  textarea:active': {\n *   'border': 'none'\n * }\n */ function textInputs() {\n    for(var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++){\n        states[_key] = arguments[_key];\n    }\n    return statefulSelectors(states, template, stateMap);\n}\n/**\n * Accepts any number of transition values as parameters for creating a single transition statement. You may also pass an array of properties as the first parameter that you would like to apply the same transition values to (second parameter).\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s'),\n *   ...transitions(['color', 'background-color'], '2.0s ease-in 2s')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s')};\n *   ${transitions(['color', 'background-color'], '2.0s ease-in 2s'),};\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'transition': 'opacity 1.0s ease-in 0s, width 2.0s ease-in 2s'\n *   'transition': 'color 2.0s ease-in 2s, background-color 2.0s ease-in 2s',\n * }\n */ function transitions() {\n    for(var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++){\n        properties[_key] = arguments[_key];\n    }\n    if (Array.isArray(properties[0]) && properties.length === 2) {\n        var value = properties[1];\n        if (typeof value !== \"string\") {\n            throw new PolishedError(61);\n        }\n        var transitionsString = properties[0].map(function(property) {\n            return property + \" \" + value;\n        }).join(\", \");\n        return {\n            transition: transitionsString\n        };\n    } else {\n        return {\n            transition: properties.join(\", \")\n        };\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9saXNoZWQvZGlzdC9wb2xpc2hlZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzRCO0FBQ2hCO0FBQ0k7QUFDc0I7QUFFaEcsU0FBU0s7SUFDUCxJQUFJQztJQUNKLE9BQU9BLE9BQU9DLFVBQVVDLE1BQU0sR0FBRyxHQUFHRixPQUFPLEtBQUtDLFVBQVVDLE1BQU0sSUFBSUYsT0FBT0csWUFBWUYsU0FBUyxDQUFDRCxLQUFLO0FBQ3hHO0FBQ0EsU0FBU0ksU0FBU0MsQ0FBQztJQUNqQixPQUFPLENBQUNBO0FBQ1Y7QUFDQSxTQUFTQyxTQUFTRCxDQUFDLEVBQUVFLENBQUM7SUFDcEIsT0FBT0YsSUFBSUU7QUFDYjtBQUNBLFNBQVNDLFlBQVlILENBQUMsRUFBRUUsQ0FBQztJQUN2QixPQUFPRixJQUFJRTtBQUNiO0FBQ0EsU0FBU0UsZUFBZUosQ0FBQyxFQUFFRSxDQUFDO0lBQzFCLE9BQU9GLElBQUlFO0FBQ2I7QUFDQSxTQUFTRyxTQUFTTCxDQUFDLEVBQUVFLENBQUM7SUFDcEIsT0FBT0YsSUFBSUU7QUFDYjtBQUNBLFNBQVNJO0lBQ1AsT0FBT0MsS0FBS0QsR0FBRyxDQUFDRSxLQUFLLENBQUNELE1BQU1YO0FBQzlCO0FBQ0EsU0FBU2E7SUFDUCxPQUFPRixLQUFLRSxHQUFHLENBQUNELEtBQUssQ0FBQ0QsTUFBTVg7QUFDOUI7QUFDQSxTQUFTYztJQUNQLE9BQU9DLE1BQU1DLEVBQUUsQ0FBQ0osS0FBSyxDQUFDRyxPQUFPZjtBQUMvQjtBQUNBLElBQUlpQixpQkFBaUI7SUFDbkJDLFNBQVM7UUFDUCxLQUFLO1lBQ0hDLE9BQU87Z0JBQ0xDLFFBQVE7Z0JBQ1JDLEdBQUdiO2dCQUNIYyxVQUFVO2dCQUNWQyxZQUFZO2dCQUNaQyxhQUFhO2dCQUNiQyxVQUFVO1lB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Ozs7Ozs7Ozs7OztDQXFDQyxHQUNELFNBQVNXO0lBQ1AsSUFBSyxJQUFJbHVCLE9BQU9qQyxVQUFVQyxNQUFNLEVBQUUwdkIsU0FBUyxJQUFJNXVCLE1BQU1rQixPQUFPRSxPQUFPLEdBQUdBLE9BQU9GLE1BQU1FLE9BQVE7UUFDekZ3dEIsTUFBTSxDQUFDeHRCLEtBQUssR0FBR25DLFNBQVMsQ0FBQ21DLEtBQUs7SUFDaEM7SUFDQSxPQUFPdXRCLGtCQUFrQkMsUUFBUTlhLFVBQVUrYTtBQUM3QztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FxQkMsR0FDRCxTQUFTUTtJQUNQLElBQUssSUFBSW51QixPQUFPakMsVUFBVUMsTUFBTSxFQUFFNHVCLGFBQWEsSUFBSTl0QixNQUFNa0IsT0FBT0UsT0FBTyxHQUFHQSxPQUFPRixNQUFNRSxPQUFRO1FBQzdGMHNCLFVBQVUsQ0FBQzFzQixLQUFLLEdBQUduQyxTQUFTLENBQUNtQyxLQUFLO0lBQ3BDO0lBQ0EsSUFBSXBCLE1BQU0rTyxPQUFPLENBQUMrZSxVQUFVLENBQUMsRUFBRSxLQUFLQSxXQUFXNXVCLE1BQU0sS0FBSyxHQUFHO1FBQzNELElBQUl1SSxRQUFRcW1CLFVBQVUsQ0FBQyxFQUFFO1FBQ3pCLElBQUksT0FBT3JtQixVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJL0YsY0FBYztRQUMxQjtRQUNBLElBQUk0dEIsb0JBQW9CeEIsVUFBVSxDQUFDLEVBQUUsQ0FBQ3pxQixHQUFHLENBQUMsU0FBVTRDLFFBQVE7WUFDMUQsT0FBT0EsV0FBVyxNQUFNd0I7UUFDMUIsR0FBR2hFLElBQUksQ0FBQztRQUNSLE9BQU87WUFDTDhyQixZQUFZRDtRQUNkO0lBQ0YsT0FBTztRQUNMLE9BQU87WUFDTEMsWUFBWXpCLFdBQVdycUIsSUFBSSxDQUFDO1FBQzlCO0lBQ0Y7QUFDRjtBQUVnbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy9wb2xpc2hlZC9kaXN0L3BvbGlzaGVkLmVzbS5qcz9jN2M4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZCc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgX3dyYXBOYXRpdmVTdXBlciBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS93cmFwTmF0aXZlU3VwZXInO1xuaW1wb3J0IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSc7XG5cbmZ1bmN0aW9uIGxhc3QoKSB7XG4gIHZhciBfcmVmO1xuICByZXR1cm4gX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxLCBfcmVmIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IF9yZWYgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbX3JlZl07XG59XG5mdW5jdGlvbiBuZWdhdGlvbihhKSB7XG4gIHJldHVybiAtYTtcbn1cbmZ1bmN0aW9uIGFkZGl0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgKyBiO1xufVxuZnVuY3Rpb24gc3VidHJhY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSAtIGI7XG59XG5mdW5jdGlvbiBtdWx0aXBsaWNhdGlvbihhLCBiKSB7XG4gIHJldHVybiBhICogYjtcbn1cbmZ1bmN0aW9uIGRpdmlzaW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgLyBiO1xufVxuZnVuY3Rpb24gbWF4KCkge1xuICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIG1pbigpIHtcbiAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBjb21tYSgpIHtcbiAgcmV0dXJuIEFycmF5Lm9mLmFwcGx5KEFycmF5LCBhcmd1bWVudHMpO1xufVxudmFyIGRlZmF1bHRTeW1ib2xzID0ge1xuICBzeW1ib2xzOiB7XG4gICAgJyonOiB7XG4gICAgICBpbmZpeDoge1xuICAgICAgICBzeW1ib2w6ICcqJyxcbiAgICAgICAgZjogbXVsdGlwbGljYXRpb24sXG4gICAgICAgIG5vdGF0aW9uOiAnaW5maXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiA0LFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDJcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6ICcqJyxcbiAgICAgIHJlZ1N5bWJvbDogJ1xcXFwqJ1xuICAgIH0sXG4gICAgJy8nOiB7XG4gICAgICBpbmZpeDoge1xuICAgICAgICBzeW1ib2w6ICcvJyxcbiAgICAgICAgZjogZGl2aXNpb24sXG4gICAgICAgIG5vdGF0aW9uOiAnaW5maXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiA0LFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDJcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6ICcvJyxcbiAgICAgIHJlZ1N5bWJvbDogJy8nXG4gICAgfSxcbiAgICAnKyc6IHtcbiAgICAgIGluZml4OiB7XG4gICAgICAgIHN5bWJvbDogJysnLFxuICAgICAgICBmOiBhZGRpdGlvbixcbiAgICAgICAgbm90YXRpb246ICdpbmZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDIsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMlxuICAgICAgfSxcbiAgICAgIHByZWZpeDoge1xuICAgICAgICBzeW1ib2w6ICcrJyxcbiAgICAgICAgZjogbGFzdCxcbiAgICAgICAgbm90YXRpb246ICdwcmVmaXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAzLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDFcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6ICcrJyxcbiAgICAgIHJlZ1N5bWJvbDogJ1xcXFwrJ1xuICAgIH0sXG4gICAgJy0nOiB7XG4gICAgICBpbmZpeDoge1xuICAgICAgICBzeW1ib2w6ICctJyxcbiAgICAgICAgZjogc3VidHJhY3Rpb24sXG4gICAgICAgIG5vdGF0aW9uOiAnaW5maXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAyLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDJcbiAgICAgIH0sXG4gICAgICBwcmVmaXg6IHtcbiAgICAgICAgc3ltYm9sOiAnLScsXG4gICAgICAgIGY6IG5lZ2F0aW9uLFxuICAgICAgICBub3RhdGlvbjogJ3ByZWZpeCcsXG4gICAgICAgIHByZWNlZGVuY2U6IDMsXG4gICAgICAgIHJpZ2h0VG9MZWZ0OiAwLFxuICAgICAgICBhcmdDb3VudDogMVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDogJy0nLFxuICAgICAgcmVnU3ltYm9sOiAnLSdcbiAgICB9LFxuICAgICcsJzoge1xuICAgICAgaW5maXg6IHtcbiAgICAgICAgc3ltYm9sOiAnLCcsXG4gICAgICAgIGY6IGNvbW1hLFxuICAgICAgICBub3RhdGlvbjogJ2luZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMSxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAyXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnLCcsXG4gICAgICByZWdTeW1ib2w6ICcsJ1xuICAgIH0sXG4gICAgJygnOiB7XG4gICAgICBwcmVmaXg6IHtcbiAgICAgICAgc3ltYm9sOiAnKCcsXG4gICAgICAgIGY6IGxhc3QsXG4gICAgICAgIG5vdGF0aW9uOiAncHJlZml4JyxcbiAgICAgICAgcHJlY2VkZW5jZTogMCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnKCcsXG4gICAgICByZWdTeW1ib2w6ICdcXFxcKCdcbiAgICB9LFxuICAgICcpJzoge1xuICAgICAgcG9zdGZpeDoge1xuICAgICAgICBzeW1ib2w6ICcpJyxcbiAgICAgICAgZjogdW5kZWZpbmVkLFxuICAgICAgICBub3RhdGlvbjogJ3Bvc3RmaXgnLFxuICAgICAgICBwcmVjZWRlbmNlOiAwLFxuICAgICAgICByaWdodFRvTGVmdDogMCxcbiAgICAgICAgYXJnQ291bnQ6IDFcbiAgICAgIH0sXG4gICAgICBzeW1ib2w6ICcpJyxcbiAgICAgIHJlZ1N5bWJvbDogJ1xcXFwpJ1xuICAgIH0sXG4gICAgbWluOiB7XG4gICAgICBmdW5jOiB7XG4gICAgICAgIHN5bWJvbDogJ21pbicsXG4gICAgICAgIGY6IG1pbixcbiAgICAgICAgbm90YXRpb246ICdmdW5jJyxcbiAgICAgICAgcHJlY2VkZW5jZTogMCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnbWluJyxcbiAgICAgIHJlZ1N5bWJvbDogJ21pblxcXFxiJ1xuICAgIH0sXG4gICAgbWF4OiB7XG4gICAgICBmdW5jOiB7XG4gICAgICAgIHN5bWJvbDogJ21heCcsXG4gICAgICAgIGY6IG1heCxcbiAgICAgICAgbm90YXRpb246ICdmdW5jJyxcbiAgICAgICAgcHJlY2VkZW5jZTogMCxcbiAgICAgICAgcmlnaHRUb0xlZnQ6IDAsXG4gICAgICAgIGFyZ0NvdW50OiAxXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiAnbWF4JyxcbiAgICAgIHJlZ1N5bWJvbDogJ21heFxcXFxiJ1xuICAgIH1cbiAgfVxufTtcbnZhciBkZWZhdWx0U3ltYm9sTWFwID0gZGVmYXVsdFN5bWJvbHM7XG5cbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zdHlsZWQtY29tcG9uZW50cy9zdHlsZWQtY29tcG9uZW50cy9ibG9iL2ZjZjZmMzgwNGM1N2ExNGRkNzk4NGRmYWI3YmMwNmVlMmVkY2EwNDQvc3JjL3V0aWxzL2Vycm9yLmpzXG4vKipcbiAqIFBhcnNlIGVycm9ycy5tZCBhbmQgdHVybiBpdCBpbnRvIGEgc2ltcGxlIGhhc2ggb2YgY29kZTogbWVzc2FnZVxuICogQHByaXZhdGVcbiAqL1xudmFyIEVSUk9SUyA9IHtcbiAgXCIxXCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnRzIHRvIGhzbCwgcGxlYXNlIHBhc3MgbXVsdGlwbGUgbnVtYmVycyBlLmcuIGhzbCgzNjAsIDAuNzUsIDAuNCkgb3IgYW4gb2JqZWN0IGUuZy4gcmdiKHsgaHVlOiAyNTUsIHNhdHVyYXRpb246IDAuNCwgbGlnaHRuZXNzOiAwLjc1IH0pLlxcblxcblwiLFxuICBcIjJcIjogXCJQYXNzZWQgaW52YWxpZCBhcmd1bWVudHMgdG8gaHNsYSwgcGxlYXNlIHBhc3MgbXVsdGlwbGUgbnVtYmVycyBlLmcuIGhzbGEoMzYwLCAwLjc1LCAwLjQsIDAuNykgb3IgYW4gb2JqZWN0IGUuZy4gcmdiKHsgaHVlOiAyNTUsIHNhdHVyYXRpb246IDAuNCwgbGlnaHRuZXNzOiAwLjc1LCBhbHBoYTogMC43IH0pLlxcblxcblwiLFxuICBcIjNcIjogXCJQYXNzZWQgYW4gaW5jb3JyZWN0IGFyZ3VtZW50IHRvIGEgY29sb3IgZnVuY3Rpb24sIHBsZWFzZSBwYXNzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXFxuXFxuXCIsXG4gIFwiNFwiOiBcIkNvdWxkbid0IGdlbmVyYXRlIHZhbGlkIHJnYiBzdHJpbmcgZnJvbSAlcywgaXQgcmV0dXJuZWQgJXMuXFxuXFxuXCIsXG4gIFwiNVwiOiBcIkNvdWxkbid0IHBhcnNlIHRoZSBjb2xvciBzdHJpbmcuIFBsZWFzZSBwcm92aWRlIHRoZSBjb2xvciBhcyBhIHN0cmluZyBpbiBoZXgsIHJnYiwgcmdiYSwgaHNsIG9yIGhzbGEgbm90YXRpb24uXFxuXFxuXCIsXG4gIFwiNlwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cyB0byByZ2IsIHBsZWFzZSBwYXNzIG11bHRpcGxlIG51bWJlcnMgZS5nLiByZ2IoMjU1LCAyMDUsIDEwMCkgb3IgYW4gb2JqZWN0IGUuZy4gcmdiKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KS5cXG5cXG5cIixcbiAgXCI3XCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnRzIHRvIHJnYmEsIHBsZWFzZSBwYXNzIG11bHRpcGxlIG51bWJlcnMgZS5nLiByZ2IoMjU1LCAyMDUsIDEwMCwgMC43NSkgb3IgYW4gb2JqZWN0IGUuZy4gcmdiKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNzUgfSkuXFxuXFxuXCIsXG4gIFwiOFwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIHRvQ29sb3JTdHJpbmcsIHBsZWFzZSBwYXNzIGEgUmdiQ29sb3IsIFJnYmFDb2xvciwgSHNsQ29sb3Igb3IgSHNsYUNvbG9yIG9iamVjdC5cXG5cXG5cIixcbiAgXCI5XCI6IFwiUGxlYXNlIHByb3ZpZGUgYSBudW1iZXIgb2Ygc3RlcHMgdG8gdGhlIG1vZHVsYXJTY2FsZSBoZWxwZXIuXFxuXFxuXCIsXG4gIFwiMTBcIjogXCJQbGVhc2UgcGFzcyBhIG51bWJlciBvciBvbmUgb2YgdGhlIHByZWRlZmluZWQgc2NhbGVzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyIGFzIHRoZSByYXRpby5cXG5cXG5cIixcbiAgXCIxMVwiOiBcIkludmFsaWQgdmFsdWUgcGFzc2VkIGFzIGJhc2UgdG8gbW9kdWxhclNjYWxlLCBleHBlY3RlZCBudW1iZXIgb3IgZW0gc3RyaW5nIGJ1dCBnb3QgXFxcIiVzXFxcIlxcblxcblwiLFxuICBcIjEyXCI6IFwiRXhwZWN0ZWQgYSBzdHJpbmcgZW5kaW5nIGluIFxcXCJweFxcXCIgb3IgYSBudW1iZXIgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byAlcygpLCBnb3QgXFxcIiVzXFxcIiBpbnN0ZWFkLlxcblxcblwiLFxuICBcIjEzXCI6IFwiRXhwZWN0ZWQgYSBzdHJpbmcgZW5kaW5nIGluIFxcXCJweFxcXCIgb3IgYSBudW1iZXIgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gJXMoKSwgZ290IFxcXCIlc1xcXCIgaW5zdGVhZC5cXG5cXG5cIixcbiAgXCIxNFwiOiBcIlBhc3NlZCBpbnZhbGlkIHBpeGVsIHZhbHVlIChcXFwiJXNcXFwiKSB0byAlcygpLCBwbGVhc2UgcGFzcyBhIHZhbHVlIGxpa2UgXFxcIjEycHhcXFwiIG9yIDEyLlxcblxcblwiLFxuICBcIjE1XCI6IFwiUGFzc2VkIGludmFsaWQgYmFzZSB2YWx1ZSAoXFxcIiVzXFxcIikgdG8gJXMoKSwgcGxlYXNlIHBhc3MgYSB2YWx1ZSBsaWtlIFxcXCIxMnB4XFxcIiBvciAxMi5cXG5cXG5cIixcbiAgXCIxNlwiOiBcIllvdSBtdXN0IHByb3ZpZGUgYSB0ZW1wbGF0ZSB0byB0aGlzIG1ldGhvZC5cXG5cXG5cIixcbiAgXCIxN1wiOiBcIllvdSBwYXNzZWQgYW4gdW5zdXBwb3J0ZWQgc2VsZWN0b3Igc3RhdGUgdG8gdGhpcyBtZXRob2QuXFxuXFxuXCIsXG4gIFwiMThcIjogXCJtaW5TY3JlZW4gYW5kIG1heFNjcmVlbiBtdXN0IGJlIHByb3ZpZGVkIGFzIHN0cmluZ2lmaWVkIG51bWJlcnMgd2l0aCB0aGUgc2FtZSB1bml0cy5cXG5cXG5cIixcbiAgXCIxOVwiOiBcImZyb21TaXplIGFuZCB0b1NpemUgbXVzdCBiZSBwcm92aWRlZCBhcyBzdHJpbmdpZmllZCBudW1iZXJzIHdpdGggdGhlIHNhbWUgdW5pdHMuXFxuXFxuXCIsXG4gIFwiMjBcIjogXCJleHBlY3RzIGVpdGhlciBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGEgc2luZ2xlIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIHByb3AsIGZyb21TaXplLCBhbmQgdG9TaXplLlxcblxcblwiLFxuICBcIjIxXCI6IFwiZXhwZWN0cyB0aGUgb2JqZWN0cyBpbiB0aGUgZmlyc3QgYXJndW1lbnQgYXJyYXkgdG8gaGF2ZSB0aGUgcHJvcGVydGllcyBgcHJvcGAsIGBmcm9tU2l6ZWAsIGFuZCBgdG9TaXplYC5cXG5cXG5cIixcbiAgXCIyMlwiOiBcImV4cGVjdHMgdGhlIGZpcnN0IGFyZ3VtZW50IG9iamVjdCB0byBoYXZlIHRoZSBwcm9wZXJ0aWVzIGBwcm9wYCwgYGZyb21TaXplYCwgYW5kIGB0b1NpemVgLlxcblxcblwiLFxuICBcIjIzXCI6IFwiZm9udEZhY2UgZXhwZWN0cyBhIG5hbWUgb2YgYSBmb250LWZhbWlseS5cXG5cXG5cIixcbiAgXCIyNFwiOiBcImZvbnRGYWNlIGV4cGVjdHMgZWl0aGVyIHRoZSBwYXRoIHRvIHRoZSBmb250IGZpbGUocykgb3IgYSBuYW1lIG9mIGEgbG9jYWwgY29weS5cXG5cXG5cIixcbiAgXCIyNVwiOiBcImZvbnRGYWNlIGV4cGVjdHMgbG9jYWxGb250cyB0byBiZSBhbiBhcnJheS5cXG5cXG5cIixcbiAgXCIyNlwiOiBcImZvbnRGYWNlIGV4cGVjdHMgZmlsZUZvcm1hdHMgdG8gYmUgYW4gYXJyYXkuXFxuXFxuXCIsXG4gIFwiMjdcIjogXCJyYWRpYWxHcmFkaWVudCByZXF1cmllcyBhdCBsZWFzdCAyIGNvbG9yLXN0b3BzIHRvIHByb3Blcmx5IHJlbmRlci5cXG5cXG5cIixcbiAgXCIyOFwiOiBcIlBsZWFzZSBzdXBwbHkgYSBmaWxlbmFtZSB0byByZXRpbmFJbWFnZSgpIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCIyOVwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIHRyaWFuZ2xlLCBwbGVhc2UgcGFzcyBjb3JyZWN0IHBvaW50aW5nRGlyZWN0aW9uIGUuZy4gJ3JpZ2h0Jy5cXG5cXG5cIixcbiAgXCIzMFwiOiBcIlBhc3NlZCBhbiBpbnZhbGlkIHZhbHVlIHRvIGBoZWlnaHRgIG9yIGB3aWR0aGAuIFBsZWFzZSBwcm92aWRlIGEgcGl4ZWwgYmFzZWQgdW5pdC5cXG5cXG5cIixcbiAgXCIzMVwiOiBcIlRoZSBhbmltYXRpb24gc2hvcnRoYW5kIG9ubHkgdGFrZXMgOCBhcmd1bWVudHMuIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cDovL21kbi5pby9hbmltYXRpb25cXG5cXG5cIixcbiAgXCIzMlwiOiBcIlRvIHBhc3MgbXVsdGlwbGUgYW5pbWF0aW9ucyBwbGVhc2Ugc3VwcGx5IHRoZW0gaW4gYXJyYXlzLCBlLmcuIGFuaW1hdGlvbihbJ3JvdGF0ZScsICcycyddLCBbJ21vdmUnLCAnMXMnXSlcXG5UbyBwYXNzIGEgc2luZ2xlIGFuaW1hdGlvbiBwbGVhc2Ugc3VwcGx5IHRoZW0gaW4gc2ltcGxlIHZhbHVlcywgZS5nLiBhbmltYXRpb24oJ3JvdGF0ZScsICcycycpXFxuXFxuXCIsXG4gIFwiMzNcIjogXCJUaGUgYW5pbWF0aW9uIHNob3J0aGFuZCBhcnJheXMgY2FuIG9ubHkgaGF2ZSA4IGVsZW1lbnRzLiBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb246IGh0dHA6Ly9tZG4uaW8vYW5pbWF0aW9uXFxuXFxuXCIsXG4gIFwiMzRcIjogXCJib3JkZXJSYWRpdXMgZXhwZWN0cyBhIHJhZGl1cyB2YWx1ZSBhcyBhIHN0cmluZyBvciBudW1iZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCIzNVwiOiBcImJvcmRlclJhZGl1cyBleHBlY3RzIG9uZSBvZiBcXFwidG9wXFxcIiwgXFxcImJvdHRvbVxcXCIsIFxcXCJsZWZ0XFxcIiBvciBcXFwicmlnaHRcXFwiIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCIzNlwiOiBcIlByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcgdmFsdWUuXFxuXFxuXCIsXG4gIFwiMzdcIjogXCJTeW50YXggRXJyb3IgYXQgJXMuXFxuXFxuXCIsXG4gIFwiMzhcIjogXCJGb3JtdWxhIGNvbnRhaW5zIGEgZnVuY3Rpb24gdGhhdCBuZWVkcyBwYXJlbnRoZXNlcyBhdCAlcy5cXG5cXG5cIixcbiAgXCIzOVwiOiBcIkZvcm11bGEgaXMgbWlzc2luZyBjbG9zaW5nIHBhcmVudGhlc2lzIGF0ICVzLlxcblxcblwiLFxuICBcIjQwXCI6IFwiRm9ybXVsYSBoYXMgdG9vIG1hbnkgY2xvc2luZyBwYXJlbnRoZXNlcyBhdCAlcy5cXG5cXG5cIixcbiAgXCI0MVwiOiBcIkFsbCB2YWx1ZXMgaW4gYSBmb3JtdWxhIG11c3QgaGF2ZSB0aGUgc2FtZSB1bml0IG9yIGJlIHVuaXRsZXNzLlxcblxcblwiLFxuICBcIjQyXCI6IFwiUGxlYXNlIHByb3ZpZGUgYSBudW1iZXIgb2Ygc3RlcHMgdG8gdGhlIG1vZHVsYXJTY2FsZSBoZWxwZXIuXFxuXFxuXCIsXG4gIFwiNDNcIjogXCJQbGVhc2UgcGFzcyBhIG51bWJlciBvciBvbmUgb2YgdGhlIHByZWRlZmluZWQgc2NhbGVzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyIGFzIHRoZSByYXRpby5cXG5cXG5cIixcbiAgXCI0NFwiOiBcIkludmFsaWQgdmFsdWUgcGFzc2VkIGFzIGJhc2UgdG8gbW9kdWxhclNjYWxlLCBleHBlY3RlZCBudW1iZXIgb3IgZW0vcmVtIHN0cmluZyBidXQgZ290ICVzLlxcblxcblwiLFxuICBcIjQ1XCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnQgdG8gaHNsVG9Db2xvclN0cmluZywgcGxlYXNlIHBhc3MgYSBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0LlxcblxcblwiLFxuICBcIjQ2XCI6IFwiUGFzc2VkIGludmFsaWQgYXJndW1lbnQgdG8gcmdiVG9Db2xvclN0cmluZywgcGxlYXNlIHBhc3MgYSBSZ2JDb2xvciBvciBSZ2JhQ29sb3Igb2JqZWN0LlxcblxcblwiLFxuICBcIjQ3XCI6IFwibWluU2NyZWVuIGFuZCBtYXhTY3JlZW4gbXVzdCBiZSBwcm92aWRlZCBhcyBzdHJpbmdpZmllZCBudW1iZXJzIHdpdGggdGhlIHNhbWUgdW5pdHMuXFxuXFxuXCIsXG4gIFwiNDhcIjogXCJmcm9tU2l6ZSBhbmQgdG9TaXplIG11c3QgYmUgcHJvdmlkZWQgYXMgc3RyaW5naWZpZWQgbnVtYmVycyB3aXRoIHRoZSBzYW1lIHVuaXRzLlxcblxcblwiLFxuICBcIjQ5XCI6IFwiRXhwZWN0cyBlaXRoZXIgYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciBhIHNpbmdsZSBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBwcm9wLCBmcm9tU2l6ZSwgYW5kIHRvU2l6ZS5cXG5cXG5cIixcbiAgXCI1MFwiOiBcIkV4cGVjdHMgdGhlIG9iamVjdHMgaW4gdGhlIGZpcnN0IGFyZ3VtZW50IGFycmF5IHRvIGhhdmUgdGhlIHByb3BlcnRpZXMgcHJvcCwgZnJvbVNpemUsIGFuZCB0b1NpemUuXFxuXFxuXCIsXG4gIFwiNTFcIjogXCJFeHBlY3RzIHRoZSBmaXJzdCBhcmd1bWVudCBvYmplY3QgdG8gaGF2ZSB0aGUgcHJvcGVydGllcyBwcm9wLCBmcm9tU2l6ZSwgYW5kIHRvU2l6ZS5cXG5cXG5cIixcbiAgXCI1MlwiOiBcImZvbnRGYWNlIGV4cGVjdHMgZWl0aGVyIHRoZSBwYXRoIHRvIHRoZSBmb250IGZpbGUocykgb3IgYSBuYW1lIG9mIGEgbG9jYWwgY29weS5cXG5cXG5cIixcbiAgXCI1M1wiOiBcImZvbnRGYWNlIGV4cGVjdHMgbG9jYWxGb250cyB0byBiZSBhbiBhcnJheS5cXG5cXG5cIixcbiAgXCI1NFwiOiBcImZvbnRGYWNlIGV4cGVjdHMgZmlsZUZvcm1hdHMgdG8gYmUgYW4gYXJyYXkuXFxuXFxuXCIsXG4gIFwiNTVcIjogXCJmb250RmFjZSBleHBlY3RzIGEgbmFtZSBvZiBhIGZvbnQtZmFtaWx5LlxcblxcblwiLFxuICBcIjU2XCI6IFwibGluZWFyR3JhZGllbnQgcmVxdXJpZXMgYXQgbGVhc3QgMiBjb2xvci1zdG9wcyB0byBwcm9wZXJseSByZW5kZXIuXFxuXFxuXCIsXG4gIFwiNTdcIjogXCJyYWRpYWxHcmFkaWVudCByZXF1cmllcyBhdCBsZWFzdCAyIGNvbG9yLXN0b3BzIHRvIHByb3Blcmx5IHJlbmRlci5cXG5cXG5cIixcbiAgXCI1OFwiOiBcIlBsZWFzZSBzdXBwbHkgYSBmaWxlbmFtZSB0byByZXRpbmFJbWFnZSgpIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCI1OVwiOiBcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIHRyaWFuZ2xlLCBwbGVhc2UgcGFzcyBjb3JyZWN0IHBvaW50aW5nRGlyZWN0aW9uIGUuZy4gJ3JpZ2h0Jy5cXG5cXG5cIixcbiAgXCI2MFwiOiBcIlBhc3NlZCBhbiBpbnZhbGlkIHZhbHVlIHRvIGBoZWlnaHRgIG9yIGB3aWR0aGAuIFBsZWFzZSBwcm92aWRlIGEgcGl4ZWwgYmFzZWQgdW5pdC5cXG5cXG5cIixcbiAgXCI2MVwiOiBcIlByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcgdmFsdWUuXFxuXFxuXCIsXG4gIFwiNjJcIjogXCJib3JkZXJSYWRpdXMgZXhwZWN0cyBhIHJhZGl1cyB2YWx1ZSBhcyBhIHN0cmluZyBvciBudW1iZXIgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCI2M1wiOiBcImJvcmRlclJhZGl1cyBleHBlY3RzIG9uZSBvZiBcXFwidG9wXFxcIiwgXFxcImJvdHRvbVxcXCIsIFxcXCJsZWZ0XFxcIiBvciBcXFwicmlnaHRcXFwiIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cXG5cIixcbiAgXCI2NFwiOiBcIlRoZSBhbmltYXRpb24gc2hvcnRoYW5kIG9ubHkgdGFrZXMgOCBhcmd1bWVudHMuIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cDovL21kbi5pby9hbmltYXRpb24uXFxuXFxuXCIsXG4gIFwiNjVcIjogXCJUbyBwYXNzIG11bHRpcGxlIGFuaW1hdGlvbnMgcGxlYXNlIHN1cHBseSB0aGVtIGluIGFycmF5cywgZS5nLiBhbmltYXRpb24oWydyb3RhdGUnLCAnMnMnXSwgWydtb3ZlJywgJzFzJ10pXFxcXG5UbyBwYXNzIGEgc2luZ2xlIGFuaW1hdGlvbiBwbGVhc2Ugc3VwcGx5IHRoZW0gaW4gc2ltcGxlIHZhbHVlcywgZS5nLiBhbmltYXRpb24oJ3JvdGF0ZScsICcycycpLlxcblxcblwiLFxuICBcIjY2XCI6IFwiVGhlIGFuaW1hdGlvbiBzaG9ydGhhbmQgYXJyYXlzIGNhbiBvbmx5IGhhdmUgOCBlbGVtZW50cy4gU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwOi8vbWRuLmlvL2FuaW1hdGlvbi5cXG5cXG5cIixcbiAgXCI2N1wiOiBcIllvdSBtdXN0IHByb3ZpZGUgYSB0ZW1wbGF0ZSB0byB0aGlzIG1ldGhvZC5cXG5cXG5cIixcbiAgXCI2OFwiOiBcIllvdSBwYXNzZWQgYW4gdW5zdXBwb3J0ZWQgc2VsZWN0b3Igc3RhdGUgdG8gdGhpcyBtZXRob2QuXFxuXFxuXCIsXG4gIFwiNjlcIjogXCJFeHBlY3RlZCBhIHN0cmluZyBlbmRpbmcgaW4gXFxcInB4XFxcIiBvciBhIG51bWJlciBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvICVzKCksIGdvdCAlcyBpbnN0ZWFkLlxcblxcblwiLFxuICBcIjcwXCI6IFwiRXhwZWN0ZWQgYSBzdHJpbmcgZW5kaW5nIGluIFxcXCJweFxcXCIgb3IgYSBudW1iZXIgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gJXMoKSwgZ290ICVzIGluc3RlYWQuXFxuXFxuXCIsXG4gIFwiNzFcIjogXCJQYXNzZWQgaW52YWxpZCBwaXhlbCB2YWx1ZSAlcyB0byAlcygpLCBwbGVhc2UgcGFzcyBhIHZhbHVlIGxpa2UgXFxcIjEycHhcXFwiIG9yIDEyLlxcblxcblwiLFxuICBcIjcyXCI6IFwiUGFzc2VkIGludmFsaWQgYmFzZSB2YWx1ZSAlcyB0byAlcygpLCBwbGVhc2UgcGFzcyBhIHZhbHVlIGxpa2UgXFxcIjEycHhcXFwiIG9yIDEyLlxcblxcblwiLFxuICBcIjczXCI6IFwiUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBDU1MgdmFyaWFibGUuXFxuXFxuXCIsXG4gIFwiNzRcIjogXCJDU1MgdmFyaWFibGUgbm90IGZvdW5kIGFuZCBubyBkZWZhdWx0IHdhcyBwcm92aWRlZC5cXG5cXG5cIixcbiAgXCI3NVwiOiBcImltcG9ydGFudCByZXF1aXJlcyBhIHZhbGlkIHN0eWxlIG9iamVjdCwgZ290IGEgJXMgaW5zdGVhZC5cXG5cXG5cIixcbiAgXCI3NlwiOiBcImZyb21TaXplIGFuZCB0b1NpemUgbXVzdCBiZSBwcm92aWRlZCBhcyBzdHJpbmdpZmllZCBudW1iZXJzIHdpdGggdGhlIHNhbWUgdW5pdHMgYXMgbWluU2NyZWVuIGFuZCBtYXhTY3JlZW4uXFxuXFxuXCIsXG4gIFwiNzdcIjogXCJyZW1Ub1B4IGV4cGVjdHMgYSB2YWx1ZSBpbiBcXFwicmVtXFxcIiBidXQgeW91IHByb3ZpZGVkIGl0IGluIFxcXCIlc1xcXCIuXFxuXFxuXCIsXG4gIFwiNzhcIjogXCJiYXNlIG11c3QgYmUgc2V0IGluIFxcXCJweFxcXCIgb3IgXFxcIiVcXFwiIGJ1dCB5b3Ugc2V0IGl0IGluIFxcXCIlc1xcXCIuXFxuXCJcbn07XG5cbi8qKlxuICogc3VwZXIgYmFzaWMgdmVyc2lvbiBvZiBzcHJpbnRmXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmb3JtYXQoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgdmFyIGEgPSBhcmdzWzBdO1xuICB2YXIgYiA9IFtdO1xuICB2YXIgYztcbiAgZm9yIChjID0gMTsgYyA8IGFyZ3MubGVuZ3RoOyBjICs9IDEpIHtcbiAgICBiLnB1c2goYXJnc1tjXSk7XG4gIH1cbiAgYi5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgYSA9IGEucmVwbGFjZSgvJVthLXpdLywgZCk7XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXJyb3IgZmlsZSBvdXQgb2YgZXJyb3JzLm1kIGZvciBkZXZlbG9wbWVudCBhbmQgYSBzaW1wbGUgd2ViIGxpbmsgdG8gdGhlIGZ1bGwgZXJyb3JzXG4gKiBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgUG9saXNoZWRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBvbGlzaGVkRXJyb3IsIF9FcnJvcik7XG4gIGZ1bmN0aW9uIFBvbGlzaGVkRXJyb3IoY29kZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgX3RoaXMgPSBfRXJyb3IuY2FsbCh0aGlzLCBcIkFuIGVycm9yIG9jY3VycmVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N0eWxlZC1jb21wb25lbnRzL3BvbGlzaGVkL2Jsb2IvbWFpbi9zcmMvaW50ZXJuYWxIZWxwZXJzL2Vycm9ycy5tZCNcIiArIGNvZGUgKyBcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIikgfHwgdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cbiAgICAgIF90aGlzID0gX0Vycm9yLmNhbGwodGhpcywgZm9ybWF0LmFwcGx5KHZvaWQgMCwgW0VSUk9SU1tjb2RlXV0uY29uY2F0KGFyZ3MpKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpO1xuICB9XG4gIHJldHVybiBQb2xpc2hlZEVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxudmFyIHVuaXRSZWdFeHAgPSAvKCg/IVxcdylhfG5hfGhjfG1jfGRnfG1lW3JdP3x4ZXxuaSg/IVthLXpBLVpdKXxtbXxjcHx0cHx4cHxxKD8hcyl8aHZ8eGFtdnxuaW12fHd2fHNtfHMoPyFcXER8JCl8Z2VkfGRhcmc/fG5ydXQpL2c7XG5cbi8vIE1lcmdlcyBhZGRpdGlvbmFsIG1hdGggZnVuY3Rpb25hbGl0eSBpbnRvIHRoZSBkZWZhdWx0cy5cbmZ1bmN0aW9uIG1lcmdlU3ltYm9sTWFwcyhhZGRpdGlvbmFsU3ltYm9scykge1xuICB2YXIgc3ltYm9sTWFwID0ge307XG4gIHN5bWJvbE1hcC5zeW1ib2xzID0gYWRkaXRpb25hbFN5bWJvbHMgPyBfZXh0ZW5kcyh7fSwgZGVmYXVsdFN5bWJvbE1hcC5zeW1ib2xzLCBhZGRpdGlvbmFsU3ltYm9scy5zeW1ib2xzKSA6IF9leHRlbmRzKHt9LCBkZWZhdWx0U3ltYm9sTWFwLnN5bWJvbHMpO1xuICByZXR1cm4gc3ltYm9sTWFwO1xufVxuZnVuY3Rpb24gZXhlYyhvcGVyYXRvcnMsIHZhbHVlcykge1xuICB2YXIgX3JlZjtcbiAgdmFyIG9wID0gb3BlcmF0b3JzLnBvcCgpO1xuICB2YWx1ZXMucHVzaChvcC5mLmFwcGx5KG9wLCAoX3JlZiA9IFtdKS5jb25jYXQuYXBwbHkoX3JlZiwgdmFsdWVzLnNwbGljZSgtb3AuYXJnQ291bnQpKSkpO1xuICByZXR1cm4gb3AucHJlY2VkZW5jZTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZShleHByZXNzaW9uLCBhZGRpdGlvbmFsU3ltYm9scykge1xuICB2YXIgc3ltYm9sTWFwID0gbWVyZ2VTeW1ib2xNYXBzKGFkZGl0aW9uYWxTeW1ib2xzKTtcbiAgdmFyIG1hdGNoO1xuICB2YXIgb3BlcmF0b3JzID0gW3N5bWJvbE1hcC5zeW1ib2xzWycoJ10ucHJlZml4XTtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoIC8vIFBhdHRlcm4gZm9yIG51bWJlcnNcbiAgXCJcXFxcZCsoPzpcXFxcLlxcXFxkKyk/fFwiICtcbiAgLy8gLi4uYW5kIHBhdHRlcm5zIGZvciBpbmRpdmlkdWFsIG9wZXJhdG9ycy9mdW5jdGlvbiBuYW1lc1xuICBPYmplY3Qua2V5cyhzeW1ib2xNYXAuc3ltYm9scykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gc3ltYm9sTWFwLnN5bWJvbHNba2V5XTtcbiAgfSlcbiAgLy8gbG9uZ2VyIHN5bWJvbHMgc2hvdWxkIGJlIGxpc3RlZCBmaXJzdFxuICAvLyAkRmxvd0ZpeE1lXG4gIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuc3ltYm9sLmxlbmd0aCAtIGEuc3ltYm9sLmxlbmd0aDtcbiAgfSlcbiAgLy8gJEZsb3dGaXhNZVxuICAubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsLnJlZ1N5bWJvbDtcbiAgfSkuam9pbignfCcpICsgXCJ8KFxcXFxTKVwiLCAnZycpO1xuICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7IC8vIFJlc2V0IHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3RcblxuICB2YXIgYWZ0ZXJWYWx1ZSA9IGZhbHNlO1xuICBkbyB7XG4gICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoZXhwcmVzc2lvbik7XG4gICAgdmFyIF9yZWYyID0gbWF0Y2ggfHwgWycpJywgdW5kZWZpbmVkXSxcbiAgICAgIHRva2VuID0gX3JlZjJbMF0sXG4gICAgICBiYWQgPSBfcmVmMlsxXTtcbiAgICB2YXIgbm90TnVtYmVyID0gc3ltYm9sTWFwLnN5bWJvbHNbdG9rZW5dO1xuICAgIHZhciBub3ROZXdWYWx1ZSA9IG5vdE51bWJlciAmJiAhbm90TnVtYmVyLnByZWZpeCAmJiAhbm90TnVtYmVyLmZ1bmM7XG4gICAgdmFyIG5vdEFmdGVyVmFsdWUgPSAhbm90TnVtYmVyIHx8ICFub3ROdW1iZXIucG9zdGZpeCAmJiAhbm90TnVtYmVyLmluZml4O1xuXG4gICAgLy8gQ2hlY2sgZm9yIHN5bnRheCBlcnJvcnM6XG4gICAgaWYgKGJhZCB8fCAoYWZ0ZXJWYWx1ZSA/IG5vdEFmdGVyVmFsdWUgOiBub3ROZXdWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDM3LCBtYXRjaCA/IG1hdGNoLmluZGV4IDogZXhwcmVzc2lvbi5sZW5ndGgsIGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBpZiAoYWZ0ZXJWYWx1ZSkge1xuICAgICAgLy8gV2UgZWl0aGVyIGhhdmUgYW4gaW5maXggb3IgcG9zdGZpeCBvcGVyYXRvciAodGhleSBzaG91bGQgYmUgbXV0dWFsbHkgZXhjbHVzaXZlKVxuICAgICAgdmFyIGN1cnIgPSBub3ROdW1iZXIucG9zdGZpeCB8fCBub3ROdW1iZXIuaW5maXg7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBwcmV2ID0gb3BlcmF0b3JzW29wZXJhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKChjdXJyLnByZWNlZGVuY2UgLSBwcmV2LnByZWNlZGVuY2UgfHwgcHJldi5yaWdodFRvTGVmdCkgPiAwKSBicmVhaztcbiAgICAgICAgLy8gQXBwbHkgcHJldmlvdXMgb3BlcmF0b3IsIHNpbmNlIGl0IGhhcyBwcmVjZWRlbmNlIG92ZXIgY3VycmVudCBvbmVcbiAgICAgIH0gd2hpbGUgKGV4ZWMob3BlcmF0b3JzLCB2YWx1ZXMpKTsgLy8gRXhpdCBsb29wIGFmdGVyIGV4ZWN1dGluZyBhbiBvcGVuaW5nIHBhcmVudGhlc2lzIG9yIGZ1bmN0aW9uXG4gICAgICBhZnRlclZhbHVlID0gY3Vyci5ub3RhdGlvbiA9PT0gJ3Bvc3RmaXgnO1xuICAgICAgaWYgKGN1cnIuc3ltYm9sICE9PSAnKScpIHtcbiAgICAgICAgb3BlcmF0b3JzLnB1c2goY3Vycik7XG4gICAgICAgIC8vIFBvc3RmaXggYWx3YXlzIGhhcyBwcmVjZWRlbmNlIG92ZXIgYW55IG9wZXJhdG9yIHRoYXQgZm9sbG93cyBhZnRlciBpdFxuICAgICAgICBpZiAoYWZ0ZXJWYWx1ZSkgZXhlYyhvcGVyYXRvcnMsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub3ROdW1iZXIpIHtcbiAgICAgIC8vIHByZWZpeCBvcGVyYXRvciBvciBmdW5jdGlvblxuICAgICAgb3BlcmF0b3JzLnB1c2gobm90TnVtYmVyLnByZWZpeCB8fCBub3ROdW1iZXIuZnVuYyk7XG4gICAgICBpZiAobm90TnVtYmVyLmZ1bmMpIHtcbiAgICAgICAgLy8gUmVxdWlyZSBhbiBvcGVuaW5nIHBhcmVudGhlc2lzXG4gICAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzBdICE9PSAnKCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigzOCwgbWF0Y2ggPyBtYXRjaC5pbmRleCA6IGV4cHJlc3Npb24ubGVuZ3RoLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBudW1iZXJcbiAgICAgIHZhbHVlcy5wdXNoKCt0b2tlbik7XG4gICAgICBhZnRlclZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0gd2hpbGUgKG1hdGNoICYmIG9wZXJhdG9ycy5sZW5ndGgpO1xuICBpZiAob3BlcmF0b3JzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDM5LCBtYXRjaCA/IG1hdGNoLmluZGV4IDogZXhwcmVzc2lvbi5sZW5ndGgsIGV4cHJlc3Npb24pO1xuICB9IGVsc2UgaWYgKG1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNDAsIG1hdGNoID8gbWF0Y2guaW5kZXggOiBleHByZXNzaW9uLmxlbmd0aCwgZXhwcmVzc2lvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlcy5wb3AoKTtcbiAgfVxufVxuZnVuY3Rpb24gcmV2ZXJzZVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgZG9pbmcgbWF0aCB3aXRoIENTUyBVbml0cy4gQWNjZXB0cyBhIGZvcm11bGEgYXMgYSBzdHJpbmcuIEFsbCB2YWx1ZXMgaW4gdGhlIGZvcm11bGEgbXVzdCBoYXZlIHRoZSBzYW1lIHVuaXQgKG9yIGJlIHVuaXRsZXNzKS4gU3VwcG9ydHMgY29tcGxleCBmb3JtdWxhcyB1dGxpemlpbmcgYWRkaXRpb24sIHN1YnRyYWN0aW9uLCBtdWx0aXBsaWNhdGlvbiwgZGl2aXNpb24sIHNxdWFyZSByb290LCBwb3dlcnMsIGZhY3RvcmlhbCwgbWluLCBtYXgsIGFzIHdlbGwgYXMgcGFyZW50aGVzZXMgZm9yIG9yZGVyIG9mIG9wZXJhdGlvbi5cbiAqXG4gKkluIGNhc2VzIHdoZXJlIHlvdSBuZWVkIHRvIGRvIGNhbGN1bGF0aW9ucyB3aXRoIG1peGVkIHVuaXRzIHdoZXJlIG9uZSB1bml0IGlzIGEgW3JlbGF0aXZlIGxlbmd0aCB1bml0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGVuZ3RoI1JlbGF0aXZlX2xlbmd0aF91bml0cyksIHlvdSB3aWxsIHdhbnQgdG8gdXNlIFtDU1MgQ2FsY10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NhbGMpLlxuICpcbiAqICp3YXJuaW5nKiBXaGlsZSB3ZSd2ZSBkb25lIGV2ZXJ5dGhpbmcgcG9zc2libGUgdG8gZW5zdXJlIG1hdGggc2FmZWx5IGV2YWx1dGVzIGZvcm11bGFzIGV4cHJlc3NlZCBhcyBzdHJpbmdzLCB5b3Ugc2hvdWxkIGFsd2F5cyB1c2UgZXh0cmVtZSBjYXV0aW9uIHdoZW4gcGFzc2luZyBgbWF0aGAgdXNlciBwcm92aWRlZCB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBmb250U2l6ZTogbWF0aCgnMTJyZW0gKyA4cmVtJyksXG4gKiAgIGZvbnRTaXplOiBtYXRoKCcoMTJweCArIDJweCkgKiAzJyksXG4gKiAgIGZvbnRTaXplOiBtYXRoKCczcHheMiArIHNxcnQoNCknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgZm9udFNpemU6ICR7bWF0aCgnMTJyZW0gKyA4cmVtJyl9O1xuICogICBmb250U2l6ZTogJHttYXRoKCcoMTJweCArIDJweCkgKiAzJyl9O1xuICogICBmb250U2l6ZTogJHttYXRoKCczcHheMiArIHNxcnQoNCknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICBmb250U2l6ZTogJzIwcmVtJyxcbiAqICAgZm9udFNpemU6ICc0MnB4JyxcbiAqICAgZm9udFNpemU6ICcxMXB4JyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gbWF0aChmb3JtdWxhLCBhZGRpdGlvbmFsU3ltYm9scykge1xuICB2YXIgcmV2ZXJzZWRGb3JtdWxhID0gcmV2ZXJzZVN0cmluZyhmb3JtdWxhKTtcbiAgdmFyIGZvcm11bGFNYXRjaCA9IHJldmVyc2VkRm9ybXVsYS5tYXRjaCh1bml0UmVnRXhwKTtcblxuICAvLyBDaGVjayB0aGF0IGFsbCB1bml0cyBhcmUgdGhlIHNhbWVcbiAgaWYgKGZvcm11bGFNYXRjaCAmJiAhZm9ybXVsYU1hdGNoLmV2ZXJ5KGZ1bmN0aW9uICh1bml0KSB7XG4gICAgcmV0dXJuIHVuaXQgPT09IGZvcm11bGFNYXRjaFswXTtcbiAgfSkpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0MSk7XG4gIH1cbiAgdmFyIGNsZWFuRm9ybXVsYSA9IHJldmVyc2VTdHJpbmcocmV2ZXJzZWRGb3JtdWxhLnJlcGxhY2UodW5pdFJlZ0V4cCwgJycpKTtcbiAgcmV0dXJuIFwiXCIgKyBjYWxjdWxhdGUoY2xlYW5Gb3JtdWxhLCBhZGRpdGlvbmFsU3ltYm9scykgKyAoZm9ybXVsYU1hdGNoID8gcmV2ZXJzZVN0cmluZyhmb3JtdWxhTWF0Y2hbMF0pIDogJycpO1xufVxuXG52YXIgY3NzVmFyaWFibGVSZWdleCA9IC8tLVtcXFNdKi9nO1xuXG4vKipcbiAqIEZldGNoZXMgdGhlIHZhbHVlIG9mIGEgcGFzc2VkIENTUyBWYXJpYWJsZSBpbiB0aGUgOnJvb3Qgc2NvcGUsIG9yIG90aGVyd2lzZSByZXR1cm5zIGEgZGVmYXVsdFZhbHVlIGlmIHByb3ZpZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICdiYWNrZ3JvdW5kJzogY3NzVmFyKCctLWJhY2tncm91bmQtY29sb3InKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtjc3NWYXIoJy0tYmFja2dyb3VuZC1jb2xvcicpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICdiYWNrZ3JvdW5kJzogJ3JlZCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gY3NzVmFyKGNzc1ZhcmlhYmxlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKCFjc3NWYXJpYWJsZSB8fCAhY3NzVmFyaWFibGUubWF0Y2goY3NzVmFyaWFibGVSZWdleCkpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3Myk7XG4gIH1cbiAgdmFyIHZhcmlhYmxlVmFsdWU7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgdmFyaWFibGVWYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKGNzc1ZhcmlhYmxlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgaWYgKHZhcmlhYmxlVmFsdWUpIHtcbiAgICByZXR1cm4gdmFyaWFibGVWYWx1ZS50cmltKCk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3NCk7XG59XG5cbi8vIEBwcml2YXRlXG5mdW5jdGlvbiBjYXBpdGFsaXplU3RyaW5nKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG52YXIgcG9zaXRpb25NYXAkMSA9IFsnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdMZWZ0J107XG5mdW5jdGlvbiBnZW5lcmF0ZVByb3BlcnR5KHByb3BlcnR5LCBwb3NpdGlvbikge1xuICBpZiAoIXByb3BlcnR5KSByZXR1cm4gcG9zaXRpb24udG9Mb3dlckNhc2UoKTtcbiAgdmFyIHNwbGl0UHJvcGVydHkgPSBwcm9wZXJ0eS5zcGxpdCgnLScpO1xuICBpZiAoc3BsaXRQcm9wZXJ0eS5sZW5ndGggPiAxKSB7XG4gICAgc3BsaXRQcm9wZXJ0eS5zcGxpY2UoMSwgMCwgcG9zaXRpb24pO1xuICAgIHJldHVybiBzcGxpdFByb3BlcnR5LnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2YWwpIHtcbiAgICAgIHJldHVybiBcIlwiICsgYWNjICsgY2FwaXRhbGl6ZVN0cmluZyh2YWwpO1xuICAgIH0pO1xuICB9XG4gIHZhciBqb2luZWRQcm9wZXJ0eSA9IHByb3BlcnR5LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDFcIiArIHBvc2l0aW9uICsgXCIkMlwiKTtcbiAgcmV0dXJuIHByb3BlcnR5ID09PSBqb2luZWRQcm9wZXJ0eSA/IFwiXCIgKyBwcm9wZXJ0eSArIHBvc2l0aW9uIDogam9pbmVkUHJvcGVydHk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVN0eWxlcyhwcm9wZXJ0eSwgdmFsdWVzV2l0aERlZmF1bHRzKSB7XG4gIHZhciBzdHlsZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXNXaXRoRGVmYXVsdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAodmFsdWVzV2l0aERlZmF1bHRzW2ldIHx8IHZhbHVlc1dpdGhEZWZhdWx0c1tpXSA9PT0gMCkge1xuICAgICAgc3R5bGVzW2dlbmVyYXRlUHJvcGVydHkocHJvcGVydHksIHBvc2l0aW9uTWFwJDFbaV0pXSA9IHZhbHVlc1dpdGhEZWZhdWx0c1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlcztcbn1cblxuLyoqXG4gKiBFbmFibGVzIHNob3J0aGFuZCBmb3IgZGlyZWN0aW9uLWJhc2VkIHByb3BlcnRpZXMuIEl0IGFjY2VwdHMgYSBwcm9wZXJ0eSAoaHlwaGVuYXRlZCBvciBjYW1lbENhc2VkKSBhbmQgdXAgdG8gZm91ciB2YWx1ZXMgdGhhdCBtYXAgdG8gdG9wLCByaWdodCwgYm90dG9tLCBhbmQgbGVmdCwgcmVzcGVjdGl2ZWx5LiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhbiBlbXB0eSBzdHJpbmcgdG8gZ2V0IG9ubHkgdGhlIGRpcmVjdGlvbmFsIHZhbHVlcyBhcyBwcm9wZXJ0aWVzLiBZb3UgY2FuIGFsc28gb3B0aW9uYWxseSBwYXNzIGEgbnVsbCBhcmd1bWVudCBmb3IgYSBkaXJlY3Rpb25hbCB2YWx1ZSB0byBpZ25vcmUgaXQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5kaXJlY3Rpb25hbFByb3BlcnR5KCdwYWRkaW5nJywgJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2RpcmVjdGlvbmFsUHJvcGVydHkoJ3BhZGRpbmcnLCAnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAncGFkZGluZ1RvcCc6ICcxMnB4JyxcbiAqICAgJ3BhZGRpbmdSaWdodCc6ICcyNHB4JyxcbiAqICAgJ3BhZGRpbmdCb3R0b20nOiAnMzZweCcsXG4gKiAgICdwYWRkaW5nTGVmdCc6ICc0OHB4J1xuICogfVxuICovXG5mdW5jdGlvbiBkaXJlY3Rpb25hbFByb3BlcnR5KHByb3BlcnR5KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgLy8gIHByZXR0aWVyLWlnbm9yZVxuICB2YXIgZmlyc3RWYWx1ZSA9IHZhbHVlc1swXSxcbiAgICBfdmFsdWVzJCA9IHZhbHVlc1sxXSxcbiAgICBzZWNvbmRWYWx1ZSA9IF92YWx1ZXMkID09PSB2b2lkIDAgPyBmaXJzdFZhbHVlIDogX3ZhbHVlcyQsXG4gICAgX3ZhbHVlcyQyID0gdmFsdWVzWzJdLFxuICAgIHRoaXJkVmFsdWUgPSBfdmFsdWVzJDIgPT09IHZvaWQgMCA/IGZpcnN0VmFsdWUgOiBfdmFsdWVzJDIsXG4gICAgX3ZhbHVlcyQzID0gdmFsdWVzWzNdLFxuICAgIGZvdXJ0aFZhbHVlID0gX3ZhbHVlcyQzID09PSB2b2lkIDAgPyBzZWNvbmRWYWx1ZSA6IF92YWx1ZXMkMztcbiAgdmFyIHZhbHVlc1dpdGhEZWZhdWx0cyA9IFtmaXJzdFZhbHVlLCBzZWNvbmRWYWx1ZSwgdGhpcmRWYWx1ZSwgZm91cnRoVmFsdWVdO1xuICByZXR1cm4gZ2VuZXJhdGVTdHlsZXMocHJvcGVydHksIHZhbHVlc1dpdGhEZWZhdWx0cyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgZW5kcyB3aXRoIHNvbWV0aGluZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCBzdWZmaXgpIHtcbiAgcmV0dXJuIHN0cmluZy5zdWJzdHIoLXN1ZmZpeC5sZW5ndGgpID09PSBzdWZmaXg7XG59XG5cbnZhciBjc3NSZWdleCQxID0gL14oWystXT8oPzpcXGQrfFxcZCpcXC5cXGQrKSkoW2Etel0qfCUpJC87XG5cbi8qKlxuICogUmV0dXJucyBhIGdpdmVuIENTUyB2YWx1ZSBtaW51cyBpdHMgdW5pdCBvZiBtZWFzdXJlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICctLWRpbWVuc2lvbic6IHN0cmlwVW5pdCgnMTAwcHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAtLWRpbWVuc2lvbjogJHtzdHJpcFVuaXQoJzEwMHB4Jyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJy0tZGltZW5zaW9uJzogMTAwXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHN0cmlwVW5pdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuIHZhbHVlO1xuICB2YXIgbWF0Y2hlZFZhbHVlID0gdmFsdWUubWF0Y2goY3NzUmVnZXgkMSk7XG4gIHJldHVybiBtYXRjaGVkVmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHZhbHVlO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHBpeGVsLXRvLXggY29udmVydGVyc1xuICogQHByaXZhdGVcbiAqL1xudmFyIHB4dG9GYWN0b3J5ID0gZnVuY3Rpb24gcHh0b0ZhY3RvcnkodG8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChweHZhbCwgYmFzZSkge1xuICAgIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICAgIGJhc2UgPSAnMTZweCc7XG4gICAgfVxuICAgIHZhciBuZXdQeHZhbCA9IHB4dmFsO1xuICAgIHZhciBuZXdCYXNlID0gYmFzZTtcbiAgICBpZiAodHlwZW9mIHB4dmFsID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCFlbmRzV2l0aChweHZhbCwgJ3B4JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjksIHRvLCBweHZhbCk7XG4gICAgICB9XG4gICAgICBuZXdQeHZhbCA9IHN0cmlwVW5pdChweHZhbCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICghZW5kc1dpdGgoYmFzZSwgJ3B4JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzAsIHRvLCBiYXNlKTtcbiAgICAgIH1cbiAgICAgIG5ld0Jhc2UgPSBzdHJpcFVuaXQoYmFzZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3UHh2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3MSwgcHh2YWwsIHRvKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdCYXNlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzIsIGJhc2UsIHRvKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIgKyBuZXdQeHZhbCAvIG5ld0Jhc2UgKyB0bztcbiAgfTtcbn07XG52YXIgcGl4ZWxzdG8gPSBweHRvRmFjdG9yeTtcblxuLyoqXG4gKiBDb252ZXJ0IHBpeGVsIHZhbHVlIHRvIGVtcy4gVGhlIGRlZmF1bHQgYmFzZSB2YWx1ZSBpcyAxNnB4LCBidXQgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBhXG4gKiBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHB4dmFsXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtiYXNlPScxNnB4J11cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICdoZWlnaHQnOiBlbSgnMTZweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGhlaWdodDogJHtlbSgnMTZweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJ2hlaWdodCc6ICcxZW0nXG4gKiB9XG4gKi9cbnZhciBlbSA9IHBpeGVsc3RvKCdlbScpO1xudmFyIGVtJDEgPSBlbTtcblxudmFyIGNzc1JlZ2V4ID0gL14oWystXT8oPzpcXGQrfFxcZCpcXC5cXGQrKSkoW2Etel0qfCUpJC87XG5cbi8qKlxuICogUmV0dXJucyBhIGdpdmVuIENTUyB2YWx1ZSBhbmQgaXRzIHVuaXQgYXMgZWxlbWVudHMgb2YgYW4gYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJy0tZGltZW5zaW9uJzogZ2V0VmFsdWVBbmRVbml0KCcxMDBweCcpWzBdLFxuICogICAnLS11bml0JzogZ2V0VmFsdWVBbmRVbml0KCcxMDBweCcpWzFdLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAtLWRpbWVuc2lvbjogJHtnZXRWYWx1ZUFuZFVuaXQoJzEwMHB4JylbMF19O1xuICogICAtLXVuaXQ6ICR7Z2V0VmFsdWVBbmRVbml0KCcxMDBweCcpWzFdfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICctLWRpbWVuc2lvbic6IDEwMCxcbiAqICAgJy0tdW5pdCc6ICdweCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlQW5kVW5pdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuIFt2YWx1ZSwgJyddO1xuICB2YXIgbWF0Y2hlZFZhbHVlID0gdmFsdWUubWF0Y2goY3NzUmVnZXgpO1xuICBpZiAobWF0Y2hlZFZhbHVlKSByZXR1cm4gW3BhcnNlRmxvYXQodmFsdWUpLCBtYXRjaGVkVmFsdWVbMl1dO1xuICByZXR1cm4gW3ZhbHVlLCB1bmRlZmluZWRdO1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgdGFyZ2V0aW5nIHJ1bGVzIGluIGEgc3R5bGUgYmxvY2sgZ2VuZXJhdGVkIGJ5IHBvbGlzaGVkIG1vZHVsZXMgdGhhdCBuZWVkICFpbXBvcnRhbnQtbGV2ZWwgc3BlY2lmaWNpdHkuIENhbiBvcHRpb25hbGx5IHNwZWNpZnkgYSBydWxlIChvciBydWxlcykgdG8gdGFyZ2V0IHNwZWNpZmljIHJ1bGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmltcG9ydGFudChjb3ZlcigpKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2ltcG9ydGFudChjb3ZlcigpKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZSAhaW1wb3J0YW50JyxcbiAqICAgJ3RvcCc6ICcwICFpbXBvcnRhbnQnLFxuICogICAncmlnaHQ6ICcwICFpbXBvcnRhbnQnLFxuICogICAnYm90dG9tJzogJzAgIWltcG9ydGFudCcsXG4gKiAgICdsZWZ0OiAnMCAhaW1wb3J0YW50J1xuICogfVxuICovXG5mdW5jdGlvbiBpbXBvcnRhbnQoc3R5bGVCbG9jaywgcnVsZXMpIHtcbiAgaWYgKHR5cGVvZiBzdHlsZUJsb2NrICE9PSAnb2JqZWN0JyB8fCBzdHlsZUJsb2NrID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNzUsIHR5cGVvZiBzdHlsZUJsb2NrKTtcbiAgfVxuICB2YXIgbmV3U3R5bGVCbG9jayA9IHt9O1xuICBPYmplY3Qua2V5cyhzdHlsZUJsb2NrKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAodHlwZW9mIHN0eWxlQmxvY2tba2V5XSA9PT0gJ29iamVjdCcgJiYgc3R5bGVCbG9ja1trZXldICE9PSBudWxsKSB7XG4gICAgICBuZXdTdHlsZUJsb2NrW2tleV0gPSBpbXBvcnRhbnQoc3R5bGVCbG9ja1trZXldLCBydWxlcyk7XG4gICAgfSBlbHNlIGlmICghcnVsZXMgfHwgcnVsZXMgJiYgKHJ1bGVzID09PSBrZXkgfHwgcnVsZXMuaW5kZXhPZihrZXkpID49IDApKSB7XG4gICAgICBuZXdTdHlsZUJsb2NrW2tleV0gPSBzdHlsZUJsb2NrW2tleV0gKyBcIiAhaW1wb3J0YW50XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlQmxvY2tba2V5XSA9IHN0eWxlQmxvY2tba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3U3R5bGVCbG9jaztcbn1cblxudmFyIHJhdGlvTmFtZXMgPSB7XG4gIG1pbm9yU2Vjb25kOiAxLjA2NyxcbiAgbWFqb3JTZWNvbmQ6IDEuMTI1LFxuICBtaW5vclRoaXJkOiAxLjIsXG4gIG1ham9yVGhpcmQ6IDEuMjUsXG4gIHBlcmZlY3RGb3VydGg6IDEuMzMzLFxuICBhdWdGb3VydGg6IDEuNDE0LFxuICBwZXJmZWN0RmlmdGg6IDEuNSxcbiAgbWlub3JTaXh0aDogMS42LFxuICBnb2xkZW5TZWN0aW9uOiAxLjYxOCxcbiAgbWFqb3JTaXh0aDogMS42NjcsXG4gIG1pbm9yU2V2ZW50aDogMS43NzgsXG4gIG1ham9yU2V2ZW50aDogMS44NzUsXG4gIG9jdGF2ZTogMixcbiAgbWFqb3JUZW50aDogMi41LFxuICBtYWpvckVsZXZlbnRoOiAyLjY2NyxcbiAgbWFqb3JUd2VsZnRoOiAzLFxuICBkb3VibGVPY3RhdmU6IDRcbn07XG5mdW5jdGlvbiBnZXRSYXRpbyhyYXRpb05hbWUpIHtcbiAgcmV0dXJuIHJhdGlvTmFtZXNbcmF0aW9OYW1lXTtcbn1cblxuLyoqXG4gKiBFc3RhYmxpc2ggY29uc2lzdGVudCBtZWFzdXJlbWVudHMgYW5kIHNwYWNpYWwgcmVsYXRpb25zaGlwcyB0aHJvdWdob3V0IHlvdXIgcHJvamVjdHMgYnkgaW5jcmVtZW50aW5nIGFuIGVtIG9yIHJlbSB2YWx1ZSB1cCBvciBkb3duIGEgZGVmaW5lZCBzY2FsZS4gV2UgcHJvdmlkZSBhIGxpc3Qgb2YgY29tbW9ubHkgdXNlZCBzY2FsZXMgYXMgcHJlLWRlZmluZWQgdmFyaWFibGVzLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgIC8vIEluY3JlbWVudCB0d28gc3RlcHMgdXAgdGhlIGRlZmF1bHQgc2NhbGVcbiAqICAgJ2ZvbnRTaXplJzogbW9kdWxhclNjYWxlKDIpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICAvLyBJbmNyZW1lbnQgdHdvIHN0ZXBzIHVwIHRoZSBkZWZhdWx0IHNjYWxlXG4gKiAgIGZvbnRTaXplOiAke21vZHVsYXJTY2FsZSgyKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICdmb250U2l6ZSc6ICcxLjc3Njg5ZW0nXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIG1vZHVsYXJTY2FsZShzdGVwcywgYmFzZSwgcmF0aW8pIHtcbiAgaWYgKGJhc2UgPT09IHZvaWQgMCkge1xuICAgIGJhc2UgPSAnMWVtJztcbiAgfVxuICBpZiAocmF0aW8gPT09IHZvaWQgMCkge1xuICAgIHJhdGlvID0gMS4zMzM7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGVwcyAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0Mik7XG4gIH1cbiAgaWYgKHR5cGVvZiByYXRpbyA9PT0gJ3N0cmluZycgJiYgIXJhdGlvTmFtZXNbcmF0aW9dKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNDMpO1xuICB9XG4gIHZhciBfcmVmID0gdHlwZW9mIGJhc2UgPT09ICdzdHJpbmcnID8gZ2V0VmFsdWVBbmRVbml0KGJhc2UpIDogW2Jhc2UsICcnXSxcbiAgICByZWFsQmFzZSA9IF9yZWZbMF0sXG4gICAgdW5pdCA9IF9yZWZbMV07XG4gIHZhciByZWFsUmF0aW8gPSB0eXBlb2YgcmF0aW8gPT09ICdzdHJpbmcnID8gZ2V0UmF0aW8ocmF0aW8pIDogcmF0aW87XG4gIGlmICh0eXBlb2YgcmVhbEJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNDQsIGJhc2UpO1xuICB9XG4gIHJldHVybiBcIlwiICsgcmVhbEJhc2UgKiBNYXRoLnBvdyhyZWFsUmF0aW8sIHN0ZXBzKSArICh1bml0IHx8ICcnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHBpeGVsIHZhbHVlIHRvIHJlbXMuIFRoZSBkZWZhdWx0IGJhc2UgdmFsdWUgaXMgMTZweCwgYnV0IGNhbiBiZSBjaGFuZ2VkIGJ5IHBhc3NpbmcgYVxuICogc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBmdW5jdGlvbi5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBweHZhbFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbYmFzZT0nMTZweCddXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnaGVpZ2h0JzogcmVtKCcxNnB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgaGVpZ2h0OiAke3JlbSgnMTZweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgJ2hlaWdodCc6ICcxcmVtJ1xuICogfVxuICovXG52YXIgcmVtID0gcGl4ZWxzdG8oJ3JlbScpO1xudmFyIHJlbSQxID0gcmVtO1xuXG52YXIgZGVmYXVsdEZvbnRTaXplID0gMTY7XG5mdW5jdGlvbiBjb252ZXJ0QmFzZShiYXNlKSB7XG4gIHZhciBkZWNvbnN0cnVjdGVkVmFsdWUgPSBnZXRWYWx1ZUFuZFVuaXQoYmFzZSk7XG4gIGlmIChkZWNvbnN0cnVjdGVkVmFsdWVbMV0gPT09ICdweCcpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChiYXNlKTtcbiAgfVxuICBpZiAoZGVjb25zdHJ1Y3RlZFZhbHVlWzFdID09PSAnJScpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChiYXNlKSAvIDEwMCAqIGRlZmF1bHRGb250U2l6ZTtcbiAgfVxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3OCwgZGVjb25zdHJ1Y3RlZFZhbHVlWzFdKTtcbn1cbmZ1bmN0aW9uIGdldEJhc2VGcm9tRG9jKCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICB2YXIgcm9vdEZvbnRTaXplID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmZvbnRTaXplO1xuICAgIHJldHVybiByb290Rm9udFNpemUgPyBjb252ZXJ0QmFzZShyb290Rm9udFNpemUpIDogZGVmYXVsdEZvbnRTaXplO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGRlZmF1bHRGb250U2l6ZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHJlbSB2YWx1ZXMgdG8gcHguIEJ5IGRlZmF1bHQsIHRoZSBiYXNlIHZhbHVlIGlzIHB1bGxlZCBmcm9tIHRoZSBmb250LXNpemUgcHJvcGVydHkgb24gdGhlIHJvb3QgZWxlbWVudCAoaWYgaXQgaXMgc2V0IGluICUgb3IgcHgpLiBJdCBkZWZhdWx0cyB0byAxNnB4IGlmIG5vdCBmb3VuZCBvbiB0aGUgcm9vdC4gWW91IGNhbiBhbHNvIG92ZXJyaWRlIHRoZSBiYXNlIHZhbHVlIGJ5IHByb3ZpZGluZyB5b3VyIG93biBiYXNlIGluICUgb3IgcHguXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnaGVpZ2h0JzogcmVtVG9QeCgnMS42cmVtJylcbiAqICAgJ2hlaWdodCc6IHJlbVRvUHgoJzEuNnJlbScsICcxMHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgaGVpZ2h0OiAke3JlbVRvUHgoJzEuNnJlbScpfVxuICogICBoZWlnaHQ6ICR7cmVtVG9QeCgnMS42cmVtJywgJzEwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICdoZWlnaHQnOiAnMjUuNnB4JyxcbiAqICAgJ2hlaWdodCc6ICcxNnB4JyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmVtVG9QeCh2YWx1ZSwgYmFzZSkge1xuICB2YXIgZGVjb25zdHJ1Y3RlZFZhbHVlID0gZ2V0VmFsdWVBbmRVbml0KHZhbHVlKTtcbiAgaWYgKGRlY29uc3RydWN0ZWRWYWx1ZVsxXSAhPT0gJ3JlbScgJiYgZGVjb25zdHJ1Y3RlZFZhbHVlWzFdICE9PSAnJykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDc3LCBkZWNvbnN0cnVjdGVkVmFsdWVbMV0pO1xuICB9XG4gIHZhciBuZXdCYXNlID0gYmFzZSA/IGNvbnZlcnRCYXNlKGJhc2UpIDogZ2V0QmFzZUZyb21Eb2MoKTtcbiAgcmV0dXJuIGRlY29uc3RydWN0ZWRWYWx1ZVswXSAqIG5ld0Jhc2UgKyBcInB4XCI7XG59XG5cbnZhciBmdW5jdGlvbnNNYXAkMyA9IHtcbiAgYmFjazogJ2N1YmljLWJlemllcigwLjYwMCwgLTAuMjgwLCAwLjczNSwgMC4wNDUpJyxcbiAgY2lyYzogJ2N1YmljLWJlemllcigwLjYwMCwgIDAuMDQwLCAwLjk4MCwgMC4zMzUpJyxcbiAgY3ViaWM6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA1NSwgMC42NzUsIDAuMTkwKScsXG4gIGV4cG86ICdjdWJpYy1iZXppZXIoMC45NTAsICAwLjA1MCwgMC43OTUsIDAuMDM1KScsXG4gIHF1YWQ6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA4NSwgMC42ODAsIDAuNTMwKScsXG4gIHF1YXJ0OiAnY3ViaWMtYmV6aWVyKDAuODk1LCAgMC4wMzAsIDAuNjg1LCAwLjIyMCknLFxuICBxdWludDogJ2N1YmljLWJlemllcigwLjc1NSwgIDAuMDUwLCAwLjg1NSwgMC4wNjApJyxcbiAgc2luZTogJ2N1YmljLWJlemllcigwLjQ3MCwgIDAuMDAwLCAwLjc0NSwgMC43MTUpJ1xufTtcblxuLyoqXG4gKiBTdHJpbmcgdG8gcmVwcmVzZW50IGNvbW1vbiBlYXNpbmcgZnVuY3Rpb25zIGFzIGRlbW9uc3RyYXRlZCBoZXJlOiAoZ2l0aHViLmNvbS9qYXVraWEvZWFzaWUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiBlYXNlSW4oJ3F1YWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiAgY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAke2Vhc2VJbigncXVhZCcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbic6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA4NSwgMC42ODAsIDAuNTMwKScsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGVhc2VJbihmdW5jdGlvbk5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uc01hcCQzW2Z1bmN0aW9uTmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKV07XG59XG5cbnZhciBmdW5jdGlvbnNNYXAkMiA9IHtcbiAgYmFjazogJ2N1YmljLWJlemllcigwLjY4MCwgLTAuNTUwLCAwLjI2NSwgMS41NTApJyxcbiAgY2lyYzogJ2N1YmljLWJlemllcigwLjc4NSwgIDAuMTM1LCAwLjE1MCwgMC44NjApJyxcbiAgY3ViaWM6ICdjdWJpYy1iZXppZXIoMC42NDUsICAwLjA0NSwgMC4zNTUsIDEuMDAwKScsXG4gIGV4cG86ICdjdWJpYy1iZXppZXIoMS4wMDAsICAwLjAwMCwgMC4wMDAsIDEuMDAwKScsXG4gIHF1YWQ6ICdjdWJpYy1iZXppZXIoMC40NTUsICAwLjAzMCwgMC41MTUsIDAuOTU1KScsXG4gIHF1YXJ0OiAnY3ViaWMtYmV6aWVyKDAuNzcwLCAgMC4wMDAsIDAuMTc1LCAxLjAwMCknLFxuICBxdWludDogJ2N1YmljLWJlemllcigwLjg2MCwgIDAuMDAwLCAwLjA3MCwgMS4wMDApJyxcbiAgc2luZTogJ2N1YmljLWJlemllcigwLjQ0NSwgIDAuMDUwLCAwLjU1MCwgMC45NTApJ1xufTtcblxuLyoqXG4gKiBTdHJpbmcgdG8gcmVwcmVzZW50IGNvbW1vbiBlYXNpbmcgZnVuY3Rpb25zIGFzIGRlbW9uc3RyYXRlZCBoZXJlOiAoZ2l0aHViLmNvbS9qYXVraWEvZWFzaWUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiBlYXNlSW5PdXQoJ3F1YWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiAgY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAke2Vhc2VJbk91dCgncXVhZCcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbic6ICdjdWJpYy1iZXppZXIoMC40NTUsICAwLjAzMCwgMC41MTUsIDAuOTU1KScsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGVhc2VJbk91dChmdW5jdGlvbk5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uc01hcCQyW2Z1bmN0aW9uTmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKV07XG59XG5cbnZhciBmdW5jdGlvbnNNYXAkMSA9IHtcbiAgYmFjazogJ2N1YmljLWJlemllcigwLjE3NSwgIDAuODg1LCAwLjMyMCwgMS4yNzUpJyxcbiAgY3ViaWM6ICdjdWJpYy1iZXppZXIoMC4yMTUsICAwLjYxMCwgMC4zNTUsIDEuMDAwKScsXG4gIGNpcmM6ICdjdWJpYy1iZXppZXIoMC4wNzUsICAwLjgyMCwgMC4xNjUsIDEuMDAwKScsXG4gIGV4cG86ICdjdWJpYy1iZXppZXIoMC4xOTAsICAxLjAwMCwgMC4yMjAsIDEuMDAwKScsXG4gIHF1YWQ6ICdjdWJpYy1iZXppZXIoMC4yNTAsICAwLjQ2MCwgMC40NTAsIDAuOTQwKScsXG4gIHF1YXJ0OiAnY3ViaWMtYmV6aWVyKDAuMTY1LCAgMC44NDAsIDAuNDQwLCAxLjAwMCknLFxuICBxdWludDogJ2N1YmljLWJlemllcigwLjIzMCwgIDEuMDAwLCAwLjMyMCwgMS4wMDApJyxcbiAgc2luZTogJ2N1YmljLWJlemllcigwLjM5MCwgIDAuNTc1LCAwLjU2NSwgMS4wMDApJ1xufTtcblxuLyoqXG4gKiBTdHJpbmcgdG8gcmVwcmVzZW50IGNvbW1vbiBlYXNpbmcgZnVuY3Rpb25zIGFzIGRlbW9uc3RyYXRlZCBoZXJlOiAoZ2l0aHViLmNvbS9qYXVraWEvZWFzaWUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiBlYXNlT3V0KCdxdWFkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogJHtlYXNlT3V0KCdxdWFkJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnZGl2Jzoge1xuICogICAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJzogJ2N1YmljLWJlemllcigwLjI1MCwgIDAuNDYwLCAwLjQ1MCwgMC45NDApJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gZWFzZU91dChmdW5jdGlvbk5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uc01hcCQxW2Z1bmN0aW9uTmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKV07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIENTUyBjYWxjIGZvcm11bGEgZm9yIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9mIGEgcHJvcGVydHkgYmV0d2VlbiB0d28gdmFsdWVzLiBBY2NlcHRzIG9wdGlvbmFsIG1pblNjcmVlbiAoZGVmYXVsdHMgdG8gJzMyMHB4JykgYW5kIG1heFNjcmVlbiAoZGVmYXVsdHMgdG8gJzEyMDBweCcpLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGZvbnRTaXplOiBiZXR3ZWVuKCcyMHB4JywgJzEwMHB4JywgJzQwMHB4JywgJzEwMDBweCcpLFxuICogICBmb250U2l6ZTogYmV0d2VlbignMjBweCcsICcxMDBweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGZvbnRTaXplOiAke2JldHdlZW4oJzIwcHgnLCAnMTAwcHgnLCAnNDAwcHgnLCAnMTAwMHB4Jyl9O1xuICogICBmb250U2l6ZTogJHtiZXR3ZWVuKCcyMHB4JywgJzEwMHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGgxOiB7XG4gKiAgICdmb250U2l6ZSc6ICdjYWxjKC0zMy4zMzMzMzMzMzMzMzMzNHB4ICsgMTMuMzMzMzMzMzMzMzMzMzM0dncpJyxcbiAqICAgJ2ZvbnRTaXplJzogJ2NhbGMoLTkuMDkwOTA5MDkwOTA5MDkzcHggKyA5LjA5MDkwOTA5MDkwOTA5MnZ3KSdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYmV0d2Vlbihmcm9tU2l6ZSwgdG9TaXplLCBtaW5TY3JlZW4sIG1heFNjcmVlbikge1xuICBpZiAobWluU2NyZWVuID09PSB2b2lkIDApIHtcbiAgICBtaW5TY3JlZW4gPSAnMzIwcHgnO1xuICB9XG4gIGlmIChtYXhTY3JlZW4gPT09IHZvaWQgMCkge1xuICAgIG1heFNjcmVlbiA9ICcxMjAwcHgnO1xuICB9XG4gIHZhciBfZ2V0VmFsdWVBbmRVbml0ID0gZ2V0VmFsdWVBbmRVbml0KGZyb21TaXplKSxcbiAgICB1bml0bGVzc0Zyb21TaXplID0gX2dldFZhbHVlQW5kVW5pdFswXSxcbiAgICBmcm9tU2l6ZVVuaXQgPSBfZ2V0VmFsdWVBbmRVbml0WzFdO1xuICB2YXIgX2dldFZhbHVlQW5kVW5pdDIgPSBnZXRWYWx1ZUFuZFVuaXQodG9TaXplKSxcbiAgICB1bml0bGVzc1RvU2l6ZSA9IF9nZXRWYWx1ZUFuZFVuaXQyWzBdLFxuICAgIHRvU2l6ZVVuaXQgPSBfZ2V0VmFsdWVBbmRVbml0MlsxXTtcbiAgdmFyIF9nZXRWYWx1ZUFuZFVuaXQzID0gZ2V0VmFsdWVBbmRVbml0KG1pblNjcmVlbiksXG4gICAgdW5pdGxlc3NNaW5TY3JlZW4gPSBfZ2V0VmFsdWVBbmRVbml0M1swXSxcbiAgICBtaW5TY3JlZW5Vbml0ID0gX2dldFZhbHVlQW5kVW5pdDNbMV07XG4gIHZhciBfZ2V0VmFsdWVBbmRVbml0NCA9IGdldFZhbHVlQW5kVW5pdChtYXhTY3JlZW4pLFxuICAgIHVuaXRsZXNzTWF4U2NyZWVuID0gX2dldFZhbHVlQW5kVW5pdDRbMF0sXG4gICAgbWF4U2NyZWVuVW5pdCA9IF9nZXRWYWx1ZUFuZFVuaXQ0WzFdO1xuICBpZiAodHlwZW9mIHVuaXRsZXNzTWluU2NyZWVuICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgdW5pdGxlc3NNYXhTY3JlZW4gIT09ICdudW1iZXInIHx8ICFtaW5TY3JlZW5Vbml0IHx8ICFtYXhTY3JlZW5Vbml0IHx8IG1pblNjcmVlblVuaXQgIT09IG1heFNjcmVlblVuaXQpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0Nyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB1bml0bGVzc0Zyb21TaXplICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgdW5pdGxlc3NUb1NpemUgIT09ICdudW1iZXInIHx8IGZyb21TaXplVW5pdCAhPT0gdG9TaXplVW5pdCkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ4KTtcbiAgfVxuICBpZiAoZnJvbVNpemVVbml0ICE9PSBtaW5TY3JlZW5Vbml0IHx8IHRvU2l6ZVVuaXQgIT09IG1heFNjcmVlblVuaXQpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3Nik7XG4gIH1cbiAgdmFyIHNsb3BlID0gKHVuaXRsZXNzRnJvbVNpemUgLSB1bml0bGVzc1RvU2l6ZSkgLyAodW5pdGxlc3NNaW5TY3JlZW4gLSB1bml0bGVzc01heFNjcmVlbik7XG4gIHZhciBiYXNlID0gdW5pdGxlc3NUb1NpemUgLSBzbG9wZSAqIHVuaXRsZXNzTWF4U2NyZWVuO1xuICByZXR1cm4gXCJjYWxjKFwiICsgYmFzZS50b0ZpeGVkKDIpICsgKGZyb21TaXplVW5pdCB8fCAnJykgKyBcIiArIFwiICsgKDEwMCAqIHNsb3BlKS50b0ZpeGVkKDIpICsgXCJ2dylcIjtcbn1cblxuLyoqXG4gKiBDU1MgdG8gY29udGFpbiBhIGZsb2F0IChjcmVkaXQgdG8gQ1NTTW9qbykuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgIC4uLmNsZWFyRml4KCksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Y2xlYXJGaXgoKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJyY6OmFmdGVyJzoge1xuICogICAnY2xlYXInOiAnYm90aCcsXG4gKiAgICdjb250ZW50JzogJ1wiXCInLFxuICogICAnZGlzcGxheSc6ICd0YWJsZSdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gY2xlYXJGaXgocGFyZW50KSB7XG4gIHZhciBfcmVmO1xuICBpZiAocGFyZW50ID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnQgPSAnJic7XG4gIH1cbiAgdmFyIHBzZXVkb1NlbGVjdG9yID0gcGFyZW50ICsgXCI6OmFmdGVyXCI7XG4gIHJldHVybiBfcmVmID0ge30sIF9yZWZbcHNldWRvU2VsZWN0b3JdID0ge1xuICAgIGNsZWFyOiAnYm90aCcsXG4gICAgY29udGVudDogJ1wiXCInLFxuICAgIGRpc3BsYXk6ICd0YWJsZSdcbiAgfSwgX3JlZjtcbn1cblxuLyoqXG4gKiBDU1MgdG8gZnVsbHkgY292ZXIgYW4gYXJlYS4gQ2FuIG9wdGlvbmFsbHkgYmUgcGFzc2VkIGFuIG9mZnNldCB0byBhY3QgYXMgYSBcInBhZGRpbmdcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5jb3ZlcigpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Y292ZXIoKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gKiAgICd0b3AnOiAnMCcsXG4gKiAgICdyaWdodDogJzAnLFxuICogICAnYm90dG9tJzogJzAnLFxuICogICAnbGVmdDogJzAnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNvdmVyKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiBvZmZzZXQsXG4gICAgcmlnaHQ6IG9mZnNldCxcbiAgICBib3R0b206IG9mZnNldCxcbiAgICBsZWZ0OiBvZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBDU1MgdG8gcmVwcmVzZW50IHRydW5jYXRlZCB0ZXh0IHdpdGggYW4gZWxsaXBzaXMuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGEgbWF4LXdpZHRoIGFuZCBudW1iZXIgb2YgbGluZXMgYmVmb3JlIHRydW5jYXRpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uZWxsaXBzaXMoJzI1MHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtlbGxpcHNpcygnMjUwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdkaXNwbGF5JzogJ2lubGluZS1ibG9jaycsXG4gKiAgICdtYXhXaWR0aCc6ICcyNTBweCcsXG4gKiAgICdvdmVyZmxvdyc6ICdoaWRkZW4nLFxuICogICAndGV4dE92ZXJmbG93JzogJ2VsbGlwc2lzJyxcbiAqICAgJ3doaXRlU3BhY2UnOiAnbm93cmFwJyxcbiAqICAgJ3dvcmRXcmFwJzogJ25vcm1hbCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gZWxsaXBzaXMod2lkdGgsIGxpbmVzKSB7XG4gIGlmIChsaW5lcyA9PT0gdm9pZCAwKSB7XG4gICAgbGluZXMgPSAxO1xuICB9XG4gIHZhciBzdHlsZXMgPSB7XG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgbWF4V2lkdGg6IHdpZHRoIHx8ICcxMDAlJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIHdvcmRXcmFwOiAnbm9ybWFsJ1xuICB9O1xuICByZXR1cm4gbGluZXMgPiAxID8gX2V4dGVuZHMoe30sIHN0eWxlcywge1xuICAgIFdlYmtpdEJveE9yaWVudDogJ3ZlcnRpY2FsJyxcbiAgICBXZWJraXRMaW5lQ2xhbXA6IGxpbmVzLFxuICAgIGRpc3BsYXk6ICctd2Via2l0LWJveCcsXG4gICAgd2hpdGVTcGFjZTogJ25vcm1hbCdcbiAgfSkgOiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmIChpdCkgcmV0dXJuIChpdCA9IGl0LmNhbGwobykpLm5leHQuYmluZChpdCk7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbi8qKlxuICogUmV0dXJucyBhIHNldCBvZiBtZWRpYSBxdWVyaWVzIHRoYXQgcmVzaXplcyBhIHByb3BlcnR5IChvciBzZXQgb2YgcHJvcGVydGllcykgYmV0d2VlbiBhIHByb3ZpZGVkIGZyb21TaXplIGFuZCB0b1NpemUuIEFjY2VwdHMgb3B0aW9uYWwgbWluU2NyZWVuIChkZWZhdWx0cyB0byAnMzIwcHgnKSBhbmQgbWF4U2NyZWVuIChkZWZhdWx0cyB0byAnMTIwMHB4JykgdG8gY29uc3RyYWluIHRoZSBpbnRlcnBvbGF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmZsdWlkUmFuZ2UoXG4gKiAgICB7XG4gKiAgICAgICAgcHJvcDogJ3BhZGRpbmcnLFxuICogICAgICAgIGZyb21TaXplOiAnMjBweCcsXG4gKiAgICAgICAgdG9TaXplOiAnMTAwcHgnLFxuICogICAgICB9LFxuICogICAgICAnNDAwcHgnLFxuICogICAgICAnMTAwMHB4JyxcbiAqICAgIClcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtmbHVpZFJhbmdlKFxuICogICAgICB7XG4gKiAgICAgICAgcHJvcDogJ3BhZGRpbmcnLFxuICogICAgICAgIGZyb21TaXplOiAnMjBweCcsXG4gKiAgICAgICAgdG9TaXplOiAnMTAwcHgnLFxuICogICAgICB9LFxuICogICAgICAnNDAwcHgnLFxuICogICAgICAnMTAwMHB4JyxcbiAqICAgICl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICBcIkBtZWRpYSAobWluLXdpZHRoOiAxMDAwcHgpXCI6IE9iamVjdCB7XG4gKiAgICAgXCJwYWRkaW5nXCI6IFwiMTAwcHhcIixcbiAqICAgfSxcbiAqICAgXCJAbWVkaWEgKG1pbi13aWR0aDogNDAwcHgpXCI6IE9iamVjdCB7XG4gKiAgICAgXCJwYWRkaW5nXCI6IFwiY2FsYygtMzMuMzMzMzMzMzMzMzMzMzRweCArIDEzLjMzMzMzMzMzMzMzMzMzNHZ3KVwiLFxuICogICB9LFxuICogICBcInBhZGRpbmdcIjogXCIyMHB4XCIsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGZsdWlkUmFuZ2UoY3NzUHJvcCwgbWluU2NyZWVuLCBtYXhTY3JlZW4pIHtcbiAgaWYgKG1pblNjcmVlbiA9PT0gdm9pZCAwKSB7XG4gICAgbWluU2NyZWVuID0gJzMyMHB4JztcbiAgfVxuICBpZiAobWF4U2NyZWVuID09PSB2b2lkIDApIHtcbiAgICBtYXhTY3JlZW4gPSAnMTIwMHB4JztcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoY3NzUHJvcCkgJiYgdHlwZW9mIGNzc1Byb3AgIT09ICdvYmplY3QnIHx8IGNzc1Byb3AgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0OSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3NzUHJvcCkpIHtcbiAgICB2YXIgbWVkaWFRdWVyaWVzID0ge307XG4gICAgdmFyIGZhbGxiYWNrcyA9IHt9O1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UoY3NzUHJvcCksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX2V4dGVuZHMyLCBfZXh0ZW5kczM7XG4gICAgICB2YXIgb2JqID0gX3N0ZXAudmFsdWU7XG4gICAgICBpZiAoIW9iai5wcm9wIHx8ICFvYmouZnJvbVNpemUgfHwgIW9iai50b1NpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTApO1xuICAgICAgfVxuICAgICAgZmFsbGJhY2tzW29iai5wcm9wXSA9IG9iai5mcm9tU2l6ZTtcbiAgICAgIG1lZGlhUXVlcmllc1tcIkBtZWRpYSAobWluLXdpZHRoOiBcIiArIG1pblNjcmVlbiArIFwiKVwiXSA9IF9leHRlbmRzKHt9LCBtZWRpYVF1ZXJpZXNbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtaW5TY3JlZW4gKyBcIilcIl0sIChfZXh0ZW5kczIgPSB7fSwgX2V4dGVuZHMyW29iai5wcm9wXSA9IGJldHdlZW4ob2JqLmZyb21TaXplLCBvYmoudG9TaXplLCBtaW5TY3JlZW4sIG1heFNjcmVlbiksIF9leHRlbmRzMikpO1xuICAgICAgbWVkaWFRdWVyaWVzW1wiQG1lZGlhIChtaW4td2lkdGg6IFwiICsgbWF4U2NyZWVuICsgXCIpXCJdID0gX2V4dGVuZHMoe30sIG1lZGlhUXVlcmllc1tcIkBtZWRpYSAobWluLXdpZHRoOiBcIiArIG1heFNjcmVlbiArIFwiKVwiXSwgKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNbb2JqLnByb3BdID0gb2JqLnRvU2l6ZSwgX2V4dGVuZHMzKSk7XG4gICAgfVxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgZmFsbGJhY2tzLCBtZWRpYVF1ZXJpZXMpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfcmVmLCBfcmVmMiwgX3JlZjM7XG4gICAgaWYgKCFjc3NQcm9wLnByb3AgfHwgIWNzc1Byb3AuZnJvbVNpemUgfHwgIWNzc1Byb3AudG9TaXplKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1MSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVmMyA9IHt9LCBfcmVmM1tjc3NQcm9wLnByb3BdID0gY3NzUHJvcC5mcm9tU2l6ZSwgX3JlZjNbXCJAbWVkaWEgKG1pbi13aWR0aDogXCIgKyBtaW5TY3JlZW4gKyBcIilcIl0gPSAoX3JlZiA9IHt9LCBfcmVmW2Nzc1Byb3AucHJvcF0gPSBiZXR3ZWVuKGNzc1Byb3AuZnJvbVNpemUsIGNzc1Byb3AudG9TaXplLCBtaW5TY3JlZW4sIG1heFNjcmVlbiksIF9yZWYpLCBfcmVmM1tcIkBtZWRpYSAobWluLXdpZHRoOiBcIiArIG1heFNjcmVlbiArIFwiKVwiXSA9IChfcmVmMiA9IHt9LCBfcmVmMltjc3NQcm9wLnByb3BdID0gY3NzUHJvcC50b1NpemUsIF9yZWYyKSwgX3JlZjM7XG4gIH1cbn1cblxudmFyIGRhdGFVUklSZWdleCA9IC9eXFxzKmRhdGE6KFthLXpdK1xcL1thLXotXSsoO1thLXotXSs9W2Etei1dKyk/KT8oO2NoYXJzZXQ9W2EtejAtOS1dKyk/KDtiYXNlNjQpPyxbYS16MC05ISQmJywoKSorLDs9XFwtLl9+OkAvPyVcXHNdKlxccyokL2k7XG52YXIgZm9ybWF0SGludE1hcCA9IHtcbiAgd29mZjogJ3dvZmYnLFxuICB3b2ZmMjogJ3dvZmYyJyxcbiAgdHRmOiAndHJ1ZXR5cGUnLFxuICBvdGY6ICdvcGVudHlwZScsXG4gIGVvdDogJ2VtYmVkZGVkLW9wZW50eXBlJyxcbiAgc3ZnOiAnc3ZnJyxcbiAgc3ZnejogJ3N2Zydcbn07XG5mdW5jdGlvbiBnZW5lcmF0ZUZvcm1hdEhpbnQoZm9ybWF0LCBmb3JtYXRIaW50KSB7XG4gIGlmICghZm9ybWF0SGludCkgcmV0dXJuICcnO1xuICByZXR1cm4gXCIgZm9ybWF0KFxcXCJcIiArIGZvcm1hdEhpbnRNYXBbZm9ybWF0XSArIFwiXFxcIilcIjtcbn1cbmZ1bmN0aW9uIGlzRGF0YVVSSShmb250RmlsZVBhdGgpIHtcbiAgcmV0dXJuICEhZm9udEZpbGVQYXRoLnJlcGxhY2UoL1xccysvZywgJyAnKS5tYXRjaChkYXRhVVJJUmVnZXgpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVGaWxlUmVmZXJlbmNlcyhmb250RmlsZVBhdGgsIGZpbGVGb3JtYXRzLCBmb3JtYXRIaW50KSB7XG4gIGlmIChpc0RhdGFVUkkoZm9udEZpbGVQYXRoKSkge1xuICAgIHJldHVybiBcInVybChcXFwiXCIgKyBmb250RmlsZVBhdGggKyBcIlxcXCIpXCIgKyBnZW5lcmF0ZUZvcm1hdEhpbnQoZmlsZUZvcm1hdHNbMF0sIGZvcm1hdEhpbnQpO1xuICB9XG4gIHZhciBmaWxlRm9udFJlZmVyZW5jZXMgPSBmaWxlRm9ybWF0cy5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiBcInVybChcXFwiXCIgKyBmb250RmlsZVBhdGggKyBcIi5cIiArIGZvcm1hdCArIFwiXFxcIilcIiArIGdlbmVyYXRlRm9ybWF0SGludChmb3JtYXQsIGZvcm1hdEhpbnQpO1xuICB9KTtcbiAgcmV0dXJuIGZpbGVGb250UmVmZXJlbmNlcy5qb2luKCcsICcpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVMb2NhbFJlZmVyZW5jZXMobG9jYWxGb250cykge1xuICB2YXIgbG9jYWxGb250UmVmZXJlbmNlcyA9IGxvY2FsRm9udHMubWFwKGZ1bmN0aW9uIChmb250KSB7XG4gICAgcmV0dXJuIFwibG9jYWwoXFxcIlwiICsgZm9udCArIFwiXFxcIilcIjtcbiAgfSk7XG4gIHJldHVybiBsb2NhbEZvbnRSZWZlcmVuY2VzLmpvaW4oJywgJyk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVNvdXJjZXMoZm9udEZpbGVQYXRoLCBsb2NhbEZvbnRzLCBmaWxlRm9ybWF0cywgZm9ybWF0SGludCkge1xuICB2YXIgZm9udFJlZmVyZW5jZXMgPSBbXTtcbiAgaWYgKGxvY2FsRm9udHMpIGZvbnRSZWZlcmVuY2VzLnB1c2goZ2VuZXJhdGVMb2NhbFJlZmVyZW5jZXMobG9jYWxGb250cykpO1xuICBpZiAoZm9udEZpbGVQYXRoKSB7XG4gICAgZm9udFJlZmVyZW5jZXMucHVzaChnZW5lcmF0ZUZpbGVSZWZlcmVuY2VzKGZvbnRGaWxlUGF0aCwgZmlsZUZvcm1hdHMsIGZvcm1hdEhpbnQpKTtcbiAgfVxuICByZXR1cm4gZm9udFJlZmVyZW5jZXMuam9pbignLCAnKTtcbn1cblxuLyoqXG4gKiBDU1MgZm9yIGEgQGZvbnQtZmFjZSBkZWNsYXJhdGlvbi4gRGVmYXVsdHMgdG8gY2hlY2sgZm9yIGxvY2FsIGNvcGllcyBvZiB0aGUgZm9udCBvbiB0aGUgdXNlcidzIG1hY2hpbmUuIFlvdSBjYW4gZGlzYWJsZSB0aGlzIGJ5IHBhc3NpbmcgYG51bGxgIHRvIGxvY2FsRm9udHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgYmFzaWMgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgIC4uLmZvbnRGYWNlKHtcbiAqICAgICAgJ2ZvbnRGYW1pbHknOiAnU2Fucy1Qcm8nLFxuICogICAgICAnZm9udEZpbGVQYXRoJzogJ3BhdGgvdG8vZmlsZSdcbiAqICAgIH0pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgYmFzaWMgdXNhZ2VcbiAqIGNvbnN0IEdsb2JhbFN0eWxlID0gY3JlYXRlR2xvYmFsU3R5bGVgJHtcbiAqICAgZm9udEZhY2Uoe1xuICogICAgICdmb250RmFtaWx5JzogJ1NhbnMtUHJvJyxcbiAqICAgICAnZm9udEZpbGVQYXRoJzogJ3BhdGgvdG8vZmlsZSdcbiAqICAgfVxuICogKX1gXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdAZm9udC1mYWNlJzoge1xuICogICAnZm9udEZhbWlseSc6ICdTYW5zLVBybycsXG4gKiAgICdzcmMnOiAndXJsKFwicGF0aC90by9maWxlLmVvdFwiKSwgdXJsKFwicGF0aC90by9maWxlLndvZmYyXCIpLCB1cmwoXCJwYXRoL3RvL2ZpbGUud29mZlwiKSwgdXJsKFwicGF0aC90by9maWxlLnR0ZlwiKSwgdXJsKFwicGF0aC90by9maWxlLnN2Z1wiKScsXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gZm9udEZhY2UoX3JlZikge1xuICB2YXIgZm9udEZhbWlseSA9IF9yZWYuZm9udEZhbWlseSxcbiAgICBmb250RmlsZVBhdGggPSBfcmVmLmZvbnRGaWxlUGF0aCxcbiAgICBmb250U3RyZXRjaCA9IF9yZWYuZm9udFN0cmV0Y2gsXG4gICAgZm9udFN0eWxlID0gX3JlZi5mb250U3R5bGUsXG4gICAgZm9udFZhcmlhbnQgPSBfcmVmLmZvbnRWYXJpYW50LFxuICAgIGZvbnRXZWlnaHQgPSBfcmVmLmZvbnRXZWlnaHQsXG4gICAgX3JlZiRmaWxlRm9ybWF0cyA9IF9yZWYuZmlsZUZvcm1hdHMsXG4gICAgZmlsZUZvcm1hdHMgPSBfcmVmJGZpbGVGb3JtYXRzID09PSB2b2lkIDAgPyBbJ2VvdCcsICd3b2ZmMicsICd3b2ZmJywgJ3R0ZicsICdzdmcnXSA6IF9yZWYkZmlsZUZvcm1hdHMsXG4gICAgX3JlZiRmb3JtYXRIaW50ID0gX3JlZi5mb3JtYXRIaW50LFxuICAgIGZvcm1hdEhpbnQgPSBfcmVmJGZvcm1hdEhpbnQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRmb3JtYXRIaW50LFxuICAgIF9yZWYkbG9jYWxGb250cyA9IF9yZWYubG9jYWxGb250cyxcbiAgICBsb2NhbEZvbnRzID0gX3JlZiRsb2NhbEZvbnRzID09PSB2b2lkIDAgPyBbZm9udEZhbWlseV0gOiBfcmVmJGxvY2FsRm9udHMsXG4gICAgdW5pY29kZVJhbmdlID0gX3JlZi51bmljb2RlUmFuZ2UsXG4gICAgZm9udERpc3BsYXkgPSBfcmVmLmZvbnREaXNwbGF5LFxuICAgIGZvbnRWYXJpYXRpb25TZXR0aW5ncyA9IF9yZWYuZm9udFZhcmlhdGlvblNldHRpbmdzLFxuICAgIGZvbnRGZWF0dXJlU2V0dGluZ3MgPSBfcmVmLmZvbnRGZWF0dXJlU2V0dGluZ3M7XG4gIC8vIEVycm9yIEhhbmRsaW5nXG4gIGlmICghZm9udEZhbWlseSkgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTUpO1xuICBpZiAoIWZvbnRGaWxlUGF0aCAmJiAhbG9jYWxGb250cykge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDUyKTtcbiAgfVxuICBpZiAobG9jYWxGb250cyAmJiAhQXJyYXkuaXNBcnJheShsb2NhbEZvbnRzKSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDUzKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsZUZvcm1hdHMpKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTQpO1xuICB9XG4gIHZhciBmb250RmFjZURlY2xhcmF0aW9uID0ge1xuICAgICdAZm9udC1mYWNlJzoge1xuICAgICAgZm9udEZhbWlseTogZm9udEZhbWlseSxcbiAgICAgIHNyYzogZ2VuZXJhdGVTb3VyY2VzKGZvbnRGaWxlUGF0aCwgbG9jYWxGb250cywgZmlsZUZvcm1hdHMsIGZvcm1hdEhpbnQpLFxuICAgICAgdW5pY29kZVJhbmdlOiB1bmljb2RlUmFuZ2UsXG4gICAgICBmb250U3RyZXRjaDogZm9udFN0cmV0Y2gsXG4gICAgICBmb250U3R5bGU6IGZvbnRTdHlsZSxcbiAgICAgIGZvbnRWYXJpYW50OiBmb250VmFyaWFudCxcbiAgICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQsXG4gICAgICBmb250RGlzcGxheTogZm9udERpc3BsYXksXG4gICAgICBmb250VmFyaWF0aW9uU2V0dGluZ3M6IGZvbnRWYXJpYXRpb25TZXR0aW5ncyxcbiAgICAgIGZvbnRGZWF0dXJlU2V0dGluZ3M6IGZvbnRGZWF0dXJlU2V0dGluZ3NcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVtb3ZlcyB1bmRlZmluZWQgZmllbGRzIGZvciBjbGVhbmVyIGNzcyBvYmplY3QuXG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGZvbnRGYWNlRGVjbGFyYXRpb24pKTtcbn1cblxuLyoqXG4gKiBDU1MgdG8gaGlkZSB0ZXh0IHRvIHNob3cgYSBiYWNrZ3JvdW5kIGltYWdlIGluIGEgU0VPLWZyaWVuZGx5IHdheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAnYmFja2dyb3VuZEltYWdlJzogJ3VybChsb2dvLnBuZyknLFxuICogICAuLi5oaWRlVGV4dCgpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kSW1hZ2U6IHVybChsb2dvLnBuZyk7XG4gKiAgICR7aGlkZVRleHQoKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdkaXYnOiB7XG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAndXJsKGxvZ28ucG5nKScsXG4gKiAgICd0ZXh0SW5kZW50JzogJzEwMSUnLFxuICogICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAqICAgJ3doaXRlU3BhY2UnOiAnbm93cmFwJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaGlkZVRleHQoKSB7XG4gIHJldHVybiB7XG4gICAgdGV4dEluZGVudDogJzEwMSUnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJ1xuICB9O1xufVxuXG4vKipcbiAqIENTUyB0byBoaWRlIGNvbnRlbnQgdmlzdWFsbHkgYnV0IHJlbWFpbiBhY2Nlc3NpYmxlIHRvIHNjcmVlbiByZWFkZXJzLlxuICogZnJvbSBbSFRNTDUgQm9pbGVycGxhdGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9oNWJwL2h0bWw1LWJvaWxlcnBsYXRlL2Jsb2IvOWExNzZmNTdhZjFjZmU4ZWM3MDMwMGRhNDYyMWZiOWIwN2U1ZmEzMS9zcmMvY3NzL21haW4uY3NzI0wxMjEpXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uaGlkZVZpc3VhbGx5KCksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7aGlkZVZpc3VhbGx5KCl9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnZGl2Jzoge1xuICogICAnYm9yZGVyJzogJzAnLFxuICogICAnY2xpcCc6ICdyZWN0KDAgMCAwIDApJyxcbiAqICAgJ2hlaWdodCc6ICcxcHgnLFxuICogICAnbWFyZ2luJzogJy0xcHgnLFxuICogICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAqICAgJ3BhZGRpbmcnOiAnMCcsXG4gKiAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gKiAgICd3aGl0ZVNwYWNlJzogJ25vd3JhcCcsXG4gKiAgICd3aWR0aCc6ICcxcHgnLFxuICogfVxuICovXG5mdW5jdGlvbiBoaWRlVmlzdWFsbHkoKSB7XG4gIHJldHVybiB7XG4gICAgYm9yZGVyOiAnMCcsXG4gICAgY2xpcDogJ3JlY3QoMCAwIDAgMCknLFxuICAgIGhlaWdodDogJzFweCcsXG4gICAgbWFyZ2luOiAnLTFweCcsXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgIHBhZGRpbmc6ICcwJyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICB3aWR0aDogJzFweCdcbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtZWRpYSBxdWVyeSB0byB0YXJnZXQgSGlEUEkgZGV2aWNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogIFtoaURQSSgxLjUpXToge1xuICogICAgd2lkdGg6IDIwMHB4O1xuICogIH1cbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtoaURQSSgxLjUpfSB7XG4gKiAgICAgd2lkdGg6IDIwMHB4O1xuICogICB9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdAbWVkaWEgb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDEuNSksXG4gKiAgb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDEuNSksXG4gKiAgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUvMSksXG4gKiAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTQ0ZHBpKSxcbiAqICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxLjVkcHB4KSc6IHtcbiAqICAgJ3dpZHRoJzogJzIwMHB4JyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaGlEUEkocmF0aW8pIHtcbiAgaWYgKHJhdGlvID09PSB2b2lkIDApIHtcbiAgICByYXRpbyA9IDEuMztcbiAgfVxuICByZXR1cm4gXCJcXG4gICAgQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiBcIiArIHJhdGlvICsgXCIpLFxcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogXCIgKyByYXRpbyArIFwiKSxcXG4gICAgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiBcIiArIHJhdGlvICsgXCIvMSksXFxuICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IFwiICsgTWF0aC5yb3VuZChyYXRpbyAqIDk2KSArIFwiZHBpKSxcXG4gICAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogXCIgKyByYXRpbyArIFwiZHBweClcXG4gIFwiO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RHcmFkaWVudFZhbHVlKGxpdGVyYWxzKSB7XG4gIHZhciB0ZW1wbGF0ZSA9ICcnO1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3Vic3RpdHV0aW9ucyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3Vic3RpdHV0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXRlcmFscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHRlbXBsYXRlICs9IGxpdGVyYWxzW2ldO1xuICAgIGlmIChpID09PSBzdWJzdGl0dXRpb25zLmxlbmd0aCAtIDEgJiYgc3Vic3RpdHV0aW9uc1tpXSkge1xuICAgICAgdmFyIGRlZmluZWRWYWx1ZXMgPSBzdWJzdGl0dXRpb25zLmZpbHRlcihmdW5jdGlvbiAoc3Vic3RpdHV0ZSkge1xuICAgICAgICByZXR1cm4gISFzdWJzdGl0dXRlO1xuICAgICAgfSk7XG4gICAgICAvLyBBZGRzIGxlYWRpbmcgY29tYSBpZiBwcm9wZXJ0aWVzIHByZWNlZWQgY29sb3Itc3RvcHNcbiAgICAgIGlmIChkZWZpbmVkVmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5zbGljZSgwLCAtMSk7XG4gICAgICAgIHRlbXBsYXRlICs9IFwiLCBcIiArIHN1YnN0aXR1dGlvbnNbaV07XG4gICAgICAgIC8vIE5vIHRyYWlsaW5nIHNwYWNlIGlmIGNvbG9yLXN0b3BzIGlzIHRoZSBvbmx5IHBhcmFtIHByb3ZpZGVkXG4gICAgICB9IGVsc2UgaWYgKGRlZmluZWRWYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IFwiXCIgKyBzdWJzdGl0dXRpb25zW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3Vic3RpdHV0aW9uc1tpXSkge1xuICAgICAgdGVtcGxhdGUgKz0gc3Vic3RpdHV0aW9uc1tpXSArIFwiIFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGVtcGxhdGUudHJpbSgpO1xufVxuXG52YXIgX3RlbXBsYXRlT2JqZWN0JDE7XG4vKipcbiAqIENTUyBmb3IgZGVjbGFyaW5nIGEgbGluZWFyIGdyYWRpZW50LCBpbmNsdWRpbmcgYSBmYWxsYmFjayBiYWNrZ3JvdW5kLWNvbG9yLiBUaGUgZmFsbGJhY2sgaXMgZWl0aGVyIHRoZSBmaXJzdCBjb2xvci1zdG9wIG9yIGFuIGV4cGxpY2l0bHkgcGFzc2VkIGZhbGxiYWNrIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmxpbmVhckdyYWRpZW50KHtcbiAgICAgICAgY29sb3JTdG9wczogWycjMDBGRkZGIDAlJywgJ3JnYmEoMCwgMCwgMjU1LCAwKSA1MCUnLCAnIzAwMDBGRiA5NSUnXSxcbiAgICAgICAgdG9EaXJlY3Rpb246ICd0byB0b3AgcmlnaHQnLFxuICAgICAgICBmYWxsYmFjazogJyNGRkYnLFxuICAgICAgfSlcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtsaW5lYXJHcmFkaWVudCh7XG4gICAgICAgIGNvbG9yU3RvcHM6IFsnIzAwRkZGRiAwJScsICdyZ2JhKDAsIDAsIDI1NSwgMCkgNTAlJywgJyMwMDAwRkYgOTUlJ10sXG4gICAgICAgIHRvRGlyZWN0aW9uOiAndG8gdG9wIHJpZ2h0JyxcbiAgICAgICAgZmFsbGJhY2s6ICcjRkZGJyxcbiAgICAgIH0pfVxuICpgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICAnYmFja2dyb3VuZENvbG9yJzogJyNGRkYnLFxuICogICAnYmFja2dyb3VuZEltYWdlJzogJ2xpbmVhci1ncmFkaWVudCh0byB0b3AgcmlnaHQsICMwMEZGRkYgMCUsIHJnYmEoMCwgMCwgMjU1LCAwKSA1MCUsICMwMDAwRkYgOTUlKScsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KF9yZWYpIHtcbiAgdmFyIGNvbG9yU3RvcHMgPSBfcmVmLmNvbG9yU3RvcHMsXG4gICAgZmFsbGJhY2sgPSBfcmVmLmZhbGxiYWNrLFxuICAgIF9yZWYkdG9EaXJlY3Rpb24gPSBfcmVmLnRvRGlyZWN0aW9uLFxuICAgIHRvRGlyZWN0aW9uID0gX3JlZiR0b0RpcmVjdGlvbiA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHRvRGlyZWN0aW9uO1xuICBpZiAoIWNvbG9yU3RvcHMgfHwgY29sb3JTdG9wcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTYpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBmYWxsYmFjayB8fCBjb2xvclN0b3BzWzBdLnJlcGxhY2UoLyxcXHMrL2csICcsJykuc3BsaXQoJyAnKVswXS5yZXBsYWNlKC8sKD89XFxTKS9nLCAnLCAnKSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IGNvbnN0cnVjdEdyYWRpZW50VmFsdWUoX3RlbXBsYXRlT2JqZWN0JDEgfHwgKF90ZW1wbGF0ZU9iamVjdCQxID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFtcImxpbmVhci1ncmFkaWVudChcIiwgXCJcIiwgXCIpXCJdKSksIHRvRGlyZWN0aW9uLCBjb2xvclN0b3BzLmpvaW4oJywgJykucmVwbGFjZSgvLCg/PVxcUykvZywgJywgJykpXG4gIH07XG59XG5cbi8qKlxuICogQ1NTIHRvIG5vcm1hbGl6ZSBhYm5vcm1hbGl0aWVzIGFjcm9zcyBicm93c2VycyAobm9ybWFsaXplLmNzcyB2OC4wLjEgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICAuLi5ub3JtYWxpemUoKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgR2xvYmFsU3R5bGUgPSBjcmVhdGVHbG9iYWxTdHlsZWAke25vcm1hbGl6ZSgpfWBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogaHRtbCB7XG4gKiAgIGxpbmVIZWlnaHQ6IDEuMTUsXG4gKiAgIHRleHRTaXplQWRqdXN0OiAxMDAlLFxuICogfSAuLi5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICB2YXIgX3JlZjtcbiAgcmV0dXJuIFsoX3JlZiA9IHtcbiAgICBodG1sOiB7XG4gICAgICBsaW5lSGVpZ2h0OiAnMS4xNScsXG4gICAgICB0ZXh0U2l6ZUFkanVzdDogJzEwMCUnXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgbWFpbjoge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgIH0sXG4gICAgaDE6IHtcbiAgICAgIGZvbnRTaXplOiAnMmVtJyxcbiAgICAgIG1hcmdpbjogJzAuNjdlbSAwJ1xuICAgIH0sXG4gICAgaHI6IHtcbiAgICAgIGJveFNpemluZzogJ2NvbnRlbnQtYm94JyxcbiAgICAgIGhlaWdodDogJzAnLFxuICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJ1xuICAgIH0sXG4gICAgcHJlOiB7XG4gICAgICBmb250RmFtaWx5OiAnbW9ub3NwYWNlLCBtb25vc3BhY2UnLFxuICAgICAgZm9udFNpemU6ICcxZW0nXG4gICAgfSxcbiAgICBhOiB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcbiAgICB9LFxuICAgICdhYmJyW3RpdGxlXSc6IHtcbiAgICAgIGJvcmRlckJvdHRvbTogJ25vbmUnLFxuICAgICAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnXG4gICAgfVxuICB9LCBfcmVmW1wiYixcXG4gICAgc3Ryb25nXCJdID0ge1xuICAgIGZvbnRXZWlnaHQ6ICdib2xkZXInXG4gIH0sIF9yZWZbXCJjb2RlLFxcbiAgICBrYmQsXFxuICAgIHNhbXBcIl0gPSB7XG4gICAgZm9udEZhbWlseTogJ21vbm9zcGFjZSwgbW9ub3NwYWNlJyxcbiAgICBmb250U2l6ZTogJzFlbSdcbiAgfSwgX3JlZi5zbWFsbCA9IHtcbiAgICBmb250U2l6ZTogJzgwJSdcbiAgfSwgX3JlZltcInN1YixcXG4gICAgc3VwXCJdID0ge1xuICAgIGZvbnRTaXplOiAnNzUlJyxcbiAgICBsaW5lSGVpZ2h0OiAnMCcsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgdmVydGljYWxBbGlnbjogJ2Jhc2VsaW5lJ1xuICB9LCBfcmVmLnN1YiA9IHtcbiAgICBib3R0b206ICctMC4yNWVtJ1xuICB9LCBfcmVmLnN1cCA9IHtcbiAgICB0b3A6ICctMC41ZW0nXG4gIH0sIF9yZWYuaW1nID0ge1xuICAgIGJvcmRlclN0eWxlOiAnbm9uZSdcbiAgfSwgX3JlZltcImJ1dHRvbixcXG4gICAgaW5wdXQsXFxuICAgIG9wdGdyb3VwLFxcbiAgICBzZWxlY3QsXFxuICAgIHRleHRhcmVhXCJdID0ge1xuICAgIGZvbnRGYW1pbHk6ICdpbmhlcml0JyxcbiAgICBmb250U2l6ZTogJzEwMCUnLFxuICAgIGxpbmVIZWlnaHQ6ICcxLjE1JyxcbiAgICBtYXJnaW46ICcwJ1xuICB9LCBfcmVmW1wiYnV0dG9uLFxcbiAgICBpbnB1dFwiXSA9IHtcbiAgICBvdmVyZmxvdzogJ3Zpc2libGUnXG4gIH0sIF9yZWZbXCJidXR0b24sXFxuICAgIHNlbGVjdFwiXSA9IHtcbiAgICB0ZXh0VHJhbnNmb3JtOiAnbm9uZSdcbiAgfSwgX3JlZltcImJ1dHRvbixcXG4gICAgaHRtbCBbdHlwZT1cXFwiYnV0dG9uXFxcIl0sXFxuICAgIFt0eXBlPVxcXCJyZXNldFxcXCJdLFxcbiAgICBbdHlwZT1cXFwic3VibWl0XFxcIl1cIl0gPSB7XG4gICAgV2Via2l0QXBwZWFyYW5jZTogJ2J1dHRvbidcbiAgfSwgX3JlZltcImJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgW3R5cGU9XFxcImJ1dHRvblxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICBbdHlwZT1cXFwicmVzZXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgW3R5cGU9XFxcInN1Ym1pdFxcXCJdOjotbW96LWZvY3VzLWlubmVyXCJdID0ge1xuICAgIGJvcmRlclN0eWxlOiAnbm9uZScsXG4gICAgcGFkZGluZzogJzAnXG4gIH0sIF9yZWZbXCJidXR0b246LW1vei1mb2N1c3JpbmcsXFxuICAgIFt0eXBlPVxcXCJidXR0b25cXFwiXTotbW96LWZvY3VzcmluZyxcXG4gICAgW3R5cGU9XFxcInJlc2V0XFxcIl06LW1vei1mb2N1c3JpbmcsXFxuICAgIFt0eXBlPVxcXCJzdWJtaXRcXFwiXTotbW96LWZvY3VzcmluZ1wiXSA9IHtcbiAgICBvdXRsaW5lOiAnMXB4IGRvdHRlZCBCdXR0b25UZXh0J1xuICB9LCBfcmVmLmZpZWxkc2V0ID0ge1xuICAgIHBhZGRpbmc6ICcwLjM1ZW0gMC42MjVlbSAwLjc1ZW0nXG4gIH0sIF9yZWYubGVnZW5kID0ge1xuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGNvbG9yOiAnaW5oZXJpdCcsXG4gICAgZGlzcGxheTogJ3RhYmxlJyxcbiAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgIHBhZGRpbmc6ICcwJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm9ybWFsJ1xuICB9LCBfcmVmLnByb2dyZXNzID0ge1xuICAgIHZlcnRpY2FsQWxpZ246ICdiYXNlbGluZSdcbiAgfSwgX3JlZi50ZXh0YXJlYSA9IHtcbiAgICBvdmVyZmxvdzogJ2F1dG8nXG4gIH0sIF9yZWZbXCJbdHlwZT1cXFwiY2hlY2tib3hcXFwiXSxcXG4gICAgW3R5cGU9XFxcInJhZGlvXFxcIl1cIl0gPSB7XG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgcGFkZGluZzogJzAnXG4gIH0sIF9yZWZbXCJbdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuICAgIFt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvblwiXSA9IHtcbiAgICBoZWlnaHQ6ICdhdXRvJ1xuICB9LCBfcmVmWydbdHlwZT1cInNlYXJjaFwiXSddID0ge1xuICAgIFdlYmtpdEFwcGVhcmFuY2U6ICd0ZXh0ZmllbGQnLFxuICAgIG91dGxpbmVPZmZzZXQ6ICctMnB4J1xuICB9LCBfcmVmWydbdHlwZT1cInNlYXJjaFwiXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiddID0ge1xuICAgIFdlYmtpdEFwcGVhcmFuY2U6ICdub25lJ1xuICB9LCBfcmVmWyc6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uJ10gPSB7XG4gICAgV2Via2l0QXBwZWFyYW5jZTogJ2J1dHRvbicsXG4gICAgZm9udDogJ2luaGVyaXQnXG4gIH0sIF9yZWYuZGV0YWlscyA9IHtcbiAgICBkaXNwbGF5OiAnYmxvY2snXG4gIH0sIF9yZWYuc3VtbWFyeSA9IHtcbiAgICBkaXNwbGF5OiAnbGlzdC1pdGVtJ1xuICB9LCBfcmVmLnRlbXBsYXRlID0ge1xuICAgIGRpc3BsYXk6ICdub25lJ1xuICB9LCBfcmVmWydbaGlkZGVuXSddID0ge1xuICAgIGRpc3BsYXk6ICdub25lJ1xuICB9LCBfcmVmKSwge1xuICAgICdhYmJyW3RpdGxlXSc6IHtcbiAgICAgIHRleHREZWNvcmF0aW9uOiAndW5kZXJsaW5lIGRvdHRlZCdcbiAgICB9XG4gIH1dO1xufVxuXG52YXIgX3RlbXBsYXRlT2JqZWN0O1xuLyoqXG4gKiBDU1MgZm9yIGRlY2xhcmluZyBhIHJhZGlhbCBncmFkaWVudCwgaW5jbHVkaW5nIGEgZmFsbGJhY2sgYmFja2dyb3VuZC1jb2xvci4gVGhlIGZhbGxiYWNrIGlzIGVpdGhlciB0aGUgZmlyc3QgY29sb3Itc3RvcCBvciBhbiBleHBsaWNpdGx5IHBhc3NlZCBmYWxsYmFjayBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5yYWRpYWxHcmFkaWVudCh7XG4gKiAgICAgY29sb3JTdG9wczogWycjMDBGRkZGIDAlJywgJ3JnYmEoMCwgMCwgMjU1LCAwKSA1MCUnLCAnIzAwMDBGRiA5NSUnXSxcbiAqICAgICBleHRlbnQ6ICdmYXJ0aGVzdC1jb3JuZXIgYXQgNDVweCA0NXB4JyxcbiAqICAgICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gKiAgICAgc2hhcGU6ICdlbGxpcHNlJyxcbiAqICAgfSlcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtyYWRpYWxHcmFkaWVudCh7XG4gKiAgICAgY29sb3JTdG9wczogWycjMDBGRkZGIDAlJywgJ3JnYmEoMCwgMCwgMjU1LCAwKSA1MCUnLCAnIzAwMDBGRiA5NSUnXSxcbiAqICAgICBleHRlbnQ6ICdmYXJ0aGVzdC1jb3JuZXIgYXQgNDVweCA0NXB4JyxcbiAqICAgICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gKiAgICAgc2hhcGU6ICdlbGxpcHNlJyxcbiAqICAgfSl9XG4gKmBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2OiB7XG4gKiAgICdiYWNrZ3JvdW5kQ29sb3InOiAnIzAwRkZGRicsXG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAncmFkaWFsLWdyYWRpZW50KGNlbnRlciBlbGxpcHNlIGZhcnRoZXN0LWNvcm5lciBhdCA0NXB4IDQ1cHgsICMwMEZGRkYgMCUsIHJnYmEoMCwgMCwgMjU1LCAwKSA1MCUsICMwMDAwRkYgOTUlKScsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHJhZGlhbEdyYWRpZW50KF9yZWYpIHtcbiAgdmFyIGNvbG9yU3RvcHMgPSBfcmVmLmNvbG9yU3RvcHMsXG4gICAgX3JlZiRleHRlbnQgPSBfcmVmLmV4dGVudCxcbiAgICBleHRlbnQgPSBfcmVmJGV4dGVudCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGV4dGVudCxcbiAgICBmYWxsYmFjayA9IF9yZWYuZmFsbGJhY2ssXG4gICAgX3JlZiRwb3NpdGlvbiA9IF9yZWYucG9zaXRpb24sXG4gICAgcG9zaXRpb24gPSBfcmVmJHBvc2l0aW9uID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkcG9zaXRpb24sXG4gICAgX3JlZiRzaGFwZSA9IF9yZWYuc2hhcGUsXG4gICAgc2hhcGUgPSBfcmVmJHNoYXBlID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkc2hhcGU7XG4gIGlmICghY29sb3JTdG9wcyB8fCBjb2xvclN0b3BzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig1Nyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGZhbGxiYWNrIHx8IGNvbG9yU3RvcHNbMF0uc3BsaXQoJyAnKVswXSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IGNvbnN0cnVjdEdyYWRpZW50VmFsdWUoX3RlbXBsYXRlT2JqZWN0IHx8IChfdGVtcGxhdGVPYmplY3QgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoW1wicmFkaWFsLWdyYWRpZW50KFwiLCBcIlwiLCBcIlwiLCBcIlwiLCBcIilcIl0pKSwgcG9zaXRpb24sIHNoYXBlLCBleHRlbnQsIGNvbG9yU3RvcHMuam9pbignLCAnKSlcbiAgfTtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciB0byBnZW5lcmF0ZSBhIHJldGluYSBiYWNrZ3JvdW5kIGltYWdlIGFuZCBub24tcmV0aW5hXG4gKiBiYWNrZ3JvdW5kIGltYWdlLiBUaGUgcmV0aW5hIGJhY2tncm91bmQgaW1hZ2Ugd2lsbCBvdXRwdXQgdG8gYSBIaURQSSBtZWRpYSBxdWVyeS4gVGhlIG1peGluIHVzZXNcbiAqIGEgXzJ4LnBuZyBmaWxlbmFtZSBzdWZmaXggYnkgZGVmYXVsdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogIC4uLnJldGluYUltYWdlKCdteS1pbWcnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3JldGluYUltYWdlKCdteS1pbWcnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKiBkaXYge1xuICogICBiYWNrZ3JvdW5kSW1hZ2U6ICd1cmwobXktaW1nLnBuZyknLFxuICogICAnQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjMpLFxuICogICAgb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDEuMyksXG4gKiAgICBvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDEuMy8xKSxcbiAqICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE0NGRwaSksXG4gKiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxLjVkcHB4KSc6IHtcbiAqICAgICBiYWNrZ3JvdW5kSW1hZ2U6ICd1cmwobXktaW1nXzJ4LnBuZyknLFxuICogICB9XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHJldGluYUltYWdlKGZpbGVuYW1lLCBiYWNrZ3JvdW5kU2l6ZSwgZXh0ZW5zaW9uLCByZXRpbmFGaWxlbmFtZSwgcmV0aW5hU3VmZml4KSB7XG4gIHZhciBfcmVmO1xuICBpZiAoZXh0ZW5zaW9uID09PSB2b2lkIDApIHtcbiAgICBleHRlbnNpb24gPSAncG5nJztcbiAgfVxuICBpZiAocmV0aW5hU3VmZml4ID09PSB2b2lkIDApIHtcbiAgICByZXRpbmFTdWZmaXggPSAnXzJ4JztcbiAgfVxuICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNTgpO1xuICB9XG4gIC8vIFJlcGxhY2UgdGhlIGRvdCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXNzZWQgZXh0ZW5zaW9uIGlmIG9uZSBleGlzdHNcbiAgdmFyIGV4dCA9IGV4dGVuc2lvbi5yZXBsYWNlKC9eXFwuLywgJycpO1xuICB2YXIgckZpbGVuYW1lID0gcmV0aW5hRmlsZW5hbWUgPyByZXRpbmFGaWxlbmFtZSArIFwiLlwiICsgZXh0IDogXCJcIiArIGZpbGVuYW1lICsgcmV0aW5hU3VmZml4ICsgXCIuXCIgKyBleHQ7XG4gIHJldHVybiBfcmVmID0ge1xuICAgIGJhY2tncm91bmRJbWFnZTogXCJ1cmwoXCIgKyBmaWxlbmFtZSArIFwiLlwiICsgZXh0ICsgXCIpXCJcbiAgfSwgX3JlZltoaURQSSgpXSA9IF9leHRlbmRzKHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwidXJsKFwiICsgckZpbGVuYW1lICsgXCIpXCJcbiAgfSwgYmFja2dyb3VuZFNpemUgPyB7XG4gICAgYmFja2dyb3VuZFNpemU6IGJhY2tncm91bmRTaXplXG4gIH0gOiB7fSksIF9yZWY7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG52YXIgZnVuY3Rpb25zTWFwID0ge1xuICBlYXNlSW5CYWNrOiAnY3ViaWMtYmV6aWVyKDAuNjAwLCAtMC4yODAsIDAuNzM1LCAwLjA0NSknLFxuICBlYXNlSW5DaXJjOiAnY3ViaWMtYmV6aWVyKDAuNjAwLCAgMC4wNDAsIDAuOTgwLCAwLjMzNSknLFxuICBlYXNlSW5DdWJpYzogJ2N1YmljLWJlemllcigwLjU1MCwgIDAuMDU1LCAwLjY3NSwgMC4xOTApJyxcbiAgZWFzZUluRXhwbzogJ2N1YmljLWJlemllcigwLjk1MCwgIDAuMDUwLCAwLjc5NSwgMC4wMzUpJyxcbiAgZWFzZUluUXVhZDogJ2N1YmljLWJlemllcigwLjU1MCwgIDAuMDg1LCAwLjY4MCwgMC41MzApJyxcbiAgZWFzZUluUXVhcnQ6ICdjdWJpYy1iZXppZXIoMC44OTUsICAwLjAzMCwgMC42ODUsIDAuMjIwKScsXG4gIGVhc2VJblF1aW50OiAnY3ViaWMtYmV6aWVyKDAuNzU1LCAgMC4wNTAsIDAuODU1LCAwLjA2MCknLFxuICBlYXNlSW5TaW5lOiAnY3ViaWMtYmV6aWVyKDAuNDcwLCAgMC4wMDAsIDAuNzQ1LCAwLjcxNSknLFxuICBlYXNlT3V0QmFjazogJ2N1YmljLWJlemllcigwLjE3NSwgIDAuODg1LCAwLjMyMCwgMS4yNzUpJyxcbiAgZWFzZU91dEN1YmljOiAnY3ViaWMtYmV6aWVyKDAuMjE1LCAgMC42MTAsIDAuMzU1LCAxLjAwMCknLFxuICBlYXNlT3V0Q2lyYzogJ2N1YmljLWJlemllcigwLjA3NSwgIDAuODIwLCAwLjE2NSwgMS4wMDApJyxcbiAgZWFzZU91dEV4cG86ICdjdWJpYy1iZXppZXIoMC4xOTAsICAxLjAwMCwgMC4yMjAsIDEuMDAwKScsXG4gIGVhc2VPdXRRdWFkOiAnY3ViaWMtYmV6aWVyKDAuMjUwLCAgMC40NjAsIDAuNDUwLCAwLjk0MCknLFxuICBlYXNlT3V0UXVhcnQ6ICdjdWJpYy1iZXppZXIoMC4xNjUsICAwLjg0MCwgMC40NDAsIDEuMDAwKScsXG4gIGVhc2VPdXRRdWludDogJ2N1YmljLWJlemllcigwLjIzMCwgIDEuMDAwLCAwLjMyMCwgMS4wMDApJyxcbiAgZWFzZU91dFNpbmU6ICdjdWJpYy1iZXppZXIoMC4zOTAsICAwLjU3NSwgMC41NjUsIDEuMDAwKScsXG4gIGVhc2VJbk91dEJhY2s6ICdjdWJpYy1iZXppZXIoMC42ODAsIC0wLjU1MCwgMC4yNjUsIDEuNTUwKScsXG4gIGVhc2VJbk91dENpcmM6ICdjdWJpYy1iZXppZXIoMC43ODUsICAwLjEzNSwgMC4xNTAsIDAuODYwKScsXG4gIGVhc2VJbk91dEN1YmljOiAnY3ViaWMtYmV6aWVyKDAuNjQ1LCAgMC4wNDUsIDAuMzU1LCAxLjAwMCknLFxuICBlYXNlSW5PdXRFeHBvOiAnY3ViaWMtYmV6aWVyKDEuMDAwLCAgMC4wMDAsIDAuMDAwLCAxLjAwMCknLFxuICBlYXNlSW5PdXRRdWFkOiAnY3ViaWMtYmV6aWVyKDAuNDU1LCAgMC4wMzAsIDAuNTE1LCAwLjk1NSknLFxuICBlYXNlSW5PdXRRdWFydDogJ2N1YmljLWJlemllcigwLjc3MCwgIDAuMDAwLCAwLjE3NSwgMS4wMDApJyxcbiAgZWFzZUluT3V0UXVpbnQ6ICdjdWJpYy1iZXppZXIoMC44NjAsICAwLjAwMCwgMC4wNzAsIDEuMDAwKScsXG4gIGVhc2VJbk91dFNpbmU6ICdjdWJpYy1iZXppZXIoMC40NDUsICAwLjA1MCwgMC41NTAsIDAuOTUwKSdcbn07XG4vKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG5cbmZ1bmN0aW9uIGdldFRpbWluZ0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb25zTWFwW2Z1bmN0aW9uTmFtZV07XG59XG5cbi8qKlxuICogU3RyaW5nIHRvIHJlcHJlc2VudCBjb21tb24gZWFzaW5nIGZ1bmN0aW9ucyBhcyBkZW1vbnN0cmF0ZWQgaGVyZTogKGdpdGh1Yi5jb20vamF1a2lhL2Vhc2llKS5cbiAqXG4gKiBAZGVwcmVjYXRlZCAtIFRoaXMgd2lsbCBiZSBkZXByZWNhdGVkIGluIHY1IGluIGZhdm9yIG9mIGBlYXNlSW5gLCBgZWFzZU91dGAsIGBlYXNlSW5PdXRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiB0aW1pbmdGdW5jdGlvbnMoJ2Vhc2VJblF1YWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiAgY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiAke3RpbWluZ0Z1bmN0aW9ucygnZWFzZUluUXVhZCcpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbic6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA4NSwgMC42ODAsIDAuNTMwKScsXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gdGltaW5nRnVuY3Rpb25zKHRpbWluZ0Z1bmN0aW9uKSB7XG4gIHJldHVybiBnZXRUaW1pbmdGdW5jdGlvbih0aW1pbmdGdW5jdGlvbik7XG59XG5cbnZhciBnZXRCb3JkZXJXaWR0aCA9IGZ1bmN0aW9uIGdldEJvcmRlcldpZHRoKHBvaW50aW5nRGlyZWN0aW9uLCBoZWlnaHQsIHdpZHRoKSB7XG4gIHZhciBmdWxsV2lkdGggPSBcIlwiICsgd2lkdGhbMF0gKyAod2lkdGhbMV0gfHwgJycpO1xuICB2YXIgaGFsZldpZHRoID0gXCJcIiArIHdpZHRoWzBdIC8gMiArICh3aWR0aFsxXSB8fCAnJyk7XG4gIHZhciBmdWxsSGVpZ2h0ID0gXCJcIiArIGhlaWdodFswXSArIChoZWlnaHRbMV0gfHwgJycpO1xuICB2YXIgaGFsZkhlaWdodCA9IFwiXCIgKyBoZWlnaHRbMF0gLyAyICsgKGhlaWdodFsxXSB8fCAnJyk7XG4gIHN3aXRjaCAocG9pbnRpbmdEaXJlY3Rpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgcmV0dXJuIFwiMCBcIiArIGhhbGZXaWR0aCArIFwiIFwiICsgZnVsbEhlaWdodCArIFwiIFwiICsgaGFsZldpZHRoO1xuICAgIGNhc2UgJ3RvcExlZnQnOlxuICAgICAgcmV0dXJuIGZ1bGxXaWR0aCArIFwiIFwiICsgZnVsbEhlaWdodCArIFwiIDAgMFwiO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIGhhbGZIZWlnaHQgKyBcIiBcIiArIGZ1bGxXaWR0aCArIFwiIFwiICsgaGFsZkhlaWdodCArIFwiIDBcIjtcbiAgICBjYXNlICdib3R0b21MZWZ0JzpcbiAgICAgIHJldHVybiBmdWxsV2lkdGggKyBcIiAwIDAgXCIgKyBmdWxsSGVpZ2h0O1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICByZXR1cm4gZnVsbEhlaWdodCArIFwiIFwiICsgaGFsZldpZHRoICsgXCIgMCBcIiArIGhhbGZXaWR0aDtcbiAgICBjYXNlICdib3R0b21SaWdodCc6XG4gICAgICByZXR1cm4gXCIwIDAgXCIgKyBmdWxsV2lkdGggKyBcIiBcIiArIGZ1bGxIZWlnaHQ7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcmV0dXJuIGhhbGZIZWlnaHQgKyBcIiAwIFwiICsgaGFsZkhlaWdodCArIFwiIFwiICsgZnVsbFdpZHRoO1xuICAgIGNhc2UgJ3RvcFJpZ2h0JzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiMCBcIiArIGZ1bGxXaWR0aCArIFwiIFwiICsgZnVsbEhlaWdodCArIFwiIDBcIjtcbiAgfVxufTtcbnZhciBnZXRCb3JkZXJDb2xvciA9IGZ1bmN0aW9uIGdldEJvcmRlckNvbG9yKHBvaW50aW5nRGlyZWN0aW9uLCBmb3JlZ3JvdW5kQ29sb3IpIHtcbiAgc3dpdGNoIChwb2ludGluZ0RpcmVjdGlvbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tUmlnaHQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYm9yZGVyQm90dG9tQ29sb3I6IGZvcmVncm91bmRDb2xvclxuICAgICAgfTtcbiAgICBjYXNlICdyaWdodCc6XG4gICAgY2FzZSAnYm90dG9tTGVmdCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib3JkZXJMZWZ0Q29sb3I6IGZvcmVncm91bmRDb2xvclxuICAgICAgfTtcbiAgICBjYXNlICdib3R0b20nOlxuICAgIGNhc2UgJ3RvcExlZnQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYm9yZGVyVG9wQ29sb3I6IGZvcmVncm91bmRDb2xvclxuICAgICAgfTtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICd0b3BSaWdodCc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib3JkZXJSaWdodENvbG9yOiBmb3JlZ3JvdW5kQ29sb3JcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDU5KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDU1MgdG8gcmVwcmVzZW50IHRyaWFuZ2xlIHdpdGggYW55IHBvaW50aW5nIGRpcmVjdGlvbiB3aXRoIGFuIG9wdGlvbmFsIGJhY2tncm91bmQgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnRyaWFuZ2xlKHsgcG9pbnRpbmdEaXJlY3Rpb246ICdyaWdodCcsIHdpZHRoOiAnMTAwcHgnLCBoZWlnaHQ6ICcxMDBweCcsIGZvcmVncm91bmRDb2xvcjogJ3JlZCcgfSlcbiAqIH1cbiAqXG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7dHJpYW5nbGUoeyBwb2ludGluZ0RpcmVjdGlvbjogJ3JpZ2h0Jywgd2lkdGg6ICcxMDBweCcsIGhlaWdodDogJzEwMHB4JywgZm9yZWdyb3VuZENvbG9yOiAncmVkJyB9KX1cbiAqXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICdib3JkZXJDb2xvcic6ICd0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCByZWQnLFxuICogICdib3JkZXJTdHlsZSc6ICdzb2xpZCcsXG4gKiAgJ2JvcmRlcldpZHRoJzogJzUwcHggMCA1MHB4IDEwMHB4JyxcbiAqICAnaGVpZ2h0JzogJzAnLFxuICogICd3aWR0aCc6ICcwJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gdHJpYW5nbGUoX3JlZikge1xuICB2YXIgcG9pbnRpbmdEaXJlY3Rpb24gPSBfcmVmLnBvaW50aW5nRGlyZWN0aW9uLFxuICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICBmb3JlZ3JvdW5kQ29sb3IgPSBfcmVmLmZvcmVncm91bmRDb2xvcixcbiAgICBfcmVmJGJhY2tncm91bmRDb2xvciA9IF9yZWYuYmFja2dyb3VuZENvbG9yLFxuICAgIGJhY2tncm91bmRDb2xvciA9IF9yZWYkYmFja2dyb3VuZENvbG9yID09PSB2b2lkIDAgPyAndHJhbnNwYXJlbnQnIDogX3JlZiRiYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciB3aWR0aEFuZFVuaXQgPSBnZXRWYWx1ZUFuZFVuaXQod2lkdGgpO1xuICB2YXIgaGVpZ2h0QW5kVW5pdCA9IGdldFZhbHVlQW5kVW5pdChoZWlnaHQpO1xuICBpZiAoaXNOYU4oaGVpZ2h0QW5kVW5pdFswXSkgfHwgaXNOYU4od2lkdGhBbmRVbml0WzBdKSkge1xuICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDYwKTtcbiAgfVxuICByZXR1cm4gX2V4dGVuZHMoe1xuICAgIHdpZHRoOiAnMCcsXG4gICAgaGVpZ2h0OiAnMCcsXG4gICAgYm9yZGVyQ29sb3I6IGJhY2tncm91bmRDb2xvclxuICB9LCBnZXRCb3JkZXJDb2xvcihwb2ludGluZ0RpcmVjdGlvbiwgZm9yZWdyb3VuZENvbG9yKSwge1xuICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxuICAgIGJvcmRlcldpZHRoOiBnZXRCb3JkZXJXaWR0aChwb2ludGluZ0RpcmVjdGlvbiwgaGVpZ2h0QW5kVW5pdCwgd2lkdGhBbmRVbml0KVxuICB9KTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhbiBlYXN5IHdheSB0byBjaGFuZ2UgdGhlIGB3b3JkV3JhcGAgcHJvcGVydHkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ud29yZFdyYXAoJ2JyZWFrLXdvcmQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3dvcmRXcmFwKCdicmVhay13b3JkJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgb3ZlcmZsb3dXcmFwOiAnYnJlYWstd29yZCcsXG4gKiAgIHdvcmRXcmFwOiAnYnJlYWstd29yZCcsXG4gKiAgIHdvcmRCcmVhazogJ2JyZWFrLWFsbCcsXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHdvcmRXcmFwKHdyYXApIHtcbiAgaWYgKHdyYXAgPT09IHZvaWQgMCkge1xuICAgIHdyYXAgPSAnYnJlYWstd29yZCc7XG4gIH1cbiAgdmFyIHdvcmRCcmVhayA9IHdyYXAgPT09ICdicmVhay13b3JkJyA/ICdicmVhay1hbGwnIDogd3JhcDtcbiAgcmV0dXJuIHtcbiAgICBvdmVyZmxvd1dyYXA6IHdyYXAsXG4gICAgd29yZFdyYXA6IHdyYXAsXG4gICAgd29yZEJyZWFrOiB3b3JkQnJlYWtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29sb3JUb0ludChjb2xvcikge1xuICByZXR1cm4gTWF0aC5yb3VuZChjb2xvciAqIDI1NSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9JbnQocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZXR1cm4gY29sb3JUb0ludChyZWQpICsgXCIsXCIgKyBjb2xvclRvSW50KGdyZWVuKSArIFwiLFwiICsgY29sb3JUb0ludChibHVlKTtcbn1cbmZ1bmN0aW9uIGhzbFRvUmdiKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBjb252ZXJ0KSB7XG4gIGlmIChjb252ZXJ0ID09PSB2b2lkIDApIHtcbiAgICBjb252ZXJ0ID0gY29udmVydFRvSW50O1xuICB9XG4gIGlmIChzYXR1cmF0aW9uID09PSAwKSB7XG4gICAgLy8gYWNocm9tYXRpY1xuICAgIHJldHVybiBjb252ZXJ0KGxpZ2h0bmVzcywgbGlnaHRuZXNzLCBsaWdodG5lc3MpO1xuICB9XG5cbiAgLy8gZm9ybXVsYWUgZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfYW5kX0hTVlxuICB2YXIgaHVlUHJpbWUgPSAoaHVlICUgMzYwICsgMzYwKSAlIDM2MCAvIDYwO1xuICB2YXIgY2hyb21hID0gKDEgLSBNYXRoLmFicygyICogbGlnaHRuZXNzIC0gMSkpICogc2F0dXJhdGlvbjtcbiAgdmFyIHNlY29uZENvbXBvbmVudCA9IGNocm9tYSAqICgxIC0gTWF0aC5hYnMoaHVlUHJpbWUgJSAyIC0gMSkpO1xuICB2YXIgcmVkID0gMDtcbiAgdmFyIGdyZWVuID0gMDtcbiAgdmFyIGJsdWUgPSAwO1xuICBpZiAoaHVlUHJpbWUgPj0gMCAmJiBodWVQcmltZSA8IDEpIHtcbiAgICByZWQgPSBjaHJvbWE7XG4gICAgZ3JlZW4gPSBzZWNvbmRDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoaHVlUHJpbWUgPj0gMSAmJiBodWVQcmltZSA8IDIpIHtcbiAgICByZWQgPSBzZWNvbmRDb21wb25lbnQ7XG4gICAgZ3JlZW4gPSBjaHJvbWE7XG4gIH0gZWxzZSBpZiAoaHVlUHJpbWUgPj0gMiAmJiBodWVQcmltZSA8IDMpIHtcbiAgICBncmVlbiA9IGNocm9tYTtcbiAgICBibHVlID0gc2Vjb25kQ29tcG9uZW50O1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDMgJiYgaHVlUHJpbWUgPCA0KSB7XG4gICAgZ3JlZW4gPSBzZWNvbmRDb21wb25lbnQ7XG4gICAgYmx1ZSA9IGNocm9tYTtcbiAgfSBlbHNlIGlmIChodWVQcmltZSA+PSA0ICYmIGh1ZVByaW1lIDwgNSkge1xuICAgIHJlZCA9IHNlY29uZENvbXBvbmVudDtcbiAgICBibHVlID0gY2hyb21hO1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDUgJiYgaHVlUHJpbWUgPCA2KSB7XG4gICAgcmVkID0gY2hyb21hO1xuICAgIGJsdWUgPSBzZWNvbmRDb21wb25lbnQ7XG4gIH1cbiAgdmFyIGxpZ2h0bmVzc01vZGlmaWNhdGlvbiA9IGxpZ2h0bmVzcyAtIGNocm9tYSAvIDI7XG4gIHZhciBmaW5hbFJlZCA9IHJlZCArIGxpZ2h0bmVzc01vZGlmaWNhdGlvbjtcbiAgdmFyIGZpbmFsR3JlZW4gPSBncmVlbiArIGxpZ2h0bmVzc01vZGlmaWNhdGlvbjtcbiAgdmFyIGZpbmFsQmx1ZSA9IGJsdWUgKyBsaWdodG5lc3NNb2RpZmljYXRpb247XG4gIHJldHVybiBjb252ZXJ0KGZpbmFsUmVkLCBmaW5hbEdyZWVuLCBmaW5hbEJsdWUpO1xufVxuXG52YXIgbmFtZWRDb2xvck1hcCA9IHtcbiAgYWxpY2VibHVlOiAnZjBmOGZmJyxcbiAgYW50aXF1ZXdoaXRlOiAnZmFlYmQ3JyxcbiAgYXF1YTogJzAwZmZmZicsXG4gIGFxdWFtYXJpbmU6ICc3ZmZmZDQnLFxuICBhenVyZTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwMDAnLFxuICBibGFuY2hlZGFsbW9uZDogJ2ZmZWJjZCcsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBibHVldmlvbGV0OiAnOGEyYmUyJyxcbiAgYnJvd246ICdhNTJhMmEnLFxuICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICBjYWRldGJsdWU6ICc1ZjllYTAnLFxuICBjaGFydHJldXNlOiAnN2ZmZjAwJyxcbiAgY2hvY29sYXRlOiAnZDI2OTFlJyxcbiAgY29yYWw6ICdmZjdmNTAnLFxuICBjb3JuZmxvd2VyYmx1ZTogJzY0OTVlZCcsXG4gIGNvcm5zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICcwMGZmZmYnLFxuICBkYXJrYmx1ZTogJzAwMDA4YicsXG4gIGRhcmtjeWFuOiAnMDA4YjhiJyxcbiAgZGFya2dvbGRlbnJvZDogJ2I4ODYwYicsXG4gIGRhcmtncmF5OiAnYTlhOWE5JyxcbiAgZGFya2dyZWVuOiAnMDA2NDAwJyxcbiAgZGFya2dyZXk6ICdhOWE5YTknLFxuICBkYXJra2hha2k6ICdiZGI3NmInLFxuICBkYXJrbWFnZW50YTogJzhiMDA4YicsXG4gIGRhcmtvbGl2ZWdyZWVuOiAnNTU2YjJmJyxcbiAgZGFya29yYW5nZTogJ2ZmOGMwMCcsXG4gIGRhcmtvcmNoaWQ6ICc5OTMyY2MnLFxuICBkYXJrcmVkOiAnOGIwMDAwJyxcbiAgZGFya3NhbG1vbjogJ2U5OTY3YScsXG4gIGRhcmtzZWFncmVlbjogJzhmYmM4ZicsXG4gIGRhcmtzbGF0ZWJsdWU6ICc0ODNkOGInLFxuICBkYXJrc2xhdGVncmF5OiAnMmY0ZjRmJyxcbiAgZGFya3NsYXRlZ3JleTogJzJmNGY0ZicsXG4gIGRhcmt0dXJxdW9pc2U6ICcwMGNlZDEnLFxuICBkYXJrdmlvbGV0OiAnOTQwMGQzJyxcbiAgZGVlcHBpbms6ICdmZjE0OTMnLFxuICBkZWVwc2t5Ymx1ZTogJzAwYmZmZicsXG4gIGRpbWdyYXk6ICc2OTY5NjknLFxuICBkaW1ncmV5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyYmx1ZTogJzFlOTBmZicsXG4gIGZpcmVicmljazogJ2IyMjIyMicsXG4gIGZsb3JhbHdoaXRlOiAnZmZmYWYwJyxcbiAgZm9yZXN0Z3JlZW46ICcyMjhiMjInLFxuICBmdWNoc2lhOiAnZmYwMGZmJyxcbiAgZ2FpbnNib3JvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3aGl0ZTogJ2Y4ZjhmZicsXG4gIGdvbGQ6ICdmZmQ3MDAnLFxuICBnb2xkZW5yb2Q6ICdkYWE1MjAnLFxuICBncmF5OiAnODA4MDgwJyxcbiAgZ3JlZW46ICcwMDgwMDAnLFxuICBncmVlbnllbGxvdzogJ2FkZmYyZicsXG4gIGdyZXk6ICc4MDgwODAnLFxuICBob25leWRldzogJ2YwZmZmMCcsXG4gIGhvdHBpbms6ICdmZjY5YjQnLFxuICBpbmRpYW5yZWQ6ICdjZDVjNWMnLFxuICBpbmRpZ286ICc0YjAwODInLFxuICBpdm9yeTogJ2ZmZmZmMCcsXG4gIGtoYWtpOiAnZjBlNjhjJyxcbiAgbGF2ZW5kZXI6ICdlNmU2ZmEnLFxuICBsYXZlbmRlcmJsdXNoOiAnZmZmMGY1JyxcbiAgbGF3bmdyZWVuOiAnN2NmYzAwJyxcbiAgbGVtb25jaGlmZm9uOiAnZmZmYWNkJyxcbiAgbGlnaHRibHVlOiAnYWRkOGU2JyxcbiAgbGlnaHRjb3JhbDogJ2YwODA4MCcsXG4gIGxpZ2h0Y3lhbjogJ2UwZmZmZicsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnZmFmYWQyJyxcbiAgbGlnaHRncmF5OiAnZDNkM2QzJyxcbiAgbGlnaHRncmVlbjogJzkwZWU5MCcsXG4gIGxpZ2h0Z3JleTogJ2QzZDNkMycsXG4gIGxpZ2h0cGluazogJ2ZmYjZjMScsXG4gIGxpZ2h0c2FsbW9uOiAnZmZhMDdhJyxcbiAgbGlnaHRzZWFncmVlbjogJzIwYjJhYScsXG4gIGxpZ2h0c2t5Ymx1ZTogJzg3Y2VmYScsXG4gIGxpZ2h0c2xhdGVncmF5OiAnNzg5JyxcbiAgbGlnaHRzbGF0ZWdyZXk6ICc3ODknLFxuICBsaWdodHN0ZWVsYmx1ZTogJ2IwYzRkZScsXG4gIGxpZ2h0eWVsbG93OiAnZmZmZmUwJyxcbiAgbGltZTogJzBmMCcsXG4gIGxpbWVncmVlbjogJzMyY2QzMicsXG4gIGxpbmVuOiAnZmFmMGU2JyxcbiAgbWFnZW50YTogJ2YwZicsXG4gIG1hcm9vbjogJzgwMDAwMCcsXG4gIG1lZGl1bWFxdWFtYXJpbmU6ICc2NmNkYWEnLFxuICBtZWRpdW1ibHVlOiAnMDAwMGNkJyxcbiAgbWVkaXVtb3JjaGlkOiAnYmE1NWQzJyxcbiAgbWVkaXVtcHVycGxlOiAnOTM3MGRiJyxcbiAgbWVkaXVtc2VhZ3JlZW46ICczY2IzNzEnLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICc3YjY4ZWUnLFxuICBtZWRpdW1zcHJpbmdncmVlbjogJzAwZmE5YScsXG4gIG1lZGl1bXR1cnF1b2lzZTogJzQ4ZDFjYycsXG4gIG1lZGl1bXZpb2xldHJlZDogJ2M3MTU4NScsXG4gIG1pZG5pZ2h0Ymx1ZTogJzE5MTk3MCcsXG4gIG1pbnRjcmVhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5cm9zZTogJ2ZmZTRlMScsXG4gIG1vY2Nhc2luOiAnZmZlNGI1JyxcbiAgbmF2YWpvd2hpdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnMDAwMDgwJyxcbiAgb2xkbGFjZTogJ2ZkZjVlNicsXG4gIG9saXZlOiAnODA4MDAwJyxcbiAgb2xpdmVkcmFiOiAnNmI4ZTIzJyxcbiAgb3JhbmdlOiAnZmZhNTAwJyxcbiAgb3JhbmdlcmVkOiAnZmY0NTAwJyxcbiAgb3JjaGlkOiAnZGE3MGQ2JyxcbiAgcGFsZWdvbGRlbnJvZDogJ2VlZThhYScsXG4gIHBhbGVncmVlbjogJzk4ZmI5OCcsXG4gIHBhbGV0dXJxdW9pc2U6ICdhZmVlZWUnLFxuICBwYWxldmlvbGV0cmVkOiAnZGI3MDkzJyxcbiAgcGFwYXlhd2hpcDogJ2ZmZWZkNScsXG4gIHBlYWNocHVmZjogJ2ZmZGFiOScsXG4gIHBlcnU6ICdjZDg1M2YnLFxuICBwaW5rOiAnZmZjMGNiJyxcbiAgcGx1bTogJ2RkYTBkZCcsXG4gIHBvd2RlcmJsdWU6ICdiMGUwZTYnLFxuICBwdXJwbGU6ICc4MDAwODAnLFxuICByZWJlY2NhcHVycGxlOiAnNjM5JyxcbiAgcmVkOiAnZjAwJyxcbiAgcm9zeWJyb3duOiAnYmM4ZjhmJyxcbiAgcm95YWxibHVlOiAnNDE2OWUxJyxcbiAgc2FkZGxlYnJvd246ICc4YjQ1MTMnLFxuICBzYWxtb246ICdmYTgwNzInLFxuICBzYW5keWJyb3duOiAnZjRhNDYwJyxcbiAgc2VhZ3JlZW46ICcyZThiNTcnLFxuICBzZWFzaGVsbDogJ2ZmZjVlZScsXG4gIHNpZW5uYTogJ2EwNTIyZCcsXG4gIHNpbHZlcjogJ2MwYzBjMCcsXG4gIHNreWJsdWU6ICc4N2NlZWInLFxuICBzbGF0ZWJsdWU6ICc2YTVhY2QnLFxuICBzbGF0ZWdyYXk6ICc3MDgwOTAnLFxuICBzbGF0ZWdyZXk6ICc3MDgwOTAnLFxuICBzbm93OiAnZmZmYWZhJyxcbiAgc3ByaW5nZ3JlZW46ICcwMGZmN2YnLFxuICBzdGVlbGJsdWU6ICc0NjgyYjQnLFxuICB0YW46ICdkMmI0OGMnLFxuICB0ZWFsOiAnMDA4MDgwJyxcbiAgdGhpc3RsZTogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIHR1cnF1b2lzZTogJzQwZTBkMCcsXG4gIHZpb2xldDogJ2VlODJlZScsXG4gIHdoZWF0OiAnZjVkZWIzJyxcbiAgd2hpdGU6ICdmZmYnLFxuICB3aGl0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgeWVsbG93OiAnZmYwJyxcbiAgeWVsbG93Z3JlZW46ICc5YWNkMzInXG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBhIENTUyBuYW1lZCBjb2xvciBhbmQgcmV0dXJucyBpdHMgZXF1aXZhbGVudCBoZXggdmFsdWUsIG90aGVyd2lzZSByZXR1cm5zIHRoZSBvcmlnaW5hbCBjb2xvci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5hbWVUb0hleChjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykgcmV0dXJuIGNvbG9yO1xuICB2YXIgbm9ybWFsaXplZENvbG9yTmFtZSA9IGNvbG9yLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBuYW1lZENvbG9yTWFwW25vcm1hbGl6ZWRDb2xvck5hbWVdID8gXCIjXCIgKyBuYW1lZENvbG9yTWFwW25vcm1hbGl6ZWRDb2xvck5hbWVdIDogY29sb3I7XG59XG5cbnZhciBoZXhSZWdleCA9IC9eI1thLWZBLUYwLTldezZ9JC87XG52YXIgaGV4UmdiYVJlZ2V4ID0gL14jW2EtZkEtRjAtOV17OH0kLztcbnZhciByZWR1Y2VkSGV4UmVnZXggPSAvXiNbYS1mQS1GMC05XXszfSQvO1xudmFyIHJlZHVjZWRSZ2JhSGV4UmVnZXggPSAvXiNbYS1mQS1GMC05XXs0fSQvO1xudmFyIHJnYlJlZ2V4ID0gL15yZ2JcXChcXHMqKFxcZHsxLDN9KVxccyooPzosKT9cXHMqKFxcZHsxLDN9KVxccyooPzosKT9cXHMqKFxcZHsxLDN9KVxccypcXCkkL2k7XG52YXIgcmdiYVJlZ2V4ID0gL15yZ2IoPzphKT9cXChcXHMqKFxcZHsxLDN9KVxccyooPzosKT9cXHMqKFxcZHsxLDN9KVxccyooPzosKT9cXHMqKFxcZHsxLDN9KVxccyooPzosfFxcLylcXHMqKFstK10/XFxkKlsuXT9cXGQrWyVdPylcXHMqXFwpJC9pO1xudmFyIGhzbFJlZ2V4ID0gL15oc2xcXChcXHMqKFxcZHswLDN9Wy5dP1swLTldKyg/OmRlZyk/KVxccyooPzosKT9cXHMqKFxcZHsxLDN9Wy5dP1swLTldPyklXFxzKig/OiwpP1xccyooXFxkezEsM31bLl0/WzAtOV0/KSVcXHMqXFwpJC9pO1xudmFyIGhzbGFSZWdleCA9IC9eaHNsKD86YSk/XFwoXFxzKihcXGR7MCwzfVsuXT9bMC05XSsoPzpkZWcpPylcXHMqKD86LCk/XFxzKihcXGR7MSwzfVsuXT9bMC05XT8pJVxccyooPzosKT9cXHMqKFxcZHsxLDN9Wy5dP1swLTldPyklXFxzKig/Oix8XFwvKVxccyooWy0rXT9cXGQqWy5dP1xcZCtbJV0/KVxccypcXCkkL2k7XG5cbi8qKlxuICogUmV0dXJucyBhbiBSZ2JDb2xvciBvciBSZ2JhQ29sb3Igb2JqZWN0LiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgb25seSB1c2VmdWxcbiAqIGlmIHdhbnQgdG8gZXh0cmFjdCBhIGNvbG9yIGNvbXBvbmVudC4gV2l0aCB0aGUgY29sb3IgdXRpbCBgdG9Db2xvclN0cmluZ2AgeW91XG4gKiBjYW4gY29udmVydCBhIFJnYkNvbG9yIG9yIFJnYmFDb2xvciBvYmplY3QgYmFjayB0byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXNzaWducyBgeyByZWQ6IDI1NSwgZ3JlZW46IDAsIGJsdWU6IDAgfWAgdG8gY29sb3IxXG4gKiBjb25zdCBjb2xvcjEgPSBwYXJzZVRvUmdiKCdyZ2IoMjU1LCAwLCAwKScpO1xuICogLy8gQXNzaWducyBgeyByZWQ6IDkyLCBncmVlbjogMTAyLCBibHVlOiAxMTIsIGFscGhhOiAwLjc1IH1gIHRvIGNvbG9yMlxuICogY29uc3QgY29sb3IyID0gcGFyc2VUb1JnYignaHNsYSgyMTAsIDEwJSwgNDAlLCAwLjc1KScpO1xuICovXG5mdW5jdGlvbiBwYXJzZVRvUmdiKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoMyk7XG4gIH1cbiAgdmFyIG5vcm1hbGl6ZWRDb2xvciA9IG5hbWVUb0hleChjb2xvcik7XG4gIGlmIChub3JtYWxpemVkQ29sb3IubWF0Y2goaGV4UmVnZXgpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsxXSArIG5vcm1hbGl6ZWRDb2xvclsyXSwgMTYpLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbM10gKyBub3JtYWxpemVkQ29sb3JbNF0sIDE2KSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbNV0gKyBub3JtYWxpemVkQ29sb3JbNl0sIDE2KVxuICAgIH07XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZWRDb2xvci5tYXRjaChoZXhSZ2JhUmVnZXgpKSB7XG4gICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdCgocGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvcls3XSArIG5vcm1hbGl6ZWRDb2xvcls4XSwgMTYpIC8gMjU1KS50b0ZpeGVkKDIpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzFdICsgbm9ybWFsaXplZENvbG9yWzJdLCAxNiksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclszXSArIG5vcm1hbGl6ZWRDb2xvcls0XSwgMTYpLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvcls1XSArIG5vcm1hbGl6ZWRDb2xvcls2XSwgMTYpLFxuICAgICAgYWxwaGE6IGFscGhhXG4gICAgfTtcbiAgfVxuICBpZiAobm9ybWFsaXplZENvbG9yLm1hdGNoKHJlZHVjZWRIZXhSZWdleCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludChcIlwiICsgbm9ybWFsaXplZENvbG9yWzFdICsgbm9ybWFsaXplZENvbG9yWzFdLCAxNiksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsyXSArIG5vcm1hbGl6ZWRDb2xvclsyXSwgMTYpLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclszXSArIG5vcm1hbGl6ZWRDb2xvclszXSwgMTYpXG4gICAgfTtcbiAgfVxuICBpZiAobm9ybWFsaXplZENvbG9yLm1hdGNoKHJlZHVjZWRSZ2JhSGV4UmVnZXgpKSB7XG4gICAgdmFyIF9hbHBoYSA9IHBhcnNlRmxvYXQoKHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbNF0gKyBub3JtYWxpemVkQ29sb3JbNF0sIDE2KSAvIDI1NSkudG9GaXhlZCgyKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIG5vcm1hbGl6ZWRDb2xvclsxXSArIG5vcm1hbGl6ZWRDb2xvclsxXSwgMTYpLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbMl0gKyBub3JtYWxpemVkQ29sb3JbMl0sIDE2KSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBub3JtYWxpemVkQ29sb3JbM10gKyBub3JtYWxpemVkQ29sb3JbM10sIDE2KSxcbiAgICAgIGFscGhhOiBfYWxwaGFcbiAgICB9O1xuICB9XG4gIHZhciByZ2JNYXRjaGVkID0gcmdiUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuICBpZiAocmdiTWF0Y2hlZCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyByZ2JNYXRjaGVkWzFdLCAxMCksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIHJnYk1hdGNoZWRbMl0sIDEwKSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyByZ2JNYXRjaGVkWzNdLCAxMClcbiAgICB9O1xuICB9XG4gIHZhciByZ2JhTWF0Y2hlZCA9IHJnYmFSZWdleC5leGVjKG5vcm1hbGl6ZWRDb2xvci5zdWJzdHJpbmcoMCwgNTApKTtcbiAgaWYgKHJnYmFNYXRjaGVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZDogcGFyc2VJbnQoXCJcIiArIHJnYmFNYXRjaGVkWzFdLCAxMCksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIHJnYmFNYXRjaGVkWzJdLCAxMCksXG4gICAgICBibHVlOiBwYXJzZUludChcIlwiICsgcmdiYU1hdGNoZWRbM10sIDEwKSxcbiAgICAgIGFscGhhOiBwYXJzZUZsb2F0KFwiXCIgKyByZ2JhTWF0Y2hlZFs0XSkgPiAxID8gcGFyc2VGbG9hdChcIlwiICsgcmdiYU1hdGNoZWRbNF0pIC8gMTAwIDogcGFyc2VGbG9hdChcIlwiICsgcmdiYU1hdGNoZWRbNF0pXG4gICAgfTtcbiAgfVxuICB2YXIgaHNsTWF0Y2hlZCA9IGhzbFJlZ2V4LmV4ZWMobm9ybWFsaXplZENvbG9yKTtcbiAgaWYgKGhzbE1hdGNoZWQpIHtcbiAgICB2YXIgaHVlID0gcGFyc2VJbnQoXCJcIiArIGhzbE1hdGNoZWRbMV0sIDEwKTtcbiAgICB2YXIgc2F0dXJhdGlvbiA9IHBhcnNlSW50KFwiXCIgKyBoc2xNYXRjaGVkWzJdLCAxMCkgLyAxMDA7XG4gICAgdmFyIGxpZ2h0bmVzcyA9IHBhcnNlSW50KFwiXCIgKyBoc2xNYXRjaGVkWzNdLCAxMCkgLyAxMDA7XG4gICAgdmFyIHJnYkNvbG9yU3RyaW5nID0gXCJyZ2IoXCIgKyBoc2xUb1JnYihodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykgKyBcIilcIjtcbiAgICB2YXIgaHNsUmdiTWF0Y2hlZCA9IHJnYlJlZ2V4LmV4ZWMocmdiQ29sb3JTdHJpbmcpO1xuICAgIGlmICghaHNsUmdiTWF0Y2hlZCkge1xuICAgICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNCwgbm9ybWFsaXplZENvbG9yLCByZ2JDb2xvclN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyBoc2xSZ2JNYXRjaGVkWzFdLCAxMCksXG4gICAgICBncmVlbjogcGFyc2VJbnQoXCJcIiArIGhzbFJnYk1hdGNoZWRbMl0sIDEwKSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KFwiXCIgKyBoc2xSZ2JNYXRjaGVkWzNdLCAxMClcbiAgICB9O1xuICB9XG4gIHZhciBoc2xhTWF0Y2hlZCA9IGhzbGFSZWdleC5leGVjKG5vcm1hbGl6ZWRDb2xvci5zdWJzdHJpbmcoMCwgNTApKTtcbiAgaWYgKGhzbGFNYXRjaGVkKSB7XG4gICAgdmFyIF9odWUgPSBwYXJzZUludChcIlwiICsgaHNsYU1hdGNoZWRbMV0sIDEwKTtcbiAgICB2YXIgX3NhdHVyYXRpb24gPSBwYXJzZUludChcIlwiICsgaHNsYU1hdGNoZWRbMl0sIDEwKSAvIDEwMDtcbiAgICB2YXIgX2xpZ2h0bmVzcyA9IHBhcnNlSW50KFwiXCIgKyBoc2xhTWF0Y2hlZFszXSwgMTApIC8gMTAwO1xuICAgIHZhciBfcmdiQ29sb3JTdHJpbmcgPSBcInJnYihcIiArIGhzbFRvUmdiKF9odWUsIF9zYXR1cmF0aW9uLCBfbGlnaHRuZXNzKSArIFwiKVwiO1xuICAgIHZhciBfaHNsUmdiTWF0Y2hlZCA9IHJnYlJlZ2V4LmV4ZWMoX3JnYkNvbG9yU3RyaW5nKTtcbiAgICBpZiAoIV9oc2xSZ2JNYXRjaGVkKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig0LCBub3JtYWxpemVkQ29sb3IsIF9yZ2JDb2xvclN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KFwiXCIgKyBfaHNsUmdiTWF0Y2hlZFsxXSwgMTApLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KFwiXCIgKyBfaHNsUmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoXCJcIiArIF9oc2xSZ2JNYXRjaGVkWzNdLCAxMCksXG4gICAgICBhbHBoYTogcGFyc2VGbG9hdChcIlwiICsgaHNsYU1hdGNoZWRbNF0pID4gMSA/IHBhcnNlRmxvYXQoXCJcIiArIGhzbGFNYXRjaGVkWzRdKSAvIDEwMCA6IHBhcnNlRmxvYXQoXCJcIiArIGhzbGFNYXRjaGVkWzRdKVxuICAgIH07XG4gIH1cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNSk7XG59XG5cbmZ1bmN0aW9uIHJnYlRvSHNsKGNvbG9yKSB7XG4gIC8vIG1ha2Ugc3VyZSByZ2IgYXJlIGNvbnRhaW5lZCBpbiBhIHNldCBvZiBbMCwgMjU1XVxuICB2YXIgcmVkID0gY29sb3IucmVkIC8gMjU1O1xuICB2YXIgZ3JlZW4gPSBjb2xvci5ncmVlbiAvIDI1NTtcbiAgdmFyIGJsdWUgPSBjb2xvci5ibHVlIC8gMjU1O1xuICB2YXIgbWF4ID0gTWF0aC5tYXgocmVkLCBncmVlbiwgYmx1ZSk7XG4gIHZhciBtaW4gPSBNYXRoLm1pbihyZWQsIGdyZWVuLCBibHVlKTtcbiAgdmFyIGxpZ2h0bmVzcyA9IChtYXggKyBtaW4pIC8gMjtcbiAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgLy8gYWNocm9tYXRpY1xuICAgIGlmIChjb2xvci5hbHBoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBodWU6IDAsXG4gICAgICAgIHNhdHVyYXRpb246IDAsXG4gICAgICAgIGxpZ2h0bmVzczogbGlnaHRuZXNzLFxuICAgICAgICBhbHBoYTogY29sb3IuYWxwaGFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGh1ZTogMCxcbiAgICAgICAgc2F0dXJhdGlvbjogMCxcbiAgICAgICAgbGlnaHRuZXNzOiBsaWdodG5lc3NcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHZhciBodWU7XG4gIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcbiAgdmFyIHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPiAwLjUgPyBkZWx0YSAvICgyIC0gbWF4IC0gbWluKSA6IGRlbHRhIC8gKG1heCArIG1pbik7XG4gIHN3aXRjaCAobWF4KSB7XG4gICAgY2FzZSByZWQ6XG4gICAgICBodWUgPSAoZ3JlZW4gLSBibHVlKSAvIGRlbHRhICsgKGdyZWVuIDwgYmx1ZSA/IDYgOiAwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZ3JlZW46XG4gICAgICBodWUgPSAoYmx1ZSAtIHJlZCkgLyBkZWx0YSArIDI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gYmx1ZSBjYXNlXG4gICAgICBodWUgPSAocmVkIC0gZ3JlZW4pIC8gZGVsdGEgKyA0O1xuICAgICAgYnJlYWs7XG4gIH1cbiAgaHVlICo9IDYwO1xuICBpZiAoY29sb3IuYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICBodWU6IGh1ZSxcbiAgICAgIHNhdHVyYXRpb246IHNhdHVyYXRpb24sXG4gICAgICBsaWdodG5lc3M6IGxpZ2h0bmVzcyxcbiAgICAgIGFscGhhOiBjb2xvci5hbHBoYVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBodWU6IGh1ZSxcbiAgICBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uLFxuICAgIGxpZ2h0bmVzczogbGlnaHRuZXNzXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0LiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgb25seSB1c2VmdWxcbiAqIGlmIHdhbnQgdG8gZXh0cmFjdCBhIGNvbG9yIGNvbXBvbmVudC4gV2l0aCB0aGUgY29sb3IgdXRpbCBgdG9Db2xvclN0cmluZ2AgeW91XG4gKiBjYW4gY29udmVydCBhIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QgYmFjayB0byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXNzaWducyBgeyBodWU6IDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH1gIHRvIGNvbG9yMVxuICogY29uc3QgY29sb3IxID0gcGFyc2VUb0hzbCgncmdiKDI1NSwgMCwgMCknKTtcbiAqIC8vIEFzc2lnbnMgYHsgaHVlOiAxMjgsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41LCBhbHBoYTogMC43NSB9YCB0byBjb2xvcjJcbiAqIGNvbnN0IGNvbG9yMiA9IHBhcnNlVG9Ic2woJ2hzbGEoMTI4LCAxMDAlLCA1MCUsIDAuNzUpJyk7XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVG9Ic2woY29sb3IpIHtcbiAgLy8gTm90ZTogQXQgYSBsYXRlciBzdGFnZSB3ZSBjYW4gb3B0aW1pemUgdGhpcyBmdW5jdGlvbiBhcyByaWdodCBub3cgYSBoc2xcbiAgLy8gY29sb3Igd291bGQgYmUgcGFyc2VkIGNvbnZlcnRlZCB0byByZ2IgdmFsdWVzIGFuZCBjb252ZXJ0ZWQgYmFjayB0byBoc2wuXG4gIHJldHVybiByZ2JUb0hzbChwYXJzZVRvUmdiKGNvbG9yKSk7XG59XG5cbi8qKlxuICogUmVkdWNlcyBoZXggdmFsdWVzIGlmIHBvc3NpYmxlIGUuZy4gI2ZmODg2NiB0byAjZjg2XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcmVkdWNlSGV4VmFsdWUgPSBmdW5jdGlvbiByZWR1Y2VIZXhWYWx1ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSA3ICYmIHZhbHVlWzFdID09PSB2YWx1ZVsyXSAmJiB2YWx1ZVszXSA9PT0gdmFsdWVbNF0gJiYgdmFsdWVbNV0gPT09IHZhbHVlWzZdKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgdmFsdWVbMV0gKyB2YWx1ZVszXSArIHZhbHVlWzVdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG52YXIgcmVkdWNlSGV4VmFsdWUkMSA9IHJlZHVjZUhleFZhbHVlO1xuXG5mdW5jdGlvbiBudW1iZXJUb0hleCh2YWx1ZSkge1xuICB2YXIgaGV4ID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgaGV4IDogaGV4O1xufVxuXG5mdW5jdGlvbiBjb2xvclRvSGV4KGNvbG9yKSB7XG4gIHJldHVybiBudW1iZXJUb0hleChNYXRoLnJvdW5kKGNvbG9yICogMjU1KSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9IZXgocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZXR1cm4gcmVkdWNlSGV4VmFsdWUkMShcIiNcIiArIGNvbG9yVG9IZXgocmVkKSArIGNvbG9yVG9IZXgoZ3JlZW4pICsgY29sb3JUb0hleChibHVlKSk7XG59XG5mdW5jdGlvbiBoc2xUb0hleChodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykge1xuICByZXR1cm4gaHNsVG9SZ2IoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGNvbnZlcnRUb0hleCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGNvbG9yLiBUaGUgcmV0dXJuZWQgcmVzdWx0IGlzIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBoZXggbm90YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogaHNsKDM1OSwgMC43NSwgMC40KSxcbiAqICAgYmFja2dyb3VuZDogaHNsKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40IH0pLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2hzbCgzNTksIDAuNzUsIDAuNCl9O1xuICogICBiYWNrZ3JvdW5kOiAke2hzbCh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNiMzE5MWNcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjYjMxOTFjXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGhzbCh2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBzYXR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGlnaHRuZXNzID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBoc2xUb0hleCh2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHNhdHVyYXRpb24gPT09IHVuZGVmaW5lZCAmJiBsaWdodG5lc3MgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoc2xUb0hleCh2YWx1ZS5odWUsIHZhbHVlLnNhdHVyYXRpb24sIHZhbHVlLmxpZ2h0bmVzcyk7XG4gIH1cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoMSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGNvbG9yLiBUaGUgcmV0dXJuZWQgcmVzdWx0IGlzIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSByZ2JhIG9yIGhleCBub3RhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBoc2xhKDM1OSwgMC43NSwgMC40LCAwLjcpLFxuICogICBiYWNrZ3JvdW5kOiBoc2xhKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMCw3IH0pLFxuICogICBiYWNrZ3JvdW5kOiBoc2xhKDM1OSwgMC43NSwgMC40LCAxKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtoc2xhKDM1OSwgMC43NSwgMC40LCAwLjcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtoc2xhKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMCw3IH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHtoc2xhKDM1OSwgMC43NSwgMC40LCAxKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTc5LDI1LDI4LDAuNylcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE3OSwyNSwyOCwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2IzMTkxY1wiO1xuICogfVxuICovXG5mdW5jdGlvbiBoc2xhKHZhbHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBzYXR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGlnaHRuZXNzID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYWxwaGEgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGFscGhhID49IDEgPyBoc2xUb0hleCh2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKSA6IFwicmdiYShcIiArIGhzbFRvUmdiKHZhbHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpICsgXCIsXCIgKyBhbHBoYSArIFwiKVwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgc2F0dXJhdGlvbiA9PT0gdW5kZWZpbmVkICYmIGxpZ2h0bmVzcyA9PT0gdW5kZWZpbmVkICYmIGFscGhhID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdmFsdWUuYWxwaGEgPj0gMSA/IGhzbFRvSGV4KHZhbHVlLmh1ZSwgdmFsdWUuc2F0dXJhdGlvbiwgdmFsdWUubGlnaHRuZXNzKSA6IFwicmdiYShcIiArIGhzbFRvUmdiKHZhbHVlLmh1ZSwgdmFsdWUuc2F0dXJhdGlvbiwgdmFsdWUubGlnaHRuZXNzKSArIFwiLFwiICsgdmFsdWUuYWxwaGEgKyBcIilcIjtcbiAgfVxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcigyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgY29sb3IuIFRoZSByZXR1cm5lZCByZXN1bHQgaXMgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIGhleCBub3RhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiByZ2IoMjU1LCAyMDUsIDEwMCksXG4gKiAgIGJhY2tncm91bmQ6IHJnYih7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiKDI1NSwgMjA1LCAxMDApfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2IoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmNkNjRcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmdiKHZhbHVlLCBncmVlbiwgYmx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBibHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiByZWR1Y2VIZXhWYWx1ZSQxKFwiI1wiICsgbnVtYmVyVG9IZXgodmFsdWUpICsgbnVtYmVyVG9IZXgoZ3JlZW4pICsgbnVtYmVyVG9IZXgoYmx1ZSkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgZ3JlZW4gPT09IHVuZGVmaW5lZCAmJiBibHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVkdWNlSGV4VmFsdWUkMShcIiNcIiArIG51bWJlclRvSGV4KHZhbHVlLnJlZCkgKyBudW1iZXJUb0hleCh2YWx1ZS5ncmVlbikgKyBudW1iZXJUb0hleCh2YWx1ZS5ibHVlKSk7XG4gIH1cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNik7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGNvbG9yLiBUaGUgcmV0dXJuZWQgcmVzdWx0IGlzIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSByZ2JhIG9yIGhleCBub3RhdGlvbi5cbiAqXG4gKiBDYW4gYWxzbyBiZSB1c2VkIHRvIGZhZGUgYSBjb2xvciBieSBwYXNzaW5nIGEgaGV4IHZhbHVlIG9yIG5hbWVkIENTUyBjb2xvciBhbG9uZyB3aXRoIGFuIGFscGhhIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyMDUsIDEwMCwgMC43KSxcbiAqICAgYmFja2dyb3VuZDogcmdiYSh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcgfSksXG4gKiAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyMDUsIDEwMCwgMSksXG4gKiAgIGJhY2tncm91bmQ6IHJnYmEoJyNmZmZmZmYnLCAwLjQpLFxuICogICBiYWNrZ3JvdW5kOiByZ2JhKCdibGFjaycsIDAuNyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiYSgyNTUsIDIwNSwgMTAwLCAwLjcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNyB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiYSgyNTUsIDIwNSwgMTAwLCAxKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiYSgnI2ZmZmZmZicsIDAuNCl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYmEoJ2JsYWNrJywgMC43KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDIwNSwxMDAsMC43KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDIwNSwxMDAsMC43KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmNkNjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuNClcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDAsMCwwLDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmdiYShmaXJzdFZhbHVlLCBzZWNvbmRWYWx1ZSwgdGhpcmRWYWx1ZSwgZm91cnRoVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc2Vjb25kVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHJnYlZhbHVlID0gcGFyc2VUb1JnYihmaXJzdFZhbHVlKTtcbiAgICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiVmFsdWUucmVkICsgXCIsXCIgKyByZ2JWYWx1ZS5ncmVlbiArIFwiLFwiICsgcmdiVmFsdWUuYmx1ZSArIFwiLFwiICsgc2Vjb25kVmFsdWUgKyBcIilcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RWYWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNlY29uZFZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdGhpcmRWYWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGZvdXJ0aFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmb3VydGhWYWx1ZSA+PSAxID8gcmdiKGZpcnN0VmFsdWUsIHNlY29uZFZhbHVlLCB0aGlyZFZhbHVlKSA6IFwicmdiYShcIiArIGZpcnN0VmFsdWUgKyBcIixcIiArIHNlY29uZFZhbHVlICsgXCIsXCIgKyB0aGlyZFZhbHVlICsgXCIsXCIgKyBmb3VydGhWYWx1ZSArIFwiKVwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAnb2JqZWN0JyAmJiBzZWNvbmRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIHRoaXJkVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBmb3VydGhWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZpcnN0VmFsdWUuYWxwaGEgPj0gMSA/IHJnYihmaXJzdFZhbHVlLnJlZCwgZmlyc3RWYWx1ZS5ncmVlbiwgZmlyc3RWYWx1ZS5ibHVlKSA6IFwicmdiYShcIiArIGZpcnN0VmFsdWUucmVkICsgXCIsXCIgKyBmaXJzdFZhbHVlLmdyZWVuICsgXCIsXCIgKyBmaXJzdFZhbHVlLmJsdWUgKyBcIixcIiArIGZpcnN0VmFsdWUuYWxwaGEgKyBcIilcIjtcbiAgfVxuICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig3KTtcbn1cblxudmFyIGlzUmdiID0gZnVuY3Rpb24gaXNSZ2IoY29sb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvci5yZWQgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ncmVlbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmJsdWUgPT09ICdudW1iZXInICYmICh0eXBlb2YgY29sb3IuYWxwaGEgIT09ICdudW1iZXInIHx8IHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ3VuZGVmaW5lZCcpO1xufTtcbnZhciBpc1JnYmEgPSBmdW5jdGlvbiBpc1JnYmEoY29sb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvci5yZWQgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ncmVlbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmJsdWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5hbHBoYSA9PT0gJ251bWJlcic7XG59O1xudmFyIGlzSHNsID0gZnVuY3Rpb24gaXNIc2woY29sb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvci5odWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5zYXR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IubGlnaHRuZXNzID09PSAnbnVtYmVyJyAmJiAodHlwZW9mIGNvbG9yLmFscGhhICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICd1bmRlZmluZWQnKTtcbn07XG52YXIgaXNIc2xhID0gZnVuY3Rpb24gaXNIc2xhKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IuaHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3Iuc2F0dXJhdGlvbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmxpZ2h0bmVzcyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmFscGhhID09PSAnbnVtYmVyJztcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBSZ2JDb2xvciwgUmdiYUNvbG9yLCBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0IHRvIGEgY29sb3Igc3RyaW5nLlxuICogVGhpcyB1dGlsIGlzIHVzZWZ1bCBpbiBjYXNlIHlvdSBvbmx5IGtub3cgb24gcnVudGltZSB3aGljaCBjb2xvciBvYmplY3QgaXNcbiAqIHVzZWQuIE90aGVyd2lzZSB3ZSByZWNvbW1lbmQgdG8gcmVseSBvbiBgcmdiYCwgYHJnYmFgLCBgaHNsYCBvciBgaHNsYWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogdG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSksXG4gKiAgIGJhY2tncm91bmQ6IHRvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43MiB9KSxcbiAqICAgYmFja2dyb3VuZDogdG9Db2xvclN0cmluZyh7IGh1ZTogMjQwLCBzYXR1cmF0aW9uOiAxLCBsaWdodG5lc3M6IDAuNSB9KSxcbiAqICAgYmFja2dyb3VuZDogdG9Db2xvclN0cmluZyh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAuNzIgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7dG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke3RvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43MiB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7dG9Db2xvclN0cmluZyh7IGh1ZTogMjQwLCBzYXR1cmF0aW9uOiAxLCBsaWdodG5lc3M6IDAuNSB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7dG9Db2xvclN0cmluZyh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAuNzIgfSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmNkNjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyMDUsMTAwLDAuNzIpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzAwZlwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTc5LDI1LDI1LDAuNzIpXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gdG9Db2xvclN0cmluZyhjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoOCk7XG4gIGlmIChpc1JnYmEoY29sb3IpKSByZXR1cm4gcmdiYShjb2xvcik7XG4gIGlmIChpc1JnYihjb2xvcikpIHJldHVybiByZ2IoY29sb3IpO1xuICBpZiAoaXNIc2xhKGNvbG9yKSkgcmV0dXJuIGhzbGEoY29sb3IpO1xuICBpZiAoaXNIc2woY29sb3IpKSByZXR1cm4gaHNsKGNvbG9yKTtcbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoOCk7XG59XG5cbi8vIFR5cGUgZGVmaW5pdGlvbnMgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ2NhbnRpL2Zsb3ctc3RhdGljLWxhbmQvYmxvYi9tYXN0ZXIvc3JjL0Z1bi5qc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGN1cnJpZWQoZiwgbGVuZ3RoLCBhY2MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZuKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICB2YXIgY29tYmluZWQgPSBhY2MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiBjb21iaW5lZC5sZW5ndGggPj0gbGVuZ3RoID8gZi5hcHBseSh0aGlzLCBjb21iaW5lZCkgOiBjdXJyaWVkKGYsIGxlbmd0aCwgY29tYmluZWQpO1xuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5mdW5jdGlvbiBjdXJyeShmKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVkZWNsYXJlXG4gIHJldHVybiBjdXJyaWVkKGYsIGYubGVuZ3RoLCBbXSk7XG59XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgaHVlIG9mIHRoZSBjb2xvci4gSHVlIGlzIGEgbnVtYmVyIGJldHdlZW4gMCB0byAzNjAuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgZm9yIGFkanVzdEh1ZSBpcyB0aGUgYW1vdW50IG9mIGRlZ3JlZXMgdGhlIGNvbG9yIGlzIHJvdGF0ZWQgYXJvdW5kXG4gKiB0aGUgY29sb3Igd2hlZWwsIGFsd2F5cyBwcm9kdWNpbmcgYSBwb3NpdGl2ZSBodWUgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogYWRqdXN0SHVlKDE4MCwgJyM0NDgnKSxcbiAqICAgYmFja2dyb3VuZDogYWRqdXN0SHVlKCcxODAnLCAncmdiYSgxMDEsMTAwLDIwNSwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7YWRqdXN0SHVlKDE4MCwgJyM0NDgnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7YWRqdXN0SHVlKCcxODAnLCAncmdiYSgxMDEsMTAwLDIwNSwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiM4ODg4NDRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDEzNiwxMzYsNjgsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBhZGp1c3RIdWUoZGVncmVlLCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIGh1ZTogaHNsQ29sb3IuaHVlICsgcGFyc2VGbG9hdChkZWdyZWUpXG4gIH0pKTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY3VycmllZEFkanVzdEh1ZSA9IGN1cnJ5IC8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovKGFkanVzdEh1ZSk7XG52YXIgY3VycmllZEFkanVzdEh1ZSQxID0gY3VycmllZEFkanVzdEh1ZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb21wbGVtZW50IG9mIHRoZSBwcm92aWRlZCBjb2xvci4gVGhpcyBpcyBpZGVudGljYWwgdG8gYWRqdXN0SHVlKDE4MCwgPGNvbG9yPikuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogY29tcGxlbWVudCgnIzQ0OCcpLFxuICogICBiYWNrZ3JvdW5kOiBjb21wbGVtZW50KCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtjb21wbGVtZW50KCcjNDQ4Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2NvbXBsZW1lbnQoJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjODg0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNTMsMTUzLDE1MywwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNvbXBsZW1lbnQoY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHZhciBoc2xDb2xvciA9IHBhcnNlVG9Ic2woY29sb3IpO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgaHNsQ29sb3IsIHtcbiAgICBodWU6IChoc2xDb2xvci5odWUgKyAxODApICUgMzYwXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gZ3VhcmQobG93ZXJCb3VuZGFyeSwgdXBwZXJCb3VuZGFyeSwgdmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGxvd2VyQm91bmRhcnksIE1hdGgubWluKHVwcGVyQm91bmRhcnksIHZhbHVlKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyB2YWx1ZSBmb3IgdGhlIGRhcmtlbmVkIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGRhcmtlbigwLjIsICcjRkZDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IGRhcmtlbignMC4yJywgJ3JnYmEoMjU1LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2RhcmtlbigwLjIsICcjRkZDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2RhcmtlbignMC4yJywgJ3JnYmEoMjU1LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmYmQzMVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDE4OSw0OSwwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGRhcmtlbihhbW91bnQsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgbGlnaHRuZXNzOiBndWFyZCgwLCAxLCBoc2xDb2xvci5saWdodG5lc3MgLSBwYXJzZUZsb2F0KGFtb3VudCkpXG4gIH0pKTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY3VycmllZERhcmtlbiA9IGN1cnJ5IC8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovKGRhcmtlbik7XG52YXIgY3VycmllZERhcmtlbiQxID0gY3VycmllZERhcmtlbjtcblxuLyoqXG4gKiBEZWNyZWFzZXMgdGhlIGludGVuc2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgaXMgYmV0d2VlbiAwIHRvIDEuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgb2YgdGhlIGRlc2F0dXJhdGUgZnVuY3Rpb24gaXMgdGhlIGFtb3VudCBieSBob3cgbXVjaCB0aGUgY29sb3JcbiAqIGludGVuc2l0eSBzaG91bGQgYmUgZGVjcmVhc2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGRlc2F0dXJhdGUoMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBkZXNhdHVyYXRlKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7ZGVzYXR1cmF0ZSgwLjIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2Rlc2F0dXJhdGUoJzAuMicsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2I4Yjk3OVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTg0LDE4NSwxMjEsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBkZXNhdHVyYXRlKGFtb3VudCwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHZhciBoc2xDb2xvciA9IHBhcnNlVG9Ic2woY29sb3IpO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgaHNsQ29sb3IsIHtcbiAgICBzYXR1cmF0aW9uOiBndWFyZCgwLCAxLCBoc2xDb2xvci5zYXR1cmF0aW9uIC0gcGFyc2VGbG9hdChhbW91bnQpKVxuICB9KSk7XG59XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIGN1cnJpZWREZXNhdHVyYXRlID0gY3VycnkgLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi8oZGVzYXR1cmF0ZSk7XG52YXIgY3VycmllZERlc2F0dXJhdGUkMSA9IGN1cnJpZWREZXNhdHVyYXRlO1xuXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgKGZsb2F0KSByZXByZXNlbnRpbmcgdGhlIGx1bWluYW5jZSBvZiBhIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGdldEx1bWluYW5jZSgnI0NDQ0Q2NCcpID49IGdldEx1bWluYW5jZSgnIzAwMDBmZicpID8gJyNDQ0NENjQnIDogJyMwMDAwZmYnLFxuICogICBiYWNrZ3JvdW5kOiBnZXRMdW1pbmFuY2UoJ3JnYmEoNTgsIDEzMywgMjU1LCAxKScpID49IGdldEx1bWluYW5jZSgncmdiYSgyNTUsIDU3LCAxNDksIDEpJykgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZ2JhKDU4LCAxMzMsIDI1NSwgMSknIDpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYSgyNTUsIDU3LCAxNDksIDEpJyxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtnZXRMdW1pbmFuY2UoJyNDQ0NENjQnKSA+PSBnZXRMdW1pbmFuY2UoJyMwMDAwZmYnKSA/ICcjQ0NDRDY0JyA6ICcjMDAwMGZmJ307XG4gKiAgIGJhY2tncm91bmQ6ICR7Z2V0THVtaW5hbmNlKCdyZ2JhKDU4LCAxMzMsIDI1NSwgMSknKSA+PSBnZXRMdW1pbmFuY2UoJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKScpID9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYSg1OCwgMTMzLCAyNTUsIDEpJyA6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKSd9O1xuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICBiYWNrZ3JvdW5kOiBcIiNDQ0NENjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDU4LCAxMzMsIDI1NSwgMSlcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gZ2V0THVtaW5hbmNlKGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIDA7XG4gIHZhciByZ2JDb2xvciA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuICB2YXIgX09iamVjdCRrZXlzJG1hcCA9IE9iamVjdC5rZXlzKHJnYkNvbG9yKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGNoYW5uZWwgPSByZ2JDb2xvcltrZXldIC8gMjU1O1xuICAgICAgcmV0dXJuIGNoYW5uZWwgPD0gMC4wMzkyOCA/IGNoYW5uZWwgLyAxMi45MiA6IE1hdGgucG93KChjaGFubmVsICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG4gICAgfSksXG4gICAgciA9IF9PYmplY3Qka2V5cyRtYXBbMF0sXG4gICAgZyA9IF9PYmplY3Qka2V5cyRtYXBbMV0sXG4gICAgYiA9IF9PYmplY3Qka2V5cyRtYXBbMl07XG4gIHJldHVybiBwYXJzZUZsb2F0KCgwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGIpLnRvRml4ZWQoMykpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvbnRyYXN0IHJhdGlvIGJldHdlZW4gdHdvIGNvbG9ycyBiYXNlZCBvblxuICogW1czJ3MgcmVjb21tZW5kZWQgZXF1YXRpb24gZm9yIGNhbGN1bGF0aW5nIGNvbnRyYXN0XShodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI2NvbnRyYXN0LXJhdGlvZGVmKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgY29udHJhc3RSYXRpbyA9IGdldENvbnRyYXN0KCcjNDQ0JywgJyNmZmYnKTtcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udHJhc3QoY29sb3IxLCBjb2xvcjIpIHtcbiAgdmFyIGx1bWluYW5jZTEgPSBnZXRMdW1pbmFuY2UoY29sb3IxKTtcbiAgdmFyIGx1bWluYW5jZTIgPSBnZXRMdW1pbmFuY2UoY29sb3IyKTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoKGx1bWluYW5jZTEgPiBsdW1pbmFuY2UyID8gKGx1bWluYW5jZTEgKyAwLjA1KSAvIChsdW1pbmFuY2UyICsgMC4wNSkgOiAobHVtaW5hbmNlMiArIDAuMDUpIC8gKGx1bWluYW5jZTEgKyAwLjA1KSkudG9GaXhlZCgyKSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNvbG9yIHRvIGEgZ3JheXNjYWxlLCBieSByZWR1Y2luZyBpdHMgc2F0dXJhdGlvbiB0byAwLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGdyYXlzY2FsZSgnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBncmF5c2NhbGUoJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2dyYXlzY2FsZSgnI0NDQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtncmF5c2NhbGUoJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjOTk5XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNTMsMTUzLDE1MywwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGdyYXlzY2FsZShjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIHBhcnNlVG9Ic2woY29sb3IpLCB7XG4gICAgc2F0dXJhdGlvbjogMFxuICB9KSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0IHRvIGEgY29sb3Igc3RyaW5nLlxuICogVGhpcyB1dGlsIGlzIHVzZWZ1bCBpbiBjYXNlIHlvdSBvbmx5IGtub3cgb24gcnVudGltZSB3aGljaCBjb2xvciBvYmplY3QgaXNcbiAqIHVzZWQuIE90aGVyd2lzZSB3ZSByZWNvbW1lbmQgdG8gcmVseSBvbiBgaHNsYCBvciBgaHNsYWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogaHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMjQwLCBzYXR1cmF0aW9uOiAxLCBsaWdodG5lc3M6IDAuNSB9KSxcbiAqICAgYmFja2dyb3VuZDogaHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAuNzIgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMjQwLCBzYXR1cmF0aW9uOiAxLCBsaWdodG5lc3M6IDAuNSB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsVG9Db2xvclN0cmluZyh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAuNzIgfSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiMwMGZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE3OSwyNSwyNSwwLjcyKVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBoc2xUb0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb2xvci5odWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5zYXR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IubGlnaHRuZXNzID09PSAnbnVtYmVyJykge1xuICAgIGlmIChjb2xvci5hbHBoYSAmJiB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gaHNsYSh7XG4gICAgICAgIGh1ZTogY29sb3IuaHVlLFxuICAgICAgICBzYXR1cmF0aW9uOiBjb2xvci5zYXR1cmF0aW9uLFxuICAgICAgICBsaWdodG5lc3M6IGNvbG9yLmxpZ2h0bmVzcyxcbiAgICAgICAgYWxwaGE6IGNvbG9yLmFscGhhXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGhzbCh7XG4gICAgICBodWU6IGNvbG9yLmh1ZSxcbiAgICAgIHNhdHVyYXRpb246IGNvbG9yLnNhdHVyYXRpb24sXG4gICAgICBsaWdodG5lc3M6IGNvbG9yLmxpZ2h0bmVzc1xuICAgIH0pO1xuICB9XG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ1KTtcbn1cblxuLyoqXG4gKiBJbnZlcnRzIHRoZSByZWQsIGdyZWVuIGFuZCBibHVlIHZhbHVlcyBvZiBhIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGludmVydCgnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBpbnZlcnQoJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2ludmVydCgnI0NDQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtpbnZlcnQoJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzMzMzI5YlwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTU0LDE1NSw1MCwwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGludmVydChjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgLy8gcGFyc2UgY29sb3Igc3RyaW5nIHRvIHJnYlxuICB2YXIgdmFsdWUgPSBwYXJzZVRvUmdiKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIHZhbHVlLCB7XG4gICAgcmVkOiAyNTUgLSB2YWx1ZS5yZWQsXG4gICAgZ3JlZW46IDI1NSAtIHZhbHVlLmdyZWVuLFxuICAgIGJsdWU6IDI1NSAtIHZhbHVlLmJsdWVcbiAgfSkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBsaWdodGVuZWQgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogbGlnaHRlbigwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IGxpZ2h0ZW4oJzAuMicsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtsaWdodGVuKDAuMiwgJyNGRkNENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7bGlnaHRlbignMC4yJywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2U1ZTZiMVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjI5LDIzMCwxNzcsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBsaWdodGVuKGFtb3VudCwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHZhciBoc2xDb2xvciA9IHBhcnNlVG9Ic2woY29sb3IpO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgaHNsQ29sb3IsIHtcbiAgICBsaWdodG5lc3M6IGd1YXJkKDAsIDEsIGhzbENvbG9yLmxpZ2h0bmVzcyArIHBhcnNlRmxvYXQoYW1vdW50KSlcbiAgfSkpO1xufVxuXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBjdXJyaWVkTGlnaHRlbiA9IGN1cnJ5IC8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovKGxpZ2h0ZW4pO1xudmFyIGN1cnJpZWRMaWdodGVuJDEgPSBjdXJyaWVkTGlnaHRlbjtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoaWNoIGNvbnRyYXN0IGd1aWRlbGluZXMgaGF2ZSBiZWVuIG1ldCBmb3IgdHdvIGNvbG9ycy5cbiAqIEJhc2VkIG9uIHRoZSBbY29udHJhc3QgY2FsY3VsYXRpb25zIHJlY29tbWVuZGVkIGJ5IFczXShodHRwczovL3d3dy53My5vcmcvV0FJL1dDQUcyMS9VbmRlcnN0YW5kaW5nL2NvbnRyYXN0LWVuaGFuY2VkLmh0bWwpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzY29yZXMgPSBtZWV0c0NvbnRyYXN0R3VpZGVsaW5lcygnIzQ0NCcsICcjZmZmJyk7XG4gKi9cbmZ1bmN0aW9uIG1lZXRzQ29udHJhc3RHdWlkZWxpbmVzKGNvbG9yMSwgY29sb3IyKSB7XG4gIHZhciBjb250cmFzdFJhdGlvID0gZ2V0Q29udHJhc3QoY29sb3IxLCBjb2xvcjIpO1xuICByZXR1cm4ge1xuICAgIEFBOiBjb250cmFzdFJhdGlvID49IDQuNSxcbiAgICBBQUxhcmdlOiBjb250cmFzdFJhdGlvID49IDMsXG4gICAgQUFBOiBjb250cmFzdFJhdGlvID49IDcsXG4gICAgQUFBTGFyZ2U6IGNvbnRyYXN0UmF0aW8gPj0gNC41XG4gIH07XG59XG5cbi8qKlxuICogTWl4ZXMgdGhlIHR3byBwcm92aWRlZCBjb2xvcnMgdG9nZXRoZXIgYnkgY2FsY3VsYXRpbmcgdGhlIGF2ZXJhZ2Ugb2YgZWFjaCBvZiB0aGUgUkdCIGNvbXBvbmVudHMgd2VpZ2h0ZWQgdG8gdGhlIGZpcnN0IGNvbG9yIGJ5IHRoZSBwcm92aWRlZCB3ZWlnaHQuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogbWl4KDAuNSwgJyNmMDAnLCAnIzAwZicpXG4gKiAgIGJhY2tncm91bmQ6IG1peCgwLjI1LCAnI2YwMCcsICcjMDBmJylcbiAqICAgYmFja2dyb3VuZDogbWl4KCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuNSknLCAnIzAwZicpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7bWl4KDAuNSwgJyNmMDAnLCAnIzAwZicpfTtcbiAqICAgYmFja2dyb3VuZDogJHttaXgoMC4yNSwgJyNmMDAnLCAnIzAwZicpfTtcbiAqICAgYmFja2dyb3VuZDogJHttaXgoJzAuNScsICdyZ2JhKDI1NSwgMCwgMCwgMC41KScsICcjMDBmJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjN2YwMDdmXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzNmMDBiZlwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoNjMsIDAsIDE5MSwgMC43NSlcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gbWl4KHdlaWdodCwgY29sb3IsIG90aGVyQ29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gb3RoZXJDb2xvcjtcbiAgaWYgKG90aGVyQ29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgaWYgKHdlaWdodCA9PT0gMCkgcmV0dXJuIG90aGVyQ29sb3I7XG4gIHZhciBwYXJzZWRDb2xvcjEgPSBwYXJzZVRvUmdiKGNvbG9yKTtcbiAgdmFyIGNvbG9yMSA9IF9leHRlbmRzKHt9LCBwYXJzZWRDb2xvcjEsIHtcbiAgICBhbHBoYTogdHlwZW9mIHBhcnNlZENvbG9yMS5hbHBoYSA9PT0gJ251bWJlcicgPyBwYXJzZWRDb2xvcjEuYWxwaGEgOiAxXG4gIH0pO1xuICB2YXIgcGFyc2VkQ29sb3IyID0gcGFyc2VUb1JnYihvdGhlckNvbG9yKTtcbiAgdmFyIGNvbG9yMiA9IF9leHRlbmRzKHt9LCBwYXJzZWRDb2xvcjIsIHtcbiAgICBhbHBoYTogdHlwZW9mIHBhcnNlZENvbG9yMi5hbHBoYSA9PT0gJ251bWJlcicgPyBwYXJzZWRDb2xvcjIuYWxwaGEgOiAxXG4gIH0pO1xuXG4gIC8vIFRoZSBmb3JtdWxhIGlzIGNvcGllZCBmcm9tIHRoZSBvcmlnaW5hbCBTYXNzIGltcGxlbWVudGF0aW9uOlxuICAvLyBodHRwOi8vc2Fzcy1sYW5nLmNvbS9kb2N1bWVudGF0aW9uL1Nhc3MvU2NyaXB0L0Z1bmN0aW9ucy5odG1sI21peC1pbnN0YW5jZV9tZXRob2RcbiAgdmFyIGFscGhhRGVsdGEgPSBjb2xvcjEuYWxwaGEgLSBjb2xvcjIuYWxwaGE7XG4gIHZhciB4ID0gcGFyc2VGbG9hdCh3ZWlnaHQpICogMiAtIDE7XG4gIHZhciB5ID0geCAqIGFscGhhRGVsdGEgPT09IC0xID8geCA6IHggKyBhbHBoYURlbHRhO1xuICB2YXIgeiA9IDEgKyB4ICogYWxwaGFEZWx0YTtcbiAgdmFyIHdlaWdodDEgPSAoeSAvIHogKyAxKSAvIDIuMDtcbiAgdmFyIHdlaWdodDIgPSAxIC0gd2VpZ2h0MTtcbiAgdmFyIG1peGVkQ29sb3IgPSB7XG4gICAgcmVkOiBNYXRoLmZsb29yKGNvbG9yMS5yZWQgKiB3ZWlnaHQxICsgY29sb3IyLnJlZCAqIHdlaWdodDIpLFxuICAgIGdyZWVuOiBNYXRoLmZsb29yKGNvbG9yMS5ncmVlbiAqIHdlaWdodDEgKyBjb2xvcjIuZ3JlZW4gKiB3ZWlnaHQyKSxcbiAgICBibHVlOiBNYXRoLmZsb29yKGNvbG9yMS5ibHVlICogd2VpZ2h0MSArIGNvbG9yMi5ibHVlICogd2VpZ2h0MiksXG4gICAgYWxwaGE6IGNvbG9yMS5hbHBoYSAqIHBhcnNlRmxvYXQod2VpZ2h0KSArIGNvbG9yMi5hbHBoYSAqICgxIC0gcGFyc2VGbG9hdCh3ZWlnaHQpKVxuICB9O1xuICByZXR1cm4gcmdiYShtaXhlZENvbG9yKTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY3VycmllZE1peCA9IGN1cnJ5IC8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi8obWl4KTtcbnZhciBtaXgkMSA9IGN1cnJpZWRNaXg7XG5cbi8qKlxuICogSW5jcmVhc2VzIHRoZSBvcGFjaXR5IG9mIGEgY29sb3IuIEl0cyByYW5nZSBmb3IgdGhlIGFtb3VudCBpcyBiZXR3ZWVuIDAgdG8gMS5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogb3BhY2lmeSgwLjEsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSknKTtcbiAqICAgYmFja2dyb3VuZDogb3BhY2lmeSgwLjIsICdoc2xhKDAsIDAlLCAxMDAlLCAwLjUpJyksXG4gKiAgIGJhY2tncm91bmQ6IG9wYWNpZnkoJzAuNScsICdyZ2JhKDI1NSwgMCwgMCwgMC4yKScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke29wYWNpZnkoMC4xLCAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpJyl9O1xuICogICBiYWNrZ3JvdW5kOiAke29wYWNpZnkoMC4yLCAnaHNsYSgwLCAwJSwgMTAwJSwgMC41KScpfSxcbiAqICAgYmFja2dyb3VuZDogJHtvcGFjaWZ5KCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuMiknKX0sXG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuNylcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwwLDAsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBvcGFjaWZ5KGFtb3VudCwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHZhciBwYXJzZWRDb2xvciA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuICB2YXIgYWxwaGEgPSB0eXBlb2YgcGFyc2VkQ29sb3IuYWxwaGEgPT09ICdudW1iZXInID8gcGFyc2VkQ29sb3IuYWxwaGEgOiAxO1xuICB2YXIgY29sb3JXaXRoQWxwaGEgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IsIHtcbiAgICBhbHBoYTogZ3VhcmQoMCwgMSwgKGFscGhhICogMTAwICsgcGFyc2VGbG9hdChhbW91bnQpICogMTAwKSAvIDEwMClcbiAgfSk7XG4gIHJldHVybiByZ2JhKGNvbG9yV2l0aEFscGhhKTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY3VycmllZE9wYWNpZnkgPSBjdXJyeSAvKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqLyhvcGFjaWZ5KTtcbnZhciBjdXJyaWVkT3BhY2lmeSQxID0gY3VycmllZE9wYWNpZnk7XG5cbnZhciBkZWZhdWx0UmV0dXJuSWZMaWdodENvbG9yID0gJyMwMDAnO1xudmFyIGRlZmF1bHRSZXR1cm5JZkRhcmtDb2xvciA9ICcjZmZmJztcblxuLyoqXG4gKiBSZXR1cm5zIGJsYWNrIG9yIHdoaXRlIChvciBvcHRpb25hbCBwYXNzZWQgY29sb3JzKSBmb3IgYmVzdFxuICogY29udHJhc3QgZGVwZW5kaW5nIG9uIHRoZSBsdW1pbm9zaXR5IG9mIHRoZSBnaXZlbiBjb2xvci5cbiAqIFdoZW4gcGFzc2luZyBjdXN0b20gcmV0dXJuIGNvbG9ycywgc3RyaWN0IG1vZGUgZW5zdXJlcyB0aGF0IHRoZVxuICogcmV0dXJuIGNvbG9yIGFsd2F5cyBtZWV0cyBvciBleGNlZWRzIFdDQUcgbGV2ZWwgQUEgb3IgZ3JlYXRlci4gSWYgdGhpcyB0ZXN0XG4gKiBmYWlscywgdGhlIGRlZmF1bHQgcmV0dXJuIGNvbG9yIChibGFjayBvciB3aGl0ZSkgaXMgcmV0dXJuZWQgaW4gcGxhY2Ugb2YgdGhlXG4gKiBjdXN0b20gcmV0dXJuIGNvbG9yLiBZb3UgY2FuIG9wdGlvbmFsbHkgdHVybiBvZmYgc3RyaWN0IG1vZGUuXG4gKlxuICogRm9sbG93cyBbVzNDIHNwZWNzIGZvciByZWFkYWJpbGl0eV0oaHR0cHM6Ly93d3cudzMub3JnL1RSL1dDQUcyMC1URUNIUy9HMTguaHRtbCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgY29sb3I6IHJlYWRhYmxlQ29sb3IoJyMwMDAnKSxcbiAqICAgY29sb3I6IHJlYWRhYmxlQ29sb3IoJ2JsYWNrJywgJyMwMDEnLCAnI2ZmOCcpLFxuICogICBjb2xvcjogcmVhZGFibGVDb2xvcignd2hpdGUnLCAnIzAwMScsICcjZmY4JyksXG4gKiAgIGNvbG9yOiByZWFkYWJsZUNvbG9yKCdyZWQnLCAnIzMzMycsICcjZGRkJywgdHJ1ZSlcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcignIzAwMCcpfTtcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcignYmxhY2snLCAnIzAwMScsICcjZmY4Jyl9O1xuICogICBjb2xvcjogJHtyZWFkYWJsZUNvbG9yKCd3aGl0ZScsICcjMDAxJywgJyNmZjgnKX07XG4gKiAgIGNvbG9yOiAke3JlYWRhYmxlQ29sb3IoJ3JlZCcsICcjMzMzJywgJyNkZGQnLCB0cnVlKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGNvbG9yOiBcIiNmZmZcIjtcbiAqICAgY29sb3I6IFwiI2ZmOFwiO1xuICogICBjb2xvcjogXCIjMDAxXCI7XG4gKiAgIGNvbG9yOiBcIiMwMDBcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmVhZGFibGVDb2xvcihjb2xvciwgcmV0dXJuSWZMaWdodENvbG9yLCByZXR1cm5JZkRhcmtDb2xvciwgc3RyaWN0KSB7XG4gIGlmIChyZXR1cm5JZkxpZ2h0Q29sb3IgPT09IHZvaWQgMCkge1xuICAgIHJldHVybklmTGlnaHRDb2xvciA9IGRlZmF1bHRSZXR1cm5JZkxpZ2h0Q29sb3I7XG4gIH1cbiAgaWYgKHJldHVybklmRGFya0NvbG9yID09PSB2b2lkIDApIHtcbiAgICByZXR1cm5JZkRhcmtDb2xvciA9IGRlZmF1bHRSZXR1cm5JZkRhcmtDb2xvcjtcbiAgfVxuICBpZiAoc3RyaWN0ID09PSB2b2lkIDApIHtcbiAgICBzdHJpY3QgPSB0cnVlO1xuICB9XG4gIHZhciBpc0NvbG9yTGlnaHQgPSBnZXRMdW1pbmFuY2UoY29sb3IpID4gMC4xNzk7XG4gIHZhciBwcmVmZXJyZWRSZXR1cm5Db2xvciA9IGlzQ29sb3JMaWdodCA/IHJldHVybklmTGlnaHRDb2xvciA6IHJldHVybklmRGFya0NvbG9yO1xuICBpZiAoIXN0cmljdCB8fCBnZXRDb250cmFzdChjb2xvciwgcHJlZmVycmVkUmV0dXJuQ29sb3IpID49IDQuNSkge1xuICAgIHJldHVybiBwcmVmZXJyZWRSZXR1cm5Db2xvcjtcbiAgfVxuICByZXR1cm4gaXNDb2xvckxpZ2h0ID8gZGVmYXVsdFJldHVybklmTGlnaHRDb2xvciA6IGRlZmF1bHRSZXR1cm5JZkRhcmtDb2xvcjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFJnYkNvbG9yIG9yIFJnYmFDb2xvciBvYmplY3QgdG8gYSBjb2xvciBzdHJpbmcuXG4gKiBUaGlzIHV0aWwgaXMgdXNlZnVsIGluIGNhc2UgeW91IG9ubHkga25vdyBvbiBydW50aW1lIHdoaWNoIGNvbG9yIG9iamVjdCBpc1xuICogdXNlZC4gT3RoZXJ3aXNlIHdlIHJlY29tbWVuZCB0byByZWx5IG9uIGByZ2JgIG9yIGByZ2JhYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiByZ2JUb0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KSxcbiAqICAgYmFja2dyb3VuZDogcmdiVG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcyIH0pLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3JnYlRvQ29sb3JTdHJpbmcoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JUb0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCwgYWxwaGE6IDAuNzIgfSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmNkNjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyMDUsMTAwLDAuNzIpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHJnYlRvQ29sb3JTdHJpbmcoY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNvbG9yLnJlZCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmdyZWVuID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuYmx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGNvbG9yLmFscGhhID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHJnYmEoe1xuICAgICAgICByZWQ6IGNvbG9yLnJlZCxcbiAgICAgICAgZ3JlZW46IGNvbG9yLmdyZWVuLFxuICAgICAgICBibHVlOiBjb2xvci5ibHVlLFxuICAgICAgICBhbHBoYTogY29sb3IuYWxwaGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmdiKHtcbiAgICAgIHJlZDogY29sb3IucmVkLFxuICAgICAgZ3JlZW46IGNvbG9yLmdyZWVuLFxuICAgICAgYmx1ZTogY29sb3IuYmx1ZVxuICAgIH0pO1xuICB9XG4gIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDQ2KTtcbn1cblxuLyoqXG4gKiBJbmNyZWFzZXMgdGhlIGludGVuc2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgaXMgYmV0d2VlbiAwIHRvIDEuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgb2YgdGhlIHNhdHVyYXRlIGZ1bmN0aW9uIGlzIHRoZSBhbW91bnQgYnkgaG93IG11Y2ggdGhlIGNvbG9yXG4gKiBpbnRlbnNpdHkgc2hvdWxkIGJlIGluY3JlYXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzYXR1cmF0ZSgwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNhdHVyYXRlKCcwLjInLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2F0dXJhdGUoMC4yLCAnI0ZGQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtzYXR1cmF0ZSgnMC4yJywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2UwZTI1MFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjI0LDIyNiw4MCwwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHNhdHVyYXRlKGFtb3VudCwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHZhciBoc2xDb2xvciA9IHBhcnNlVG9Ic2woY29sb3IpO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgaHNsQ29sb3IsIHtcbiAgICBzYXR1cmF0aW9uOiBndWFyZCgwLCAxLCBoc2xDb2xvci5zYXR1cmF0aW9uICsgcGFyc2VGbG9hdChhbW91bnQpKVxuICB9KSk7XG59XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIGN1cnJpZWRTYXR1cmF0ZSA9IGN1cnJ5IC8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovKHNhdHVyYXRlKTtcbnZhciBjdXJyaWVkU2F0dXJhdGUkMSA9IGN1cnJpZWRTYXR1cmF0ZTtcblxuLyoqXG4gKiBTZXRzIHRoZSBodWUgb2YgYSBjb2xvciB0byB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoZSBodWUgcmFuZ2UgY2FuIGJlXG4gKiBmcm9tIDAgYW5kIDM1OS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzZXRIdWUoNDIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNldEh1ZSgnMjQ0JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3NldEh1ZSg0MiwgJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7c2V0SHVlKCcyNDQnLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNjZGFlNjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDEwNywxMDAsMjA1LDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gc2V0SHVlKGh1ZSwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBwYXJzZVRvSHNsKGNvbG9yKSwge1xuICAgIGh1ZTogcGFyc2VGbG9hdChodWUpXG4gIH0pKTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY3VycmllZFNldEh1ZSA9IGN1cnJ5IC8qIDo6PG51bWJlciB8IHN0cmluZywgc3RyaW5nLCBzdHJpbmc+ICovKHNldEh1ZSk7XG52YXIgY3VycmllZFNldEh1ZSQxID0gY3VycmllZFNldEh1ZTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaWdodG5lc3Mgb2YgYSBjb2xvciB0byB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoZSBsaWdodG5lc3MgcmFuZ2UgY2FuIGJlXG4gKiBmcm9tIDAgYW5kIDEuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2V0TGlnaHRuZXNzKDAuMiwgJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogc2V0TGlnaHRuZXNzKCcwLjc1JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3NldExpZ2h0bmVzcygwLjIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldExpZ2h0bmVzcygnMC43NScsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzRkNGQxOVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjIzLDIyNCwxNTksMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBzZXRMaWdodG5lc3MobGlnaHRuZXNzLCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIHBhcnNlVG9Ic2woY29sb3IpLCB7XG4gICAgbGlnaHRuZXNzOiBwYXJzZUZsb2F0KGxpZ2h0bmVzcylcbiAgfSkpO1xufVxuXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBjdXJyaWVkU2V0TGlnaHRuZXNzID0gY3VycnkgLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi8oc2V0TGlnaHRuZXNzKTtcbnZhciBjdXJyaWVkU2V0TGlnaHRuZXNzJDEgPSBjdXJyaWVkU2V0TGlnaHRuZXNzO1xuXG4vKipcbiAqIFNldHMgdGhlIHNhdHVyYXRpb24gb2YgYSBjb2xvciB0byB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoZSBzYXR1cmF0aW9uIHJhbmdlIGNhbiBiZVxuICogZnJvbSAwIGFuZCAxLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHNldFNhdHVyYXRpb24oMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBzZXRTYXR1cmF0aW9uKCcwLjc1JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3NldFNhdHVyYXRpb24oMC4yLCAnI0NDQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtzZXRTYXR1cmF0aW9uKCcwLjc1JywgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjYWRhZDg0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyMjgsMjI5LDc2LDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gc2V0U2F0dXJhdGlvbihzYXR1cmF0aW9uLCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIHBhcnNlVG9Ic2woY29sb3IpLCB7XG4gICAgc2F0dXJhdGlvbjogcGFyc2VGbG9hdChzYXR1cmF0aW9uKVxuICB9KSk7XG59XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxudmFyIGN1cnJpZWRTZXRTYXR1cmF0aW9uID0gY3VycnkgLyogOjo8bnVtYmVyIHwgc3RyaW5nLCBzdHJpbmcsIHN0cmluZz4gKi8oc2V0U2F0dXJhdGlvbik7XG52YXIgY3VycmllZFNldFNhdHVyYXRpb24kMSA9IGN1cnJpZWRTZXRTYXR1cmF0aW9uO1xuXG4vKipcbiAqIFNoYWRlcyBhIGNvbG9yIGJ5IG1peGluZyBpdCB3aXRoIGJsYWNrLiBgc2hhZGVgIGNhbiBwcm9kdWNlXG4gKiBodWUgc2hpZnRzLCB3aGVyZSBhcyBgZGFya2VuYCBtYW5pcHVsYXRlcyB0aGUgbHVtaW5hbmNlIGNoYW5uZWwgYW5kIHRoZXJlZm9yZVxuICogZG9lc24ndCBwcm9kdWNlIGh1ZSBzaGlmdHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2hhZGUoMC4yNSwgJyMwMGYnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3NoYWRlKDAuMjUsICcjMDBmJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjMDAwMDNmXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc2hhZGUocGVyY2VudGFnZSwgY29sb3IpIHtcbiAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiBtaXgkMShwYXJzZUZsb2F0KHBlcmNlbnRhZ2UpLCAncmdiKDAsIDAsIDApJywgY29sb3IpO1xufVxuXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBjdXJyaWVkU2hhZGUgPSBjdXJyeSAvKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqLyhzaGFkZSk7XG52YXIgY3VycmllZFNoYWRlJDEgPSBjdXJyaWVkU2hhZGU7XG5cbi8qKlxuICogVGludHMgYSBjb2xvciBieSBtaXhpbmcgaXQgd2l0aCB3aGl0ZS4gYHRpbnRgIGNhbiBwcm9kdWNlXG4gKiBodWUgc2hpZnRzLCB3aGVyZSBhcyBgbGlnaHRlbmAgbWFuaXB1bGF0ZXMgdGhlIGx1bWluYW5jZSBjaGFubmVsIGFuZCB0aGVyZWZvcmVcbiAqIGRvZXNuJ3QgcHJvZHVjZSBodWUgc2hpZnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHRpbnQoMC4yNSwgJyMwMGYnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3RpbnQoMC4yNSwgJyMwMGYnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNiZmJmZmZcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0aW50KHBlcmNlbnRhZ2UsIGNvbG9yKSB7XG4gIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50JykgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gbWl4JDEocGFyc2VGbG9hdChwZXJjZW50YWdlKSwgJ3JnYigyNTUsIDI1NSwgMjU1KScsIGNvbG9yKTtcbn1cblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgY3VycmllZFRpbnQgPSBjdXJyeSAvKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqLyh0aW50KTtcbnZhciBjdXJyaWVkVGludCQxID0gY3VycmllZFRpbnQ7XG5cbi8qKlxuICogRGVjcmVhc2VzIHRoZSBvcGFjaXR5IG9mIGEgY29sb3IuIEl0cyByYW5nZSBmb3IgdGhlIGFtb3VudCBpcyBiZXR3ZWVuIDAgdG8gMS5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnRpemUoMC4xLCAnI2ZmZicpLFxuICogICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudGl6ZSgwLjIsICdoc2woMCwgMCUsIDEwMCUpJyksXG4gKiAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50aXplKCcwLjUnLCAncmdiYSgyNTUsIDAsIDAsIDAuOCknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHt0cmFuc3BhcmVudGl6ZSgwLjEsICcjZmZmJyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3RyYW5zcGFyZW50aXplKDAuMiwgJ2hzbCgwLCAwJSwgMTAwJSknKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7dHJhbnNwYXJlbnRpemUoJzAuNScsICdyZ2JhKDI1NSwgMCwgMCwgMC44KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjkpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjgpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMCwwLDAuMylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gdHJhbnNwYXJlbnRpemUoYW1vdW50LCBjb2xvcikge1xuICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHJldHVybiBjb2xvcjtcbiAgdmFyIHBhcnNlZENvbG9yID0gcGFyc2VUb1JnYihjb2xvcik7XG4gIHZhciBhbHBoYSA9IHR5cGVvZiBwYXJzZWRDb2xvci5hbHBoYSA9PT0gJ251bWJlcicgPyBwYXJzZWRDb2xvci5hbHBoYSA6IDE7XG4gIHZhciBjb2xvcldpdGhBbHBoYSA9IF9leHRlbmRzKHt9LCBwYXJzZWRDb2xvciwge1xuICAgIGFscGhhOiBndWFyZCgwLCAxLCArKGFscGhhICogMTAwIC0gcGFyc2VGbG9hdChhbW91bnQpICogMTAwKS50b0ZpeGVkKDIpIC8gMTAwKVxuICB9KTtcbiAgcmV0dXJuIHJnYmEoY29sb3JXaXRoQWxwaGEpO1xufVxuXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBjdXJyaWVkVHJhbnNwYXJlbnRpemUgPSBjdXJyeSAvKiA6OjxudW1iZXIgfCBzdHJpbmcsIHN0cmluZywgc3RyaW5nPiAqLyh0cmFuc3BhcmVudGl6ZSk7XG52YXIgY3VycmllZFRyYW5zcGFyZW50aXplJDEgPSBjdXJyaWVkVHJhbnNwYXJlbnRpemU7XG5cbi8qKlxuICogU2hvcnRoYW5kIGZvciBlYXNpbHkgc2V0dGluZyB0aGUgYW5pbWF0aW9uIHByb3BlcnR5LiBBbGxvd3MgZWl0aGVyIG11bHRpcGxlIGFycmF5cyB3aXRoIGFuaW1hdGlvbnNcbiAqIG9yIGEgc2luZ2xlIGFuaW1hdGlvbiBzcHJlYWQgb3ZlciB0aGUgYXJndW1lbnRzLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYW5pbWF0aW9uKFsncm90YXRlJywgJzFzJywgJ2Vhc2UtaW4tb3V0J10sIFsnY29sb3JjaGFuZ2UnLCAnMnMnXSlcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHthbmltYXRpb24oWydyb3RhdGUnLCAnMXMnLCAnZWFzZS1pbi1vdXQnXSwgWydjb2xvcmNoYW5nZScsICcycyddKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2FuaW1hdGlvbic6ICdyb3RhdGUgMXMgZWFzZS1pbi1vdXQsIGNvbG9yY2hhbmdlIDJzJ1xuICogfVxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYW5pbWF0aW9uKCdyb3RhdGUnLCAnMXMnLCAnZWFzZS1pbi1vdXQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2FuaW1hdGlvbigncm90YXRlJywgJzFzJywgJ2Vhc2UtaW4tb3V0Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdhbmltYXRpb24nOiAncm90YXRlIDFzIGVhc2UtaW4tb3V0J1xuICogfVxuICovXG5mdW5jdGlvbiBhbmltYXRpb24oKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgLy8gQWxsb3cgc2luZ2xlIG9yIG11bHRpcGxlIGFuaW1hdGlvbnMgcGFzc2VkXG4gIHZhciBtdWx0aU1vZGUgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pO1xuICBpZiAoIW11bHRpTW9kZSAmJiBhcmdzLmxlbmd0aCA+IDgpIHtcbiAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2NCk7XG4gIH1cbiAgdmFyIGNvZGUgPSBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKG11bHRpTW9kZSAmJiAhQXJyYXkuaXNBcnJheShhcmcpIHx8ICFtdWx0aU1vZGUgJiYgQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2NSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCA+IDgpIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY2KTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZy5qb2luKCcgJykgOiBhcmc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIHJldHVybiB7XG4gICAgYW5pbWF0aW9uOiBjb2RlXG4gIH07XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyBhbnkgbnVtYmVyIG9mIGJhY2tncm91bmRJbWFnZSB2YWx1ZXMgYXMgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBzaW5nbGUgYmFja2dyb3VuZCBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5iYWNrZ3JvdW5kSW1hZ2VzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtiYWNrZ3JvdW5kSW1hZ2VzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpLCBsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiknXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGJhY2tncm91bmRJbWFnZXMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wZXJ0aWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHByb3BlcnRpZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHByb3BlcnRpZXMuam9pbignLCAnKVxuICB9O1xufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgYW55IG51bWJlciBvZiBiYWNrZ3JvdW5kIHZhbHVlcyBhcyBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhIHNpbmdsZSBiYWNrZ3JvdW5kIHN0YXRlbWVudC5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJhY2tncm91bmRzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJywgJ2NlbnRlciBuby1yZXBlYXQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JhY2tncm91bmRzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJywgJ2NlbnRlciBuby1yZXBlYXQnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JhY2tncm91bmQnOiAndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpLCBsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiksIGNlbnRlciBuby1yZXBlYXQnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGJhY2tncm91bmRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcHJvcGVydGllcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwcm9wZXJ0aWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZDogcHJvcGVydGllcy5qb2luKCcsICcpXG4gIH07XG59XG5cbnZhciBzaWRlTWFwID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcblxuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIHRoZSBib3JkZXIgcHJvcGVydHkgdGhhdCBzcGxpdHMgb3V0IGluZGl2aWR1YWwgcHJvcGVydGllcyBmb3IgdXNlIHdpdGggdG9vbHMgbGlrZSBGZWxhIGFuZCBTdHlsZXRyb24uIEEgc2lkZSBrZXl3b3JkIGNhbiBvcHRpb25hbGx5IGJlIHBhc3NlZCB0byB0YXJnZXQgb25seSBvbmUgc2lkZSdzIGJvcmRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJvcmRlcignMXB4JywgJ3NvbGlkJywgJ3JlZCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyKCcxcHgnLCAnc29saWQnLCAncmVkJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdib3JkZXJDb2xvcic6ICdyZWQnLFxuICogICAnYm9yZGVyU3R5bGUnOiAnc29saWQnLFxuICogICAnYm9yZGVyV2lkdGgnOiBgMXB4YCxcbiAqIH1cbiAqXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJvcmRlcigndG9wJywgJzFweCcsICdzb2xpZCcsICdyZWQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JvcmRlcigndG9wJywgJzFweCcsICdzb2xpZCcsICdyZWQnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JvcmRlclRvcENvbG9yJzogJ3JlZCcsXG4gKiAgICdib3JkZXJUb3BTdHlsZSc6ICdzb2xpZCcsXG4gKiAgICdib3JkZXJUb3BXaWR0aCc6IGAxcHhgLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIGJvcmRlcihzaWRlS2V5d29yZCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIGlmICh0eXBlb2Ygc2lkZUtleXdvcmQgPT09ICdzdHJpbmcnICYmIHNpZGVNYXAuaW5kZXhPZihzaWRlS2V5d29yZCkgPj0gMCkge1xuICAgIHZhciBfcmVmO1xuICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbXCJib3JkZXJcIiArIGNhcGl0YWxpemVTdHJpbmcoc2lkZUtleXdvcmQpICsgXCJXaWR0aFwiXSA9IHZhbHVlc1swXSwgX3JlZltcImJvcmRlclwiICsgY2FwaXRhbGl6ZVN0cmluZyhzaWRlS2V5d29yZCkgKyBcIlN0eWxlXCJdID0gdmFsdWVzWzFdLCBfcmVmW1wiYm9yZGVyXCIgKyBjYXBpdGFsaXplU3RyaW5nKHNpZGVLZXl3b3JkKSArIFwiQ29sb3JcIl0gPSB2YWx1ZXNbMl0sIF9yZWY7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVzLnVuc2hpZnQoc2lkZUtleXdvcmQpO1xuICAgIHJldHVybiB7XG4gICAgICBib3JkZXJXaWR0aDogdmFsdWVzWzBdLFxuICAgICAgYm9yZGVyU3R5bGU6IHZhbHVlc1sxXSxcbiAgICAgIGJvcmRlckNvbG9yOiB2YWx1ZXNbMl1cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJvcmRlckNvbG9yKCdyZWQnLCAnZ3JlZW4nLCAnYmx1ZScsICd5ZWxsb3cnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JvcmRlckNvbG9yKCdyZWQnLCAnZ3JlZW4nLCAnYmx1ZScsICd5ZWxsb3cnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JvcmRlclRvcENvbG9yJzogJ3JlZCcsXG4gKiAgICdib3JkZXJSaWdodENvbG9yJzogJ2dyZWVuJyxcbiAqICAgJ2JvcmRlckJvdHRvbUNvbG9yJzogJ2JsdWUnLFxuICogICAnYm9yZGVyTGVmdENvbG9yJzogJ3llbGxvdydcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYm9yZGVyQ29sb3IoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBkaXJlY3Rpb25hbFByb3BlcnR5LmFwcGx5KHZvaWQgMCwgWydib3JkZXJDb2xvciddLmNvbmNhdCh2YWx1ZXMpKTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIGEgdmFsdWUgZm9yIHNpZGUgYW5kIGEgdmFsdWUgZm9yIHJhZGl1cyBhbmQgYXBwbGllcyB0aGUgcmFkaXVzIHZhbHVlIHRvIGJvdGggY29ybmVycyBvZiB0aGUgc2lkZS5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJvcmRlclJhZGl1cygndG9wJywgJzVweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyUmFkaXVzKCd0b3AnLCAnNXB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdib3JkZXJUb3BSaWdodFJhZGl1cyc6ICc1cHgnLFxuICogICAnYm9yZGVyVG9wTGVmdFJhZGl1cyc6ICc1cHgnLFxuICogfVxuICovXG5mdW5jdGlvbiBib3JkZXJSYWRpdXMoc2lkZSwgcmFkaXVzKSB7XG4gIHZhciB1cHBlcmNhc2VTaWRlID0gY2FwaXRhbGl6ZVN0cmluZyhzaWRlKTtcbiAgaWYgKCFyYWRpdXMgJiYgcmFkaXVzICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjIpO1xuICB9XG4gIGlmICh1cHBlcmNhc2VTaWRlID09PSAnVG9wJyB8fCB1cHBlcmNhc2VTaWRlID09PSAnQm90dG9tJykge1xuICAgIHZhciBfcmVmO1xuICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbXCJib3JkZXJcIiArIHVwcGVyY2FzZVNpZGUgKyBcIlJpZ2h0UmFkaXVzXCJdID0gcmFkaXVzLCBfcmVmW1wiYm9yZGVyXCIgKyB1cHBlcmNhc2VTaWRlICsgXCJMZWZ0UmFkaXVzXCJdID0gcmFkaXVzLCBfcmVmO1xuICB9XG4gIGlmICh1cHBlcmNhc2VTaWRlID09PSAnTGVmdCcgfHwgdXBwZXJjYXNlU2lkZSA9PT0gJ1JpZ2h0Jykge1xuICAgIHZhciBfcmVmMjtcbiAgICByZXR1cm4gX3JlZjIgPSB7fSwgX3JlZjJbXCJib3JkZXJUb3BcIiArIHVwcGVyY2FzZVNpZGUgKyBcIlJhZGl1c1wiXSA9IHJhZGl1cywgX3JlZjJbXCJib3JkZXJCb3R0b21cIiArIHVwcGVyY2FzZVNpZGUgKyBcIlJhZGl1c1wiXSA9IHJhZGl1cywgX3JlZjI7XG4gIH1cbiAgdGhyb3cgbmV3IFBvbGlzaGVkRXJyb3IoNjMpO1xufVxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXJTdHlsZSgnc29saWQnLCAnZGFzaGVkJywgJ2RvdHRlZCcsICdkb3VibGUnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JvcmRlclN0eWxlKCdzb2xpZCcsICdkYXNoZWQnLCAnZG90dGVkJywgJ2RvdWJsZScpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wU3R5bGUnOiAnc29saWQnLFxuICogICAnYm9yZGVyUmlnaHRTdHlsZSc6ICdkYXNoZWQnLFxuICogICAnYm9yZGVyQm90dG9tU3R5bGUnOiAnZG90dGVkJyxcbiAqICAgJ2JvcmRlckxlZnRTdHlsZSc6ICdkb3VibGUnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGJvcmRlclN0eWxlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHZhbHVlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnYm9yZGVyU3R5bGUnXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJvcmRlcldpZHRoKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtib3JkZXJXaWR0aCgnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wV2lkdGgnOiAnMTJweCcsXG4gKiAgICdib3JkZXJSaWdodFdpZHRoJzogJzI0cHgnLFxuICogICAnYm9yZGVyQm90dG9tV2lkdGgnOiAnMzZweCcsXG4gKiAgICdib3JkZXJMZWZ0V2lkdGgnOiAnNDhweCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYm9yZGVyV2lkdGgoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBkaXJlY3Rpb25hbFByb3BlcnR5LmFwcGx5KHZvaWQgMCwgWydib3JkZXJXaWR0aCddLmNvbmNhdCh2YWx1ZXMpKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTZWxlY3RvcnModGVtcGxhdGUsIHN0YXRlKSB7XG4gIHZhciBzdGF0ZVN1ZmZpeCA9IHN0YXRlID8gXCI6XCIgKyBzdGF0ZSA6ICcnO1xuICByZXR1cm4gdGVtcGxhdGUoc3RhdGVTdWZmaXgpO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGhlbHBlciB0aGF0IGFkZHMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRvIGEgdGVtcGxhdGUgb2Ygc2VsZWN0b3JzLiBVc2VkIGluIHRleHRJbnB1dHMgYW5kIGJ1dHRvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdGF0ZWZ1bFNlbGVjdG9ycyhzdGF0ZXMsIHRlbXBsYXRlLCBzdGF0ZU1hcCkge1xuICBpZiAoIXRlbXBsYXRlKSB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2Nyk7XG4gIGlmIChzdGF0ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZ2VuZXJhdGVTZWxlY3RvcnModGVtcGxhdGUsIG51bGwpO1xuICB2YXIgc2VsZWN0b3JzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHN0YXRlTWFwICYmIHN0YXRlTWFwLmluZGV4T2Yoc3RhdGVzW2ldKSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBQb2xpc2hlZEVycm9yKDY4KTtcbiAgICB9XG4gICAgc2VsZWN0b3JzLnB1c2goZ2VuZXJhdGVTZWxlY3RvcnModGVtcGxhdGUsIHN0YXRlc1tpXSkpO1xuICB9XG4gIHNlbGVjdG9ycyA9IHNlbGVjdG9ycy5qb2luKCcsJyk7XG4gIHJldHVybiBzZWxlY3RvcnM7XG59XG5cbnZhciBzdGF0ZU1hcCQxID0gW3VuZGVmaW5lZCwgbnVsbCwgJ2FjdGl2ZScsICdmb2N1cycsICdob3ZlciddO1xuZnVuY3Rpb24gdGVtcGxhdGUkMShzdGF0ZSkge1xuICByZXR1cm4gXCJidXR0b25cIiArIHN0YXRlICsgXCIsXFxuICBpbnB1dFt0eXBlPVxcXCJidXR0b25cXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gIGlucHV0W3R5cGU9XFxcInJlc2V0XFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICBpbnB1dFt0eXBlPVxcXCJzdWJtaXRcXFwiXVwiICsgc3RhdGU7XG59XG5cbi8qKlxuICogUG9wdWxhdGVzIHNlbGVjdG9ycyB0aGF0IHRhcmdldCBhbGwgYnV0dG9ucy4gWW91IGNhbiBwYXNzIG9wdGlvbmFsIHN0YXRlcyB0byBhcHBlbmQgdG8gdGhlIHNlbGVjdG9ycy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIFtidXR0b25zKCdhY3RpdmUnKV06IHtcbiAqICAgICAnYm9yZGVyJzogJ25vbmUnXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgPiAke2J1dHRvbnMoJ2FjdGl2ZScpfSB7XG4gKiAgICAgYm9yZGVyOiBub25lO1xuICogICB9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqICAnYnV0dG9uOmFjdGl2ZSxcbiAqICAnaW5wdXRbdHlwZT1cImJ1dHRvblwiXTphY3RpdmUsXG4gKiAgJ2lucHV0W3R5cGU9XFxcInJlc2V0XFxcIl06YWN0aXZlLFxuICogICdpbnB1dFt0eXBlPVxcXCJzdWJtaXRcXFwiXTphY3RpdmU6IHtcbiAqICAgJ2JvcmRlcic6ICdub25lJ1xuICogfVxuICovXG5mdW5jdGlvbiBidXR0b25zKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RhdGVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0YXRlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gc3RhdGVmdWxTZWxlY3RvcnMoc3RhdGVzLCB0ZW1wbGF0ZSQxLCBzdGF0ZU1hcCQxKTtcbn1cblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ubWFyZ2luKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHttYXJnaW4oJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ21hcmdpblRvcCc6ICcxMnB4JyxcbiAqICAgJ21hcmdpblJpZ2h0JzogJzI0cHgnLFxuICogICAnbWFyZ2luQm90dG9tJzogJzM2cHgnLFxuICogICAnbWFyZ2luTGVmdCc6ICc0OHB4J1xuICogfVxuICovXG5mdW5jdGlvbiBtYXJnaW4oKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBkaXJlY3Rpb25hbFByb3BlcnR5LmFwcGx5KHZvaWQgMCwgWydtYXJnaW4nXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnBhZGRpbmcoJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3BhZGRpbmcoJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ3BhZGRpbmdUb3AnOiAnMTJweCcsXG4gKiAgICdwYWRkaW5nUmlnaHQnOiAnMjRweCcsXG4gKiAgICdwYWRkaW5nQm90dG9tJzogJzM2cHgnLFxuICogICAncGFkZGluZ0xlZnQnOiAnNDhweCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcGFkZGluZygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJ3BhZGRpbmcnXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbnZhciBwb3NpdGlvbk1hcCA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnLCAncmVsYXRpdmUnLCAnc3RhdGljJywgJ3N0aWNreSddO1xuXG4vKipcbiAqIFNob3J0aGFuZCBhY2NlcHRzIHVwIHRvIGZpdmUgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLiBUaGUgZmlyc3QgdmFsdWUgY2FuIG9wdGlvbmFsbHkgYmUgYSBwb3NpdGlvbiBrZXl3b3JkLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ucG9zaXRpb24oJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3Bvc2l0aW9uKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICd0b3AnOiAnMTJweCcsXG4gKiAgICdyaWdodCc6ICcyNHB4JyxcbiAqICAgJ2JvdHRvbSc6ICczNnB4JyxcbiAqICAgJ2xlZnQnOiAnNDhweCdcbiAqIH1cbiAqXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnBvc2l0aW9uKCdhYnNvbHV0ZScsICcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtwb3NpdGlvbignYWJzb2x1dGUnLCAnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICogICAndG9wJzogJzEycHgnLFxuICogICAncmlnaHQnOiAnMjRweCcsXG4gKiAgICdib3R0b20nOiAnMzZweCcsXG4gKiAgICdsZWZ0JzogJzQ4cHgnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHBvc2l0aW9uKGZpcnN0VmFsdWUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBpZiAocG9zaXRpb25NYXAuaW5kZXhPZihmaXJzdFZhbHVlKSA+PSAwICYmIGZpcnN0VmFsdWUpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodm9pZCAwLCBbJyddLmNvbmNhdCh2YWx1ZXMpKSwge1xuICAgICAgcG9zaXRpb246IGZpcnN0VmFsdWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh2b2lkIDAsIFsnJywgZmlyc3RWYWx1ZV0uY29uY2F0KHZhbHVlcykpO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnRoYW5kIHRvIHNldCB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBwcm9wZXJ0aWVzIGluIGEgc2luZ2xlIHN0YXRlbWVudC5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnNpemUoJzMwMHB4JywgJzI1MHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtzaXplKCczMDBweCcsICcyNTBweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnaGVpZ2h0JzogJzMwMHB4JyxcbiAqICAgJ3dpZHRoJzogJzI1MHB4JyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gc2l6ZShoZWlnaHQsIHdpZHRoKSB7XG4gIGlmICh3aWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgd2lkdGggPSBoZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB3aWR0aDogd2lkdGhcbiAgfTtcbn1cblxudmFyIHN0YXRlTWFwID0gW3VuZGVmaW5lZCwgbnVsbCwgJ2FjdGl2ZScsICdmb2N1cycsICdob3ZlciddO1xuZnVuY3Rpb24gdGVtcGxhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIFwiaW5wdXRbdHlwZT1cXFwiY29sb3JcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwiZGF0ZVxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJkYXRldGltZVxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJkYXRldGltZS1sb2NhbFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJlbWFpbFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJtb250aFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJudW1iZXJcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwicGFzc3dvcmRcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcInRlbFxcXCJdXCIgKyBzdGF0ZSArIFwiLFxcbiAgICBpbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcInRpbWVcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXRbdHlwZT1cXFwidXJsXFxcIl1cIiArIHN0YXRlICsgXCIsXFxuICAgIGlucHV0W3R5cGU9XFxcIndlZWtcXFwiXVwiICsgc3RhdGUgKyBcIixcXG4gICAgaW5wdXQ6bm90KFt0eXBlXSlcIiArIHN0YXRlICsgXCIsXFxuICAgIHRleHRhcmVhXCIgKyBzdGF0ZTtcbn1cblxuLyoqXG4gKiBQb3B1bGF0ZXMgc2VsZWN0b3JzIHRoYXQgdGFyZ2V0IGFsbCB0ZXh0IGlucHV0cy4gWW91IGNhbiBwYXNzIG9wdGlvbmFsIHN0YXRlcyB0byBhcHBlbmQgdG8gdGhlIHNlbGVjdG9ycy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIFt0ZXh0SW5wdXRzKCdhY3RpdmUnKV06IHtcbiAqICAgICAnYm9yZGVyJzogJ25vbmUnXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgPiAke3RleHRJbnB1dHMoJ2FjdGl2ZScpfSB7XG4gKiAgICAgYm9yZGVyOiBub25lO1xuICogICB9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqICAnaW5wdXRbdHlwZT1cImNvbG9yXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwiZGF0ZVwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cImRhdGV0aW1lXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJlbWFpbFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cIm1vbnRoXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwibnVtYmVyXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwicGFzc3dvcmRcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJzZWFyY2hcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ0ZWxcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ0ZXh0XCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwidGltZVwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInVybFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cIndlZWtcIl06YWN0aXZlLFxuICogIGlucHV0Om5vdChbdHlwZV0pOmFjdGl2ZSxcbiAqICB0ZXh0YXJlYTphY3RpdmUnOiB7XG4gKiAgICdib3JkZXInOiAnbm9uZSdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gdGV4dElucHV0cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0YXRlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdGF0ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIHN0YXRlZnVsU2VsZWN0b3JzKHN0YXRlcywgdGVtcGxhdGUsIHN0YXRlTWFwKTtcbn1cblxuLyoqXG4gKiBBY2NlcHRzIGFueSBudW1iZXIgb2YgdHJhbnNpdGlvbiB2YWx1ZXMgYXMgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBzaW5nbGUgdHJhbnNpdGlvbiBzdGF0ZW1lbnQuIFlvdSBtYXkgYWxzbyBwYXNzIGFuIGFycmF5IG9mIHByb3BlcnRpZXMgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIGFwcGx5IHRoZSBzYW1lIHRyYW5zaXRpb24gdmFsdWVzIHRvIChzZWNvbmQgcGFyYW1ldGVyKS5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnRyYW5zaXRpb25zKCdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcycsICd3aWR0aCAyLjBzIGVhc2UtaW4gMnMnKSxcbiAqICAgLi4udHJhbnNpdGlvbnMoWydjb2xvcicsICdiYWNrZ3JvdW5kLWNvbG9yJ10sICcyLjBzIGVhc2UtaW4gMnMnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3RyYW5zaXRpb25zKCdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcycsICd3aWR0aCAyLjBzIGVhc2UtaW4gMnMnKX07XG4gKiAgICR7dHJhbnNpdGlvbnMoWydjb2xvcicsICdiYWNrZ3JvdW5kLWNvbG9yJ10sICcyLjBzIGVhc2UtaW4gMnMnKSx9O1xuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAndHJhbnNpdGlvbic6ICdvcGFjaXR5IDEuMHMgZWFzZS1pbiAwcywgd2lkdGggMi4wcyBlYXNlLWluIDJzJ1xuICogICAndHJhbnNpdGlvbic6ICdjb2xvciAyLjBzIGVhc2UtaW4gMnMsIGJhY2tncm91bmQtY29sb3IgMi4wcyBlYXNlLWluIDJzJyxcbiAqIH1cbiAqL1xuZnVuY3Rpb24gdHJhbnNpdGlvbnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wZXJ0aWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHByb3BlcnRpZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydGllc1swXSkgJiYgcHJvcGVydGllcy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0aWVzWzFdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgUG9saXNoZWRFcnJvcig2MSk7XG4gICAgfVxuICAgIHZhciB0cmFuc2l0aW9uc1N0cmluZyA9IHByb3BlcnRpZXNbMF0ubWFwKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHByb3BlcnR5ICsgXCIgXCIgKyB2YWx1ZTtcbiAgICB9KS5qb2luKCcsICcpO1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uc1N0cmluZ1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb246IHByb3BlcnRpZXMuam9pbignLCAnKVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IHsgY3VycmllZEFkanVzdEh1ZSQxIGFzIGFkanVzdEh1ZSwgYW5pbWF0aW9uLCBiYWNrZ3JvdW5kSW1hZ2VzLCBiYWNrZ3JvdW5kcywgYmV0d2VlbiwgYm9yZGVyLCBib3JkZXJDb2xvciwgYm9yZGVyUmFkaXVzLCBib3JkZXJTdHlsZSwgYm9yZGVyV2lkdGgsIGJ1dHRvbnMsIGNsZWFyRml4LCBjb21wbGVtZW50LCBjb3ZlciwgY3NzVmFyLCBjdXJyaWVkRGFya2VuJDEgYXMgZGFya2VuLCBjdXJyaWVkRGVzYXR1cmF0ZSQxIGFzIGRlc2F0dXJhdGUsIGRpcmVjdGlvbmFsUHJvcGVydHksIGVhc2VJbiwgZWFzZUluT3V0LCBlYXNlT3V0LCBlbGxpcHNpcywgZW0kMSBhcyBlbSwgZmx1aWRSYW5nZSwgZm9udEZhY2UsIGdldENvbnRyYXN0LCBnZXRMdW1pbmFuY2UsIGdldFZhbHVlQW5kVW5pdCwgZ3JheXNjYWxlLCBoaURQSSwgaGlkZVRleHQsIGhpZGVWaXN1YWxseSwgaHNsLCBoc2xUb0NvbG9yU3RyaW5nLCBoc2xhLCBpbXBvcnRhbnQsIGludmVydCwgY3VycmllZExpZ2h0ZW4kMSBhcyBsaWdodGVuLCBsaW5lYXJHcmFkaWVudCwgbWFyZ2luLCBtYXRoLCBtZWV0c0NvbnRyYXN0R3VpZGVsaW5lcywgbWl4JDEgYXMgbWl4LCBtb2R1bGFyU2NhbGUsIG5vcm1hbGl6ZSwgY3VycmllZE9wYWNpZnkkMSBhcyBvcGFjaWZ5LCBwYWRkaW5nLCBwYXJzZVRvSHNsLCBwYXJzZVRvUmdiLCBwb3NpdGlvbiwgcmFkaWFsR3JhZGllbnQsIHJlYWRhYmxlQ29sb3IsIHJlbSQxIGFzIHJlbSwgcmVtVG9QeCwgcmV0aW5hSW1hZ2UsIHJnYiwgcmdiVG9Db2xvclN0cmluZywgcmdiYSwgY3VycmllZFNhdHVyYXRlJDEgYXMgc2F0dXJhdGUsIGN1cnJpZWRTZXRIdWUkMSBhcyBzZXRIdWUsIGN1cnJpZWRTZXRMaWdodG5lc3MkMSBhcyBzZXRMaWdodG5lc3MsIGN1cnJpZWRTZXRTYXR1cmF0aW9uJDEgYXMgc2V0U2F0dXJhdGlvbiwgY3VycmllZFNoYWRlJDEgYXMgc2hhZGUsIHNpemUsIHN0cmlwVW5pdCwgdGV4dElucHV0cywgdGltaW5nRnVuY3Rpb25zLCBjdXJyaWVkVGludCQxIGFzIHRpbnQsIHRvQ29sb3JTdHJpbmcsIHRyYW5zaXRpb25zLCBjdXJyaWVkVHJhbnNwYXJlbnRpemUkMSBhcyB0cmFuc3BhcmVudGl6ZSwgdHJpYW5nbGUsIHdvcmRXcmFwIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX2luaGVyaXRzTG9vc2UiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlIiwibGFzdCIsIl9yZWYiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJuZWdhdGlvbiIsImEiLCJhZGRpdGlvbiIsImIiLCJzdWJ0cmFjdGlvbiIsIm11bHRpcGxpY2F0aW9uIiwiZGl2aXNpb24iLCJtYXgiLCJNYXRoIiwiYXBwbHkiLCJtaW4iLCJjb21tYSIsIkFycmF5Iiwib2YiLCJkZWZhdWx0U3ltYm9scyIsInN5bWJvbHMiLCJpbmZpeCIsInN5bWJvbCIsImYiLCJub3RhdGlvbiIsInByZWNlZGVuY2UiLCJyaWdodFRvTGVmdCIsImFyZ0NvdW50IiwicmVnU3ltYm9sIiwicHJlZml4IiwicG9zdGZpeCIsImZ1bmMiLCJkZWZhdWx0U3ltYm9sTWFwIiwiRVJST1JTIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3MiLCJfa2V5IiwiYyIsInB1c2giLCJmb3JFYWNoIiwiZCIsInJlcGxhY2UiLCJQb2xpc2hlZEVycm9yIiwiX0Vycm9yIiwiY29kZSIsIl90aGlzIiwicHJvY2VzcyIsImNhbGwiLCJfbGVuMiIsIl9rZXkyIiwiY29uY2F0IiwiRXJyb3IiLCJ1bml0UmVnRXhwIiwibWVyZ2VTeW1ib2xNYXBzIiwiYWRkaXRpb25hbFN5bWJvbHMiLCJzeW1ib2xNYXAiLCJleGVjIiwib3BlcmF0b3JzIiwidmFsdWVzIiwib3AiLCJwb3AiLCJzcGxpY2UiLCJjYWxjdWxhdGUiLCJleHByZXNzaW9uIiwibWF0Y2giLCJwYXR0ZXJuIiwiUmVnRXhwIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsImtleSIsInNvcnQiLCJ2YWwiLCJqb2luIiwibGFzdEluZGV4IiwiYWZ0ZXJWYWx1ZSIsIl9yZWYyIiwidG9rZW4iLCJiYWQiLCJub3ROdW1iZXIiLCJub3ROZXdWYWx1ZSIsIm5vdEFmdGVyVmFsdWUiLCJpbmRleCIsImN1cnIiLCJwcmV2IiwicmV2ZXJzZVN0cmluZyIsInN0ciIsInNwbGl0IiwicmV2ZXJzZSIsIm1hdGgiLCJmb3JtdWxhIiwicmV2ZXJzZWRGb3JtdWxhIiwiZm9ybXVsYU1hdGNoIiwiZXZlcnkiLCJ1bml0IiwiY2xlYW5Gb3JtdWxhIiwiY3NzVmFyaWFibGVSZWdleCIsImNzc1ZhciIsImNzc1ZhcmlhYmxlIiwiZGVmYXVsdFZhbHVlIiwidmFyaWFibGVWYWx1ZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJ0cmltIiwiY2FwaXRhbGl6ZVN0cmluZyIsInN0cmluZyIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJwb3NpdGlvbk1hcCQxIiwiZ2VuZXJhdGVQcm9wZXJ0eSIsInByb3BlcnR5IiwicG9zaXRpb24iLCJ0b0xvd2VyQ2FzZSIsInNwbGl0UHJvcGVydHkiLCJyZWR1Y2UiLCJhY2MiLCJqb2luZWRQcm9wZXJ0eSIsImdlbmVyYXRlU3R5bGVzIiwidmFsdWVzV2l0aERlZmF1bHRzIiwic3R5bGVzIiwiaSIsImRpcmVjdGlvbmFsUHJvcGVydHkiLCJmaXJzdFZhbHVlIiwiX3ZhbHVlcyQiLCJzZWNvbmRWYWx1ZSIsIl92YWx1ZXMkMiIsInRoaXJkVmFsdWUiLCJfdmFsdWVzJDMiLCJmb3VydGhWYWx1ZSIsImVuZHNXaXRoIiwic3VmZml4Iiwic3Vic3RyIiwiY3NzUmVnZXgkMSIsInN0cmlwVW5pdCIsInZhbHVlIiwibWF0Y2hlZFZhbHVlIiwicGFyc2VGbG9hdCIsInB4dG9GYWN0b3J5IiwidG8iLCJweHZhbCIsImJhc2UiLCJuZXdQeHZhbCIsIm5ld0Jhc2UiLCJwaXhlbHN0byIsImVtIiwiZW0kMSIsImNzc1JlZ2V4IiwiZ2V0VmFsdWVBbmRVbml0IiwiaW1wb3J0YW50Iiwic3R5bGVCbG9jayIsInJ1bGVzIiwibmV3U3R5bGVCbG9jayIsImluZGV4T2YiLCJyYXRpb05hbWVzIiwibWlub3JTZWNvbmQiLCJtYWpvclNlY29uZCIsIm1pbm9yVGhpcmQiLCJtYWpvclRoaXJkIiwicGVyZmVjdEZvdXJ0aCIsImF1Z0ZvdXJ0aCIsInBlcmZlY3RGaWZ0aCIsIm1pbm9yU2l4dGgiLCJnb2xkZW5TZWN0aW9uIiwibWFqb3JTaXh0aCIsIm1pbm9yU2V2ZW50aCIsIm1ham9yU2V2ZW50aCIsIm9jdGF2ZSIsIm1ham9yVGVudGgiLCJtYWpvckVsZXZlbnRoIiwibWFqb3JUd2VsZnRoIiwiZG91YmxlT2N0YXZlIiwiZ2V0UmF0aW8iLCJyYXRpb05hbWUiLCJtb2R1bGFyU2NhbGUiLCJzdGVwcyIsInJhdGlvIiwicmVhbEJhc2UiLCJyZWFsUmF0aW8iLCJwb3ciLCJyZW0iLCJyZW0kMSIsImRlZmF1bHRGb250U2l6ZSIsImNvbnZlcnRCYXNlIiwiZGVjb25zdHJ1Y3RlZFZhbHVlIiwiZ2V0QmFzZUZyb21Eb2MiLCJyb290Rm9udFNpemUiLCJmb250U2l6ZSIsInJlbVRvUHgiLCJmdW5jdGlvbnNNYXAkMyIsImJhY2siLCJjaXJjIiwiY3ViaWMiLCJleHBvIiwicXVhZCIsInF1YXJ0IiwicXVpbnQiLCJzaW5lIiwiZWFzZUluIiwiZnVuY3Rpb25OYW1lIiwiZnVuY3Rpb25zTWFwJDIiLCJlYXNlSW5PdXQiLCJmdW5jdGlvbnNNYXAkMSIsImVhc2VPdXQiLCJiZXR3ZWVuIiwiZnJvbVNpemUiLCJ0b1NpemUiLCJtaW5TY3JlZW4iLCJtYXhTY3JlZW4iLCJfZ2V0VmFsdWVBbmRVbml0IiwidW5pdGxlc3NGcm9tU2l6ZSIsImZyb21TaXplVW5pdCIsIl9nZXRWYWx1ZUFuZFVuaXQyIiwidW5pdGxlc3NUb1NpemUiLCJ0b1NpemVVbml0IiwiX2dldFZhbHVlQW5kVW5pdDMiLCJ1bml0bGVzc01pblNjcmVlbiIsIm1pblNjcmVlblVuaXQiLCJfZ2V0VmFsdWVBbmRVbml0NCIsInVuaXRsZXNzTWF4U2NyZWVuIiwibWF4U2NyZWVuVW5pdCIsInNsb3BlIiwidG9GaXhlZCIsImNsZWFyRml4IiwicGFyZW50IiwicHNldWRvU2VsZWN0b3IiLCJjbGVhciIsImNvbnRlbnQiLCJkaXNwbGF5IiwiY292ZXIiLCJvZmZzZXQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJlbGxpcHNpcyIsIndpZHRoIiwibGluZXMiLCJtYXhXaWR0aCIsIm92ZXJmbG93IiwidGV4dE92ZXJmbG93Iiwid2hpdGVTcGFjZSIsIndvcmRXcmFwIiwiV2Via2l0Qm94T3JpZW50IiwiV2Via2l0TGluZUNsYW1wIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSIsIm8iLCJhbGxvd0FycmF5TGlrZSIsIml0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuZXh0IiwiYmluZCIsImlzQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJkb25lIiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJuIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJmcm9tIiwidGVzdCIsImFyciIsImxlbiIsImFycjIiLCJmbHVpZFJhbmdlIiwiY3NzUHJvcCIsIm1lZGlhUXVlcmllcyIsImZhbGxiYWNrcyIsIl9pdGVyYXRvciIsIl9zdGVwIiwiX2V4dGVuZHMyIiwiX2V4dGVuZHMzIiwib2JqIiwicHJvcCIsIl9yZWYzIiwiZGF0YVVSSVJlZ2V4IiwiZm9ybWF0SGludE1hcCIsIndvZmYiLCJ3b2ZmMiIsInR0ZiIsIm90ZiIsImVvdCIsInN2ZyIsInN2Z3oiLCJnZW5lcmF0ZUZvcm1hdEhpbnQiLCJmb3JtYXRIaW50IiwiaXNEYXRhVVJJIiwiZm9udEZpbGVQYXRoIiwiZ2VuZXJhdGVGaWxlUmVmZXJlbmNlcyIsImZpbGVGb3JtYXRzIiwiZmlsZUZvbnRSZWZlcmVuY2VzIiwiZ2VuZXJhdGVMb2NhbFJlZmVyZW5jZXMiLCJsb2NhbEZvbnRzIiwibG9jYWxGb250UmVmZXJlbmNlcyIsImZvbnQiLCJnZW5lcmF0ZVNvdXJjZXMiLCJmb250UmVmZXJlbmNlcyIsImZvbnRGYWNlIiwiZm9udEZhbWlseSIsImZvbnRTdHJldGNoIiwiZm9udFN0eWxlIiwiZm9udFZhcmlhbnQiLCJmb250V2VpZ2h0IiwiX3JlZiRmaWxlRm9ybWF0cyIsIl9yZWYkZm9ybWF0SGludCIsIl9yZWYkbG9jYWxGb250cyIsInVuaWNvZGVSYW5nZSIsImZvbnREaXNwbGF5IiwiZm9udFZhcmlhdGlvblNldHRpbmdzIiwiZm9udEZlYXR1cmVTZXR0aW5ncyIsImZvbnRGYWNlRGVjbGFyYXRpb24iLCJzcmMiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJoaWRlVGV4dCIsInRleHRJbmRlbnQiLCJoaWRlVmlzdWFsbHkiLCJib3JkZXIiLCJjbGlwIiwiaGVpZ2h0IiwibWFyZ2luIiwicGFkZGluZyIsImhpRFBJIiwicm91bmQiLCJjb25zdHJ1Y3RHcmFkaWVudFZhbHVlIiwibGl0ZXJhbHMiLCJ0ZW1wbGF0ZSIsInN1YnN0aXR1dGlvbnMiLCJkZWZpbmVkVmFsdWVzIiwiZmlsdGVyIiwic3Vic3RpdHV0ZSIsIl90ZW1wbGF0ZU9iamVjdCQxIiwibGluZWFyR3JhZGllbnQiLCJjb2xvclN0b3BzIiwiZmFsbGJhY2siLCJfcmVmJHRvRGlyZWN0aW9uIiwidG9EaXJlY3Rpb24iLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJub3JtYWxpemUiLCJodG1sIiwibGluZUhlaWdodCIsInRleHRTaXplQWRqdXN0IiwiYm9keSIsIm1haW4iLCJoMSIsImhyIiwiYm94U2l6aW5nIiwicHJlIiwiYm9yZGVyQm90dG9tIiwidGV4dERlY29yYXRpb24iLCJzbWFsbCIsInZlcnRpY2FsQWxpZ24iLCJzdWIiLCJzdXAiLCJpbWciLCJib3JkZXJTdHlsZSIsInRleHRUcmFuc2Zvcm0iLCJXZWJraXRBcHBlYXJhbmNlIiwib3V0bGluZSIsImZpZWxkc2V0IiwibGVnZW5kIiwiY29sb3IiLCJwcm9ncmVzcyIsInRleHRhcmVhIiwib3V0bGluZU9mZnNldCIsImRldGFpbHMiLCJzdW1tYXJ5IiwiX3RlbXBsYXRlT2JqZWN0IiwicmFkaWFsR3JhZGllbnQiLCJfcmVmJGV4dGVudCIsImV4dGVudCIsIl9yZWYkcG9zaXRpb24iLCJfcmVmJHNoYXBlIiwic2hhcGUiLCJyZXRpbmFJbWFnZSIsImZpbGVuYW1lIiwiYmFja2dyb3VuZFNpemUiLCJleHRlbnNpb24iLCJyZXRpbmFGaWxlbmFtZSIsInJldGluYVN1ZmZpeCIsImV4dCIsInJGaWxlbmFtZSIsImZ1bmN0aW9uc01hcCIsImVhc2VJbkJhY2siLCJlYXNlSW5DaXJjIiwiZWFzZUluQ3ViaWMiLCJlYXNlSW5FeHBvIiwiZWFzZUluUXVhZCIsImVhc2VJblF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlSW5TaW5lIiwiZWFzZU91dEJhY2siLCJlYXNlT3V0Q3ViaWMiLCJlYXNlT3V0Q2lyYyIsImVhc2VPdXRFeHBvIiwiZWFzZU91dFF1YWQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dEJhY2siLCJlYXNlSW5PdXRDaXJjIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5PdXRTaW5lIiwiZ2V0VGltaW5nRnVuY3Rpb24iLCJ0aW1pbmdGdW5jdGlvbnMiLCJ0aW1pbmdGdW5jdGlvbiIsImdldEJvcmRlcldpZHRoIiwicG9pbnRpbmdEaXJlY3Rpb24iLCJmdWxsV2lkdGgiLCJoYWxmV2lkdGgiLCJmdWxsSGVpZ2h0IiwiaGFsZkhlaWdodCIsImdldEJvcmRlckNvbG9yIiwiZm9yZWdyb3VuZENvbG9yIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJib3JkZXJMZWZ0Q29sb3IiLCJib3JkZXJUb3BDb2xvciIsImJvcmRlclJpZ2h0Q29sb3IiLCJ0cmlhbmdsZSIsIl9yZWYkYmFja2dyb3VuZENvbG9yIiwid2lkdGhBbmRVbml0IiwiaGVpZ2h0QW5kVW5pdCIsImlzTmFOIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJXaWR0aCIsIndyYXAiLCJ3b3JkQnJlYWsiLCJvdmVyZmxvd1dyYXAiLCJjb2xvclRvSW50IiwiY29udmVydFRvSW50IiwicmVkIiwiZ3JlZW4iLCJibHVlIiwiaHNsVG9SZ2IiLCJodWUiLCJzYXR1cmF0aW9uIiwibGlnaHRuZXNzIiwiY29udmVydCIsImh1ZVByaW1lIiwiY2hyb21hIiwiYWJzIiwic2Vjb25kQ29tcG9uZW50IiwibGlnaHRuZXNzTW9kaWZpY2F0aW9uIiwiZmluYWxSZWQiLCJmaW5hbEdyZWVuIiwiZmluYWxCbHVlIiwibmFtZWRDb2xvck1hcCIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYWNrIiwiYmxhbmNoZWRhbG1vbmQiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW55ZWxsb3ciLCJncmV5IiwiaG9uZXlkZXciLCJob3RwaW5rIiwiaW5kaWFucmVkIiwiaW5kaWdvIiwiaXZvcnkiLCJraGFraSIsImxhdmVuZGVyIiwibGF2ZW5kZXJibHVzaCIsImxhd25ncmVlbiIsImxlbW9uY2hpZmZvbiIsImxpZ2h0Ymx1ZSIsImxpZ2h0Y29yYWwiLCJsaWdodGN5YW4iLCJsaWdodGdvbGRlbnJvZHllbGxvdyIsImxpZ2h0Z3JheSIsImxpZ2h0Z3JlZW4iLCJsaWdodGdyZXkiLCJsaWdodHBpbmsiLCJsaWdodHNhbG1vbiIsImxpZ2h0c2VhZ3JlZW4iLCJsaWdodHNreWJsdWUiLCJsaWdodHNsYXRlZ3JheSIsImxpZ2h0c2xhdGVncmV5IiwibGlnaHRzdGVlbGJsdWUiLCJsaWdodHllbGxvdyIsImxpbWUiLCJsaW1lZ3JlZW4iLCJsaW5lbiIsIm1hZ2VudGEiLCJtYXJvb24iLCJtZWRpdW1hcXVhbWFyaW5lIiwibWVkaXVtYmx1ZSIsIm1lZGl1bW9yY2hpZCIsIm1lZGl1bXB1cnBsZSIsIm1lZGl1bXNlYWdyZWVuIiwibWVkaXVtc2xhdGVibHVlIiwibWVkaXVtc3ByaW5nZ3JlZW4iLCJtZWRpdW10dXJxdW9pc2UiLCJtZWRpdW12aW9sZXRyZWQiLCJtaWRuaWdodGJsdWUiLCJtaW50Y3JlYW0iLCJtaXN0eXJvc2UiLCJtb2NjYXNpbiIsIm5hdmFqb3doaXRlIiwibmF2eSIsIm9sZGxhY2UiLCJvbGl2ZSIsIm9saXZlZHJhYiIsIm9yYW5nZSIsIm9yYW5nZXJlZCIsIm9yY2hpZCIsInBhbGVnb2xkZW5yb2QiLCJwYWxlZ3JlZW4iLCJwYWxldHVycXVvaXNlIiwicGFsZXZpb2xldHJlZCIsInBhcGF5YXdoaXAiLCJwZWFjaHB1ZmYiLCJwZXJ1IiwicGluayIsInBsdW0iLCJwb3dkZXJibHVlIiwicHVycGxlIiwicmViZWNjYXB1cnBsZSIsInJvc3licm93biIsInJveWFsYmx1ZSIsInNhZGRsZWJyb3duIiwic2FsbW9uIiwic2FuZHlicm93biIsInNlYWdyZWVuIiwic2Vhc2hlbGwiLCJzaWVubmEiLCJzaWx2ZXIiLCJza3libHVlIiwic2xhdGVibHVlIiwic2xhdGVncmF5Iiwic2xhdGVncmV5Iiwic25vdyIsInNwcmluZ2dyZWVuIiwic3RlZWxibHVlIiwidGFuIiwidGVhbCIsInRoaXN0bGUiLCJ0b21hdG8iLCJ0dXJxdW9pc2UiLCJ2aW9sZXQiLCJ3aGVhdCIsIndoaXRlIiwid2hpdGVzbW9rZSIsInllbGxvdyIsInllbGxvd2dyZWVuIiwibmFtZVRvSGV4Iiwibm9ybWFsaXplZENvbG9yTmFtZSIsImhleFJlZ2V4IiwiaGV4UmdiYVJlZ2V4IiwicmVkdWNlZEhleFJlZ2V4IiwicmVkdWNlZFJnYmFIZXhSZWdleCIsInJnYlJlZ2V4IiwicmdiYVJlZ2V4IiwiaHNsUmVnZXgiLCJoc2xhUmVnZXgiLCJwYXJzZVRvUmdiIiwibm9ybWFsaXplZENvbG9yIiwicGFyc2VJbnQiLCJhbHBoYSIsIl9hbHBoYSIsInJnYk1hdGNoZWQiLCJyZ2JhTWF0Y2hlZCIsInN1YnN0cmluZyIsImhzbE1hdGNoZWQiLCJyZ2JDb2xvclN0cmluZyIsImhzbFJnYk1hdGNoZWQiLCJoc2xhTWF0Y2hlZCIsIl9odWUiLCJfc2F0dXJhdGlvbiIsIl9saWdodG5lc3MiLCJfcmdiQ29sb3JTdHJpbmciLCJfaHNsUmdiTWF0Y2hlZCIsInJnYlRvSHNsIiwiZGVsdGEiLCJwYXJzZVRvSHNsIiwicmVkdWNlSGV4VmFsdWUiLCJyZWR1Y2VIZXhWYWx1ZSQxIiwibnVtYmVyVG9IZXgiLCJoZXgiLCJjb2xvclRvSGV4IiwiY29udmVydFRvSGV4IiwiaHNsVG9IZXgiLCJoc2wiLCJoc2xhIiwicmdiIiwicmdiYSIsInJnYlZhbHVlIiwiaXNSZ2IiLCJpc1JnYmEiLCJpc0hzbCIsImlzSHNsYSIsInRvQ29sb3JTdHJpbmciLCJjdXJyaWVkIiwiZm4iLCJjb21iaW5lZCIsImN1cnJ5IiwiYWRqdXN0SHVlIiwiZGVncmVlIiwiaHNsQ29sb3IiLCJjdXJyaWVkQWRqdXN0SHVlIiwiY3VycmllZEFkanVzdEh1ZSQxIiwiY29tcGxlbWVudCIsImd1YXJkIiwibG93ZXJCb3VuZGFyeSIsInVwcGVyQm91bmRhcnkiLCJkYXJrZW4iLCJhbW91bnQiLCJjdXJyaWVkRGFya2VuIiwiY3VycmllZERhcmtlbiQxIiwiZGVzYXR1cmF0ZSIsImN1cnJpZWREZXNhdHVyYXRlIiwiY3VycmllZERlc2F0dXJhdGUkMSIsImdldEx1bWluYW5jZSIsInJnYkNvbG9yIiwiX09iamVjdCRrZXlzJG1hcCIsImNoYW5uZWwiLCJyIiwiZyIsImdldENvbnRyYXN0IiwiY29sb3IxIiwiY29sb3IyIiwibHVtaW5hbmNlMSIsImx1bWluYW5jZTIiLCJncmF5c2NhbGUiLCJoc2xUb0NvbG9yU3RyaW5nIiwiaW52ZXJ0IiwibGlnaHRlbiIsImN1cnJpZWRMaWdodGVuIiwiY3VycmllZExpZ2h0ZW4kMSIsIm1lZXRzQ29udHJhc3RHdWlkZWxpbmVzIiwiY29udHJhc3RSYXRpbyIsIkFBIiwiQUFMYXJnZSIsIkFBQSIsIkFBQUxhcmdlIiwibWl4Iiwid2VpZ2h0Iiwib3RoZXJDb2xvciIsInBhcnNlZENvbG9yMSIsInBhcnNlZENvbG9yMiIsImFscGhhRGVsdGEiLCJ4IiwieSIsInoiLCJ3ZWlnaHQxIiwid2VpZ2h0MiIsIm1peGVkQ29sb3IiLCJmbG9vciIsImN1cnJpZWRNaXgiLCJtaXgkMSIsIm9wYWNpZnkiLCJwYXJzZWRDb2xvciIsImNvbG9yV2l0aEFscGhhIiwiY3VycmllZE9wYWNpZnkiLCJjdXJyaWVkT3BhY2lmeSQxIiwiZGVmYXVsdFJldHVybklmTGlnaHRDb2xvciIsImRlZmF1bHRSZXR1cm5JZkRhcmtDb2xvciIsInJlYWRhYmxlQ29sb3IiLCJyZXR1cm5JZkxpZ2h0Q29sb3IiLCJyZXR1cm5JZkRhcmtDb2xvciIsInN0cmljdCIsImlzQ29sb3JMaWdodCIsInByZWZlcnJlZFJldHVybkNvbG9yIiwicmdiVG9Db2xvclN0cmluZyIsInNhdHVyYXRlIiwiY3VycmllZFNhdHVyYXRlIiwiY3VycmllZFNhdHVyYXRlJDEiLCJzZXRIdWUiLCJjdXJyaWVkU2V0SHVlIiwiY3VycmllZFNldEh1ZSQxIiwic2V0TGlnaHRuZXNzIiwiY3VycmllZFNldExpZ2h0bmVzcyIsImN1cnJpZWRTZXRMaWdodG5lc3MkMSIsInNldFNhdHVyYXRpb24iLCJjdXJyaWVkU2V0U2F0dXJhdGlvbiIsImN1cnJpZWRTZXRTYXR1cmF0aW9uJDEiLCJzaGFkZSIsInBlcmNlbnRhZ2UiLCJjdXJyaWVkU2hhZGUiLCJjdXJyaWVkU2hhZGUkMSIsInRpbnQiLCJjdXJyaWVkVGludCIsImN1cnJpZWRUaW50JDEiLCJ0cmFuc3BhcmVudGl6ZSIsImN1cnJpZWRUcmFuc3BhcmVudGl6ZSIsImN1cnJpZWRUcmFuc3BhcmVudGl6ZSQxIiwiYW5pbWF0aW9uIiwibXVsdGlNb2RlIiwiYXJnIiwiYmFja2dyb3VuZEltYWdlcyIsInByb3BlcnRpZXMiLCJiYWNrZ3JvdW5kcyIsImJhY2tncm91bmQiLCJzaWRlTWFwIiwic2lkZUtleXdvcmQiLCJ1bnNoaWZ0IiwiYm9yZGVyUmFkaXVzIiwic2lkZSIsInJhZGl1cyIsInVwcGVyY2FzZVNpZGUiLCJnZW5lcmF0ZVNlbGVjdG9ycyIsInN0YXRlIiwic3RhdGVTdWZmaXgiLCJzdGF0ZWZ1bFNlbGVjdG9ycyIsInN0YXRlcyIsInN0YXRlTWFwIiwic2VsZWN0b3JzIiwic3RhdGVNYXAkMSIsInRlbXBsYXRlJDEiLCJidXR0b25zIiwicG9zaXRpb25NYXAiLCJzaXplIiwidGV4dElucHV0cyIsInRyYW5zaXRpb25zIiwidHJhbnNpdGlvbnNTdHJpbmciLCJ0cmFuc2l0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polished/dist/polished.esm.js\n");

/***/ })

};
;