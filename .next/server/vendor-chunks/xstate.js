"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xstate";
exports.ids = ["vendor-chunks/xstate"];
exports.modules = {

/***/ "(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/xstate/actors/dist/xstate-actors.development.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyActor: () => (/* binding */ createEmptyActor),\n/* harmony export */   fromCallback: () => (/* binding */ fromCallback),\n/* harmony export */   fromEventObservable: () => (/* binding */ fromEventObservable),\n/* harmony export */   fromObservable: () => (/* binding */ fromObservable),\n/* harmony export */   fromPromise: () => (/* binding */ fromPromise),\n/* harmony export */   fromTransition: () => (/* binding */ fromTransition)\n/* harmony export */ });\n/* harmony import */ var _dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/raise-1db27a82.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */ /**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromTransition(transition, initialContext) {\n    return {\n        config: transition,\n        transition: (snapshot, event, actorScope)=>{\n            return {\n                ...snapshot,\n                context: transition(snapshot.context, event, actorScope)\n            };\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: typeof initialContext === \"function\" ? initialContext({\n                    input\n                }) : initialContext\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n}\nconst instanceStates = /* #__PURE__ */ new WeakMap();\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */ /**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromCallback(callback) {\n    const logic = {\n        config: callback,\n        start: (state, actorScope)=>{\n            const { self, system, emit } = actorScope;\n            const callbackState = {\n                receivers: undefined,\n                dispose: undefined\n            };\n            instanceStates.set(self, callbackState);\n            callbackState.dispose = callback({\n                input: state.input,\n                system,\n                self,\n                sendBack: (event)=>{\n                    if (self.getSnapshot().status === \"stopped\") {\n                        return;\n                    }\n                    if (self._parent) {\n                        system._relay(self, self._parent, event);\n                    }\n                },\n                receive: (listener)=>{\n                    callbackState.receivers ??= new Set();\n                    callbackState.receivers.add(listener);\n                },\n                emit\n            });\n        },\n        transition: (state, event, actorScope)=>{\n            const callbackState = instanceStates.get(actorScope.self);\n            if (event.type === _dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X) {\n                state = {\n                    ...state,\n                    status: \"stopped\",\n                    error: undefined\n                };\n                callbackState.dispose?.();\n                return state;\n            }\n            callbackState.receivers?.forEach((receiver)=>receiver(event));\n            return state;\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                input\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n    return logic;\n}\nconst XSTATE_OBSERVABLE_NEXT = \"xstate.observable.next\";\nconst XSTATE_OBSERVABLE_ERROR = \"xstate.observable.error\";\nconst XSTATE_OBSERVABLE_COMPLETE = \"xstate.observable.complete\";\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */ /**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */ function fromObservable(observableCreator) {\n    // TODO: add event types\n    const logic = {\n        config: observableCreator,\n        transition: (snapshot, event)=>{\n            if (snapshot.status !== \"active\") {\n                return snapshot;\n            }\n            switch(event.type){\n                case XSTATE_OBSERVABLE_NEXT:\n                    {\n                        const newSnapshot = {\n                            ...snapshot,\n                            context: event.data\n                        };\n                        return newSnapshot;\n                    }\n                case XSTATE_OBSERVABLE_ERROR:\n                    return {\n                        ...snapshot,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case XSTATE_OBSERVABLE_COMPLETE:\n                    return {\n                        ...snapshot,\n                        status: \"done\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case _dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    snapshot._subscription.unsubscribe();\n                    return {\n                        ...snapshot,\n                        status: \"stopped\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                default:\n                    return snapshot;\n            }\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: undefined,\n                input,\n                _subscription: undefined\n            };\n        },\n        start: (state, { self, system, emit })=>{\n            if (state.status === \"done\") {\n                // Do not restart a completed observable\n                return;\n            }\n            state._subscription = observableCreator({\n                input: state.input,\n                system,\n                self,\n                emit\n            }).subscribe({\n                next: (value)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_NEXT,\n                        data: value\n                    });\n                },\n                error: (err)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_ERROR,\n                        data: err\n                    });\n                },\n                complete: ()=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_COMPLETE\n                    });\n                }\n            });\n        },\n        getPersistedSnapshot: ({ _subscription, ...state })=>state,\n        restoreSnapshot: (state)=>({\n                ...state,\n                _subscription: undefined\n            })\n    };\n    return logic;\n}\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */ function fromEventObservable(lazyObservable) {\n    // TODO: event types\n    const logic = {\n        config: lazyObservable,\n        transition: (state, event)=>{\n            if (state.status !== \"active\") {\n                return state;\n            }\n            switch(event.type){\n                case XSTATE_OBSERVABLE_ERROR:\n                    return {\n                        ...state,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case XSTATE_OBSERVABLE_COMPLETE:\n                    return {\n                        ...state,\n                        status: \"done\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case _dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    state._subscription.unsubscribe();\n                    return {\n                        ...state,\n                        status: \"stopped\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                default:\n                    return state;\n            }\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: undefined,\n                input,\n                _subscription: undefined\n            };\n        },\n        start: (state, { self, system, emit })=>{\n            if (state.status === \"done\") {\n                // Do not restart a completed observable\n                return;\n            }\n            state._subscription = lazyObservable({\n                input: state.input,\n                system,\n                self,\n                emit\n            }).subscribe({\n                next: (value)=>{\n                    if (self._parent) {\n                        system._relay(self, self._parent, value);\n                    }\n                },\n                error: (err)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_ERROR,\n                        data: err\n                    });\n                },\n                complete: ()=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_COMPLETE\n                    });\n                }\n            });\n        },\n        getPersistedSnapshot: ({ _subscription, ...snapshot })=>snapshot,\n        restoreSnapshot: (snapshot)=>({\n                ...snapshot,\n                _subscription: undefined\n            })\n    };\n    return logic;\n}\nconst XSTATE_PROMISE_RESOLVE = \"xstate.promise.resolve\";\nconst XSTATE_PROMISE_REJECT = \"xstate.promise.reject\";\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */ const controllerMap = new WeakMap();\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromPromise(promiseCreator) {\n    const logic = {\n        config: promiseCreator,\n        transition: (state, event, scope)=>{\n            if (state.status !== \"active\") {\n                return state;\n            }\n            switch(event.type){\n                case XSTATE_PROMISE_RESOLVE:\n                    {\n                        const resolvedValue = event.data;\n                        return {\n                            ...state,\n                            status: \"done\",\n                            output: resolvedValue,\n                            input: undefined\n                        };\n                    }\n                case XSTATE_PROMISE_REJECT:\n                    return {\n                        ...state,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined\n                    };\n                case _dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    {\n                        controllerMap.get(scope.self)?.abort();\n                        return {\n                            ...state,\n                            status: \"stopped\",\n                            input: undefined\n                        };\n                    }\n                default:\n                    return state;\n            }\n        },\n        start: (state, { self, system, emit })=>{\n            // TODO: determine how to allow customizing this so that promises\n            // can be restarted if necessary\n            if (state.status !== \"active\") {\n                return;\n            }\n            const controller = new AbortController();\n            controllerMap.set(self, controller);\n            const resolvedPromise = Promise.resolve(promiseCreator({\n                input: state.input,\n                system,\n                self,\n                signal: controller.signal,\n                emit\n            }));\n            resolvedPromise.then((response)=>{\n                if (self.getSnapshot().status !== \"active\") {\n                    return;\n                }\n                controllerMap.delete(self);\n                system._relay(self, self, {\n                    type: XSTATE_PROMISE_RESOLVE,\n                    data: response\n                });\n            }, (errorData)=>{\n                if (self.getSnapshot().status !== \"active\") {\n                    return;\n                }\n                controllerMap.delete(self);\n                system._relay(self, self, {\n                    type: XSTATE_PROMISE_REJECT,\n                    data: errorData\n                });\n            });\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                input\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n    return logic;\n}\nconst emptyLogic = fromTransition((_)=>undefined, undefined);\nfunction createEmptyActor() {\n    return (0,_dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(emptyLogic);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2FjdG9ycy9kaXN0L3hzdGF0ZS1hY3RvcnMuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtHO0FBQzVDO0FBRXREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5REMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlFQyxHQUNELFNBQVNJLGVBQWVDLFVBQVUsRUFBRUMsY0FBYztJQUNoRCxPQUFPO1FBQ0xDLFFBQVFGO1FBQ1JBLFlBQVksQ0FBQ0csVUFBVUMsT0FBT0M7WUFDNUIsT0FBTztnQkFDTCxHQUFHRixRQUFRO2dCQUNYRyxTQUFTTixXQUFXRyxTQUFTRyxPQUFPLEVBQUVGLE9BQU9DO1lBQy9DO1FBQ0Y7UUFDQUUsb0JBQW9CLENBQUNDLEdBQUdDO1lBQ3RCLE9BQU87Z0JBQ0xDLFFBQVE7Z0JBQ1JDLFFBQVFDO2dCQUNSQyxPQUFPRDtnQkFDUE4sU0FBUyxPQUFPTCxtQkFBbUIsYUFBYUEsZUFBZTtvQkFDN0RRO2dCQUNGLEtBQUtSO1lBQ1A7UUFDRjtRQUNBYSxzQkFBc0JYLENBQUFBLFdBQVlBO1FBQ2xDWSxpQkFBaUJaLENBQUFBLFdBQVlBO0lBQy9CO0FBQ0Y7QUFFQSxNQUFNYSxpQkFBaUIsYUFBYSxHQUFFLElBQUlDO0FBRTFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQ0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpRUMsR0FDRCxTQUFTQyxhQUFhQyxRQUFRO0lBQzVCLE1BQU1DLFFBQVE7UUFDWmxCLFFBQVFpQjtRQUNSRSxPQUFPLENBQUNDLE9BQU9qQjtZQUNiLE1BQU0sRUFDSmtCLElB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QjtBQUNUO0FBRUEsTUFBTXdELGFBQWE3RSxlQUFlUyxDQUFBQSxJQUFLSSxXQUFXQTtBQUNsRCxTQUFTaUU7SUFDUCxPQUFPL0UsMEVBQVdBLENBQUM4RTtBQUNyQjtBQUU0RyIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9hY3RvcnMvZGlzdC94c3RhdGUtYWN0b3JzLmRldmVsb3BtZW50LmVzbS5qcz8yYmY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFggYXMgWFNUQVRFX1NUT1AsIEEgYXMgY3JlYXRlQWN0b3IgfSBmcm9tICcuLi8uLi9kaXN0L3JhaXNlLTFkYjI3YTgyLmRldmVsb3BtZW50LmVzbS5qcyc7XG5pbXBvcnQgJy4uLy4uL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFjdG9yIGNyZWF0ZWQgYnkgYGZyb21UcmFuc2l0aW9uYC5cbiAqXG4gKiBUaGUgdHlwZSBvZiBgc2VsZmAgd2l0aGluIHRoZSBhY3RvcidzIGxvZ2ljLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7XG4gKiAgIGZyb21UcmFuc2l0aW9uLFxuICogICBjcmVhdGVBY3RvcixcbiAqICAgdHlwZSBBbnlBY3RvclN5c3RlbVxuICogfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIC8vKiBUaGUgYWN0b3IncyBzdG9yZWQgY29udGV4dC5cbiAqIHR5cGUgQ29udGV4dCA9IHtcbiAqICAgLy8gVGhlIGN1cnJlbnQgY291bnQuXG4gKiAgIGNvdW50OiBudW1iZXI7XG4gKiAgIC8vIFRoZSBhbW91bnQgdG8gaW5jcmVhc2UgYGNvdW50YCBieS5cbiAqICAgc3RlcDogbnVtYmVyO1xuICogfTtcbiAqIC8vIFRoZSBldmVudHMgdGhlIGFjdG9yIHJlY2VpdmVzLlxuICogdHlwZSBFdmVudCA9IHsgdHlwZTogJ2luY3JlbWVudCcgfTtcbiAqIC8vIFRoZSBhY3RvcidzIGlucHV0LlxuICogdHlwZSBJbnB1dCA9IHsgc3RlcD86IG51bWJlciB9O1xuICpcbiAqIC8vIEFjdG9yIGxvZ2ljIHRoYXQgaW5jcmVtZW50cyBgY291bnRgIGJ5IGBzdGVwYCB3aGVuIGl0IHJlY2VpdmVzIGFuIGV2ZW50IG9mXG4gKiAvLyB0eXBlIGBpbmNyZW1lbnRgLlxuICogY29uc3QgbG9naWMgPSBmcm9tVHJhbnNpdGlvbjxDb250ZXh0LCBFdmVudCwgQW55QWN0b3JTeXN0ZW0sIElucHV0PihcbiAqICAgKHN0YXRlLCBldmVudCwgYWN0b3JTY29wZSkgPT4ge1xuICogICAgIGFjdG9yU2NvcGUuc2VsZjtcbiAqICAgICAvLyAgICAgICAgIF4/IFRyYW5zaXRpb25BY3RvclJlZjxDb250ZXh0LCBFdmVudD5cbiAqXG4gKiAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdpbmNyZW1lbnQnKSB7XG4gKiAgICAgICByZXR1cm4ge1xuICogICAgICAgICAuLi5zdGF0ZSxcbiAqICAgICAgICAgY291bnQ6IHN0YXRlLmNvdW50ICsgc3RhdGUuc3RlcFxuICogICAgICAgfTtcbiAqICAgICB9XG4gKiAgICAgcmV0dXJuIHN0YXRlO1xuICogICB9LFxuICogICAoeyBpbnB1dCwgc2VsZiB9KSA9PiB7XG4gKiAgICAgc2VsZjtcbiAqICAgICAvLyBePyBUcmFuc2l0aW9uQWN0b3JSZWY8Q29udGV4dCwgRXZlbnQ+XG4gKlxuICogICAgIHJldHVybiB7XG4gKiAgICAgICBjb3VudDogMCxcbiAqICAgICAgIHN0ZXA6IGlucHV0LnN0ZXAgPz8gMVxuICogICAgIH07XG4gKiAgIH1cbiAqICk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihsb2dpYywgeyBpbnB1dDogeyBzdGVwOiAxMCB9IH0pO1xuICogLy8gICAgXj8gVHJhbnNpdGlvbkFjdG9yUmVmPENvbnRleHQsIEV2ZW50PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbVRyYW5zaXRpb259XG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGFjdG9yIGxvZ2ljIGdpdmVuIGEgdHJhbnNpdGlvbiBmdW5jdGlvbiBhbmQgaXRzIGluaXRpYWwgc3RhdGUuXG4gKlxuICogQSDigJx0cmFuc2l0aW9uIGZ1bmN0aW9u4oCdIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgY3VycmVudCBgc3RhdGVgIGFuZFxuICogcmVjZWl2ZWQgYGV2ZW50YCBvYmplY3QgYXMgYXJndW1lbnRzLCBhbmQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSwgc2ltaWxhciB0b1xuICogYSByZWR1Y2VyLlxuICpcbiAqIEFjdG9ycyBjcmVhdGVkIGZyb20gdHJhbnNpdGlvbiBsb2dpYyAo4oCcdHJhbnNpdGlvbiBhY3RvcnPigJ0pIGNhbjpcbiAqXG4gKiAtIFJlY2VpdmUgZXZlbnRzXG4gKiAtIEVtaXQgc25hcHNob3RzIG9mIGl0cyBzdGF0ZVxuICpcbiAqIFRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9u4oCZcyBgc3RhdGVgIGlzIHVzZWQgYXMgaXRzIHRyYW5zaXRpb24gYWN0b3LigJlzXG4gKiBgY29udGV4dGAuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBcInN0YXRlXCIgZm9yIGEgdHJhbnNpdGlvbiBmdW5jdGlvbiBpcyBwcm92aWRlZCBieSB0aGUgaW5pdGlhbFxuICogc3RhdGUgYXJndW1lbnQsIGFuZCBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIFN0YXRlIG9iamVjdCBvZiBhbiBhY3RvciBvciBhXG4gKiBzdGF0ZSB3aXRoaW4gYSBtYWNoaW5lIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgdHJhbnNpdGlvbkxvZ2ljID0gZnJvbVRyYW5zaXRpb24oXG4gKiAgIChzdGF0ZSwgZXZlbnQpID0+IHtcbiAqICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2luY3JlbWVudCcpIHtcbiAqICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgICBjb3VudDogc3RhdGUuY291bnQgKyAxXG4gKiAgICAgICB9O1xuICogICAgIH1cbiAqICAgICByZXR1cm4gc3RhdGU7XG4gKiAgIH0sXG4gKiAgIHsgY291bnQ6IDAgfVxuICogKTtcbiAqXG4gKiBjb25zdCB0cmFuc2l0aW9uQWN0b3IgPSBjcmVhdGVBY3Rvcih0cmFuc2l0aW9uTG9naWMpO1xuICogdHJhbnNpdGlvbkFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAqICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICogfSk7XG4gKiB0cmFuc2l0aW9uQWN0b3Iuc3RhcnQoKTtcbiAqIC8vID0+IHtcbiAqIC8vICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAqIC8vICAgY29udGV4dDogeyBjb3VudDogMCB9LFxuICogLy8gICAuLi5cbiAqIC8vIH1cbiAqXG4gKiB0cmFuc2l0aW9uQWN0b3Iuc2VuZCh7IHR5cGU6ICdpbmNyZW1lbnQnIH0pO1xuICogLy8gPT4ge1xuICogLy8gICBzdGF0dXM6ICdhY3RpdmUnLFxuICogLy8gICBjb250ZXh0OiB7IGNvdW50OiAxIH0sXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHRyYW5zaXRpb24gVGhlIHRyYW5zaXRpb24gZnVuY3Rpb24gdXNlZCB0byBkZXNjcmliZSB0aGUgdHJhbnNpdGlvblxuICogICBsb2dpYy4gSXQgc2hvdWxkIHJldHVybiB0aGUgbmV4dCBzdGF0ZSBnaXZlbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgZXZlbnQuXG4gKiAgIEl0IHJlY2VpdmVzIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxuICpcbiAqICAgLSBgc3RhdGVgIC0gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiAgIC0gYGV2ZW50YCAtIHRoZSByZWNlaXZlZCBldmVudC5cbiAqICAgLSBgYWN0b3JTY29wZWAgLSB0aGUgYWN0b3Igc2NvcGUgb2JqZWN0LCB3aXRoIHByb3BlcnRpZXMgbGlrZSBgc2VsZmAgYW5kXG4gKiAgICAgICBgc3lzdGVtYC5cbiAqXG4gKiBAcGFyYW0gaW5pdGlhbENvbnRleHQgVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHRyYW5zaXRpb24gZnVuY3Rpb24sIGVpdGhlciBhblxuICogICBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSwgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgc3RhdGUgb2JqZWN0LlxuICogICBJZiBhIGZ1bmN0aW9uLCBpdCB3aWxsIHJlY2VpdmUgYXMgaXRzIG9ubHkgYXJndW1lbnQgYW4gb2JqZWN0IHdpdGggdGhlXG4gKiAgIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gdGhlIGBpbnB1dGAgcHJvdmlkZWQgdG8gaXRzIHBhcmVudCB0cmFuc2l0aW9uIGFjdG9yLlxuICogICAtIGBzZWxmYCAtIGEgcmVmZXJlbmNlIHRvIGl0cyBwYXJlbnQgdHJhbnNpdGlvbiBhY3Rvci5cbiAqXG4gKiBAcmV0dXJucyBBY3RvciBsb2dpY1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvaW5wdXQgfCBJbnB1dCBkb2NzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgaW5wdXQgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGZyb21UcmFuc2l0aW9uKHRyYW5zaXRpb24sIGluaXRpYWxDb250ZXh0KSB7XG4gIHJldHVybiB7XG4gICAgY29uZmlnOiB0cmFuc2l0aW9uLFxuICAgIHRyYW5zaXRpb246IChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICBjb250ZXh0OiB0cmFuc2l0aW9uKHNuYXBzaG90LmNvbnRleHQsIGV2ZW50LCBhY3RvclNjb3BlKVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldEluaXRpYWxTbmFwc2hvdDogKF8sIGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgY29udGV4dDogdHlwZW9mIGluaXRpYWxDb250ZXh0ID09PSAnZnVuY3Rpb24nID8gaW5pdGlhbENvbnRleHQoe1xuICAgICAgICAgIGlucHV0XG4gICAgICAgIH0pIDogaW5pdGlhbENvbnRleHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3QsXG4gICAgcmVzdG9yZVNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdFxuICB9O1xufVxuXG5jb25zdCBpbnN0YW5jZVN0YXRlcyA9IC8qICNfX1BVUkVfXyAqL25ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhY3RvciBjcmVhdGVkIGJ5IGBmcm9tQ2FsbGJhY2tgLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbUNhbGxiYWNrLCBjcmVhdGVBY3RvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogLy8gVGhlIGV2ZW50cyB0aGUgYWN0b3IgcmVjZWl2ZXMuXG4gKiB0eXBlIEV2ZW50ID0geyB0eXBlOiAnc29tZUV2ZW50JyB9O1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBuYW1lOiBzdHJpbmcgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IGxvZ3Mgd2hlbmV2ZXIgaXQgcmVjZWl2ZXMgYW4gZXZlbnQgb2YgdHlwZSBgc29tZUV2ZW50YC5cbiAqIGNvbnN0IGxvZ2ljID0gZnJvbUNhbGxiYWNrPEV2ZW50LCBJbnB1dD4oKHsgc2VsZiwgaW5wdXQsIHJlY2VpdmUgfSkgPT4ge1xuICogICBzZWxmO1xuICogICAvLyBePyBDYWxsYmFja0FjdG9yUmVmPEV2ZW50LCBJbnB1dD5cbiAqXG4gKiAgIHJlY2VpdmUoKGV2ZW50KSA9PiB7XG4gKiAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdzb21lRXZlbnQnKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhgJHtpbnB1dC5uYW1lfTogcmVjZWl2ZWQgXCJzb21lRXZlbnRcIiBldmVudGApO1xuICogICAgICAgLy8gbG9ncyAnbXlBY3RvcjogcmVjZWl2ZWQgXCJzb21lRXZlbnRcIiBldmVudCdcbiAqICAgICB9XG4gKiAgIH0pO1xuICogfSk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihsb2dpYywgeyBpbnB1dDogeyBuYW1lOiAnbXlBY3RvcicgfSB9KTtcbiAqIC8vICAgIF4/IENhbGxiYWNrQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbUNhbGxiYWNrfVxuICovXG5cbi8qKlxuICogQW4gYWN0b3IgbG9naWMgY3JlYXRvciB3aGljaCByZXR1cm5zIGNhbGxiYWNrIGxvZ2ljIGFzIGRlZmluZWQgYnkgYSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIFVzZWZ1bCBmb3Igc3Vic2NyaXB0aW9uLWJhc2VkIG9yIG90aGVyIGZyZWUtZm9ybSBsb2dpYyB0aGF0IGNhbiBzZW5kIGV2ZW50c1xuICogYmFjayB0byB0aGUgcGFyZW50IGFjdG9yLlxuICpcbiAqIEFjdG9ycyBjcmVhdGVkIGZyb20gY2FsbGJhY2sgbG9naWMgKOKAnGNhbGxiYWNrIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gUmVjZWl2ZSBldmVudHMgdmlhIHRoZSBgcmVjZWl2ZWAgZnVuY3Rpb25cbiAqIC0gU2VuZCBldmVudHMgdG8gdGhlIHBhcmVudCBhY3RvciB2aWEgdGhlIGBzZW5kQmFja2AgZnVuY3Rpb25cbiAqXG4gKiBDYWxsYmFjayBhY3RvcnMgYXJlIGEgYml0IGRpZmZlcmVudCBmcm9tIG90aGVyIGFjdG9ycyBpbiB0aGF0IHRoZXk6XG4gKlxuICogLSBEbyBub3Qgd29yayB3aXRoIGBvbkRvbmVgXG4gKiAtIERvIG5vdCBwcm9kdWNlIGEgc25hcHNob3QgdXNpbmcgYC5nZXRTbmFwc2hvdCgpYFxuICogLSBEbyBub3QgZW1pdCB2YWx1ZXMgd2hlbiB1c2VkIHdpdGggYC5zdWJzY3JpYmUoKWBcbiAqIC0gQ2FuIG5vdCBiZSBzdG9wcGVkIHdpdGggYC5zdG9wKClgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBjYWxsYmFja0xvZ2ljID0gZnJvbUNhbGxiYWNrKCh7IHNlbmRCYWNrLCByZWNlaXZlIH0pID0+IHtcbiAqICAgbGV0IGxvY2tTdGF0dXMgPSAndW5sb2NrZWQnO1xuICpcbiAqICAgY29uc3QgaGFuZGxlciA9IChldmVudCkgPT4ge1xuICogICAgIGlmIChsb2NrU3RhdHVzID09PSAnbG9ja2VkJykge1xuICogICAgICAgcmV0dXJuO1xuICogICAgIH1cbiAqICAgICBzZW5kQmFjayhldmVudCk7XG4gKiAgIH07XG4gKlxuICogICByZWNlaXZlKChldmVudCkgPT4ge1xuICogICAgIGlmIChldmVudC50eXBlID09PSAnbG9jaycpIHtcbiAqICAgICAgIGxvY2tTdGF0dXMgPSAnbG9ja2VkJztcbiAqICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICd1bmxvY2snKSB7XG4gKiAgICAgICBsb2NrU3RhdHVzID0gJ3VubG9ja2VkJztcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICpcbiAqICAgcmV0dXJuICgpID0+IHtcbiAqICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gKiAgIH07XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB1c2VkIHRvIGRlc2NyaWJlIHRoZSBjYWxsYmFjayBsb2dpY1xuICogICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcGFzc2VkIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYHJlY2VpdmVgIC0gQSBmdW5jdGlvbiB0aGF0IGNhbiBzZW5kIGV2ZW50cyBiYWNrIHRvIHRoZSBwYXJlbnQgYWN0b3I7IHRoZVxuICogICAgICAgbGlzdGVuZXIgaXMgdGhlbiBjYWxsZWQgd2hlbmV2ZXIgZXZlbnRzIGFyZSByZWNlaXZlZCBieSB0aGUgY2FsbGJhY2tcbiAqICAgICAgIGFjdG9yXG4gKiAgIC0gYHNlbmRCYWNrYCAtIEEgZnVuY3Rpb24gdGhhdCBjYW4gc2VuZCBldmVudHMgYmFjayB0byB0aGUgcGFyZW50IGFjdG9yXG4gKiAgIC0gYGlucHV0YCAtIERhdGEgdGhhdCB3YXMgcHJvdmlkZWQgdG8gdGhlIGNhbGxiYWNrIGFjdG9yXG4gKiAgIC0gYHNlbGZgIC0gVGhlIHBhcmVudCBhY3RvciBvZiB0aGUgY2FsbGJhY2sgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIGNhbGxiYWNrIGFjdG9yIGJlbG9uZ3MgVGhlIGNhbGxiYWNrXG4gKiAgICAgICBmdW5jdGlvbiBjYW4gKG9wdGlvbmFsbHkpIHJldHVybiBhIGNsZWFudXAgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZFxuICogICAgICAgd2hlbiB0aGUgYWN0b3IgaXMgc3RvcHBlZC5cbiAqXG4gKiBAcmV0dXJucyBDYWxsYmFjayBsb2dpY1xuICogQHNlZSB7QGxpbmsgQ2FsbGJhY2tMb2dpY0Z1bmN0aW9ufSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIGl0cyBvYmplY3QgYXJndW1lbnRcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2lucHV0IHwgSW5wdXQgZG9jc30gZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgaG93IGlucHV0IGlzIHBhc3NlZFxuICovXG5mdW5jdGlvbiBmcm9tQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBjYWxsYmFjayxcbiAgICBzdGFydDogKHN0YXRlLCBhY3RvclNjb3BlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGYsXG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgZW1pdFxuICAgICAgfSA9IGFjdG9yU2NvcGU7XG4gICAgICBjb25zdCBjYWxsYmFja1N0YXRlID0ge1xuICAgICAgICByZWNlaXZlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgZGlzcG9zZTogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgaW5zdGFuY2VTdGF0ZXMuc2V0KHNlbGYsIGNhbGxiYWNrU3RhdGUpO1xuICAgICAgY2FsbGJhY2tTdGF0ZS5kaXNwb3NlID0gY2FsbGJhY2soe1xuICAgICAgICBpbnB1dDogc3RhdGUuaW5wdXQsXG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgc2VsZixcbiAgICAgICAgc2VuZEJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoc2VsZi5nZXRTbmFwc2hvdCgpLnN0YXR1cyA9PT0gJ3N0b3BwZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxmLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZi5fcGFyZW50LCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWNlaXZlOiBsaXN0ZW5lciA9PiB7XG4gICAgICAgICAgY2FsbGJhY2tTdGF0ZS5yZWNlaXZlcnMgPz89IG5ldyBTZXQoKTtcbiAgICAgICAgICBjYWxsYmFja1N0YXRlLnJlY2VpdmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICB9LFxuICAgICAgICBlbWl0XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRyYW5zaXRpb246IChzdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrU3RhdGUgPSBpbnN0YW5jZVN0YXRlcy5nZXQoYWN0b3JTY29wZS5zZWxmKTtcbiAgICAgIGlmIChldmVudC50eXBlID09PSBYU1RBVEVfU1RPUCkge1xuICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICBzdGF0dXM6ICdzdG9wcGVkJyxcbiAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGNhbGxiYWNrU3RhdGUuZGlzcG9zZT8uKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrU3RhdGUucmVjZWl2ZXJzPy5mb3JFYWNoKHJlY2VpdmVyID0+IHJlY2VpdmVyKGV2ZW50KSk7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBnZXRJbml0aWFsU25hcHNob3Q6IChfLCBpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0XG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90LFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3RcbiAgfTtcbiAgcmV0dXJuIGxvZ2ljO1xufVxuXG5jb25zdCBYU1RBVEVfT0JTRVJWQUJMRV9ORVhUID0gJ3hzdGF0ZS5vYnNlcnZhYmxlLm5leHQnO1xuY29uc3QgWFNUQVRFX09CU0VSVkFCTEVfRVJST1IgPSAneHN0YXRlLm9ic2VydmFibGUuZXJyb3InO1xuY29uc3QgWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEUgPSAneHN0YXRlLm9ic2VydmFibGUuY29tcGxldGUnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYWN0b3IgY3JlYXRlZCBieSBgZnJvbU9ic2VydmFibGVgIG9yIGBmcm9tRXZlbnRPYnNlcnZhYmxlYC5cbiAqXG4gKiBUaGUgdHlwZSBvZiBgc2VsZmAgd2l0aGluIHRoZSBhY3RvcidzIGxvZ2ljLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21PYnNlcnZhYmxlLCBjcmVhdGVBY3RvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyBpbnRlcnZhbCB9IGZyb20gJ3J4anMnO1xuICpcbiAqIC8vIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBvYnNlcnZlZCBieSB0aGUgYWN0b3IncyBsb2dpYy5cbiAqIHR5cGUgQ29udGV4dCA9IG51bWJlcjtcbiAqIC8vIFRoZSBhY3RvcidzIGlucHV0LlxuICogdHlwZSBJbnB1dCA9IHsgcGVyaW9kPzogbnVtYmVyIH07XG4gKlxuICogLy8gQWN0b3IgbG9naWMgdGhhdCBvYnNlcnZlcyBhIG51bWJlciBpbmNyZW1lbnRlZCBldmVyeSBgaW5wdXQucGVyaW9kYFxuICogLy8gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiAxXzAwMCkuXG4gKiBjb25zdCBsb2dpYyA9IGZyb21PYnNlcnZhYmxlPENvbnRleHQsIElucHV0PigoeyBpbnB1dCwgc2VsZiB9KSA9PiB7XG4gKiAgIHNlbGY7XG4gKiAgIC8vIF4/IE9ic2VydmFibGVBY3RvclJlZjxFdmVudCwgSW5wdXQ+XG4gKlxuICogICByZXR1cm4gaW50ZXJ2YWwoaW5wdXQucGVyaW9kID8/IDFfMDAwKTtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobG9naWMsIHsgaW5wdXQ6IHsgcGVyaW9kOiAyXzAwMCB9IH0pO1xuICogLy8gICAgXj8gT2JzZXJ2YWJsZUFjdG9yUmVmPEV2ZW50LCBJbnB1dD5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGZyb21PYnNlcnZhYmxlfVxuICogQHNlZSB7QGxpbmsgZnJvbUV2ZW50T2JzZXJ2YWJsZX1cbiAqL1xuXG4vKipcbiAqIE9ic2VydmFibGUgYWN0b3IgbG9naWMgaXMgZGVzY3JpYmVkIGJ5IGFuIG9ic2VydmFibGUgc3RyZWFtIG9mIHZhbHVlcy4gQWN0b3JzXG4gKiBjcmVhdGVkIGZyb20gb2JzZXJ2YWJsZSBsb2dpYyAo4oCcb2JzZXJ2YWJsZSBhY3RvcnPigJ0pIGNhbjpcbiAqXG4gKiAtIEVtaXQgc25hcHNob3RzIG9mIHRoZSBvYnNlcnZhYmxl4oCZcyBlbWl0dGVkIHZhbHVlXG4gKlxuICogVGhlIG9ic2VydmFibGXigJlzIGVtaXR0ZWQgdmFsdWUgaXMgdXNlZCBhcyBpdHMgb2JzZXJ2YWJsZSBhY3RvcuKAmXMgYGNvbnRleHRgLlxuICpcbiAqIFNlbmRpbmcgZXZlbnRzIHRvIG9ic2VydmFibGUgYWN0b3JzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbU9ic2VydmFibGUsIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqIGltcG9ydCB7IGludGVydmFsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgbG9naWMgPSBmcm9tT2JzZXJ2YWJsZSgob2JqKSA9PiBpbnRlcnZhbCgxMDAwKSk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihsb2dpYyk7XG4gKlxuICogYWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhzbmFwc2hvdC5jb250ZXh0KTtcbiAqIH0pO1xuICpcbiAqIGFjdG9yLnN0YXJ0KCk7XG4gKiAvLyBBdCBldmVyeSBzZWNvbmQ6XG4gKiAvLyBMb2dzIDBcbiAqIC8vIExvZ3MgMVxuICogLy8gTG9ncyAyXG4gKiAvLyAuLi5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvYnNlcnZhYmxlQ3JlYXRvciBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhbiBvYnNlcnZhYmxlLiBJdCByZWNlaXZlc1xuICogICBvbmUgYXJndW1lbnQsIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYGlucHV0YCAtIERhdGEgdGhhdCB3YXMgcHJvdmlkZWQgdG8gdGhlIG9ic2VydmFibGUgYWN0b3JcbiAqICAgLSBgc2VsZmAgLSBUaGUgcGFyZW50IGFjdG9yXG4gKiAgIC0gYHN5c3RlbWAgLSBUaGUgYWN0b3Igc3lzdGVtIHRvIHdoaWNoIHRoZSBvYnNlcnZhYmxlIGFjdG9yIGJlbG9uZ3NcbiAqXG4gKiAgIEl0IHNob3VsZCByZXR1cm4gYSB7QGxpbmsgU3Vic2NyaWJhYmxlfSwgd2hpY2ggaXMgY29tcGF0aWJsZSB3aXRoIGFuIFJ4SlNcbiAqICAgT2JzZXJ2YWJsZSwgYWx0aG91Z2ggUnhKUyBpcyBub3QgcmVxdWlyZWQgdG8gY3JlYXRlIHRoZW0uXG4gKiBAc2VlIHtAbGluayBodHRwczovL3J4anMuZGV2fSBmb3IgZG9jdW1lbnRhdGlvbiBvbiBSeEpTIE9ic2VydmFibGUgYW5kIG9ic2VydmFibGUgY3JlYXRvcnMuXG4gKiBAc2VlIHtAbGluayBTdWJzY3JpYmFibGV9IGludGVyZmFjZSBpbiBYU3RhdGUsIHdoaWNoIGlzIGJhc2VkIG9uIGFuZCBjb21wYXRpYmxlIHdpdGggUnhKUyBPYnNlcnZhYmxlLlxuICovXG5mdW5jdGlvbiBmcm9tT2JzZXJ2YWJsZShvYnNlcnZhYmxlQ3JlYXRvcikge1xuICAvLyBUT0RPOiBhZGQgZXZlbnQgdHlwZXNcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBvYnNlcnZhYmxlQ3JlYXRvcixcbiAgICB0cmFuc2l0aW9uOiAoc25hcHNob3QsIGV2ZW50KSA9PiB7XG4gICAgICBpZiAoc25hcHNob3Quc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9ORVhUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NuYXBzaG90ID0ge1xuICAgICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgICAgY29udGV4dDogZXZlbnQuZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXdTbmFwc2hvdDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgWFNUQVRFX09CU0VSVkFCTEVfRVJST1I6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgZXJyb3I6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURTpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9TVE9QOlxuICAgICAgICAgIHNuYXBzaG90Ll9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgICBzdGF0dXM6ICdzdG9wcGVkJyxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEluaXRpYWxTbmFwc2hvdDogKF8sIGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgY29udGV4dDogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhcnQ6IChzdGF0ZSwge1xuICAgICAgc2VsZixcbiAgICAgIHN5c3RlbSxcbiAgICAgIGVtaXRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoc3RhdGUuc3RhdHVzID09PSAnZG9uZScpIHtcbiAgICAgICAgLy8gRG8gbm90IHJlc3RhcnQgYSBjb21wbGV0ZWQgb2JzZXJ2YWJsZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdGF0ZS5fc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZUNyZWF0b3Ioe1xuICAgICAgICBpbnB1dDogc3RhdGUuaW5wdXQsXG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgc2VsZixcbiAgICAgICAgZW1pdFxuICAgICAgfSkuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogdmFsdWUgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfTkVYVCxcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBlcnIgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfRVJST1IsXG4gICAgICAgICAgICBkYXRhOiBlcnJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICAgIHR5cGU6IFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6ICh7XG4gICAgICBfc3Vic2NyaXB0aW9uLFxuICAgICAgLi4uc3RhdGVcbiAgICB9KSA9PiBzdGF0ZSxcbiAgICByZXN0b3JlU25hcHNob3Q6IHN0YXRlID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgIH0pXG4gIH07XG4gIHJldHVybiBsb2dpYztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGV2ZW50IG9ic2VydmFibGUgbG9naWMgdGhhdCBsaXN0ZW5zIHRvIGFuIG9ic2VydmFibGUgdGhhdCBkZWxpdmVyc1xuICogZXZlbnQgb2JqZWN0cy5cbiAqXG4gKiBFdmVudCBvYnNlcnZhYmxlIGFjdG9yIGxvZ2ljIGlzIGRlc2NyaWJlZCBieSBhbiBvYnNlcnZhYmxlIHN0cmVhbSBvZlxuICoge0BsaW5rIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL3RyYW5zaXRpb25zI2V2ZW50LW9iamVjdHMgfCBldmVudCBvYmplY3RzfS5cbiAqIEFjdG9ycyBjcmVhdGVkIGZyb20gZXZlbnQgb2JzZXJ2YWJsZSBsb2dpYyAo4oCcZXZlbnQgb2JzZXJ2YWJsZSBhY3RvcnPigJ0pIGNhbjpcbiAqXG4gKiAtIEltcGxpY2l0bHkgc2VuZCBldmVudHMgdG8gaXRzIHBhcmVudCBhY3RvclxuICogLSBFbWl0IHNuYXBzaG90cyBvZiBpdHMgZW1pdHRlZCBldmVudCBvYmplY3RzXG4gKlxuICogU2VuZGluZyBldmVudHMgdG8gZXZlbnQgb2JzZXJ2YWJsZSBhY3RvcnMgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge1xuICogICBmcm9tRXZlbnRPYnNlcnZhYmxlLFxuICogICBTdWJzY3JpYmFibGUsXG4gKiAgIEV2ZW50T2JqZWN0LFxuICogICBjcmVhdGVNYWNoaW5lLFxuICogICBjcmVhdGVBY3RvclxuICogfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcyc7XG4gKlxuICogY29uc3QgbW91c2VDbGlja0xvZ2ljID0gZnJvbUV2ZW50T2JzZXJ2YWJsZShcbiAqICAgKCkgPT4gZnJvbUV2ZW50KGRvY3VtZW50LmJvZHksICdjbGljaycpIGFzIFN1YnNjcmliYWJsZTxFdmVudE9iamVjdD5cbiAqICk7XG4gKlxuICogY29uc3QgY2FudmFzTWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICBpbnZva2U6IHtcbiAqICAgICAvLyBXaWxsIHNlbmQgbW91c2UgYGNsaWNrYCBldmVudHMgdG8gdGhlIGNhbnZhcyBhY3RvclxuICogICAgIHNyYzogbW91c2VDbGlja0xvZ2ljXG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNhbnZhc0FjdG9yID0gY3JlYXRlQWN0b3IoY2FudmFzTWFjaGluZSk7XG4gKiBjYW52YXNBY3Rvci5zdGFydCgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGxhenlPYnNlcnZhYmxlIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIG9ic2VydmFibGUgdGhhdCBkZWxpdmVyc1xuICogICBldmVudCBvYmplY3RzLiBJdCByZWNlaXZlcyBvbmUgYXJndW1lbnQsIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqICAgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYGlucHV0YCAtIERhdGEgdGhhdCB3YXMgcHJvdmlkZWQgdG8gdGhlIGV2ZW50IG9ic2VydmFibGUgYWN0b3JcbiAqICAgLSBgc2VsZmAgLSBUaGUgcGFyZW50IGFjdG9yXG4gKiAgIC0gYHN5c3RlbWAgLSBUaGUgYWN0b3Igc3lzdGVtIHRvIHdoaWNoIHRoZSBldmVudCBvYnNlcnZhYmxlIGFjdG9yIGJlbG9uZ3MuXG4gKlxuICogICBJdCBzaG91bGQgcmV0dXJuIGEge0BsaW5rIFN1YnNjcmliYWJsZX0sIHdoaWNoIGlzIGNvbXBhdGlibGUgd2l0aCBhbiBSeEpTXG4gKiAgIE9ic2VydmFibGUsIGFsdGhvdWdoIFJ4SlMgaXMgbm90IHJlcXVpcmVkIHRvIGNyZWF0ZSB0aGVtLlxuICovXG5mdW5jdGlvbiBmcm9tRXZlbnRPYnNlcnZhYmxlKGxhenlPYnNlcnZhYmxlKSB7XG4gIC8vIFRPRE86IGV2ZW50IHR5cGVzXG4gIGNvbnN0IGxvZ2ljID0ge1xuICAgIGNvbmZpZzogbGF6eU9ic2VydmFibGUsXG4gICAgdHJhbnNpdGlvbjogKHN0YXRlLCBldmVudCkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgWFNUQVRFX09CU0VSVkFCTEVfRVJST1I6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgZXJyb3I6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURTpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9TVE9QOlxuICAgICAgICAgIHN0YXRlLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBzdGF0dXM6ICdzdG9wcGVkJyxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEluaXRpYWxTbmFwc2hvdDogKF8sIGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgY29udGV4dDogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhcnQ6IChzdGF0ZSwge1xuICAgICAgc2VsZixcbiAgICAgIHN5c3RlbSxcbiAgICAgIGVtaXRcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoc3RhdGUuc3RhdHVzID09PSAnZG9uZScpIHtcbiAgICAgICAgLy8gRG8gbm90IHJlc3RhcnQgYSBjb21wbGV0ZWQgb2JzZXJ2YWJsZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdGF0ZS5fc3Vic2NyaXB0aW9uID0gbGF6eU9ic2VydmFibGUoe1xuICAgICAgICBpbnB1dDogc3RhdGUuaW5wdXQsXG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgc2VsZixcbiAgICAgICAgZW1pdFxuICAgICAgfSkuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogdmFsdWUgPT4ge1xuICAgICAgICAgIGlmIChzZWxmLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZi5fcGFyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZXJyID0+IHtcbiAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICAgIHR5cGU6IFhTVEFURV9PQlNFUlZBQkxFX0VSUk9SLFxuICAgICAgICAgICAgZGF0YTogZXJyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiAoe1xuICAgICAgX3N1YnNjcmlwdGlvbixcbiAgICAgIC4uLnNuYXBzaG90XG4gICAgfSkgPT4gc25hcHNob3QsXG4gICAgcmVzdG9yZVNuYXBzaG90OiBzbmFwc2hvdCA9PiAoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICB9KVxuICB9O1xuICByZXR1cm4gbG9naWM7XG59XG5cbmNvbnN0IFhTVEFURV9QUk9NSVNFX1JFU09MVkUgPSAneHN0YXRlLnByb21pc2UucmVzb2x2ZSc7XG5jb25zdCBYU1RBVEVfUFJPTUlTRV9SRUpFQ1QgPSAneHN0YXRlLnByb21pc2UucmVqZWN0JztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFjdG9yIGNyZWF0ZWQgYnkgYGZyb21Qcm9taXNlYC5cbiAqXG4gKiBUaGUgdHlwZSBvZiBgc2VsZmAgd2l0aGluIHRoZSBhY3RvcidzIGxvZ2ljLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGZyb21Qcm9taXNlLCBjcmVhdGVBY3RvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogLy8gVGhlIGFjdG9yJ3MgcmVzb2x2ZWQgb3V0cHV0XG4gKiB0eXBlIE91dHB1dCA9IHN0cmluZztcbiAqIC8vIFRoZSBhY3RvcidzIGlucHV0LlxuICogdHlwZSBJbnB1dCA9IHsgbWVzc2FnZTogc3RyaW5nIH07XG4gKlxuICogLy8gQWN0b3IgbG9naWMgdGhhdCBmZXRjaGVzIHRoZSB1cmwgb2YgYW4gaW1hZ2Ugb2YgYSBjYXQgc2F5aW5nIGBpbnB1dC5tZXNzYWdlYC5cbiAqIGNvbnN0IGxvZ2ljID0gZnJvbVByb21pc2U8T3V0cHV0LCBJbnB1dD4oYXN5bmMgKHsgaW5wdXQsIHNlbGYgfSkgPT4ge1xuICogICBzZWxmO1xuICogICAvLyBePyBQcm9taXNlQWN0b3JSZWY8T3V0cHV0LCBJbnB1dD5cbiAqXG4gKiAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaChcbiAqICAgICBgaHR0cHM6Ly9jYXRhYXMuY29tL2NhdC9zYXlzLyR7aW5wdXQubWVzc2FnZX1gXG4gKiAgICk7XG4gKiAgIGNvbnN0IHVybCA9IGF3YWl0IGRhdGEuanNvbigpO1xuICogICByZXR1cm4gdXJsO1xuICogfSk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihsb2dpYywgeyBpbnB1dDogeyBtZXNzYWdlOiAnaGVsbG8gd29ybGQnIH0gfSk7XG4gKiAvLyAgICBePyBQcm9taXNlQWN0b3JSZWY8T3V0cHV0LCBJbnB1dD5cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIGZyb21Qcm9taXNlfVxuICovXG5cbmNvbnN0IGNvbnRyb2xsZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEFuIGFjdG9yIGxvZ2ljIGNyZWF0b3Igd2hpY2ggcmV0dXJucyBwcm9taXNlIGxvZ2ljIGFzIGRlZmluZWQgYnkgYW4gYXN5bmNcbiAqIHByb2Nlc3MgdGhhdCByZXNvbHZlcyBvciByZWplY3RzIGFmdGVyIHNvbWUgdGltZS5cbiAqXG4gKiBBY3RvcnMgY3JlYXRlZCBmcm9tIHByb21pc2UgYWN0b3IgbG9naWMgKOKAnHByb21pc2UgYWN0b3Jz4oCdKSBjYW46XG4gKlxuICogLSBFbWl0IHRoZSByZXNvbHZlZCB2YWx1ZSBvZiB0aGUgcHJvbWlzZVxuICogLSBPdXRwdXQgdGhlIHJlc29sdmVkIHZhbHVlIG9mIHRoZSBwcm9taXNlXG4gKlxuICogU2VuZGluZyBldmVudHMgdG8gcHJvbWlzZSBhY3RvcnMgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBwcm9taXNlTG9naWMgPSBmcm9tUHJvbWlzZShhc3luYyAoKSA9PiB7XG4gKiAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoKCdodHRwczovL2V4YW1wbGUuY29tLy4uLicpLnRoZW4oKGRhdGEpID0+XG4gKiAgICAgZGF0YS5qc29uKClcbiAqICAgKTtcbiAqXG4gKiAgIHJldHVybiByZXN1bHQ7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBwcm9taXNlQWN0b3IgPSBjcmVhdGVBY3Rvcihwcm9taXNlTG9naWMpO1xuICogcHJvbWlzZUFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAqICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICogfSk7XG4gKiBwcm9taXNlQWN0b3Iuc3RhcnQoKTtcbiAqIC8vID0+IHtcbiAqIC8vICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gKiAvLyAgIHN0YXR1czogJ2FjdGl2ZSdcbiAqIC8vICAgLi4uXG4gKiAvLyB9XG4gKlxuICogLy8gQWZ0ZXIgcHJvbWlzZSByZXNvbHZlc1xuICogLy8gPT4ge1xuICogLy8gICBvdXRwdXQ6IHsgLi4uIH0sXG4gKiAvLyAgIHN0YXR1czogJ2RvbmUnLFxuICogLy8gICAuLi5cbiAqIC8vIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwcm9taXNlQ3JlYXRvciBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBQcm9taXNlLCBhbmQgYWNjZXB0cyBhblxuICogICBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBpbnB1dGAgLSBEYXRhIHRoYXQgd2FzIHByb3ZpZGVkIHRvIHRoZSBwcm9taXNlIGFjdG9yXG4gKiAgIC0gYHNlbGZgIC0gVGhlIHBhcmVudCBhY3RvciBvZiB0aGUgcHJvbWlzZSBhY3RvclxuICogICAtIGBzeXN0ZW1gIC0gVGhlIGFjdG9yIHN5c3RlbSB0byB3aGljaCB0aGUgcHJvbWlzZSBhY3RvciBiZWxvbmdzXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvaW5wdXQgfCBJbnB1dCBkb2NzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgaW5wdXQgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGZyb21Qcm9taXNlKHByb21pc2VDcmVhdG9yKSB7XG4gIGNvbnN0IGxvZ2ljID0ge1xuICAgIGNvbmZpZzogcHJvbWlzZUNyZWF0b3IsXG4gICAgdHJhbnNpdGlvbjogKHN0YXRlLCBldmVudCwgc2NvcGUpID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFhTVEFURV9QUk9NSVNFX1JFU09MVkU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnZG9uZScsXG4gICAgICAgICAgICAgIG91dHB1dDogcmVzb2x2ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgWFNUQVRFX1BST01JU0VfUkVKRUNUOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICAgIGVycm9yOiBldmVudC5kYXRhLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX1NUT1A6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29udHJvbGxlck1hcC5nZXQoc2NvcGUuc2VsZik/LmFib3J0KCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgICAgc3RhdHVzOiAnc3RvcHBlZCcsXG4gICAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0YXJ0OiAoc3RhdGUsIHtcbiAgICAgIHNlbGYsXG4gICAgICBzeXN0ZW0sXG4gICAgICBlbWl0XG4gICAgfSkgPT4ge1xuICAgICAgLy8gVE9ETzogZGV0ZXJtaW5lIGhvdyB0byBhbGxvdyBjdXN0b21pemluZyB0aGlzIHNvIHRoYXQgcHJvbWlzZXNcbiAgICAgIC8vIGNhbiBiZSByZXN0YXJ0ZWQgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29udHJvbGxlck1hcC5zZXQoc2VsZiwgY29udHJvbGxlcik7XG4gICAgICBjb25zdCByZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHJvbWlzZUNyZWF0b3Ioe1xuICAgICAgICBpbnB1dDogc3RhdGUuaW5wdXQsXG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgc2VsZixcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgZW1pdFxuICAgICAgfSkpO1xuICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICBpZiAoc2VsZi5nZXRTbmFwc2hvdCgpLnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlck1hcC5kZWxldGUoc2VsZik7XG4gICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgIHR5cGU6IFhTVEFURV9QUk9NSVNFX1JFU09MVkUsXG4gICAgICAgICAgZGF0YTogcmVzcG9uc2VcbiAgICAgICAgfSk7XG4gICAgICB9LCBlcnJvckRhdGEgPT4ge1xuICAgICAgICBpZiAoc2VsZi5nZXRTbmFwc2hvdCgpLnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlck1hcC5kZWxldGUoc2VsZik7XG4gICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgIHR5cGU6IFhTVEFURV9QUk9NSVNFX1JFSkVDVCxcbiAgICAgICAgICBkYXRhOiBlcnJvckRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldEluaXRpYWxTbmFwc2hvdDogKF8sIGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXRcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3QsXG4gICAgcmVzdG9yZVNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdFxuICB9O1xuICByZXR1cm4gbG9naWM7XG59XG5cbmNvbnN0IGVtcHR5TG9naWMgPSBmcm9tVHJhbnNpdGlvbihfID0+IHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5QWN0b3IoKSB7XG4gIHJldHVybiBjcmVhdGVBY3RvcihlbXB0eUxvZ2ljKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRW1wdHlBY3RvciwgZnJvbUNhbGxiYWNrLCBmcm9tRXZlbnRPYnNlcnZhYmxlLCBmcm9tT2JzZXJ2YWJsZSwgZnJvbVByb21pc2UsIGZyb21UcmFuc2l0aW9uIH07XG4iXSwibmFtZXMiOlsiWCIsIlhTVEFURV9TVE9QIiwiQSIsImNyZWF0ZUFjdG9yIiwiZnJvbVRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uIiwiaW5pdGlhbENvbnRleHQiLCJjb25maWciLCJzbmFwc2hvdCIsImV2ZW50IiwiYWN0b3JTY29wZSIsImNvbnRleHQiLCJnZXRJbml0aWFsU25hcHNob3QiLCJfIiwiaW5wdXQiLCJzdGF0dXMiLCJvdXRwdXQiLCJ1bmRlZmluZWQiLCJlcnJvciIsImdldFBlcnNpc3RlZFNuYXBzaG90IiwicmVzdG9yZVNuYXBzaG90IiwiaW5zdGFuY2VTdGF0ZXMiLCJXZWFrTWFwIiwiZnJvbUNhbGxiYWNrIiwiY2FsbGJhY2siLCJsb2dpYyIsInN0YXJ0Iiwic3RhdGUiLCJzZWxmIiwic3lzdGVtIiwiZW1pdCIsImNhbGxiYWNrU3RhdGUiLCJyZWNlaXZlcnMiLCJkaXNwb3NlIiwic2V0Iiwic2VuZEJhY2siLCJnZXRTbmFwc2hvdCIsIl9wYXJlbnQiLCJfcmVsYXkiLCJyZWNlaXZlIiwibGlzdGVuZXIiLCJTZXQiLCJhZGQiLCJnZXQiLCJ0eXBlIiwiZm9yRWFjaCIsInJlY2VpdmVyIiwiWFNUQVRFX09CU0VSVkFCTEVfTkVYVCIsIlhTVEFURV9PQlNFUlZBQkxFX0VSUk9SIiwiWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEUiLCJmcm9tT2JzZXJ2YWJsZSIsIm9ic2VydmFibGVDcmVhdG9yIiwibmV3U25hcHNob3QiLCJkYXRhIiwiX3N1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlIiwic3Vic2NyaWJlIiwibmV4dCIsInZhbHVlIiwiZXJyIiwiY29tcGxldGUiLCJmcm9tRXZlbnRPYnNlcnZhYmxlIiwibGF6eU9ic2VydmFibGUiLCJYU1RBVEVfUFJPTUlTRV9SRVNPTFZFIiwiWFNUQVRFX1BST01JU0VfUkVKRUNUIiwiY29udHJvbGxlck1hcCIsImZyb21Qcm9taXNlIiwicHJvbWlzZUNyZWF0b3IiLCJzY29wZSIsInJlc29sdmVkVmFsdWUiLCJhYm9ydCIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJyZXNvbHZlZFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNpZ25hbCIsInRoZW4iLCJyZXNwb25zZSIsImRlbGV0ZSIsImVycm9yRGF0YSIsImVtcHR5TG9naWMiLCJjcmVhdGVFbXB0eUFjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dev/dist/xstate-dev.development.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devToolsAdapter: () => (/* binding */ devToolsAdapter),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   registerService: () => (/* binding */ registerService)\n/* harmony export */ });\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal() {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (false) {}\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    {\n        console.warn(\"XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues\");\n    }\n}\nfunction getDevTools() {\n    const w = getGlobal();\n    if (w.__xstate__) {\n        return w.__xstate__;\n    }\n    return undefined;\n}\nfunction registerService(service) {\n    if (true) {\n        return;\n    }\n    const devTools = getDevTools();\n    if (devTools) {\n        devTools.register(service);\n    }\n}\nconst devToolsAdapter = (service)=>{\n    if (true) {\n        return;\n    }\n    const devTools = getDevTools();\n    if (devTools) {\n        devTools.register(service);\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1HQUFtRztBQUNuRyxTQUFTQTtJQUNQLElBQUksT0FBT0MsZUFBZSxhQUFhO1FBQ3JDLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLE9BQU9DLFNBQVMsYUFBYTtRQUMvQixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxLQUFrQixFQUFhLEVBRWxDO0lBQ0QsSUFBSSxPQUFPRSxXQUFXLGFBQWE7UUFDakMsT0FBT0E7SUFDVDtJQUNBO1FBQ0VDLFFBQVFDLElBQUksQ0FBQztJQUNmO0FBQ0Y7QUFDQSxTQUFTQztJQUNQLE1BQU1DLElBQUlSO0lBQ1YsSUFBSVEsRUFBRUMsVUFBVSxFQUFFO1FBQ2hCLE9BQU9ELEVBQUVDLFVBQVU7SUFDckI7SUFDQSxPQUFPQztBQUNUO0FBQ0EsU0FBU0MsZ0JBQWdCQyxPQUFPO0lBQzlCLElBQUksSUFBa0IsRUFBYTtRQUNqQztJQUNGO0lBQ0EsTUFBTUMsV0FBV047SUFDakIsSUFBSU0sVUFBVTtRQUNaQSxTQUFTQyxRQUFRLENBQUNGO0lBQ3BCO0FBQ0Y7QUFDQSxNQUFNRyxrQkFBa0JILENBQUFBO0lBQ3RCLElBQUksSUFBa0IsRUFBYTtRQUNqQztJQUNGO0lBQ0EsTUFBTUMsV0FBV047SUFDakIsSUFBSU0sVUFBVTtRQUNaQSxTQUFTQyxRQUFRLENBQUNGO0lBQ3BCO0FBQ0Y7QUFFdUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanM/NGZmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL2dsb2JhbFRoaXNcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBnbG9iYWw7XG4gIH1cbiAge1xuICAgIGNvbnNvbGUud2FybignWFN0YXRlIGNvdWxkIG5vdCBmaW5kIGEgZ2xvYmFsIG9iamVjdCBpbiB0aGlzIGVudmlyb25tZW50LiBQbGVhc2UgbGV0IHRoZSBtYWludGFpbmVycyBrbm93IGFuZCByYWlzZSBhbiBpc3N1ZSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vc3RhdGVseWFpL3hzdGF0ZS9pc3N1ZXMnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGV2VG9vbHMoKSB7XG4gIGNvbnN0IHcgPSBnZXRHbG9iYWwoKTtcbiAgaWYgKHcuX194c3RhdGVfXykge1xuICAgIHJldHVybiB3Ll9feHN0YXRlX187XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU2VydmljZShzZXJ2aWNlKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZXZUb29scyA9IGdldERldlRvb2xzKCk7XG4gIGlmIChkZXZUb29scykge1xuICAgIGRldlRvb2xzLnJlZ2lzdGVyKHNlcnZpY2UpO1xuICB9XG59XG5jb25zdCBkZXZUb29sc0FkYXB0ZXIgPSBzZXJ2aWNlID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRldlRvb2xzID0gZ2V0RGV2VG9vbHMoKTtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZGV2VG9vbHMucmVnaXN0ZXIoc2VydmljZSk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGRldlRvb2xzQWRhcHRlciwgZ2V0R2xvYmFsLCByZWdpc3RlclNlcnZpY2UgfTtcbiJdLCJuYW1lcyI6WyJnZXRHbG9iYWwiLCJnbG9iYWxUaGlzIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0RGV2VG9vbHMiLCJ3IiwiX194c3RhdGVfXyIsInVuZGVmaW5lZCIsInJlZ2lzdGVyU2VydmljZSIsInNlcnZpY2UiLCJkZXZUb29scyIsInJlZ2lzdGVyIiwiZGV2VG9vbHNBZGFwdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/log-0acd9069.development.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/xstate/dist/log-0acd9069.development.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ SpecialTargets),\n/* harmony export */   a: () => (/* binding */ assign),\n/* harmony export */   b: () => (/* binding */ enqueueActions),\n/* harmony export */   c: () => (/* binding */ sendTo),\n/* harmony export */   e: () => (/* binding */ emit),\n/* harmony export */   f: () => (/* binding */ forwardTo),\n/* harmony export */   l: () => (/* binding */ log),\n/* harmony export */   s: () => (/* binding */ sendParent)\n/* harmony export */ });\n/* harmony import */ var _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-1db27a82.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n\nfunction createSpawner(actorScope, { machine, context }, event, spawnedChildren) {\n    const spawn = (src, options)=>{\n        if (typeof src === \"string\") {\n            const logic = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)(machine, src);\n            if (!logic) {\n                throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n            }\n            const actorRef = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(logic, {\n                id: options?.id,\n                parent: actorScope.self,\n                syncSnapshot: options?.syncSnapshot,\n                input: typeof options?.input === \"function\" ? options.input({\n                    context,\n                    event,\n                    self: actorScope.self\n                }) : options?.input,\n                src,\n                systemId: options?.systemId\n            });\n            spawnedChildren[actorRef.id] = actorRef;\n            return actorRef;\n        } else {\n            const actorRef = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(src, {\n                id: options?.id,\n                parent: actorScope.self,\n                syncSnapshot: options?.syncSnapshot,\n                input: options?.input,\n                src,\n                systemId: options?.systemId\n            });\n            return actorRef;\n        }\n    };\n    return (src, options)=>{\n        const actorRef = spawn(src, options); // TODO: fix types\n        spawnedChildren[actorRef.id] = actorRef;\n        actorScope.defer(()=>{\n            if (actorRef._processingStatus === _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T.Stopped) {\n                return;\n            }\n            actorRef.start();\n        });\n        return actorRef;\n    };\n}\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, { assignment }) {\n    if (!snapshot.context) {\n        throw new Error(\"Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.\");\n    }\n    const spawnedChildren = {};\n    const assignArgs = {\n        context: snapshot.context,\n        event: actionArgs.event,\n        spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n        self: actorScope.self,\n        system: actorScope.system\n    };\n    let partialUpdate = {};\n    if (typeof assignment === \"function\") {\n        partialUpdate = assignment(assignArgs, actionParams);\n    } else {\n        for (const key of Object.keys(assignment)){\n            const propAssignment = assignment[key];\n            partialUpdate[key] = typeof propAssignment === \"function\" ? propAssignment(assignArgs, actionParams) : propAssignment;\n        }\n    }\n    const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n    return [\n        (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U)(snapshot, {\n            context: updatedContext,\n            children: Object.keys(spawnedChildren).length ? {\n                ...snapshot.children,\n                ...spawnedChildren\n            } : snapshot.children\n        }),\n        undefined,\n        undefined\n    ];\n}\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */ function assign(assignment) {\n    if (_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n        console.warn(\"Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function assign(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    assign.type = \"xstate.assign\";\n    assign.assignment = assignment;\n    assign.resolve = resolveAssign;\n    return assign;\n}\nfunction resolveEmit(_, snapshot, args, actionParams, { event: eventOrExpr }) {\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    return [\n        snapshot,\n        {\n            event: resolvedEvent\n        },\n        undefined\n    ];\n}\nfunction executeEmit(actorScope, { event }) {\n    actorScope.defer(()=>actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event,\n * handler)`.\n *\n * @example\n *\n * ```ts\n * import { emit } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     something: {\n *       actions: emit({\n *         type: 'emitted',\n *         some: 'data'\n *       })\n *     }\n *   }\n *   // ...\n * });\n *\n * const actor = createActor(machine).start();\n *\n * actor.on('emitted', (event) => {\n *   console.log(event);\n * });\n *\n * actor.send({ type: 'something' });\n * // logs:\n * // {\n * //   type: 'emitted',\n * //   some: 'data'\n * // }\n * ```\n */ function emit(/** The event to emit, or an expression that returns an event to emit. */ eventOrExpr) {\n    if (_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n        console.warn(\"Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function emit(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    emit.type = \"xstate.emit\";\n    emit.event = eventOrExpr;\n    emit.resolve = resolveEmit;\n    emit.execute = executeEmit;\n    return emit;\n}\n/**\n * @remarks\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\n * to contextual typing. It especially is a problem when the union has a\n * function member, like here:\n *\n * ```ts\n * declare function test(\n *   cbOrVal: ((arg: number) => unknown) | unknown\n * ): void;\n * test((arg) => {}); // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same\n * value space as `unknown`.\n */ // https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n// @TODO: Replace with native `NoInfer` when TS issue gets fixed:\n// https://github.com/microsoft/TypeScript/pull/57673\n/** @deprecated Use the built-in `NoInfer` type instead */ /** The full definition of an event, with a string `type`. */ /**\n * The string or object representing the state value relative to the parent\n * state node.\n *\n * @remarks\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success:\n *   \"someChildState\" }`.\n */ /** @deprecated Use `AnyMachineSnapshot` instead */ // TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */ let SpecialTargets = /*#__PURE__*/ function(SpecialTargets) {\n    SpecialTargets[\"Parent\"] = \"#_parent\";\n    SpecialTargets[\"Internal\"] = \"#_internal\";\n    return SpecialTargets;\n}({});\n/** @deprecated Use `AnyActor` instead. */ // Based on RxJS types\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\n/** @deprecated Use `Actor<T>` instead. */ /**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */ /** @deprecated */ // TODO: cover all that can be actually returned\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, { to, event: eventOrExpr, id, delay }, extra) {\n    const delaysMap = snapshot.machine.implementations.delays;\n    if (typeof eventOrExpr === \"string\") {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\n    }\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    let resolvedDelay;\n    if (typeof delay === \"string\") {\n        const configDelay = delaysMap && delaysMap[delay];\n        resolvedDelay = typeof configDelay === \"function\" ? configDelay(args, actionParams) : configDelay;\n    } else {\n        resolvedDelay = typeof delay === \"function\" ? delay(args, actionParams) : delay;\n    }\n    const resolvedTarget = typeof to === \"function\" ? to(args, actionParams) : to;\n    let targetActorRef;\n    if (typeof resolvedTarget === \"string\") {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (resolvedTarget === SpecialTargets.Parent) {\n            targetActorRef = actorScope.self._parent;\n        } else if (resolvedTarget === SpecialTargets.Internal) {\n            targetActorRef = actorScope.self;\n        } else if (resolvedTarget.startsWith(\"#_\")) {\n            // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n            // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n            targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n        } else {\n            targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n        }\n        if (!targetActorRef) {\n            throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\n        }\n    } else {\n        targetActorRef = resolvedTarget || actorScope.self;\n    }\n    return [\n        snapshot,\n        {\n            to: targetActorRef,\n            targetId: typeof resolvedTarget === \"string\" ? resolvedTarget : undefined,\n            event: resolvedEvent,\n            id,\n            delay: resolvedDelay\n        },\n        undefined\n    ];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n    if (typeof params.to === \"string\") {\n        params.to = snapshot.children[params.to];\n    }\n}\nfunction executeSendTo(actorScope, params) {\n    // this forms an outgoing events queue\n    // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n    actorScope.defer(()=>{\n        const { to, event, delay, id } = params;\n        if (typeof delay === \"number\") {\n            actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n            return;\n        }\n        actorScope.system._relay(actorScope.self, // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n        // if it initially started as a string\n        to, event.type === _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.W ? (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Y)(actorScope.self.id, event.data) : event);\n    });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event\n *   to send\n * @param options Send action options\n *\n *   - `id` - The unique send event identifier (used with `cancel()`).\n *   - `delay` - The number of milliseconds to delay the sending of the event.\n */ function sendTo(to, eventOrExpr, options) {\n    if (_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n        console.warn(\"Custom actions should not call `sendTo()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function sendTo(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    sendTo.type = \"xstate.sendTo\";\n    sendTo.to = to;\n    sendTo.event = eventOrExpr;\n    sendTo.id = options?.id;\n    sendTo.delay = options?.delay;\n    sendTo.resolve = resolveSendTo;\n    sendTo.retryResolve = retryResolveSendTo;\n    sendTo.execute = executeSendTo;\n    return sendTo;\n}\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */ function sendParent(event, options) {\n    return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */ function forwardTo(target, options) {\n    if (!target || typeof target === \"function\") {\n        const originalTarget = target;\n        target = (...args)=>{\n            const resolvedTarget = typeof originalTarget === \"function\" ? originalTarget(...args) : originalTarget;\n            if (!resolvedTarget) {\n                throw new Error(`Attempted to forward event to undefined actor. This risks an infinite loop in the sender.`);\n            }\n            return resolvedTarget;\n        };\n    }\n    return sendTo(target, ({ event })=>event, options);\n}\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, { collect }) {\n    const actions = [];\n    const enqueue = function enqueue(action) {\n        actions.push(action);\n    };\n    enqueue.assign = (...args)=>{\n        actions.push(assign(...args));\n    };\n    enqueue.cancel = (...args)=>{\n        actions.push((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.M)(...args));\n    };\n    enqueue.raise = (...args)=>{\n        // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n        // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n        actions.push((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.O)(...args));\n    };\n    enqueue.sendTo = (...args)=>{\n        // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n        // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n        actions.push(sendTo(...args));\n    };\n    enqueue.sendParent = (...args)=>{\n        actions.push(sendParent(...args));\n    };\n    enqueue.spawnChild = (...args)=>{\n        actions.push((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.P)(...args));\n    };\n    enqueue.stopChild = (...args)=>{\n        actions.push((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.R)(...args));\n    };\n    enqueue.emit = (...args)=>{\n        actions.push(emit(...args));\n    };\n    collect({\n        context: args.context,\n        event: args.event,\n        enqueue,\n        check: (guard)=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(guard, snapshot.context, args.event, snapshot),\n        self: actorScope.self,\n        system: actorScope.system\n    }, actionParams);\n    return [\n        snapshot,\n        undefined,\n        actions\n    ];\n}\n/**\n * Creates an action object that will execute actions that are queued by the\n * `enqueue(action)` function.\n *\n * @example\n *\n * ```ts\n * import { createMachine, enqueueActions } from 'xstate';\n *\n * const machine = createMachine({\n *   entry: enqueueActions(({ enqueue, check }) => {\n *     enqueue.assign({ count: 0 });\n *\n *     if (check('someGuard')) {\n *       enqueue.assign({ count: 1 });\n *     }\n *\n *     enqueue('someAction');\n *   })\n * });\n * ```\n */ function enqueueActions(collect) {\n    function enqueueActions(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    enqueueActions.type = \"xstate.enqueueActions\";\n    enqueueActions.collect = collect;\n    enqueueActions.resolve = resolveEnqueueActions;\n    return enqueueActions;\n}\nfunction resolveLog(_, snapshot, actionArgs, actionParams, { value, label }) {\n    return [\n        snapshot,\n        {\n            value: typeof value === \"function\" ? value(actionArgs, actionParams) : value,\n            label\n        },\n        undefined\n    ];\n}\nfunction executeLog({ logger }, { value, label }) {\n    if (label) {\n        logger(label, value);\n    } else {\n        logger(value);\n    }\n}\n/**\n * @param expr The expression function to evaluate which will be logged. Takes\n *   in 2 arguments:\n *\n *   - `ctx` - the current state context\n *   - `event` - the event that caused this action to be executed.\n *\n * @param label The label to give to the logged expression.\n */ function log(value = ({ context, event })=>({\n        context,\n        event\n    }), label) {\n    function log(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    log.type = \"xstate.log\";\n    log.value = value;\n    log.label = label;\n    log.resolve = resolveLog;\n    log.execute = executeLog;\n    return log;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvbG9nLTBhY2Q5MDY5LmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBK1M7QUFFL1MsU0FBU3dCLGNBQWNDLFVBQVUsRUFBRSxFQUNqQ0MsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsRUFBRUMsS0FBSyxFQUFFQyxlQUFlO0lBQ3ZCLE1BQU1DLFFBQVEsQ0FBQ0MsS0FBS0M7UUFDbEIsSUFBSSxPQUFPRCxRQUFRLFVBQVU7WUFDM0IsTUFBTUUsUUFBUTlCLHFFQUFzQkEsQ0FBQ3VCLFNBQVNLO1lBQzlDLElBQUksQ0FBQ0UsT0FBTztnQkFDVixNQUFNLElBQUlDLE1BQU0sQ0FBQyxhQUFhLEVBQUVILElBQUksOEJBQThCLEVBQUVMLFFBQVFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbkY7WUFDQSxNQUFNQyxXQUFXL0IscUVBQVdBLENBQUM0QixPQUFPO2dCQUNsQ0UsSUFBSUgsU0FBU0c7Z0JBQ2JFLFFBQVFaLFdBQVdhLElBQUk7Z0JBQ3ZCQyxjQUFjUCxTQUFTTztnQkFDdkJDLE9BQU8sT0FBT1IsU0FBU1EsVUFBVSxhQUFhUixRQUFRUSxLQUFLLENBQUM7b0JBQzFEYjtvQkFDQUM7b0JBQ0FVLE1BQU1iLFdBQVdhLElBQUk7Z0JBQ3ZCLEtBQUtOLFNBQVNRO2dCQUNkVDtnQkFDQVUsVUFBVVQsU0FBU1M7WUFDckI7WUFDQVosZUFBZSxDQUFDTyxTQUFTRCxFQUFFLENBQUMsR0FBR0M7WUFDL0IsT0FBT0E7UUFDVCxPQUFPO1lBQ0wsTUFBTUEsV0FBVy9CLHFFQUFXQSxDQUFDMEIsS0FBSztnQkFDaENJLElBQUlILFNBQVNHO2dCQUNiRSxRQUFRWixXQUFXYSxJQUFJO2dCQUN2QkMsY0FBY1AsU0FBU087Z0JBQ3ZCQyxPQUFPUixTQUFTUTtnQkFDaEJUO2dCQUNBVSxVQUFVVCxTQUFTUztZQUNyQjtZQUNBLE9BQU9MO1FBQ1Q7SUFDRjtJQUNBLE9BQU8sQ0FBQ0wsS0FB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TyxHQUFHOEM7SUFDZCxPQUFPRTtBQUNUO0FBRW9JIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvbG9nLTBhY2Q5MDY5LmRldmVsb3BtZW50LmVzbS5qcz9hZTE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFQgYXMgUHJvY2Vzc2luZ1N0YXR1cywgeiBhcyByZXNvbHZlUmVmZXJlbmNlZEFjdG9yLCBBIGFzIGNyZWF0ZUFjdG9yLCBVIGFzIGNsb25lTWFjaGluZVNuYXBzaG90LCBWIGFzIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiwgVyBhcyBYU1RBVEVfRVJST1IsIFkgYXMgY3JlYXRlRXJyb3JBY3RvckV2ZW50LCBlIGFzIGV2YWx1YXRlR3VhcmQsIE0gYXMgY2FuY2VsLCBPIGFzIHJhaXNlLCBQIGFzIHNwYXduQ2hpbGQsIFIgYXMgc3RvcENoaWxkIH0gZnJvbSAnLi9yYWlzZS0xZGIyN2E4Mi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVTcGF3bmVyKGFjdG9yU2NvcGUsIHtcbiAgbWFjaGluZSxcbiAgY29udGV4dFxufSwgZXZlbnQsIHNwYXduZWRDaGlsZHJlbikge1xuICBjb25zdCBzcGF3biA9IChzcmMsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGxvZ2ljID0gcmVzb2x2ZVJlZmVyZW5jZWRBY3RvcihtYWNoaW5lLCBzcmMpO1xuICAgICAgaWYgKCFsb2dpYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdG9yIGxvZ2ljICcke3NyY30nIG5vdCBpbXBsZW1lbnRlZCBpbiBtYWNoaW5lICcke21hY2hpbmUuaWR9J2ApO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0b3JSZWYgPSBjcmVhdGVBY3Rvcihsb2dpYywge1xuICAgICAgICBpZDogb3B0aW9ucz8uaWQsXG4gICAgICAgIHBhcmVudDogYWN0b3JTY29wZS5zZWxmLFxuICAgICAgICBzeW5jU25hcHNob3Q6IG9wdGlvbnM/LnN5bmNTbmFwc2hvdCxcbiAgICAgICAgaW5wdXQ6IHR5cGVvZiBvcHRpb25zPy5pbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuaW5wdXQoe1xuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgc2VsZjogYWN0b3JTY29wZS5zZWxmXG4gICAgICAgIH0pIDogb3B0aW9ucz8uaW5wdXQsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWQ6IG9wdGlvbnM/LnN5c3RlbUlkXG4gICAgICB9KTtcbiAgICAgIHNwYXduZWRDaGlsZHJlblthY3RvclJlZi5pZF0gPSBhY3RvclJlZjtcbiAgICAgIHJldHVybiBhY3RvclJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWN0b3JSZWYgPSBjcmVhdGVBY3RvcihzcmMsIHtcbiAgICAgICAgaWQ6IG9wdGlvbnM/LmlkLFxuICAgICAgICBwYXJlbnQ6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgICAgc3luY1NuYXBzaG90OiBvcHRpb25zPy5zeW5jU25hcHNob3QsXG4gICAgICAgIGlucHV0OiBvcHRpb25zPy5pbnB1dCxcbiAgICAgICAgc3JjLFxuICAgICAgICBzeXN0ZW1JZDogb3B0aW9ucz8uc3lzdGVtSWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjdG9yUmVmO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIChzcmMsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBhY3RvclJlZiA9IHNwYXduKHNyYywgb3B0aW9ucyk7IC8vIFRPRE86IGZpeCB0eXBlc1xuICAgIHNwYXduZWRDaGlsZHJlblthY3RvclJlZi5pZF0gPSBhY3RvclJlZjtcbiAgICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICAgIGlmIChhY3RvclJlZi5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFjdG9yUmVmLnN0YXJ0KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjdG9yUmVmO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQXNzaWduKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgYXNzaWdubWVudFxufSkge1xuICBpZiAoIXNuYXBzaG90LmNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhc3NpZ24gdG8gdW5kZWZpbmVkIGBjb250ZXh0YC4gRW5zdXJlIHRoYXQgYGNvbnRleHRgIGlzIGRlZmluZWQgaW4gdGhlIG1hY2hpbmUgY29uZmlnLicpO1xuICB9XG4gIGNvbnN0IHNwYXduZWRDaGlsZHJlbiA9IHt9O1xuICBjb25zdCBhc3NpZ25BcmdzID0ge1xuICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgZXZlbnQ6IGFjdGlvbkFyZ3MuZXZlbnQsXG4gICAgc3Bhd246IGNyZWF0ZVNwYXduZXIoYWN0b3JTY29wZSwgc25hcHNob3QsIGFjdGlvbkFyZ3MuZXZlbnQsIHNwYXduZWRDaGlsZHJlbiksXG4gICAgc2VsZjogYWN0b3JTY29wZS5zZWxmLFxuICAgIHN5c3RlbTogYWN0b3JTY29wZS5zeXN0ZW1cbiAgfTtcbiAgbGV0IHBhcnRpYWxVcGRhdGUgPSB7fTtcbiAgaWYgKHR5cGVvZiBhc3NpZ25tZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcGFydGlhbFVwZGF0ZSA9IGFzc2lnbm1lbnQoYXNzaWduQXJncywgYWN0aW9uUGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhhc3NpZ25tZW50KSkge1xuICAgICAgY29uc3QgcHJvcEFzc2lnbm1lbnQgPSBhc3NpZ25tZW50W2tleV07XG4gICAgICBwYXJ0aWFsVXBkYXRlW2tleV0gPSB0eXBlb2YgcHJvcEFzc2lnbm1lbnQgPT09ICdmdW5jdGlvbicgPyBwcm9wQXNzaWdubWVudChhc3NpZ25BcmdzLCBhY3Rpb25QYXJhbXMpIDogcHJvcEFzc2lnbm1lbnQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IHVwZGF0ZWRDb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgc25hcHNob3QuY29udGV4dCwgcGFydGlhbFVwZGF0ZSk7XG4gIHJldHVybiBbY2xvbmVNYWNoaW5lU25hcHNob3Qoc25hcHNob3QsIHtcbiAgICBjb250ZXh0OiB1cGRhdGVkQ29udGV4dCxcbiAgICBjaGlsZHJlbjogT2JqZWN0LmtleXMoc3Bhd25lZENoaWxkcmVuKS5sZW5ndGggPyB7XG4gICAgICAuLi5zbmFwc2hvdC5jaGlsZHJlbixcbiAgICAgIC4uLnNwYXduZWRDaGlsZHJlblxuICAgIH0gOiBzbmFwc2hvdC5jaGlsZHJlblxuICB9KSwgdW5kZWZpbmVkLCB1bmRlZmluZWRdO1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIG1hY2hpbmUuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlTWFjaGluZSwgYXNzaWduIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBjb3VudE1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgY29udGV4dDoge1xuICogICAgIGNvdW50OiAwLFxuICogICAgIG1lc3NhZ2U6ICcnXG4gKiAgIH0sXG4gKiAgIG9uOiB7XG4gKiAgICAgaW5jOiB7XG4gKiAgICAgICBhY3Rpb25zOiBhc3NpZ24oe1xuICogICAgICAgICBjb3VudDogKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LmNvdW50ICsgMVxuICogICAgICAgfSlcbiAqICAgICB9LFxuICogICAgIHVwZGF0ZU1lc3NhZ2U6IHtcbiAqICAgICAgIGFjdGlvbnM6IGFzc2lnbigoeyBjb250ZXh0LCBldmVudCB9KSA9PiB7XG4gKiAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAgbWVzc2FnZTogZXZlbnQubWVzc2FnZS50cmltKClcbiAqICAgICAgICAgfTtcbiAqICAgICAgIH0pXG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhc3NpZ25tZW50IEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhcnRpYWwgY29udGV4dCB0byB1cGRhdGUsIG9yXG4gKiAgIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhcnRpYWwgY29udGV4dCB0b1xuICogICB1cGRhdGUuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbihhc3NpZ25tZW50KSB7XG4gIGlmIChleGVjdXRpbmdDdXN0b21BY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBhY3Rpb25zIHNob3VsZCBub3QgY2FsbCBgYXNzaWduKClgIGRpcmVjdGx5LCBhcyBpdCBpcyBub3QgaW1wZXJhdGl2ZS4gU2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2FjdGlvbnMjYnVpbHQtaW4tYWN0aW9ucyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2lnbihfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgYXNzaWduLnR5cGUgPSAneHN0YXRlLmFzc2lnbic7XG4gIGFzc2lnbi5hc3NpZ25tZW50ID0gYXNzaWdubWVudDtcbiAgYXNzaWduLnJlc29sdmUgPSByZXNvbHZlQXNzaWduO1xuICByZXR1cm4gYXNzaWduO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRW1pdChfLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGV2ZW50OiBldmVudE9yRXhwclxufSkge1xuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgZXZlbnQ6IHJlc29sdmVkRXZlbnRcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVFbWl0KGFjdG9yU2NvcGUsIHtcbiAgZXZlbnRcbn0pIHtcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiBhY3RvclNjb3BlLmVtaXQoZXZlbnQpKTtcbn1cbi8qKlxuICogRW1pdHMgYW4gZXZlbnQgdG8gZXZlbnQgaGFuZGxlcnMgcmVnaXN0ZXJlZCBvbiB0aGUgYWN0b3IgdmlhIGBhY3Rvci5vbihldmVudCxcbiAqIGhhbmRsZXIpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBlbWl0IH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIC8vIC4uLlxuICogICBvbjoge1xuICogICAgIHNvbWV0aGluZzoge1xuICogICAgICAgYWN0aW9uczogZW1pdCh7XG4gKiAgICAgICAgIHR5cGU6ICdlbWl0dGVkJyxcbiAqICAgICAgICAgc29tZTogJ2RhdGEnXG4gKiAgICAgICB9KVxuICogICAgIH1cbiAqICAgfVxuICogICAvLyAuLi5cbiAqIH0pO1xuICpcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3IobWFjaGluZSkuc3RhcnQoKTtcbiAqXG4gKiBhY3Rvci5vbignZW1pdHRlZCcsIChldmVudCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhldmVudCk7XG4gKiB9KTtcbiAqXG4gKiBhY3Rvci5zZW5kKHsgdHlwZTogJ3NvbWV0aGluZycgfSk7XG4gKiAvLyBsb2dzOlxuICogLy8ge1xuICogLy8gICB0eXBlOiAnZW1pdHRlZCcsXG4gKiAvLyAgIHNvbWU6ICdkYXRhJ1xuICogLy8gfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGVtaXQoLyoqIFRoZSBldmVudCB0byBlbWl0LCBvciBhbiBleHByZXNzaW9uIHRoYXQgcmV0dXJucyBhbiBldmVudCB0byBlbWl0LiAqL1xuZXZlbnRPckV4cHIpIHtcbiAgaWYgKGV4ZWN1dGluZ0N1c3RvbUFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIGFjdGlvbnMgc2hvdWxkIG5vdCBjYWxsIGBlbWl0KClgIGRpcmVjdGx5LCBhcyBpdCBpcyBub3QgaW1wZXJhdGl2ZS4gU2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2FjdGlvbnMjYnVpbHQtaW4tYWN0aW9ucyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICB9XG4gIGZ1bmN0aW9uIGVtaXQoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGVtaXQudHlwZSA9ICd4c3RhdGUuZW1pdCc7XG4gIGVtaXQuZXZlbnQgPSBldmVudE9yRXhwcjtcbiAgZW1pdC5yZXNvbHZlID0gcmVzb2x2ZUVtaXQ7XG4gIGVtaXQuZXhlY3V0ZSA9IGV4ZWN1dGVFbWl0O1xuICByZXR1cm4gZW1pdDtcbn1cblxuLyoqXG4gKiBAcmVtYXJrc1xuICogYFQgfCB1bmtub3duYCByZWR1Y2VzIHRvIGB1bmtub3duYCBhbmQgdGhhdCBjYW4gYmUgcHJvYmxlbWF0aWMgd2hlbiBpdCBjb21lc1xuICogdG8gY29udGV4dHVhbCB0eXBpbmcuIEl0IGVzcGVjaWFsbHkgaXMgYSBwcm9ibGVtIHdoZW4gdGhlIHVuaW9uIGhhcyBhXG4gKiBmdW5jdGlvbiBtZW1iZXIsIGxpa2UgaGVyZTpcbiAqXG4gKiBgYGB0c1xuICogZGVjbGFyZSBmdW5jdGlvbiB0ZXN0KFxuICogICBjYk9yVmFsOiAoKGFyZzogbnVtYmVyKSA9PiB1bmtub3duKSB8IHVua25vd25cbiAqICk6IHZvaWQ7XG4gKiB0ZXN0KChhcmcpID0+IHt9KTsgLy8gb29wcywgaW1wbGljaXQgYW55XG4gKiBgYGBcbiAqXG4gKiBUaGlzIHR5cGUgY2FuIGJlIHVzZWQgdG8gYXZvaWQgdGhpcyBwcm9ibGVtLiBUaGlzIHVuaW9uIHJlcHJlc2VudHMgdGhlIHNhbWVcbiAqIHZhbHVlIHNwYWNlIGFzIGB1bmtub3duYC5cbiAqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzIzMTgyI2lzc3VlY29tbWVudC0zNzkwOTE4ODdcblxuLy8gQFRPRE86IFJlcGxhY2Ugd2l0aCBuYXRpdmUgYE5vSW5mZXJgIHdoZW4gVFMgaXNzdWUgZ2V0cyBmaXhlZDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9wdWxsLzU3NjczXG5cbi8qKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGJ1aWx0LWluIGBOb0luZmVyYCB0eXBlIGluc3RlYWQgKi9cblxuLyoqIFRoZSBmdWxsIGRlZmluaXRpb24gb2YgYW4gZXZlbnQsIHdpdGggYSBzdHJpbmcgYHR5cGVgLiAqL1xuXG4vKipcbiAqIFRoZSBzdHJpbmcgb3Igb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3RhdGUgdmFsdWUgcmVsYXRpdmUgdG8gdGhlIHBhcmVudFxuICogc3RhdGUgbm9kZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogLSBGb3IgYSBjaGlsZCBhdG9taWMgc3RhdGUgbm9kZSwgdGhpcyBpcyBhIHN0cmluZywgZS5nLiwgYFwicGVuZGluZ1wiYC5cbiAqIC0gRm9yIGNvbXBsZXggc3RhdGUgbm9kZXMsIHRoaXMgaXMgYW4gb2JqZWN0LCBlLmcuLCBgeyBzdWNjZXNzOlxuICogICBcInNvbWVDaGlsZFN0YXRlXCIgfWAuXG4gKi9cblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgQW55TWFjaGluZVNuYXBzaG90YCBpbnN0ZWFkICovXG5cbi8vIFRPRE86IHBvc3NpYmx5IHJlZmFjdG9yIHRoaXMgc29tZWhvdywgdXNlIGV2ZW4gYSBzaW1wbGVyIHR5cGUsIGFuZCBtYXliZSBldmVuIG1ha2UgYG1hY2hpbmUub3B0aW9uc2AgcHJpdmF0ZSBvciBzb21ldGhpbmdcbi8qKiBAaWdub3JlICovXG5cbmxldCBTcGVjaWFsVGFyZ2V0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoU3BlY2lhbFRhcmdldHMpIHtcbiAgU3BlY2lhbFRhcmdldHNbXCJQYXJlbnRcIl0gPSBcIiNfcGFyZW50XCI7XG4gIFNwZWNpYWxUYXJnZXRzW1wiSW50ZXJuYWxcIl0gPSBcIiNfaW50ZXJuYWxcIjtcbiAgcmV0dXJuIFNwZWNpYWxUYXJnZXRzO1xufSh7fSk7XG5cbi8qKiBAZGVwcmVjYXRlZCBVc2UgYEFueUFjdG9yYCBpbnN0ZWFkLiAqL1xuXG4vLyBCYXNlZCBvbiBSeEpTIHR5cGVzXG5cbi8vIFRPRE86IGluIHY2LCB0aGlzIHNob3VsZCBvbmx5IGFjY2VwdCBBbnlBY3RvckxvZ2ljLCBsaWtlIEFjdG9yUmVmRnJvbUxvZ2ljXG5cbi8qKiBAZGVwcmVjYXRlZCBVc2UgYEFjdG9yPFQ+YCBpbnN0ZWFkLiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgbG9naWMgd2hpY2ggY2FuIGJlIHVzZWQgYnkgYW4gYWN0b3IuXG4gKlxuICogQHRlbXBsYXRlIFRTbmFwc2hvdCAtIFRoZSB0eXBlIG9mIHRoZSBzbmFwc2hvdC5cbiAqIEB0ZW1wbGF0ZSBURXZlbnQgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgb2JqZWN0LlxuICogQHRlbXBsYXRlIFRJbnB1dCAtIFRoZSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqIEB0ZW1wbGF0ZSBUU3lzdGVtIC0gVGhlIHR5cGUgb2YgdGhlIGFjdG9yIHN5c3RlbS5cbiAqL1xuXG4vKiogQGRlcHJlY2F0ZWQgKi9cblxuLy8gVE9ETzogY292ZXIgYWxsIHRoYXQgY2FuIGJlIGFjdHVhbGx5IHJldHVybmVkXG5cbmZ1bmN0aW9uIHJlc29sdmVTZW5kVG8oYWN0b3JTY29wZSwgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICB0byxcbiAgZXZlbnQ6IGV2ZW50T3JFeHByLFxuICBpZCxcbiAgZGVsYXlcbn0sIGV4dHJhKSB7XG4gIGNvbnN0IGRlbGF5c01hcCA9IHNuYXBzaG90Lm1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmRlbGF5cztcbiAgaWYgKHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9uc1xuICAgIGBPbmx5IGV2ZW50IG9iamVjdHMgbWF5IGJlIHVzZWQgd2l0aCBzZW5kVG87IHVzZSBzZW5kVG8oeyB0eXBlOiBcIiR7ZXZlbnRPckV4cHJ9XCIgfSkgaW5zdGVhZGApO1xuICB9XG4gIGNvbnN0IHJlc29sdmVkRXZlbnQgPSB0eXBlb2YgZXZlbnRPckV4cHIgPT09ICdmdW5jdGlvbicgPyBldmVudE9yRXhwcihhcmdzLCBhY3Rpb25QYXJhbXMpIDogZXZlbnRPckV4cHI7XG4gIGxldCByZXNvbHZlZERlbGF5O1xuICBpZiAodHlwZW9mIGRlbGF5ID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNvbmZpZ0RlbGF5ID0gZGVsYXlzTWFwICYmIGRlbGF5c01hcFtkZWxheV07XG4gICAgcmVzb2x2ZWREZWxheSA9IHR5cGVvZiBjb25maWdEZWxheSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbmZpZ0RlbGF5KGFyZ3MsIGFjdGlvblBhcmFtcykgOiBjb25maWdEZWxheTtcbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlZERlbGF5ID0gdHlwZW9mIGRlbGF5ID09PSAnZnVuY3Rpb24nID8gZGVsYXkoYXJncywgYWN0aW9uUGFyYW1zKSA6IGRlbGF5O1xuICB9XG4gIGNvbnN0IHJlc29sdmVkVGFyZ2V0ID0gdHlwZW9mIHRvID09PSAnZnVuY3Rpb24nID8gdG8oYXJncywgYWN0aW9uUGFyYW1zKSA6IHRvO1xuICBsZXQgdGFyZ2V0QWN0b3JSZWY7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZWRUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZW51bS1jb21wYXJpc29uXG4gICAgaWYgKHJlc29sdmVkVGFyZ2V0ID09PSBTcGVjaWFsVGFyZ2V0cy5QYXJlbnQpIHtcbiAgICAgIHRhcmdldEFjdG9yUmVmID0gYWN0b3JTY29wZS5zZWxmLl9wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgIGVsc2UgaWYgKHJlc29sdmVkVGFyZ2V0ID09PSBTcGVjaWFsVGFyZ2V0cy5JbnRlcm5hbCkge1xuICAgICAgdGFyZ2V0QWN0b3JSZWYgPSBhY3RvclNjb3BlLnNlbGY7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZFRhcmdldC5zdGFydHNXaXRoKCcjXycpKSB7XG4gICAgICAvLyBTQ1hNTCBjb21wYXRpYmlsaXR5OiBodHRwczovL3d3dy53My5vcmcvVFIvc2N4bWwvI1NDWE1MRXZlbnRQcm9jZXNzb3JcbiAgICAgIC8vICNfaW52b2tlaWQuIElmIHRoZSB0YXJnZXQgaXMgdGhlIHNwZWNpYWwgdGVybSAnI19pbnZva2VpZCcsIHdoZXJlIGludm9rZWlkIGlzIHRoZSBpbnZva2VpZCBvZiBhbiBTQ1hNTCBzZXNzaW9uIHRoYXQgdGhlIHNlbmRpbmcgc2Vzc2lvbiBoYXMgY3JlYXRlZCBieSA8aW52b2tlPiwgdGhlIFByb2Nlc3NvciBtdXN0IGFkZCB0aGUgZXZlbnQgdG8gdGhlIGV4dGVybmFsIHF1ZXVlIG9mIHRoYXQgc2Vzc2lvbi5cbiAgICAgIHRhcmdldEFjdG9yUmVmID0gc25hcHNob3QuY2hpbGRyZW5bcmVzb2x2ZWRUYXJnZXQuc2xpY2UoMildO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRBY3RvclJlZiA9IGV4dHJhLmRlZmVycmVkQWN0b3JJZHM/LmluY2x1ZGVzKHJlc29sdmVkVGFyZ2V0KSA/IHJlc29sdmVkVGFyZ2V0IDogc25hcHNob3QuY2hpbGRyZW5bcmVzb2x2ZWRUYXJnZXRdO1xuICAgIH1cbiAgICBpZiAoIXRhcmdldEFjdG9yUmVmKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBzZW5kIGV2ZW50IHRvIGFjdG9yICcke3Jlc29sdmVkVGFyZ2V0fScgZnJvbSBtYWNoaW5lICcke3NuYXBzaG90Lm1hY2hpbmUuaWR9Jy5gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0QWN0b3JSZWYgPSByZXNvbHZlZFRhcmdldCB8fCBhY3RvclNjb3BlLnNlbGY7XG4gIH1cbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIHRvOiB0YXJnZXRBY3RvclJlZixcbiAgICB0YXJnZXRJZDogdHlwZW9mIHJlc29sdmVkVGFyZ2V0ID09PSAnc3RyaW5nJyA/IHJlc29sdmVkVGFyZ2V0IDogdW5kZWZpbmVkLFxuICAgIGV2ZW50OiByZXNvbHZlZEV2ZW50LFxuICAgIGlkLFxuICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiByZXRyeVJlc29sdmVTZW5kVG8oXywgc25hcHNob3QsIHBhcmFtcykge1xuICBpZiAodHlwZW9mIHBhcmFtcy50byA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXJhbXMudG8gPSBzbmFwc2hvdC5jaGlsZHJlbltwYXJhbXMudG9dO1xuICB9XG59XG5mdW5jdGlvbiBleGVjdXRlU2VuZFRvKGFjdG9yU2NvcGUsIHBhcmFtcykge1xuICAvLyB0aGlzIGZvcm1zIGFuIG91dGdvaW5nIGV2ZW50cyBxdWV1ZVxuICAvLyB0aGFua3MgdG8gdGhhdCB0aGUgcmVjaXBpZW50IGFjdG9ycyBhcmUgYWJsZSB0byByZWFkIHRoZSAqdXBkYXRlZCogc25hcHNob3QgdmFsdWUgb2YgdGhlIHNlbmRlclxuICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0byxcbiAgICAgIGV2ZW50LFxuICAgICAgZGVsYXksXG4gICAgICBpZFxuICAgIH0gPSBwYXJhbXM7XG4gICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjdG9yU2NvcGUuc3lzdGVtLnNjaGVkdWxlci5zY2hlZHVsZShhY3RvclNjb3BlLnNlbGYsIHRvLCBldmVudCwgZGVsYXksIGlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYWN0b3JTY29wZS5zeXN0ZW0uX3JlbGF5KGFjdG9yU2NvcGUuc2VsZixcbiAgICAvLyBhdCB0aGlzIHBvaW50LCBpbiBhIGRlZmVycmVkIHRhc2ssIGl0IHNob3VsZCBhbHJlYWR5IGJlIG11dGF0ZWQgYnkgcmV0cnlSZXNvbHZlU2VuZFRvXG4gICAgLy8gaWYgaXQgaW5pdGlhbGx5IHN0YXJ0ZWQgYXMgYSBzdHJpbmdcbiAgICB0bywgZXZlbnQudHlwZSA9PT0gWFNUQVRFX0VSUk9SID8gY3JlYXRlRXJyb3JBY3RvckV2ZW50KGFjdG9yU2NvcGUuc2VsZi5pZCwgZXZlbnQuZGF0YSkgOiBldmVudCk7XG4gIH0pO1xufVxuLyoqXG4gKiBTZW5kcyBhbiBldmVudCB0byBhbiBhY3Rvci5cbiAqXG4gKiBAcGFyYW0gYWN0b3IgVGhlIGBBY3RvclJlZmAgdG8gc2VuZCB0aGUgZXZlbnQgdG8uXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmQsIG9yIGFuIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gdGhlIGV2ZW50XG4gKiAgIHRvIHNlbmRcbiAqIEBwYXJhbSBvcHRpb25zIFNlbmQgYWN0aW9uIG9wdGlvbnNcbiAqXG4gKiAgIC0gYGlkYCAtIFRoZSB1bmlxdWUgc2VuZCBldmVudCBpZGVudGlmaWVyICh1c2VkIHdpdGggYGNhbmNlbCgpYCkuXG4gKiAgIC0gYGRlbGF5YCAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IHRoZSBzZW5kaW5nIG9mIHRoZSBldmVudC5cbiAqL1xuZnVuY3Rpb24gc2VuZFRvKHRvLCBldmVudE9yRXhwciwgb3B0aW9ucykge1xuICBpZiAoZXhlY3V0aW5nQ3VzdG9tQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gYWN0aW9ucyBzaG91bGQgbm90IGNhbGwgYHNlbmRUbygpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiBzZW5kVG8oX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIHNlbmRUby50eXBlID0gJ3hzdGF0ZS5zZW5kVG8nO1xuICBzZW5kVG8udG8gPSB0bztcbiAgc2VuZFRvLmV2ZW50ID0gZXZlbnRPckV4cHI7XG4gIHNlbmRUby5pZCA9IG9wdGlvbnM/LmlkO1xuICBzZW5kVG8uZGVsYXkgPSBvcHRpb25zPy5kZWxheTtcbiAgc2VuZFRvLnJlc29sdmUgPSByZXNvbHZlU2VuZFRvO1xuICBzZW5kVG8ucmV0cnlSZXNvbHZlID0gcmV0cnlSZXNvbHZlU2VuZFRvO1xuICBzZW5kVG8uZXhlY3V0ZSA9IGV4ZWN1dGVTZW5kVG87XG4gIHJldHVybiBzZW5kVG87XG59XG5cbi8qKlxuICogU2VuZHMgYW4gZXZlbnQgdG8gdGhpcyBtYWNoaW5lJ3MgcGFyZW50LlxuICpcbiAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gc2VuZCB0byB0aGUgcGFyZW50IG1hY2hpbmUuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgaW50byB0aGUgc2VuZCBldmVudC5cbiAqL1xuZnVuY3Rpb24gc2VuZFBhcmVudChldmVudCwgb3B0aW9ucykge1xuICByZXR1cm4gc2VuZFRvKFNwZWNpYWxUYXJnZXRzLlBhcmVudCwgZXZlbnQsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBGb3J3YXJkcyAoc2VuZHMpIGFuIGV2ZW50IHRvIHRoZSBgdGFyZ2V0YCBhY3Rvci5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgYWN0b3IgdG8gZm9yd2FyZCB0aGUgZXZlbnQgdG8uXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgaW50byB0aGUgc2VuZCBhY3Rpb24gY3JlYXRvci5cbiAqL1xuZnVuY3Rpb24gZm9yd2FyZFRvKHRhcmdldCwgb3B0aW9ucykge1xuICBpZiAoKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjb25zdCBvcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcbiAgICB0YXJnZXQgPSAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWRUYXJnZXQgPSB0eXBlb2Ygb3JpZ2luYWxUYXJnZXQgPT09ICdmdW5jdGlvbicgPyBvcmlnaW5hbFRhcmdldCguLi5hcmdzKSA6IG9yaWdpbmFsVGFyZ2V0O1xuICAgICAgaWYgKCFyZXNvbHZlZFRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBmb3J3YXJkIGV2ZW50IHRvIHVuZGVmaW5lZCBhY3Rvci4gVGhpcyByaXNrcyBhbiBpbmZpbml0ZSBsb29wIGluIHRoZSBzZW5kZXIuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZWRUYXJnZXQ7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2VuZFRvKHRhcmdldCwgKHtcbiAgICBldmVudFxuICB9KSA9PiBldmVudCwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVFbnF1ZXVlQWN0aW9ucyhhY3RvclNjb3BlLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGNvbGxlY3Rcbn0pIHtcbiAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICBjb25zdCBlbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShhY3Rpb24pIHtcbiAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgfTtcbiAgZW5xdWV1ZS5hc3NpZ24gPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChhc3NpZ24oLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLmNhbmNlbCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKGNhbmNlbCguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUucmFpc2UgPSAoLi4uYXJncykgPT4ge1xuICAgIC8vIGZvciBzb21lIHJlYXNvbiBpdCBmYWlscyB0byBpbmZlciBgVERlbGF5YCBmcm9tIGAuLi5hcmdzYCBoZXJlIGFuZCBwaWNrcyBpdHMgZGVmYXVsdCAoYG5ldmVyYClcbiAgICAvLyB0aGVuIGl0IGZhaWxzIHRvIHR5cGVjaGVjayB0aGF0IGJlY2F1c2UgYC4uLmFyZ3NgIHVzZSBgc3RyaW5nYCBpbiBwbGFjZSBvZiBgVERlbGF5YFxuICAgIGFjdGlvbnMucHVzaChyYWlzZSguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuc2VuZFRvID0gKC4uLmFyZ3MpID0+IHtcbiAgICAvLyBmb3Igc29tZSByZWFzb24gaXQgZmFpbHMgdG8gaW5mZXIgYFREZWxheWAgZnJvbSBgLi4uYXJnc2AgaGVyZSBhbmQgcGlja3MgaXRzIGRlZmF1bHQgKGBuZXZlcmApXG4gICAgLy8gdGhlbiBpdCBmYWlscyB0byB0eXBlY2hlY2sgdGhhdCBiZWNhdXNlIGAuLi5hcmdzYCB1c2UgYHN0cmluZ2AgaW4gcGxhY2Ugb2YgYFREZWxheVxuICAgIGFjdGlvbnMucHVzaChzZW5kVG8oLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnNlbmRQYXJlbnQgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChzZW5kUGFyZW50KC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5zcGF3bkNoaWxkID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goc3Bhd25DaGlsZCguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuc3RvcENoaWxkID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goc3RvcENoaWxkKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5lbWl0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goZW1pdCguLi5hcmdzKSk7XG4gIH07XG4gIGNvbGxlY3Qoe1xuICAgIGNvbnRleHQ6IGFyZ3MuY29udGV4dCxcbiAgICBldmVudDogYXJncy5ldmVudCxcbiAgICBlbnF1ZXVlLFxuICAgIGNoZWNrOiBndWFyZCA9PiBldmFsdWF0ZUd1YXJkKGd1YXJkLCBzbmFwc2hvdC5jb250ZXh0LCBhcmdzLmV2ZW50LCBzbmFwc2hvdCksXG4gICAgc2VsZjogYWN0b3JTY29wZS5zZWxmLFxuICAgIHN5c3RlbTogYWN0b3JTY29wZS5zeXN0ZW1cbiAgfSwgYWN0aW9uUGFyYW1zKTtcbiAgcmV0dXJuIFtzbmFwc2hvdCwgdW5kZWZpbmVkLCBhY3Rpb25zXTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhY3Rpb24gb2JqZWN0IHRoYXQgd2lsbCBleGVjdXRlIGFjdGlvbnMgdGhhdCBhcmUgcXVldWVkIGJ5IHRoZVxuICogYGVucXVldWUoYWN0aW9uKWAgZnVuY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlTWFjaGluZSwgZW5xdWV1ZUFjdGlvbnMgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IG1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgZW50cnk6IGVucXVldWVBY3Rpb25zKCh7IGVucXVldWUsIGNoZWNrIH0pID0+IHtcbiAqICAgICBlbnF1ZXVlLmFzc2lnbih7IGNvdW50OiAwIH0pO1xuICpcbiAqICAgICBpZiAoY2hlY2soJ3NvbWVHdWFyZCcpKSB7XG4gKiAgICAgICBlbnF1ZXVlLmFzc2lnbih7IGNvdW50OiAxIH0pO1xuICogICAgIH1cbiAqXG4gKiAgICAgZW5xdWV1ZSgnc29tZUFjdGlvbicpO1xuICogICB9KVxuICogfSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZUFjdGlvbnMoY29sbGVjdCkge1xuICBmdW5jdGlvbiBlbnF1ZXVlQWN0aW9ucyhfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgZW5xdWV1ZUFjdGlvbnMudHlwZSA9ICd4c3RhdGUuZW5xdWV1ZUFjdGlvbnMnO1xuICBlbnF1ZXVlQWN0aW9ucy5jb2xsZWN0ID0gY29sbGVjdDtcbiAgZW5xdWV1ZUFjdGlvbnMucmVzb2x2ZSA9IHJlc29sdmVFbnF1ZXVlQWN0aW9ucztcbiAgcmV0dXJuIGVucXVldWVBY3Rpb25zO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTG9nKF8sIHNuYXBzaG90LCBhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgdmFsdWUsXG4gIGxhYmVsXG59KSB7XG4gIHJldHVybiBbc25hcHNob3QsIHtcbiAgICB2YWx1ZTogdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUoYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zKSA6IHZhbHVlLFxuICAgIGxhYmVsXG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlTG9nKHtcbiAgbG9nZ2VyXG59LCB7XG4gIHZhbHVlLFxuICBsYWJlbFxufSkge1xuICBpZiAobGFiZWwpIHtcbiAgICBsb2dnZXIobGFiZWwsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBsb2dnZXIodmFsdWUpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSBleHByIFRoZSBleHByZXNzaW9uIGZ1bmN0aW9uIHRvIGV2YWx1YXRlIHdoaWNoIHdpbGwgYmUgbG9nZ2VkLiBUYWtlc1xuICogICBpbiAyIGFyZ3VtZW50czpcbiAqXG4gKiAgIC0gYGN0eGAgLSB0aGUgY3VycmVudCBzdGF0ZSBjb250ZXh0XG4gKiAgIC0gYGV2ZW50YCAtIHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cbiAqXG4gKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIHRvIGdpdmUgdG8gdGhlIGxvZ2dlZCBleHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiBsb2codmFsdWUgPSAoe1xuICBjb250ZXh0LFxuICBldmVudFxufSkgPT4gKHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0pLCBsYWJlbCkge1xuICBmdW5jdGlvbiBsb2coX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGxvZy50eXBlID0gJ3hzdGF0ZS5sb2cnO1xuICBsb2cudmFsdWUgPSB2YWx1ZTtcbiAgbG9nLmxhYmVsID0gbGFiZWw7XG4gIGxvZy5yZXNvbHZlID0gcmVzb2x2ZUxvZztcbiAgbG9nLmV4ZWN1dGUgPSBleGVjdXRlTG9nO1xuICByZXR1cm4gbG9nO1xufVxuXG5leHBvcnQgeyBTcGVjaWFsVGFyZ2V0cyBhcyBTLCBhc3NpZ24gYXMgYSwgZW5xdWV1ZUFjdGlvbnMgYXMgYiwgc2VuZFRvIGFzIGMsIGVtaXQgYXMgZSwgZm9yd2FyZFRvIGFzIGYsIGxvZyBhcyBsLCBzZW5kUGFyZW50IGFzIHMgfTtcbiJdLCJuYW1lcyI6WyJUIiwiUHJvY2Vzc2luZ1N0YXR1cyIsInoiLCJyZXNvbHZlUmVmZXJlbmNlZEFjdG9yIiwiQSIsImNyZWF0ZUFjdG9yIiwiVSIsImNsb25lTWFjaGluZVNuYXBzaG90IiwiViIsImV4ZWN1dGluZ0N1c3RvbUFjdGlvbiIsIlciLCJYU1RBVEVfRVJST1IiLCJZIiwiY3JlYXRlRXJyb3JBY3RvckV2ZW50IiwiZSIsImV2YWx1YXRlR3VhcmQiLCJNIiwiY2FuY2VsIiwiTyIsInJhaXNlIiwiUCIsInNwYXduQ2hpbGQiLCJSIiwic3RvcENoaWxkIiwiY3JlYXRlU3Bhd25lciIsImFjdG9yU2NvcGUiLCJtYWNoaW5lIiwiY29udGV4dCIsImV2ZW50Iiwic3Bhd25lZENoaWxkcmVuIiwic3Bhd24iLCJzcmMiLCJvcHRpb25zIiwibG9naWMiLCJFcnJvciIsImlkIiwiYWN0b3JSZWYiLCJwYXJlbnQiLCJzZWxmIiwic3luY1NuYXBzaG90IiwiaW5wdXQiLCJzeXN0ZW1JZCIsImRlZmVyIiwiX3Byb2Nlc3NpbmdTdGF0dXMiLCJTdG9wcGVkIiwic3RhcnQiLCJyZXNvbHZlQXNzaWduIiwic25hcHNob3QiLCJhY3Rpb25BcmdzIiwiYWN0aW9uUGFyYW1zIiwiYXNzaWdubWVudCIsImFzc2lnbkFyZ3MiLCJzeXN0ZW0iLCJwYXJ0aWFsVXBkYXRlIiwia2V5IiwiT2JqZWN0Iiwia2V5cyIsInByb3BBc3NpZ25tZW50IiwidXBkYXRlZENvbnRleHQiLCJhc3NpZ24iLCJjaGlsZHJlbiIsImxlbmd0aCIsInVuZGVmaW5lZCIsImNvbnNvbGUiLCJ3YXJuIiwiX2FyZ3MiLCJfcGFyYW1zIiwidHlwZSIsInJlc29sdmUiLCJyZXNvbHZlRW1pdCIsIl8iLCJhcmdzIiwiZXZlbnRPckV4cHIiLCJyZXNvbHZlZEV2ZW50IiwiZXhlY3V0ZUVtaXQiLCJlbWl0IiwiZXhlY3V0ZSIsIlNwZWNpYWxUYXJnZXRzIiwicmVzb2x2ZVNlbmRUbyIsInRvIiwiZGVsYXkiLCJleHRyYSIsImRlbGF5c01hcCIsImltcGxlbWVudGF0aW9ucyIsImRlbGF5cyIsInJlc29sdmVkRGVsYXkiLCJjb25maWdEZWxheSIsInJlc29sdmVkVGFyZ2V0IiwidGFyZ2V0QWN0b3JSZWYiLCJQYXJlbnQiLCJfcGFyZW50IiwiSW50ZXJuYWwiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJkZWZlcnJlZEFjdG9ySWRzIiwiaW5jbHVkZXMiLCJ0YXJnZXRJZCIsInJldHJ5UmVzb2x2ZVNlbmRUbyIsInBhcmFtcyIsImV4ZWN1dGVTZW5kVG8iLCJzY2hlZHVsZXIiLCJzY2hlZHVsZSIsIl9yZWxheSIsImRhdGEiLCJzZW5kVG8iLCJyZXRyeVJlc29sdmUiLCJzZW5kUGFyZW50IiwiZm9yd2FyZFRvIiwidGFyZ2V0Iiwib3JpZ2luYWxUYXJnZXQiLCJyZXNvbHZlRW5xdWV1ZUFjdGlvbnMiLCJjb2xsZWN0IiwiYWN0aW9ucyIsImVucXVldWUiLCJhY3Rpb24iLCJwdXNoIiwiY2hlY2siLCJndWFyZCIsImVucXVldWVBY3Rpb25zIiwicmVzb2x2ZUxvZyIsInZhbHVlIiwibGFiZWwiLCJleGVjdXRlTG9nIiwibG9nZ2VyIiwibG9nIiwiUyIsImEiLCJiIiwiYyIsImYiLCJsIiwicyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dist/raise-1db27a82.development.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ $$ACTOR_TYPE),\n/* harmony export */   A: () => (/* binding */ createActor),\n/* harmony export */   B: () => (/* binding */ Actor),\n/* harmony export */   C: () => (/* binding */ interpret),\n/* harmony export */   D: () => (/* binding */ and),\n/* harmony export */   E: () => (/* binding */ not),\n/* harmony export */   F: () => (/* binding */ or),\n/* harmony export */   G: () => (/* binding */ stateIn),\n/* harmony export */   H: () => (/* binding */ isMachineSnapshot),\n/* harmony export */   I: () => (/* binding */ getAllOwnEventDescriptors),\n/* harmony export */   J: () => (/* binding */ matchesState),\n/* harmony export */   K: () => (/* binding */ pathToStateValue),\n/* harmony export */   L: () => (/* binding */ toObserver),\n/* harmony export */   M: () => (/* binding */ cancel),\n/* harmony export */   N: () => (/* binding */ NULL_EVENT),\n/* harmony export */   O: () => (/* binding */ raise),\n/* harmony export */   P: () => (/* binding */ spawnChild),\n/* harmony export */   Q: () => (/* binding */ stop),\n/* harmony export */   R: () => (/* binding */ stopChild),\n/* harmony export */   S: () => (/* binding */ STATE_DELIMITER),\n/* harmony export */   T: () => (/* binding */ ProcessingStatus),\n/* harmony export */   U: () => (/* binding */ cloneMachineSnapshot),\n/* harmony export */   V: () => (/* binding */ executingCustomAction),\n/* harmony export */   W: () => (/* binding */ XSTATE_ERROR),\n/* harmony export */   X: () => (/* binding */ XSTATE_STOP),\n/* harmony export */   Y: () => (/* binding */ createErrorActorEvent),\n/* harmony export */   a: () => (/* binding */ toTransitionConfigArray),\n/* harmony export */   b: () => (/* binding */ formatTransition),\n/* harmony export */   c: () => (/* binding */ createInvokeId),\n/* harmony export */   d: () => (/* binding */ formatInitialTransition),\n/* harmony export */   e: () => (/* binding */ evaluateGuard),\n/* harmony export */   f: () => (/* binding */ formatTransitions),\n/* harmony export */   g: () => (/* binding */ getDelayedTransitions),\n/* harmony export */   h: () => (/* binding */ getCandidates),\n/* harmony export */   i: () => (/* binding */ getAllStateNodes),\n/* harmony export */   j: () => (/* binding */ getStateNodes),\n/* harmony export */   k: () => (/* binding */ createMachineSnapshot),\n/* harmony export */   l: () => (/* binding */ isInFinalState),\n/* harmony export */   m: () => (/* binding */ mapValues),\n/* harmony export */   n: () => (/* binding */ macrostep),\n/* harmony export */   o: () => (/* binding */ transitionNode),\n/* harmony export */   p: () => (/* binding */ resolveActionsAndContext),\n/* harmony export */   q: () => (/* binding */ createInitEvent),\n/* harmony export */   r: () => (/* binding */ resolveStateValue),\n/* harmony export */   s: () => (/* binding */ microstep),\n/* harmony export */   t: () => (/* binding */ toArray),\n/* harmony export */   u: () => (/* binding */ getInitialStateNodes),\n/* harmony export */   v: () => (/* binding */ toStatePath),\n/* harmony export */   w: () => (/* binding */ isStateId),\n/* harmony export */   x: () => (/* binding */ getStateNodeByPath),\n/* harmony export */   y: () => (/* binding */ getPersistedSnapshot),\n/* harmony export */   z: () => (/* binding */ resolveReferencedActor)\n/* harmony export */ });\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\nclass Mailbox {\n    constructor(_process){\n        this._process = _process;\n        this._active = false;\n        this._current = null;\n        this._last = null;\n    }\n    start() {\n        this._active = true;\n        this.flush();\n    }\n    clear() {\n        // we can't set _current to null because we might be currently processing\n        // and enqueue following clear shouldnt start processing the enqueued item immediately\n        if (this._current) {\n            this._current.next = null;\n            this._last = this._current;\n        }\n    }\n    enqueue(event) {\n        const enqueued = {\n            value: event,\n            next: null\n        };\n        if (this._current) {\n            this._last.next = enqueued;\n            this._last = enqueued;\n            return;\n        }\n        this._current = enqueued;\n        this._last = enqueued;\n        if (this._active) {\n            this.flush();\n        }\n    }\n    flush() {\n        while(this._current){\n            // atm the given _process is responsible for implementing proper try/catch handling\n            // we assume here that this won't throw in a way that can affect this mailbox\n            const consumed = this._current;\n            this._process(consumed.value);\n            this._current = consumed.next;\n        }\n        this._last = null;\n    }\n}\nconst STATE_DELIMITER = \".\";\nconst TARGETLESS_KEY = \"\";\nconst NULL_EVENT = \"\";\nconst STATE_IDENTIFIER = \"#\";\nconst WILDCARD = \"*\";\nconst XSTATE_INIT = \"xstate.init\";\nconst XSTATE_ERROR = \"xstate.error\";\nconst XSTATE_STOP = \"xstate.stop\";\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */ function createAfterEvent(delayRef, id) {\n    return {\n        type: `xstate.after.${delayRef}.${id}`\n    };\n}\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */ function createDoneStateEvent(id, output) {\n    return {\n        type: `xstate.done.state.${id}`,\n        output\n    };\n}\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */ function createDoneActorEvent(invokeId, output) {\n    return {\n        type: `xstate.done.actor.${invokeId}`,\n        output,\n        actorId: invokeId\n    };\n}\nfunction createErrorActorEvent(id, error) {\n    return {\n        type: `xstate.error.actor.${id}`,\n        error,\n        actorId: id\n    };\n}\nfunction createInitEvent(input) {\n    return {\n        type: XSTATE_INIT,\n        input\n    };\n}\n/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */ function reportUnhandledError(err) {\n    setTimeout(()=>{\n        throw err;\n    });\n}\nconst symbolObservable = (()=>typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\nfunction matchesState(parentStateId, childStateId) {\n    const parentStateValue = toStateValue(parentStateId);\n    const childStateValue = toStateValue(childStateId);\n    if (typeof childStateValue === \"string\") {\n        if (typeof parentStateValue === \"string\") {\n            return childStateValue === parentStateValue;\n        }\n        // Parent more specific than child\n        return false;\n    }\n    if (typeof parentStateValue === \"string\") {\n        return parentStateValue in childStateValue;\n    }\n    return Object.keys(parentStateValue).every((key)=>{\n        if (!(key in childStateValue)) {\n            return false;\n        }\n        return matchesState(parentStateValue[key], childStateValue[key]);\n    });\n}\nfunction toStatePath(stateId) {\n    if (isArray(stateId)) {\n        return stateId;\n    }\n    const result = [];\n    let segment = \"\";\n    for(let i = 0; i < stateId.length; i++){\n        const char = stateId.charCodeAt(i);\n        switch(char){\n            // \\\n            case 92:\n                // consume the next character\n                segment += stateId[i + 1];\n                // and skip over it\n                i++;\n                continue;\n            // .\n            case 46:\n                result.push(segment);\n                segment = \"\";\n                continue;\n        }\n        segment += stateId[i];\n    }\n    result.push(segment);\n    return result;\n}\nfunction toStateValue(stateValue) {\n    if (isMachineSnapshot(stateValue)) {\n        return stateValue.value;\n    }\n    if (typeof stateValue !== \"string\") {\n        return stateValue;\n    }\n    const statePath = toStatePath(stateValue);\n    return pathToStateValue(statePath);\n}\nfunction pathToStateValue(statePath) {\n    if (statePath.length === 1) {\n        return statePath[0];\n    }\n    const value = {};\n    let marker = value;\n    for(let i = 0; i < statePath.length - 1; i++){\n        if (i === statePath.length - 2) {\n            marker[statePath[i]] = statePath[i + 1];\n        } else {\n            const previous = marker;\n            marker = {};\n            previous[statePath[i]] = marker;\n        }\n    }\n    return value;\n}\nfunction mapValues(collection, iteratee) {\n    const result = {};\n    const collectionKeys = Object.keys(collection);\n    for(let i = 0; i < collectionKeys.length; i++){\n        const key = collectionKeys[i];\n        result[key] = iteratee(collection[key], key, collection, i);\n    }\n    return result;\n}\nfunction toArrayStrict(value) {\n    if (isArray(value)) {\n        return value;\n    }\n    return [\n        value\n    ];\n}\nfunction toArray(value) {\n    if (value === undefined) {\n        return [];\n    }\n    return toArrayStrict(value);\n}\nfunction resolveOutput(mapper, context, event, self) {\n    if (typeof mapper === \"function\") {\n        return mapper({\n            context,\n            event,\n            self\n        });\n    }\n    if (!!mapper && typeof mapper === \"object\" && Object.values(mapper).some((val)=>typeof val === \"function\")) {\n        console.warn(`Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(mapper).filter(([, value])=>typeof value === \"function\").map(([key, value])=>`\\n - ${key}: ${value.toString().replace(/\\n\\s*/g, \"\")}`).join(\"\")}`);\n    }\n    return mapper;\n}\nfunction isArray(value) {\n    return Array.isArray(value);\n}\nfunction isErrorActorEvent(event) {\n    return event.type.startsWith(\"xstate.error.actor\");\n}\nfunction toTransitionConfigArray(configLike) {\n    return toArrayStrict(configLike).map((transitionLike)=>{\n        if (typeof transitionLike === \"undefined\" || typeof transitionLike === \"string\") {\n            return {\n                target: transitionLike\n            };\n        }\n        return transitionLike;\n    });\n}\nfunction normalizeTarget(target) {\n    if (target === undefined || target === TARGETLESS_KEY) {\n        return undefined;\n    }\n    return toArray(target);\n}\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n    const isObserver = typeof nextHandler === \"object\";\n    const self = isObserver ? nextHandler : undefined;\n    return {\n        next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n        error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n        complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(self)\n    };\n}\nfunction createInvokeId(stateNodeId, index) {\n    return `${index}.${stateNodeId}`;\n}\nfunction resolveReferencedActor(machine, src) {\n    const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/);\n    if (!match) {\n        return machine.implementations.actors[src];\n    }\n    const [, indexStr, nodeId] = match;\n    const node = machine.getStateNodeById(nodeId);\n    const invokeConfig = node.config.invoke;\n    return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;\n}\nfunction getAllOwnEventDescriptors(snapshot) {\n    return [\n        ...new Set([\n            ...snapshot._nodes.flatMap((sn)=>sn.ownEvents)\n        ])\n    ];\n}\nfunction createScheduledEventId(actorRef, id) {\n    return `${actorRef.sessionId}.${id}`;\n}\nlet idCounter = 0;\nfunction createSystem(rootActor, options) {\n    const children = new Map();\n    const keyedActors = new Map();\n    const reverseKeyedActors = new WeakMap();\n    const inspectionObservers = new Set();\n    const timerMap = {};\n    const { clock, logger } = options;\n    const scheduler = {\n        schedule: (source, target, event, delay, id = Math.random().toString(36).slice(2))=>{\n            const scheduledEvent = {\n                source,\n                target,\n                event,\n                delay,\n                id,\n                startedAt: Date.now()\n            };\n            const scheduledEventId = createScheduledEventId(source, id);\n            system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n            const timeout = clock.setTimeout(()=>{\n                delete timerMap[scheduledEventId];\n                delete system._snapshot._scheduledEvents[scheduledEventId];\n                system._relay(source, target, event);\n            }, delay);\n            timerMap[scheduledEventId] = timeout;\n        },\n        cancel: (source, id)=>{\n            const scheduledEventId = createScheduledEventId(source, id);\n            const timeout = timerMap[scheduledEventId];\n            delete timerMap[scheduledEventId];\n            delete system._snapshot._scheduledEvents[scheduledEventId];\n            if (timeout !== undefined) {\n                clock.clearTimeout(timeout);\n            }\n        },\n        cancelAll: (actorRef)=>{\n            for(const scheduledEventId in system._snapshot._scheduledEvents){\n                const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];\n                if (scheduledEvent.source === actorRef) {\n                    scheduler.cancel(actorRef, scheduledEvent.id);\n                }\n            }\n        }\n    };\n    const sendInspectionEvent = (event)=>{\n        if (!inspectionObservers.size) {\n            return;\n        }\n        const resolvedInspectionEvent = {\n            ...event,\n            rootId: rootActor.sessionId\n        };\n        inspectionObservers.forEach((observer)=>observer.next?.(resolvedInspectionEvent));\n    };\n    const system = {\n        _snapshot: {\n            _scheduledEvents: (options?.snapshot && options.snapshot.scheduler) ?? {}\n        },\n        _bookId: ()=>`x:${idCounter++}`,\n        _register: (sessionId, actorRef)=>{\n            children.set(sessionId, actorRef);\n            return sessionId;\n        },\n        _unregister: (actorRef)=>{\n            children.delete(actorRef.sessionId);\n            const systemId = reverseKeyedActors.get(actorRef);\n            if (systemId !== undefined) {\n                keyedActors.delete(systemId);\n                reverseKeyedActors.delete(actorRef);\n            }\n        },\n        get: (systemId)=>{\n            return keyedActors.get(systemId);\n        },\n        _set: (systemId, actorRef)=>{\n            const existing = keyedActors.get(systemId);\n            if (existing && existing !== actorRef) {\n                throw new Error(`Actor with system ID '${systemId}' already exists.`);\n            }\n            keyedActors.set(systemId, actorRef);\n            reverseKeyedActors.set(actorRef, systemId);\n        },\n        inspect: (observerOrFn)=>{\n            const observer = toObserver(observerOrFn);\n            inspectionObservers.add(observer);\n            return {\n                unsubscribe () {\n                    inspectionObservers.delete(observer);\n                }\n            };\n        },\n        _sendInspectionEvent: sendInspectionEvent,\n        _relay: (source, target, event)=>{\n            system._sendInspectionEvent({\n                type: \"@xstate.event\",\n                sourceRef: source,\n                actorRef: target,\n                event\n            });\n            target._send(event);\n        },\n        scheduler,\n        getSnapshot: ()=>{\n            return {\n                _scheduledEvents: {\n                    ...system._snapshot._scheduledEvents\n                }\n            };\n        },\n        start: ()=>{\n            const scheduledEvents = system._snapshot._scheduledEvents;\n            system._snapshot._scheduledEvents = {};\n            for(const scheduledId in scheduledEvents){\n                const { source, target, event, delay, id } = scheduledEvents[scheduledId];\n                scheduler.schedule(source, target, event, delay, id);\n            }\n        },\n        _clock: clock,\n        _logger: logger\n    };\n    return system;\n}\nlet executingCustomAction = false;\nconst $$ACTOR_TYPE = 1;\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nlet ProcessingStatus = /*#__PURE__*/ function(ProcessingStatus) {\n    ProcessingStatus[ProcessingStatus[\"NotStarted\"] = 0] = \"NotStarted\";\n    ProcessingStatus[ProcessingStatus[\"Running\"] = 1] = \"Running\";\n    ProcessingStatus[ProcessingStatus[\"Stopped\"] = 2] = \"Stopped\";\n    return ProcessingStatus;\n}({});\nconst defaultOptions = {\n    clock: {\n        setTimeout: (fn, ms)=>{\n            return setTimeout(fn, ms);\n        },\n        clearTimeout: (id)=>{\n            return clearTimeout(id);\n        }\n    },\n    logger: console.log.bind(console),\n    devTools: false\n};\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */ class Actor {\n    /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */ constructor(logic, options){\n        this.logic = logic;\n        /** The current internal state of the actor. */ this._snapshot = void 0;\n        /**\n     * The clock that is responsible for setting and clearing timeouts, such as\n     * delayed events and transitions.\n     */ this.clock = void 0;\n        this.options = void 0;\n        /** The unique identifier for this actor relative to its parent. */ this.id = void 0;\n        this.mailbox = new Mailbox(this._process.bind(this));\n        this.observers = new Set();\n        this.eventListeners = new Map();\n        this.logger = void 0;\n        /** @internal */ this._processingStatus = ProcessingStatus.NotStarted;\n        // Actor Ref\n        this._parent = void 0;\n        /** @internal */ this._syncSnapshot = void 0;\n        this.ref = void 0;\n        // TODO: add typings for system\n        this._actorScope = void 0;\n        this._systemId = void 0;\n        /** The globally unique process ID for this invocation. */ this.sessionId = void 0;\n        /** The system to which this actor belongs. */ this.system = void 0;\n        this._doneEvent = void 0;\n        this.src = void 0;\n        // array of functions to defer\n        this._deferred = [];\n        const resolvedOptions = {\n            ...defaultOptions,\n            ...options\n        };\n        const { clock, logger, parent, syncSnapshot, id, systemId, inspect } = resolvedOptions;\n        this.system = parent ? parent.system : createSystem(this, {\n            clock,\n            logger\n        });\n        if (inspect && !parent) {\n            // Always inspect at the system-level\n            this.system.inspect(toObserver(inspect));\n        }\n        this.sessionId = this.system._bookId();\n        this.id = id ?? this.sessionId;\n        this.logger = options?.logger ?? this.system._logger;\n        this.clock = options?.clock ?? this.system._clock;\n        this._parent = parent;\n        this._syncSnapshot = syncSnapshot;\n        this.options = resolvedOptions;\n        this.src = resolvedOptions.src ?? logic;\n        this.ref = this;\n        this._actorScope = {\n            self: this,\n            id: this.id,\n            sessionId: this.sessionId,\n            logger: this.logger,\n            defer: (fn)=>{\n                this._deferred.push(fn);\n            },\n            system: this.system,\n            stopChild: (child)=>{\n                if (child._parent !== this) {\n                    throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);\n                }\n                child._stop();\n            },\n            emit: (emittedEvent)=>{\n                const listeners = this.eventListeners.get(emittedEvent.type);\n                const wildcardListener = this.eventListeners.get(\"*\");\n                if (!listeners && !wildcardListener) {\n                    return;\n                }\n                const allListeners = [\n                    ...listeners ? listeners.values() : [],\n                    ...wildcardListener ? wildcardListener.values() : []\n                ];\n                for (const handler of allListeners){\n                    handler(emittedEvent);\n                }\n            },\n            actionExecutor: (action)=>{\n                const exec = ()=>{\n                    this._actorScope.system._sendInspectionEvent({\n                        type: \"@xstate.action\",\n                        actorRef: this,\n                        action: {\n                            type: action.type,\n                            params: action.params\n                        }\n                    });\n                    if (!action.exec) {\n                        return;\n                    }\n                    const saveExecutingCustomAction = executingCustomAction;\n                    try {\n                        executingCustomAction = true;\n                        action.exec(action.info, action.params);\n                    } finally{\n                        executingCustomAction = saveExecutingCustomAction;\n                    }\n                };\n                if (this._processingStatus === ProcessingStatus.Running) {\n                    exec();\n                } else {\n                    this._deferred.push(exec);\n                }\n            }\n        };\n        // Ensure that the send method is bound to this Actor instance\n        // if destructured\n        this.send = this.send.bind(this);\n        this.system._sendInspectionEvent({\n            type: \"@xstate.actor\",\n            actorRef: this\n        });\n        if (systemId) {\n            this._systemId = systemId;\n            this.system._set(systemId, this);\n        }\n        this._initState(options?.snapshot ?? options?.state);\n        if (systemId && this._snapshot.status !== \"active\") {\n            this.system._unregister(this);\n        }\n    }\n    _initState(persistedState) {\n        try {\n            this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n        } catch (err) {\n            // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n            // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n            // so right now this is a lie of sorts\n            this._snapshot = {\n                status: \"error\",\n                output: undefined,\n                error: err\n            };\n        }\n    }\n    update(snapshot, event) {\n        // Update state\n        this._snapshot = snapshot;\n        // Execute deferred effects\n        let deferredFn;\n        while(deferredFn = this._deferred.shift()){\n            try {\n                deferredFn();\n            } catch (err) {\n                // this error can only be caught when executing *initial* actions\n                // it's the only time when we call actions provided by the user through those deferreds\n                // when the actor is already running we always execute them synchronously while transitioning\n                // no \"builtin deferred\" should actually throw an error since they are either safe\n                // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n                this._deferred.length = 0;\n                this._snapshot = {\n                    ...snapshot,\n                    status: \"error\",\n                    error: err\n                };\n            }\n        }\n        switch(this._snapshot.status){\n            case \"active\":\n                for (const observer of this.observers){\n                    try {\n                        observer.next?.(snapshot);\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                }\n                break;\n            case \"done\":\n                // next observers are meant to be notified about done snapshots\n                // this can be seen as something that is different from how observable work\n                // but with observables `complete` callback is called without any arguments\n                // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n                // and the completion event as something that is separate,\n                // something that merely follows emitting that done snapshot\n                for (const observer of this.observers){\n                    try {\n                        observer.next?.(snapshot);\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                }\n                this._stopProcedure();\n                this._complete();\n                this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);\n                if (this._parent) {\n                    this.system._relay(this, this._parent, this._doneEvent);\n                }\n                break;\n            case \"error\":\n                this._error(this._snapshot.error);\n                break;\n        }\n        this.system._sendInspectionEvent({\n            type: \"@xstate.snapshot\",\n            actorRef: this,\n            event,\n            snapshot\n        });\n    }\n    /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */ subscribe(nextListenerOrObserver, errorListener, completeListener) {\n        const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);\n        if (this._processingStatus !== ProcessingStatus.Stopped) {\n            this.observers.add(observer);\n        } else {\n            switch(this._snapshot.status){\n                case \"done\":\n                    try {\n                        observer.complete?.();\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                    break;\n                case \"error\":\n                    {\n                        const err = this._snapshot.error;\n                        if (!observer.error) {\n                            reportUnhandledError(err);\n                        } else {\n                            try {\n                                observer.error(err);\n                            } catch (err) {\n                                reportUnhandledError(err);\n                            }\n                        }\n                        break;\n                    }\n            }\n        }\n        return {\n            unsubscribe: ()=>{\n                this.observers.delete(observer);\n            }\n        };\n    }\n    on(type, handler) {\n        let listeners = this.eventListeners.get(type);\n        if (!listeners) {\n            listeners = new Set();\n            this.eventListeners.set(type, listeners);\n        }\n        const wrappedHandler = handler.bind(undefined);\n        listeners.add(wrappedHandler);\n        return {\n            unsubscribe: ()=>{\n                listeners.delete(wrappedHandler);\n            }\n        };\n    }\n    /** Starts the Actor from the initial state */ start() {\n        if (this._processingStatus === ProcessingStatus.Running) {\n            // Do not restart the service if it is already started\n            return this;\n        }\n        if (this._syncSnapshot) {\n            this.subscribe({\n                next: (snapshot)=>{\n                    if (snapshot.status === \"active\") {\n                        this.system._relay(this, this._parent, {\n                            type: `xstate.snapshot.${this.id}`,\n                            snapshot\n                        });\n                    }\n                },\n                error: ()=>{}\n            });\n        }\n        this.system._register(this.sessionId, this);\n        if (this._systemId) {\n            this.system._set(this._systemId, this);\n        }\n        this._processingStatus = ProcessingStatus.Running;\n        // TODO: this isn't correct when rehydrating\n        const initEvent = createInitEvent(this.options.input);\n        this.system._sendInspectionEvent({\n            type: \"@xstate.event\",\n            sourceRef: this._parent,\n            actorRef: this,\n            event: initEvent\n        });\n        const status = this._snapshot.status;\n        switch(status){\n            case \"done\":\n                // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n                // we still need to complete observers, flush deferreds etc\n                this.update(this._snapshot, initEvent);\n                // TODO: rethink cleanup of observers, mailbox, etc\n                return this;\n            case \"error\":\n                this._error(this._snapshot.error);\n                return this;\n        }\n        if (!this._parent) {\n            this.system.start();\n        }\n        if (this.logic.start) {\n            try {\n                this.logic.start(this._snapshot, this._actorScope);\n            } catch (err) {\n                this._snapshot = {\n                    ...this._snapshot,\n                    status: \"error\",\n                    error: err\n                };\n                this._error(err);\n                return this;\n            }\n        }\n        // TODO: this notifies all subscribers but usually this is redundant\n        // there is no real change happening here\n        // we need to rethink if this needs to be refactored\n        this.update(this._snapshot, initEvent);\n        if (this.options.devTools) {\n            this.attachDevTools();\n        }\n        this.mailbox.start();\n        return this;\n    }\n    _process(event) {\n        let nextState;\n        let caughtError;\n        try {\n            nextState = this.logic.transition(this._snapshot, event, this._actorScope);\n        } catch (err) {\n            // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n            caughtError = {\n                err\n            };\n        }\n        if (caughtError) {\n            const { err } = caughtError;\n            this._snapshot = {\n                ...this._snapshot,\n                status: \"error\",\n                error: err\n            };\n            this._error(err);\n            return;\n        }\n        this.update(nextState, event);\n        if (event.type === XSTATE_STOP) {\n            this._stopProcedure();\n            this._complete();\n        }\n    }\n    _stop() {\n        if (this._processingStatus === ProcessingStatus.Stopped) {\n            return this;\n        }\n        this.mailbox.clear();\n        if (this._processingStatus === ProcessingStatus.NotStarted) {\n            this._processingStatus = ProcessingStatus.Stopped;\n            return this;\n        }\n        this.mailbox.enqueue({\n            type: XSTATE_STOP\n        });\n        return this;\n    }\n    /** Stops the Actor and unsubscribe all listeners. */ stop() {\n        if (this._parent) {\n            throw new Error(\"A non-root actor cannot be stopped directly.\");\n        }\n        return this._stop();\n    }\n    _complete() {\n        for (const observer of this.observers){\n            try {\n                observer.complete?.();\n            } catch (err) {\n                reportUnhandledError(err);\n            }\n        }\n        this.observers.clear();\n    }\n    _reportError(err) {\n        if (!this.observers.size) {\n            if (!this._parent) {\n                reportUnhandledError(err);\n            }\n            return;\n        }\n        let reportError = false;\n        for (const observer of this.observers){\n            const errorListener = observer.error;\n            reportError ||= !errorListener;\n            try {\n                errorListener?.(err);\n            } catch (err2) {\n                reportUnhandledError(err2);\n            }\n        }\n        this.observers.clear();\n        if (reportError) {\n            reportUnhandledError(err);\n        }\n    }\n    _error(err) {\n        this._stopProcedure();\n        this._reportError(err);\n        if (this._parent) {\n            this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));\n        }\n    }\n    // TODO: atm children don't belong entirely to the actor so\n    // in a way - it's not even super aware of them\n    // so we can't stop them from here but we really should!\n    // right now, they are being stopped within the machine's transition\n    // but that could throw and leave us with \"orphaned\" active actors\n    _stopProcedure() {\n        if (this._processingStatus !== ProcessingStatus.Running) {\n            // Actor already stopped; do nothing\n            return this;\n        }\n        // Cancel all delayed events\n        this.system.scheduler.cancelAll(this);\n        // TODO: mailbox.reset\n        this.mailbox.clear();\n        // TODO: after `stop` we must prepare ourselves for receiving events again\n        // events sent *after* stop signal must be queued\n        // it seems like this should be the common behavior for all of our consumers\n        // so perhaps this should be unified somehow for all of them\n        this.mailbox = new Mailbox(this._process.bind(this));\n        this._processingStatus = ProcessingStatus.Stopped;\n        this.system._unregister(this);\n        return this;\n    }\n    /** @internal */ _send(event) {\n        if (this._processingStatus === ProcessingStatus.Stopped) {\n            // do nothing\n            {\n                const eventString = JSON.stringify(event);\n                console.warn(`Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`);\n            }\n            return;\n        }\n        this.mailbox.enqueue(event);\n    }\n    /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */ send(event) {\n        if (typeof event === \"string\") {\n            throw new Error(`Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`);\n        }\n        this.system._relay(undefined, this, event);\n    }\n    attachDevTools() {\n        const { devTools } = this.options;\n        if (devTools) {\n            const resolvedDevToolsAdapter = typeof devTools === \"function\" ? devTools : _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.devToolsAdapter;\n            resolvedDevToolsAdapter(this);\n        }\n    }\n    toJSON() {\n        return {\n            xstate$$type: $$ACTOR_TYPE,\n            id: this.id\n        };\n    }\n    /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */ getPersistedSnapshot(options) {\n        return this.logic.getPersistedSnapshot(this._snapshot, options);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n    /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */ getSnapshot() {\n        if (!this._snapshot) {\n            throw new Error(`Snapshot can't be read while the actor initializes itself`);\n        }\n        return this._snapshot;\n    }\n}\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */ function createActor(logic, ...[options]) {\n    return new Actor(logic, options);\n}\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */ const interpret = createActor;\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */ function resolveCancel(_, snapshot, actionArgs, actionParams, { sendId }) {\n    const resolvedSendId = typeof sendId === \"function\" ? sendId(actionArgs, actionParams) : sendId;\n    return [\n        snapshot,\n        {\n            sendId: resolvedSendId\n        },\n        undefined\n    ];\n}\nfunction executeCancel(actorScope, params) {\n    actorScope.defer(()=>{\n        actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n    });\n}\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */ function cancel(sendId) {\n    function cancel(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    cancel.type = \"xstate.cancel\";\n    cancel.sendId = sendId;\n    cancel.resolve = resolveCancel;\n    cancel.execute = executeCancel;\n    return cancel;\n}\nfunction resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, { id, systemId, src, input, syncSnapshot }) {\n    const logic = typeof src === \"string\" ? resolveReferencedActor(snapshot.machine, src) : src;\n    const resolvedId = typeof id === \"function\" ? id(actionArgs) : id;\n    let actorRef;\n    let resolvedInput = undefined;\n    if (logic) {\n        resolvedInput = typeof input === \"function\" ? input({\n            context: snapshot.context,\n            event: actionArgs.event,\n            self: actorScope.self\n        }) : input;\n        actorRef = createActor(logic, {\n            id: resolvedId,\n            src,\n            parent: actorScope.self,\n            syncSnapshot,\n            systemId,\n            input: resolvedInput\n        });\n    }\n    if (!actorRef) {\n        console.warn(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string\n        `Actor type '${src}' not found in machine '${actorScope.id}'.`);\n    }\n    return [\n        cloneMachineSnapshot(snapshot, {\n            children: {\n                ...snapshot.children,\n                [resolvedId]: actorRef\n            }\n        }),\n        {\n            id,\n            systemId,\n            actorRef,\n            src,\n            input: resolvedInput\n        },\n        undefined\n    ];\n}\nfunction executeSpawn(actorScope, { actorRef }) {\n    if (!actorRef) {\n        return;\n    }\n    actorScope.defer(()=>{\n        if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n            return;\n        }\n        actorRef.start();\n    });\n}\nfunction spawnChild(...[src, { id, systemId, input, syncSnapshot = false } = {}]) {\n    function spawnChild1(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    spawnChild1.type = \"xstate.spawnChild\";\n    spawnChild1.id = id;\n    spawnChild1.systemId = systemId;\n    spawnChild1.src = src;\n    spawnChild1.input = input;\n    spawnChild1.syncSnapshot = syncSnapshot;\n    spawnChild1.resolve = resolveSpawn;\n    spawnChild1.execute = executeSpawn;\n    return spawnChild1;\n}\nfunction resolveStop(_, snapshot, args, actionParams, { actorRef }) {\n    const actorRefOrString = typeof actorRef === \"function\" ? actorRef(args, actionParams) : actorRef;\n    const resolvedActorRef = typeof actorRefOrString === \"string\" ? snapshot.children[actorRefOrString] : actorRefOrString;\n    let children = snapshot.children;\n    if (resolvedActorRef) {\n        children = {\n            ...children\n        };\n        delete children[resolvedActorRef.id];\n    }\n    return [\n        cloneMachineSnapshot(snapshot, {\n            children\n        }),\n        resolvedActorRef,\n        undefined\n    ];\n}\nfunction executeStop(actorScope, actorRef) {\n    if (!actorRef) {\n        return;\n    }\n    // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n    // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n    // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n    actorScope.system._unregister(actorRef);\n    // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n    // this can happen, for example, when the invoking state is being exited immediately by an always transition\n    if (actorRef._processingStatus !== ProcessingStatus.Running) {\n        actorScope.stopChild(actorRef);\n        return;\n    }\n    // stopping a child enqueues a stop event in the child actor's mailbox\n    // we need for all of the already enqueued events to be processed before we stop the child\n    // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n    // and we don't want to ignore those events\n    actorScope.defer(()=>{\n        actorScope.stopChild(actorRef);\n    });\n}\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */ function stopChild(actorRef) {\n    function stop(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    stop.type = \"xstate.stopChild\";\n    stop.actorRef = actorRef;\n    stop.resolve = resolveStop;\n    stop.execute = executeStop;\n    return stop;\n}\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */ const stop = stopChild;\nfunction checkStateIn(snapshot, _, { stateValue }) {\n    if (typeof stateValue === \"string\" && isStateId(stateValue)) {\n        const target = snapshot.machine.getStateNodeById(stateValue);\n        return snapshot._nodes.some((sn)=>sn === target);\n    }\n    return snapshot.matches(stateValue);\n}\nfunction stateIn(stateValue) {\n    function stateIn() {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    stateIn.check = checkStateIn;\n    stateIn.stateValue = stateValue;\n    return stateIn;\n}\nfunction checkNot(snapshot, { context, event }, { guards }) {\n    return !evaluateGuard(guards[0], context, event, snapshot);\n}\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */ function not(guard) {\n    function not(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    not.check = checkNot;\n    not.guards = [\n        guard\n    ];\n    return not;\n}\nfunction checkAnd(snapshot, { context, event }, { guards }) {\n    return guards.every((guard)=>evaluateGuard(guard, context, event, snapshot));\n}\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */ function and(guards) {\n    function and(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    and.check = checkAnd;\n    and.guards = guards;\n    return and;\n}\nfunction checkOr(snapshot, { context, event }, { guards }) {\n    return guards.some((guard)=>evaluateGuard(guard, context, event, snapshot));\n}\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */ function or(guards) {\n    function or(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    or.check = checkOr;\n    or.guards = guards;\n    return or;\n}\n// TODO: throw on cycles (depth check should be enough)\nfunction evaluateGuard(guard, context, event, snapshot) {\n    const { machine } = snapshot;\n    const isInline = typeof guard === \"function\";\n    const resolved = isInline ? guard : machine.implementations.guards[typeof guard === \"string\" ? guard : guard.type];\n    if (!isInline && !resolved) {\n        throw new Error(`Guard '${typeof guard === \"string\" ? guard : guard.type}' is not implemented.'.`);\n    }\n    if (typeof resolved !== \"function\") {\n        return evaluateGuard(resolved, context, event, snapshot);\n    }\n    const guardArgs = {\n        context,\n        event\n    };\n    const guardParams = isInline || typeof guard === \"string\" ? undefined : \"params\" in guard ? typeof guard.params === \"function\" ? guard.params({\n        context,\n        event\n    }) : guard.params : undefined;\n    if (!(\"check\" in resolved)) {\n        // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n        // inline guards expect `TExpressionGuard` to be set to `undefined`\n        // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n        return resolved(guardArgs, guardParams);\n    }\n    const builtinGuard = resolved;\n    return builtinGuard.check(snapshot, guardArgs, resolved // this holds all params\n    );\n}\nconst isAtomicStateNode = (stateNode)=>stateNode.type === \"atomic\" || stateNode.type === \"final\";\nfunction getChildren(stateNode) {\n    return Object.values(stateNode.states).filter((sn)=>sn.type !== \"history\");\n}\nfunction getProperAncestors(stateNode, toStateNode) {\n    const ancestors = [];\n    if (toStateNode === stateNode) {\n        return ancestors;\n    }\n    // add all ancestors\n    let m = stateNode.parent;\n    while(m && m !== toStateNode){\n        ancestors.push(m);\n        m = m.parent;\n    }\n    return ancestors;\n}\nfunction getAllStateNodes(stateNodes) {\n    const nodeSet = new Set(stateNodes);\n    const adjList = getAdjList(nodeSet);\n    // add descendants\n    for (const s of nodeSet){\n        // if previously active, add existing child nodes\n        if (s.type === \"compound\" && (!adjList.get(s) || !adjList.get(s).length)) {\n            getInitialStateNodesWithTheirAncestors(s).forEach((sn)=>nodeSet.add(sn));\n        } else {\n            if (s.type === \"parallel\") {\n                for (const child of getChildren(s)){\n                    if (child.type === \"history\") {\n                        continue;\n                    }\n                    if (!nodeSet.has(child)) {\n                        const initialStates = getInitialStateNodesWithTheirAncestors(child);\n                        for (const initialStateNode of initialStates){\n                            nodeSet.add(initialStateNode);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // add all ancestors\n    for (const s of nodeSet){\n        let m = s.parent;\n        while(m){\n            nodeSet.add(m);\n            m = m.parent;\n        }\n    }\n    return nodeSet;\n}\nfunction getValueFromAdj(baseNode, adjList) {\n    const childStateNodes = adjList.get(baseNode);\n    if (!childStateNodes) {\n        return {}; // todo: fix?\n    }\n    if (baseNode.type === \"compound\") {\n        const childStateNode = childStateNodes[0];\n        if (childStateNode) {\n            if (isAtomicStateNode(childStateNode)) {\n                return childStateNode.key;\n            }\n        } else {\n            return {};\n        }\n    }\n    const stateValue = {};\n    for (const childStateNode of childStateNodes){\n        stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n    }\n    return stateValue;\n}\nfunction getAdjList(stateNodes) {\n    const adjList = new Map();\n    for (const s of stateNodes){\n        if (!adjList.has(s)) {\n            adjList.set(s, []);\n        }\n        if (s.parent) {\n            if (!adjList.has(s.parent)) {\n                adjList.set(s.parent, []);\n            }\n            adjList.get(s.parent).push(s);\n        }\n    }\n    return adjList;\n}\nfunction getStateValue(rootNode, stateNodes) {\n    const config = getAllStateNodes(stateNodes);\n    return getValueFromAdj(rootNode, getAdjList(config));\n}\nfunction isInFinalState(stateNodeSet, stateNode) {\n    if (stateNode.type === \"compound\") {\n        return getChildren(stateNode).some((s)=>s.type === \"final\" && stateNodeSet.has(s));\n    }\n    if (stateNode.type === \"parallel\") {\n        return getChildren(stateNode).every((sn)=>isInFinalState(stateNodeSet, sn));\n    }\n    return stateNode.type === \"final\";\n}\nconst isStateId = (str)=>str[0] === STATE_IDENTIFIER;\nfunction getCandidates(stateNode, receivedEventType) {\n    const candidates = stateNode.transitions.get(receivedEventType) || [\n        ...stateNode.transitions.keys()\n    ].filter((eventDescriptor)=>{\n        // check if transition is a wildcard transition,\n        // which matches any non-transient events\n        if (eventDescriptor === WILDCARD) {\n            return true;\n        }\n        if (!eventDescriptor.endsWith(\".*\")) {\n            return false;\n        }\n        if (/.*\\*.+/.test(eventDescriptor)) {\n            console.warn(`Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"${eventDescriptor}\" event.`);\n        }\n        const partialEventTokens = eventDescriptor.split(\".\");\n        const eventTokens = receivedEventType.split(\".\");\n        for(let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++){\n            const partialEventToken = partialEventTokens[tokenIndex];\n            const eventToken = eventTokens[tokenIndex];\n            if (partialEventToken === \"*\") {\n                const isLastToken = tokenIndex === partialEventTokens.length - 1;\n                if (!isLastToken) {\n                    console.warn(`Infix wildcards in transition events are not allowed. Check the \"${eventDescriptor}\" transition.`);\n                }\n                return isLastToken;\n            }\n            if (partialEventToken !== eventToken) {\n                return false;\n            }\n        }\n        return true;\n    }).sort((a, b)=>b.length - a.length).flatMap((key)=>stateNode.transitions.get(key));\n    return candidates;\n}\n/** All delayed transitions from the config. */ function getDelayedTransitions(stateNode) {\n    const afterConfig = stateNode.config.after;\n    if (!afterConfig) {\n        return [];\n    }\n    const mutateEntryExit = (delay)=>{\n        const afterEvent = createAfterEvent(delay, stateNode.id);\n        const eventType = afterEvent.type;\n        stateNode.entry.push(raise(afterEvent, {\n            id: eventType,\n            delay\n        }));\n        stateNode.exit.push(cancel(eventType));\n        return eventType;\n    };\n    const delayedTransitions = Object.keys(afterConfig).flatMap((delay)=>{\n        const configTransition = afterConfig[delay];\n        const resolvedTransition = typeof configTransition === \"string\" ? {\n            target: configTransition\n        } : configTransition;\n        const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n        const eventType = mutateEntryExit(resolvedDelay);\n        return toArray(resolvedTransition).map((transition)=>({\n                ...transition,\n                event: eventType,\n                delay: resolvedDelay\n            }));\n    });\n    return delayedTransitions.map((delayedTransition)=>{\n        const { delay } = delayedTransition;\n        return {\n            ...formatTransition(stateNode, delayedTransition.event, delayedTransition),\n            delay\n        };\n    });\n}\nfunction formatTransition(stateNode, descriptor, transitionConfig) {\n    const normalizedTarget = normalizeTarget(transitionConfig.target);\n    const reenter = transitionConfig.reenter ?? false;\n    const target = resolveTarget(stateNode, normalizedTarget);\n    // TODO: should this be part of a lint rule instead?\n    if (transitionConfig.cond) {\n        throw new Error(`State \"${stateNode.id}\" has declared \\`cond\\` for one of its transitions. This property has been renamed to \\`guard\\`. Please update your code.`);\n    }\n    const transition = {\n        ...transitionConfig,\n        actions: toArray(transitionConfig.actions),\n        guard: transitionConfig.guard,\n        target,\n        source: stateNode,\n        reenter,\n        eventType: descriptor,\n        toJSON: ()=>({\n                ...transition,\n                source: `#${stateNode.id}`,\n                target: target ? target.map((t)=>`#${t.id}`) : undefined\n            })\n    };\n    return transition;\n}\nfunction formatTransitions(stateNode) {\n    const transitions = new Map();\n    if (stateNode.config.on) {\n        for (const descriptor of Object.keys(stateNode.config.on)){\n            if (descriptor === NULL_EVENT) {\n                throw new Error('Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.');\n            }\n            const transitionsConfig = stateNode.config.on[descriptor];\n            transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n    }\n    if (stateNode.config.onDone) {\n        const descriptor = `xstate.done.state.${stateNode.id}`;\n        transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));\n    }\n    for (const invokeDef of stateNode.invoke){\n        if (invokeDef.onDone) {\n            const descriptor = `xstate.done.actor.${invokeDef.id}`;\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n        if (invokeDef.onError) {\n            const descriptor = `xstate.error.actor.${invokeDef.id}`;\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n        if (invokeDef.onSnapshot) {\n            const descriptor = `xstate.snapshot.${invokeDef.id}`;\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n    }\n    for (const delayedTransition of stateNode.after){\n        let existing = transitions.get(delayedTransition.eventType);\n        if (!existing) {\n            existing = [];\n            transitions.set(delayedTransition.eventType, existing);\n        }\n        existing.push(delayedTransition);\n    }\n    return transitions;\n}\nfunction formatInitialTransition(stateNode, _target) {\n    const resolvedTarget = typeof _target === \"string\" ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : undefined;\n    if (!resolvedTarget && _target) {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n        `Initial state node \"${_target}\" not found on parent state node #${stateNode.id}`);\n    }\n    const transition = {\n        source: stateNode,\n        actions: !_target || typeof _target === \"string\" ? [] : toArray(_target.actions),\n        eventType: null,\n        reenter: false,\n        target: resolvedTarget ? [\n            resolvedTarget\n        ] : [],\n        toJSON: ()=>({\n                ...transition,\n                source: `#${stateNode.id}`,\n                target: resolvedTarget ? [\n                    `#${resolvedTarget.id}`\n                ] : []\n            })\n    };\n    return transition;\n}\nfunction resolveTarget(stateNode, targets) {\n    if (targets === undefined) {\n        // an undefined target signals that the state node should not transition from that state when receiving that event\n        return undefined;\n    }\n    return targets.map((target)=>{\n        if (typeof target !== \"string\") {\n            return target;\n        }\n        if (isStateId(target)) {\n            return stateNode.machine.getStateNodeById(target);\n        }\n        const isInternalTarget = target[0] === STATE_DELIMITER;\n        // If internal target is defined on machine,\n        // do not include machine key on target\n        if (isInternalTarget && !stateNode.parent) {\n            return getStateNodeByPath(stateNode, target.slice(1));\n        }\n        const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n        if (stateNode.parent) {\n            try {\n                const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);\n                return targetStateNode;\n            } catch (err) {\n                throw new Error(`Invalid transition definition for state node '${stateNode.id}':\\n${err.message}`);\n            }\n        } else {\n            throw new Error(`Invalid target: \"${target}\" is not a valid target from the root node. Did you mean \".${target}\"?`);\n        }\n    });\n}\nfunction resolveHistoryDefaultTransition(stateNode) {\n    const normalizedTarget = normalizeTarget(stateNode.config.target);\n    if (!normalizedTarget) {\n        return stateNode.parent.initial;\n    }\n    return {\n        target: normalizedTarget.map((t)=>typeof t === \"string\" ? getStateNodeByPath(stateNode.parent, t) : t)\n    };\n}\nfunction isHistoryNode(stateNode) {\n    return stateNode.type === \"history\";\n}\nfunction getInitialStateNodesWithTheirAncestors(stateNode) {\n    const states = getInitialStateNodes(stateNode);\n    for (const initialState of states){\n        for (const ancestor of getProperAncestors(initialState, stateNode)){\n            states.add(ancestor);\n        }\n    }\n    return states;\n}\nfunction getInitialStateNodes(stateNode) {\n    const set = new Set();\n    function iter(descStateNode) {\n        if (set.has(descStateNode)) {\n            return;\n        }\n        set.add(descStateNode);\n        if (descStateNode.type === \"compound\") {\n            iter(descStateNode.initial.target[0]);\n        } else if (descStateNode.type === \"parallel\") {\n            for (const child of getChildren(descStateNode)){\n                iter(child);\n            }\n        }\n    }\n    iter(stateNode);\n    return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */ function getStateNode(stateNode, stateKey) {\n    if (isStateId(stateKey)) {\n        return stateNode.machine.getStateNodeById(stateKey);\n    }\n    if (!stateNode.states) {\n        throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);\n    }\n    const result = stateNode.states[stateKey];\n    if (!result) {\n        throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);\n    }\n    return result;\n}\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */ function getStateNodeByPath(stateNode, statePath) {\n    if (typeof statePath === \"string\" && isStateId(statePath)) {\n        try {\n            return stateNode.machine.getStateNodeById(statePath);\n        } catch  {\n        // try individual paths\n        // throw e;\n        }\n    }\n    const arrayStatePath = toStatePath(statePath).slice();\n    let currentStateNode = stateNode;\n    while(arrayStatePath.length){\n        const key = arrayStatePath.shift();\n        if (!key.length) {\n            break;\n        }\n        currentStateNode = getStateNode(currentStateNode, key);\n    }\n    return currentStateNode;\n}\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */ function getStateNodes(stateNode, stateValue) {\n    if (typeof stateValue === \"string\") {\n        const childStateNode = stateNode.states[stateValue];\n        if (!childStateNode) {\n            throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);\n        }\n        return [\n            stateNode,\n            childStateNode\n        ];\n    }\n    const childStateKeys = Object.keys(stateValue);\n    const childStateNodes = childStateKeys.map((subStateKey)=>getStateNode(stateNode, subStateKey)).filter(Boolean);\n    return [\n        stateNode.machine.root,\n        stateNode\n    ].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey)=>{\n        const subStateNode = getStateNode(stateNode, subStateKey);\n        if (!subStateNode) {\n            return allSubStateNodes;\n        }\n        const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);\n        return allSubStateNodes.concat(subStateNodes);\n    }, []));\n}\nfunction transitionAtomicNode(stateNode, stateValue, snapshot, event) {\n    const childStateNode = getStateNode(stateNode, stateValue);\n    const next = childStateNode.next(snapshot, event);\n    if (!next || !next.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return next;\n}\nfunction transitionCompoundNode(stateNode, stateValue, snapshot, event) {\n    const subStateKeys = Object.keys(stateValue);\n    const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n    const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);\n    if (!next || !next.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return next;\n}\nfunction transitionParallelNode(stateNode, stateValue, snapshot, event) {\n    const allInnerTransitions = [];\n    for (const subStateKey of Object.keys(stateValue)){\n        const subStateValue = stateValue[subStateKey];\n        if (!subStateValue) {\n            continue;\n        }\n        const subStateNode = getStateNode(stateNode, subStateKey);\n        const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);\n        if (innerTransitions) {\n            allInnerTransitions.push(...innerTransitions);\n        }\n    }\n    if (!allInnerTransitions.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return allInnerTransitions;\n}\nfunction transitionNode(stateNode, stateValue, snapshot, event) {\n    // leaf node\n    if (typeof stateValue === \"string\") {\n        return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n    }\n    // compound node\n    if (Object.keys(stateValue).length === 1) {\n        return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n    }\n    // parallel node\n    return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\nfunction getHistoryNodes(stateNode) {\n    return Object.keys(stateNode.states).map((key)=>stateNode.states[key]).filter((sn)=>sn.type === \"history\");\n}\nfunction isDescendant(childStateNode, parentStateNode) {\n    let marker = childStateNode;\n    while(marker.parent && marker.parent !== parentStateNode){\n        marker = marker.parent;\n    }\n    return marker.parent === parentStateNode;\n}\nfunction hasIntersection(s1, s2) {\n    const set1 = new Set(s1);\n    const set2 = new Set(s2);\n    for (const item of set1){\n        if (set2.has(item)) {\n            return true;\n        }\n    }\n    for (const item of set2){\n        if (set1.has(item)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {\n    const filteredTransitions = new Set();\n    for (const t1 of enabledTransitions){\n        let t1Preempted = false;\n        const transitionsToRemove = new Set();\n        for (const t2 of filteredTransitions){\n            if (hasIntersection(computeExitSet([\n                t1\n            ], stateNodeSet, historyValue), computeExitSet([\n                t2\n            ], stateNodeSet, historyValue))) {\n                if (isDescendant(t1.source, t2.source)) {\n                    transitionsToRemove.add(t2);\n                } else {\n                    t1Preempted = true;\n                    break;\n                }\n            }\n        }\n        if (!t1Preempted) {\n            for (const t3 of transitionsToRemove){\n                filteredTransitions.delete(t3);\n            }\n            filteredTransitions.add(t1);\n        }\n    }\n    return Array.from(filteredTransitions);\n}\nfunction findLeastCommonAncestor(stateNodes) {\n    const [head, ...tail] = stateNodes;\n    for (const ancestor of getProperAncestors(head, undefined)){\n        if (tail.every((sn)=>isDescendant(sn, ancestor))) {\n            return ancestor;\n        }\n    }\n}\nfunction getEffectiveTargetStates(transition, historyValue) {\n    if (!transition.target) {\n        return [];\n    }\n    const targets = new Set();\n    for (const targetNode of transition.target){\n        if (isHistoryNode(targetNode)) {\n            if (historyValue[targetNode.id]) {\n                for (const node of historyValue[targetNode.id]){\n                    targets.add(node);\n                }\n            } else {\n                for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)){\n                    targets.add(node);\n                }\n            }\n        } else {\n            targets.add(targetNode);\n        }\n    }\n    return [\n        ...targets\n    ];\n}\nfunction getTransitionDomain(transition, historyValue) {\n    const targetStates = getEffectiveTargetStates(transition, historyValue);\n    if (!targetStates) {\n        return;\n    }\n    if (!transition.reenter && targetStates.every((target)=>target === transition.source || isDescendant(target, transition.source))) {\n        return transition.source;\n    }\n    const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n    if (lca) {\n        return lca;\n    }\n    // at this point we know that it's a root transition since LCA couldn't be found\n    if (transition.reenter) {\n        return;\n    }\n    return transition.source.machine.root;\n}\nfunction computeExitSet(transitions, stateNodeSet, historyValue) {\n    const statesToExit = new Set();\n    for (const t of transitions){\n        if (t.target?.length) {\n            const domain = getTransitionDomain(t, historyValue);\n            if (t.reenter && t.source === domain) {\n                statesToExit.add(domain);\n            }\n            for (const stateNode of stateNodeSet){\n                if (isDescendant(stateNode, domain)) {\n                    statesToExit.add(stateNode);\n                }\n            }\n        }\n    }\n    return [\n        ...statesToExit\n    ];\n}\nfunction areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {\n    if (prevStateNodes.length !== nextStateNodeSet.size) {\n        return false;\n    }\n    for (const node of prevStateNodes){\n        if (!nextStateNodeSet.has(node)) {\n            return false;\n        }\n    }\n    return true;\n}\n/** https://www.w3.org/TR/scxml/#microstepProcedure */ function microstep(transitions, currentSnapshot, actorScope, event, isInitial, internalQueue) {\n    if (!transitions.length) {\n        return currentSnapshot;\n    }\n    const mutStateNodeSet = new Set(currentSnapshot._nodes);\n    let historyValue = currentSnapshot.historyValue;\n    const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);\n    let nextState = currentSnapshot;\n    // Exit states\n    if (!isInitial) {\n        [nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor);\n    }\n    // Execute transition content\n    nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap((t)=>t.actions), internalQueue, undefined);\n    // Enter states\n    nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);\n    const nextStateNodes = [\n        ...mutStateNodeSet\n    ];\n    if (nextState.status === \"done\") {\n        nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a, b)=>b.order - a.order).flatMap((state)=>state.exit), internalQueue, undefined);\n    }\n    // eslint-disable-next-line no-useless-catch\n    try {\n        if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {\n            return nextState;\n        }\n        return cloneMachineSnapshot(nextState, {\n            _nodes: nextStateNodes,\n            historyValue\n        });\n    } catch (e) {\n        // TODO: Refactor this once proper error handling is implemented.\n        // See https://github.com/statelyai/rfcs/pull/4\n        throw e;\n    }\n}\nfunction getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {\n    if (rootNode.output === undefined) {\n        return;\n    }\n    const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== undefined && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : undefined);\n    return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);\n}\nfunction enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {\n    let nextSnapshot = currentSnapshot;\n    const statesToEnter = new Set();\n    // those are states that were directly targeted or indirectly targeted by the explicit target\n    // in other words, those are states for which initial actions should be executed\n    // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n    const statesForDefaultEntry = new Set();\n    computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);\n    // In the initial state, the root state node is \"entered\".\n    if (isInitial) {\n        statesForDefaultEntry.add(currentSnapshot.machine.root);\n    }\n    const completedNodes = new Set();\n    for (const stateNodeToEnter of [\n        ...statesToEnter\n    ].sort((a, b)=>a.order - b.order)){\n        mutStateNodeSet.add(stateNodeToEnter);\n        const actions = [];\n        // Add entry actions\n        actions.push(...stateNodeToEnter.entry);\n        for (const invokeDef of stateNodeToEnter.invoke){\n            actions.push(spawnChild(invokeDef.src, {\n                ...invokeDef,\n                syncSnapshot: !!invokeDef.onSnapshot\n            }));\n        }\n        if (statesForDefaultEntry.has(stateNodeToEnter)) {\n            const initialActions = stateNodeToEnter.initial.actions;\n            actions.push(...initialActions);\n        }\n        nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map((invokeDef)=>invokeDef.id));\n        if (stateNodeToEnter.type === \"final\") {\n            const parent = stateNodeToEnter.parent;\n            let ancestorMarker = parent?.type === \"parallel\" ? parent : parent?.parent;\n            let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n            if (parent?.type === \"compound\") {\n                internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== undefined ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : undefined));\n            }\n            while(ancestorMarker?.type === \"parallel\" && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)){\n                completedNodes.add(ancestorMarker);\n                internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n                rootCompletionNode = ancestorMarker;\n                ancestorMarker = ancestorMarker.parent;\n            }\n            if (ancestorMarker) {\n                continue;\n            }\n            nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n                status: \"done\",\n                output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)\n            });\n        }\n    }\n    return nextSnapshot;\n}\nfunction computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {\n    for (const t of transitions){\n        const domain = getTransitionDomain(t, historyValue);\n        for (const s of t.target || []){\n            if (!isHistoryNode(s) && // if the target is different than the source then it will *definitely* be entered\n            (t.source !== s || // we know that the domain can't lie within the source\n            // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n            t.source !== domain || // reentering transitions always enter the target, even if it's the source itself\n            t.reenter)) {\n                statesToEnter.add(s);\n                statesForDefaultEntry.add(s);\n            }\n            addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n        }\n        const targetStates = getEffectiveTargetStates(t, historyValue);\n        for (const s of targetStates){\n            const ancestors = getProperAncestors(s, domain);\n            if (domain?.type === \"parallel\") {\n                ancestors.push(domain);\n            }\n            addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t.source.parent && t.reenter ? undefined : domain);\n        }\n    }\n}\nfunction addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {\n    if (isHistoryNode(stateNode)) {\n        if (historyValue[stateNode.id]) {\n            const historyStateNodes = historyValue[stateNode.id];\n            for (const s of historyStateNodes){\n                statesToEnter.add(s);\n                addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n            }\n            for (const s of historyStateNodes){\n                addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n            }\n        } else {\n            const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);\n            for (const s of historyDefaultTransition.target){\n                statesToEnter.add(s);\n                if (historyDefaultTransition === stateNode.parent?.initial) {\n                    statesForDefaultEntry.add(stateNode.parent);\n                }\n                addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n            }\n            for (const s of historyDefaultTransition.target){\n                addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n            }\n        }\n    } else {\n        if (stateNode.type === \"compound\") {\n            const [initialState] = stateNode.initial.target;\n            if (!isHistoryNode(initialState)) {\n                statesToEnter.add(initialState);\n                statesForDefaultEntry.add(initialState);\n            }\n            addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);\n            addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);\n        } else {\n            if (stateNode.type === \"parallel\") {\n                for (const child of getChildren(stateNode).filter((sn)=>!isHistoryNode(sn))){\n                    if (![\n                        ...statesToEnter\n                    ].some((s)=>isDescendant(s, child))) {\n                        if (!isHistoryNode(child)) {\n                            statesToEnter.add(child);\n                            statesForDefaultEntry.add(child);\n                        }\n                        addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n                    }\n                }\n            }\n        }\n    }\n}\nfunction addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {\n    for (const anc of ancestors){\n        if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n            statesToEnter.add(anc);\n        }\n        if (anc.type === \"parallel\") {\n            for (const child of getChildren(anc).filter((sn)=>!isHistoryNode(sn))){\n                if (![\n                    ...statesToEnter\n                ].some((s)=>isDescendant(s, child))) {\n                    statesToEnter.add(child);\n                    addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n                }\n            }\n        }\n    }\n}\nfunction addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {\n    addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));\n}\nfunction exitStates(currentSnapshot, event, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {\n    let nextSnapshot = currentSnapshot;\n    const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);\n    statesToExit.sort((a, b)=>b.order - a.order);\n    let changedHistory;\n    // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n    for (const exitStateNode of statesToExit){\n        for (const historyNode of getHistoryNodes(exitStateNode)){\n            let predicate;\n            if (historyNode.history === \"deep\") {\n                predicate = (sn)=>isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n            } else {\n                predicate = (sn)=>{\n                    return sn.parent === exitStateNode;\n                };\n            }\n            changedHistory ??= {\n                ...historyValue\n            };\n            changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);\n        }\n    }\n    for (const s of statesToExit){\n        nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [\n            ...s.exit,\n            ...s.invoke.map((def)=>stopChild(def.id))\n        ], internalQueue, undefined);\n        mutStateNodeSet.delete(s);\n    }\n    return [\n        nextSnapshot,\n        changedHistory || historyValue\n    ];\n}\nfunction getAction(machine, actionType) {\n    return machine.implementations.actions[actionType];\n}\nfunction resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {\n    const { machine } = currentSnapshot;\n    let intermediateSnapshot = currentSnapshot;\n    for (const action of actions){\n        const isInline = typeof action === \"function\";\n        const resolvedAction = isInline ? action : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n        getAction(machine, typeof action === \"string\" ? action : action.type);\n        const actionArgs = {\n            context: intermediateSnapshot.context,\n            event,\n            self: actorScope.self,\n            system: actorScope.system\n        };\n        const actionParams = isInline || typeof action === \"string\" ? undefined : \"params\" in action ? typeof action.params === \"function\" ? action.params({\n            context: intermediateSnapshot.context,\n            event\n        }) : action.params : undefined;\n        if (!resolvedAction || !(\"resolve\" in resolvedAction)) {\n            actorScope.actionExecutor({\n                type: typeof action === \"string\" ? action : typeof action === \"object\" ? action.type : action.name || \"(anonymous)\",\n                info: actionArgs,\n                params: actionParams,\n                exec: resolvedAction\n            });\n            continue;\n        }\n        const builtinAction = resolvedAction;\n        const [nextState, params, actions] = builtinAction.resolve(actorScope, intermediateSnapshot, actionArgs, actionParams, resolvedAction, // this holds all params\n        extra);\n        intermediateSnapshot = nextState;\n        if (\"retryResolve\" in builtinAction) {\n            retries?.push([\n                builtinAction,\n                params\n            ]);\n        }\n        if (\"execute\" in builtinAction) {\n            actorScope.actionExecutor({\n                type: builtinAction.type,\n                info: actionArgs,\n                params,\n                exec: builtinAction.execute.bind(null, actorScope, params)\n            });\n        }\n        if (actions) {\n            intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions, extra, retries);\n        }\n    }\n    return intermediateSnapshot;\n}\nfunction resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {\n    const retries = deferredActorIds ? [] : undefined;\n    const nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {\n        internalQueue,\n        deferredActorIds\n    }, retries);\n    retries?.forEach(([builtinAction, params])=>{\n        builtinAction.retryResolve(actorScope, nextState, params);\n    });\n    return nextState;\n}\nfunction macrostep(snapshot, event, actorScope, internalQueue) {\n    if (event.type === WILDCARD) {\n        throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);\n    }\n    let nextSnapshot = snapshot;\n    const microstates = [];\n    function addMicrostate(microstate, event, transitions) {\n        actorScope.system._sendInspectionEvent({\n            type: \"@xstate.microstep\",\n            actorRef: actorScope.self,\n            event,\n            snapshot: microstate,\n            _transitions: transitions\n        });\n        microstates.push(microstate);\n    }\n    // Handle stop event\n    if (event.type === XSTATE_STOP) {\n        nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {\n            status: \"stopped\"\n        });\n        addMicrostate(nextSnapshot, event, []);\n        return {\n            snapshot: nextSnapshot,\n            microstates\n        };\n    }\n    let nextEvent = event;\n    // Assume the state is at rest (no raised events)\n    // Determine the next state based on the next microstep\n    if (nextEvent.type !== XSTATE_INIT) {\n        const currentEvent = nextEvent;\n        const isErr = isErrorActorEvent(currentEvent);\n        const transitions = selectTransitions(currentEvent, nextSnapshot);\n        if (isErr && !transitions.length) {\n            // TODO: we should likely only allow transitions selected by very explicit descriptors\n            // `*` shouldn't be matched, likely `xstate.error.*` shouldnt be either\n            // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n            nextSnapshot = cloneMachineSnapshot(snapshot, {\n                status: \"error\",\n                error: currentEvent.error\n            });\n            addMicrostate(nextSnapshot, currentEvent, []);\n            return {\n                snapshot: nextSnapshot,\n                microstates\n            };\n        }\n        nextSnapshot = microstep(transitions, snapshot, actorScope, nextEvent, false, // isInitial\n        internalQueue);\n        addMicrostate(nextSnapshot, currentEvent, transitions);\n    }\n    let shouldSelectEventlessTransitions = true;\n    while(nextSnapshot.status === \"active\"){\n        let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];\n        // eventless transitions should always be selected after selecting *regular* transitions\n        // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n        const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n        if (!enabledTransitions.length) {\n            if (!internalQueue.length) {\n                break;\n            }\n            nextEvent = internalQueue.shift();\n            enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n        }\n        nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);\n        shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n        addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n    }\n    if (nextSnapshot.status !== \"active\") {\n        stopChildren(nextSnapshot, nextEvent, actorScope);\n    }\n    return {\n        snapshot: nextSnapshot,\n        microstates\n    };\n}\nfunction stopChildren(nextState, event, actorScope) {\n    return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map((child)=>stopChild(child)), [], undefined);\n}\nfunction selectTransitions(event, nextState) {\n    return nextState.machine.getTransitionData(nextState, event);\n}\nfunction selectEventlessTransitions(nextState, event) {\n    const enabledTransitionSet = new Set();\n    const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n    for (const stateNode of atomicStates){\n        loop: for (const s of [\n            stateNode\n        ].concat(getProperAncestors(stateNode, undefined))){\n            if (!s.always) {\n                continue;\n            }\n            for (const transition of s.always){\n                if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {\n                    enabledTransitionSet.add(transition);\n                    break loop;\n                }\n            }\n        }\n    }\n    return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);\n}\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */ function resolveStateValue(rootNode, stateValue) {\n    const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n    return getStateValue(rootNode, [\n        ...allStateNodes\n    ]);\n}\nfunction isMachineSnapshot(value) {\n    return !!value && typeof value === \"object\" && \"machine\" in value && \"value\" in value;\n}\nconst machineSnapshotMatches = function matches(testValue) {\n    return matchesState(testValue, this.value);\n};\nconst machineSnapshotHasTag = function hasTag(tag) {\n    return this.tags.has(tag);\n};\nconst machineSnapshotCan = function can(event) {\n    if (!this.machine) {\n        console.warn(`state.can(...) used outside of a machine-created State object; this will always return false.`);\n    }\n    const transitionData = this.machine.getTransitionData(this, event);\n    return !!transitionData?.length && // Check that at least one transition is not forbidden\n    transitionData.some((t)=>t.target !== undefined || t.actions.length);\n};\nconst machineSnapshotToJSON = function toJSON() {\n    const { _nodes: nodes, tags, machine, getMeta, toJSON, can, hasTag, matches, ...jsonValues } = this;\n    return {\n        ...jsonValues,\n        tags: Array.from(tags)\n    };\n};\nconst machineSnapshotGetMeta = function getMeta() {\n    return this._nodes.reduce((acc, stateNode)=>{\n        if (stateNode.meta !== undefined) {\n            acc[stateNode.id] = stateNode.meta;\n        }\n        return acc;\n    }, {});\n};\nfunction createMachineSnapshot(config, machine) {\n    return {\n        status: config.status,\n        output: config.output,\n        error: config.error,\n        machine,\n        context: config.context,\n        _nodes: config._nodes,\n        value: getStateValue(machine.root, config._nodes),\n        tags: new Set(config._nodes.flatMap((sn)=>sn.tags)),\n        children: config.children,\n        historyValue: config.historyValue || {},\n        matches: machineSnapshotMatches,\n        hasTag: machineSnapshotHasTag,\n        can: machineSnapshotCan,\n        getMeta: machineSnapshotGetMeta,\n        toJSON: machineSnapshotToJSON\n    };\n}\nfunction cloneMachineSnapshot(snapshot, config = {}) {\n    return createMachineSnapshot({\n        ...snapshot,\n        ...config\n    }, snapshot.machine);\n}\nfunction getPersistedSnapshot(snapshot, options) {\n    const { _nodes: nodes, tags, machine, children, context, can, hasTag, matches, getMeta, toJSON, ...jsonValues } = snapshot;\n    const childrenJson = {};\n    for(const id in children){\n        const child = children[id];\n        if (typeof child.src !== \"string\" && (!options || !(\"__unsafeAllowInlineActors\" in options))) {\n            throw new Error(\"An inline child actor cannot be persisted.\");\n        }\n        childrenJson[id] = {\n            snapshot: child.getPersistedSnapshot(options),\n            src: child.src,\n            systemId: child._systemId,\n            syncSnapshot: child._syncSnapshot\n        };\n    }\n    const persisted = {\n        ...jsonValues,\n        context: persistContext(context),\n        children: childrenJson\n    };\n    return persisted;\n}\nfunction persistContext(contextPart) {\n    let copy;\n    for(const key in contextPart){\n        const value = contextPart[key];\n        if (value && typeof value === \"object\") {\n            if (\"sessionId\" in value && \"send\" in value && \"ref\" in value) {\n                copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n                    ...contextPart\n                };\n                copy[key] = {\n                    xstate$$type: $$ACTOR_TYPE,\n                    id: value.id\n                };\n            } else {\n                const result = persistContext(value);\n                if (result !== value) {\n                    copy ??= Array.isArray(contextPart) ? contextPart.slice() : {\n                        ...contextPart\n                    };\n                    copy[key] = result;\n                }\n            }\n        }\n    }\n    return copy ?? contextPart;\n}\nfunction resolveRaise(_, snapshot, args, actionParams, { event: eventOrExpr, id, delay }, { internalQueue }) {\n    const delaysMap = snapshot.machine.implementations.delays;\n    if (typeof eventOrExpr === \"string\") {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Only event objects may be used with raise; use raise({ type: \"${eventOrExpr}\" }) instead`);\n    }\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    let resolvedDelay;\n    if (typeof delay === \"string\") {\n        const configDelay = delaysMap && delaysMap[delay];\n        resolvedDelay = typeof configDelay === \"function\" ? configDelay(args, actionParams) : configDelay;\n    } else {\n        resolvedDelay = typeof delay === \"function\" ? delay(args, actionParams) : delay;\n    }\n    if (typeof resolvedDelay !== \"number\") {\n        internalQueue.push(resolvedEvent);\n    }\n    return [\n        snapshot,\n        {\n            event: resolvedEvent,\n            id,\n            delay: resolvedDelay\n        },\n        undefined\n    ];\n}\nfunction executeRaise(actorScope, params) {\n    const { event, delay, id } = params;\n    if (typeof delay === \"number\") {\n        actorScope.defer(()=>{\n            const self = actorScope.self;\n            actorScope.system.scheduler.schedule(self, self, event, delay, id);\n        });\n        return;\n    }\n}\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */ function raise(eventOrExpr, options) {\n    if (executingCustomAction) {\n        console.warn(\"Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function raise(_args, _params) {\n        {\n            throw new Error(`This isn't supposed to be called`);\n        }\n    }\n    raise.type = \"xstate.raise\";\n    raise.event = eventOrExpr;\n    raise.id = options?.id;\n    raise.delay = options?.delay;\n    raise.resolve = resolveRaise;\n    raise.execute = executeRaise;\n    return raise;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvcmFpc2UtMWRiMjdhODIuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRFO0FBRTVFLE1BQU1DO0lBQ0pDLFlBQVlDLFFBQVEsQ0FBRTtRQUNwQixJQUFJLENBQUNBLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNmO0lBQ0FDLFFBQVE7UUFDTixJQUFJLENBQUNILE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0ksS0FBSztJQUNaO0lBQ0FDLFFBQVE7UUFDTix5RUFBeUU7UUFDekUsc0ZBQXNGO1FBQ3RGLElBQUksSUFBSSxDQUFDSixRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDQSxRQUFRLENBQUNLLElBQUksR0FBRztZQUNyQixJQUFJLENBQUNKLEtBQUssR0FBRyxJQUFJLENBQUNELFFBQVE7UUFDNUI7SUFDRjtJQUNBTSxRQUFRQyxLQUFLLEVBQUU7UUFDYixNQUFNQyxXQUFXO1lBQ2ZDLE9BQU9GO1lBQ1BGLE1BQU07UUFDUjtRQUNBLElBQUksSUFBSSxDQUFDTCxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDQyxLQUFLLENBQUNJLElBQUksR0FBR0c7WUFDbEIsSUFBSSxDQUFDUCxLQUFLLEdBQUdPO1lBQ2I7UUFDRjtRQUNBLElBQUksQ0FBQ1IsUUFBUSxHQUFHUTtRQUNoQixJQUFJLENBQUNQLEtBQUssR0FBR087UUFDYixJQUFJLElBQUksQ0FBQ1QsT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQ0ksS0FBSztRQUNaO0lBQ0Y7SUFDQUEsUUFBUTtRQUNOLE1BQU8sSUFBSSxDQUFDSCxRQUFRLENBQUU7WUFDcEIsbUZBQW1GO1lBQ25GLDZFQUE2RTtZQUM3RSxN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bXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kaXN0L3JhaXNlLTFkYjI3YTgyLmRldmVsb3BtZW50LmVzbS5qcz9lNWU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRldlRvb2xzQWRhcHRlciB9IGZyb20gJy4uL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuY2xhc3MgTWFpbGJveCB7XG4gIGNvbnN0cnVjdG9yKF9wcm9jZXNzKSB7XG4gICAgdGhpcy5fcHJvY2VzcyA9IF9wcm9jZXNzO1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3QgPSBudWxsO1xuICB9XG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIC8vIHdlIGNhbid0IHNldCBfY3VycmVudCB0byBudWxsIGJlY2F1c2Ugd2UgbWlnaHQgYmUgY3VycmVudGx5IHByb2Nlc3NpbmdcbiAgICAvLyBhbmQgZW5xdWV1ZSBmb2xsb3dpbmcgY2xlYXIgc2hvdWxkbnQgc3RhcnQgcHJvY2Vzc2luZyB0aGUgZW5xdWV1ZWQgaXRlbSBpbW1lZGlhdGVseVxuICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50Lm5leHQgPSBudWxsO1xuICAgICAgdGhpcy5fbGFzdCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgfVxuICB9XG4gIGVucXVldWUoZXZlbnQpIHtcbiAgICBjb25zdCBlbnF1ZXVlZCA9IHtcbiAgICAgIHZhbHVlOiBldmVudCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICB0aGlzLl9sYXN0Lm5leHQgPSBlbnF1ZXVlZDtcbiAgICAgIHRoaXMuX2xhc3QgPSBlbnF1ZXVlZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudCA9IGVucXVldWVkO1xuICAgIHRoaXMuX2xhc3QgPSBlbnF1ZXVlZDtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICB9XG4gIGZsdXNoKCkge1xuICAgIHdoaWxlICh0aGlzLl9jdXJyZW50KSB7XG4gICAgICAvLyBhdG0gdGhlIGdpdmVuIF9wcm9jZXNzIGlzIHJlc3BvbnNpYmxlIGZvciBpbXBsZW1lbnRpbmcgcHJvcGVyIHRyeS9jYXRjaCBoYW5kbGluZ1xuICAgICAgLy8gd2UgYXNzdW1lIGhlcmUgdGhhdCB0aGlzIHdvbid0IHRocm93IGluIGEgd2F5IHRoYXQgY2FuIGFmZmVjdCB0aGlzIG1haWxib3hcbiAgICAgIGNvbnN0IGNvbnN1bWVkID0gdGhpcy5fY3VycmVudDtcbiAgICAgIHRoaXMuX3Byb2Nlc3MoY29uc3VtZWQudmFsdWUpO1xuICAgICAgdGhpcy5fY3VycmVudCA9IGNvbnN1bWVkLm5leHQ7XG4gICAgfVxuICAgIHRoaXMuX2xhc3QgPSBudWxsO1xuICB9XG59XG5cbmNvbnN0IFNUQVRFX0RFTElNSVRFUiA9ICcuJztcbmNvbnN0IFRBUkdFVExFU1NfS0VZID0gJyc7XG5jb25zdCBOVUxMX0VWRU5UID0gJyc7XG5jb25zdCBTVEFURV9JREVOVElGSUVSID0gJyMnO1xuY29uc3QgV0lMRENBUkQgPSAnKic7XG5jb25zdCBYU1RBVEVfSU5JVCA9ICd4c3RhdGUuaW5pdCc7XG5jb25zdCBYU1RBVEVfRVJST1IgPSAneHN0YXRlLmVycm9yJztcbmNvbnN0IFhTVEFURV9TVE9QID0gJ3hzdGF0ZS5zdG9wJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyBhbiBpbXBsaWNpdCBldmVudCB0aGF0IGlzIHNlbnQgYWZ0ZXIgdGhlXG4gKiBzcGVjaWZpZWQgYGRlbGF5YC5cbiAqXG4gKiBAcGFyYW0gZGVsYXlSZWYgVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICogQHBhcmFtIGlkIFRoZSBzdGF0ZSBub2RlIElEIHdoZXJlIHRoaXMgZXZlbnQgaXMgaGFuZGxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVBZnRlckV2ZW50KGRlbGF5UmVmLCBpZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGB4c3RhdGUuYWZ0ZXIuJHtkZWxheVJlZn0uJHtpZH1gXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBldmVudCB0aGF0IHJlcHJlc2VudHMgdGhhdCBhIGZpbmFsIHN0YXRlIG5vZGUgaGFzIGJlZW4gcmVhY2hlZCBpblxuICogdGhlIHBhcmVudCBzdGF0ZSBub2RlLlxuICpcbiAqIEBwYXJhbSBpZCBUaGUgZmluYWwgc3RhdGUgbm9kZSdzIHBhcmVudCBzdGF0ZSBub2RlIGBpZGBcbiAqIEBwYXJhbSBvdXRwdXQgVGhlIGRhdGEgdG8gcGFzcyBpbnRvIHRoZSBldmVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVEb25lU3RhdGVFdmVudChpZCwgb3V0cHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5kb25lLnN0YXRlLiR7aWR9YCxcbiAgICBvdXRwdXRcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyB0aGF0IGFuIGludm9rZWQgc2VydmljZSBoYXMgdGVybWluYXRlZC5cbiAqXG4gKiBBbiBpbnZva2VkIHNlcnZpY2UgaXMgdGVybWluYXRlZCB3aGVuIGl0IGhhcyByZWFjaGVkIGEgdG9wLWxldmVsIGZpbmFsIHN0YXRlXG4gKiBub2RlLCBidXQgbm90IHdoZW4gaXQgaXMgY2FuY2VsZWQuXG4gKlxuICogQHBhcmFtIGludm9rZUlkIFRoZSBpbnZva2VkIHNlcnZpY2UgSURcbiAqIEBwYXJhbSBvdXRwdXQgVGhlIGRhdGEgdG8gcGFzcyBpbnRvIHRoZSBldmVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVEb25lQWN0b3JFdmVudChpbnZva2VJZCwgb3V0cHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5kb25lLmFjdG9yLiR7aW52b2tlSWR9YCxcbiAgICBvdXRwdXQsXG4gICAgYWN0b3JJZDogaW52b2tlSWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yQWN0b3JFdmVudChpZCwgZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBgeHN0YXRlLmVycm9yLmFjdG9yLiR7aWR9YCxcbiAgICBlcnJvcixcbiAgICBhY3RvcklkOiBpZFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5pdEV2ZW50KGlucHV0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogWFNUQVRFX0lOSVQsXG4gICAgaW5wdXRcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW4gYSBzZXBhcmF0ZVxuICogbWFjcm90YXNrLiBJdCBhbGxvd3MgdGhvc2UgZXJyb3JzIHRvIGJlIGRldGVjdGVkIGJ5IGdsb2JhbCBlcnJvciBoYW5kbGVycyBhbmRcbiAqIHJlcG9ydGVkIHRvIGJ1ZyB0cmFja2luZyBzZXJ2aWNlcyB3aXRob3V0IGludGVycnVwdGluZyBvdXIgb3duIHN0YWNrIG9mXG4gKiBleGVjdXRpb24uXG4gKlxuICogQHBhcmFtIGVyciBFcnJvciB0byBiZSB0aHJvd25cbiAqL1xuZnVuY3Rpb24gcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKSB7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59XG5cbmNvbnN0IHN5bWJvbE9ic2VydmFibGUgPSAoKCkgPT4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wub2JzZXJ2YWJsZSB8fCAnQEBvYnNlcnZhYmxlJykoKTtcblxuZnVuY3Rpb24gbWF0Y2hlc1N0YXRlKHBhcmVudFN0YXRlSWQsIGNoaWxkU3RhdGVJZCkge1xuICBjb25zdCBwYXJlbnRTdGF0ZVZhbHVlID0gdG9TdGF0ZVZhbHVlKHBhcmVudFN0YXRlSWQpO1xuICBjb25zdCBjaGlsZFN0YXRlVmFsdWUgPSB0b1N0YXRlVmFsdWUoY2hpbGRTdGF0ZUlkKTtcbiAgaWYgKHR5cGVvZiBjaGlsZFN0YXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJlbnRTdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNoaWxkU3RhdGVWYWx1ZSA9PT0gcGFyZW50U3RhdGVWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBQYXJlbnQgbW9yZSBzcGVjaWZpYyB0aGFuIGNoaWxkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcGFyZW50U3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyZW50U3RhdGVWYWx1ZSBpbiBjaGlsZFN0YXRlVmFsdWU7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmVudFN0YXRlVmFsdWUpLmV2ZXJ5KGtleSA9PiB7XG4gICAgaWYgKCEoa2V5IGluIGNoaWxkU3RhdGVWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXNTdGF0ZShwYXJlbnRTdGF0ZVZhbHVlW2tleV0sIGNoaWxkU3RhdGVWYWx1ZVtrZXldKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0b1N0YXRlUGF0aChzdGF0ZUlkKSB7XG4gIGlmIChpc0FycmF5KHN0YXRlSWQpKSB7XG4gICAgcmV0dXJuIHN0YXRlSWQ7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBzZWdtZW50ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVJZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdGF0ZUlkLmNoYXJDb2RlQXQoaSk7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAvLyBcXFxuICAgICAgY2FzZSA5MjpcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgc2VnbWVudCArPSBzdGF0ZUlkW2kgKyAxXTtcbiAgICAgICAgLy8gYW5kIHNraXAgb3ZlciBpdFxuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgLy8gLlxuICAgICAgY2FzZSA0NjpcbiAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICAgIHNlZ21lbnQgPSAnJztcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHNlZ21lbnQgKz0gc3RhdGVJZFtpXTtcbiAgfVxuICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvU3RhdGVWYWx1ZShzdGF0ZVZhbHVlKSB7XG4gIGlmIChpc01hY2hpbmVTbmFwc2hvdChzdGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBzdGF0ZVZhbHVlLnZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RhdGVWYWx1ZTtcbiAgfVxuICBjb25zdCBzdGF0ZVBhdGggPSB0b1N0YXRlUGF0aChzdGF0ZVZhbHVlKTtcbiAgcmV0dXJuIHBhdGhUb1N0YXRlVmFsdWUoc3RhdGVQYXRoKTtcbn1cbmZ1bmN0aW9uIHBhdGhUb1N0YXRlVmFsdWUoc3RhdGVQYXRoKSB7XG4gIGlmIChzdGF0ZVBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHN0YXRlUGF0aFswXTtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IHt9O1xuICBsZXQgbWFya2VyID0gdmFsdWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmIChpID09PSBzdGF0ZVBhdGgubGVuZ3RoIC0gMikge1xuICAgICAgbWFya2VyW3N0YXRlUGF0aFtpXV0gPSBzdGF0ZVBhdGhbaSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmV2aW91cyA9IG1hcmtlcjtcbiAgICAgIG1hcmtlciA9IHt9O1xuICAgICAgcHJldmlvdXNbc3RhdGVQYXRoW2ldXSA9IG1hcmtlcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbWFwVmFsdWVzKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBjb2xsZWN0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxlY3Rpb25LZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gY29sbGVjdGlvbktleXNbaV07XG4gICAgcmVzdWx0W2tleV0gPSBpdGVyYXRlZShjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbiwgaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvQXJyYXlTdHJpY3QodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBbdmFsdWVdO1xufVxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gdG9BcnJheVN0cmljdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlT3V0cHV0KG1hcHBlciwgY29udGV4dCwgZXZlbnQsIHNlbGYpIHtcbiAgaWYgKHR5cGVvZiBtYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWFwcGVyKHtcbiAgICAgIGNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIHNlbGZcbiAgICB9KTtcbiAgfVxuICBpZiAoISFtYXBwZXIgJiYgdHlwZW9mIG1hcHBlciA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnZhbHVlcyhtYXBwZXIpLnNvbWUodmFsID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY29uc29sZS53YXJuKGBEeW5hbWljYWxseSBtYXBwaW5nIHZhbHVlcyB0byBpbmRpdmlkdWFsIHByb3BlcnRpZXMgaXMgZGVwcmVjYXRlZC4gVXNlIGEgc2luZ2xlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWFwcGVkIG9iamVjdCBpbnN0ZWFkLlxcbkZvdW5kIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgd2hvc2UgdmFsdWVzIGFyZSBwb3NzaWJseSBtYXBwaW5nIGZ1bmN0aW9uczogJHtPYmplY3QuZW50cmllcyhtYXBwZXIpLmZpbHRlcigoWywgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgXFxuIC0gJHtrZXl9OiAke3ZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxuXFxzKi9nLCAnJyl9YCkuam9pbignJyl9YCk7XG4gIH1cbiAgcmV0dXJuIG1hcHBlcjtcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNFcnJvckFjdG9yRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgneHN0YXRlLmVycm9yLmFjdG9yJyk7XG59XG5mdW5jdGlvbiB0b1RyYW5zaXRpb25Db25maWdBcnJheShjb25maWdMaWtlKSB7XG4gIHJldHVybiB0b0FycmF5U3RyaWN0KGNvbmZpZ0xpa2UpLm1hcCh0cmFuc2l0aW9uTGlrZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2l0aW9uTGlrZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHRyYW5zaXRpb25MaWtlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB0cmFuc2l0aW9uTGlrZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zaXRpb25MaWtlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gVEFSR0VUTEVTU19LRVkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0b0FycmF5KHRhcmdldCk7XG59XG5mdW5jdGlvbiB0b09ic2VydmVyKG5leHRIYW5kbGVyLCBlcnJvckhhbmRsZXIsIGNvbXBsZXRpb25IYW5kbGVyKSB7XG4gIGNvbnN0IGlzT2JzZXJ2ZXIgPSB0eXBlb2YgbmV4dEhhbmRsZXIgPT09ICdvYmplY3QnO1xuICBjb25zdCBzZWxmID0gaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyIDogdW5kZWZpbmVkO1xuICByZXR1cm4ge1xuICAgIG5leHQ6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIubmV4dCA6IG5leHRIYW5kbGVyKT8uYmluZChzZWxmKSxcbiAgICBlcnJvcjogKGlzT2JzZXJ2ZXIgPyBuZXh0SGFuZGxlci5lcnJvciA6IGVycm9ySGFuZGxlcik/LmJpbmQoc2VsZiksXG4gICAgY29tcGxldGU6IChpc09ic2VydmVyID8gbmV4dEhhbmRsZXIuY29tcGxldGUgOiBjb21wbGV0aW9uSGFuZGxlcik/LmJpbmQoc2VsZilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUludm9rZUlkKHN0YXRlTm9kZUlkLCBpbmRleCkge1xuICByZXR1cm4gYCR7aW5kZXh9LiR7c3RhdGVOb2RlSWR9YDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZWZlcmVuY2VkQWN0b3IobWFjaGluZSwgc3JjKSB7XG4gIGNvbnN0IG1hdGNoID0gc3JjLm1hdGNoKC9eeHN0YXRlXFwuaW52b2tlXFwuKFxcZCspXFwuKC4qKS8pO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmFjdG9yc1tzcmNdO1xuICB9XG4gIGNvbnN0IFssIGluZGV4U3RyLCBub2RlSWRdID0gbWF0Y2g7XG4gIGNvbnN0IG5vZGUgPSBtYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQobm9kZUlkKTtcbiAgY29uc3QgaW52b2tlQ29uZmlnID0gbm9kZS5jb25maWcuaW52b2tlO1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoaW52b2tlQ29uZmlnKSA/IGludm9rZUNvbmZpZ1tpbmRleFN0cl0gOiBpbnZva2VDb25maWcpLnNyYztcbn1cbmZ1bmN0aW9uIGdldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMoc25hcHNob3QpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KFsuLi5zbmFwc2hvdC5fbm9kZXMuZmxhdE1hcChzbiA9PiBzbi5vd25FdmVudHMpXSldO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY2hlZHVsZWRFdmVudElkKGFjdG9yUmVmLCBpZCkge1xuICByZXR1cm4gYCR7YWN0b3JSZWYuc2Vzc2lvbklkfS4ke2lkfWA7XG59XG5sZXQgaWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZVN5c3RlbShyb290QWN0b3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGtleWVkQWN0b3JzID0gbmV3IE1hcCgpO1xuICBjb25zdCByZXZlcnNlS2V5ZWRBY3RvcnMgPSBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBpbnNwZWN0aW9uT2JzZXJ2ZXJzID0gbmV3IFNldCgpO1xuICBjb25zdCB0aW1lck1hcCA9IHt9O1xuICBjb25zdCB7XG4gICAgY2xvY2ssXG4gICAgbG9nZ2VyXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzY2hlZHVsZXIgPSB7XG4gICAgc2NoZWR1bGU6IChzb3VyY2UsIHRhcmdldCwgZXZlbnQsIGRlbGF5LCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpKSA9PiB7XG4gICAgICBjb25zdCBzY2hlZHVsZWRFdmVudCA9IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICBkZWxheSxcbiAgICAgICAgaWQsXG4gICAgICAgIHN0YXJ0ZWRBdDogRGF0ZS5ub3coKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50SWQgPSBjcmVhdGVTY2hlZHVsZWRFdmVudElkKHNvdXJjZSwgaWQpO1xuICAgICAgc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZEV2ZW50SWRdID0gc2NoZWR1bGVkRXZlbnQ7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gY2xvY2suc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aW1lck1hcFtzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgICAgZGVsZXRlIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgICAgc3lzdGVtLl9yZWxheShzb3VyY2UsIHRhcmdldCwgZXZlbnQpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgICAgdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF0gPSB0aW1lb3V0O1xuICAgIH0sXG4gICAgY2FuY2VsOiAoc291cmNlLCBpZCkgPT4ge1xuICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnRJZCA9IGNyZWF0ZVNjaGVkdWxlZEV2ZW50SWQoc291cmNlLCBpZCk7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICBkZWxldGUgdGltZXJNYXBbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICBkZWxldGUgc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgaWYgKHRpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbG9jay5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWxBbGw6IGFjdG9yUmVmID0+IHtcbiAgICAgIGZvciAoY29uc3Qgc2NoZWR1bGVkRXZlbnRJZCBpbiBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHMpIHtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnQgPSBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHNbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICAgIGlmIChzY2hlZHVsZWRFdmVudC5zb3VyY2UgPT09IGFjdG9yUmVmKSB7XG4gICAgICAgICAgc2NoZWR1bGVyLmNhbmNlbChhY3RvclJlZiwgc2NoZWR1bGVkRXZlbnQuaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBzZW5kSW5zcGVjdGlvbkV2ZW50ID0gZXZlbnQgPT4ge1xuICAgIGlmICghaW5zcGVjdGlvbk9ic2VydmVycy5zaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkSW5zcGVjdGlvbkV2ZW50ID0ge1xuICAgICAgLi4uZXZlbnQsXG4gICAgICByb290SWQ6IHJvb3RBY3Rvci5zZXNzaW9uSWRcbiAgICB9O1xuICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuZm9yRWFjaChvYnNlcnZlciA9PiBvYnNlcnZlci5uZXh0Py4ocmVzb2x2ZWRJbnNwZWN0aW9uRXZlbnQpKTtcbiAgfTtcbiAgY29uc3Qgc3lzdGVtID0ge1xuICAgIF9zbmFwc2hvdDoge1xuICAgICAgX3NjaGVkdWxlZEV2ZW50czogKG9wdGlvbnM/LnNuYXBzaG90ICYmIG9wdGlvbnMuc25hcHNob3Quc2NoZWR1bGVyKSA/PyB7fVxuICAgIH0sXG4gICAgX2Jvb2tJZDogKCkgPT4gYHg6JHtpZENvdW50ZXIrK31gLFxuICAgIF9yZWdpc3RlcjogKHNlc3Npb25JZCwgYWN0b3JSZWYpID0+IHtcbiAgICAgIGNoaWxkcmVuLnNldChzZXNzaW9uSWQsIGFjdG9yUmVmKTtcbiAgICAgIHJldHVybiBzZXNzaW9uSWQ7XG4gICAgfSxcbiAgICBfdW5yZWdpc3RlcjogYWN0b3JSZWYgPT4ge1xuICAgICAgY2hpbGRyZW4uZGVsZXRlKGFjdG9yUmVmLnNlc3Npb25JZCk7XG4gICAgICBjb25zdCBzeXN0ZW1JZCA9IHJldmVyc2VLZXllZEFjdG9ycy5nZXQoYWN0b3JSZWYpO1xuICAgICAgaWYgKHN5c3RlbUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5ZWRBY3RvcnMuZGVsZXRlKHN5c3RlbUlkKTtcbiAgICAgICAgcmV2ZXJzZUtleWVkQWN0b3JzLmRlbGV0ZShhY3RvclJlZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IHN5c3RlbUlkID0+IHtcbiAgICAgIHJldHVybiBrZXllZEFjdG9ycy5nZXQoc3lzdGVtSWQpO1xuICAgIH0sXG4gICAgX3NldDogKHN5c3RlbUlkLCBhY3RvclJlZikgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBrZXllZEFjdG9ycy5nZXQoc3lzdGVtSWQpO1xuICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nICE9PSBhY3RvclJlZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdG9yIHdpdGggc3lzdGVtIElEICcke3N5c3RlbUlkfScgYWxyZWFkeSBleGlzdHMuYCk7XG4gICAgICB9XG4gICAgICBrZXllZEFjdG9ycy5zZXQoc3lzdGVtSWQsIGFjdG9yUmVmKTtcbiAgICAgIHJldmVyc2VLZXllZEFjdG9ycy5zZXQoYWN0b3JSZWYsIHN5c3RlbUlkKTtcbiAgICB9LFxuICAgIGluc3BlY3Q6IG9ic2VydmVyT3JGbiA9PiB7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIob2JzZXJ2ZXJPckZuKTtcbiAgICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgIGluc3BlY3Rpb25PYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIF9zZW5kSW5zcGVjdGlvbkV2ZW50OiBzZW5kSW5zcGVjdGlvbkV2ZW50LFxuICAgIF9yZWxheTogKHNvdXJjZSwgdGFyZ2V0LCBldmVudCkgPT4ge1xuICAgICAgc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgICAgdHlwZTogJ0B4c3RhdGUuZXZlbnQnLFxuICAgICAgICBzb3VyY2VSZWY6IHNvdXJjZSxcbiAgICAgICAgYWN0b3JSZWY6IHRhcmdldCxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pO1xuICAgICAgdGFyZ2V0Ll9zZW5kKGV2ZW50KTtcbiAgICB9LFxuICAgIHNjaGVkdWxlcixcbiAgICBnZXRTbmFwc2hvdDogKCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3NjaGVkdWxlZEV2ZW50czoge1xuICAgICAgICAgIC4uLnN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgc3RhcnQ6ICgpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50cyA9IHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cztcbiAgICAgIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBzY2hlZHVsZWRJZCBpbiBzY2hlZHVsZWRFdmVudHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IHNjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRJZF07XG4gICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZShzb3VyY2UsIHRhcmdldCwgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2xvY2s6IGNsb2NrLFxuICAgIF9sb2dnZXI6IGxvZ2dlclxuICB9O1xuICByZXR1cm4gc3lzdGVtO1xufVxuXG5sZXQgZXhlY3V0aW5nQ3VzdG9tQWN0aW9uID0gZmFsc2U7XG5jb25zdCAkJEFDVE9SX1RZUEUgPSAxO1xuXG4vLyB0aG9zZSB2YWx1ZXMgYXJlIGN1cnJlbnRseSB1c2VkIGJ5IEB4c3RhdGUvcmVhY3QgZGlyZWN0bHkgc28gaXQncyBpbXBvcnRhbnQgdG8ga2VlcCB0aGUgYXNzaWduZWQgdmFsdWVzIGluIHN5bmNcbmxldCBQcm9jZXNzaW5nU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChQcm9jZXNzaW5nU3RhdHVzKSB7XG4gIFByb2Nlc3NpbmdTdGF0dXNbUHJvY2Vzc2luZ1N0YXR1c1tcIk5vdFN0YXJ0ZWRcIl0gPSAwXSA9IFwiTm90U3RhcnRlZFwiO1xuICBQcm9jZXNzaW5nU3RhdHVzW1Byb2Nlc3NpbmdTdGF0dXNbXCJSdW5uaW5nXCJdID0gMV0gPSBcIlJ1bm5pbmdcIjtcbiAgUHJvY2Vzc2luZ1N0YXR1c1tQcm9jZXNzaW5nU3RhdHVzW1wiU3RvcHBlZFwiXSA9IDJdID0gXCJTdG9wcGVkXCI7XG4gIHJldHVybiBQcm9jZXNzaW5nU3RhdHVzO1xufSh7fSk7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgY2xvY2s6IHtcbiAgICBzZXRUaW1lb3V0OiAoZm4sIG1zKSA9PiB7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmbiwgbXMpO1xuICAgIH0sXG4gICAgY2xlYXJUaW1lb3V0OiBpZCA9PiB7XG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9XG4gIH0sXG4gIGxvZ2dlcjogY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgZGV2VG9vbHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIEFuIEFjdG9yIGlzIGEgcnVubmluZyBwcm9jZXNzIHRoYXQgY2FuIHJlY2VpdmUgZXZlbnRzLCBzZW5kIGV2ZW50cyBhbmQgY2hhbmdlXG4gKiBpdHMgYmVoYXZpb3IgYmFzZWQgb24gdGhlIGV2ZW50cyBpdCByZWNlaXZlcywgd2hpY2ggY2FuIGNhdXNlIGVmZmVjdHMgb3V0c2lkZVxuICogb2YgdGhlIGFjdG9yLiBXaGVuIHlvdSBydW4gYSBzdGF0ZSBtYWNoaW5lLCBpdCBiZWNvbWVzIGFuIGFjdG9yLlxuICovXG5jbGFzcyBBY3RvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGFjdG9yIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gbG9naWMgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucyxcbiAgICogaWYgYW55LlxuICAgKlxuICAgKiBAcGFyYW0gbG9naWMgVGhlIGxvZ2ljIHRvIGNyZWF0ZSBhbiBhY3RvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIEFjdG9yIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvZ2ljLCBvcHRpb25zKSB7XG4gICAgdGhpcy5sb2dpYyA9IGxvZ2ljO1xuICAgIC8qKiBUaGUgY3VycmVudCBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgYWN0b3IuICovXG4gICAgdGhpcy5fc25hcHNob3QgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIGNsb2NrIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHNldHRpbmcgYW5kIGNsZWFyaW5nIHRpbWVvdXRzLCBzdWNoIGFzXG4gICAgICogZGVsYXllZCBldmVudHMgYW5kIHRyYW5zaXRpb25zLlxuICAgICAqL1xuICAgIHRoaXMuY2xvY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0b3IgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC4gKi9cbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMubWFpbGJveCA9IG5ldyBNYWlsYm94KHRoaXMuX3Byb2Nlc3MuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5vYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9IFByb2Nlc3NpbmdTdGF0dXMuTm90U3RhcnRlZDtcbiAgICAvLyBBY3RvciBSZWZcbiAgICB0aGlzLl9wYXJlbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3N5bmNTbmFwc2hvdCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlZiA9IHZvaWQgMDtcbiAgICAvLyBUT0RPOiBhZGQgdHlwaW5ncyBmb3Igc3lzdGVtXG4gICAgdGhpcy5fYWN0b3JTY29wZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9zeXN0ZW1JZCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGdsb2JhbGx5IHVuaXF1ZSBwcm9jZXNzIElEIGZvciB0aGlzIGludm9jYXRpb24uICovXG4gICAgdGhpcy5zZXNzaW9uSWQgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBzeXN0ZW0gdG8gd2hpY2ggdGhpcyBhY3RvciBiZWxvbmdzLiAqL1xuICAgIHRoaXMuc3lzdGVtID0gdm9pZCAwO1xuICAgIHRoaXMuX2RvbmVFdmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnNyYyA9IHZvaWQgMDtcbiAgICAvLyBhcnJheSBvZiBmdW5jdGlvbnMgdG8gZGVmZXJcbiAgICB0aGlzLl9kZWZlcnJlZCA9IFtdO1xuICAgIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgY2xvY2ssXG4gICAgICBsb2dnZXIsXG4gICAgICBwYXJlbnQsXG4gICAgICBzeW5jU25hcHNob3QsXG4gICAgICBpZCxcbiAgICAgIHN5c3RlbUlkLFxuICAgICAgaW5zcGVjdFxuICAgIH0gPSByZXNvbHZlZE9wdGlvbnM7XG4gICAgdGhpcy5zeXN0ZW0gPSBwYXJlbnQgPyBwYXJlbnQuc3lzdGVtIDogY3JlYXRlU3lzdGVtKHRoaXMsIHtcbiAgICAgIGNsb2NrLFxuICAgICAgbG9nZ2VyXG4gICAgfSk7XG4gICAgaWYgKGluc3BlY3QgJiYgIXBhcmVudCkge1xuICAgICAgLy8gQWx3YXlzIGluc3BlY3QgYXQgdGhlIHN5c3RlbS1sZXZlbFxuICAgICAgdGhpcy5zeXN0ZW0uaW5zcGVjdCh0b09ic2VydmVyKGluc3BlY3QpKTtcbiAgICB9XG4gICAgdGhpcy5zZXNzaW9uSWQgPSB0aGlzLnN5c3RlbS5fYm9va0lkKCk7XG4gICAgdGhpcy5pZCA9IGlkID8/IHRoaXMuc2Vzc2lvbklkO1xuICAgIHRoaXMubG9nZ2VyID0gb3B0aW9ucz8ubG9nZ2VyID8/IHRoaXMuc3lzdGVtLl9sb2dnZXI7XG4gICAgdGhpcy5jbG9jayA9IG9wdGlvbnM/LmNsb2NrID8/IHRoaXMuc3lzdGVtLl9jbG9jaztcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fc3luY1NuYXBzaG90ID0gc3luY1NuYXBzaG90O1xuICAgIHRoaXMub3B0aW9ucyA9IHJlc29sdmVkT3B0aW9ucztcbiAgICB0aGlzLnNyYyA9IHJlc29sdmVkT3B0aW9ucy5zcmMgPz8gbG9naWM7XG4gICAgdGhpcy5yZWYgPSB0aGlzO1xuICAgIHRoaXMuX2FjdG9yU2NvcGUgPSB7XG4gICAgICBzZWxmOiB0aGlzLFxuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBzZXNzaW9uSWQ6IHRoaXMuc2Vzc2lvbklkLFxuICAgICAgbG9nZ2VyOiB0aGlzLmxvZ2dlcixcbiAgICAgIGRlZmVyOiBmbiA9PiB7XG4gICAgICAgIHRoaXMuX2RlZmVycmVkLnB1c2goZm4pO1xuICAgICAgfSxcbiAgICAgIHN5c3RlbTogdGhpcy5zeXN0ZW0sXG4gICAgICBzdG9wQ2hpbGQ6IGNoaWxkID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLl9wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdG9wIGNoaWxkIGFjdG9yICR7Y2hpbGQuaWR9IG9mICR7dGhpcy5pZH0gYmVjYXVzZSBpdCBpcyBub3QgYSBjaGlsZGApO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkLl9zdG9wKCk7XG4gICAgICB9LFxuICAgICAgZW1pdDogZW1pdHRlZEV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZW1pdHRlZEV2ZW50LnR5cGUpO1xuICAgICAgICBjb25zdCB3aWxkY2FyZExpc3RlbmVyID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQoJyonKTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMgJiYgIXdpbGRjYXJkTGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsTGlzdGVuZXJzID0gWy4uLihsaXN0ZW5lcnMgPyBsaXN0ZW5lcnMudmFsdWVzKCkgOiBbXSksIC4uLih3aWxkY2FyZExpc3RlbmVyID8gd2lsZGNhcmRMaXN0ZW5lci52YWx1ZXMoKSA6IFtdKV07XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBhbGxMaXN0ZW5lcnMpIHtcbiAgICAgICAgICBoYW5kbGVyKGVtaXR0ZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhY3Rpb25FeGVjdXRvcjogYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgZXhlYyA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9hY3RvclNjb3BlLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnQHhzdGF0ZS5hY3Rpb24nLFxuICAgICAgICAgICAgYWN0b3JSZWY6IHRoaXMsXG4gICAgICAgICAgICBhY3Rpb246IHtcbiAgICAgICAgICAgICAgdHlwZTogYWN0aW9uLnR5cGUsXG4gICAgICAgICAgICAgIHBhcmFtczogYWN0aW9uLnBhcmFtc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghYWN0aW9uLmV4ZWMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2F2ZUV4ZWN1dGluZ0N1c3RvbUFjdGlvbiA9IGV4ZWN1dGluZ0N1c3RvbUFjdGlvbjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXhlY3V0aW5nQ3VzdG9tQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGFjdGlvbi5leGVjKGFjdGlvbi5pbmZvLCBhY3Rpb24ucGFyYW1zKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZXhlY3V0aW5nQ3VzdG9tQWN0aW9uID0gc2F2ZUV4ZWN1dGluZ0N1c3RvbUFjdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgICAgICBleGVjKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZGVmZXJyZWQucHVzaChleGVjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc2VuZCBtZXRob2QgaXMgYm91bmQgdG8gdGhpcyBBY3RvciBpbnN0YW5jZVxuICAgIC8vIGlmIGRlc3RydWN0dXJlZFxuICAgIHRoaXMuc2VuZCA9IHRoaXMuc2VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgIHR5cGU6ICdAeHN0YXRlLmFjdG9yJyxcbiAgICAgIGFjdG9yUmVmOiB0aGlzXG4gICAgfSk7XG4gICAgaWYgKHN5c3RlbUlkKSB7XG4gICAgICB0aGlzLl9zeXN0ZW1JZCA9IHN5c3RlbUlkO1xuICAgICAgdGhpcy5zeXN0ZW0uX3NldChzeXN0ZW1JZCwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRTdGF0ZShvcHRpb25zPy5zbmFwc2hvdCA/PyBvcHRpb25zPy5zdGF0ZSk7XG4gICAgaWYgKHN5c3RlbUlkICYmIHRoaXMuX3NuYXBzaG90LnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHRoaXMuc3lzdGVtLl91bnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICBfaW5pdFN0YXRlKHBlcnNpc3RlZFN0YXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0gcGVyc2lzdGVkU3RhdGUgPyB0aGlzLmxvZ2ljLnJlc3RvcmVTbmFwc2hvdCA/IHRoaXMubG9naWMucmVzdG9yZVNuYXBzaG90KHBlcnNpc3RlZFN0YXRlLCB0aGlzLl9hY3RvclNjb3BlKSA6IHBlcnNpc3RlZFN0YXRlIDogdGhpcy5sb2dpYy5nZXRJbml0aWFsU25hcHNob3QodGhpcy5fYWN0b3JTY29wZSwgdGhpcy5vcHRpb25zPy5pbnB1dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBpZiB3ZSBnZXQgaGVyZSB0aGVuIGl0IG1lYW5zIHRoYXQgd2UgYXNzaWduIGEgdmFsdWUgdG8gdGhpcy5fc25hcHNob3QgdGhhdCBpcyBub3Qgb2YgdGhlIGNvcnJlY3QgdHlwZVxuICAgICAgLy8gd2UgY2FuJ3QgZ2V0IHRoZSB0cnVlIGBUU25hcHNob3QgJiB7IHN0YXR1czogJ2Vycm9yJzsgfWAsIGl0J3MgaW1wb3NzaWJsZVxuICAgICAgLy8gc28gcmlnaHQgbm93IHRoaXMgaXMgYSBsaWUgb2Ygc29ydHNcbiAgICAgIHRoaXMuX3NuYXBzaG90ID0ge1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB1cGRhdGUoc25hcHNob3QsIGV2ZW50KSB7XG4gICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgdGhpcy5fc25hcHNob3QgPSBzbmFwc2hvdDtcblxuICAgIC8vIEV4ZWN1dGUgZGVmZXJyZWQgZWZmZWN0c1xuICAgIGxldCBkZWZlcnJlZEZuO1xuICAgIHdoaWxlIChkZWZlcnJlZEZuID0gdGhpcy5fZGVmZXJyZWQuc2hpZnQoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVmZXJyZWRGbigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHRoaXMgZXJyb3IgY2FuIG9ubHkgYmUgY2F1Z2h0IHdoZW4gZXhlY3V0aW5nICppbml0aWFsKiBhY3Rpb25zXG4gICAgICAgIC8vIGl0J3MgdGhlIG9ubHkgdGltZSB3aGVuIHdlIGNhbGwgYWN0aW9ucyBwcm92aWRlZCBieSB0aGUgdXNlciB0aHJvdWdoIHRob3NlIGRlZmVycmVkc1xuICAgICAgICAvLyB3aGVuIHRoZSBhY3RvciBpcyBhbHJlYWR5IHJ1bm5pbmcgd2UgYWx3YXlzIGV4ZWN1dGUgdGhlbSBzeW5jaHJvbm91c2x5IHdoaWxlIHRyYW5zaXRpb25pbmdcbiAgICAgICAgLy8gbm8gXCJidWlsdGluIGRlZmVycmVkXCIgc2hvdWxkIGFjdHVhbGx5IHRocm93IGFuIGVycm9yIHNpbmNlIHRoZXkgYXJlIGVpdGhlciBzYWZlXG4gICAgICAgIC8vIG9yIHRoZSBjb250cm9sIGZsb3cgaXMgcGFzc2VkIHRocm91Z2ggdGhlIG1haWxib3ggYW5kIGVycm9ycyBzaG91bGQgYmUgY2F1Z2h0IGJ5IHRoZSBgX3Byb2Nlc3NgIHVzZWQgYnkgdGhlIG1haWxib3hcbiAgICAgICAgdGhpcy5fZGVmZXJyZWQubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLl9zbmFwc2hvdC5zdGF0dXMpIHtcbiAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHNuYXBzaG90KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgIC8vIG5leHQgb2JzZXJ2ZXJzIGFyZSBtZWFudCB0byBiZSBub3RpZmllZCBhYm91dCBkb25lIHNuYXBzaG90c1xuICAgICAgICAvLyB0aGlzIGNhbiBiZSBzZWVuIGFzIHNvbWV0aGluZyB0aGF0IGlzIGRpZmZlcmVudCBmcm9tIGhvdyBvYnNlcnZhYmxlIHdvcmtcbiAgICAgICAgLy8gYnV0IHdpdGggb2JzZXJ2YWJsZXMgYGNvbXBsZXRlYCBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aG91dCBhbnkgYXJndW1lbnRzXG4gICAgICAgIC8vIGl0J3MgbW9yZSBlcmdvbm9taWMgZm9yIFhTdGF0ZSB0byB0cmVhdCBhIGRvbmUgc25hcHNob3QgYXMgYSBcIm5leHRcIiB2YWx1ZVxuICAgICAgICAvLyBhbmQgdGhlIGNvbXBsZXRpb24gZXZlbnQgYXMgc29tZXRoaW5nIHRoYXQgaXMgc2VwYXJhdGUsXG4gICAgICAgIC8vIHNvbWV0aGluZyB0aGF0IG1lcmVseSBmb2xsb3dzIGVtaXR0aW5nIHRoYXQgZG9uZSBzbmFwc2hvdFxuICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQ/LihzbmFwc2hvdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9wUHJvY2VkdXJlKCk7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuX2RvbmVFdmVudCA9IGNyZWF0ZURvbmVBY3RvckV2ZW50KHRoaXMuaWQsIHRoaXMuX3NuYXBzaG90Lm91dHB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLnN5c3RlbS5fcmVsYXkodGhpcywgdGhpcy5fcGFyZW50LCB0aGlzLl9kb25lRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB0aGlzLl9lcnJvcih0aGlzLl9zbmFwc2hvdC5lcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5zbmFwc2hvdCcsXG4gICAgICBhY3RvclJlZjogdGhpcyxcbiAgICAgIGV2ZW50LFxuICAgICAgc25hcHNob3RcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgYW4gb2JzZXJ2ZXIgdG8gYW4gYWN0b3LigJlzIHNuYXBzaG90IHZhbHVlcy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlIG9ic2VydmVyIHdpbGwgcmVjZWl2ZSB0aGUgYWN0b3LigJlzIHNuYXBzaG90IHZhbHVlIHdoZW4gaXQgaXMgZW1pdHRlZC5cbiAgICogVGhlIG9ic2VydmVyIGNhbiBiZTpcbiAgICpcbiAgICogLSBBIHBsYWluIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGxhdGVzdCBzbmFwc2hvdCwgb3JcbiAgICogLSBBbiBvYnNlcnZlciBvYmplY3Qgd2hvc2UgYC5uZXh0KHNuYXBzaG90KWAgbWV0aG9kIHJlY2VpdmVzIHRoZSBsYXRlc3RcbiAgICogICBzbmFwc2hvdFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBPYnNlcnZlciBhcyBhIHBsYWluIGZ1bmN0aW9uXG4gICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogYGBgdHNcbiAgICogLy8gT2JzZXJ2ZXIgYXMgYW4gb2JqZWN0XG4gICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdG9yLnN1YnNjcmliZSh7XG4gICAqICAgbmV4dChzbmFwc2hvdCkge1xuICAgKiAgICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICAgKiAgIH0sXG4gICAqICAgZXJyb3IoZXJyKSB7XG4gICAqICAgICAvLyAuLi5cbiAgICogICB9LFxuICAgKiAgIGNvbXBsZXRlKCkge1xuICAgKiAgICAgLy8gLi4uXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIFRoZSByZXR1cm4gdmFsdWUgb2YgYGFjdG9yLnN1YnNjcmliZShvYnNlcnZlcilgIGlzIGEgc3Vic2NyaXB0aW9uIG9iamVjdFxuICAgKiB0aGF0IGhhcyBhbiBgLnVuc3Vic2NyaWJlKClgIG1ldGhvZC4gWW91IGNhbiBjYWxsXG4gICAqIGBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKWAgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmVyOlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBzdWJzY3JpcHRpb24gPSBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gICAqICAgLy8gLi4uXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBVbnN1YnNjcmliZSB0aGUgb2JzZXJ2ZXJcbiAgICogc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBXaGVuIHRoZSBhY3RvciBpcyBzdG9wcGVkLCBhbGwgb2YgaXRzIG9ic2VydmVycyB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICogdW5zdWJzY3JpYmVkLlxuICAgKlxuICAgKiBAcGFyYW0gb2JzZXJ2ZXIgLSBFaXRoZXIgYSBwbGFpbiBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBsYXRlc3RcbiAgICogICBzbmFwc2hvdCwgb3IgYW4gb2JzZXJ2ZXIgb2JqZWN0IHdob3NlIGAubmV4dChzbmFwc2hvdClgIG1ldGhvZCByZWNlaXZlc1xuICAgKiAgIHRoZSBsYXRlc3Qgc25hcHNob3RcbiAgICovXG5cbiAgc3Vic2NyaWJlKG5leHRMaXN0ZW5lck9yT2JzZXJ2ZXIsIGVycm9yTGlzdGVuZXIsIGNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IHRvT2JzZXJ2ZXIobmV4dExpc3RlbmVyT3JPYnNlcnZlciwgZXJyb3JMaXN0ZW5lciwgY29tcGxldGVMaXN0ZW5lcik7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgIT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgdGhpcy5vYnNlcnZlcnMuYWRkKG9ic2VydmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aGlzLl9zbmFwc2hvdC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlPy4oKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5fc25hcHNob3QuZXJyb3I7XG4gICAgICAgICAgICBpZiAoIW9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KHR5cGUpO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNldCh0eXBlLCBsaXN0ZW5lcnMpO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IGhhbmRsZXIuYmluZCh1bmRlZmluZWQpO1xuICAgIGxpc3RlbmVycy5hZGQod3JhcHBlZEhhbmRsZXIpO1xuICAgIHJldHVybiB7XG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lcnMuZGVsZXRlKHdyYXBwZWRIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqIFN0YXJ0cyB0aGUgQWN0b3IgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZSAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgICAvLyBEbyBub3QgcmVzdGFydCB0aGUgc2VydmljZSBpZiBpdCBpcyBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3luY1NuYXBzaG90KSB7XG4gICAgICB0aGlzLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcbiAgICAgICAgICBpZiAoc25hcHNob3Quc3RhdHVzID09PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgdGhpcy5zeXN0ZW0uX3JlbGF5KHRoaXMsIHRoaXMuX3BhcmVudCwge1xuICAgICAgICAgICAgICB0eXBlOiBgeHN0YXRlLnNuYXBzaG90LiR7dGhpcy5pZH1gLFxuICAgICAgICAgICAgICBzbmFwc2hvdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKCkgPT4ge31cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fcmVnaXN0ZXIodGhpcy5zZXNzaW9uSWQsIHRoaXMpO1xuICAgIGlmICh0aGlzLl9zeXN0ZW1JZCkge1xuICAgICAgdGhpcy5zeXN0ZW0uX3NldCh0aGlzLl9zeXN0ZW1JZCwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmc7XG5cbiAgICAvLyBUT0RPOiB0aGlzIGlzbid0IGNvcnJlY3Qgd2hlbiByZWh5ZHJhdGluZ1xuICAgIGNvbnN0IGluaXRFdmVudCA9IGNyZWF0ZUluaXRFdmVudCh0aGlzLm9wdGlvbnMuaW5wdXQpO1xuICAgIHRoaXMuc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgIHR5cGU6ICdAeHN0YXRlLmV2ZW50JyxcbiAgICAgIHNvdXJjZVJlZjogdGhpcy5fcGFyZW50LFxuICAgICAgYWN0b3JSZWY6IHRoaXMsXG4gICAgICBldmVudDogaW5pdEV2ZW50XG4gICAgfSk7XG4gICAgY29uc3Qgc3RhdHVzID0gdGhpcy5fc25hcHNob3Quc3RhdHVzO1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgLy8gYSBzdGF0ZSBtYWNoaW5lIGNhbiBiZSBcImRvbmVcIiB1cG9uIGluaXRpYWxpemF0aW9uIChpdCBjb3VsZCByZWFjaCBhIGZpbmFsIHN0YXRlIHVzaW5nIGluaXRpYWwgbWljcm9zdGVwcylcbiAgICAgICAgLy8gd2Ugc3RpbGwgbmVlZCB0byBjb21wbGV0ZSBvYnNlcnZlcnMsIGZsdXNoIGRlZmVycmVkcyBldGNcbiAgICAgICAgdGhpcy51cGRhdGUodGhpcy5fc25hcHNob3QsIGluaXRFdmVudCk7XG4gICAgICAgIC8vIFRPRE86IHJldGhpbmsgY2xlYW51cCBvZiBvYnNlcnZlcnMsIG1haWxib3gsIGV0Y1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdGhpcy5fZXJyb3IodGhpcy5fc25hcHNob3QuZXJyb3IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRoaXMuc3lzdGVtLnN0YXJ0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxvZ2ljLnN0YXJ0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmxvZ2ljLnN0YXJ0KHRoaXMuX3NuYXBzaG90LCB0aGlzLl9hY3RvclNjb3BlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IHtcbiAgICAgICAgICAuLi50aGlzLl9zbmFwc2hvdCxcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGlzIG5vdGlmaWVzIGFsbCBzdWJzY3JpYmVycyBidXQgdXN1YWxseSB0aGlzIGlzIHJlZHVuZGFudFxuICAgIC8vIHRoZXJlIGlzIG5vIHJlYWwgY2hhbmdlIGhhcHBlbmluZyBoZXJlXG4gICAgLy8gd2UgbmVlZCB0byByZXRoaW5rIGlmIHRoaXMgbmVlZHMgdG8gYmUgcmVmYWN0b3JlZFxuICAgIHRoaXMudXBkYXRlKHRoaXMuX3NuYXBzaG90LCBpbml0RXZlbnQpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGV2VG9vbHMpIHtcbiAgICAgIHRoaXMuYXR0YWNoRGV2VG9vbHMoKTtcbiAgICB9XG4gICAgdGhpcy5tYWlsYm94LnN0YXJ0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX3Byb2Nlc3MoZXZlbnQpIHtcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGxldCBjYXVnaHRFcnJvcjtcbiAgICB0cnkge1xuICAgICAgbmV4dFN0YXRlID0gdGhpcy5sb2dpYy50cmFuc2l0aW9uKHRoaXMuX3NuYXBzaG90LCBldmVudCwgdGhpcy5fYWN0b3JTY29wZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyB3ZSB3cmFwIGl0IGluIGEgYm94IHNvIHdlIGNhbiByZXRocm93IGl0IGxhdGVyIGV2ZW4gaWYgZmFsc3kgdmFsdWUgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgY2F1Z2h0RXJyb3IgPSB7XG4gICAgICAgIGVyclxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVyclxuICAgICAgfSA9IGNhdWdodEVycm9yO1xuICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgIC4uLnRoaXMuX3NuYXBzaG90LFxuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH07XG4gICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShuZXh0U3RhdGUsIGV2ZW50KTtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gWFNUQVRFX1NUT1ApIHtcbiAgICAgIHRoaXMuX3N0b3BQcm9jZWR1cmUoKTtcbiAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG4gIF9zdG9wKCkge1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLm1haWxib3guY2xlYXIoKTtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5Ob3RTdGFydGVkKSB7XG4gICAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMubWFpbGJveC5lbnF1ZXVlKHtcbiAgICAgIHR5cGU6IFhTVEFURV9TVE9QXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogU3RvcHMgdGhlIEFjdG9yIGFuZCB1bnN1YnNjcmliZSBhbGwgbGlzdGVuZXJzLiAqL1xuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBub24tcm9vdCBhY3RvciBjYW5ub3QgYmUgc3RvcHBlZCBkaXJlY3RseS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0b3AoKTtcbiAgfVxuICBfY29tcGxldGUoKSB7XG4gICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiB0aGlzLm9ic2VydmVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXJzLmNsZWFyKCk7XG4gIH1cbiAgX3JlcG9ydEVycm9yKGVycikge1xuICAgIGlmICghdGhpcy5vYnNlcnZlcnMuc2l6ZSkge1xuICAgICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJlcG9ydEVycm9yID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiB0aGlzLm9ic2VydmVycykge1xuICAgICAgY29uc3QgZXJyb3JMaXN0ZW5lciA9IG9ic2VydmVyLmVycm9yO1xuICAgICAgcmVwb3J0RXJyb3IgfHw9ICFlcnJvckxpc3RlbmVyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JMaXN0ZW5lcj8uKGVycik7XG4gICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycjIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9ic2VydmVycy5jbGVhcigpO1xuICAgIGlmIChyZXBvcnRFcnJvcikge1xuICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgX2Vycm9yKGVycikge1xuICAgIHRoaXMuX3N0b3BQcm9jZWR1cmUoKTtcbiAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnIpO1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRoaXMuc3lzdGVtLl9yZWxheSh0aGlzLCB0aGlzLl9wYXJlbnQsIGNyZWF0ZUVycm9yQWN0b3JFdmVudCh0aGlzLmlkLCBlcnIpKTtcbiAgICB9XG4gIH1cbiAgLy8gVE9ETzogYXRtIGNoaWxkcmVuIGRvbid0IGJlbG9uZyBlbnRpcmVseSB0byB0aGUgYWN0b3Igc29cbiAgLy8gaW4gYSB3YXkgLSBpdCdzIG5vdCBldmVuIHN1cGVyIGF3YXJlIG9mIHRoZW1cbiAgLy8gc28gd2UgY2FuJ3Qgc3RvcCB0aGVtIGZyb20gaGVyZSBidXQgd2UgcmVhbGx5IHNob3VsZCFcbiAgLy8gcmlnaHQgbm93LCB0aGV5IGFyZSBiZWluZyBzdG9wcGVkIHdpdGhpbiB0aGUgbWFjaGluZSdzIHRyYW5zaXRpb25cbiAgLy8gYnV0IHRoYXQgY291bGQgdGhyb3cgYW5kIGxlYXZlIHVzIHdpdGggXCJvcnBoYW5lZFwiIGFjdGl2ZSBhY3RvcnNcbiAgX3N0b3BQcm9jZWR1cmUoKSB7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgIT09IFByb2Nlc3NpbmdTdGF0dXMuUnVubmluZykge1xuICAgICAgLy8gQWN0b3IgYWxyZWFkeSBzdG9wcGVkOyBkbyBub3RoaW5nXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBDYW5jZWwgYWxsIGRlbGF5ZWQgZXZlbnRzXG4gICAgdGhpcy5zeXN0ZW0uc2NoZWR1bGVyLmNhbmNlbEFsbCh0aGlzKTtcblxuICAgIC8vIFRPRE86IG1haWxib3gucmVzZXRcbiAgICB0aGlzLm1haWxib3guY2xlYXIoKTtcbiAgICAvLyBUT0RPOiBhZnRlciBgc3RvcGAgd2UgbXVzdCBwcmVwYXJlIG91cnNlbHZlcyBmb3IgcmVjZWl2aW5nIGV2ZW50cyBhZ2FpblxuICAgIC8vIGV2ZW50cyBzZW50ICphZnRlciogc3RvcCBzaWduYWwgbXVzdCBiZSBxdWV1ZWRcbiAgICAvLyBpdCBzZWVtcyBsaWtlIHRoaXMgc2hvdWxkIGJlIHRoZSBjb21tb24gYmVoYXZpb3IgZm9yIGFsbCBvZiBvdXIgY29uc3VtZXJzXG4gICAgLy8gc28gcGVyaGFwcyB0aGlzIHNob3VsZCBiZSB1bmlmaWVkIHNvbWVob3cgZm9yIGFsbCBvZiB0aGVtXG4gICAgdGhpcy5tYWlsYm94ID0gbmV3IE1haWxib3godGhpcy5fcHJvY2Vzcy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkO1xuICAgIHRoaXMuc3lzdGVtLl91bnJlZ2lzdGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfc2VuZChldmVudCkge1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIHtcbiAgICAgICAgY29uc3QgZXZlbnRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShldmVudCk7XG4gICAgICAgIGNvbnNvbGUud2FybihgRXZlbnQgXCIke2V2ZW50LnR5cGV9XCIgd2FzIHNlbnQgdG8gc3RvcHBlZCBhY3RvciBcIiR7dGhpcy5pZH0gKCR7dGhpcy5zZXNzaW9uSWR9KVwiLiBUaGlzIGFjdG9yIGhhcyBhbHJlYWR5IHJlYWNoZWQgaXRzIGZpbmFsIHN0YXRlLCBhbmQgd2lsbCBub3QgdHJhbnNpdGlvbi5cXG5FdmVudDogJHtldmVudFN0cmluZ31gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tYWlsYm94LmVucXVldWUoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoZSBydW5uaW5nIEFjdG9yIHRvIHRyaWdnZXIgYSB0cmFuc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmRcbiAgICovXG4gIHNlbmQoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbmx5IGV2ZW50IG9iamVjdHMgbWF5IGJlIHNlbnQgdG8gYWN0b3JzOyB1c2UgLnNlbmQoeyB0eXBlOiBcIiR7ZXZlbnR9XCIgfSkgaW5zdGVhZGApO1xuICAgIH1cbiAgICB0aGlzLnN5c3RlbS5fcmVsYXkodW5kZWZpbmVkLCB0aGlzLCBldmVudCk7XG4gIH1cbiAgYXR0YWNoRGV2VG9vbHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGV2VG9vbHNcbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChkZXZUb29scykge1xuICAgICAgY29uc3QgcmVzb2x2ZWREZXZUb29sc0FkYXB0ZXIgPSB0eXBlb2YgZGV2VG9vbHMgPT09ICdmdW5jdGlvbicgPyBkZXZUb29scyA6IGRldlRvb2xzQWRhcHRlcjtcbiAgICAgIHJlc29sdmVkRGV2VG9vbHNBZGFwdGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHhzdGF0ZSQkdHlwZTogJCRBQ1RPUl9UWVBFLFxuICAgICAgaWQ6IHRoaXMuaWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE9idGFpbiB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGFjdG9yLCB3aGljaCBjYW4gYmUgcGVyc2lzdGVkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgaW50ZXJuYWwgc3RhdGUgY2FuIGJlIHBlcnNpc3RlZCBmcm9tIGFueSBhY3Rvciwgbm90IG9ubHkgbWFjaGluZXMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgcGVyc2lzdGVkIHN0YXRlIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgc25hcHNob3QgZnJvbVxuICAgKiB7QGxpbmsgQWN0b3IuZ2V0U25hcHNob3R9LiBQZXJzaXN0ZWQgc3RhdGUgcmVwcmVzZW50cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2ZcbiAgICogdGhlIGFjdG9yLCB3aGlsZSBzbmFwc2hvdHMgcmVwcmVzZW50IHRoZSBhY3RvcidzIGxhc3QgZW1pdHRlZCB2YWx1ZS5cbiAgICpcbiAgICogQ2FuIGJlIHJlc3RvcmVkIHdpdGgge0BsaW5rIEFjdG9yT3B0aW9ucy5zdGF0ZX1cbiAgICogQHNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9wZXJzaXN0ZW5jZVxuICAgKi9cblxuICBnZXRQZXJzaXN0ZWRTbmFwc2hvdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubG9naWMuZ2V0UGVyc2lzdGVkU25hcHNob3QodGhpcy5fc25hcHNob3QsIG9wdGlvbnMpO1xuICB9XG4gIFtzeW1ib2xPYnNlcnZhYmxlXSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGFuIGFjdG9y4oCZcyBzbmFwc2hvdCBzeW5jaHJvbm91c2x5LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgc25hcHNob3QgcmVwcmVzZW50IGFuIGFjdG9yJ3MgbGFzdCBlbWl0dGVkIHZhbHVlLlxuICAgKlxuICAgKiBXaGVuIGFuIGFjdG9yIHJlY2VpdmVzIGFuIGV2ZW50LCBpdHMgaW50ZXJuYWwgc3RhdGUgbWF5IGNoYW5nZS4gQW4gYWN0b3JcbiAgICogbWF5IGVtaXQgYSBzbmFwc2hvdCB3aGVuIGEgc3RhdGUgdHJhbnNpdGlvbiBvY2N1cnMuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBzb21lIGFjdG9ycywgc3VjaCBhcyBjYWxsYmFjayBhY3RvcnMgZ2VuZXJhdGVkIHdpdGhcbiAgICogYGZyb21DYWxsYmFja2AsIHdpbGwgbm90IGVtaXQgc25hcHNob3RzLlxuICAgKiBAc2VlIHtAbGluayBBY3Rvci5zdWJzY3JpYmV9IHRvIHN1YnNjcmliZSB0byBhbiBhY3RvcuKAmXMgc25hcHNob3QgdmFsdWVzLlxuICAgKiBAc2VlIHtAbGluayBBY3Rvci5nZXRQZXJzaXN0ZWRTbmFwc2hvdH0gdG8gcGVyc2lzdCB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgYW4gYWN0b3IgKHdoaWNoIGlzIG1vcmUgdGhhbiBqdXN0IGEgc25hcHNob3QpLlxuICAgKi9cbiAgZ2V0U25hcHNob3QoKSB7XG4gICAgaWYgKCF0aGlzLl9zbmFwc2hvdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTbmFwc2hvdCBjYW4ndCBiZSByZWFkIHdoaWxlIHRoZSBhY3RvciBpbml0aWFsaXplcyBpdHNlbGZgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NuYXBzaG90O1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYWN0b3IgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhY3RvciBsb2dpYyB3aXRoIHRoZSBwcm92aWRlZFxuICogb3B0aW9ucywgaWYgYW55LlxuICpcbiAqIEByZW1hcmtzXG4gKiBXaGVuIHlvdSBjcmVhdGUgYW4gYWN0b3IgZnJvbSBhY3RvciBsb2dpYyB2aWEgYGNyZWF0ZUFjdG9yKGxvZ2ljKWAsIHlvdVxuICogaW1wbGljaXRseSBjcmVhdGUgYW4gYWN0b3Igc3lzdGVtIHdoZXJlIHRoZSBjcmVhdGVkIGFjdG9yIGlzIHRoZSByb290IGFjdG9yLlxuICogQW55IGFjdG9ycyBzcGF3bmVkIGZyb20gdGhpcyByb290IGFjdG9yIGFuZCBpdHMgZGVzY2VuZGFudHMgYXJlIHBhcnQgb2YgdGhhdFxuICogYWN0b3Igc3lzdGVtLlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgc29tZUFjdG9yTG9naWMgfSBmcm9tICcuL3NvbWVBY3RvckxvZ2ljLnRzJztcbiAqXG4gKiAvLyBDcmVhdGluZyB0aGUgYWN0b3IsIHdoaWNoIGltcGxpY2l0bHkgY3JlYXRlcyBhbiBhY3RvciBzeXN0ZW0gd2l0aCBpdHNlbGYgYXMgdGhlIHJvb3QgYWN0b3JcbiAqIGNvbnN0IGFjdG9yID0gY3JlYXRlQWN0b3Ioc29tZUFjdG9yTG9naWMpO1xuICpcbiAqIGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAqICAgY29uc29sZS5sb2coc25hcHNob3QpO1xuICogfSk7XG4gKlxuICogLy8gQWN0b3JzIG11c3QgYmUgc3RhcnRlZCBieSBjYWxsaW5nIGBhY3Rvci5zdGFydCgpYCwgd2hpY2ggd2lsbCBhbHNvIHN0YXJ0IHRoZSBhY3RvciBzeXN0ZW0uXG4gKiBhY3Rvci5zdGFydCgpO1xuICpcbiAqIC8vIEFjdG9ycyBjYW4gcmVjZWl2ZSBldmVudHNcbiAqIGFjdG9yLnNlbmQoeyB0eXBlOiAnc29tZUV2ZW50JyB9KTtcbiAqXG4gKiAvLyBZb3UgY2FuIHN0b3Agcm9vdCBhY3RvcnMgYnkgY2FsbGluZyBgYWN0b3Iuc3RvcCgpYCwgd2hpY2ggd2lsbCBhbHNvIHN0b3AgdGhlIGFjdG9yIHN5c3RlbSBhbmQgYWxsIGFjdG9ycyBpbiB0aGF0IHN5c3RlbS5cbiAqIGFjdG9yLnN0b3AoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsb2dpYyAtIFRoZSBhY3RvciBsb2dpYyB0byBjcmVhdGUgYW4gYWN0b3IgZnJvbS4gRm9yIGEgc3RhdGUgbWFjaGluZVxuICogICBhY3RvciBsb2dpYyBjcmVhdG9yLCBzZWUge0BsaW5rIGNyZWF0ZU1hY2hpbmV9LiBPdGhlciBhY3RvciBsb2dpYyBjcmVhdG9yc1xuICogICBpbmNsdWRlIHtAbGluayBmcm9tQ2FsbGJhY2t9LCB7QGxpbmsgZnJvbUV2ZW50T2JzZXJ2YWJsZX0sXG4gKiAgIHtAbGluayBmcm9tT2JzZXJ2YWJsZX0sIHtAbGluayBmcm9tUHJvbWlzZX0sIGFuZCB7QGxpbmsgZnJvbVRyYW5zaXRpb259LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBY3RvciBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFjdG9yKGxvZ2ljLCAuLi5bb3B0aW9uc10pIHtcbiAgcmV0dXJuIG5ldyBBY3Rvcihsb2dpYywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBJbnRlcnByZXRlciBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIG1hY2hpbmUgd2l0aCB0aGUgcHJvdmlkZWRcbiAqIG9wdGlvbnMsIGlmIGFueS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGNyZWF0ZUFjdG9yYCBpbnN0ZWFkXG4gKiBAYWxpYXNcbiAqL1xuY29uc3QgaW50ZXJwcmV0ID0gY3JlYXRlQWN0b3I7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBBY3RvcmAgaW5zdGVhZC5cbiAqIEBhbGlhc1xuICovXG5cbmZ1bmN0aW9uIHJlc29sdmVDYW5jZWwoXywgc25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBzZW5kSWRcbn0pIHtcbiAgY29uc3QgcmVzb2x2ZWRTZW5kSWQgPSB0eXBlb2Ygc2VuZElkID09PSAnZnVuY3Rpb24nID8gc2VuZElkKGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcykgOiBzZW5kSWQ7XG4gIHJldHVybiBbc25hcHNob3QsIHtcbiAgICBzZW5kSWQ6IHJlc29sdmVkU2VuZElkXG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlQ2FuY2VsKGFjdG9yU2NvcGUsIHBhcmFtcykge1xuICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICBhY3RvclNjb3BlLnN5c3RlbS5zY2hlZHVsZXIuY2FuY2VsKGFjdG9yU2NvcGUuc2VsZiwgcGFyYW1zLnNlbmRJZCk7XG4gIH0pO1xufVxuLyoqXG4gKiBDYW5jZWxzIGEgZGVsYXllZCBgc2VuZFRvKC4uLilgIGFjdGlvbiB0aGF0IGlzIHdhaXRpbmcgdG8gYmUgZXhlY3V0ZWQuIFRoZVxuICogY2FuY2VsZWQgYHNlbmRUbyguLi4pYCBhY3Rpb24gd2lsbCBub3Qgc2VuZCBpdHMgZXZlbnQgb3IgZXhlY3V0ZSwgdW5sZXNzIHRoZVxuICogYGRlbGF5YCBoYXMgYWxyZWFkeSBlbGFwc2VkIGJlZm9yZSBgY2FuY2VsKC4uLilgIGlzIGNhbGxlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVNYWNoaW5lLCBzZW5kVG8sIGNhbmNlbCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICAvLyAuLi5cbiAqICAgb246IHtcbiAqICAgICBzZW5kRXZlbnQ6IHtcbiAqICAgICAgIGFjdGlvbnM6IHNlbmRUbyhcbiAqICAgICAgICAgJ3NvbWUtYWN0b3InLFxuICogICAgICAgICB7IHR5cGU6ICdzb21lRXZlbnQnIH0sXG4gKiAgICAgICAgIHtcbiAqICAgICAgICAgICBpZDogJ3NvbWUtaWQnLFxuICogICAgICAgICAgIGRlbGF5OiAxMDAwXG4gKiAgICAgICAgIH1cbiAqICAgICAgIClcbiAqICAgICB9LFxuICogICAgIGNhbmNlbEV2ZW50OiB7XG4gKiAgICAgICBhY3Rpb25zOiBjYW5jZWwoJ3NvbWUtaWQnKVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VuZElkIFRoZSBgaWRgIG9mIHRoZSBgc2VuZFRvKC4uLilgIGFjdGlvbiB0byBjYW5jZWwuXG4gKi9cbmZ1bmN0aW9uIGNhbmNlbChzZW5kSWQpIHtcbiAgZnVuY3Rpb24gY2FuY2VsKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBjYW5jZWwudHlwZSA9ICd4c3RhdGUuY2FuY2VsJztcbiAgY2FuY2VsLnNlbmRJZCA9IHNlbmRJZDtcbiAgY2FuY2VsLnJlc29sdmUgPSByZXNvbHZlQ2FuY2VsO1xuICBjYW5jZWwuZXhlY3V0ZSA9IGV4ZWN1dGVDYW5jZWw7XG4gIHJldHVybiBjYW5jZWw7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTcGF3bihhY3RvclNjb3BlLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgX2FjdGlvblBhcmFtcywge1xuICBpZCxcbiAgc3lzdGVtSWQsXG4gIHNyYyxcbiAgaW5wdXQsXG4gIHN5bmNTbmFwc2hvdFxufSkge1xuICBjb25zdCBsb2dpYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gcmVzb2x2ZVJlZmVyZW5jZWRBY3RvcihzbmFwc2hvdC5tYWNoaW5lLCBzcmMpIDogc3JjO1xuICBjb25zdCByZXNvbHZlZElkID0gdHlwZW9mIGlkID09PSAnZnVuY3Rpb24nID8gaWQoYWN0aW9uQXJncykgOiBpZDtcbiAgbGV0IGFjdG9yUmVmO1xuICBsZXQgcmVzb2x2ZWRJbnB1dCA9IHVuZGVmaW5lZDtcbiAgaWYgKGxvZ2ljKSB7XG4gICAgcmVzb2x2ZWRJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/IGlucHV0KHtcbiAgICAgIGNvbnRleHQ6IHNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudDogYWN0aW9uQXJncy5ldmVudCxcbiAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZlxuICAgIH0pIDogaW5wdXQ7XG4gICAgYWN0b3JSZWYgPSBjcmVhdGVBY3Rvcihsb2dpYywge1xuICAgICAgaWQ6IHJlc29sdmVkSWQsXG4gICAgICBzcmMsXG4gICAgICBwYXJlbnQ6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIHN5bmNTbmFwc2hvdCxcbiAgICAgIHN5c3RlbUlkLFxuICAgICAgaW5wdXQ6IHJlc29sdmVkSW5wdXRcbiAgICB9KTtcbiAgfVxuICBpZiAoIWFjdG9yUmVmKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnMsQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgYEFjdG9yIHR5cGUgJyR7c3JjfScgbm90IGZvdW5kIGluIG1hY2hpbmUgJyR7YWN0b3JTY29wZS5pZH0nLmApO1xuICB9XG4gIHJldHVybiBbY2xvbmVNYWNoaW5lU25hcHNob3Qoc25hcHNob3QsIHtcbiAgICBjaGlsZHJlbjoge1xuICAgICAgLi4uc25hcHNob3QuY2hpbGRyZW4sXG4gICAgICBbcmVzb2x2ZWRJZF06IGFjdG9yUmVmXG4gICAgfVxuICB9KSwge1xuICAgIGlkLFxuICAgIHN5c3RlbUlkLFxuICAgIGFjdG9yUmVmLFxuICAgIHNyYyxcbiAgICBpbnB1dDogcmVzb2x2ZWRJbnB1dFxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVNwYXduKGFjdG9yU2NvcGUsIHtcbiAgYWN0b3JSZWZcbn0pIHtcbiAgaWYgKCFhY3RvclJlZikge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RvclNjb3BlLmRlZmVyKCgpID0+IHtcbiAgICBpZiAoYWN0b3JSZWYuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhY3RvclJlZi5zdGFydCgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNwYXduQ2hpbGQoLi4uW3NyYywge1xuICBpZCxcbiAgc3lzdGVtSWQsXG4gIGlucHV0LFxuICBzeW5jU25hcHNob3QgPSBmYWxzZVxufSA9IHt9XSkge1xuICBmdW5jdGlvbiBzcGF3bkNoaWxkKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzcGF3bkNoaWxkLnR5cGUgPSAneHN0YXRlLnNwYXduQ2hpbGQnO1xuICBzcGF3bkNoaWxkLmlkID0gaWQ7XG4gIHNwYXduQ2hpbGQuc3lzdGVtSWQgPSBzeXN0ZW1JZDtcbiAgc3Bhd25DaGlsZC5zcmMgPSBzcmM7XG4gIHNwYXduQ2hpbGQuaW5wdXQgPSBpbnB1dDtcbiAgc3Bhd25DaGlsZC5zeW5jU25hcHNob3QgPSBzeW5jU25hcHNob3Q7XG4gIHNwYXduQ2hpbGQucmVzb2x2ZSA9IHJlc29sdmVTcGF3bjtcbiAgc3Bhd25DaGlsZC5leGVjdXRlID0gZXhlY3V0ZVNwYXduO1xuICByZXR1cm4gc3Bhd25DaGlsZDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVN0b3AoXywgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBhY3RvclJlZlxufSkge1xuICBjb25zdCBhY3RvclJlZk9yU3RyaW5nID0gdHlwZW9mIGFjdG9yUmVmID09PSAnZnVuY3Rpb24nID8gYWN0b3JSZWYoYXJncywgYWN0aW9uUGFyYW1zKSA6IGFjdG9yUmVmO1xuICBjb25zdCByZXNvbHZlZEFjdG9yUmVmID0gdHlwZW9mIGFjdG9yUmVmT3JTdHJpbmcgPT09ICdzdHJpbmcnID8gc25hcHNob3QuY2hpbGRyZW5bYWN0b3JSZWZPclN0cmluZ10gOiBhY3RvclJlZk9yU3RyaW5nO1xuICBsZXQgY2hpbGRyZW4gPSBzbmFwc2hvdC5jaGlsZHJlbjtcbiAgaWYgKHJlc29sdmVkQWN0b3JSZWYpIHtcbiAgICBjaGlsZHJlbiA9IHtcbiAgICAgIC4uLmNoaWxkcmVuXG4gICAgfTtcbiAgICBkZWxldGUgY2hpbGRyZW5bcmVzb2x2ZWRBY3RvclJlZi5pZF07XG4gIH1cbiAgcmV0dXJuIFtjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwge1xuICAgIGNoaWxkcmVuXG4gIH0pLCByZXNvbHZlZEFjdG9yUmVmLCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZVN0b3AoYWN0b3JTY29wZSwgYWN0b3JSZWYpIHtcbiAgaWYgKCFhY3RvclJlZikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHdlIG5lZWQgdG8gZWFnZXJseSB1bnJlZ2lzdGVyIGl0IGhlcmUgc28gYSBuZXcgYWN0b3Igd2l0aCB0aGUgc2FtZSBzeXN0ZW1JZCBjYW4gYmUgcmVnaXN0ZXJlZCBpbW1lZGlhdGVseVxuICAvLyBzaW5jZSB3ZSBkZWZlciBhY3R1YWwgc3RvcHBpbmcgb2YgdGhlIGFjdG9yIGJ1dCB3ZSBkb24ndCBkZWZlciBhY3RvciBjcmVhdGlvbnMgKGFuZCB3ZSBjYW4ndCBkbyB0aGF0KVxuICAvLyB0aGlzIGNvdWxkIHRocm93IG9uIGBzeXN0ZW1JZGAgY29sbGlzaW9uLCBmb3IgZXhhbXBsZSwgd2hlbiBkZWFsaW5nIHdpdGggcmVlbnRlcmluZyB0cmFuc2l0aW9uc1xuICBhY3RvclNjb3BlLnN5c3RlbS5fdW5yZWdpc3RlcihhY3RvclJlZik7XG5cbiAgLy8gdGhpcyBhbGxvd3MgdXMgdG8gcHJldmVudCBhbiBhY3RvciBmcm9tIGJlaW5nIHN0YXJ0ZWQgaWYgaXQgZ2V0cyBzdG9wcGVkIHdpdGhpbiB0aGUgc2FtZSBtYWNyb3N0ZXBcbiAgLy8gdGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgd2hlbiB0aGUgaW52b2tpbmcgc3RhdGUgaXMgYmVpbmcgZXhpdGVkIGltbWVkaWF0ZWx5IGJ5IGFuIGFsd2F5cyB0cmFuc2l0aW9uXG4gIGlmIChhY3RvclJlZi5fcHJvY2Vzc2luZ1N0YXR1cyAhPT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgYWN0b3JTY29wZS5zdG9wQ2hpbGQoYWN0b3JSZWYpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzdG9wcGluZyBhIGNoaWxkIGVucXVldWVzIGEgc3RvcCBldmVudCBpbiB0aGUgY2hpbGQgYWN0b3IncyBtYWlsYm94XG4gIC8vIHdlIG5lZWQgZm9yIGFsbCBvZiB0aGUgYWxyZWFkeSBlbnF1ZXVlZCBldmVudHMgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSB3ZSBzdG9wIHRoZSBjaGlsZFxuICAvLyB0aGUgcGFyZW50IGl0c2VsZiBtaWdodCB3YW50IHRvIHNlbmQgc29tZSBldmVudHMgdG8gYSBjaGlsZCAoZm9yIGV4YW1wbGUgZnJvbSBleGl0IGFjdGlvbnMgb24gdGhlIGludm9raW5nIHN0YXRlKVxuICAvLyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBpZ25vcmUgdGhvc2UgZXZlbnRzXG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgIGFjdG9yU2NvcGUuc3RvcENoaWxkKGFjdG9yUmVmKTtcbiAgfSk7XG59XG4vKipcbiAqIFN0b3BzIGEgY2hpbGQgYWN0b3IuXG4gKlxuICogQHBhcmFtIGFjdG9yUmVmIFRoZSBhY3RvciB0byBzdG9wLlxuICovXG5mdW5jdGlvbiBzdG9wQ2hpbGQoYWN0b3JSZWYpIHtcbiAgZnVuY3Rpb24gc3RvcChfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgc3RvcC50eXBlID0gJ3hzdGF0ZS5zdG9wQ2hpbGQnO1xuICBzdG9wLmFjdG9yUmVmID0gYWN0b3JSZWY7XG4gIHN0b3AucmVzb2x2ZSA9IHJlc29sdmVTdG9wO1xuICBzdG9wLmV4ZWN1dGUgPSBleGVjdXRlU3RvcDtcbiAgcmV0dXJuIHN0b3A7XG59XG5cbi8qKlxuICogU3RvcHMgYSBjaGlsZCBhY3Rvci5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHN0b3BDaGlsZCguLi4pYCBpbnN0ZWFkXG4gKiBAYWxpYXNcbiAqL1xuY29uc3Qgc3RvcCA9IHN0b3BDaGlsZDtcblxuZnVuY3Rpb24gY2hlY2tTdGF0ZUluKHNuYXBzaG90LCBfLCB7XG4gIHN0YXRlVmFsdWVcbn0pIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJyAmJiBpc1N0YXRlSWQoc3RhdGVWYWx1ZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBzbmFwc2hvdC5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQoc3RhdGVWYWx1ZSk7XG4gICAgcmV0dXJuIHNuYXBzaG90Ll9ub2Rlcy5zb21lKHNuID0+IHNuID09PSB0YXJnZXQpO1xuICB9XG4gIHJldHVybiBzbmFwc2hvdC5tYXRjaGVzKHN0YXRlVmFsdWUpO1xufVxuZnVuY3Rpb24gc3RhdGVJbihzdGF0ZVZhbHVlKSB7XG4gIGZ1bmN0aW9uIHN0YXRlSW4oKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzdGF0ZUluLmNoZWNrID0gY2hlY2tTdGF0ZUluO1xuICBzdGF0ZUluLnN0YXRlVmFsdWUgPSBzdGF0ZVZhbHVlO1xuICByZXR1cm4gc3RhdGVJbjtcbn1cbmZ1bmN0aW9uIGNoZWNrTm90KHNuYXBzaG90LCB7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59LCB7XG4gIGd1YXJkc1xufSkge1xuICByZXR1cm4gIWV2YWx1YXRlR3VhcmQoZ3VhcmRzWzBdLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpO1xufVxuXG4vKipcbiAqIEhpZ2hlci1vcmRlciBndWFyZCB0aGF0IGV2YWx1YXRlcyB0byBgdHJ1ZWAgaWYgdGhlIGBndWFyZGAgcGFzc2VkIHRvIGl0XG4gKiBldmFsdWF0ZXMgdG8gYGZhbHNlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgR3VhcmRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXR1cCwgbm90IH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gc2V0dXAoe1xuICogICBndWFyZHM6IHtcbiAqICAgICBzb21lTmFtZWRHdWFyZDogKCkgPT4gZmFsc2VcbiAqICAgfVxuICogfSkuY3JlYXRlTWFjaGluZSh7XG4gKiAgIG9uOiB7XG4gKiAgICAgc29tZUV2ZW50OiB7XG4gKiAgICAgICBndWFyZDogbm90KCdzb21lTmFtZWRHdWFyZCcpLFxuICogICAgICAgYWN0aW9uczogKCkgPT4ge1xuICogICAgICAgICAvLyB3aWxsIGJlIGV4ZWN1dGVkIGlmIGd1YXJkIGluIGBub3QoLi4uKWBcbiAqICAgICAgICAgLy8gZXZhbHVhdGVzIHRvIGBmYWxzZWBcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHJldHVybnMgQSBndWFyZFxuICovXG5mdW5jdGlvbiBub3QoZ3VhcmQpIHtcbiAgZnVuY3Rpb24gbm90KF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBub3QuY2hlY2sgPSBjaGVja05vdDtcbiAgbm90Lmd1YXJkcyA9IFtndWFyZF07XG4gIHJldHVybiBub3Q7XG59XG5mdW5jdGlvbiBjaGVja0FuZChzbmFwc2hvdCwge1xuICBjb250ZXh0LFxuICBldmVudFxufSwge1xuICBndWFyZHNcbn0pIHtcbiAgcmV0dXJuIGd1YXJkcy5ldmVyeShndWFyZCA9PiBldmFsdWF0ZUd1YXJkKGd1YXJkLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpKTtcbn1cblxuLyoqXG4gKiBIaWdoZXItb3JkZXIgZ3VhcmQgdGhhdCBldmFsdWF0ZXMgdG8gYHRydWVgIGlmIGFsbCBgZ3VhcmRzYCBwYXNzZWQgdG8gaXRcbiAqIGV2YWx1YXRlIHRvIGB0cnVlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgR3VhcmRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXR1cCwgYW5kIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gc2V0dXAoe1xuICogICBndWFyZHM6IHtcbiAqICAgICBzb21lTmFtZWRHdWFyZDogKCkgPT4gdHJ1ZVxuICogICB9XG4gKiB9KS5jcmVhdGVNYWNoaW5lKHtcbiAqICAgb246IHtcbiAqICAgICBzb21lRXZlbnQ6IHtcbiAqICAgICAgIGd1YXJkOiBhbmQoWyh7IGNvbnRleHQgfSkgPT4gY29udGV4dC52YWx1ZSA+IDAsICdzb21lTmFtZWRHdWFyZCddKSxcbiAqICAgICAgIGFjdGlvbnM6ICgpID0+IHtcbiAqICAgICAgICAgLy8gd2lsbCBiZSBleGVjdXRlZCBpZiBhbGwgZ3VhcmRzIGluIGBhbmQoLi4uKWBcbiAqICAgICAgICAgLy8gZXZhbHVhdGUgdG8gdHJ1ZVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIGd1YXJkIGFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYW5kKGd1YXJkcykge1xuICBmdW5jdGlvbiBhbmQoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGFuZC5jaGVjayA9IGNoZWNrQW5kO1xuICBhbmQuZ3VhcmRzID0gZ3VhcmRzO1xuICByZXR1cm4gYW5kO1xufVxuZnVuY3Rpb24gY2hlY2tPcihzbmFwc2hvdCwge1xuICBjb250ZXh0LFxuICBldmVudFxufSwge1xuICBndWFyZHNcbn0pIHtcbiAgcmV0dXJuIGd1YXJkcy5zb21lKGd1YXJkID0+IGV2YWx1YXRlR3VhcmQoZ3VhcmQsIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCkpO1xufVxuXG4vKipcbiAqIEhpZ2hlci1vcmRlciBndWFyZCB0aGF0IGV2YWx1YXRlcyB0byBgdHJ1ZWAgaWYgYW55IG9mIHRoZSBgZ3VhcmRzYCBwYXNzZWQgdG9cbiAqIGl0IGV2YWx1YXRlIHRvIGB0cnVlYC5cbiAqXG4gKiBAY2F0ZWdvcnkgR3VhcmRzXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXR1cCwgb3IgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IG1hY2hpbmUgPSBzZXR1cCh7XG4gKiAgIGd1YXJkczoge1xuICogICAgIHNvbWVOYW1lZEd1YXJkOiAoKSA9PiB0cnVlXG4gKiAgIH1cbiAqIH0pLmNyZWF0ZU1hY2hpbmUoe1xuICogICBvbjoge1xuICogICAgIHNvbWVFdmVudDoge1xuICogICAgICAgZ3VhcmQ6IG9yKFsoeyBjb250ZXh0IH0pID0+IGNvbnRleHQudmFsdWUgPiAwLCAnc29tZU5hbWVkR3VhcmQnXSksXG4gKiAgICAgICBhY3Rpb25zOiAoKSA9PiB7XG4gKiAgICAgICAgIC8vIHdpbGwgYmUgZXhlY3V0ZWQgaWYgYW55IG9mIHRoZSBndWFyZHMgaW4gYG9yKC4uLilgXG4gKiAgICAgICAgIC8vIGV2YWx1YXRlIHRvIHRydWVcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHJldHVybnMgQSBndWFyZCBhY3Rpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG9yKGd1YXJkcykge1xuICBmdW5jdGlvbiBvcihfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgb3IuY2hlY2sgPSBjaGVja09yO1xuICBvci5ndWFyZHMgPSBndWFyZHM7XG4gIHJldHVybiBvcjtcbn1cblxuLy8gVE9ETzogdGhyb3cgb24gY3ljbGVzIChkZXB0aCBjaGVjayBzaG91bGQgYmUgZW5vdWdoKVxuZnVuY3Rpb24gZXZhbHVhdGVHdWFyZChndWFyZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KSB7XG4gIGNvbnN0IHtcbiAgICBtYWNoaW5lXG4gIH0gPSBzbmFwc2hvdDtcbiAgY29uc3QgaXNJbmxpbmUgPSB0eXBlb2YgZ3VhcmQgPT09ICdmdW5jdGlvbic7XG4gIGNvbnN0IHJlc29sdmVkID0gaXNJbmxpbmUgPyBndWFyZCA6IG1hY2hpbmUuaW1wbGVtZW50YXRpb25zLmd1YXJkc1t0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gZ3VhcmQgOiBndWFyZC50eXBlXTtcbiAgaWYgKCFpc0lubGluZSAmJiAhcmVzb2x2ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEd1YXJkICcke3R5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyBndWFyZCA6IGd1YXJkLnR5cGV9JyBpcyBub3QgaW1wbGVtZW50ZWQuJy5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc29sdmVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGV2YWx1YXRlR3VhcmQocmVzb2x2ZWQsIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCk7XG4gIH1cbiAgY29uc3QgZ3VhcmRBcmdzID0ge1xuICAgIGNvbnRleHQsXG4gICAgZXZlbnRcbiAgfTtcbiAgY29uc3QgZ3VhcmRQYXJhbXMgPSBpc0lubGluZSB8fCB0eXBlb2YgZ3VhcmQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogJ3BhcmFtcycgaW4gZ3VhcmQgPyB0eXBlb2YgZ3VhcmQucGFyYW1zID09PSAnZnVuY3Rpb24nID8gZ3VhcmQucGFyYW1zKHtcbiAgICBjb250ZXh0LFxuICAgIGV2ZW50XG4gIH0pIDogZ3VhcmQucGFyYW1zIDogdW5kZWZpbmVkO1xuICBpZiAoISgnY2hlY2snIGluIHJlc29sdmVkKSkge1xuICAgIC8vIHRoZSBleGlzdGluZyB0eXBlIG9mIGAuZ3VhcmRzYCBhc3N1bWVzIG5vbi1udWxsYWJsZSBgVEV4cHJlc3Npb25HdWFyZGBcbiAgICAvLyBpbmxpbmUgZ3VhcmRzIGV4cGVjdCBgVEV4cHJlc3Npb25HdWFyZGAgdG8gYmUgc2V0IHRvIGB1bmRlZmluZWRgXG4gICAgLy8gaXQncyBmaW5lIHRvIGNhc3QgdGhpcyBoZXJlLCBvdXIgbG9naWMgbWFrZXMgc3VyZSB0aGF0IHdlIGNhbGwgdGhvc2UgMiBcInZhcmlhbnRzXCIgY29ycmVjdGx5XG4gICAgcmV0dXJuIHJlc29sdmVkKGd1YXJkQXJncywgZ3VhcmRQYXJhbXMpO1xuICB9XG4gIGNvbnN0IGJ1aWx0aW5HdWFyZCA9IHJlc29sdmVkO1xuICByZXR1cm4gYnVpbHRpbkd1YXJkLmNoZWNrKHNuYXBzaG90LCBndWFyZEFyZ3MsIHJlc29sdmVkIC8vIHRoaXMgaG9sZHMgYWxsIHBhcmFtc1xuICApO1xufVxuXG5jb25zdCBpc0F0b21pY1N0YXRlTm9kZSA9IHN0YXRlTm9kZSA9PiBzdGF0ZU5vZGUudHlwZSA9PT0gJ2F0b21pYycgfHwgc3RhdGVOb2RlLnR5cGUgPT09ICdmaW5hbCc7XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3RhdGVOb2RlLnN0YXRlcykuZmlsdGVyKHNuID0+IHNuLnR5cGUgIT09ICdoaXN0b3J5Jyk7XG59XG5mdW5jdGlvbiBnZXRQcm9wZXJBbmNlc3RvcnMoc3RhdGVOb2RlLCB0b1N0YXRlTm9kZSkge1xuICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgaWYgKHRvU3RhdGVOb2RlID09PSBzdGF0ZU5vZGUpIHtcbiAgICByZXR1cm4gYW5jZXN0b3JzO1xuICB9XG5cbiAgLy8gYWRkIGFsbCBhbmNlc3RvcnNcbiAgbGV0IG0gPSBzdGF0ZU5vZGUucGFyZW50O1xuICB3aGlsZSAobSAmJiBtICE9PSB0b1N0YXRlTm9kZSkge1xuICAgIGFuY2VzdG9ycy5wdXNoKG0pO1xuICAgIG0gPSBtLnBhcmVudDtcbiAgfVxuICByZXR1cm4gYW5jZXN0b3JzO1xufVxuZnVuY3Rpb24gZ2V0QWxsU3RhdGVOb2RlcyhzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IG5vZGVTZXQgPSBuZXcgU2V0KHN0YXRlTm9kZXMpO1xuICBjb25zdCBhZGpMaXN0ID0gZ2V0QWRqTGlzdChub2RlU2V0KTtcblxuICAvLyBhZGQgZGVzY2VuZGFudHNcbiAgZm9yIChjb25zdCBzIG9mIG5vZGVTZXQpIHtcbiAgICAvLyBpZiBwcmV2aW91c2x5IGFjdGl2ZSwgYWRkIGV4aXN0aW5nIGNoaWxkIG5vZGVzXG4gICAgaWYgKHMudHlwZSA9PT0gJ2NvbXBvdW5kJyAmJiAoIWFkakxpc3QuZ2V0KHMpIHx8ICFhZGpMaXN0LmdldChzKS5sZW5ndGgpKSB7XG4gICAgICBnZXRJbml0aWFsU3RhdGVOb2Rlc1dpdGhUaGVpckFuY2VzdG9ycyhzKS5mb3JFYWNoKHNuID0+IG5vZGVTZXQuYWRkKHNuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnR5cGUgPT09ICdwYXJhbGxlbCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBnZXRDaGlsZHJlbihzKSkge1xuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnaGlzdG9yeScpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW5vZGVTZXQuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFN0YXRlcyA9IGdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzKGNoaWxkKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaW5pdGlhbFN0YXRlTm9kZSBvZiBpbml0aWFsU3RhdGVzKSB7XG4gICAgICAgICAgICAgIG5vZGVTZXQuYWRkKGluaXRpYWxTdGF0ZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBhbGwgYW5jZXN0b3JzXG4gIGZvciAoY29uc3QgcyBvZiBub2RlU2V0KSB7XG4gICAgbGV0IG0gPSBzLnBhcmVudDtcbiAgICB3aGlsZSAobSkge1xuICAgICAgbm9kZVNldC5hZGQobSk7XG4gICAgICBtID0gbS5wYXJlbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlU2V0O1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tQWRqKGJhc2VOb2RlLCBhZGpMaXN0KSB7XG4gIGNvbnN0IGNoaWxkU3RhdGVOb2RlcyA9IGFkakxpc3QuZ2V0KGJhc2VOb2RlKTtcbiAgaWYgKCFjaGlsZFN0YXRlTm9kZXMpIHtcbiAgICByZXR1cm4ge307IC8vIHRvZG86IGZpeD9cbiAgfVxuICBpZiAoYmFzZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIGNvbnN0IGNoaWxkU3RhdGVOb2RlID0gY2hpbGRTdGF0ZU5vZGVzWzBdO1xuICAgIGlmIChjaGlsZFN0YXRlTm9kZSkge1xuICAgICAgaWYgKGlzQXRvbWljU3RhdGVOb2RlKGNoaWxkU3RhdGVOb2RlKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRTdGF0ZU5vZGUua2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0YXRlVmFsdWUgPSB7fTtcbiAgZm9yIChjb25zdCBjaGlsZFN0YXRlTm9kZSBvZiBjaGlsZFN0YXRlTm9kZXMpIHtcbiAgICBzdGF0ZVZhbHVlW2NoaWxkU3RhdGVOb2RlLmtleV0gPSBnZXRWYWx1ZUZyb21BZGooY2hpbGRTdGF0ZU5vZGUsIGFkakxpc3QpO1xuICB9XG4gIHJldHVybiBzdGF0ZVZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QWRqTGlzdChzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IGFkakxpc3QgPSBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgcyBvZiBzdGF0ZU5vZGVzKSB7XG4gICAgaWYgKCFhZGpMaXN0LmhhcyhzKSkge1xuICAgICAgYWRqTGlzdC5zZXQocywgW10pO1xuICAgIH1cbiAgICBpZiAocy5wYXJlbnQpIHtcbiAgICAgIGlmICghYWRqTGlzdC5oYXMocy5wYXJlbnQpKSB7XG4gICAgICAgIGFkakxpc3Quc2V0KHMucGFyZW50LCBbXSk7XG4gICAgICB9XG4gICAgICBhZGpMaXN0LmdldChzLnBhcmVudCkucHVzaChzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFkakxpc3Q7XG59XG5mdW5jdGlvbiBnZXRTdGF0ZVZhbHVlKHJvb3ROb2RlLCBzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGdldEFsbFN0YXRlTm9kZXMoc3RhdGVOb2Rlcyk7XG4gIHJldHVybiBnZXRWYWx1ZUZyb21BZGoocm9vdE5vZGUsIGdldEFkakxpc3QoY29uZmlnKSk7XG59XG5mdW5jdGlvbiBpc0luRmluYWxTdGF0ZShzdGF0ZU5vZGVTZXQsIHN0YXRlTm9kZSkge1xuICBpZiAoc3RhdGVOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlKS5zb21lKHMgPT4gcy50eXBlID09PSAnZmluYWwnICYmIHN0YXRlTm9kZVNldC5oYXMocykpO1xuICB9XG4gIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpLmV2ZXJ5KHNuID0+IGlzSW5GaW5hbFN0YXRlKHN0YXRlTm9kZVNldCwgc24pKTtcbiAgfVxuICByZXR1cm4gc3RhdGVOb2RlLnR5cGUgPT09ICdmaW5hbCc7XG59XG5jb25zdCBpc1N0YXRlSWQgPSBzdHIgPT4gc3RyWzBdID09PSBTVEFURV9JREVOVElGSUVSO1xuZnVuY3Rpb24gZ2V0Q2FuZGlkYXRlcyhzdGF0ZU5vZGUsIHJlY2VpdmVkRXZlbnRUeXBlKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBzdGF0ZU5vZGUudHJhbnNpdGlvbnMuZ2V0KHJlY2VpdmVkRXZlbnRUeXBlKSB8fCBbLi4uc3RhdGVOb2RlLnRyYW5zaXRpb25zLmtleXMoKV0uZmlsdGVyKGV2ZW50RGVzY3JpcHRvciA9PiB7XG4gICAgLy8gY2hlY2sgaWYgdHJhbnNpdGlvbiBpcyBhIHdpbGRjYXJkIHRyYW5zaXRpb24sXG4gICAgLy8gd2hpY2ggbWF0Y2hlcyBhbnkgbm9uLXRyYW5zaWVudCBldmVudHNcbiAgICBpZiAoZXZlbnREZXNjcmlwdG9yID09PSBXSUxEQ0FSRCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZXZlbnREZXNjcmlwdG9yLmVuZHNXaXRoKCcuKicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgvLipcXCouKy8udGVzdChldmVudERlc2NyaXB0b3IpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFdpbGRjYXJkcyBjYW4gb25seSBiZSB0aGUgbGFzdCB0b2tlbiBvZiBhbiBldmVudCBkZXNjcmlwdG9yIChlLmcuLCBcImV2ZW50LipcIikgb3IgdGhlIGVudGlyZSBldmVudCBkZXNjcmlwdG9yIChcIipcIikuIENoZWNrIHRoZSBcIiR7ZXZlbnREZXNjcmlwdG9yfVwiIGV2ZW50LmApO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0aWFsRXZlbnRUb2tlbnMgPSBldmVudERlc2NyaXB0b3Iuc3BsaXQoJy4nKTtcbiAgICBjb25zdCBldmVudFRva2VucyA9IHJlY2VpdmVkRXZlbnRUeXBlLnNwbGl0KCcuJyk7XG4gICAgZm9yIChsZXQgdG9rZW5JbmRleCA9IDA7IHRva2VuSW5kZXggPCBwYXJ0aWFsRXZlbnRUb2tlbnMubGVuZ3RoOyB0b2tlbkluZGV4KyspIHtcbiAgICAgIGNvbnN0IHBhcnRpYWxFdmVudFRva2VuID0gcGFydGlhbEV2ZW50VG9rZW5zW3Rva2VuSW5kZXhdO1xuICAgICAgY29uc3QgZXZlbnRUb2tlbiA9IGV2ZW50VG9rZW5zW3Rva2VuSW5kZXhdO1xuICAgICAgaWYgKHBhcnRpYWxFdmVudFRva2VuID09PSAnKicpIHtcbiAgICAgICAgY29uc3QgaXNMYXN0VG9rZW4gPSB0b2tlbkluZGV4ID09PSBwYXJ0aWFsRXZlbnRUb2tlbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKCFpc0xhc3RUb2tlbikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgSW5maXggd2lsZGNhcmRzIGluIHRyYW5zaXRpb24gZXZlbnRzIGFyZSBub3QgYWxsb3dlZC4gQ2hlY2sgdGhlIFwiJHtldmVudERlc2NyaXB0b3J9XCIgdHJhbnNpdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNMYXN0VG9rZW47XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbEV2ZW50VG9rZW4gIT09IGV2ZW50VG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCkuZmxhdE1hcChrZXkgPT4gc3RhdGVOb2RlLnRyYW5zaXRpb25zLmdldChrZXkpKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59XG5cbi8qKiBBbGwgZGVsYXllZCB0cmFuc2l0aW9ucyBmcm9tIHRoZSBjb25maWcuICovXG5mdW5jdGlvbiBnZXREZWxheWVkVHJhbnNpdGlvbnMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IGFmdGVyQ29uZmlnID0gc3RhdGVOb2RlLmNvbmZpZy5hZnRlcjtcbiAgaWYgKCFhZnRlckNvbmZpZykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBtdXRhdGVFbnRyeUV4aXQgPSBkZWxheSA9PiB7XG4gICAgY29uc3QgYWZ0ZXJFdmVudCA9IGNyZWF0ZUFmdGVyRXZlbnQoZGVsYXksIHN0YXRlTm9kZS5pZCk7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gYWZ0ZXJFdmVudC50eXBlO1xuICAgIHN0YXRlTm9kZS5lbnRyeS5wdXNoKHJhaXNlKGFmdGVyRXZlbnQsIHtcbiAgICAgIGlkOiBldmVudFR5cGUsXG4gICAgICBkZWxheVxuICAgIH0pKTtcbiAgICBzdGF0ZU5vZGUuZXhpdC5wdXNoKGNhbmNlbChldmVudFR5cGUpKTtcbiAgICByZXR1cm4gZXZlbnRUeXBlO1xuICB9O1xuICBjb25zdCBkZWxheWVkVHJhbnNpdGlvbnMgPSBPYmplY3Qua2V5cyhhZnRlckNvbmZpZykuZmxhdE1hcChkZWxheSA9PiB7XG4gICAgY29uc3QgY29uZmlnVHJhbnNpdGlvbiA9IGFmdGVyQ29uZmlnW2RlbGF5XTtcbiAgICBjb25zdCByZXNvbHZlZFRyYW5zaXRpb24gPSB0eXBlb2YgY29uZmlnVHJhbnNpdGlvbiA9PT0gJ3N0cmluZycgPyB7XG4gICAgICB0YXJnZXQ6IGNvbmZpZ1RyYW5zaXRpb25cbiAgICB9IDogY29uZmlnVHJhbnNpdGlvbjtcbiAgICBjb25zdCByZXNvbHZlZERlbGF5ID0gTnVtYmVyLmlzTmFOKCtkZWxheSkgPyBkZWxheSA6ICtkZWxheTtcbiAgICBjb25zdCBldmVudFR5cGUgPSBtdXRhdGVFbnRyeUV4aXQocmVzb2x2ZWREZWxheSk7XG4gICAgcmV0dXJuIHRvQXJyYXkocmVzb2x2ZWRUcmFuc2l0aW9uKS5tYXAodHJhbnNpdGlvbiA9PiAoe1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIGV2ZW50OiBldmVudFR5cGUsXG4gICAgICBkZWxheTogcmVzb2x2ZWREZWxheVxuICAgIH0pKTtcbiAgfSk7XG4gIHJldHVybiBkZWxheWVkVHJhbnNpdGlvbnMubWFwKGRlbGF5ZWRUcmFuc2l0aW9uID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkZWxheVxuICAgIH0gPSBkZWxheWVkVHJhbnNpdGlvbjtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlbGF5ZWRUcmFuc2l0aW9uLmV2ZW50LCBkZWxheWVkVHJhbnNpdGlvbiksXG4gICAgICBkZWxheVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlc2NyaXB0b3IsIHRyYW5zaXRpb25Db25maWcpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFRhcmdldCA9IG5vcm1hbGl6ZVRhcmdldCh0cmFuc2l0aW9uQ29uZmlnLnRhcmdldCk7XG4gIGNvbnN0IHJlZW50ZXIgPSB0cmFuc2l0aW9uQ29uZmlnLnJlZW50ZXIgPz8gZmFsc2U7XG4gIGNvbnN0IHRhcmdldCA9IHJlc29sdmVUYXJnZXQoc3RhdGVOb2RlLCBub3JtYWxpemVkVGFyZ2V0KTtcblxuICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBwYXJ0IG9mIGEgbGludCBydWxlIGluc3RlYWQ/XG4gIGlmICh0cmFuc2l0aW9uQ29uZmlnLmNvbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlIFwiJHtzdGF0ZU5vZGUuaWR9XCIgaGFzIGRlY2xhcmVkIFxcYGNvbmRcXGAgZm9yIG9uZSBvZiBpdHMgdHJhbnNpdGlvbnMuIFRoaXMgcHJvcGVydHkgaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBndWFyZFxcYC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGNvZGUuYCk7XG4gIH1cbiAgY29uc3QgdHJhbnNpdGlvbiA9IHtcbiAgICAuLi50cmFuc2l0aW9uQ29uZmlnLFxuICAgIGFjdGlvbnM6IHRvQXJyYXkodHJhbnNpdGlvbkNvbmZpZy5hY3Rpb25zKSxcbiAgICBndWFyZDogdHJhbnNpdGlvbkNvbmZpZy5ndWFyZCxcbiAgICB0YXJnZXQsXG4gICAgc291cmNlOiBzdGF0ZU5vZGUsXG4gICAgcmVlbnRlcixcbiAgICBldmVudFR5cGU6IGRlc2NyaXB0b3IsXG4gICAgdG9KU09OOiAoKSA9PiAoe1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIHNvdXJjZTogYCMke3N0YXRlTm9kZS5pZH1gLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQgPyB0YXJnZXQubWFwKHQgPT4gYCMke3QuaWR9YCkgOiB1bmRlZmluZWRcbiAgICB9KVxuICB9O1xuICByZXR1cm4gdHJhbnNpdGlvbjtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRyYW5zaXRpb25zKHN0YXRlTm9kZSkge1xuICBjb25zdCB0cmFuc2l0aW9ucyA9IG5ldyBNYXAoKTtcbiAgaWYgKHN0YXRlTm9kZS5jb25maWcub24pIHtcbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgT2JqZWN0LmtleXMoc3RhdGVOb2RlLmNvbmZpZy5vbikpIHtcbiAgICAgIGlmIChkZXNjcmlwdG9yID09PSBOVUxMX0VWRU5UKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTnVsbCBldmVudHMgKFwiXCIpIGNhbm5vdCBiZSBzcGVjaWZpZWQgYXMgYSB0cmFuc2l0aW9uIGtleS4gVXNlIGBhbHdheXM6IHsgLi4uIH1gIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2l0aW9uc0NvbmZpZyA9IHN0YXRlTm9kZS5jb25maWcub25bZGVzY3JpcHRvcl07XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkodHJhbnNpdGlvbnNDb25maWcpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGVOb2RlLmNvbmZpZy5vbkRvbmUpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gYHhzdGF0ZS5kb25lLnN0YXRlLiR7c3RhdGVOb2RlLmlkfWA7XG4gICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KHN0YXRlTm9kZS5jb25maWcub25Eb25lKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgfVxuICBmb3IgKGNvbnN0IGludm9rZURlZiBvZiBzdGF0ZU5vZGUuaW52b2tlKSB7XG4gICAgaWYgKGludm9rZURlZi5vbkRvbmUpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLmRvbmUuYWN0b3IuJHtpbnZva2VEZWYuaWR9YDtcbiAgICAgIHRyYW5zaXRpb25zLnNldChkZXNjcmlwdG9yLCB0b1RyYW5zaXRpb25Db25maWdBcnJheShpbnZva2VEZWYub25Eb25lKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgICB9XG4gICAgaWYgKGludm9rZURlZi5vbkVycm9yKSB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gYHhzdGF0ZS5lcnJvci5hY3Rvci4ke2ludm9rZURlZi5pZH1gO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGludm9rZURlZi5vbkVycm9yKS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgICB9XG4gICAgaWYgKGludm9rZURlZi5vblNuYXBzaG90KSB7XG4gICAgICBjb25zdCBkZXNjcmlwdG9yID0gYHhzdGF0ZS5zbmFwc2hvdC4ke2ludm9rZURlZi5pZH1gO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGludm9rZURlZi5vblNuYXBzaG90KS5tYXAodCA9PiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdCkpKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBkZWxheWVkVHJhbnNpdGlvbiBvZiBzdGF0ZU5vZGUuYWZ0ZXIpIHtcbiAgICBsZXQgZXhpc3RpbmcgPSB0cmFuc2l0aW9ucy5nZXQoZGVsYXllZFRyYW5zaXRpb24uZXZlbnRUeXBlKTtcbiAgICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgICBleGlzdGluZyA9IFtdO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlbGF5ZWRUcmFuc2l0aW9uLmV2ZW50VHlwZSwgZXhpc3RpbmcpO1xuICAgIH1cbiAgICBleGlzdGluZy5wdXNoKGRlbGF5ZWRUcmFuc2l0aW9uKTtcbiAgfVxuICByZXR1cm4gdHJhbnNpdGlvbnM7XG59XG5mdW5jdGlvbiBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbihzdGF0ZU5vZGUsIF90YXJnZXQpIHtcbiAgY29uc3QgcmVzb2x2ZWRUYXJnZXQgPSB0eXBlb2YgX3RhcmdldCA9PT0gJ3N0cmluZycgPyBzdGF0ZU5vZGUuc3RhdGVzW190YXJnZXRdIDogX3RhcmdldCA/IHN0YXRlTm9kZS5zdGF0ZXNbX3RhcmdldC50YXJnZXRdIDogdW5kZWZpbmVkO1xuICBpZiAoIXJlc29sdmVkVGFyZ2V0ICYmIF90YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucywgQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgYEluaXRpYWwgc3RhdGUgbm9kZSBcIiR7X3RhcmdldH1cIiBub3QgZm91bmQgb24gcGFyZW50IHN0YXRlIG5vZGUgIyR7c3RhdGVOb2RlLmlkfWApO1xuICB9XG4gIGNvbnN0IHRyYW5zaXRpb24gPSB7XG4gICAgc291cmNlOiBzdGF0ZU5vZGUsXG4gICAgYWN0aW9uczogIV90YXJnZXQgfHwgdHlwZW9mIF90YXJnZXQgPT09ICdzdHJpbmcnID8gW10gOiB0b0FycmF5KF90YXJnZXQuYWN0aW9ucyksXG4gICAgZXZlbnRUeXBlOiBudWxsLFxuICAgIHJlZW50ZXI6IGZhbHNlLFxuICAgIHRhcmdldDogcmVzb2x2ZWRUYXJnZXQgPyBbcmVzb2x2ZWRUYXJnZXRdIDogW10sXG4gICAgdG9KU09OOiAoKSA9PiAoe1xuICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgIHNvdXJjZTogYCMke3N0YXRlTm9kZS5pZH1gLFxuICAgICAgdGFyZ2V0OiByZXNvbHZlZFRhcmdldCA/IFtgIyR7cmVzb2x2ZWRUYXJnZXQuaWR9YF0gOiBbXVxuICAgIH0pXG4gIH07XG4gIHJldHVybiB0cmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzdGF0ZU5vZGUsIHRhcmdldHMpIHtcbiAgaWYgKHRhcmdldHMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGFuIHVuZGVmaW5lZCB0YXJnZXQgc2lnbmFscyB0aGF0IHRoZSBzdGF0ZSBub2RlIHNob3VsZCBub3QgdHJhbnNpdGlvbiBmcm9tIHRoYXQgc3RhdGUgd2hlbiByZWNlaXZpbmcgdGhhdCBldmVudFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHRhcmdldHMubWFwKHRhcmdldCA9PiB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoaXNTdGF0ZUlkKHRhcmdldCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGUubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHRhcmdldCk7XG4gICAgfVxuICAgIGNvbnN0IGlzSW50ZXJuYWxUYXJnZXQgPSB0YXJnZXRbMF0gPT09IFNUQVRFX0RFTElNSVRFUjtcbiAgICAvLyBJZiBpbnRlcm5hbCB0YXJnZXQgaXMgZGVmaW5lZCBvbiBtYWNoaW5lLFxuICAgIC8vIGRvIG5vdCBpbmNsdWRlIG1hY2hpbmUga2V5IG9uIHRhcmdldFxuICAgIGlmIChpc0ludGVybmFsVGFyZ2V0ICYmICFzdGF0ZU5vZGUucGFyZW50KSB7XG4gICAgICByZXR1cm4gZ2V0U3RhdGVOb2RlQnlQYXRoKHN0YXRlTm9kZSwgdGFyZ2V0LnNsaWNlKDEpKTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRUYXJnZXQgPSBpc0ludGVybmFsVGFyZ2V0ID8gc3RhdGVOb2RlLmtleSArIHRhcmdldCA6IHRhcmdldDtcbiAgICBpZiAoc3RhdGVOb2RlLnBhcmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlQnlQYXRoKHN0YXRlTm9kZS5wYXJlbnQsIHJlc29sdmVkVGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlTm9kZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJhbnNpdGlvbiBkZWZpbml0aW9uIGZvciBzdGF0ZSBub2RlICcke3N0YXRlTm9kZS5pZH0nOlxcbiR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0YXJnZXQ6IFwiJHt0YXJnZXR9XCIgaXMgbm90IGEgdmFsaWQgdGFyZ2V0IGZyb20gdGhlIHJvb3Qgbm9kZS4gRGlkIHlvdSBtZWFuIFwiLiR7dGFyZ2V0fVwiP2ApO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlSGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uKHN0YXRlTm9kZSkge1xuICBjb25zdCBub3JtYWxpemVkVGFyZ2V0ID0gbm9ybWFsaXplVGFyZ2V0KHN0YXRlTm9kZS5jb25maWcudGFyZ2V0KTtcbiAgaWYgKCFub3JtYWxpemVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5wYXJlbnQuaW5pdGlhbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRhcmdldDogbm9ybWFsaXplZFRhcmdldC5tYXAodCA9PiB0eXBlb2YgdCA9PT0gJ3N0cmluZycgPyBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLnBhcmVudCwgdCkgOiB0KVxuICB9O1xufVxuZnVuY3Rpb24gaXNIaXN0b3J5Tm9kZShzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIHN0YXRlTm9kZS50eXBlID09PSAnaGlzdG9yeSc7XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsU3RhdGVOb2Rlc1dpdGhUaGVpckFuY2VzdG9ycyhzdGF0ZU5vZGUpIHtcbiAgY29uc3Qgc3RhdGVzID0gZ2V0SW5pdGlhbFN0YXRlTm9kZXMoc3RhdGVOb2RlKTtcbiAgZm9yIChjb25zdCBpbml0aWFsU3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBhbmNlc3RvciBvZiBnZXRQcm9wZXJBbmNlc3RvcnMoaW5pdGlhbFN0YXRlLCBzdGF0ZU5vZGUpKSB7XG4gICAgICBzdGF0ZXMuYWRkKGFuY2VzdG9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlcztcbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZU5vZGVzKHN0YXRlTm9kZSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIGZ1bmN0aW9uIGl0ZXIoZGVzY1N0YXRlTm9kZSkge1xuICAgIGlmIChzZXQuaGFzKGRlc2NTdGF0ZU5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldC5hZGQoZGVzY1N0YXRlTm9kZSk7XG4gICAgaWYgKGRlc2NTdGF0ZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgaXRlcihkZXNjU3RhdGVOb2RlLmluaXRpYWwudGFyZ2V0WzBdKTtcbiAgICB9IGVsc2UgaWYgKGRlc2NTdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBnZXRDaGlsZHJlbihkZXNjU3RhdGVOb2RlKSkge1xuICAgICAgICBpdGVyKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXRlcihzdGF0ZU5vZGUpO1xuICByZXR1cm4gc2V0O1xufVxuLyoqIFJldHVybnMgdGhlIGNoaWxkIHN0YXRlIG5vZGUgZnJvbSBpdHMgcmVsYXRpdmUgYHN0YXRlS2V5YCwgb3IgdGhyb3dzLiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3RhdGVLZXkpIHtcbiAgaWYgKGlzU3RhdGVJZChzdGF0ZUtleSkpIHtcbiAgICByZXR1cm4gc3RhdGVOb2RlLm1hY2hpbmUuZ2V0U3RhdGVOb2RlQnlJZChzdGF0ZUtleSk7XG4gIH1cbiAgaWYgKCFzdGF0ZU5vZGUuc3RhdGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmV0cmlldmUgY2hpbGQgc3RhdGUgJyR7c3RhdGVLZXl9JyBmcm9tICcke3N0YXRlTm9kZS5pZH0nOyBubyBjaGlsZCBzdGF0ZXMgZXhpc3QuYCk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gc3RhdGVOb2RlLnN0YXRlc1tzdGF0ZUtleV07XG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDaGlsZCBzdGF0ZSAnJHtzdGF0ZUtleX0nIGRvZXMgbm90IGV4aXN0IG9uICcke3N0YXRlTm9kZS5pZH0nYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWxhdGl2ZSBzdGF0ZSBub2RlIGZyb20gdGhlIGdpdmVuIGBzdGF0ZVBhdGhgLCBvciB0aHJvd3MuXG4gKlxuICogQHBhcmFtIHN0YXRlUGF0aCBUaGUgc3RyaW5nIG9yIHN0cmluZyBhcnJheSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBzdGF0ZSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCBzdGF0ZVBhdGgpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVBhdGggPT09ICdzdHJpbmcnICYmIGlzU3RhdGVJZChzdGF0ZVBhdGgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzdGF0ZU5vZGUubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlUGF0aCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyB0cnkgaW5kaXZpZHVhbCBwYXRoc1xuICAgICAgLy8gdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYXJyYXlTdGF0ZVBhdGggPSB0b1N0YXRlUGF0aChzdGF0ZVBhdGgpLnNsaWNlKCk7XG4gIGxldCBjdXJyZW50U3RhdGVOb2RlID0gc3RhdGVOb2RlO1xuICB3aGlsZSAoYXJyYXlTdGF0ZVBhdGgubGVuZ3RoKSB7XG4gICAgY29uc3Qga2V5ID0gYXJyYXlTdGF0ZVBhdGguc2hpZnQoKTtcbiAgICBpZiAoIWtleS5sZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjdXJyZW50U3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlKGN1cnJlbnRTdGF0ZU5vZGUsIGtleSk7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZU5vZGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RhdGUgbm9kZXMgcmVwcmVzZW50ZWQgYnkgdGhlIGN1cnJlbnQgc3RhdGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIHN0YXRlVmFsdWUgVGhlIHN0YXRlIHZhbHVlIG9yIFN0YXRlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlTm9kZXMoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IHN0YXRlTm9kZS5zdGF0ZXNbc3RhdGVWYWx1ZV07XG4gICAgaWYgKCFjaGlsZFN0YXRlTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGF0ZSAnJHtzdGF0ZVZhbHVlfScgZG9lcyBub3QgZXhpc3Qgb24gJyR7c3RhdGVOb2RlLmlkfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdGF0ZU5vZGUsIGNoaWxkU3RhdGVOb2RlXTtcbiAgfVxuICBjb25zdCBjaGlsZFN0YXRlS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpO1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZXMgPSBjaGlsZFN0YXRlS2V5cy5tYXAoc3ViU3RhdGVLZXkgPT4gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3ViU3RhdGVLZXkpKS5maWx0ZXIoQm9vbGVhbik7XG4gIHJldHVybiBbc3RhdGVOb2RlLm1hY2hpbmUucm9vdCwgc3RhdGVOb2RlXS5jb25jYXQoY2hpbGRTdGF0ZU5vZGVzLCBjaGlsZFN0YXRlS2V5cy5yZWR1Y2UoKGFsbFN1YlN0YXRlTm9kZXMsIHN1YlN0YXRlS2V5KSA9PiB7XG4gICAgY29uc3Qgc3ViU3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3ViU3RhdGVLZXkpO1xuICAgIGlmICghc3ViU3RhdGVOb2RlKSB7XG4gICAgICByZXR1cm4gYWxsU3ViU3RhdGVOb2RlcztcbiAgICB9XG4gICAgY29uc3Qgc3ViU3RhdGVOb2RlcyA9IGdldFN0YXRlTm9kZXMoc3ViU3RhdGVOb2RlLCBzdGF0ZVZhbHVlW3N1YlN0YXRlS2V5XSk7XG4gICAgcmV0dXJuIGFsbFN1YlN0YXRlTm9kZXMuY29uY2F0KHN1YlN0YXRlTm9kZXMpO1xuICB9LCBbXSkpO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbkF0b21pY05vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgY29uc3QgY2hpbGRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlKTtcbiAgY29uc3QgbmV4dCA9IGNoaWxkU3RhdGVOb2RlLm5leHQoc25hcHNob3QsIGV2ZW50KTtcbiAgaWYgKCFuZXh0IHx8ICFuZXh0Lmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbkNvbXBvdW5kTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBzdWJTdGF0ZUtleXMgPSBPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKTtcbiAgY29uc3QgY2hpbGRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleXNbMF0pO1xuICBjb25zdCBuZXh0ID0gdHJhbnNpdGlvbk5vZGUoY2hpbGRTdGF0ZU5vZGUsIHN0YXRlVmFsdWVbc3ViU3RhdGVLZXlzWzBdXSwgc25hcHNob3QsIGV2ZW50KTtcbiAgaWYgKCFuZXh0IHx8ICFuZXh0Lmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBuZXh0O1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvblBhcmFsbGVsTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBhbGxJbm5lclRyYW5zaXRpb25zID0gW107XG4gIGZvciAoY29uc3Qgc3ViU3RhdGVLZXkgb2YgT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSkpIHtcbiAgICBjb25zdCBzdWJTdGF0ZVZhbHVlID0gc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleV07XG4gICAgaWYgKCFzdWJTdGF0ZVZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViU3RhdGVOb2RlID0gZ2V0U3RhdGVOb2RlKHN0YXRlTm9kZSwgc3ViU3RhdGVLZXkpO1xuICAgIGNvbnN0IGlubmVyVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uTm9kZShzdWJTdGF0ZU5vZGUsIHN1YlN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gICAgaWYgKGlubmVyVHJhbnNpdGlvbnMpIHtcbiAgICAgIGFsbElubmVyVHJhbnNpdGlvbnMucHVzaCguLi5pbm5lclRyYW5zaXRpb25zKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFhbGxJbm5lclRyYW5zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBhbGxJbm5lclRyYW5zaXRpb25zO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbk5vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgLy8gbGVhZiBub2RlXG4gIGlmICh0eXBlb2Ygc3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbkF0b21pY05vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG5cbiAgLy8gY29tcG91bmQgbm9kZVxuICBpZiAoT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSkubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25Db21wb3VuZE5vZGUoc3RhdGVOb2RlLCBzdGF0ZVZhbHVlLCBzbmFwc2hvdCwgZXZlbnQpO1xuICB9XG5cbiAgLy8gcGFyYWxsZWwgbm9kZVxuICByZXR1cm4gdHJhbnNpdGlvblBhcmFsbGVsTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG59XG5mdW5jdGlvbiBnZXRIaXN0b3J5Tm9kZXMoc3RhdGVOb2RlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzdGF0ZU5vZGUuc3RhdGVzKS5tYXAoa2V5ID0+IHN0YXRlTm9kZS5zdGF0ZXNba2V5XSkuZmlsdGVyKHNuID0+IHNuLnR5cGUgPT09ICdoaXN0b3J5Jyk7XG59XG5mdW5jdGlvbiBpc0Rlc2NlbmRhbnQoY2hpbGRTdGF0ZU5vZGUsIHBhcmVudFN0YXRlTm9kZSkge1xuICBsZXQgbWFya2VyID0gY2hpbGRTdGF0ZU5vZGU7XG4gIHdoaWxlIChtYXJrZXIucGFyZW50ICYmIG1hcmtlci5wYXJlbnQgIT09IHBhcmVudFN0YXRlTm9kZSkge1xuICAgIG1hcmtlciA9IG1hcmtlci5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG1hcmtlci5wYXJlbnQgPT09IHBhcmVudFN0YXRlTm9kZTtcbn1cbmZ1bmN0aW9uIGhhc0ludGVyc2VjdGlvbihzMSwgczIpIHtcbiAgY29uc3Qgc2V0MSA9IG5ldyBTZXQoczEpO1xuICBjb25zdCBzZXQyID0gbmV3IFNldChzMik7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBzZXQxKSB7XG4gICAgaWYgKHNldDIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIHNldDIpIHtcbiAgICBpZiAoc2V0MS5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZW1vdmVDb25mbGljdGluZ1RyYW5zaXRpb25zKGVuYWJsZWRUcmFuc2l0aW9ucywgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3QgZmlsdGVyZWRUcmFuc2l0aW9ucyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0MSBvZiBlbmFibGVkVHJhbnNpdGlvbnMpIHtcbiAgICBsZXQgdDFQcmVlbXB0ZWQgPSBmYWxzZTtcbiAgICBjb25zdCB0cmFuc2l0aW9uc1RvUmVtb3ZlID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdDIgb2YgZmlsdGVyZWRUcmFuc2l0aW9ucykge1xuICAgICAgaWYgKGhhc0ludGVyc2VjdGlvbihjb21wdXRlRXhpdFNldChbdDFdLCBzdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSksIGNvbXB1dGVFeGl0U2V0KFt0Ml0sIHN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKSkpIHtcbiAgICAgICAgaWYgKGlzRGVzY2VuZGFudCh0MS5zb3VyY2UsIHQyLnNvdXJjZSkpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uc1RvUmVtb3ZlLmFkZCh0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdDFQcmVlbXB0ZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdDFQcmVlbXB0ZWQpIHtcbiAgICAgIGZvciAoY29uc3QgdDMgb2YgdHJhbnNpdGlvbnNUb1JlbW92ZSkge1xuICAgICAgICBmaWx0ZXJlZFRyYW5zaXRpb25zLmRlbGV0ZSh0Myk7XG4gICAgICB9XG4gICAgICBmaWx0ZXJlZFRyYW5zaXRpb25zLmFkZCh0MSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGZpbHRlcmVkVHJhbnNpdGlvbnMpO1xufVxuZnVuY3Rpb24gZmluZExlYXN0Q29tbW9uQW5jZXN0b3Ioc3RhdGVOb2Rlcykge1xuICBjb25zdCBbaGVhZCwgLi4udGFpbF0gPSBzdGF0ZU5vZGVzO1xuICBmb3IgKGNvbnN0IGFuY2VzdG9yIG9mIGdldFByb3BlckFuY2VzdG9ycyhoZWFkLCB1bmRlZmluZWQpKSB7XG4gICAgaWYgKHRhaWwuZXZlcnkoc24gPT4gaXNEZXNjZW5kYW50KHNuLCBhbmNlc3RvcikpKSB7XG4gICAgICByZXR1cm4gYW5jZXN0b3I7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXModHJhbnNpdGlvbiwgaGlzdG9yeVZhbHVlKSB7XG4gIGlmICghdHJhbnNpdGlvbi50YXJnZXQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgdGFyZ2V0cyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0YXJnZXROb2RlIG9mIHRyYW5zaXRpb24udGFyZ2V0KSB7XG4gICAgaWYgKGlzSGlzdG9yeU5vZGUodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChoaXN0b3J5VmFsdWVbdGFyZ2V0Tm9kZS5pZF0pIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGhpc3RvcnlWYWx1ZVt0YXJnZXROb2RlLmlkXSkge1xuICAgICAgICAgIHRhcmdldHMuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ2V0RWZmZWN0aXZlVGFyZ2V0U3RhdGVzKHJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24odGFyZ2V0Tm9kZSksIGhpc3RvcnlWYWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXRzLmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRzLmFkZCh0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi50YXJnZXRzXTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25Eb21haW4odHJhbnNpdGlvbiwgaGlzdG9yeVZhbHVlKSB7XG4gIGNvbnN0IHRhcmdldFN0YXRlcyA9IGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpO1xuICBpZiAoIXRhcmdldFN0YXRlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXRyYW5zaXRpb24ucmVlbnRlciAmJiB0YXJnZXRTdGF0ZXMuZXZlcnkodGFyZ2V0ID0+IHRhcmdldCA9PT0gdHJhbnNpdGlvbi5zb3VyY2UgfHwgaXNEZXNjZW5kYW50KHRhcmdldCwgdHJhbnNpdGlvbi5zb3VyY2UpKSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uLnNvdXJjZTtcbiAgfVxuICBjb25zdCBsY2EgPSBmaW5kTGVhc3RDb21tb25BbmNlc3Rvcih0YXJnZXRTdGF0ZXMuY29uY2F0KHRyYW5zaXRpb24uc291cmNlKSk7XG4gIGlmIChsY2EpIHtcbiAgICByZXR1cm4gbGNhO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCB3ZSBrbm93IHRoYXQgaXQncyBhIHJvb3QgdHJhbnNpdGlvbiBzaW5jZSBMQ0EgY291bGRuJ3QgYmUgZm91bmRcbiAgaWYgKHRyYW5zaXRpb24ucmVlbnRlcikge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdHJhbnNpdGlvbi5zb3VyY2UubWFjaGluZS5yb290O1xufVxuZnVuY3Rpb24gY29tcHV0ZUV4aXRTZXQodHJhbnNpdGlvbnMsIHN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKSB7XG4gIGNvbnN0IHN0YXRlc1RvRXhpdCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0IG9mIHRyYW5zaXRpb25zKSB7XG4gICAgaWYgKHQudGFyZ2V0Py5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IGdldFRyYW5zaXRpb25Eb21haW4odCwgaGlzdG9yeVZhbHVlKTtcbiAgICAgIGlmICh0LnJlZW50ZXIgJiYgdC5zb3VyY2UgPT09IGRvbWFpbikge1xuICAgICAgICBzdGF0ZXNUb0V4aXQuYWRkKGRvbWFpbik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHN0YXRlTm9kZSBvZiBzdGF0ZU5vZGVTZXQpIHtcbiAgICAgICAgaWYgKGlzRGVzY2VuZGFudChzdGF0ZU5vZGUsIGRvbWFpbikpIHtcbiAgICAgICAgICBzdGF0ZXNUb0V4aXQuYWRkKHN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5zdGF0ZXNUb0V4aXRdO1xufVxuZnVuY3Rpb24gYXJlU3RhdGVOb2RlQ29sbGVjdGlvbnNFcXVhbChwcmV2U3RhdGVOb2RlcywgbmV4dFN0YXRlTm9kZVNldCkge1xuICBpZiAocHJldlN0YXRlTm9kZXMubGVuZ3RoICE9PSBuZXh0U3RhdGVOb2RlU2V0LnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBub2RlIG9mIHByZXZTdGF0ZU5vZGVzKSB7XG4gICAgaWYgKCFuZXh0U3RhdGVOb2RlU2V0Lmhhcyhub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zY3htbC8jbWljcm9zdGVwUHJvY2VkdXJlICovXG5mdW5jdGlvbiBtaWNyb3N0ZXAodHJhbnNpdGlvbnMsIGN1cnJlbnRTbmFwc2hvdCwgYWN0b3JTY29wZSwgZXZlbnQsIGlzSW5pdGlhbCwgaW50ZXJuYWxRdWV1ZSkge1xuICBpZiAoIXRyYW5zaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBjdXJyZW50U25hcHNob3Q7XG4gIH1cbiAgY29uc3QgbXV0U3RhdGVOb2RlU2V0ID0gbmV3IFNldChjdXJyZW50U25hcHNob3QuX25vZGVzKTtcbiAgbGV0IGhpc3RvcnlWYWx1ZSA9IGN1cnJlbnRTbmFwc2hvdC5oaXN0b3J5VmFsdWU7XG4gIGNvbnN0IGZpbHRlcmVkVHJhbnNpdGlvbnMgPSByZW1vdmVDb25mbGljdGluZ1RyYW5zaXRpb25zKHRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSk7XG4gIGxldCBuZXh0U3RhdGUgPSBjdXJyZW50U25hcHNob3Q7XG5cbiAgLy8gRXhpdCBzdGF0ZXNcbiAgaWYgKCFpc0luaXRpYWwpIHtcbiAgICBbbmV4dFN0YXRlLCBoaXN0b3J5VmFsdWVdID0gZXhpdFN0YXRlcyhuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSwgaW50ZXJuYWxRdWV1ZSwgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvcik7XG4gIH1cblxuICAvLyBFeGVjdXRlIHRyYW5zaXRpb24gY29udGVudFxuICBuZXh0U3RhdGUgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgZmlsdGVyZWRUcmFuc2l0aW9ucy5mbGF0TWFwKHQgPT4gdC5hY3Rpb25zKSwgaW50ZXJuYWxRdWV1ZSwgdW5kZWZpbmVkKTtcblxuICAvLyBFbnRlciBzdGF0ZXNcbiAgbmV4dFN0YXRlID0gZW50ZXJTdGF0ZXMobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgZmlsdGVyZWRUcmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBpbnRlcm5hbFF1ZXVlLCBoaXN0b3J5VmFsdWUsIGlzSW5pdGlhbCk7XG4gIGNvbnN0IG5leHRTdGF0ZU5vZGVzID0gWy4uLm11dFN0YXRlTm9kZVNldF07XG4gIGlmIChuZXh0U3RhdGUuc3RhdHVzID09PSAnZG9uZScpIHtcbiAgICBuZXh0U3RhdGUgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSwgbmV4dFN0YXRlTm9kZXMuc29ydCgoYSwgYikgPT4gYi5vcmRlciAtIGEub3JkZXIpLmZsYXRNYXAoc3RhdGUgPT4gc3RhdGUuZXhpdCksIGludGVybmFsUXVldWUsIHVuZGVmaW5lZCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYXRjaFxuICB0cnkge1xuICAgIGlmIChoaXN0b3J5VmFsdWUgPT09IGN1cnJlbnRTbmFwc2hvdC5oaXN0b3J5VmFsdWUgJiYgYXJlU3RhdGVOb2RlQ29sbGVjdGlvbnNFcXVhbChjdXJyZW50U25hcHNob3QuX25vZGVzLCBtdXRTdGF0ZU5vZGVTZXQpKSB7XG4gICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVNYWNoaW5lU25hcHNob3QobmV4dFN0YXRlLCB7XG4gICAgICBfbm9kZXM6IG5leHRTdGF0ZU5vZGVzLFxuICAgICAgaGlzdG9yeVZhbHVlXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGlzIG9uY2UgcHJvcGVyIGVycm9yIGhhbmRsaW5nIGlzIGltcGxlbWVudGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3RhdGVseWFpL3JmY3MvcHVsbC80XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TWFjaGluZU91dHB1dChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIHJvb3ROb2RlLCByb290Q29tcGxldGlvbk5vZGUpIHtcbiAgaWYgKHJvb3ROb2RlLm91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRvbmVTdGF0ZUV2ZW50ID0gY3JlYXRlRG9uZVN0YXRlRXZlbnQocm9vdENvbXBsZXRpb25Ob2RlLmlkLCByb290Q29tcGxldGlvbk5vZGUub3V0cHV0ICE9PSB1bmRlZmluZWQgJiYgcm9vdENvbXBsZXRpb25Ob2RlLnBhcmVudCA/IHJlc29sdmVPdXRwdXQocm9vdENvbXBsZXRpb25Ob2RlLm91dHB1dCwgc25hcHNob3QuY29udGV4dCwgZXZlbnQsIGFjdG9yU2NvcGUuc2VsZikgOiB1bmRlZmluZWQpO1xuICByZXR1cm4gcmVzb2x2ZU91dHB1dChyb290Tm9kZS5vdXRwdXQsIHNuYXBzaG90LmNvbnRleHQsIGRvbmVTdGF0ZUV2ZW50LCBhY3RvclNjb3BlLnNlbGYpO1xufVxuZnVuY3Rpb24gZW50ZXJTdGF0ZXMoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgZmlsdGVyZWRUcmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBpbnRlcm5hbFF1ZXVlLCBoaXN0b3J5VmFsdWUsIGlzSW5pdGlhbCkge1xuICBsZXQgbmV4dFNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBjb25zdCBzdGF0ZXNUb0VudGVyID0gbmV3IFNldCgpO1xuICAvLyB0aG9zZSBhcmUgc3RhdGVzIHRoYXQgd2VyZSBkaXJlY3RseSB0YXJnZXRlZCBvciBpbmRpcmVjdGx5IHRhcmdldGVkIGJ5IHRoZSBleHBsaWNpdCB0YXJnZXRcbiAgLy8gaW4gb3RoZXIgd29yZHMsIHRob3NlIGFyZSBzdGF0ZXMgZm9yIHdoaWNoIGluaXRpYWwgYWN0aW9ucyBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgLy8gd2hlbiB3ZSB0YXJnZXQgYCNkZWVwX2NoaWxkYCBpbml0aWFsIGFjdGlvbnMgb2YgaXRzIGFuY2VzdG9ycyBzaG91bGRuJ3QgYmUgZXhlY3V0ZWRcbiAgY29uc3Qgc3RhdGVzRm9yRGVmYXVsdEVudHJ5ID0gbmV3IFNldCgpO1xuICBjb21wdXRlRW50cnlTZXQoZmlsdGVyZWRUcmFuc2l0aW9ucywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuXG4gIC8vIEluIHRoZSBpbml0aWFsIHN0YXRlLCB0aGUgcm9vdCBzdGF0ZSBub2RlIGlzIFwiZW50ZXJlZFwiLlxuICBpZiAoaXNJbml0aWFsKSB7XG4gICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChjdXJyZW50U25hcHNob3QubWFjaGluZS5yb290KTtcbiAgfVxuICBjb25zdCBjb21wbGV0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBzdGF0ZU5vZGVUb0VudGVyIG9mIFsuLi5zdGF0ZXNUb0VudGVyXS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyIC0gYi5vcmRlcikpIHtcbiAgICBtdXRTdGF0ZU5vZGVTZXQuYWRkKHN0YXRlTm9kZVRvRW50ZXIpO1xuICAgIGNvbnN0IGFjdGlvbnMgPSBbXTtcblxuICAgIC8vIEFkZCBlbnRyeSBhY3Rpb25zXG4gICAgYWN0aW9ucy5wdXNoKC4uLnN0YXRlTm9kZVRvRW50ZXIuZW50cnkpO1xuICAgIGZvciAoY29uc3QgaW52b2tlRGVmIG9mIHN0YXRlTm9kZVRvRW50ZXIuaW52b2tlKSB7XG4gICAgICBhY3Rpb25zLnB1c2goc3Bhd25DaGlsZChpbnZva2VEZWYuc3JjLCB7XG4gICAgICAgIC4uLmludm9rZURlZixcbiAgICAgICAgc3luY1NuYXBzaG90OiAhIWludm9rZURlZi5vblNuYXBzaG90XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZXNGb3JEZWZhdWx0RW50cnkuaGFzKHN0YXRlTm9kZVRvRW50ZXIpKSB7XG4gICAgICBjb25zdCBpbml0aWFsQWN0aW9ucyA9IHN0YXRlTm9kZVRvRW50ZXIuaW5pdGlhbC5hY3Rpb25zO1xuICAgICAgYWN0aW9ucy5wdXNoKC4uLmluaXRpYWxBY3Rpb25zKTtcbiAgICB9XG4gICAgbmV4dFNuYXBzaG90ID0gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KG5leHRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGludGVybmFsUXVldWUsIHN0YXRlTm9kZVRvRW50ZXIuaW52b2tlLm1hcChpbnZva2VEZWYgPT4gaW52b2tlRGVmLmlkKSk7XG4gICAgaWYgKHN0YXRlTm9kZVRvRW50ZXIudHlwZSA9PT0gJ2ZpbmFsJykge1xuICAgICAgY29uc3QgcGFyZW50ID0gc3RhdGVOb2RlVG9FbnRlci5wYXJlbnQ7XG4gICAgICBsZXQgYW5jZXN0b3JNYXJrZXIgPSBwYXJlbnQ/LnR5cGUgPT09ICdwYXJhbGxlbCcgPyBwYXJlbnQgOiBwYXJlbnQ/LnBhcmVudDtcbiAgICAgIGxldCByb290Q29tcGxldGlvbk5vZGUgPSBhbmNlc3Rvck1hcmtlciB8fCBzdGF0ZU5vZGVUb0VudGVyO1xuICAgICAgaWYgKHBhcmVudD8udHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgICBpbnRlcm5hbFF1ZXVlLnB1c2goY3JlYXRlRG9uZVN0YXRlRXZlbnQocGFyZW50LmlkLCBzdGF0ZU5vZGVUb0VudGVyLm91dHB1dCAhPT0gdW5kZWZpbmVkID8gcmVzb2x2ZU91dHB1dChzdGF0ZU5vZGVUb0VudGVyLm91dHB1dCwgbmV4dFNuYXBzaG90LmNvbnRleHQsIGV2ZW50LCBhY3RvclNjb3BlLnNlbGYpIDogdW5kZWZpbmVkKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYW5jZXN0b3JNYXJrZXI/LnR5cGUgPT09ICdwYXJhbGxlbCcgJiYgIWNvbXBsZXRlZE5vZGVzLmhhcyhhbmNlc3Rvck1hcmtlcikgJiYgaXNJbkZpbmFsU3RhdGUobXV0U3RhdGVOb2RlU2V0LCBhbmNlc3Rvck1hcmtlcikpIHtcbiAgICAgICAgY29tcGxldGVkTm9kZXMuYWRkKGFuY2VzdG9yTWFya2VyKTtcbiAgICAgICAgaW50ZXJuYWxRdWV1ZS5wdXNoKGNyZWF0ZURvbmVTdGF0ZUV2ZW50KGFuY2VzdG9yTWFya2VyLmlkKSk7XG4gICAgICAgIHJvb3RDb21wbGV0aW9uTm9kZSA9IGFuY2VzdG9yTWFya2VyO1xuICAgICAgICBhbmNlc3Rvck1hcmtlciA9IGFuY2VzdG9yTWFya2VyLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmIChhbmNlc3Rvck1hcmtlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG5leHRTbmFwc2hvdCA9IGNsb25lTWFjaGluZVNuYXBzaG90KG5leHRTbmFwc2hvdCwge1xuICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgb3V0cHV0OiBnZXRNYWNoaW5lT3V0cHV0KG5leHRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIG5leHRTbmFwc2hvdC5tYWNoaW5lLnJvb3QsIHJvb3RDb21wbGV0aW9uTm9kZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dFNuYXBzaG90O1xufVxuZnVuY3Rpb24gY29tcHV0ZUVudHJ5U2V0KHRyYW5zaXRpb25zLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcikge1xuICBmb3IgKGNvbnN0IHQgb2YgdHJhbnNpdGlvbnMpIHtcbiAgICBjb25zdCBkb21haW4gPSBnZXRUcmFuc2l0aW9uRG9tYWluKHQsIGhpc3RvcnlWYWx1ZSk7XG4gICAgZm9yIChjb25zdCBzIG9mIHQudGFyZ2V0IHx8IFtdKSB7XG4gICAgICBpZiAoIWlzSGlzdG9yeU5vZGUocykgJiYgKFxuICAgICAgLy8gaWYgdGhlIHRhcmdldCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgc291cmNlIHRoZW4gaXQgd2lsbCAqZGVmaW5pdGVseSogYmUgZW50ZXJlZFxuICAgICAgdC5zb3VyY2UgIT09IHMgfHxcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgZG9tYWluIGNhbid0IGxpZSB3aXRoaW4gdGhlIHNvdXJjZVxuICAgICAgLy8gaWYgaXQncyBkaWZmZXJlbnQgdGhhbiB0aGUgc291cmNlIHRoZW4gaXQncyBvdXRzaWRlIG9mIGl0IGFuZCBpdCBtZWFucyB0aGF0IHRoZSB0YXJnZXQgaGFzIHRvIGJlIGVudGVyZWQgYXMgd2VsbFxuICAgICAgdC5zb3VyY2UgIT09IGRvbWFpbiB8fFxuICAgICAgLy8gcmVlbnRlcmluZyB0cmFuc2l0aW9ucyBhbHdheXMgZW50ZXIgdGhlIHRhcmdldCwgZXZlbiBpZiBpdCdzIHRoZSBzb3VyY2UgaXRzZWxmXG4gICAgICB0LnJlZW50ZXIpKSB7XG4gICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKHMpO1xuICAgICAgICBzdGF0ZXNGb3JEZWZhdWx0RW50cnkuYWRkKHMpO1xuICAgICAgfVxuICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIocywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTdGF0ZXMgPSBnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXModCwgaGlzdG9yeVZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdGFyZ2V0U3RhdGVzKSB7XG4gICAgICBjb25zdCBhbmNlc3RvcnMgPSBnZXRQcm9wZXJBbmNlc3RvcnMocywgZG9tYWluKTtcbiAgICAgIGlmIChkb21haW4/LnR5cGUgPT09ICdwYXJhbGxlbCcpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goZG9tYWluKTtcbiAgICAgIH1cbiAgICAgIGFkZEFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgYW5jZXN0b3JzLCAhdC5zb3VyY2UucGFyZW50ICYmIHQucmVlbnRlciA/IHVuZGVmaW5lZCA6IGRvbWFpbik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzdGF0ZU5vZGUsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKSB7XG4gIGlmIChpc0hpc3RvcnlOb2RlKHN0YXRlTm9kZSkpIHtcbiAgICBpZiAoaGlzdG9yeVZhbHVlW3N0YXRlTm9kZS5pZF0pIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlTdGF0ZU5vZGVzID0gaGlzdG9yeVZhbHVlW3N0YXRlTm9kZS5pZF07XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaGlzdG9yeVN0YXRlTm9kZXMpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQocyk7XG4gICAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKHMsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5U3RhdGVOb2Rlcykge1xuICAgICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIocywgc3RhdGVOb2RlLnBhcmVudCwgc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24gPSByZXNvbHZlSGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uKHN0YXRlTm9kZSk7XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uLnRhcmdldCkge1xuICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChzKTtcbiAgICAgICAgaWYgKGhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbiA9PT0gc3RhdGVOb2RlLnBhcmVudD8uaW5pdGlhbCkge1xuICAgICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQoc3RhdGVOb2RlLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIocywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzIG9mIGhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbi50YXJnZXQpIHtcbiAgICAgICAgYWRkUHJvcGVyQW5jZXN0b3JTdGF0ZXNUb0VudGVyKHMsIHN0YXRlTm9kZS5wYXJlbnQsIHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICBjb25zdCBbaW5pdGlhbFN0YXRlXSA9IHN0YXRlTm9kZS5pbml0aWFsLnRhcmdldDtcbiAgICAgIGlmICghaXNIaXN0b3J5Tm9kZShpbml0aWFsU3RhdGUpKSB7XG4gICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKGluaXRpYWxTdGF0ZSwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgYWRkUHJvcGVyQW5jZXN0b3JTdGF0ZXNUb0VudGVyKGluaXRpYWxTdGF0ZSwgc3RhdGVOb2RlLCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKHN0YXRlTm9kZSkuZmlsdGVyKHNuID0+ICFpc0hpc3RvcnlOb2RlKHNuKSkpIHtcbiAgICAgICAgICBpZiAoIVsuLi5zdGF0ZXNUb0VudGVyXS5zb21lKHMgPT4gaXNEZXNjZW5kYW50KHMsIGNoaWxkKSkpIHtcbiAgICAgICAgICAgIGlmICghaXNIaXN0b3J5Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgICBzdGF0ZXNGb3JEZWZhdWx0RW50cnkuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKGNoaWxkLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRBbmNlc3RvclN0YXRlc1RvRW50ZXIoc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIGFuY2VzdG9ycywgcmVlbnRyYW5jeURvbWFpbikge1xuICBmb3IgKGNvbnN0IGFuYyBvZiBhbmNlc3RvcnMpIHtcbiAgICBpZiAoIXJlZW50cmFuY3lEb21haW4gfHwgaXNEZXNjZW5kYW50KGFuYywgcmVlbnRyYW5jeURvbWFpbikpIHtcbiAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKGFuYyk7XG4gICAgfVxuICAgIGlmIChhbmMudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBnZXRDaGlsZHJlbihhbmMpLmZpbHRlcihzbiA9PiAhaXNIaXN0b3J5Tm9kZShzbikpKSB7XG4gICAgICAgIGlmICghWy4uLnN0YXRlc1RvRW50ZXJdLnNvbWUocyA9PiBpc0Rlc2NlbmRhbnQocywgY2hpbGQpKSkge1xuICAgICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKGNoaWxkKTtcbiAgICAgICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihjaGlsZCwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIoc3RhdGVOb2RlLCB0b1N0YXRlTm9kZSwgc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkpIHtcbiAgYWRkQW5jZXN0b3JTdGF0ZXNUb0VudGVyKHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBnZXRQcm9wZXJBbmNlc3RvcnMoc3RhdGVOb2RlLCB0b1N0YXRlTm9kZSkpO1xufVxuZnVuY3Rpb24gZXhpdFN0YXRlcyhjdXJyZW50U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCB0cmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUsIGludGVybmFsUXVldWUsIF9hY3Rpb25FeGVjdXRvcikge1xuICBsZXQgbmV4dFNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBjb25zdCBzdGF0ZXNUb0V4aXQgPSBjb21wdXRlRXhpdFNldCh0cmFuc2l0aW9ucywgbXV0U3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpO1xuICBzdGF0ZXNUb0V4aXQuc29ydCgoYSwgYikgPT4gYi5vcmRlciAtIGEub3JkZXIpO1xuICBsZXQgY2hhbmdlZEhpc3Rvcnk7XG5cbiAgLy8gRnJvbSBTQ1hNTCBhbGdvcml0aG06IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zY3htbC8jZXhpdFN0YXRlc1xuICBmb3IgKGNvbnN0IGV4aXRTdGF0ZU5vZGUgb2Ygc3RhdGVzVG9FeGl0KSB7XG4gICAgZm9yIChjb25zdCBoaXN0b3J5Tm9kZSBvZiBnZXRIaXN0b3J5Tm9kZXMoZXhpdFN0YXRlTm9kZSkpIHtcbiAgICAgIGxldCBwcmVkaWNhdGU7XG4gICAgICBpZiAoaGlzdG9yeU5vZGUuaGlzdG9yeSA9PT0gJ2RlZXAnKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHNuID0+IGlzQXRvbWljU3RhdGVOb2RlKHNuKSAmJiBpc0Rlc2NlbmRhbnQoc24sIGV4aXRTdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZGljYXRlID0gc24gPT4ge1xuICAgICAgICAgIHJldHVybiBzbi5wYXJlbnQgPT09IGV4aXRTdGF0ZU5vZGU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjaGFuZ2VkSGlzdG9yeSA/Pz0ge1xuICAgICAgICAuLi5oaXN0b3J5VmFsdWVcbiAgICAgIH07XG4gICAgICBjaGFuZ2VkSGlzdG9yeVtoaXN0b3J5Tm9kZS5pZF0gPSBBcnJheS5mcm9tKG11dFN0YXRlTm9kZVNldCkuZmlsdGVyKHByZWRpY2F0ZSk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcyBvZiBzdGF0ZXNUb0V4aXQpIHtcbiAgICBuZXh0U25hcHNob3QgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgWy4uLnMuZXhpdCwgLi4ucy5pbnZva2UubWFwKGRlZiA9PiBzdG9wQ2hpbGQoZGVmLmlkKSldLCBpbnRlcm5hbFF1ZXVlLCB1bmRlZmluZWQpO1xuICAgIG11dFN0YXRlTm9kZVNldC5kZWxldGUocyk7XG4gIH1cbiAgcmV0dXJuIFtuZXh0U25hcHNob3QsIGNoYW5nZWRIaXN0b3J5IHx8IGhpc3RvcnlWYWx1ZV07XG59XG5mdW5jdGlvbiBnZXRBY3Rpb24obWFjaGluZSwgYWN0aW9uVHlwZSkge1xuICByZXR1cm4gbWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuYWN0aW9uc1thY3Rpb25UeXBlXTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBbmRFeGVjdXRlQWN0aW9uc1dpdGhDb250ZXh0KGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGV4dHJhLCByZXRyaWVzKSB7XG4gIGNvbnN0IHtcbiAgICBtYWNoaW5lXG4gIH0gPSBjdXJyZW50U25hcHNob3Q7XG4gIGxldCBpbnRlcm1lZGlhdGVTbmFwc2hvdCA9IGN1cnJlbnRTbmFwc2hvdDtcbiAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykge1xuICAgIGNvbnN0IGlzSW5saW5lID0gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICBjb25zdCByZXNvbHZlZEFjdGlvbiA9IGlzSW5saW5lID8gYWN0aW9uIDpcbiAgICAvLyB0aGUgZXhpc3RpbmcgdHlwZSBvZiBgLmFjdGlvbnNgIGFzc3VtZXMgbm9uLW51bGxhYmxlIGBURXhwcmVzc2lvbkFjdGlvbmBcbiAgICAvLyBpdCdzIGZpbmUgdG8gY2FzdCB0aGlzIGhlcmUgdG8gZ2V0IGEgY29tbW9uIHR5cGUgYW5kIGxhY2sgb2YgZXJyb3JzIGluIHRoZSByZXN0IG9mIHRoZSBjb2RlXG4gICAgLy8gb3VyIGxvZ2ljIGJlbG93IG1ha2VzIHN1cmUgdGhhdCB3ZSBjYWxsIHRob3NlIDIgXCJ2YXJpYW50c1wiIGNvcnJlY3RseVxuXG4gICAgZ2V0QWN0aW9uKG1hY2hpbmUsIHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gYWN0aW9uIDogYWN0aW9uLnR5cGUpO1xuICAgIGNvbnN0IGFjdGlvbkFyZ3MgPSB7XG4gICAgICBjb250ZXh0OiBpbnRlcm1lZGlhdGVTbmFwc2hvdC5jb250ZXh0LFxuICAgICAgZXZlbnQsXG4gICAgICBzZWxmOiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gICAgfTtcbiAgICBjb25zdCBhY3Rpb25QYXJhbXMgPSBpc0lubGluZSB8fCB0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJyA/IHVuZGVmaW5lZCA6ICdwYXJhbXMnIGluIGFjdGlvbiA/IHR5cGVvZiBhY3Rpb24ucGFyYW1zID09PSAnZnVuY3Rpb24nID8gYWN0aW9uLnBhcmFtcyh7XG4gICAgICBjb250ZXh0OiBpbnRlcm1lZGlhdGVTbmFwc2hvdC5jb250ZXh0LFxuICAgICAgZXZlbnRcbiAgICB9KSA6IGFjdGlvbi5wYXJhbXMgOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFyZXNvbHZlZEFjdGlvbiB8fCAhKCdyZXNvbHZlJyBpbiByZXNvbHZlZEFjdGlvbikpIHtcbiAgICAgIGFjdG9yU2NvcGUuYWN0aW9uRXhlY3V0b3Ioe1xuICAgICAgICB0eXBlOiB0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJyA/IGFjdGlvbiA6IHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnID8gYWN0aW9uLnR5cGUgOiBhY3Rpb24ubmFtZSB8fCAnKGFub255bW91cyknLFxuICAgICAgICBpbmZvOiBhY3Rpb25BcmdzLFxuICAgICAgICBwYXJhbXM6IGFjdGlvblBhcmFtcyxcbiAgICAgICAgZXhlYzogcmVzb2x2ZWRBY3Rpb25cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGJ1aWx0aW5BY3Rpb24gPSByZXNvbHZlZEFjdGlvbjtcbiAgICBjb25zdCBbbmV4dFN0YXRlLCBwYXJhbXMsIGFjdGlvbnNdID0gYnVpbHRpbkFjdGlvbi5yZXNvbHZlKGFjdG9yU2NvcGUsIGludGVybWVkaWF0ZVNuYXBzaG90LCBhY3Rpb25BcmdzLCBhY3Rpb25QYXJhbXMsIHJlc29sdmVkQWN0aW9uLFxuICAgIC8vIHRoaXMgaG9sZHMgYWxsIHBhcmFtc1xuICAgIGV4dHJhKTtcbiAgICBpbnRlcm1lZGlhdGVTbmFwc2hvdCA9IG5leHRTdGF0ZTtcbiAgICBpZiAoJ3JldHJ5UmVzb2x2ZScgaW4gYnVpbHRpbkFjdGlvbikge1xuICAgICAgcmV0cmllcz8ucHVzaChbYnVpbHRpbkFjdGlvbiwgcGFyYW1zXSk7XG4gICAgfVxuICAgIGlmICgnZXhlY3V0ZScgaW4gYnVpbHRpbkFjdGlvbikge1xuICAgICAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvcih7XG4gICAgICAgIHR5cGU6IGJ1aWx0aW5BY3Rpb24udHlwZSxcbiAgICAgICAgaW5mbzogYWN0aW9uQXJncyxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBleGVjOiBidWlsdGluQWN0aW9uLmV4ZWN1dGUuYmluZChudWxsLCBhY3RvclNjb3BlLCBwYXJhbXMpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbnMpIHtcbiAgICAgIGludGVybWVkaWF0ZVNuYXBzaG90ID0gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoaW50ZXJtZWRpYXRlU25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBhY3Rpb25zLCBleHRyYSwgcmV0cmllcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnRlcm1lZGlhdGVTbmFwc2hvdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChjdXJyZW50U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBhY3Rpb25zLCBpbnRlcm5hbFF1ZXVlLCBkZWZlcnJlZEFjdG9ySWRzKSB7XG4gIGNvbnN0IHJldHJpZXMgPSBkZWZlcnJlZEFjdG9ySWRzID8gW10gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG5leHRTdGF0ZSA9IHJlc29sdmVBbmRFeGVjdXRlQWN0aW9uc1dpdGhDb250ZXh0KGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIHtcbiAgICBpbnRlcm5hbFF1ZXVlLFxuICAgIGRlZmVycmVkQWN0b3JJZHNcbiAgfSwgcmV0cmllcyk7XG4gIHJldHJpZXM/LmZvckVhY2goKFtidWlsdGluQWN0aW9uLCBwYXJhbXNdKSA9PiB7XG4gICAgYnVpbHRpbkFjdGlvbi5yZXRyeVJlc29sdmUoYWN0b3JTY29wZSwgbmV4dFN0YXRlLCBwYXJhbXMpO1xuICB9KTtcbiAgcmV0dXJuIG5leHRTdGF0ZTtcbn1cbmZ1bmN0aW9uIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGludGVybmFsUXVldWUpIHtcbiAgaWYgKGV2ZW50LnR5cGUgPT09IFdJTERDQVJEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBbiBldmVudCBjYW5ub3QgaGF2ZSB0aGUgd2lsZGNhcmQgdHlwZSAoJyR7V0lMRENBUkR9JylgKTtcbiAgfVxuICBsZXQgbmV4dFNuYXBzaG90ID0gc25hcHNob3Q7XG4gIGNvbnN0IG1pY3Jvc3RhdGVzID0gW107XG4gIGZ1bmN0aW9uIGFkZE1pY3Jvc3RhdGUobWljcm9zdGF0ZSwgZXZlbnQsIHRyYW5zaXRpb25zKSB7XG4gICAgYWN0b3JTY29wZS5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgdHlwZTogJ0B4c3RhdGUubWljcm9zdGVwJyxcbiAgICAgIGFjdG9yUmVmOiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICBldmVudCxcbiAgICAgIHNuYXBzaG90OiBtaWNyb3N0YXRlLFxuICAgICAgX3RyYW5zaXRpb25zOiB0cmFuc2l0aW9uc1xuICAgIH0pO1xuICAgIG1pY3Jvc3RhdGVzLnB1c2gobWljcm9zdGF0ZSk7XG4gIH1cblxuICAvLyBIYW5kbGUgc3RvcCBldmVudFxuICBpZiAoZXZlbnQudHlwZSA9PT0gWFNUQVRFX1NUT1ApIHtcbiAgICBuZXh0U25hcHNob3QgPSBjbG9uZU1hY2hpbmVTbmFwc2hvdChzdG9wQ2hpbGRyZW4obmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSksIHtcbiAgICAgIHN0YXR1czogJ3N0b3BwZWQnXG4gICAgfSk7XG4gICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIGV2ZW50LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNuYXBzaG90OiBuZXh0U25hcHNob3QsXG4gICAgICBtaWNyb3N0YXRlc1xuICAgIH07XG4gIH1cbiAgbGV0IG5leHRFdmVudCA9IGV2ZW50O1xuXG4gIC8vIEFzc3VtZSB0aGUgc3RhdGUgaXMgYXQgcmVzdCAobm8gcmFpc2VkIGV2ZW50cylcbiAgLy8gRGV0ZXJtaW5lIHRoZSBuZXh0IHN0YXRlIGJhc2VkIG9uIHRoZSBuZXh0IG1pY3Jvc3RlcFxuICBpZiAobmV4dEV2ZW50LnR5cGUgIT09IFhTVEFURV9JTklUKSB7XG4gICAgY29uc3QgY3VycmVudEV2ZW50ID0gbmV4dEV2ZW50O1xuICAgIGNvbnN0IGlzRXJyID0gaXNFcnJvckFjdG9yRXZlbnQoY3VycmVudEV2ZW50KTtcbiAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHNlbGVjdFRyYW5zaXRpb25zKGN1cnJlbnRFdmVudCwgbmV4dFNuYXBzaG90KTtcbiAgICBpZiAoaXNFcnIgJiYgIXRyYW5zaXRpb25zLmxlbmd0aCkge1xuICAgICAgLy8gVE9ETzogd2Ugc2hvdWxkIGxpa2VseSBvbmx5IGFsbG93IHRyYW5zaXRpb25zIHNlbGVjdGVkIGJ5IHZlcnkgZXhwbGljaXQgZGVzY3JpcHRvcnNcbiAgICAgIC8vIGAqYCBzaG91bGRuJ3QgYmUgbWF0Y2hlZCwgbGlrZWx5IGB4c3RhdGUuZXJyb3IuKmAgc2hvdWxkbnQgYmUgZWl0aGVyXG4gICAgICAvLyBzaW1pbGFybHkgYHhzdGF0ZS5lcnJvci5hY3Rvci4qYCBhbmQgYHhzdGF0ZS5lcnJvci5hY3Rvci50b2RvLipgIGhhdmUgdG8gYmUgY29uc2lkZXJlZCB0b29cbiAgICAgIG5leHRTbmFwc2hvdCA9IGNsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3I6IGN1cnJlbnRFdmVudC5lcnJvclxuICAgICAgfSk7XG4gICAgICBhZGRNaWNyb3N0YXRlKG5leHRTbmFwc2hvdCwgY3VycmVudEV2ZW50LCBbXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzbmFwc2hvdDogbmV4dFNuYXBzaG90LFxuICAgICAgICBtaWNyb3N0YXRlc1xuICAgICAgfTtcbiAgICB9XG4gICAgbmV4dFNuYXBzaG90ID0gbWljcm9zdGVwKHRyYW5zaXRpb25zLCBzbmFwc2hvdCwgYWN0b3JTY29wZSwgbmV4dEV2ZW50LCBmYWxzZSxcbiAgICAvLyBpc0luaXRpYWxcbiAgICBpbnRlcm5hbFF1ZXVlKTtcbiAgICBhZGRNaWNyb3N0YXRlKG5leHRTbmFwc2hvdCwgY3VycmVudEV2ZW50LCB0cmFuc2l0aW9ucyk7XG4gIH1cbiAgbGV0IHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zID0gdHJ1ZTtcbiAgd2hpbGUgKG5leHRTbmFwc2hvdC5zdGF0dXMgPT09ICdhY3RpdmUnKSB7XG4gICAgbGV0IGVuYWJsZWRUcmFuc2l0aW9ucyA9IHNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zID8gc2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMobmV4dFNuYXBzaG90LCBuZXh0RXZlbnQpIDogW107XG5cbiAgICAvLyBldmVudGxlc3MgdHJhbnNpdGlvbnMgc2hvdWxkIGFsd2F5cyBiZSBzZWxlY3RlZCBhZnRlciBzZWxlY3RpbmcgKnJlZ3VsYXIqIHRyYW5zaXRpb25zXG4gICAgLy8gYnkgYXNzaWduaW5nIGB1bmRlZmluZWRgIHRvIGBwcmV2aW91c1N0YXRlYCB3ZSBlbnN1cmUgdGhhdCBgc2hvdWxkU2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnNgIGdldHMgYWx3YXlzIGNvbXB1dGVkIHRvIHRydWUgaW4gc3VjaCBhIGNhc2VcbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gZW5hYmxlZFRyYW5zaXRpb25zLmxlbmd0aCA/IG5leHRTbmFwc2hvdCA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIWVuYWJsZWRUcmFuc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGlmICghaW50ZXJuYWxRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBuZXh0RXZlbnQgPSBpbnRlcm5hbFF1ZXVlLnNoaWZ0KCk7XG4gICAgICBlbmFibGVkVHJhbnNpdGlvbnMgPSBzZWxlY3RUcmFuc2l0aW9ucyhuZXh0RXZlbnQsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICAgIG5leHRTbmFwc2hvdCA9IG1pY3Jvc3RlcChlbmFibGVkVHJhbnNpdGlvbnMsIG5leHRTbmFwc2hvdCwgYWN0b3JTY29wZSwgbmV4dEV2ZW50LCBmYWxzZSwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgc2hvdWxkU2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMgPSBuZXh0U25hcHNob3QgIT09IHByZXZpb3VzU3RhdGU7XG4gICAgYWRkTWljcm9zdGF0ZShuZXh0U25hcHNob3QsIG5leHRFdmVudCwgZW5hYmxlZFRyYW5zaXRpb25zKTtcbiAgfVxuICBpZiAobmV4dFNuYXBzaG90LnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICBzdG9wQ2hpbGRyZW4obmV4dFNuYXBzaG90LCBuZXh0RXZlbnQsIGFjdG9yU2NvcGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc25hcHNob3Q6IG5leHRTbmFwc2hvdCxcbiAgICBtaWNyb3N0YXRlc1xuICB9O1xufVxuZnVuY3Rpb24gc3RvcENoaWxkcmVuKG5leHRTdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUpIHtcbiAgcmV0dXJuIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBPYmplY3QudmFsdWVzKG5leHRTdGF0ZS5jaGlsZHJlbikubWFwKGNoaWxkID0+IHN0b3BDaGlsZChjaGlsZCkpLCBbXSwgdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRyYW5zaXRpb25zKGV2ZW50LCBuZXh0U3RhdGUpIHtcbiAgcmV0dXJuIG5leHRTdGF0ZS5tYWNoaW5lLmdldFRyYW5zaXRpb25EYXRhKG5leHRTdGF0ZSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gc2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMobmV4dFN0YXRlLCBldmVudCkge1xuICBjb25zdCBlbmFibGVkVHJhbnNpdGlvblNldCA9IG5ldyBTZXQoKTtcbiAgY29uc3QgYXRvbWljU3RhdGVzID0gbmV4dFN0YXRlLl9ub2Rlcy5maWx0ZXIoaXNBdG9taWNTdGF0ZU5vZGUpO1xuICBmb3IgKGNvbnN0IHN0YXRlTm9kZSBvZiBhdG9taWNTdGF0ZXMpIHtcbiAgICBsb29wOiBmb3IgKGNvbnN0IHMgb2YgW3N0YXRlTm9kZV0uY29uY2F0KGdldFByb3BlckFuY2VzdG9ycyhzdGF0ZU5vZGUsIHVuZGVmaW5lZCkpKSB7XG4gICAgICBpZiAoIXMuYWx3YXlzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIHMuYWx3YXlzKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uLmd1YXJkID09PSB1bmRlZmluZWQgfHwgZXZhbHVhdGVHdWFyZCh0cmFuc2l0aW9uLmd1YXJkLCBuZXh0U3RhdGUuY29udGV4dCwgZXZlbnQsIG5leHRTdGF0ZSkpIHtcbiAgICAgICAgICBlbmFibGVkVHJhbnNpdGlvblNldC5hZGQodHJhbnNpdGlvbik7XG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVtb3ZlQ29uZmxpY3RpbmdUcmFuc2l0aW9ucyhBcnJheS5mcm9tKGVuYWJsZWRUcmFuc2l0aW9uU2V0KSwgbmV3IFNldChuZXh0U3RhdGUuX25vZGVzKSwgbmV4dFN0YXRlLmhpc3RvcnlWYWx1ZSk7XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYSBwYXJ0aWFsIHN0YXRlIHZhbHVlIHdpdGggaXRzIGZ1bGwgcmVwcmVzZW50YXRpb24gaW4gdGhlIHN0YXRlXG4gKiBub2RlJ3MgbWFjaGluZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGVWYWx1ZSBUaGUgcGFydGlhbCBzdGF0ZSB2YWx1ZSB0byByZXNvbHZlLlxuICovXG5mdW5jdGlvbiByZXNvbHZlU3RhdGVWYWx1ZShyb290Tm9kZSwgc3RhdGVWYWx1ZSkge1xuICBjb25zdCBhbGxTdGF0ZU5vZGVzID0gZ2V0QWxsU3RhdGVOb2RlcyhnZXRTdGF0ZU5vZGVzKHJvb3ROb2RlLCBzdGF0ZVZhbHVlKSk7XG4gIHJldHVybiBnZXRTdGF0ZVZhbHVlKHJvb3ROb2RlLCBbLi4uYWxsU3RhdGVOb2Rlc10pO1xufVxuXG5mdW5jdGlvbiBpc01hY2hpbmVTbmFwc2hvdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICdtYWNoaW5lJyBpbiB2YWx1ZSAmJiAndmFsdWUnIGluIHZhbHVlO1xufVxuY29uc3QgbWFjaGluZVNuYXBzaG90TWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXModGVzdFZhbHVlKSB7XG4gIHJldHVybiBtYXRjaGVzU3RhdGUodGVzdFZhbHVlLCB0aGlzLnZhbHVlKTtcbn07XG5jb25zdCBtYWNoaW5lU25hcHNob3RIYXNUYWcgPSBmdW5jdGlvbiBoYXNUYWcodGFnKSB7XG4gIHJldHVybiB0aGlzLnRhZ3MuaGFzKHRhZyk7XG59O1xuY29uc3QgbWFjaGluZVNuYXBzaG90Q2FuID0gZnVuY3Rpb24gY2FuKGV2ZW50KSB7XG4gIGlmICghdGhpcy5tYWNoaW5lKSB7XG4gICAgY29uc29sZS53YXJuKGBzdGF0ZS5jYW4oLi4uKSB1c2VkIG91dHNpZGUgb2YgYSBtYWNoaW5lLWNyZWF0ZWQgU3RhdGUgb2JqZWN0OyB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZS5gKTtcbiAgfVxuICBjb25zdCB0cmFuc2l0aW9uRGF0YSA9IHRoaXMubWFjaGluZS5nZXRUcmFuc2l0aW9uRGF0YSh0aGlzLCBldmVudCk7XG4gIHJldHVybiAhIXRyYW5zaXRpb25EYXRhPy5sZW5ndGggJiZcbiAgLy8gQ2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdHJhbnNpdGlvbiBpcyBub3QgZm9yYmlkZGVuXG4gIHRyYW5zaXRpb25EYXRhLnNvbWUodCA9PiB0LnRhcmdldCAhPT0gdW5kZWZpbmVkIHx8IHQuYWN0aW9ucy5sZW5ndGgpO1xufTtcbmNvbnN0IG1hY2hpbmVTbmFwc2hvdFRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgY29uc3Qge1xuICAgIF9ub2Rlczogbm9kZXMsXG4gICAgdGFncyxcbiAgICBtYWNoaW5lLFxuICAgIGdldE1ldGEsXG4gICAgdG9KU09OLFxuICAgIGNhbixcbiAgICBoYXNUYWcsXG4gICAgbWF0Y2hlcyxcbiAgICAuLi5qc29uVmFsdWVzXG4gIH0gPSB0aGlzO1xuICByZXR1cm4ge1xuICAgIC4uLmpzb25WYWx1ZXMsXG4gICAgdGFnczogQXJyYXkuZnJvbSh0YWdzKVxuICB9O1xufTtcbmNvbnN0IG1hY2hpbmVTbmFwc2hvdEdldE1ldGEgPSBmdW5jdGlvbiBnZXRNZXRhKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZXMucmVkdWNlKChhY2MsIHN0YXRlTm9kZSkgPT4ge1xuICAgIGlmIChzdGF0ZU5vZGUubWV0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhY2Nbc3RhdGVOb2RlLmlkXSA9IHN0YXRlTm9kZS5tZXRhO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlTWFjaGluZVNuYXBzaG90KGNvbmZpZywgbWFjaGluZSkge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogY29uZmlnLnN0YXR1cyxcbiAgICBvdXRwdXQ6IGNvbmZpZy5vdXRwdXQsXG4gICAgZXJyb3I6IGNvbmZpZy5lcnJvcixcbiAgICBtYWNoaW5lLFxuICAgIGNvbnRleHQ6IGNvbmZpZy5jb250ZXh0LFxuICAgIF9ub2RlczogY29uZmlnLl9ub2RlcyxcbiAgICB2YWx1ZTogZ2V0U3RhdGVWYWx1ZShtYWNoaW5lLnJvb3QsIGNvbmZpZy5fbm9kZXMpLFxuICAgIHRhZ3M6IG5ldyBTZXQoY29uZmlnLl9ub2Rlcy5mbGF0TWFwKHNuID0+IHNuLnRhZ3MpKSxcbiAgICBjaGlsZHJlbjogY29uZmlnLmNoaWxkcmVuLFxuICAgIGhpc3RvcnlWYWx1ZTogY29uZmlnLmhpc3RvcnlWYWx1ZSB8fCB7fSxcbiAgICBtYXRjaGVzOiBtYWNoaW5lU25hcHNob3RNYXRjaGVzLFxuICAgIGhhc1RhZzogbWFjaGluZVNuYXBzaG90SGFzVGFnLFxuICAgIGNhbjogbWFjaGluZVNuYXBzaG90Q2FuLFxuICAgIGdldE1ldGE6IG1hY2hpbmVTbmFwc2hvdEdldE1ldGEsXG4gICAgdG9KU09OOiBtYWNoaW5lU25hcHNob3RUb0pTT05cbiAgfTtcbn1cbmZ1bmN0aW9uIGNsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCBjb25maWcgPSB7fSkge1xuICByZXR1cm4gY3JlYXRlTWFjaGluZVNuYXBzaG90KHtcbiAgICAuLi5zbmFwc2hvdCxcbiAgICAuLi5jb25maWdcbiAgfSwgc25hcHNob3QubWFjaGluZSk7XG59XG5mdW5jdGlvbiBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgX25vZGVzOiBub2RlcyxcbiAgICB0YWdzLFxuICAgIG1hY2hpbmUsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dCxcbiAgICBjYW4sXG4gICAgaGFzVGFnLFxuICAgIG1hdGNoZXMsXG4gICAgZ2V0TWV0YSxcbiAgICB0b0pTT04sXG4gICAgLi4uanNvblZhbHVlc1xuICB9ID0gc25hcHNob3Q7XG4gIGNvbnN0IGNoaWxkcmVuSnNvbiA9IHt9O1xuICBmb3IgKGNvbnN0IGlkIGluIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpZF07XG4gICAgaWYgKHR5cGVvZiBjaGlsZC5zcmMgIT09ICdzdHJpbmcnICYmICghb3B0aW9ucyB8fCAhKCdfX3Vuc2FmZUFsbG93SW5saW5lQWN0b3JzJyBpbiBvcHRpb25zKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaW5saW5lIGNoaWxkIGFjdG9yIGNhbm5vdCBiZSBwZXJzaXN0ZWQuJyk7XG4gICAgfVxuICAgIGNoaWxkcmVuSnNvbltpZF0gPSB7XG4gICAgICBzbmFwc2hvdDogY2hpbGQuZ2V0UGVyc2lzdGVkU25hcHNob3Qob3B0aW9ucyksXG4gICAgICBzcmM6IGNoaWxkLnNyYyxcbiAgICAgIHN5c3RlbUlkOiBjaGlsZC5fc3lzdGVtSWQsXG4gICAgICBzeW5jU25hcHNob3Q6IGNoaWxkLl9zeW5jU25hcHNob3RcbiAgICB9O1xuICB9XG4gIGNvbnN0IHBlcnNpc3RlZCA9IHtcbiAgICAuLi5qc29uVmFsdWVzLFxuICAgIGNvbnRleHQ6IHBlcnNpc3RDb250ZXh0KGNvbnRleHQpLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbkpzb25cbiAgfTtcbiAgcmV0dXJuIHBlcnNpc3RlZDtcbn1cbmZ1bmN0aW9uIHBlcnNpc3RDb250ZXh0KGNvbnRleHRQYXJ0KSB7XG4gIGxldCBjb3B5O1xuICBmb3IgKGNvbnN0IGtleSBpbiBjb250ZXh0UGFydCkge1xuICAgIGNvbnN0IHZhbHVlID0gY29udGV4dFBhcnRba2V5XTtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKCdzZXNzaW9uSWQnIGluIHZhbHVlICYmICdzZW5kJyBpbiB2YWx1ZSAmJiAncmVmJyBpbiB2YWx1ZSkge1xuICAgICAgICBjb3B5ID8/PSBBcnJheS5pc0FycmF5KGNvbnRleHRQYXJ0KSA/IGNvbnRleHRQYXJ0LnNsaWNlKCkgOiB7XG4gICAgICAgICAgLi4uY29udGV4dFBhcnRcbiAgICAgICAgfTtcbiAgICAgICAgY29weVtrZXldID0ge1xuICAgICAgICAgIHhzdGF0ZSQkdHlwZTogJCRBQ1RPUl9UWVBFLFxuICAgICAgICAgIGlkOiB2YWx1ZS5pZFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGVyc2lzdENvbnRleHQodmFsdWUpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGNvcHkgPz89IEFycmF5LmlzQXJyYXkoY29udGV4dFBhcnQpID8gY29udGV4dFBhcnQuc2xpY2UoKSA6IHtcbiAgICAgICAgICAgIC4uLmNvbnRleHRQYXJ0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb3B5W2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvcHkgPz8gY29udGV4dFBhcnQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSYWlzZShfLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGV2ZW50OiBldmVudE9yRXhwcixcbiAgaWQsXG4gIGRlbGF5XG59LCB7XG4gIGludGVybmFsUXVldWVcbn0pIHtcbiAgY29uc3QgZGVsYXlzTWFwID0gc25hcHNob3QubWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuZGVsYXlzO1xuICBpZiAodHlwZW9mIGV2ZW50T3JFeHByID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgYE9ubHkgZXZlbnQgb2JqZWN0cyBtYXkgYmUgdXNlZCB3aXRoIHJhaXNlOyB1c2UgcmFpc2UoeyB0eXBlOiBcIiR7ZXZlbnRPckV4cHJ9XCIgfSkgaW5zdGVhZGApO1xuICB9XG4gIGNvbnN0IHJlc29sdmVkRXZlbnQgPSB0eXBlb2YgZXZlbnRPckV4cHIgPT09ICdmdW5jdGlvbicgPyBldmVudE9yRXhwcihhcmdzLCBhY3Rpb25QYXJhbXMpIDogZXZlbnRPckV4cHI7XG4gIGxldCByZXNvbHZlZERlbGF5O1xuICBpZiAodHlwZW9mIGRlbGF5ID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNvbmZpZ0RlbGF5ID0gZGVsYXlzTWFwICYmIGRlbGF5c01hcFtkZWxheV07XG4gICAgcmVzb2x2ZWREZWxheSA9IHR5cGVvZiBjb25maWdEZWxheSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbmZpZ0RlbGF5KGFyZ3MsIGFjdGlvblBhcmFtcykgOiBjb25maWdEZWxheTtcbiAgfSBlbHNlIHtcbiAgICByZXNvbHZlZERlbGF5ID0gdHlwZW9mIGRlbGF5ID09PSAnZnVuY3Rpb24nID8gZGVsYXkoYXJncywgYWN0aW9uUGFyYW1zKSA6IGRlbGF5O1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb2x2ZWREZWxheSAhPT0gJ251bWJlcicpIHtcbiAgICBpbnRlcm5hbFF1ZXVlLnB1c2gocmVzb2x2ZWRFdmVudCk7XG4gIH1cbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIGV2ZW50OiByZXNvbHZlZEV2ZW50LFxuICAgIGlkLFxuICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlUmFpc2UoYWN0b3JTY29wZSwgcGFyYW1zKSB7XG4gIGNvbnN0IHtcbiAgICBldmVudCxcbiAgICBkZWxheSxcbiAgICBpZFxuICB9ID0gcGFyYW1zO1xuICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZiA9IGFjdG9yU2NvcGUuc2VsZjtcbiAgICAgIGFjdG9yU2NvcGUuc3lzdGVtLnNjaGVkdWxlci5zY2hlZHVsZShzZWxmLCBzZWxmLCBldmVudCwgZGVsYXksIGlkKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbn1cbi8qKlxuICogUmFpc2VzIGFuIGV2ZW50LiBUaGlzIHBsYWNlcyB0aGUgZXZlbnQgaW4gdGhlIGludGVybmFsIGV2ZW50IHF1ZXVlLCBzbyB0aGF0XG4gKiB0aGUgZXZlbnQgaXMgaW1tZWRpYXRlbHkgY29uc3VtZWQgYnkgdGhlIG1hY2hpbmUgaW4gdGhlIGN1cnJlbnQgc3RlcC5cbiAqXG4gKiBAcGFyYW0gZXZlbnRUeXBlIFRoZSBldmVudCB0byByYWlzZS5cbiAqL1xuZnVuY3Rpb24gcmFpc2UoZXZlbnRPckV4cHIsIG9wdGlvbnMpIHtcbiAgaWYgKGV4ZWN1dGluZ0N1c3RvbUFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIGFjdGlvbnMgc2hvdWxkIG5vdCBjYWxsIGByYWlzZSgpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiByYWlzZShfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgcmFpc2UudHlwZSA9ICd4c3RhdGUucmFpc2UnO1xuICByYWlzZS5ldmVudCA9IGV2ZW50T3JFeHByO1xuICByYWlzZS5pZCA9IG9wdGlvbnM/LmlkO1xuICByYWlzZS5kZWxheSA9IG9wdGlvbnM/LmRlbGF5O1xuICByYWlzZS5yZXNvbHZlID0gcmVzb2x2ZVJhaXNlO1xuICByYWlzZS5leGVjdXRlID0gZXhlY3V0ZVJhaXNlO1xuICByZXR1cm4gcmFpc2U7XG59XG5cbmV4cG9ydCB7ICQkQUNUT1JfVFlQRSBhcyAkLCBjcmVhdGVBY3RvciBhcyBBLCBBY3RvciBhcyBCLCBpbnRlcnByZXQgYXMgQywgYW5kIGFzIEQsIG5vdCBhcyBFLCBvciBhcyBGLCBzdGF0ZUluIGFzIEcsIGlzTWFjaGluZVNuYXBzaG90IGFzIEgsIGdldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMgYXMgSSwgbWF0Y2hlc1N0YXRlIGFzIEosIHBhdGhUb1N0YXRlVmFsdWUgYXMgSywgdG9PYnNlcnZlciBhcyBMLCBjYW5jZWwgYXMgTSwgTlVMTF9FVkVOVCBhcyBOLCByYWlzZSBhcyBPLCBzcGF3bkNoaWxkIGFzIFAsIHN0b3AgYXMgUSwgc3RvcENoaWxkIGFzIFIsIFNUQVRFX0RFTElNSVRFUiBhcyBTLCBQcm9jZXNzaW5nU3RhdHVzIGFzIFQsIGNsb25lTWFjaGluZVNuYXBzaG90IGFzIFUsIGV4ZWN1dGluZ0N1c3RvbUFjdGlvbiBhcyBWLCBYU1RBVEVfRVJST1IgYXMgVywgWFNUQVRFX1NUT1AgYXMgWCwgY3JlYXRlRXJyb3JBY3RvckV2ZW50IGFzIFksIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5IGFzIGEsIGZvcm1hdFRyYW5zaXRpb24gYXMgYiwgY3JlYXRlSW52b2tlSWQgYXMgYywgZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24gYXMgZCwgZXZhbHVhdGVHdWFyZCBhcyBlLCBmb3JtYXRUcmFuc2l0aW9ucyBhcyBmLCBnZXREZWxheWVkVHJhbnNpdGlvbnMgYXMgZywgZ2V0Q2FuZGlkYXRlcyBhcyBoLCBnZXRBbGxTdGF0ZU5vZGVzIGFzIGksIGdldFN0YXRlTm9kZXMgYXMgaiwgY3JlYXRlTWFjaGluZVNuYXBzaG90IGFzIGssIGlzSW5GaW5hbFN0YXRlIGFzIGwsIG1hcFZhbHVlcyBhcyBtLCBtYWNyb3N0ZXAgYXMgbiwgdHJhbnNpdGlvbk5vZGUgYXMgbywgcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0IGFzIHAsIGNyZWF0ZUluaXRFdmVudCBhcyBxLCByZXNvbHZlU3RhdGVWYWx1ZSBhcyByLCBtaWNyb3N0ZXAgYXMgcywgdG9BcnJheSBhcyB0LCBnZXRJbml0aWFsU3RhdGVOb2RlcyBhcyB1LCB0b1N0YXRlUGF0aCBhcyB2LCBpc1N0YXRlSWQgYXMgdywgZ2V0U3RhdGVOb2RlQnlQYXRoIGFzIHgsIGdldFBlcnNpc3RlZFNuYXBzaG90IGFzIHksIHJlc29sdmVSZWZlcmVuY2VkQWN0b3IgYXMgeiB9O1xuIl0sIm5hbWVzIjpbImRldlRvb2xzQWRhcHRlciIsIk1haWxib3giLCJjb25zdHJ1Y3RvciIsIl9wcm9jZXNzIiwiX2FjdGl2ZSIsIl9jdXJyZW50IiwiX2xhc3QiLCJzdGFydCIsImZsdXNoIiwiY2xlYXIiLCJuZXh0IiwiZW5xdWV1ZSIsImV2ZW50IiwiZW5xdWV1ZWQiLCJ2YWx1ZSIsImNvbnN1bWVkIiwiU1RBVEVfREVMSU1JVEVSIiwiVEFSR0VUTEVTU19LRVkiLCJOVUxMX0VWRU5UIiwiU1RBVEVfSURFTlRJRklFUiIsIldJTERDQVJEIiwiWFNUQVRFX0lOSVQiLCJYU1RBVEVfRVJST1IiLCJYU1RBVEVfU1RPUCIsImNyZWF0ZUFmdGVyRXZlbnQiLCJkZWxheVJlZiIsImlkIiwidHlwZSIsImNyZWF0ZURvbmVTdGF0ZUV2ZW50Iiwib3V0cHV0IiwiY3JlYXRlRG9uZUFjdG9yRXZlbnQiLCJpbnZva2VJZCIsImFjdG9ySWQiLCJjcmVhdGVFcnJvckFjdG9yRXZlbnQiLCJlcnJvciIsImNyZWF0ZUluaXRFdmVudCIsImlucHV0IiwicmVwb3J0VW5oYW5kbGVkRXJyb3IiLCJlcnIiLCJzZXRUaW1lb3V0Iiwic3ltYm9sT2JzZXJ2YWJsZSIsIlN5bWJvbCIsIm9ic2VydmFibGUiLCJtYXRjaGVzU3RhdGUiLCJwYXJlbnRTdGF0ZUlkIiwiY2hpbGRTdGF0ZUlkIiwicGFyZW50U3RhdGVWYWx1ZSIsInRvU3RhdGVWYWx1ZSIsImNoaWxkU3RhdGVWYWx1ZSIsIk9iamVjdCIsImtleXMiLCJldmVyeSIsImtleSIsInRvU3RhdGVQYXRoIiwic3RhdGVJZCIsImlzQXJyYXkiLCJyZXN1bHQiLCJzZWdtZW50IiwiaSIsImxlbmd0aCIsImNoYXIiLCJjaGFyQ29kZUF0IiwicHVzaCIsInN0YXRlVmFsdWUiLCJpc01hY2hpbmVTbmFwc2hvdCIsInN0YXRlUGF0aCIsInBhdGhUb1N0YXRlVmFsdWUiLCJtYXJrZXIiLCJwcmV2aW91cyIsIm1hcFZhbHVlcyIsImNvbGxlY3Rpb24iLCJpdGVyYXRlZSIsImNvbGxlY3Rpb25LZXlzIiwidG9BcnJheVN0cmljdCIsInRvQXJyYXkiLCJ1bmRlZmluZWQiLCJyZXNvbHZlT3V0cHV0IiwibWFwcGVyIiwiY29udGV4dCIsInNlbGYiLCJ2YWx1ZXMiLCJzb21lIiwidmFsIiwiY29uc29sZSIsIndhcm4iLCJlbnRyaWVzIiwiZmlsdGVyIiwibWFwIiwidG9TdHJpbmciLCJyZXBsYWNlIiwiam9pbiIsIkFycmF5IiwiaXNFcnJvckFjdG9yRXZlbnQiLCJzdGFydHNXaXRoIiwidG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkiLCJjb25maWdMaWtlIiwidHJhbnNpdGlvbkxpa2UiLCJ0YXJnZXQiLCJub3JtYWxpemVUYXJnZXQiLCJ0b09ic2VydmVyIiwibmV4dEhhbmRsZXIiLCJlcnJvckhhbmRsZXIiLCJjb21wbGV0aW9uSGFuZGxlciIsImlzT2JzZXJ2ZXIiLCJiaW5kIiwiY29tcGxldGUiLCJjcmVhdGVJbnZva2VJZCIsInN0YXRlTm9kZUlkIiwiaW5kZXgiLCJyZXNvbHZlUmVmZXJlbmNlZEFjdG9yIiwibWFjaGluZSIsInNyYyIsIm1hdGNoIiwiaW1wbGVtZW50YXRpb25zIiwiYWN0b3JzIiwiaW5kZXhTdHIiLCJub2RlSWQiLCJub2RlIiwiZ2V0U3RhdGVOb2RlQnlJZCIsImludm9rZUNvbmZpZyIsImNvbmZpZyIsImludm9rZSIsImdldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMiLCJzbmFwc2hvdCIsIlNldCIsIl9ub2RlcyIsImZsYXRNYXAiLCJzbiIsIm93bkV2ZW50cyIsImNyZWF0ZVNjaGVkdWxlZEV2ZW50SWQiLCJhY3RvclJlZiIsInNlc3Npb25JZCIsImlkQ291bnRlciIsImNyZWF0ZVN5c3RlbSIsInJvb3RBY3RvciIsIm9wdGlvbnMiLCJjaGlsZHJlbiIsIk1hcCIsImtleWVkQWN0b3JzIiwicmV2ZXJzZUtleWVkQWN0b3JzIiwiV2Vha01hcCIsImluc3BlY3Rpb25PYnNlcnZlcnMiLCJ0aW1lck1hcCIsImNsb2NrIiwibG9nZ2VyIiwic2NoZWR1bGVyIiwic2NoZWR1bGUiLCJzb3VyY2UiLCJkZWxheSIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsInNjaGVkdWxlZEV2ZW50Iiwic3RhcnRlZEF0IiwiRGF0ZSIsIm5vdyIsInNjaGVkdWxlZEV2ZW50SWQiLCJzeXN0ZW0iLCJfc25hcHNob3QiLCJfc2NoZWR1bGVkRXZlbnRzIiwidGltZW91dCIsIl9yZWxheSIsImNhbmNlbCIsImNsZWFyVGltZW91dCIsImNhbmNlbEFsbCIsInNlbmRJbnNwZWN0aW9uRXZlbnQiLCJzaXplIiwicmVzb2x2ZWRJbnNwZWN0aW9uRXZlbnQiLCJyb290SWQiLCJmb3JFYWNoIiwib2JzZXJ2ZXIiLCJfYm9va0lkIiwiX3JlZ2lzdGVyIiwic2V0IiwiX3VucmVnaXN0ZXIiLCJkZWxldGUiLCJzeXN0ZW1JZCIsImdldCIsIl9zZXQiLCJleGlzdGluZyIsIkVycm9yIiwiaW5zcGVjdCIsIm9ic2VydmVyT3JGbiIsImFkZCIsInVuc3Vic2NyaWJlIiwiX3NlbmRJbnNwZWN0aW9uRXZlbnQiLCJzb3VyY2VSZWYiLCJfc2VuZCIsImdldFNuYXBzaG90Iiwic2NoZWR1bGVkRXZlbnRzIiwic2NoZWR1bGVkSWQiLCJfY2xvY2siLCJfbG9nZ2VyIiwiZXhlY3V0aW5nQ3VzdG9tQWN0aW9uIiwiJCRBQ1RPUl9UWVBFIiwiUHJvY2Vzc2luZ1N0YXR1cyIsImRlZmF1bHRPcHRpb25zIiwiZm4iLCJtcyIsImxvZyIsImRldlRvb2xzIiwiQWN0b3IiLCJsb2dpYyIsIm1haWxib3giLCJvYnNlcnZlcnMiLCJldmVudExpc3RlbmVycyIsIl9wcm9jZXNzaW5nU3RhdHVzIiwiTm90U3RhcnRlZCIsIl9wYXJlbnQiLCJfc3luY1NuYXBzaG90IiwicmVmIiwiX2FjdG9yU2NvcGUiLCJfc3lzdGVtSWQiLCJfZG9uZUV2ZW50IiwiX2RlZmVycmVkIiwicmVzb2x2ZWRPcHRpb25zIiwicGFyZW50Iiwic3luY1NuYXBzaG90IiwiZGVmZXIiLCJzdG9wQ2hpbGQiLCJjaGlsZCIsIl9zdG9wIiwiZW1pdCIsImVtaXR0ZWRFdmVudCIsImxpc3RlbmVycyIsIndpbGRjYXJkTGlzdGVuZXIiLCJhbGxMaXN0ZW5lcnMiLCJoYW5kbGVyIiwiYWN0aW9uRXhlY3V0b3IiLCJhY3Rpb24iLCJleGVjIiwicGFyYW1zIiwic2F2ZUV4ZWN1dGluZ0N1c3RvbUFjdGlvbiIsImluZm8iLCJSdW5uaW5nIiwic2VuZCIsIl9pbml0U3RhdGUiLCJzdGF0ZSIsInN0YXR1cyIsInBlcnNpc3RlZFN0YXRlIiwicmVzdG9yZVNuYXBzaG90IiwiZ2V0SW5pdGlhbFNuYXBzaG90IiwidXBkYXRlIiwiZGVmZXJyZWRGbiIsInNoaWZ0IiwiX3N0b3BQcm9jZWR1cmUiLCJfY29tcGxldGUiLCJfZXJyb3IiLCJzdWJzY3JpYmUiLCJuZXh0TGlzdGVuZXJPck9ic2VydmVyIiwiZXJyb3JMaXN0ZW5lciIsImNvbXBsZXRlTGlzdGVuZXIiLCJTdG9wcGVkIiwib24iLCJ3cmFwcGVkSGFuZGxlciIsImluaXRFdmVudCIsImF0dGFjaERldlRvb2xzIiwibmV4dFN0YXRlIiwiY2F1Z2h0RXJyb3IiLCJ0cmFuc2l0aW9uIiwic3RvcCIsIl9yZXBvcnRFcnJvciIsInJlcG9ydEVycm9yIiwiZXJyMiIsImV2ZW50U3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc29sdmVkRGV2VG9vbHNBZGFwdGVyIiwidG9KU09OIiwieHN0YXRlJCR0eXBlIiwiZ2V0UGVyc2lzdGVkU25hcHNob3QiLCJjcmVhdGVBY3RvciIsImludGVycHJldCIsInJlc29sdmVDYW5jZWwiLCJfIiwiYWN0aW9uQXJncyIsImFjdGlvblBhcmFtcyIsInNlbmRJZCIsInJlc29sdmVkU2VuZElkIiwiZXhlY3V0ZUNhbmNlbCIsImFjdG9yU2NvcGUiLCJfYXJncyIsIl9wYXJhbXMiLCJyZXNvbHZlIiwiZXhlY3V0ZSIsInJlc29sdmVTcGF3biIsIl9hY3Rpb25QYXJhbXMiLCJyZXNvbHZlZElkIiwicmVzb2x2ZWRJbnB1dCIsImNsb25lTWFjaGluZVNuYXBzaG90IiwiZXhlY3V0ZVNwYXduIiwic3Bhd25DaGlsZCIsInJlc29sdmVTdG9wIiwiYXJncyIsImFjdG9yUmVmT3JTdHJpbmciLCJyZXNvbHZlZEFjdG9yUmVmIiwiZXhlY3V0ZVN0b3AiLCJjaGVja1N0YXRlSW4iLCJpc1N0YXRlSWQiLCJtYXRjaGVzIiwic3RhdGVJbiIsImNoZWNrIiwiY2hlY2tOb3QiLCJndWFyZHMiLCJldmFsdWF0ZUd1YXJkIiwibm90IiwiZ3VhcmQiLCJjaGVja0FuZCIsImFuZCIsImNoZWNrT3IiLCJvciIsImlzSW5saW5lIiwicmVzb2x2ZWQiLCJndWFyZEFyZ3MiLCJndWFyZFBhcmFtcyIsImJ1aWx0aW5HdWFyZCIsImlzQXRvbWljU3RhdGVOb2RlIiwic3RhdGVOb2RlIiwiZ2V0Q2hpbGRyZW4iLCJzdGF0ZXMiLCJnZXRQcm9wZXJBbmNlc3RvcnMiLCJ0b1N0YXRlTm9kZSIsImFuY2VzdG9ycyIsIm0iLCJnZXRBbGxTdGF0ZU5vZGVzIiwic3RhdGVOb2RlcyIsIm5vZGVTZXQiLCJhZGpMaXN0IiwiZ2V0QWRqTGlzdCIsInMiLCJnZXRJbml0aWFsU3RhdGVOb2Rlc1dpdGhUaGVpckFuY2VzdG9ycyIsImhhcyIsImluaXRpYWxTdGF0ZXMiLCJpbml0aWFsU3RhdGVOb2RlIiwiZ2V0VmFsdWVGcm9tQWRqIiwiYmFzZU5vZGUiLCJjaGlsZFN0YXRlTm9kZXMiLCJjaGlsZFN0YXRlTm9kZSIsImdldFN0YXRlVmFsdWUiLCJyb290Tm9kZSIsImlzSW5GaW5hbFN0YXRlIiwic3RhdGVOb2RlU2V0Iiwic3RyIiwiZ2V0Q2FuZGlkYXRlcyIsInJlY2VpdmVkRXZlbnRUeXBlIiwiY2FuZGlkYXRlcyIsInRyYW5zaXRpb25zIiwiZXZlbnREZXNjcmlwdG9yIiwiZW5kc1dpdGgiLCJ0ZXN0IiwicGFydGlhbEV2ZW50VG9rZW5zIiwic3BsaXQiLCJldmVudFRva2VucyIsInRva2VuSW5kZXgiLCJwYXJ0aWFsRXZlbnRUb2tlbiIsImV2ZW50VG9rZW4iLCJpc0xhc3RUb2tlbiIsInNvcnQiLCJhIiwiYiIsImdldERlbGF5ZWRUcmFuc2l0aW9ucyIsImFmdGVyQ29uZmlnIiwiYWZ0ZXIiLCJtdXRhdGVFbnRyeUV4aXQiLCJhZnRlckV2ZW50IiwiZXZlbnRUeXBlIiwiZW50cnkiLCJyYWlzZSIsImV4aXQiLCJkZWxheWVkVHJhbnNpdGlvbnMiLCJjb25maWdUcmFuc2l0aW9uIiwicmVzb2x2ZWRUcmFuc2l0aW9uIiwicmVzb2x2ZWREZWxheSIsIk51bWJlciIsImlzTmFOIiwiZGVsYXllZFRyYW5zaXRpb24iLCJmb3JtYXRUcmFuc2l0aW9uIiwiZGVzY3JpcHRvciIsInRyYW5zaXRpb25Db25maWciLCJub3JtYWxpemVkVGFyZ2V0IiwicmVlbnRlciIsInJlc29sdmVUYXJnZXQiLCJjb25kIiwiYWN0aW9ucyIsInQiLCJmb3JtYXRUcmFuc2l0aW9ucyIsInRyYW5zaXRpb25zQ29uZmlnIiwib25Eb25lIiwiaW52b2tlRGVmIiwib25FcnJvciIsIm9uU25hcHNob3QiLCJmb3JtYXRJbml0aWFsVHJhbnNpdGlvbiIsIl90YXJnZXQiLCJyZXNvbHZlZFRhcmdldCIsInRhcmdldHMiLCJpc0ludGVybmFsVGFyZ2V0IiwiZ2V0U3RhdGVOb2RlQnlQYXRoIiwidGFyZ2V0U3RhdGVOb2RlIiwibWVzc2FnZSIsInJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24iLCJpbml0aWFsIiwiaXNIaXN0b3J5Tm9kZSIsImdldEluaXRpYWxTdGF0ZU5vZGVzIiwiaW5pdGlhbFN0YXRlIiwiYW5jZXN0b3IiLCJpdGVyIiwiZGVzY1N0YXRlTm9kZSIsImdldFN0YXRlTm9kZSIsInN0YXRlS2V5IiwiYXJyYXlTdGF0ZVBhdGgiLCJjdXJyZW50U3RhdGVOb2RlIiwiZ2V0U3RhdGVOb2RlcyIsImNoaWxkU3RhdGVLZXlzIiwic3ViU3RhdGVLZXkiLCJCb29sZWFuIiwicm9vdCIsImNvbmNhdCIsInJlZHVjZSIsImFsbFN1YlN0YXRlTm9kZXMiLCJzdWJTdGF0ZU5vZGUiLCJzdWJTdGF0ZU5vZGVzIiwidHJhbnNpdGlvbkF0b21pY05vZGUiLCJ0cmFuc2l0aW9uQ29tcG91bmROb2RlIiwic3ViU3RhdGVLZXlzIiwidHJhbnNpdGlvbk5vZGUiLCJ0cmFuc2l0aW9uUGFyYWxsZWxOb2RlIiwiYWxsSW5uZXJUcmFuc2l0aW9ucyIsInN1YlN0YXRlVmFsdWUiLCJpbm5lclRyYW5zaXRpb25zIiwiZ2V0SGlzdG9yeU5vZGVzIiwiaXNEZXNjZW5kYW50IiwicGFyZW50U3RhdGVOb2RlIiwiaGFzSW50ZXJzZWN0aW9uIiwiczEiLCJzMiIsInNldDEiLCJzZXQyIiwiaXRlbSIsInJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnMiLCJlbmFibGVkVHJhbnNpdGlvbnMiLCJoaXN0b3J5VmFsdWUiLCJmaWx0ZXJlZFRyYW5zaXRpb25zIiwidDEiLCJ0MVByZWVtcHRlZCIsInRyYW5zaXRpb25zVG9SZW1vdmUiLCJ0MiIsImNvbXB1dGVFeGl0U2V0IiwidDMiLCJmcm9tIiwiZmluZExlYXN0Q29tbW9uQW5jZXN0b3IiLCJoZWFkIiwidGFpbCIsImdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyIsInRhcmdldE5vZGUiLCJnZXRUcmFuc2l0aW9uRG9tYWluIiwidGFyZ2V0U3RhdGVzIiwibGNhIiwic3RhdGVzVG9FeGl0IiwiZG9tYWluIiwiYXJlU3RhdGVOb2RlQ29sbGVjdGlvbnNFcXVhbCIsInByZXZTdGF0ZU5vZGVzIiwibmV4dFN0YXRlTm9kZVNldCIsIm1pY3Jvc3RlcCIsImN1cnJlbnRTbmFwc2hvdCIsImlzSW5pdGlhbCIsImludGVybmFsUXVldWUiLCJtdXRTdGF0ZU5vZGVTZXQiLCJleGl0U3RhdGVzIiwicmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0IiwiZW50ZXJTdGF0ZXMiLCJuZXh0U3RhdGVOb2RlcyIsIm9yZGVyIiwiZSIsImdldE1hY2hpbmVPdXRwdXQiLCJyb290Q29tcGxldGlvbk5vZGUiLCJkb25lU3RhdGVFdmVudCIsIm5leHRTbmFwc2hvdCIsInN0YXRlc1RvRW50ZXIiLCJzdGF0ZXNGb3JEZWZhdWx0RW50cnkiLCJjb21wdXRlRW50cnlTZXQiLCJjb21wbGV0ZWROb2RlcyIsInN0YXRlTm9kZVRvRW50ZXIiLCJpbml0aWFsQWN0aW9ucyIsImFuY2VzdG9yTWFya2VyIiwiYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIiLCJhZGRBbmNlc3RvclN0YXRlc1RvRW50ZXIiLCJoaXN0b3J5U3RhdGVOb2RlcyIsImFkZFByb3BlckFuY2VzdG9yU3RhdGVzVG9FbnRlciIsImhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbiIsInJlZW50cmFuY3lEb21haW4iLCJhbmMiLCJfYWN0aW9uRXhlY3V0b3IiLCJjaGFuZ2VkSGlzdG9yeSIsImV4aXRTdGF0ZU5vZGUiLCJoaXN0b3J5Tm9kZSIsInByZWRpY2F0ZSIsImhpc3RvcnkiLCJkZWYiLCJnZXRBY3Rpb24iLCJhY3Rpb25UeXBlIiwicmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQiLCJleHRyYSIsInJldHJpZXMiLCJpbnRlcm1lZGlhdGVTbmFwc2hvdCIsInJlc29sdmVkQWN0aW9uIiwibmFtZSIsImJ1aWx0aW5BY3Rpb24iLCJkZWZlcnJlZEFjdG9ySWRzIiwicmV0cnlSZXNvbHZlIiwibWFjcm9zdGVwIiwibWljcm9zdGF0ZXMiLCJhZGRNaWNyb3N0YXRlIiwibWljcm9zdGF0ZSIsIl90cmFuc2l0aW9ucyIsInN0b3BDaGlsZHJlbiIsIm5leHRFdmVudCIsImN1cnJlbnRFdmVudCIsImlzRXJyIiwic2VsZWN0VHJhbnNpdGlvbnMiLCJzaG91bGRTZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyIsInNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zIiwicHJldmlvdXNTdGF0ZSIsImdldFRyYW5zaXRpb25EYXRhIiwiZW5hYmxlZFRyYW5zaXRpb25TZXQiLCJhdG9taWNTdGF0ZXMiLCJsb29wIiwiYWx3YXlzIiwicmVzb2x2ZVN0YXRlVmFsdWUiLCJhbGxTdGF0ZU5vZGVzIiwibWFjaGluZVNuYXBzaG90TWF0Y2hlcyIsInRlc3RWYWx1ZSIsIm1hY2hpbmVTbmFwc2hvdEhhc1RhZyIsImhhc1RhZyIsInRhZyIsInRhZ3MiLCJtYWNoaW5lU25hcHNob3RDYW4iLCJjYW4iLCJ0cmFuc2l0aW9uRGF0YSIsIm1hY2hpbmVTbmFwc2hvdFRvSlNPTiIsIm5vZGVzIiwiZ2V0TWV0YSIsImpzb25WYWx1ZXMiLCJtYWNoaW5lU25hcHNob3RHZXRNZXRhIiwiYWNjIiwibWV0YSIsImNyZWF0ZU1hY2hpbmVTbmFwc2hvdCIsImNoaWxkcmVuSnNvbiIsInBlcnNpc3RlZCIsInBlcnNpc3RDb250ZXh0IiwiY29udGV4dFBhcnQiLCJjb3B5IiwicmVzb2x2ZVJhaXNlIiwiZXZlbnRPckV4cHIiLCJkZWxheXNNYXAiLCJkZWxheXMiLCJyZXNvbHZlZEV2ZW50IiwiY29uZmlnRGVsYXkiLCJleGVjdXRlUmFpc2UiLCIkIiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJJIiwiSiIsIksiLCJMIiwiTSIsIk4iLCJPIiwiUCIsIlEiLCJSIiwiUyIsIlQiLCJVIiwiViIsIlciLCJYIiwiWSIsImMiLCJkIiwiZiIsImciLCJoIiwiaiIsImsiLCJsIiwibiIsIm8iLCJwIiwicSIsInIiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/xstate/dist/xstate.development.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/xstate/dist/xstate.development.esm.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Actor: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.B),\n/* harmony export */   SimulatedClock: () => (/* binding */ SimulatedClock),\n/* harmony export */   SpecialTargets: () => (/* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.S),\n/* harmony export */   StateMachine: () => (/* binding */ StateMachine),\n/* harmony export */   StateNode: () => (/* binding */ StateNode),\n/* harmony export */   __unsafe_getAllOwnEventDescriptors: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.I),\n/* harmony export */   and: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.D),\n/* harmony export */   assertEvent: () => (/* binding */ assertEvent),\n/* harmony export */   assign: () => (/* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a),\n/* harmony export */   cancel: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.M),\n/* harmony export */   createActor: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A),\n/* harmony export */   createEmptyActor: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.createEmptyActor),\n/* harmony export */   createMachine: () => (/* binding */ createMachine),\n/* harmony export */   emit: () => (/* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.e),\n/* harmony export */   enqueueActions: () => (/* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.b),\n/* harmony export */   forwardTo: () => (/* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.f),\n/* harmony export */   fromCallback: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromCallback),\n/* harmony export */   fromEventObservable: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromEventObservable),\n/* harmony export */   fromObservable: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromObservable),\n/* harmony export */   fromPromise: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromPromise),\n/* harmony export */   fromTransition: () => (/* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromTransition),\n/* harmony export */   getInitialSnapshot: () => (/* binding */ getInitialSnapshot),\n/* harmony export */   getNextSnapshot: () => (/* binding */ getNextSnapshot),\n/* harmony export */   getStateNodes: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j),\n/* harmony export */   initialTransition: () => (/* binding */ initialTransition),\n/* harmony export */   interpret: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.C),\n/* harmony export */   isMachineSnapshot: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.H),\n/* harmony export */   log: () => (/* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.l),\n/* harmony export */   matchesState: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.J),\n/* harmony export */   not: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.E),\n/* harmony export */   or: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.F),\n/* harmony export */   pathToStateValue: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.K),\n/* harmony export */   raise: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.O),\n/* harmony export */   sendParent: () => (/* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.s),\n/* harmony export */   sendTo: () => (/* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.c),\n/* harmony export */   setup: () => (/* binding */ setup),\n/* harmony export */   spawnChild: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.P),\n/* harmony export */   stateIn: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.G),\n/* harmony export */   stop: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.Q),\n/* harmony export */   stopChild: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.R),\n/* harmony export */   toObserver: () => (/* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.L),\n/* harmony export */   toPromise: () => (/* binding */ toPromise),\n/* harmony export */   transition: () => (/* binding */ transition),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\n/* harmony import */ var _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actors/dist/xstate-actors.development.esm.js */ \"(ssr)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raise-1db27a82.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./log-0acd9069.development.esm.js */ \"(ssr)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(ssr)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n\n\n\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */ function assertEvent(event, type) {\n    const types = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(type);\n    if (!types.includes(event.type)) {\n        const typesText = types.length === 1 ? `type \"${types[0]}\"` : `one of types \"${types.join('\", \"')}\"`;\n        throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n    }\n}\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n    let memoizedData = cache.get(object);\n    if (!memoizedData) {\n        memoizedData = {\n            [key]: fn()\n        };\n        cache.set(object, memoizedData);\n    } else if (!(key in memoizedData)) {\n        memoizedData[key] = fn();\n    }\n    return memoizedData[key];\n}\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = (action)=>{\n    if (typeof action === \"string\") {\n        return {\n            type: action\n        };\n    }\n    if (typeof action === \"function\") {\n        if (\"resolve\" in action) {\n            return {\n                type: action.type\n            };\n        }\n        return {\n            type: action.name\n        };\n    }\n    return action;\n};\nclass StateNode {\n    constructor(/** The raw config used to create the machine. */ config, options){\n        this.config = config;\n        /**\n     * The relative key of the state node, which represents its location in the\n     * overall state value.\n     */ this.key = void 0;\n        /** The unique ID of the state node. */ this.id = void 0;\n        /**\n     * The type of this state node:\n     *\n     * - `'atomic'` - no child state nodes\n     * - `'compound'` - nested child state nodes (XOR)\n     * - `'parallel'` - orthogonal nested child state nodes (AND)\n     * - `'history'` - history state node\n     * - `'final'` - final state node\n     */ this.type = void 0;\n        /** The string path from the root machine node to this node. */ this.path = void 0;\n        /** The child state nodes. */ this.states = void 0;\n        /**\n     * The type of history on this state node. Can be:\n     *\n     * - `'shallow'` - recalls only top-level historical state value\n     * - `'deep'` - recalls historical state value at all levels\n     */ this.history = void 0;\n        /** The action(s) to be executed upon entering the state node. */ this.entry = void 0;\n        /** The action(s) to be executed upon exiting the state node. */ this.exit = void 0;\n        /** The parent state node. */ this.parent = void 0;\n        /** The root machine node. */ this.machine = void 0;\n        /**\n     * The meta data associated with this state node, which will be returned in\n     * State instances.\n     */ this.meta = void 0;\n        /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a\n     * final state node.\n     */ this.output = void 0;\n        /**\n     * The order this state node appears. Corresponds to the implicit document\n     * order.\n     */ this.order = -1;\n        this.description = void 0;\n        this.tags = [];\n        this.transitions = void 0;\n        this.always = void 0;\n        this.parent = options._parent;\n        this.key = options._key;\n        this.machine = options._machine;\n        this.path = this.parent ? this.parent.path.concat(this.key) : [];\n        this.id = this.config.id || [\n            this.machine.id,\n            ...this.path\n        ].join(_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.S);\n        this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? \"compound\" : this.config.history ? \"history\" : \"atomic\");\n        this.description = this.config.description;\n        this.order = this.machine.idMap.size;\n        this.machine.idMap.set(this.id, this);\n        this.states = this.config.states ? (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(this.config.states, (stateConfig, key)=>{\n            const stateNode = new StateNode(stateConfig, {\n                _parent: this,\n                _key: key,\n                _machine: this.machine\n            });\n            return stateNode;\n        }) : EMPTY_OBJECT;\n        if (this.type === \"compound\" && !this.config.initial) {\n            throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n        }\n        // History config\n        this.history = this.config.history === true ? \"shallow\" : this.config.history || false;\n        this.entry = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.entry).slice();\n        this.exit = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.exit).slice();\n        this.meta = this.config.meta;\n        this.output = this.type === \"final\" || !this.parent ? this.config.output : undefined;\n        this.tags = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(config.tags).slice();\n    }\n    /** @internal */ _initialize() {\n        this.transitions = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(this);\n        if (this.config.always) {\n            this.always = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(this.config.always).map((t)=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.N, t));\n        }\n        Object.keys(this.states).forEach((key)=>{\n            this.states[key]._initialize();\n        });\n    }\n    /** The well-structured state node definition. */ get definition() {\n        return {\n            id: this.id,\n            key: this.key,\n            version: this.machine.version,\n            type: this.type,\n            initial: this.initial ? {\n                target: this.initial.target,\n                source: this,\n                actions: this.initial.actions.map(toSerializableAction),\n                eventType: null,\n                reenter: false,\n                toJSON: ()=>({\n                        target: this.initial.target.map((t)=>`#${t.id}`),\n                        source: `#${this.id}`,\n                        actions: this.initial.actions.map(toSerializableAction),\n                        eventType: null\n                    })\n            } : undefined,\n            history: this.history,\n            states: (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(this.states, (state)=>{\n                return state.definition;\n            }),\n            on: this.on,\n            transitions: [\n                ...this.transitions.values()\n            ].flat().map((t)=>({\n                    ...t,\n                    actions: t.actions.map(toSerializableAction)\n                })),\n            entry: this.entry.map(toSerializableAction),\n            exit: this.exit.map(toSerializableAction),\n            meta: this.meta,\n            order: this.order || -1,\n            output: this.output,\n            invoke: this.invoke,\n            description: this.description,\n            tags: this.tags\n        };\n    }\n    /** @internal */ toJSON() {\n        return this.definition;\n    }\n    /** The logic invoked as actors by this state node. */ get invoke() {\n        return memo(this, \"invoke\", ()=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.invoke).map((invokeConfig, i)=>{\n                const { src, systemId } = invokeConfig;\n                const resolvedId = invokeConfig.id ?? (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this.id, i);\n                const sourceName = typeof src === \"string\" ? src : `xstate.invoke.${(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this.id, i)}`;\n                return {\n                    ...invokeConfig,\n                    src: sourceName,\n                    id: resolvedId,\n                    systemId: systemId,\n                    toJSON () {\n                        const { onDone, onError, ...invokeDefValues } = invokeConfig;\n                        return {\n                            ...invokeDefValues,\n                            type: \"xstate.invoke\",\n                            src: sourceName,\n                            id: resolvedId\n                        };\n                    }\n                };\n            }));\n    }\n    /** The mapping of events to transitions. */ get on() {\n        return memo(this, \"on\", ()=>{\n            const transitions = this.transitions;\n            return [\n                ...transitions\n            ].flatMap(([descriptor, t])=>t.map((t)=>[\n                        descriptor,\n                        t\n                    ])).reduce((map, [descriptor, transition])=>{\n                map[descriptor] = map[descriptor] || [];\n                map[descriptor].push(transition);\n                return map;\n            }, {});\n        });\n    }\n    get after() {\n        return memo(this, \"delayedTransitions\", ()=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(this));\n    }\n    get initial() {\n        return memo(this, \"initial\", ()=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(this, this.config.initial));\n    }\n    /** @internal */ next(snapshot, event) {\n        const eventType = event.type;\n        const actions = [];\n        let selectedTransition;\n        const candidates = memo(this, `candidates-${eventType}`, ()=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.h)(this, eventType));\n        for (const candidate of candidates){\n            const { guard } = candidate;\n            const resolvedContext = snapshot.context;\n            let guardPassed = false;\n            try {\n                guardPassed = !guard || (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.e)(guard, resolvedContext, event, snapshot);\n            } catch (err) {\n                const guardType = typeof guard === \"string\" ? guard : typeof guard === \"object\" ? guard.type : undefined;\n                throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : \"\"}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n            }\n            if (guardPassed) {\n                actions.push(...candidate.actions);\n                selectedTransition = candidate;\n                break;\n            }\n        }\n        return selectedTransition ? [\n            selectedTransition\n        ] : undefined;\n    }\n    /** All the event types accepted by this state node and its descendants. */ get events() {\n        return memo(this, \"events\", ()=>{\n            const { states } = this;\n            const events = new Set(this.ownEvents);\n            if (states) {\n                for (const stateId of Object.keys(states)){\n                    const state = states[stateId];\n                    if (state.states) {\n                        for (const event of state.events){\n                            events.add(`${event}`);\n                        }\n                    }\n                }\n            }\n            return Array.from(events);\n        });\n    }\n    /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */ get ownEvents() {\n        const events = new Set([\n            ...this.transitions.keys()\n        ].filter((descriptor)=>{\n            return this.transitions.get(descriptor).some((transition)=>!(!transition.target && !transition.actions.length && !transition.reenter));\n        }));\n        return Array.from(events);\n    }\n}\nconst STATE_IDENTIFIER = \"#\";\nclass StateMachine {\n    constructor(/** The raw config used to create the machine. */ config, implementations){\n        this.config = config;\n        /** The machine's own version. */ this.version = void 0;\n        this.schemas = void 0;\n        this.implementations = void 0;\n        /** @internal */ this.__xstatenode = true;\n        /** @internal */ this.idMap = new Map();\n        this.root = void 0;\n        this.id = void 0;\n        this.states = void 0;\n        this.events = void 0;\n        this.id = config.id || \"(machine)\";\n        this.implementations = {\n            actors: implementations?.actors ?? {},\n            actions: implementations?.actions ?? {},\n            delays: implementations?.delays ?? {},\n            guards: implementations?.guards ?? {}\n        };\n        this.version = this.config.version;\n        this.schemas = this.config.schemas;\n        this.transition = this.transition.bind(this);\n        this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n        this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n        this.restoreSnapshot = this.restoreSnapshot.bind(this);\n        this.start = this.start.bind(this);\n        this.root = new StateNode(config, {\n            _key: this.id,\n            _machine: this\n        });\n        this.root._initialize();\n        this.states = this.root.states; // TODO: remove!\n        this.events = this.root.events;\n        if (!(\"output\" in this.root) && Object.values(this.states).some((state)=>state.type === \"final\" && \"output\" in state)) {\n            console.warn(\"Missing `machine.output` declaration (top-level final state with output detected)\");\n        }\n    }\n    /**\n   * Clones this state machine with the provided implementations and merges the\n   * `context` (if provided).\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,\n   *   `context`) to recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */ provide(implementations) {\n        const { actions, guards, actors, delays } = this.implementations;\n        return new StateMachine(this.config, {\n            actions: {\n                ...actions,\n                ...implementations.actions\n            },\n            guards: {\n                ...guards,\n                ...implementations.guards\n            },\n            actors: {\n                ...actors,\n                ...implementations.actors\n            },\n            delays: {\n                ...delays,\n                ...implementations.delays\n            }\n        });\n    }\n    resolveState(config) {\n        const resolvedStateValue = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.r)(this.root, config.value);\n        const nodeSet = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j)(this.root, resolvedStateValue));\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n            _nodes: [\n                ...nodeSet\n            ],\n            context: config.context || {},\n            children: {},\n            status: (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.l)(nodeSet, this.root) ? \"done\" : config.status || \"active\",\n            output: config.output,\n            error: config.error,\n            historyValue: config.historyValue\n        }, this);\n    }\n    /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */ transition(snapshot, event, actorScope) {\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(snapshot, event, actorScope, []).snapshot;\n    }\n    /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */ microstep(snapshot, event, actorScope) {\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(snapshot, event, actorScope, []).microstates;\n    }\n    getTransitionData(snapshot, event) {\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.o)(this.root, snapshot.value, snapshot, event) || [];\n    }\n    /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */ getPreInitialState(actorScope, initEvent, internalQueue) {\n        const { context } = this.config;\n        const preInitial = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n            context: typeof context !== \"function\" && context ? context : {},\n            _nodes: [\n                this.root\n            ],\n            children: {},\n            status: \"active\"\n        }, this);\n        if (typeof context === \"function\") {\n            const assignment = ({ spawn, event, self })=>context({\n                    spawn,\n                    input: event.input,\n                    self\n                });\n            return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.p)(preInitial, initEvent, actorScope, [\n                (0,_log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a)(assignment)\n            ], internalQueue, undefined);\n        }\n        return preInitial;\n    }\n    /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */ getInitialSnapshot(actorScope, input) {\n        const initEvent = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.q)(input); // TODO: fix;\n        const internalQueue = [];\n        const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n        const nextState = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.s)([\n            {\n                target: [\n                    ...(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.u)(this.root)\n                ],\n                source: this.root,\n                reenter: true,\n                actions: [],\n                eventType: null,\n                toJSON: null // TODO: fix\n            }\n        ], preInitialState, actorScope, initEvent, true, internalQueue);\n        const { snapshot: macroState } = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(nextState, initEvent, actorScope, internalQueue);\n        return macroState;\n    }\n    start(snapshot) {\n        Object.values(snapshot.children).forEach((child)=>{\n            if (child.getSnapshot().status === \"active\") {\n                child.start();\n            }\n        });\n    }\n    getStateNodeById(stateId) {\n        const fullPath = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.v)(stateId);\n        const relativePath = fullPath.slice(1);\n        const resolvedStateId = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.w)(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n        const stateNode = this.idMap.get(resolvedStateId);\n        if (!stateNode) {\n            throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n        }\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.x)(stateNode, relativePath);\n    }\n    get definition() {\n        return this.root.definition;\n    }\n    toJSON() {\n        return this.definition;\n    }\n    getPersistedSnapshot(snapshot, options) {\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.y)(snapshot, options);\n    }\n    restoreSnapshot(snapshot, _actorScope) {\n        const children = {};\n        const snapshotChildren = snapshot.children;\n        Object.keys(snapshotChildren).forEach((actorId)=>{\n            const actorData = snapshotChildren[actorId];\n            const childState = actorData.snapshot;\n            const src = actorData.src;\n            const logic = typeof src === \"string\" ? (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.z)(this, src) : src;\n            if (!logic) {\n                return;\n            }\n            const actorRef = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(logic, {\n                id: actorId,\n                parent: _actorScope.self,\n                syncSnapshot: actorData.syncSnapshot,\n                snapshot: childState,\n                src,\n                systemId: actorData.systemId\n            });\n            children[actorId] = actorRef;\n        });\n        const restoredSnapshot = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n            ...snapshot,\n            children,\n            _nodes: Array.from((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j)(this.root, snapshot.value)))\n        }, this);\n        const seen = new Set();\n        function reviveContext(contextPart, children) {\n            if (seen.has(contextPart)) {\n                return;\n            }\n            seen.add(contextPart);\n            for(const key in contextPart){\n                const value = contextPart[key];\n                if (value && typeof value === \"object\") {\n                    if (\"xstate$$type\" in value && value.xstate$$type === _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.$) {\n                        contextPart[key] = children[value.id];\n                        continue;\n                    }\n                    reviveContext(value, children);\n                }\n            }\n        }\n        reviveContext(restoredSnapshot.context, children);\n        return restoredSnapshot;\n    }\n}\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */ function createMachine(config, implementations) {\n    return new StateMachine(config, implementations);\n}\n/** @internal */ function createInertActorScope(actorLogic) {\n    const self = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(actorLogic);\n    const inertActorScope = {\n        self,\n        defer: ()=>{},\n        id: \"\",\n        logger: ()=>{},\n        sessionId: \"\",\n        stopChild: ()=>{},\n        system: self.system,\n        emit: ()=>{},\n        actionExecutor: ()=>{}\n    };\n    return inertActorScope;\n}\n/** @deprecated Use `initialTransition(…)` instead. */ function getInitialSnapshot(actorLogic, ...[input]) {\n    const actorScope = createInertActorScope(actorLogic);\n    return actorLogic.getInitialSnapshot(actorScope, input);\n}\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @deprecated Use `transition(…)` instead.\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */ function getNextSnapshot(actorLogic, snapshot, event) {\n    const inertActorScope = createInertActorScope(actorLogic);\n    inertActorScope.self._snapshot = snapshot;\n    return actorLogic.transition(snapshot, event, inertActorScope);\n}\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\nfunction setup({ schemas, actors, actions, guards, delays }) {\n    return {\n        createMachine: (config)=>createMachine({\n                ...config,\n                schemas\n            }, {\n                actors,\n                actions,\n                guards,\n                delays\n            })\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass SimulatedClock {\n    constructor(){\n        this.timeouts = new Map();\n        this._now = 0;\n        this._id = 0;\n        this._flushing = false;\n        this._flushingInvalidated = false;\n    }\n    now() {\n        return this._now;\n    }\n    getId() {\n        return this._id++;\n    }\n    setTimeout(fn, timeout) {\n        this._flushingInvalidated = this._flushing;\n        const id = this.getId();\n        this.timeouts.set(id, {\n            start: this.now(),\n            timeout,\n            fn\n        });\n        return id;\n    }\n    clearTimeout(id) {\n        this._flushingInvalidated = this._flushing;\n        this.timeouts.delete(id);\n    }\n    set(time) {\n        if (this._now > time) {\n            throw new Error(\"Unable to travel back in time\");\n        }\n        this._now = time;\n        this.flushTimeouts();\n    }\n    flushTimeouts() {\n        if (this._flushing) {\n            this._flushingInvalidated = true;\n            return;\n        }\n        this._flushing = true;\n        const sorted = [\n            ...this.timeouts\n        ].sort(([_idA, timeoutA], [_idB, timeoutB])=>{\n            const endA = timeoutA.start + timeoutA.timeout;\n            const endB = timeoutB.start + timeoutB.timeout;\n            return endB > endA ? -1 : 1;\n        });\n        for (const [id, timeout] of sorted){\n            if (this._flushingInvalidated) {\n                this._flushingInvalidated = false;\n                this._flushing = false;\n                this.flushTimeouts();\n                return;\n            }\n            if (this.now() - timeout.start >= timeout.timeout) {\n                this.timeouts.delete(id);\n                timeout.fn.call(null);\n            }\n        }\n        this._flushing = false;\n    }\n    increment(ms) {\n        this._now += ms;\n        this.flushTimeouts();\n    }\n}\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */ function toPromise(actor) {\n    return new Promise((resolve, reject)=>{\n        actor.subscribe({\n            complete: ()=>{\n                resolve(actor.getSnapshot().output);\n            },\n            error: reject\n        });\n    });\n}\n/**\n * Given actor `logic`, a `snapshot`, and an `event`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute.\n *\n * This is a pure function that does not execute `actions`.\n */ function transition(logic, snapshot, event) {\n    const executableActions = [];\n    const actorScope = createInertActorScope(logic);\n    actorScope.actionExecutor = (action)=>{\n        executableActions.push(action);\n    };\n    const nextSnapshot = logic.transition(snapshot, event, actorScope);\n    return [\n        nextSnapshot,\n        executableActions\n    ];\n}\n/**\n * Given actor `logic` and optional `input`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute from the initial transition (no\n * previous state).\n *\n * This is a pure function that does not execute `actions`.\n */ function initialTransition(logic, ...[input]) {\n    const executableActions = [];\n    const actorScope = createInertActorScope(logic);\n    actorScope.actionExecutor = (action)=>{\n        executableActions.push(action);\n    };\n    const nextSnapshot = logic.getInitialSnapshot(actorScope, input);\n    return [\n        nextSnapshot,\n        executableActions\n    ];\n}\nconst defaultWaitForOptions = {\n    timeout: Infinity // much more than 10 seconds\n};\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */ function waitFor(actorRef, predicate, options) {\n    const resolvedOptions = {\n        ...defaultWaitForOptions,\n        ...options\n    };\n    return new Promise((res, rej)=>{\n        const { signal } = resolvedOptions;\n        if (signal?.aborted) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            rej(signal.reason);\n            return;\n        }\n        let done = false;\n        if (resolvedOptions.timeout < 0) {\n            console.error(\"`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.\");\n        }\n        const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(()=>{\n            dispose();\n            rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n        }, resolvedOptions.timeout);\n        const dispose = ()=>{\n            clearTimeout(handle);\n            done = true;\n            sub?.unsubscribe();\n            if (abortListener) {\n                signal.removeEventListener(\"abort\", abortListener);\n            }\n        };\n        function checkEmitted(emitted) {\n            if (predicate(emitted)) {\n                dispose();\n                res(emitted);\n            }\n        }\n        /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */ let abortListener;\n        // eslint-disable-next-line prefer-const\n        let sub; // avoid TDZ when disposing synchronously\n        // See if the current snapshot already matches the predicate\n        checkEmitted(actorRef.getSnapshot());\n        if (done) {\n            return;\n        }\n        // only define the `abortListener` if the `signal` option is provided\n        if (signal) {\n            abortListener = ()=>{\n                dispose();\n                // XState does not \"own\" the signal, so we should reject with its reason (if any)\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                rej(signal.reason);\n            };\n            signal.addEventListener(\"abort\", abortListener);\n        }\n        sub = actorRef.subscribe({\n            next: checkEmitted,\n            error: (err)=>{\n                dispose();\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                rej(err);\n            },\n            complete: ()=>{\n                dispose();\n                rej(new Error(`Actor terminated without satisfying predicate`));\n            }\n        });\n        if (done) {\n            sub.unsubscribe();\n        }\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QveHN0YXRlLmRldmVsb3BtZW50LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUs7QUFDNGlCO0FBQzVXO0FBQ25TO0FBQzZHO0FBQzFIO0FBRW5EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsU0FBUzBHLFlBQVlDLEtBQUssRUFBRUMsSUFBSTtJQUM5QixNQUFNQyxRQUFRdEcscUVBQU9BLENBQUNxRztJQUN0QixJQUFJLENBQUNDLE1BQU1DLFFBQVEsQ0FBQ0gsTUFBTUMsSUFBSSxHQUFHO1FBQy9CLE1BQU1HLFlBQVlGLE1BQU1HLE1BQU0sS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFSCxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFQSxNQUFNSSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDcEcsTUFBTSxJQUFJQyxNQUFNLENBQUMsZUFBZSxFQUFFQyxLQUFLQyxTQUFTLENBQUNULE9BQU8sU0FBUyxFQUFFSSxVQUFVLENBQUM7SUFDaEY7QUFDRjtBQUVBLE1BQU1NLFFBQVEsSUFBSUM7QUFDbEIsU0FBU0MsS0FBS0MsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLEVBQUU7SUFDM0IsSUFBSUMsZUFBZU4sTUFBTU8sR0FBRyxDQUFDSjtJQUM3QixJQUFJLENBQUNHLGNBQWM7UUFDakJBLGVBQWU7WUFDYixDQUFDRixJQUFJLEVBQUVDO1FBQ1Q7UUFDQUwsTUFBTVEsR0FBRyxDQUFDTCxRQUFRRztJQUNwQixPQUFPLElBQUksQ0FBRUYsQ0FBQUEsT0FBT0UsWUFBVyxHQUFJO1FBQ2pDQSxZQUFZLENBQUNGLElBQUksR0FBR0M7SUFDdEI7SUFDQSxPQUFPQyxZQUFZLENBQUNGLElBQUk7QUFDMUI7QUFFQSxNQUFNSyxlQUFlLENBQUM7QUFDdEIsTUFBTUMsdUJB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aUZBQWlGO2dCQUNqRiwyRUFBMkU7Z0JBQzNFTixJQUFJQyxPQUFPRSxNQUFNO1lBQ25CO1lBQ0FGLE9BQU9ZLGdCQUFnQixDQUFDLFNBQVNKO1FBQ25DO1FBQ0FGLE1BQU1wRSxTQUFTa0QsU0FBUyxDQUFDO1lBQ3ZCM0gsTUFBTWlKO1lBQ05wRyxPQUFPcEMsQ0FBQUE7Z0JBQ0xtSTtnQkFDQSwyRUFBMkU7Z0JBQzNFTixJQUFJN0g7WUFDTjtZQUNBbUgsVUFBVTtnQkFDUmdCO2dCQUNBTixJQUFJLElBQUlwTixNQUFNLENBQUMsNkNBQTZDLENBQUM7WUFDL0Q7UUFDRjtRQUNBLElBQUl3TixNQUFNO1lBQ1JHLElBQUlDLFdBQVc7UUFDakI7SUFDRjtBQUNGO0FBRThLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2ltcGxlLWJsb2ctc3R5bGVkLXRlbXBsYXRlLWZvci1oZWFkbGVzcy1jbXMvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QveHN0YXRlLmRldmVsb3BtZW50LmVzbS5qcz80Y2Q0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGNyZWF0ZUVtcHR5QWN0b3IsIGZyb21DYWxsYmFjaywgZnJvbUV2ZW50T2JzZXJ2YWJsZSwgZnJvbU9ic2VydmFibGUsIGZyb21Qcm9taXNlLCBmcm9tVHJhbnNpdGlvbiB9IGZyb20gJy4uL2FjdG9ycy9kaXN0L3hzdGF0ZS1hY3RvcnMuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCB7IHQgYXMgdG9BcnJheSwgUyBhcyBTVEFURV9ERUxJTUlURVIsIG0gYXMgbWFwVmFsdWVzLCBmIGFzIGZvcm1hdFRyYW5zaXRpb25zLCBhIGFzIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5LCBiIGFzIGZvcm1hdFRyYW5zaXRpb24sIE4gYXMgTlVMTF9FVkVOVCwgZSBhcyBldmFsdWF0ZUd1YXJkLCBjIGFzIGNyZWF0ZUludm9rZUlkLCBnIGFzIGdldERlbGF5ZWRUcmFuc2l0aW9ucywgZCBhcyBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbiwgaCBhcyBnZXRDYW5kaWRhdGVzLCByIGFzIHJlc29sdmVTdGF0ZVZhbHVlLCBpIGFzIGdldEFsbFN0YXRlTm9kZXMsIGogYXMgZ2V0U3RhdGVOb2RlcywgayBhcyBjcmVhdGVNYWNoaW5lU25hcHNob3QsIGwgYXMgaXNJbkZpbmFsU3RhdGUsIG4gYXMgbWFjcm9zdGVwLCBvIGFzIHRyYW5zaXRpb25Ob2RlLCBwIGFzIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dCwgcSBhcyBjcmVhdGVJbml0RXZlbnQsIHMgYXMgbWljcm9zdGVwLCB1IGFzIGdldEluaXRpYWxTdGF0ZU5vZGVzLCB2IGFzIHRvU3RhdGVQYXRoLCB3IGFzIGlzU3RhdGVJZCwgeCBhcyBnZXRTdGF0ZU5vZGVCeVBhdGgsIHkgYXMgZ2V0UGVyc2lzdGVkU25hcHNob3QsIHogYXMgcmVzb2x2ZVJlZmVyZW5jZWRBY3RvciwgQSBhcyBjcmVhdGVBY3RvciwgJCBhcyAkJEFDVE9SX1RZUEUgfSBmcm9tICcuL3JhaXNlLTFkYjI3YTgyLmRldmVsb3BtZW50LmVzbS5qcyc7XG5leHBvcnQgeyBCIGFzIEFjdG9yLCBJIGFzIF9fdW5zYWZlX2dldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMsIEQgYXMgYW5kLCBNIGFzIGNhbmNlbCwgQSBhcyBjcmVhdGVBY3RvciwgaiBhcyBnZXRTdGF0ZU5vZGVzLCBDIGFzIGludGVycHJldCwgSCBhcyBpc01hY2hpbmVTbmFwc2hvdCwgSiBhcyBtYXRjaGVzU3RhdGUsIEUgYXMgbm90LCBGIGFzIG9yLCBLIGFzIHBhdGhUb1N0YXRlVmFsdWUsIE8gYXMgcmFpc2UsIFAgYXMgc3Bhd25DaGlsZCwgRyBhcyBzdGF0ZUluLCBRIGFzIHN0b3AsIFIgYXMgc3RvcENoaWxkLCBMIGFzIHRvT2JzZXJ2ZXIgfSBmcm9tICcuL3JhaXNlLTFkYjI3YTgyLmRldmVsb3BtZW50LmVzbS5qcyc7XG5pbXBvcnQgeyBhIGFzIGFzc2lnbiB9IGZyb20gJy4vbG9nLTBhY2Q5MDY5LmRldmVsb3BtZW50LmVzbS5qcyc7XG5leHBvcnQgeyBTIGFzIFNwZWNpYWxUYXJnZXRzLCBhIGFzIGFzc2lnbiwgZSBhcyBlbWl0LCBiIGFzIGVucXVldWVBY3Rpb25zLCBmIGFzIGZvcndhcmRUbywgbCBhcyBsb2csIHMgYXMgc2VuZFBhcmVudCwgYyBhcyBzZW5kVG8gfSBmcm9tICcuL2xvZy0wYWNkOTA2OS5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0ICcuLi9kZXYvZGlzdC94c3RhdGUtZGV2LmRldmVsb3BtZW50LmVzbS5qcyc7XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBldmVudCBvYmplY3QgaXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9yIHR5cGVzLiBUaHJvd3NcbiAqIGFuIGVycm9yIGlmIHRoZSBldmVudCBvYmplY3QgaXMgbm90IG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogLy8gLi4uXG4gKiBlbnRyeTogKHsgZXZlbnQgfSkgPT4ge1xuICogICBhc3NlcnRFdmVudChldmVudCwgJ2RvTm90aGluZycpO1xuICogICAvLyBldmVudCBpcyB7IHR5cGU6ICdkb05vdGhpbmcnIH1cbiAqIH0sXG4gKiAvLyAuLi5cbiAqIGV4aXQ6ICh7IGV2ZW50IH0pID0+IHtcbiAqICAgYXNzZXJ0RXZlbnQoZXZlbnQsICdncmVldCcpO1xuICogICAvLyBldmVudCBpcyB7IHR5cGU6ICdncmVldCc7IG1lc3NhZ2U6IHN0cmluZyB9XG4gKlxuICogICBhc3NlcnRFdmVudChldmVudCwgWydncmVldCcsICdub3RpZnknXSk7XG4gKiAgIC8vIGV2ZW50IGlzIHsgdHlwZTogJ2dyZWV0JzsgbWVzc2FnZTogc3RyaW5nIH1cbiAqICAgLy8gb3IgeyB0eXBlOiAnbm90aWZ5JzsgbWVzc2FnZTogc3RyaW5nOyBsZXZlbDogJ2luZm8nIHwgJ2Vycm9yJyB9XG4gKiB9LFxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV2ZW50KGV2ZW50LCB0eXBlKSB7XG4gIGNvbnN0IHR5cGVzID0gdG9BcnJheSh0eXBlKTtcbiAgaWYgKCF0eXBlcy5pbmNsdWRlcyhldmVudC50eXBlKSkge1xuICAgIGNvbnN0IHR5cGVzVGV4dCA9IHR5cGVzLmxlbmd0aCA9PT0gMSA/IGB0eXBlIFwiJHt0eXBlc1swXX1cImAgOiBgb25lIG9mIHR5cGVzIFwiJHt0eXBlcy5qb2luKCdcIiwgXCInKX1cImA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBldmVudCAke0pTT04uc3RyaW5naWZ5KGV2ZW50KX0gdG8gaGF2ZSAke3R5cGVzVGV4dH1gKTtcbiAgfVxufVxuXG5jb25zdCBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBtZW1vKG9iamVjdCwga2V5LCBmbikge1xuICBsZXQgbWVtb2l6ZWREYXRhID0gY2FjaGUuZ2V0KG9iamVjdCk7XG4gIGlmICghbWVtb2l6ZWREYXRhKSB7XG4gICAgbWVtb2l6ZWREYXRhID0ge1xuICAgICAgW2tleV06IGZuKClcbiAgICB9O1xuICAgIGNhY2hlLnNldChvYmplY3QsIG1lbW9pemVkRGF0YSk7XG4gIH0gZWxzZSBpZiAoIShrZXkgaW4gbWVtb2l6ZWREYXRhKSkge1xuICAgIG1lbW9pemVkRGF0YVtrZXldID0gZm4oKTtcbiAgfVxuICByZXR1cm4gbWVtb2l6ZWREYXRhW2tleV07XG59XG5cbmNvbnN0IEVNUFRZX09CSkVDVCA9IHt9O1xuY29uc3QgdG9TZXJpYWxpemFibGVBY3Rpb24gPSBhY3Rpb24gPT4ge1xuICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogYWN0aW9uXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICgncmVzb2x2ZScgaW4gYWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBhY3Rpb24udHlwZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGFjdGlvbi5uYW1lXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWN0aW9uO1xufTtcbmNsYXNzIFN0YXRlTm9kZSB7XG4gIGNvbnN0cnVjdG9yKC8qKiBUaGUgcmF3IGNvbmZpZyB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFjaGluZS4gKi9cbiAgY29uZmlnLCBvcHRpb25zKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgLyoqXG4gICAgICogVGhlIHJlbGF0aXZlIGtleSBvZiB0aGUgc3RhdGUgbm9kZSwgd2hpY2ggcmVwcmVzZW50cyBpdHMgbG9jYXRpb24gaW4gdGhlXG4gICAgICogb3ZlcmFsbCBzdGF0ZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgc3RhdGUgbm9kZTpcbiAgICAgKlxuICAgICAqIC0gYCdhdG9taWMnYCAtIG5vIGNoaWxkIHN0YXRlIG5vZGVzXG4gICAgICogLSBgJ2NvbXBvdW5kJ2AgLSBuZXN0ZWQgY2hpbGQgc3RhdGUgbm9kZXMgKFhPUilcbiAgICAgKiAtIGAncGFyYWxsZWwnYCAtIG9ydGhvZ29uYWwgbmVzdGVkIGNoaWxkIHN0YXRlIG5vZGVzIChBTkQpXG4gICAgICogLSBgJ2hpc3RvcnknYCAtIGhpc3Rvcnkgc3RhdGUgbm9kZVxuICAgICAqIC0gYCdmaW5hbCdgIC0gZmluYWwgc3RhdGUgbm9kZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHN0cmluZyBwYXRoIGZyb20gdGhlIHJvb3QgbWFjaGluZSBub2RlIHRvIHRoaXMgbm9kZS4gKi9cbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBjaGlsZCBzdGF0ZSBub2Rlcy4gKi9cbiAgICB0aGlzLnN0YXRlcyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBoaXN0b3J5IG9uIHRoaXMgc3RhdGUgbm9kZS4gQ2FuIGJlOlxuICAgICAqXG4gICAgICogLSBgJ3NoYWxsb3cnYCAtIHJlY2FsbHMgb25seSB0b3AtbGV2ZWwgaGlzdG9yaWNhbCBzdGF0ZSB2YWx1ZVxuICAgICAqIC0gYCdkZWVwJ2AgLSByZWNhbGxzIGhpc3RvcmljYWwgc3RhdGUgdmFsdWUgYXQgYWxsIGxldmVsc1xuICAgICAqL1xuICAgIHRoaXMuaGlzdG9yeSA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGFjdGlvbihzKSB0byBiZSBleGVjdXRlZCB1cG9uIGVudGVyaW5nIHRoZSBzdGF0ZSBub2RlLiAqL1xuICAgIHRoaXMuZW50cnkgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBhY3Rpb24ocykgdG8gYmUgZXhlY3V0ZWQgdXBvbiBleGl0aW5nIHRoZSBzdGF0ZSBub2RlLiAqL1xuICAgIHRoaXMuZXhpdCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHBhcmVudCBzdGF0ZSBub2RlLiAqL1xuICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgcm9vdCBtYWNoaW5lIG5vZGUuICovXG4gICAgdGhpcy5tYWNoaW5lID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZXRhIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RhdGUgbm9kZSwgd2hpY2ggd2lsbCBiZSByZXR1cm5lZCBpblxuICAgICAqIFN0YXRlIGluc3RhbmNlcy5cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBkYXRhIHNlbnQgd2l0aCB0aGUgXCJ4c3RhdGUuZG9uZS5zdGF0ZS5faWRfXCIgZXZlbnQgaWYgdGhpcyBpcyBhXG4gICAgICogZmluYWwgc3RhdGUgbm9kZS5cbiAgICAgKi9cbiAgICB0aGlzLm91dHB1dCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JkZXIgdGhpcyBzdGF0ZSBub2RlIGFwcGVhcnMuIENvcnJlc3BvbmRzIHRvIHRoZSBpbXBsaWNpdCBkb2N1bWVudFxuICAgICAqIG9yZGVyLlxuICAgICAqL1xuICAgIHRoaXMub3JkZXIgPSAtMTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHdheXMgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLl9wYXJlbnQ7XG4gICAgdGhpcy5rZXkgPSBvcHRpb25zLl9rZXk7XG4gICAgdGhpcy5tYWNoaW5lID0gb3B0aW9ucy5fbWFjaGluZTtcbiAgICB0aGlzLnBhdGggPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBhdGguY29uY2F0KHRoaXMua2V5KSA6IFtdO1xuICAgIHRoaXMuaWQgPSB0aGlzLmNvbmZpZy5pZCB8fCBbdGhpcy5tYWNoaW5lLmlkLCAuLi50aGlzLnBhdGhdLmpvaW4oU1RBVEVfREVMSU1JVEVSKTtcbiAgICB0aGlzLnR5cGUgPSB0aGlzLmNvbmZpZy50eXBlIHx8ICh0aGlzLmNvbmZpZy5zdGF0ZXMgJiYgT2JqZWN0LmtleXModGhpcy5jb25maWcuc3RhdGVzKS5sZW5ndGggPyAnY29tcG91bmQnIDogdGhpcy5jb25maWcuaGlzdG9yeSA/ICdoaXN0b3J5JyA6ICdhdG9taWMnKTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gdGhpcy5jb25maWcuZGVzY3JpcHRpb247XG4gICAgdGhpcy5vcmRlciA9IHRoaXMubWFjaGluZS5pZE1hcC5zaXplO1xuICAgIHRoaXMubWFjaGluZS5pZE1hcC5zZXQodGhpcy5pZCwgdGhpcyk7XG4gICAgdGhpcy5zdGF0ZXMgPSB0aGlzLmNvbmZpZy5zdGF0ZXMgPyBtYXBWYWx1ZXModGhpcy5jb25maWcuc3RhdGVzLCAoc3RhdGVDb25maWcsIGtleSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGVOb2RlID0gbmV3IFN0YXRlTm9kZShzdGF0ZUNvbmZpZywge1xuICAgICAgICBfcGFyZW50OiB0aGlzLFxuICAgICAgICBfa2V5OiBrZXksXG4gICAgICAgIF9tYWNoaW5lOiB0aGlzLm1hY2hpbmVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0YXRlTm9kZTtcbiAgICB9KSA6IEVNUFRZX09CSkVDVDtcbiAgICBpZiAodGhpcy50eXBlID09PSAnY29tcG91bmQnICYmICF0aGlzLmNvbmZpZy5pbml0aWFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGluaXRpYWwgc3RhdGUgc3BlY2lmaWVkIGZvciBjb21wb3VuZCBzdGF0ZSBub2RlIFwiIyR7dGhpcy5pZH1cIi4gVHJ5IGFkZGluZyB7IGluaXRpYWw6IFwiJHtPYmplY3Qua2V5cyh0aGlzLnN0YXRlcylbMF19XCIgfSB0byB0aGUgc3RhdGUgY29uZmlnLmApO1xuICAgIH1cblxuICAgIC8vIEhpc3RvcnkgY29uZmlnXG4gICAgdGhpcy5oaXN0b3J5ID0gdGhpcy5jb25maWcuaGlzdG9yeSA9PT0gdHJ1ZSA/ICdzaGFsbG93JyA6IHRoaXMuY29uZmlnLmhpc3RvcnkgfHwgZmFsc2U7XG4gICAgdGhpcy5lbnRyeSA9IHRvQXJyYXkodGhpcy5jb25maWcuZW50cnkpLnNsaWNlKCk7XG4gICAgdGhpcy5leGl0ID0gdG9BcnJheSh0aGlzLmNvbmZpZy5leGl0KS5zbGljZSgpO1xuICAgIHRoaXMubWV0YSA9IHRoaXMuY29uZmlnLm1ldGE7XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLnR5cGUgPT09ICdmaW5hbCcgfHwgIXRoaXMucGFyZW50ID8gdGhpcy5jb25maWcub3V0cHV0IDogdW5kZWZpbmVkO1xuICAgIHRoaXMudGFncyA9IHRvQXJyYXkoY29uZmlnLnRhZ3MpLnNsaWNlKCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBmb3JtYXRUcmFuc2l0aW9ucyh0aGlzKTtcbiAgICBpZiAodGhpcy5jb25maWcuYWx3YXlzKSB7XG4gICAgICB0aGlzLmFsd2F5cyA9IHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KHRoaXMuY29uZmlnLmFsd2F5cykubWFwKHQgPT4gZm9ybWF0VHJhbnNpdGlvbih0aGlzLCBOVUxMX0VWRU5ULCB0KSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHRoaXMuc3RhdGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICB0aGlzLnN0YXRlc1trZXldLl9pbml0aWFsaXplKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGhlIHdlbGwtc3RydWN0dXJlZCBzdGF0ZSBub2RlIGRlZmluaXRpb24uICovXG4gIGdldCBkZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICB2ZXJzaW9uOiB0aGlzLm1hY2hpbmUudmVyc2lvbixcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGluaXRpYWw6IHRoaXMuaW5pdGlhbCA/IHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmluaXRpYWwudGFyZ2V0LFxuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIGFjdGlvbnM6IHRoaXMuaW5pdGlhbC5hY3Rpb25zLm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbiksXG4gICAgICAgIGV2ZW50VHlwZTogbnVsbCxcbiAgICAgICAgcmVlbnRlcjogZmFsc2UsXG4gICAgICAgIHRvSlNPTjogKCkgPT4gKHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMuaW5pdGlhbC50YXJnZXQubWFwKHQgPT4gYCMke3QuaWR9YCksXG4gICAgICAgICAgc291cmNlOiBgIyR7dGhpcy5pZH1gLFxuICAgICAgICAgIGFjdGlvbnM6IHRoaXMuaW5pdGlhbC5hY3Rpb25zLm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbiksXG4gICAgICAgICAgZXZlbnRUeXBlOiBudWxsXG4gICAgICAgIH0pXG4gICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgc3RhdGVzOiBtYXBWYWx1ZXModGhpcy5zdGF0ZXMsIHN0YXRlID0+IHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmRlZmluaXRpb247XG4gICAgICB9KSxcbiAgICAgIG9uOiB0aGlzLm9uLFxuICAgICAgdHJhbnNpdGlvbnM6IFsuLi50aGlzLnRyYW5zaXRpb25zLnZhbHVlcygpXS5mbGF0KCkubWFwKHQgPT4gKHtcbiAgICAgICAgLi4udCxcbiAgICAgICAgYWN0aW9uczogdC5hY3Rpb25zLm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbilcbiAgICAgIH0pKSxcbiAgICAgIGVudHJ5OiB0aGlzLmVudHJ5Lm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbiksXG4gICAgICBleGl0OiB0aGlzLmV4aXQubWFwKHRvU2VyaWFsaXphYmxlQWN0aW9uKSxcbiAgICAgIG1ldGE6IHRoaXMubWV0YSxcbiAgICAgIG9yZGVyOiB0aGlzLm9yZGVyIHx8IC0xLFxuICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgIGludm9rZTogdGhpcy5pbnZva2UsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIHRhZ3M6IHRoaXMudGFnc1xuICAgIH07XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uO1xuICB9XG5cbiAgLyoqIFRoZSBsb2dpYyBpbnZva2VkIGFzIGFjdG9ycyBieSB0aGlzIHN0YXRlIG5vZGUuICovXG4gIGdldCBpbnZva2UoKSB7XG4gICAgcmV0dXJuIG1lbW8odGhpcywgJ2ludm9rZScsICgpID0+IHRvQXJyYXkodGhpcy5jb25maWcuaW52b2tlKS5tYXAoKGludm9rZUNvbmZpZywgaSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzcmMsXG4gICAgICAgIHN5c3RlbUlkXG4gICAgICB9ID0gaW52b2tlQ29uZmlnO1xuICAgICAgY29uc3QgcmVzb2x2ZWRJZCA9IGludm9rZUNvbmZpZy5pZCA/PyBjcmVhdGVJbnZva2VJZCh0aGlzLmlkLCBpKTtcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHNyYyA6IGB4c3RhdGUuaW52b2tlLiR7Y3JlYXRlSW52b2tlSWQodGhpcy5pZCwgaSl9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmludm9rZUNvbmZpZyxcbiAgICAgICAgc3JjOiBzb3VyY2VOYW1lLFxuICAgICAgICBpZDogcmVzb2x2ZWRJZCxcbiAgICAgICAgc3lzdGVtSWQ6IHN5c3RlbUlkLFxuICAgICAgICB0b0pTT04oKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb25Eb25lLFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIC4uLmludm9rZURlZlZhbHVlc1xuICAgICAgICAgIH0gPSBpbnZva2VDb25maWc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmludm9rZURlZlZhbHVlcyxcbiAgICAgICAgICAgIHR5cGU6ICd4c3RhdGUuaW52b2tlJyxcbiAgICAgICAgICAgIHNyYzogc291cmNlTmFtZSxcbiAgICAgICAgICAgIGlkOiByZXNvbHZlZElkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSk7XG4gIH1cblxuICAvKiogVGhlIG1hcHBpbmcgb2YgZXZlbnRzIHRvIHRyYW5zaXRpb25zLiAqL1xuICBnZXQgb24oKSB7XG4gICAgcmV0dXJuIG1lbW8odGhpcywgJ29uJywgKCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb25zO1xuICAgICAgcmV0dXJuIFsuLi50cmFuc2l0aW9uc10uZmxhdE1hcCgoW2Rlc2NyaXB0b3IsIHRdKSA9PiB0Lm1hcCh0ID0+IFtkZXNjcmlwdG9yLCB0XSkpLnJlZHVjZSgobWFwLCBbZGVzY3JpcHRvciwgdHJhbnNpdGlvbl0pID0+IHtcbiAgICAgICAgbWFwW2Rlc2NyaXB0b3JdID0gbWFwW2Rlc2NyaXB0b3JdIHx8IFtdO1xuICAgICAgICBtYXBbZGVzY3JpcHRvcl0ucHVzaCh0cmFuc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH0sIHt9KTtcbiAgICB9KTtcbiAgfVxuICBnZXQgYWZ0ZXIoKSB7XG4gICAgcmV0dXJuIG1lbW8odGhpcywgJ2RlbGF5ZWRUcmFuc2l0aW9ucycsICgpID0+IGdldERlbGF5ZWRUcmFuc2l0aW9ucyh0aGlzKSk7XG4gIH1cbiAgZ2V0IGluaXRpYWwoKSB7XG4gICAgcmV0dXJuIG1lbW8odGhpcywgJ2luaXRpYWwnLCAoKSA9PiBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbih0aGlzLCB0aGlzLmNvbmZpZy5pbml0aWFsKSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIG5leHQoc25hcHNob3QsIGV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gZXZlbnQudHlwZTtcbiAgICBjb25zdCBhY3Rpb25zID0gW107XG4gICAgbGV0IHNlbGVjdGVkVHJhbnNpdGlvbjtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gbWVtbyh0aGlzLCBgY2FuZGlkYXRlcy0ke2V2ZW50VHlwZX1gLCAoKSA9PiBnZXRDYW5kaWRhdGVzKHRoaXMsIGV2ZW50VHlwZSkpO1xuICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZ3VhcmRcbiAgICAgIH0gPSBjYW5kaWRhdGU7XG4gICAgICBjb25zdCByZXNvbHZlZENvbnRleHQgPSBzbmFwc2hvdC5jb250ZXh0O1xuICAgICAgbGV0IGd1YXJkUGFzc2VkID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBndWFyZFBhc3NlZCA9ICFndWFyZCB8fCBldmFsdWF0ZUd1YXJkKGd1YXJkLCByZXNvbHZlZENvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZ3VhcmRUeXBlID0gdHlwZW9mIGd1YXJkID09PSAnc3RyaW5nJyA/IGd1YXJkIDogdHlwZW9mIGd1YXJkID09PSAnb2JqZWN0JyA/IGd1YXJkLnR5cGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGV2YWx1YXRlIGd1YXJkICR7Z3VhcmRUeXBlID8gYCcke2d1YXJkVHlwZX0nIGAgOiAnJ31pbiB0cmFuc2l0aW9uIGZvciBldmVudCAnJHtldmVudFR5cGV9JyBpbiBzdGF0ZSBub2RlICcke3RoaXMuaWR9JzpcXG4ke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkUGFzc2VkKSB7XG4gICAgICAgIGFjdGlvbnMucHVzaCguLi5jYW5kaWRhdGUuYWN0aW9ucyk7XG4gICAgICAgIHNlbGVjdGVkVHJhbnNpdGlvbiA9IGNhbmRpZGF0ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFRyYW5zaXRpb24gPyBbc2VsZWN0ZWRUcmFuc2l0aW9uXSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKiBBbGwgdGhlIGV2ZW50IHR5cGVzIGFjY2VwdGVkIGJ5IHRoaXMgc3RhdGUgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzLiAqL1xuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdldmVudHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXRlc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBldmVudHMgPSBuZXcgU2V0KHRoaXMub3duRXZlbnRzKTtcbiAgICAgIGlmIChzdGF0ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdGF0ZUlkIG9mIE9iamVjdC5rZXlzKHN0YXRlcykpIHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlc1tzdGF0ZUlkXTtcbiAgICAgICAgICBpZiAoc3RhdGUuc3RhdGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHN0YXRlLmV2ZW50cykge1xuICAgICAgICAgICAgICBldmVudHMuYWRkKGAke2V2ZW50fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGwgdGhlIGV2ZW50cyB0aGF0IGhhdmUgdHJhbnNpdGlvbnMgZGlyZWN0bHkgZnJvbSB0aGlzIHN0YXRlIG5vZGUuXG4gICAqXG4gICAqIEV4Y2x1ZGVzIGFueSBpbmVydCBldmVudHMuXG4gICAqL1xuICBnZXQgb3duRXZlbnRzKCkge1xuICAgIGNvbnN0IGV2ZW50cyA9IG5ldyBTZXQoWy4uLnRoaXMudHJhbnNpdGlvbnMua2V5cygpXS5maWx0ZXIoZGVzY3JpcHRvciA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5nZXQoZGVzY3JpcHRvcikuc29tZSh0cmFuc2l0aW9uID0+ICEoIXRyYW5zaXRpb24udGFyZ2V0ICYmICF0cmFuc2l0aW9uLmFjdGlvbnMubGVuZ3RoICYmICF0cmFuc2l0aW9uLnJlZW50ZXIpKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnRzKTtcbiAgfVxufVxuXG5jb25zdCBTVEFURV9JREVOVElGSUVSID0gJyMnO1xuY2xhc3MgU3RhdGVNYWNoaW5lIHtcbiAgY29uc3RydWN0b3IoLyoqIFRoZSByYXcgY29uZmlnIHVzZWQgdG8gY3JlYXRlIHRoZSBtYWNoaW5lLiAqL1xuICBjb25maWcsIGltcGxlbWVudGF0aW9ucykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIC8qKiBUaGUgbWFjaGluZSdzIG93biB2ZXJzaW9uLiAqL1xuICAgIHRoaXMudmVyc2lvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnNjaGVtYXMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbXBsZW1lbnRhdGlvbnMgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX194c3RhdGVub2RlID0gdHJ1ZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5pZE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJvb3QgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmV2ZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gY29uZmlnLmlkIHx8ICcobWFjaGluZSknO1xuICAgIHRoaXMuaW1wbGVtZW50YXRpb25zID0ge1xuICAgICAgYWN0b3JzOiBpbXBsZW1lbnRhdGlvbnM/LmFjdG9ycyA/PyB7fSxcbiAgICAgIGFjdGlvbnM6IGltcGxlbWVudGF0aW9ucz8uYWN0aW9ucyA/PyB7fSxcbiAgICAgIGRlbGF5czogaW1wbGVtZW50YXRpb25zPy5kZWxheXMgPz8ge30sXG4gICAgICBndWFyZHM6IGltcGxlbWVudGF0aW9ucz8uZ3VhcmRzID8/IHt9XG4gICAgfTtcbiAgICB0aGlzLnZlcnNpb24gPSB0aGlzLmNvbmZpZy52ZXJzaW9uO1xuICAgIHRoaXMuc2NoZW1hcyA9IHRoaXMuY29uZmlnLnNjaGVtYXM7XG4gICAgdGhpcy50cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRJbml0aWFsU25hcHNob3QgPSB0aGlzLmdldEluaXRpYWxTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0UGVyc2lzdGVkU25hcHNob3QgPSB0aGlzLmdldFBlcnNpc3RlZFNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZXN0b3JlU25hcHNob3QgPSB0aGlzLnJlc3RvcmVTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5yb290ID0gbmV3IFN0YXRlTm9kZShjb25maWcsIHtcbiAgICAgIF9rZXk6IHRoaXMuaWQsXG4gICAgICBfbWFjaGluZTogdGhpc1xuICAgIH0pO1xuICAgIHRoaXMucm9vdC5faW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMuc3RhdGVzID0gdGhpcy5yb290LnN0YXRlczsgLy8gVE9ETzogcmVtb3ZlIVxuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5yb290LmV2ZW50cztcbiAgICBpZiAoISgnb3V0cHV0JyBpbiB0aGlzLnJvb3QpICYmIE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZXMpLnNvbWUoc3RhdGUgPT4gc3RhdGUudHlwZSA9PT0gJ2ZpbmFsJyAmJiAnb3V0cHV0JyBpbiBzdGF0ZSkpIHtcbiAgICAgIGNvbnNvbGUud2FybignTWlzc2luZyBgbWFjaGluZS5vdXRwdXRgIGRlY2xhcmF0aW9uICh0b3AtbGV2ZWwgZmluYWwgc3RhdGUgd2l0aCBvdXRwdXQgZGV0ZWN0ZWQpJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGlzIHN0YXRlIG1hY2hpbmUgd2l0aCB0aGUgcHJvdmlkZWQgaW1wbGVtZW50YXRpb25zIGFuZCBtZXJnZXMgdGhlXG4gICAqIGBjb250ZXh0YCAoaWYgcHJvdmlkZWQpLlxuICAgKlxuICAgKiBAcGFyYW0gaW1wbGVtZW50YXRpb25zIE9wdGlvbnMgKGBhY3Rpb25zYCwgYGd1YXJkc2AsIGBhY3RvcnNgLCBgZGVsYXlzYCxcbiAgICogICBgY29udGV4dGApIHRvIHJlY3Vyc2l2ZWx5IG1lcmdlIHdpdGggdGhlIGV4aXN0aW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIEEgbmV3IGBTdGF0ZU1hY2hpbmVgIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGltcGxlbWVudGF0aW9ucy5cbiAgICovXG4gIHByb3ZpZGUoaW1wbGVtZW50YXRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWN0aW9ucyxcbiAgICAgIGd1YXJkcyxcbiAgICAgIGFjdG9ycyxcbiAgICAgIGRlbGF5c1xuICAgIH0gPSB0aGlzLmltcGxlbWVudGF0aW9ucztcbiAgICByZXR1cm4gbmV3IFN0YXRlTWFjaGluZSh0aGlzLmNvbmZpZywge1xuICAgICAgYWN0aW9uczoge1xuICAgICAgICAuLi5hY3Rpb25zLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuYWN0aW9uc1xuICAgICAgfSxcbiAgICAgIGd1YXJkczoge1xuICAgICAgICAuLi5ndWFyZHMsXG4gICAgICAgIC4uLmltcGxlbWVudGF0aW9ucy5ndWFyZHNcbiAgICAgIH0sXG4gICAgICBhY3RvcnM6IHtcbiAgICAgICAgLi4uYWN0b3JzLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuYWN0b3JzXG4gICAgICB9LFxuICAgICAgZGVsYXlzOiB7XG4gICAgICAgIC4uLmRlbGF5cyxcbiAgICAgICAgLi4uaW1wbGVtZW50YXRpb25zLmRlbGF5c1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc29sdmVTdGF0ZShjb25maWcpIHtcbiAgICBjb25zdCByZXNvbHZlZFN0YXRlVmFsdWUgPSByZXNvbHZlU3RhdGVWYWx1ZSh0aGlzLnJvb3QsIGNvbmZpZy52YWx1ZSk7XG4gICAgY29uc3Qgbm9kZVNldCA9IGdldEFsbFN0YXRlTm9kZXMoZ2V0U3RhdGVOb2Rlcyh0aGlzLnJvb3QsIHJlc29sdmVkU3RhdGVWYWx1ZSkpO1xuICAgIHJldHVybiBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgX25vZGVzOiBbLi4ubm9kZVNldF0sXG4gICAgICBjb250ZXh0OiBjb25maWcuY29udGV4dCB8fCB7fSxcbiAgICAgIGNoaWxkcmVuOiB7fSxcbiAgICAgIHN0YXR1czogaXNJbkZpbmFsU3RhdGUobm9kZVNldCwgdGhpcy5yb290KSA/ICdkb25lJyA6IGNvbmZpZy5zdGF0dXMgfHwgJ2FjdGl2ZScsXG4gICAgICBvdXRwdXQ6IGNvbmZpZy5vdXRwdXQsXG4gICAgICBlcnJvcjogY29uZmlnLmVycm9yLFxuICAgICAgaGlzdG9yeVZhbHVlOiBjb25maWcuaGlzdG9yeVZhbHVlXG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgbmV4dCBzbmFwc2hvdCBnaXZlbiB0aGUgY3VycmVudCBgc25hcHNob3RgIGFuZCByZWNlaXZlZFxuICAgKiBgZXZlbnRgLiBDYWxjdWxhdGVzIGEgZnVsbCBtYWNyb3N0ZXAgZnJvbSBhbGwgbWljcm9zdGVwcy5cbiAgICpcbiAgICogQHBhcmFtIHNuYXBzaG90IFRoZSBjdXJyZW50IHNuYXBzaG90XG4gICAqIEBwYXJhbSBldmVudCBUaGUgcmVjZWl2ZWQgZXZlbnRcbiAgICovXG4gIHRyYW5zaXRpb24oc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gICAgcmV0dXJuIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIFtdKS5zbmFwc2hvdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBuZXh0IHN0YXRlIGdpdmVuIHRoZSBjdXJyZW50IGBzdGF0ZWAgYW5kIGBldmVudGAuIENhbGN1bGF0ZXNcbiAgICogYSBtaWNyb3N0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgY3VycmVudCBzdGF0ZVxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIHJlY2VpdmVkIGV2ZW50XG4gICAqL1xuICBtaWNyb3N0ZXAoc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gICAgcmV0dXJuIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIFtdKS5taWNyb3N0YXRlcztcbiAgfVxuICBnZXRUcmFuc2l0aW9uRGF0YShzbmFwc2hvdCwgZXZlbnQpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk5vZGUodGhpcy5yb290LCBzbmFwc2hvdC52YWx1ZSwgc25hcHNob3QsIGV2ZW50KSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBzdGF0ZSBfYmVmb3JlXyBldmFsdWF0aW5nIGFueSBtaWNyb3N0ZXBzLiBUaGlzIFwicHJlLWluaXRpYWxcIlxuICAgKiBzdGF0ZSBpcyBwcm92aWRlZCB0byBpbml0aWFsIGFjdGlvbnMgZXhlY3V0ZWQgaW4gdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBnZXRQcmVJbml0aWFsU3RhdGUoYWN0b3JTY29wZSwgaW5pdEV2ZW50LCBpbnRlcm5hbFF1ZXVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dFxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBwcmVJbml0aWFsID0gY3JlYXRlTWFjaGluZVNuYXBzaG90KHtcbiAgICAgIGNvbnRleHQ6IHR5cGVvZiBjb250ZXh0ICE9PSAnZnVuY3Rpb24nICYmIGNvbnRleHQgPyBjb250ZXh0IDoge30sXG4gICAgICBfbm9kZXM6IFt0aGlzLnJvb3RdLFxuICAgICAgY2hpbGRyZW46IHt9LFxuICAgICAgc3RhdHVzOiAnYWN0aXZlJ1xuICAgIH0sIHRoaXMpO1xuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgYXNzaWdubWVudCA9ICh7XG4gICAgICAgIHNwYXduLFxuICAgICAgICBldmVudCxcbiAgICAgICAgc2VsZlxuICAgICAgfSkgPT4gY29udGV4dCh7XG4gICAgICAgIHNwYXduLFxuICAgICAgICBpbnB1dDogZXZlbnQuaW5wdXQsXG4gICAgICAgIHNlbGZcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChwcmVJbml0aWFsLCBpbml0RXZlbnQsIGFjdG9yU2NvcGUsIFthc3NpZ24oYXNzaWdubWVudCldLCBpbnRlcm5hbFF1ZXVlLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlSW5pdGlhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIGBTdGF0ZWAgaW5zdGFuY2UsIHdpdGggcmVmZXJlbmNlIHRvIGBzZWxmYCBhcyBhblxuICAgKiBgQWN0b3JSZWZgLlxuICAgKi9cbiAgZ2V0SW5pdGlhbFNuYXBzaG90KGFjdG9yU2NvcGUsIGlucHV0KSB7XG4gICAgY29uc3QgaW5pdEV2ZW50ID0gY3JlYXRlSW5pdEV2ZW50KGlucHV0KTsgLy8gVE9ETzogZml4O1xuICAgIGNvbnN0IGludGVybmFsUXVldWUgPSBbXTtcbiAgICBjb25zdCBwcmVJbml0aWFsU3RhdGUgPSB0aGlzLmdldFByZUluaXRpYWxTdGF0ZShhY3RvclNjb3BlLCBpbml0RXZlbnQsIGludGVybmFsUXVldWUpO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IG1pY3Jvc3RlcChbe1xuICAgICAgdGFyZ2V0OiBbLi4uZ2V0SW5pdGlhbFN0YXRlTm9kZXModGhpcy5yb290KV0sXG4gICAgICBzb3VyY2U6IHRoaXMucm9vdCxcbiAgICAgIHJlZW50ZXI6IHRydWUsXG4gICAgICBhY3Rpb25zOiBbXSxcbiAgICAgIGV2ZW50VHlwZTogbnVsbCxcbiAgICAgIHRvSlNPTjogbnVsbCAvLyBUT0RPOiBmaXhcbiAgICB9XSwgcHJlSW5pdGlhbFN0YXRlLCBhY3RvclNjb3BlLCBpbml0RXZlbnQsIHRydWUsIGludGVybmFsUXVldWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNuYXBzaG90OiBtYWNyb1N0YXRlXG4gICAgfSA9IG1hY3Jvc3RlcChuZXh0U3RhdGUsIGluaXRFdmVudCwgYWN0b3JTY29wZSwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgcmV0dXJuIG1hY3JvU3RhdGU7XG4gIH1cbiAgc3RhcnQoc25hcHNob3QpIHtcbiAgICBPYmplY3QudmFsdWVzKHNuYXBzaG90LmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmIChjaGlsZC5nZXRTbmFwc2hvdCgpLnN0YXR1cyA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgY2hpbGQuc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZU5vZGVCeUlkKHN0YXRlSWQpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlSWQpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGZ1bGxQYXRoLnNsaWNlKDEpO1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVJZCA9IGlzU3RhdGVJZChmdWxsUGF0aFswXSkgPyBmdWxsUGF0aFswXS5zbGljZShTVEFURV9JREVOVElGSUVSLmxlbmd0aCkgOiBmdWxsUGF0aFswXTtcbiAgICBjb25zdCBzdGF0ZU5vZGUgPSB0aGlzLmlkTWFwLmdldChyZXNvbHZlZFN0YXRlSWQpO1xuICAgIGlmICghc3RhdGVOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlIG5vZGUgJyMke3Jlc29sdmVkU3RhdGVJZH0nIGRvZXMgbm90IGV4aXN0IG9uIG1hY2hpbmUgJyR7dGhpcy5pZH0nYCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCByZWxhdGl2ZVBhdGgpO1xuICB9XG4gIGdldCBkZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QuZGVmaW5pdGlvbjtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbjtcbiAgfVxuICBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucyk7XG4gIH1cbiAgcmVzdG9yZVNuYXBzaG90KHNuYXBzaG90LCBfYWN0b3JTY29wZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0ge307XG4gICAgY29uc3Qgc25hcHNob3RDaGlsZHJlbiA9IHNuYXBzaG90LmNoaWxkcmVuO1xuICAgIE9iamVjdC5rZXlzKHNuYXBzaG90Q2hpbGRyZW4pLmZvckVhY2goYWN0b3JJZCA9PiB7XG4gICAgICBjb25zdCBhY3RvckRhdGEgPSBzbmFwc2hvdENoaWxkcmVuW2FjdG9ySWRdO1xuICAgICAgY29uc3QgY2hpbGRTdGF0ZSA9IGFjdG9yRGF0YS5zbmFwc2hvdDtcbiAgICAgIGNvbnN0IHNyYyA9IGFjdG9yRGF0YS5zcmM7XG4gICAgICBjb25zdCBsb2dpYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gcmVzb2x2ZVJlZmVyZW5jZWRBY3Rvcih0aGlzLCBzcmMpIDogc3JjO1xuICAgICAgaWYgKCFsb2dpYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RvclJlZiA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7XG4gICAgICAgIGlkOiBhY3RvcklkLFxuICAgICAgICBwYXJlbnQ6IF9hY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogYWN0b3JEYXRhLnN5bmNTbmFwc2hvdCxcbiAgICAgICAgc25hcHNob3Q6IGNoaWxkU3RhdGUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWQ6IGFjdG9yRGF0YS5zeXN0ZW1JZFxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlblthY3RvcklkXSA9IGFjdG9yUmVmO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3RvcmVkU25hcHNob3QgPSBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIF9ub2RlczogQXJyYXkuZnJvbShnZXRBbGxTdGF0ZU5vZGVzKGdldFN0YXRlTm9kZXModGhpcy5yb290LCBzbmFwc2hvdC52YWx1ZSkpKVxuICAgIH0sIHRoaXMpO1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gcmV2aXZlQ29udGV4dChjb250ZXh0UGFydCwgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChzZWVuLmhhcyhjb250ZXh0UGFydCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2Vlbi5hZGQoY29udGV4dFBhcnQpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dFBhcnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0UGFydFtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICgneHN0YXRlJCR0eXBlJyBpbiB2YWx1ZSAmJiB2YWx1ZS54c3RhdGUkJHR5cGUgPT09ICQkQUNUT1JfVFlQRSkge1xuICAgICAgICAgICAgY29udGV4dFBhcnRba2V5XSA9IGNoaWxkcmVuW3ZhbHVlLmlkXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXZpdmVDb250ZXh0KHZhbHVlLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV2aXZlQ29udGV4dChyZXN0b3JlZFNuYXBzaG90LmNvbnRleHQsIGNoaWxkcmVuKTtcbiAgICByZXR1cm4gcmVzdG9yZWRTbmFwc2hvdDtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGF0ZSBtYWNoaW5lIChzdGF0ZWNoYXJ0KSB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoZSBzdGF0ZSBtYWNoaW5lIHJlcHJlc2VudHMgdGhlIHB1cmUgbG9naWMgb2YgYSBzdGF0ZSBtYWNoaW5lIGFjdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IGxpZ2h0TWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICBpZDogJ2xpZ2h0JyxcbiAqICAgaW5pdGlhbDogJ2dyZWVuJyxcbiAqICAgc3RhdGVzOiB7XG4gKiAgICAgZ3JlZW46IHtcbiAqICAgICAgIG9uOiB7XG4gKiAgICAgICAgIFRJTUVSOiB7IHRhcmdldDogJ3llbGxvdycgfVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAgeWVsbG93OiB7XG4gKiAgICAgICBvbjoge1xuICogICAgICAgICBUSU1FUjogeyB0YXJnZXQ6ICdyZWQnIH1cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHJlZDoge1xuICogICAgICAgb246IHtcbiAqICAgICAgICAgVElNRVI6IHsgdGFyZ2V0OiAnZ3JlZW4nIH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGNvbnN0IGxpZ2h0QWN0b3IgPSBjcmVhdGVBY3RvcihsaWdodE1hY2hpbmUpO1xuICogbGlnaHRBY3Rvci5zdGFydCgpO1xuICpcbiAqIGxpZ2h0QWN0b3Iuc2VuZCh7IHR5cGU6ICdUSU1FUicgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY29uZmlnIFRoZSBzdGF0ZSBtYWNoaW5lIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0gb3B0aW9ucyBERVBSRUNBVEVEOiB1c2UgYHNldHVwKHsgLi4uIH0pYCBvciBgbWFjaGluZS5wcm92aWRlKHsgLi4uIH0pYFxuICogICB0byBwcm92aWRlIG1hY2hpbmUgaW1wbGVtZW50YXRpb25zIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hY2hpbmUoY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTdGF0ZU1hY2hpbmUoY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBjcmVhdGVJbmVydEFjdG9yU2NvcGUoYWN0b3JMb2dpYykge1xuICBjb25zdCBzZWxmID0gY3JlYXRlQWN0b3IoYWN0b3JMb2dpYyk7XG4gIGNvbnN0IGluZXJ0QWN0b3JTY29wZSA9IHtcbiAgICBzZWxmLFxuICAgIGRlZmVyOiAoKSA9PiB7fSxcbiAgICBpZDogJycsXG4gICAgbG9nZ2VyOiAoKSA9PiB7fSxcbiAgICBzZXNzaW9uSWQ6ICcnLFxuICAgIHN0b3BDaGlsZDogKCkgPT4ge30sXG4gICAgc3lzdGVtOiBzZWxmLnN5c3RlbSxcbiAgICBlbWl0OiAoKSA9PiB7fSxcbiAgICBhY3Rpb25FeGVjdXRvcjogKCkgPT4ge31cbiAgfTtcbiAgcmV0dXJuIGluZXJ0QWN0b3JTY29wZTtcbn1cblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgaW5pdGlhbFRyYW5zaXRpb24o4oCmKWAgaW5zdGVhZC4gKi9cbmZ1bmN0aW9uIGdldEluaXRpYWxTbmFwc2hvdChhY3RvckxvZ2ljLCAuLi5baW5wdXRdKSB7XG4gIGNvbnN0IGFjdG9yU2NvcGUgPSBjcmVhdGVJbmVydEFjdG9yU2NvcGUoYWN0b3JMb2dpYyk7XG4gIHJldHVybiBhY3RvckxvZ2ljLmdldEluaXRpYWxTbmFwc2hvdChhY3RvclNjb3BlLCBpbnB1dCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbmV4dCBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIGBhY3RvckxvZ2ljYCBiYXNlZCBvbiB0aGUgZ2l2ZW5cbiAqIGBzbmFwc2hvdGAgYW5kIGBldmVudGAuXG4gKlxuICogSWYgdGhlIGBzbmFwc2hvdGAgaXMgYHVuZGVmaW5lZGAsIHRoZSBpbml0aWFsIHNuYXBzaG90IG9mIHRoZSBgYWN0b3JMb2dpY2AgaXNcbiAqIHVzZWQuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB0cmFuc2l0aW9uKOKApilgIGluc3RlYWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBnZXROZXh0U25hcHNob3QgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgdHJhZmZpY0xpZ2h0TWFjaGluZSB9IGZyb20gJy4vdHJhZmZpY0xpZ2h0TWFjaGluZS50cyc7XG4gKlxuICogY29uc3QgbmV4dFNuYXBzaG90ID0gZ2V0TmV4dFNuYXBzaG90KFxuICogICB0cmFmZmljTGlnaHRNYWNoaW5lLCAvLyBhY3RvciBsb2dpY1xuICogICB1bmRlZmluZWQsIC8vIHNuYXBzaG90IChvciBpbml0aWFsIHN0YXRlIGlmIHVuZGVmaW5lZClcbiAqICAgeyB0eXBlOiAnVElNRVInIH1cbiAqICk7IC8vIGV2ZW50IG9iamVjdFxuICpcbiAqIGNvbnNvbGUubG9nKG5leHRTbmFwc2hvdC52YWx1ZSk7XG4gKiAvLyA9PiAneWVsbG93J1xuICpcbiAqIGNvbnN0IG5leHRTbmFwc2hvdDIgPSBnZXROZXh0U25hcHNob3QoXG4gKiAgIHRyYWZmaWNMaWdodE1hY2hpbmUsIC8vIGFjdG9yIGxvZ2ljXG4gKiAgIG5leHRTbmFwc2hvdCwgLy8gc25hcHNob3RcbiAqICAgeyB0eXBlOiAnVElNRVInIH1cbiAqICk7IC8vIGV2ZW50IG9iamVjdFxuICpcbiAqIGNvbnNvbGUubG9nKG5leHRTbmFwc2hvdDIudmFsdWUpO1xuICogLy8gPT4ncmVkJ1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldE5leHRTbmFwc2hvdChhY3RvckxvZ2ljLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgY29uc3QgaW5lcnRBY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGFjdG9yTG9naWMpO1xuICBpbmVydEFjdG9yU2NvcGUuc2VsZi5fc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgcmV0dXJuIGFjdG9yTG9naWMudHJhbnNpdGlvbihzbmFwc2hvdCwgZXZlbnQsIGluZXJ0QWN0b3JTY29wZSk7XG59XG5cbi8vIGF0IHRoZSBtb21lbnQgd2UgYWxsb3cgZXh0cmEgYWN0b3JzIC0gb25lcyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIGJ5IGBjaGlsZHJlbmBcbi8vIHRoaXMgY291bGQgYmUgcmVjb25zaWRlcmVkIGluIHRoZSBmdXR1cmVcblxuZnVuY3Rpb24gc2V0dXAoe1xuICBzY2hlbWFzLFxuICBhY3RvcnMsXG4gIGFjdGlvbnMsXG4gIGd1YXJkcyxcbiAgZGVsYXlzXG59KSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlTWFjaGluZTogY29uZmlnID0+IGNyZWF0ZU1hY2hpbmUoe1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgc2NoZW1hc1xuICAgIH0sIHtcbiAgICAgIGFjdG9ycyxcbiAgICAgIGFjdGlvbnMsXG4gICAgICBndWFyZHMsXG4gICAgICBkZWxheXNcbiAgICB9KVxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1kZWNsYXJhdGlvbi1tZXJnaW5nXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcbmNsYXNzIFNpbXVsYXRlZENsb2NrIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50aW1lb3V0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub3cgPSAwO1xuICAgIHRoaXMuX2lkID0gMDtcbiAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgfVxuICBub3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vdztcbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQrKztcbiAgfVxuICBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0KSB7XG4gICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRoaXMuX2ZsdXNoaW5nO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZCgpO1xuICAgIHRoaXMudGltZW91dHMuc2V0KGlkLCB7XG4gICAgICBzdGFydDogdGhpcy5ub3coKSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBmblxuICAgIH0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBjbGVhclRpbWVvdXQoaWQpIHtcbiAgICB0aGlzLl9mbHVzaGluZ0ludmFsaWRhdGVkID0gdGhpcy5fZmx1c2hpbmc7XG4gICAgdGhpcy50aW1lb3V0cy5kZWxldGUoaWQpO1xuICB9XG4gIHNldCh0aW1lKSB7XG4gICAgaWYgKHRoaXMuX25vdyA+IHRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHRyYXZlbCBiYWNrIGluIHRpbWUnKTtcbiAgICB9XG4gICAgdGhpcy5fbm93ID0gdGltZTtcbiAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgfVxuICBmbHVzaFRpbWVvdXRzKCkge1xuICAgIGlmICh0aGlzLl9mbHVzaGluZykge1xuICAgICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZsdXNoaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4udGhpcy50aW1lb3V0c10uc29ydCgoW19pZEEsIHRpbWVvdXRBXSwgW19pZEIsIHRpbWVvdXRCXSkgPT4ge1xuICAgICAgY29uc3QgZW5kQSA9IHRpbWVvdXRBLnN0YXJ0ICsgdGltZW91dEEudGltZW91dDtcbiAgICAgIGNvbnN0IGVuZEIgPSB0aW1lb3V0Qi5zdGFydCArIHRpbWVvdXRCLnRpbWVvdXQ7XG4gICAgICByZXR1cm4gZW5kQiA+IGVuZEEgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbaWQsIHRpbWVvdXRdIG9mIHNvcnRlZCkge1xuICAgICAgaWYgKHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubm93KCkgLSB0aW1lb3V0LnN0YXJ0ID49IHRpbWVvdXQudGltZW91dCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRzLmRlbGV0ZShpZCk7XG4gICAgICAgIHRpbWVvdXQuZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmx1c2hpbmcgPSBmYWxzZTtcbiAgfVxuICBpbmNyZW1lbnQobXMpIHtcbiAgICB0aGlzLl9ub3cgKz0gbXM7XG4gICAgdGhpcy5mbHVzaFRpbWVvdXRzKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBgb3V0cHV0YCBvZiB0aGUgYWN0b3Igd2hlbiBpdCBpcyBkb25lLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IG1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgLy8gLi4uXG4gKiAgIG91dHB1dDoge1xuICogICAgIGNvdW50OiA0MlxuICogICB9XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKG1hY2hpbmUpO1xuICpcbiAqIGFjdG9yLnN0YXJ0KCk7XG4gKlxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgdG9Qcm9taXNlKGFjdG9yKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvdXRwdXQpO1xuICogLy8gbG9ncyB7IGNvdW50OiA0MiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdG9Qcm9taXNlKGFjdG9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYWN0b3Iuc3Vic2NyaWJlKHtcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoYWN0b3IuZ2V0U25hcHNob3QoKS5vdXRwdXQpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiByZWplY3RcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYWN0b3IgYGxvZ2ljYCwgYSBgc25hcHNob3RgLCBhbmQgYW4gYGV2ZW50YCwgcmV0dXJucyBhIHR1cGxlIG9mIHRoZVxuICogYG5leHRTbmFwc2hvdGAgYW5kIGBhY3Rpb25zYCB0byBleGVjdXRlLlxuICpcbiAqIFRoaXMgaXMgYSBwdXJlIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgZXhlY3V0ZSBgYWN0aW9uc2AuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zaXRpb24obG9naWMsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBleGVjdXRhYmxlQWN0aW9ucyA9IFtdO1xuICBjb25zdCBhY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGxvZ2ljKTtcbiAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvciA9IGFjdGlvbiA9PiB7XG4gICAgZXhlY3V0YWJsZUFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9O1xuICBjb25zdCBuZXh0U25hcHNob3QgPSBsb2dpYy50cmFuc2l0aW9uKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSk7XG4gIHJldHVybiBbbmV4dFNuYXBzaG90LCBleGVjdXRhYmxlQWN0aW9uc107XG59XG5cbi8qKlxuICogR2l2ZW4gYWN0b3IgYGxvZ2ljYCBhbmQgb3B0aW9uYWwgYGlucHV0YCwgcmV0dXJucyBhIHR1cGxlIG9mIHRoZVxuICogYG5leHRTbmFwc2hvdGAgYW5kIGBhY3Rpb25zYCB0byBleGVjdXRlIGZyb20gdGhlIGluaXRpYWwgdHJhbnNpdGlvbiAobm9cbiAqIHByZXZpb3VzIHN0YXRlKS5cbiAqXG4gKiBUaGlzIGlzIGEgcHVyZSBmdW5jdGlvbiB0aGF0IGRvZXMgbm90IGV4ZWN1dGUgYGFjdGlvbnNgLlxuICovXG5mdW5jdGlvbiBpbml0aWFsVHJhbnNpdGlvbihsb2dpYywgLi4uW2lucHV0XSkge1xuICBjb25zdCBleGVjdXRhYmxlQWN0aW9ucyA9IFtdO1xuICBjb25zdCBhY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGxvZ2ljKTtcbiAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvciA9IGFjdGlvbiA9PiB7XG4gICAgZXhlY3V0YWJsZUFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9O1xuICBjb25zdCBuZXh0U25hcHNob3QgPSBsb2dpYy5nZXRJbml0aWFsU25hcHNob3QoYWN0b3JTY29wZSwgaW5wdXQpO1xuICByZXR1cm4gW25leHRTbmFwc2hvdCwgZXhlY3V0YWJsZUFjdGlvbnNdO1xufVxuXG5jb25zdCBkZWZhdWx0V2FpdEZvck9wdGlvbnMgPSB7XG4gIHRpbWVvdXQ6IEluZmluaXR5IC8vIG11Y2ggbW9yZSB0aGFuIDEwIHNlY29uZHNcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlcyB0byBhbiBhY3RvciByZWYgYW5kIHdhaXRzIGZvciBpdHMgZW1pdHRlZCB2YWx1ZSB0byBzYXRpc2Z5IGFcbiAqIHByZWRpY2F0ZSwgYW5kIHRoZW4gcmVzb2x2ZXMgd2l0aCB0aGF0IHZhbHVlLiBXaWxsIHRocm93IGlmIHRoZSBkZXNpcmVkIHN0YXRlXG4gKiBpcyBub3QgcmVhY2hlZCBhZnRlciBhbiBvcHRpb25hbCB0aW1lb3V0LiAoZGVmYXVsdHMgdG8gSW5maW5pdHkpLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHN0YXRlID0gYXdhaXQgd2FpdEZvcihzb21lU2VydmljZSwgKHN0YXRlKSA9PiB7XG4gKiAgIHJldHVybiBzdGF0ZS5oYXNUYWcoJ2xvYWRlZCcpO1xuICogfSk7XG4gKlxuICogc3RhdGUuaGFzVGFnKCdsb2FkZWQnKTsgLy8gdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFjdG9yUmVmIFRoZSBhY3RvciByZWYgdG8gc3Vic2NyaWJlIHRvXG4gKiBAcGFyYW0gcHJlZGljYXRlIERldGVybWluZXMgaWYgYSB2YWx1ZSBtYXRjaGVzIHRoZSBjb25kaXRpb24gdG8gd2FpdCBmb3JcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCBldmVudHVhbGx5IHJlc29sdmVzIHRvIHRoZSBlbWl0dGVkIHZhbHVlIHRoYXQgbWF0Y2hlc1xuICogICB0aGUgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIHdhaXRGb3IoYWN0b3JSZWYsIHByZWRpY2F0ZSwgb3B0aW9ucykge1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdFdhaXRGb3JPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hbFxuICAgIH0gPSByZXNvbHZlZE9wdGlvbnM7XG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICByZWooc2lnbmFsLnJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgaWYgKHJlc29sdmVkT3B0aW9ucy50aW1lb3V0IDwgMCkge1xuICAgICAgY29uc29sZS5lcnJvcignYHRpbWVvdXRgIHBhc3NlZCB0byBgd2FpdEZvcmAgaXMgbmVnYXRpdmUgYW5kIGl0IHdpbGwgcmVqZWN0IGl0cyBpbnRlcm5hbCBwcm9taXNlIGltbWVkaWF0ZWx5LicpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSByZXNvbHZlZE9wdGlvbnMudGltZW91dCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRpc3Bvc2UoKTtcbiAgICAgIHJlaihuZXcgRXJyb3IoYFRpbWVvdXQgb2YgJHtyZXNvbHZlZE9wdGlvbnMudGltZW91dH0gbXMgZXhjZWVkZWRgKSk7XG4gICAgfSwgcmVzb2x2ZWRPcHRpb25zLnRpbWVvdXQpO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgc3ViPy51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKGFib3J0TGlzdGVuZXIpIHtcbiAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaGVja0VtaXR0ZWQoZW1pdHRlZCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShlbWl0dGVkKSkge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIHJlcyhlbWl0dGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYHNpZ25hbGAgb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGlzIHdpbGwgYmUgdGhlIGxpc3RlbmVyIGZvciBpdHNcbiAgICAgKiBgYWJvcnRgIGV2ZW50XG4gICAgICovXG4gICAgbGV0IGFib3J0TGlzdGVuZXI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCBzdWI7IC8vIGF2b2lkIFREWiB3aGVuIGRpc3Bvc2luZyBzeW5jaHJvbm91c2x5XG5cbiAgICAvLyBTZWUgaWYgdGhlIGN1cnJlbnQgc25hcHNob3QgYWxyZWFkeSBtYXRjaGVzIHRoZSBwcmVkaWNhdGVcbiAgICBjaGVja0VtaXR0ZWQoYWN0b3JSZWYuZ2V0U25hcHNob3QoKSk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGRlZmluZSB0aGUgYGFib3J0TGlzdGVuZXJgIGlmIHRoZSBgc2lnbmFsYCBvcHRpb24gaXMgcHJvdmlkZWRcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBhYm9ydExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIC8vIFhTdGF0ZSBkb2VzIG5vdCBcIm93blwiIHRoZSBzaWduYWwsIHNvIHdlIHNob3VsZCByZWplY3Qgd2l0aCBpdHMgcmVhc29uIChpZiBhbnkpXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXByb21pc2UtcmVqZWN0LWVycm9yc1xuICAgICAgICByZWooc2lnbmFsLnJlYXNvbik7XG4gICAgICB9O1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgfVxuICAgIHN1YiA9IGFjdG9yUmVmLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiBjaGVja0VtaXR0ZWQsXG4gICAgICBlcnJvcjogZXJyID0+IHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnNcbiAgICAgICAgcmVqKGVycik7XG4gICAgICB9LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICByZWoobmV3IEVycm9yKGBBY3RvciB0ZXJtaW5hdGVkIHdpdGhvdXQgc2F0aXNmeWluZyBwcmVkaWNhdGVgKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IFNpbXVsYXRlZENsb2NrLCBTdGF0ZU1hY2hpbmUsIFN0YXRlTm9kZSwgYXNzZXJ0RXZlbnQsIGNyZWF0ZU1hY2hpbmUsIGdldEluaXRpYWxTbmFwc2hvdCwgZ2V0TmV4dFNuYXBzaG90LCBpbml0aWFsVHJhbnNpdGlvbiwgc2V0dXAsIHRvUHJvbWlzZSwgdHJhbnNpdGlvbiwgd2FpdEZvciB9O1xuIl0sIm5hbWVzIjpbImNyZWF0ZUVtcHR5QWN0b3IiLCJmcm9tQ2FsbGJhY2siLCJmcm9tRXZlbnRPYnNlcnZhYmxlIiwiZnJvbU9ic2VydmFibGUiLCJmcm9tUHJvbWlzZSIsImZyb21UcmFuc2l0aW9uIiwidCIsInRvQXJyYXkiLCJTIiwiU1RBVEVfREVMSU1JVEVSIiwibSIsIm1hcFZhbHVlcyIsImYiLCJmb3JtYXRUcmFuc2l0aW9ucyIsImEiLCJ0b1RyYW5zaXRpb25Db25maWdBcnJheSIsImIiLCJmb3JtYXRUcmFuc2l0aW9uIiwiTiIsIk5VTExfRVZFTlQiLCJlIiwiZXZhbHVhdGVHdWFyZCIsImMiLCJjcmVhdGVJbnZva2VJZCIsImciLCJnZXREZWxheWVkVHJhbnNpdGlvbnMiLCJkIiwiZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24iLCJoIiwiZ2V0Q2FuZGlkYXRlcyIsInIiLCJyZXNvbHZlU3RhdGVWYWx1ZSIsImkiLCJnZXRBbGxTdGF0ZU5vZGVzIiwiaiIsImdldFN0YXRlTm9kZXMiLCJrIiwiY3JlYXRlTWFjaGluZVNuYXBzaG90IiwibCIsImlzSW5GaW5hbFN0YXRlIiwibiIsIm1hY3Jvc3RlcCIsIm8iLCJ0cmFuc2l0aW9uTm9kZSIsInAiLCJyZXNvbHZlQWN0aW9uc0FuZENvbnRleHQiLCJxIiwiY3JlYXRlSW5pdEV2ZW50IiwicyIsIm1pY3Jvc3RlcCIsInUiLCJnZXRJbml0aWFsU3RhdGVOb2RlcyIsInYiLCJ0b1N0YXRlUGF0aCIsInciLCJpc1N0YXRlSWQiLCJ4IiwiZ2V0U3RhdGVOb2RlQnlQYXRoIiwieSIsImdldFBlcnNpc3RlZFNuYXBzaG90IiwieiIsInJlc29sdmVSZWZlcmVuY2VkQWN0b3IiLCJBIiwiY3JlYXRlQWN0b3IiLCIkIiwiJCRBQ1RPUl9UWVBFIiwiQiIsIkFjdG9yIiwiSSIsIl9fdW5zYWZlX2dldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMiLCJEIiwiYW5kIiwiTSIsImNhbmNlbCIsIkMiLCJpbnRlcnByZXQiLCJIIiwiaXNNYWNoaW5lU25hcHNob3QiLCJKIiwibWF0Y2hlc1N0YXRlIiwiRSIsIm5vdCIsIkYiLCJvciIsIksiLCJwYXRoVG9TdGF0ZVZhbHVlIiwiTyIsInJhaXNlIiwiUCIsInNwYXduQ2hpbGQiLCJHIiwic3RhdGVJbiIsIlEiLCJzdG9wIiwiUiIsInN0b3BDaGlsZCIsIkwiLCJ0b09ic2VydmVyIiwiYXNzaWduIiwiU3BlY2lhbFRhcmdldHMiLCJlbWl0IiwiZW5xdWV1ZUFjdGlvbnMiLCJmb3J3YXJkVG8iLCJsb2ciLCJzZW5kUGFyZW50Iiwic2VuZFRvIiwiYXNzZXJ0RXZlbnQiLCJldmVudCIsInR5cGUiLCJ0eXBlcyIsImluY2x1ZGVzIiwidHlwZXNUZXh0IiwibGVuZ3RoIiwiam9pbiIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImNhY2hlIiwiV2Vha01hcCIsIm1lbW8iLCJvYmplY3QiLCJrZXkiLCJmbiIsIm1lbW9pemVkRGF0YSIsImdldCIsInNldCIsIkVNUFRZX09CSkVDVCIsInRvU2VyaWFsaXphYmxlQWN0aW9uIiwiYWN0aW9uIiwibmFtZSIsIlN0YXRlTm9kZSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwib3B0aW9ucyIsImlkIiwicGF0aCIsInN0YXRlcyIsImhpc3RvcnkiLCJlbnRyeSIsImV4aXQiLCJwYXJlbnQiLCJtYWNoaW5lIiwibWV0YSIsIm91dHB1dCIsIm9yZGVyIiwiZGVzY3JpcHRpb24iLCJ0YWdzIiwidHJhbnNpdGlvbnMiLCJhbHdheXMiLCJfcGFyZW50IiwiX2tleSIsIl9tYWNoaW5lIiwiY29uY2F0IiwiT2JqZWN0Iiwia2V5cyIsImlkTWFwIiwic2l6ZSIsInN0YXRlQ29uZmlnIiwic3RhdGVOb2RlIiwiaW5pdGlhbCIsInNsaWNlIiwidW5kZWZpbmVkIiwiX2luaXRpYWxpemUiLCJtYXAiLCJmb3JFYWNoIiwiZGVmaW5pdGlvbiIsInZlcnNpb24iLCJ0YXJnZXQiLCJzb3VyY2UiLCJhY3Rpb25zIiwiZXZlbnRUeXBlIiwicmVlbnRlciIsInRvSlNPTiIsInN0YXRlIiwib24iLCJ2YWx1ZXMiLCJmbGF0IiwiaW52b2tlIiwiaW52b2tlQ29uZmlnIiwic3JjIiwic3lzdGVtSWQiLCJyZXNvbHZlZElkIiwic291cmNlTmFtZSIsIm9uRG9uZSIsIm9uRXJyb3IiLCJpbnZva2VEZWZWYWx1ZXMiLCJmbGF0TWFwIiwiZGVzY3JpcHRvciIsInJlZHVjZSIsInRyYW5zaXRpb24iLCJwdXNoIiwiYWZ0ZXIiLCJuZXh0Iiwic25hcHNob3QiLCJzZWxlY3RlZFRyYW5zaXRpb24iLCJjYW5kaWRhdGVzIiwiY2FuZGlkYXRlIiwiZ3VhcmQiLCJyZXNvbHZlZENvbnRleHQiLCJjb250ZXh0IiwiZ3VhcmRQYXNzZWQiLCJlcnIiLCJndWFyZFR5cGUiLCJtZXNzYWdlIiwiZXZlbnRzIiwiU2V0Iiwib3duRXZlbnRzIiwic3RhdGVJZCIsImFkZCIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsInNvbWUiLCJTVEFURV9JREVOVElGSUVSIiwiU3RhdGVNYWNoaW5lIiwiaW1wbGVtZW50YXRpb25zIiwic2NoZW1hcyIsIl9feHN0YXRlbm9kZSIsIk1hcCIsInJvb3QiLCJhY3RvcnMiLCJkZWxheXMiLCJndWFyZHMiLCJiaW5kIiwiZ2V0SW5pdGlhbFNuYXBzaG90IiwicmVzdG9yZVNuYXBzaG90Iiwic3RhcnQiLCJjb25zb2xlIiwid2FybiIsInByb3ZpZGUiLCJyZXNvbHZlU3RhdGUiLCJyZXNvbHZlZFN0YXRlVmFsdWUiLCJ2YWx1ZSIsIm5vZGVTZXQiLCJfbm9kZXMiLCJjaGlsZHJlbiIsInN0YXR1cyIsImVycm9yIiwiaGlzdG9yeVZhbHVlIiwiYWN0b3JTY29wZSIsIm1pY3Jvc3RhdGVzIiwiZ2V0VHJhbnNpdGlvbkRhdGEiLCJnZXRQcmVJbml0aWFsU3RhdGUiLCJpbml0RXZlbnQiLCJpbnRlcm5hbFF1ZXVlIiwicHJlSW5pdGlhbCIsImFzc2lnbm1lbnQiLCJzcGF3biIsInNlbGYiLCJpbnB1dCIsInByZUluaXRpYWxTdGF0ZSIsIm5leHRTdGF0ZSIsIm1hY3JvU3RhdGUiLCJjaGlsZCIsImdldFNuYXBzaG90IiwiZ2V0U3RhdGVOb2RlQnlJZCIsImZ1bGxQYXRoIiwicmVsYXRpdmVQYXRoIiwicmVzb2x2ZWRTdGF0ZUlkIiwiX2FjdG9yU2NvcGUiLCJzbmFwc2hvdENoaWxkcmVuIiwiYWN0b3JJZCIsImFjdG9yRGF0YSIsImNoaWxkU3RhdGUiLCJsb2dpYyIsImFjdG9yUmVmIiwic3luY1NuYXBzaG90IiwicmVzdG9yZWRTbmFwc2hvdCIsInNlZW4iLCJyZXZpdmVDb250ZXh0IiwiY29udGV4dFBhcnQiLCJoYXMiLCJ4c3RhdGUkJHR5cGUiLCJjcmVhdGVNYWNoaW5lIiwiY3JlYXRlSW5lcnRBY3RvclNjb3BlIiwiYWN0b3JMb2dpYyIsImluZXJ0QWN0b3JTY29wZSIsImRlZmVyIiwibG9nZ2VyIiwic2Vzc2lvbklkIiwic3lzdGVtIiwiYWN0aW9uRXhlY3V0b3IiLCJnZXROZXh0U25hcHNob3QiLCJfc25hcHNob3QiLCJzZXR1cCIsIlNpbXVsYXRlZENsb2NrIiwidGltZW91dHMiLCJfbm93IiwiX2lkIiwiX2ZsdXNoaW5nIiwiX2ZsdXNoaW5nSW52YWxpZGF0ZWQiLCJub3ciLCJnZXRJZCIsInNldFRpbWVvdXQiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZGVsZXRlIiwidGltZSIsImZsdXNoVGltZW91dHMiLCJzb3J0ZWQiLCJzb3J0IiwiX2lkQSIsInRpbWVvdXRBIiwiX2lkQiIsInRpbWVvdXRCIiwiZW5kQSIsImVuZEIiLCJjYWxsIiwiaW5jcmVtZW50IiwibXMiLCJ0b1Byb21pc2UiLCJhY3RvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic3Vic2NyaWJlIiwiY29tcGxldGUiLCJleGVjdXRhYmxlQWN0aW9ucyIsIm5leHRTbmFwc2hvdCIsImluaXRpYWxUcmFuc2l0aW9uIiwiZGVmYXVsdFdhaXRGb3JPcHRpb25zIiwiSW5maW5pdHkiLCJ3YWl0Rm9yIiwicHJlZGljYXRlIiwicmVzb2x2ZWRPcHRpb25zIiwicmVzIiwicmVqIiwic2lnbmFsIiwiYWJvcnRlZCIsInJlYXNvbiIsImRvbmUiLCJoYW5kbGUiLCJkaXNwb3NlIiwic3ViIiwidW5zdWJzY3JpYmUiLCJhYm9ydExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNoZWNrRW1pdHRlZCIsImVtaXR0ZWQiLCJhZGRFdmVudExpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/xstate/dist/xstate.development.esm.js\n");

/***/ })

};
;