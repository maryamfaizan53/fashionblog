"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/history";
exports.ids = ["vendor-chunks/history"];
exports.modules = {

/***/ "(ssr)/./node_modules/history/index.js":
/*!***************************************!*\
  !*** ./node_modules/history/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   parsePath: () => (/* binding */ parsePath)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */ var Action;\n(function(Action) {\n    /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */ Action[\"Pop\"] = \"POP\";\n    /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */ Action[\"Push\"] = \"PUSH\";\n    /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */ Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nvar readOnly =  true ? function(obj) {\n    return Object.freeze(obj);\n} : 0;\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message); // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nvar BeforeUnloadEventType = \"beforeunload\";\nvar HashChangeEventType = \"hashchange\";\nvar PopStateEventType = \"popstate\";\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */ function createBrowserHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, _options$window = _options.window, window = _options$window === void 0 ? document.defaultView : _options$window;\n    var globalHistory = window.history;\n    function getIndexAndLocation() {\n        var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;\n        var state = globalHistory.state || {};\n        return [\n            state.idx,\n            readOnly({\n                pathname: pathname,\n                search: search,\n                hash: hash,\n                state: state.usr || null,\n                key: state.key || \"default\"\n            })\n        ];\n    }\n    var blockedPopTx = null;\n    function handlePop() {\n        if (blockedPopTx) {\n            blockers.call(blockedPopTx);\n            blockedPopTx = null;\n        } else {\n            var nextAction = Action.Pop;\n            var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];\n            if (blockers.length) {\n                if (nextIndex != null) {\n                    var delta = index - nextIndex;\n                    if (delta) {\n                        // Revert the POP\n                        blockedPopTx = {\n                            action: nextAction,\n                            location: nextLocation,\n                            retry: function retry() {\n                                go(delta * -1);\n                            }\n                        };\n                        go(delta);\n                    }\n                } else {\n                    // Trying to POP to a location with no index. We did not create\n                    // this location, so we can't effectively block the navigation.\n                     true ? warning(false, // detail and link to it here so people can understand better what\n                    // is going on and how to avoid it.\n                    \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : 0;\n                }\n            } else {\n                applyTx(nextAction);\n            }\n        }\n    }\n    window.addEventListener(PopStateEventType, handlePop);\n    var action = Action.Pop;\n    var _getIndexAndLocation2 = getIndexAndLocation(), index = _getIndexAndLocation2[0], location = _getIndexAndLocation2[1];\n    var listeners = createEvents();\n    var blockers = createEvents();\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    } // state defaults to `null` because `window.history.state` does\n    function getNextLocation(to, state) {\n        if (state === void 0) {\n            state = null;\n        }\n        return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: location.pathname,\n            hash: \"\",\n            search: \"\"\n        }, typeof to === \"string\" ? parsePath(to) : to, {\n            state: state,\n            key: createKey()\n        }));\n    }\n    function getHistoryStateAndUrl(nextLocation, index) {\n        return [\n            {\n                usr: nextLocation.state,\n                key: nextLocation.key,\n                idx: index\n            },\n            createHref(nextLocation)\n        ];\n    }\n    function allowTx(action, location, retry) {\n        return !blockers.length || (blockers.call({\n            action: action,\n            location: location,\n            retry: retry\n        }), false);\n    }\n    function applyTx(nextAction) {\n        action = nextAction;\n        var _getIndexAndLocation3 = getIndexAndLocation();\n        index = _getIndexAndLocation3[0];\n        location = _getIndexAndLocation3[1];\n        listeners.call({\n            action: action,\n            location: location\n        });\n    }\n    function push(to, state) {\n        var nextAction = Action.Push;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n            // try...catch because iOS limits us to 100 pushState calls :/\n            try {\n                globalHistory.pushState(historyState, \"\", url);\n            } catch (error) {\n                // They are going to lose state here, but there is no real\n                // way to warn them about it since the page will refresh...\n                window.location.assign(url);\n            }\n            applyTx(nextAction);\n        }\n    }\n    function replace(to, state) {\n        var nextAction = Action.Replace;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            replace(to, state);\n        }\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n            globalHistory.replaceState(historyState, \"\", url);\n            applyTx(nextAction);\n        }\n    }\n    function go(delta) {\n        globalHistory.go(delta);\n    }\n    var history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return location;\n        },\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        back: function back() {\n            go(-1);\n        },\n        forward: function forward() {\n            go(1);\n        },\n        listen: function listen(listener) {\n            return listeners.push(listener);\n        },\n        block: function block(blocker) {\n            var unblock = blockers.push(blocker);\n            if (blockers.length === 1) {\n                window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n            }\n            return function() {\n                unblock(); // Remove the beforeunload listener so the document may\n                // still be salvageable in the pagehide event.\n                // See https://html.spec.whatwg.org/#unloading-documents\n                if (!blockers.length) {\n                    window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n                }\n            };\n        }\n    };\n    return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */ function createHashHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options2 = options, _options2$window = _options2.window, window = _options2$window === void 0 ? document.defaultView : _options2$window;\n    var globalHistory = window.history;\n    function getIndexAndLocation() {\n        var _parsePath = parsePath(window.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? \"/\" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? \"\" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? \"\" : _parsePath$hash;\n        var state = globalHistory.state || {};\n        return [\n            state.idx,\n            readOnly({\n                pathname: pathname,\n                search: search,\n                hash: hash,\n                state: state.usr || null,\n                key: state.key || \"default\"\n            })\n        ];\n    }\n    var blockedPopTx = null;\n    function handlePop() {\n        if (blockedPopTx) {\n            blockers.call(blockedPopTx);\n            blockedPopTx = null;\n        } else {\n            var nextAction = Action.Pop;\n            var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];\n            if (blockers.length) {\n                if (nextIndex != null) {\n                    var delta = index - nextIndex;\n                    if (delta) {\n                        // Revert the POP\n                        blockedPopTx = {\n                            action: nextAction,\n                            location: nextLocation,\n                            retry: function retry() {\n                                go(delta * -1);\n                            }\n                        };\n                        go(delta);\n                    }\n                } else {\n                    // Trying to POP to a location with no index. We did not create\n                    // this location, so we can't effectively block the navigation.\n                     true ? warning(false, // detail and link to it here so people can understand better\n                    // what is going on and how to avoid it.\n                    \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : 0;\n                }\n            } else {\n                applyTx(nextAction);\n            }\n        }\n    }\n    window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n    // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n    window.addEventListener(HashChangeEventType, function() {\n        var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n        if (createPath(nextLocation) !== createPath(location)) {\n            handlePop();\n        }\n    });\n    var action = Action.Pop;\n    var _getIndexAndLocation6 = getIndexAndLocation(), index = _getIndexAndLocation6[0], location = _getIndexAndLocation6[1];\n    var listeners = createEvents();\n    var blockers = createEvents();\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function getBaseHref() {\n        var base = document.querySelector(\"base\");\n        var href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            var url = window.location.href;\n            var hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href;\n    }\n    function createHref(to) {\n        return getBaseHref() + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function getNextLocation(to, state) {\n        if (state === void 0) {\n            state = null;\n        }\n        return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: location.pathname,\n            hash: \"\",\n            search: \"\"\n        }, typeof to === \"string\" ? parsePath(to) : to, {\n            state: state,\n            key: createKey()\n        }));\n    }\n    function getHistoryStateAndUrl(nextLocation, index) {\n        return [\n            {\n                usr: nextLocation.state,\n                key: nextLocation.key,\n                idx: index\n            },\n            createHref(nextLocation)\n        ];\n    }\n    function allowTx(action, location, retry) {\n        return !blockers.length || (blockers.call({\n            action: action,\n            location: location,\n            retry: retry\n        }), false);\n    }\n    function applyTx(nextAction) {\n        action = nextAction;\n        var _getIndexAndLocation7 = getIndexAndLocation();\n        index = _getIndexAndLocation7[0];\n        location = _getIndexAndLocation7[1];\n        listeners.call({\n            action: action,\n            location: location\n        });\n    }\n    function push(to, state) {\n        var nextAction = Action.Push;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n         true ? warning(nextLocation.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n            // try...catch because iOS limits us to 100 pushState calls :/\n            try {\n                globalHistory.pushState(historyState, \"\", url);\n            } catch (error) {\n                // They are going to lose state here, but there is no real\n                // way to warn them about it since the page will refresh...\n                window.location.assign(url);\n            }\n            applyTx(nextAction);\n        }\n    }\n    function replace(to, state) {\n        var nextAction = Action.Replace;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            replace(to, state);\n        }\n         true ? warning(nextLocation.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n            globalHistory.replaceState(historyState, \"\", url);\n            applyTx(nextAction);\n        }\n    }\n    function go(delta) {\n        globalHistory.go(delta);\n    }\n    var history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return location;\n        },\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        back: function back() {\n            go(-1);\n        },\n        forward: function forward() {\n            go(1);\n        },\n        listen: function listen(listener) {\n            return listeners.push(listener);\n        },\n        block: function block(blocker) {\n            var unblock = blockers.push(blocker);\n            if (blockers.length === 1) {\n                window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n            }\n            return function() {\n                unblock(); // Remove the beforeunload listener so the document may\n                // still be salvageable in the pagehide event.\n                // See https://html.spec.whatwg.org/#unloading-documents\n                if (!blockers.length) {\n                    window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n                }\n            };\n        }\n    };\n    return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */ function createMemoryHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options3 = options, _options3$initialEntr = _options3.initialEntries, initialEntries = _options3$initialEntr === void 0 ? [\n        \"/\"\n    ] : _options3$initialEntr, initialIndex = _options3.initialIndex;\n    var entries = initialEntries.map(function(entry) {\n        var location = readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: createKey()\n        }, typeof entry === \"string\" ? parsePath(entry) : entry));\n         true ? warning(location.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : 0;\n        return location;\n    });\n    var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n    var action = Action.Pop;\n    var location = entries[index];\n    var listeners = createEvents();\n    var blockers = createEvents();\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    function getNextLocation(to, state) {\n        if (state === void 0) {\n            state = null;\n        }\n        return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: location.pathname,\n            search: \"\",\n            hash: \"\"\n        }, typeof to === \"string\" ? parsePath(to) : to, {\n            state: state,\n            key: createKey()\n        }));\n    }\n    function allowTx(action, location, retry) {\n        return !blockers.length || (blockers.call({\n            action: action,\n            location: location,\n            retry: retry\n        }), false);\n    }\n    function applyTx(nextAction, nextLocation) {\n        action = nextAction;\n        location = nextLocation;\n        listeners.call({\n            action: action,\n            location: location\n        });\n    }\n    function push(to, state) {\n        var nextAction = Action.Push;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n         true ? warning(location.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            applyTx(nextAction, nextLocation);\n        }\n    }\n    function replace(to, state) {\n        var nextAction = Action.Replace;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            replace(to, state);\n        }\n         true ? warning(location.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            entries[index] = nextLocation;\n            applyTx(nextAction, nextLocation);\n        }\n    }\n    function go(delta) {\n        var nextIndex = clamp(index + delta, 0, entries.length - 1);\n        var nextAction = Action.Pop;\n        var nextLocation = entries[nextIndex];\n        function retry() {\n            go(delta);\n        }\n        if (allowTx(nextAction, nextLocation, retry)) {\n            index = nextIndex;\n            applyTx(nextAction, nextLocation);\n        }\n    }\n    var history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return location;\n        },\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        back: function back() {\n            go(-1);\n        },\n        forward: function forward() {\n            go(1);\n        },\n        listen: function listen(listener) {\n            return listeners.push(listener);\n        },\n        block: function block(blocker) {\n            return blockers.push(blocker);\n        }\n    };\n    return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\nfunction clamp(n, lowerBound, upperBound) {\n    return Math.min(Math.max(n, lowerBound), upperBound);\n}\nfunction promptBeforeUnload(event) {\n    // Cancel the event.\n    event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n    event.returnValue = \"\";\n}\nfunction createEvents() {\n    var handlers = [];\n    return {\n        get length () {\n            return handlers.length;\n        },\n        push: function push(fn) {\n            handlers.push(fn);\n            return function() {\n                handlers = handlers.filter(function(handler) {\n                    return handler !== fn;\n                });\n            };\n        },\n        call: function call(arg) {\n            handlers.forEach(function(fn) {\n                return fn && fn(arg);\n            });\n        }\n    };\n}\nfunction createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */ function createPath(_ref) {\n    var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? \"/\" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? \"\" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? \"\" : _ref$hash;\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */ function parsePath(path) {\n    var parsedPath = {};\n    if (path) {\n        var hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        var searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVMsS0FBS0YsWUFBWUUsS0FBSzJFLE1BQU0sQ0FBQyxPQUFPLE1BQU0zRSxPQUFPLE1BQU1BO0lBQzVFLE9BQU9GO0FBQ1Q7QUFDQTs7OztDQUlDLEdBRUQsU0FBU2dDLFVBQVVpRixJQUFJO0lBQ3JCLElBQUlDLGFBQWEsQ0FBQztJQUVsQixJQUFJRCxNQUFNO1FBQ1IsSUFBSXhDLFlBQVl3QyxLQUFLdkMsT0FBTyxDQUFDO1FBRTdCLElBQUlELGFBQWEsR0FBRztZQUNsQnlDLFdBQVdoSCxJQUFJLEdBQUcrRyxLQUFLcEQsTUFBTSxDQUFDWTtZQUM5QndDLE9BQU9BLEtBQUtwRCxNQUFNLENBQUMsR0FBR1k7UUFDeEI7UUFFQSxJQUFJMEMsY0FBY0YsS0FBS3ZDLE9BQU8sQ0FBQztRQUUvQixJQUFJeUMsZUFBZSxHQUFHO1lBQ3BCRCxXQUFXakgsTUFBTSxHQUFHZ0gsS0FBS3BELE1BQU0sQ0FBQ3NEO1lBQ2hDRixPQUFPQSxLQUFLcEQsTUFBTSxDQUFDLEdBQUdzRDtRQUN4QjtRQUVBLElBQUlGLE1BQU07WUFDUkMsV0FBV2xILFFBQVEsR0FBR2lIO1FBQ3hCO0lBQ0Y7SUFFQSxPQUFPQztBQUNUO0FBRXVHLENBQ3ZHLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NpbXBsZS1ibG9nLXN0eWxlZC10ZW1wbGF0ZS1mb3ItaGVhZGxlc3MtY21zLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvaW5kZXguanM/ZTFmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5cbi8qKlxyXG4gKiBBY3Rpb25zIHJlcHJlc2VudCB0aGUgdHlwZSBvZiBjaGFuZ2UgdG8gYSBsb2NhdGlvbiB2YWx1ZS5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNhY3Rpb25cclxuICovXG52YXIgQWN0aW9uO1xuXG4oZnVuY3Rpb24gKEFjdGlvbikge1xuICAvKipcclxuICAgKiBBIFBPUCBpbmRpY2F0ZXMgYSBjaGFuZ2UgdG8gYW4gYXJiaXRyYXJ5IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoXHJcbiAgICogYXMgYSBiYWNrIG9yIGZvcndhcmQgbmF2aWdhdGlvbi4gSXQgZG9lcyBub3QgZGVzY3JpYmUgdGhlIGRpcmVjdGlvbiBvZiB0aGVcclxuICAgKiBuYXZpZ2F0aW9uLCBvbmx5IHRoYXQgdGhlIGN1cnJlbnQgaW5kZXggY2hhbmdlZC5cclxuICAgKlxyXG4gICAqIE5vdGU6IFRoaXMgaXMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBuZXdseSBjcmVhdGVkIGhpc3Rvcnkgb2JqZWN0cy5cclxuICAgKi9cbiAgQWN0aW9uW1wiUG9wXCJdID0gXCJQT1BcIjtcbiAgLyoqXHJcbiAgICogQSBQVVNIIGluZGljYXRlcyBhIG5ldyBlbnRyeSBiZWluZyBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaCBhcyB3aGVuXHJcbiAgICogYSBsaW5rIGlzIGNsaWNrZWQgYW5kIGEgbmV3IHBhZ2UgbG9hZHMuIFdoZW4gdGhpcyBoYXBwZW5zLCBhbGwgc3Vic2VxdWVudFxyXG4gICAqIGVudHJpZXMgaW4gdGhlIHN0YWNrIGFyZSBsb3N0LlxyXG4gICAqL1xuXG4gIEFjdGlvbltcIlB1c2hcIl0gPSBcIlBVU0hcIjtcbiAgLyoqXHJcbiAgICogQSBSRVBMQUNFIGluZGljYXRlcyB0aGUgZW50cnkgYXQgdGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2tcclxuICAgKiBiZWluZyByZXBsYWNlZCBieSBhIG5ldyBvbmUuXHJcbiAgICovXG5cbiAgQWN0aW9uW1wiUmVwbGFjZVwiXSA9IFwiUkVQTEFDRVwiO1xufSkoQWN0aW9uIHx8IChBY3Rpb24gPSB7fSkpO1xuXG52YXIgcmVhZE9ubHkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqO1xufTtcblxuZnVuY3Rpb24gd2FybmluZyhjb25kLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIGhpc3RvcnkhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG52YXIgQmVmb3JlVW5sb2FkRXZlbnRUeXBlID0gJ2JlZm9yZXVubG9hZCc7XG52YXIgSGFzaENoYW5nZUV2ZW50VHlwZSA9ICdoYXNoY2hhbmdlJztcbnZhciBQb3BTdGF0ZUV2ZW50VHlwZSA9ICdwb3BzdGF0ZSc7XG4vKipcclxuICogQnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3JcclxuICogbW9zdCB3ZWIgYXBwcywgYnV0IGl0IHJlcXVpcmVzIHNvbWUgY29uZmlndXJhdGlvbiBvbiB0aGUgc2VydmVyIHRvIGVuc3VyZSB5b3VcclxuICogc2VydmUgdGhlIHNhbWUgYXBwIGF0IG11bHRpcGxlIFVSTHMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlYnJvd3Nlcmhpc3RvcnlcclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyR3aW5kb3cgPSBfb3B0aW9ucy53aW5kb3csXG4gICAgICB3aW5kb3cgPSBfb3B0aW9ucyR3aW5kb3cgPT09IHZvaWQgMCA/IGRvY3VtZW50LmRlZmF1bHRWaWV3IDogX29wdGlvbnMkd2luZG93O1xuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuXG4gIGZ1bmN0aW9uIGdldEluZGV4QW5kTG9jYXRpb24oKSB7XG4gICAgdmFyIF93aW5kb3ckbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgIHBhdGhuYW1lID0gX3dpbmRvdyRsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoID0gX3dpbmRvdyRsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGhhc2ggPSBfd2luZG93JGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gZ2xvYmFsSGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgICByZXR1cm4gW3N0YXRlLmlkeCwgcmVhZE9ubHkoe1xuICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgICBoYXNoOiBoYXNoLFxuICAgICAgc3RhdGU6IHN0YXRlLnVzciB8fCBudWxsLFxuICAgICAga2V5OiBzdGF0ZS5rZXkgfHwgJ2RlZmF1bHQnXG4gICAgfSldO1xuICB9XG5cbiAgdmFyIGJsb2NrZWRQb3BUeCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGlmIChibG9ja2VkUG9wVHgpIHtcbiAgICAgIGJsb2NrZXJzLmNhbGwoYmxvY2tlZFBvcFR4KTtcbiAgICAgIGJsb2NrZWRQb3BUeCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlBvcDtcblxuICAgICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpLFxuICAgICAgICAgIG5leHRJbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uWzBdLFxuICAgICAgICAgIG5leHRMb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uWzFdO1xuXG4gICAgICBpZiAoYmxvY2tlcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChuZXh0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBkZWx0YSA9IGluZGV4IC0gbmV4dEluZGV4O1xuXG4gICAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBSZXZlcnQgdGhlIFBPUFxuICAgICAgICAgICAgYmxvY2tlZFBvcFR4ID0ge1xuICAgICAgICAgICAgICBhY3Rpb246IG5leHRBY3Rpb24sXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgICAgICAgIHJldHJ5OiBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgICAgICAgICAgICBnbyhkZWx0YSAqIC0xKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdvKGRlbHRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVHJ5aW5nIHRvIFBPUCB0byBhIGxvY2F0aW9uIHdpdGggbm8gaW5kZXguIFdlIGRpZCBub3QgY3JlYXRlXG4gICAgICAgICAgLy8gdGhpcyBsb2NhdGlvbiwgc28gd2UgY2FuJ3QgZWZmZWN0aXZlbHkgYmxvY2sgdGhlIG5hdmlnYXRpb24uXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgLy8gVE9ETzogV3JpdGUgdXAgYSBkb2MgdGhhdCBleHBsYWlucyBvdXIgYmxvY2tpbmcgc3RyYXRlZ3kgaW5cbiAgICAgICAgICAvLyBkZXRhaWwgYW5kIGxpbmsgdG8gaXQgaGVyZSBzbyBwZW9wbGUgY2FuIHVuZGVyc3RhbmQgYmV0dGVyIHdoYXRcbiAgICAgICAgICAvLyBpcyBnb2luZyBvbiBhbmQgaG93IHRvIGF2b2lkIGl0LlxuICAgICAgICAgIFwiWW91IGFyZSB0cnlpbmcgdG8gYmxvY2sgYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIHRoYXQgd2FzIG5vdCBcIiArIFwiY3JlYXRlZCBieSB0aGUgaGlzdG9yeSBsaWJyYXJ5LiBUaGUgYmxvY2sgd2lsbCBmYWlsIHNpbGVudGx5IGluIFwiICsgXCJwcm9kdWN0aW9uLCBidXQgaW4gZ2VuZXJhbCB5b3Ugc2hvdWxkIGRvIGFsbCBuYXZpZ2F0aW9uIHdpdGggdGhlIFwiICsgXCJoaXN0b3J5IGxpYnJhcnkgKGluc3RlYWQgb2YgdXNpbmcgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlIGRpcmVjdGx5KSBcIiArIFwidG8gYXZvaWQgdGhpcyBzaXR1YXRpb24uXCIpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBseVR4KG5leHRBY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICB2YXIgYWN0aW9uID0gQWN0aW9uLlBvcDtcblxuICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb24yID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpLFxuICAgICAgaW5kZXggPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjJbMF0sXG4gICAgICBsb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uMlsxXTtcblxuICB2YXIgbGlzdGVuZXJzID0gY3JlYXRlRXZlbnRzKCk7XG4gIHZhciBibG9ja2VycyA9IGNyZWF0ZUV2ZW50cygpO1xuXG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LCBnbG9iYWxIaXN0b3J5LnN0YXRlLCB7XG4gICAgICBpZHg6IGluZGV4XG4gICAgfSksICcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYodG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH0gLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG5cblxuICBmdW5jdGlvbiBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVhZE9ubHkoX2V4dGVuZHMoe1xuICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgaGFzaDogJycsXG4gICAgICBzZWFyY2g6ICcnXG4gICAgfSwgdHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAga2V5OiBjcmVhdGVLZXkoKVxuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZUFuZFVybChuZXh0TG9jYXRpb24sIGluZGV4KSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICB1c3I6IG5leHRMb2NhdGlvbi5zdGF0ZSxcbiAgICAgIGtleTogbmV4dExvY2F0aW9uLmtleSxcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9LCBjcmVhdGVIcmVmKG5leHRMb2NhdGlvbildO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxsb3dUeChhY3Rpb24sIGxvY2F0aW9uLCByZXRyeSkge1xuICAgIHJldHVybiAhYmxvY2tlcnMubGVuZ3RoIHx8IChibG9ja2Vycy5jYWxsKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcmV0cnk6IHJldHJ5XG4gICAgfSksIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5VHgobmV4dEFjdGlvbikge1xuICAgIGFjdGlvbiA9IG5leHRBY3Rpb247XG5cbiAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb24zID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpO1xuXG4gICAgaW5kZXggPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjNbMF07XG4gICAgbG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjNbMV07XG4gICAgbGlzdGVuZXJzLmNhbGwoe1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2godG8sIHN0YXRlKSB7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIHB1c2godG8sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgdmFyIF9nZXRIaXN0b3J5U3RhdGVBbmRVciA9IGdldEhpc3RvcnlTdGF0ZUFuZFVybChuZXh0TG9jYXRpb24sIGluZGV4ICsgMSksXG4gICAgICAgICAgaGlzdG9yeVN0YXRlID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyWzBdLFxuICAgICAgICAgIHVybCA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVclsxXTsgLy8gVE9ETzogU3VwcG9ydCBmb3JjZWQgcmVsb2FkaW5nXG4gICAgICAvLyB0cnkuLi5jYXRjaCBiZWNhdXNlIGlPUyBsaW1pdHMgdXMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxscyA6L1xuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIHVybCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAgIC8vIHdheSB0byB3YXJuIHRoZW0gYWJvdXQgaXQgc2luY2UgdGhlIHBhZ2Ugd2lsbCByZWZyZXNoLi4uXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgIH1cblxuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICByZXBsYWNlKHRvLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIHZhciBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIyID0gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXgpLFxuICAgICAgICAgIGhpc3RvcnlTdGF0ZSA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjJbMF0sXG4gICAgICAgICAgdXJsID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyMlsxXTsgLy8gVE9ETzogU3VwcG9ydCBmb3JjZWQgcmVsb2FkaW5nXG5cblxuICAgICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgdXJsKTtcbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ28oZGVsdGEpIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKGRlbHRhKTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG5cbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfSxcblxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xuICAgICAgZ28oLTEpO1xuICAgIH0sXG4gICAgZm9yd2FyZDogZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgICAgIGdvKDEpO1xuICAgIH0sXG4gICAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBibG9jazogZnVuY3Rpb24gYmxvY2soYmxvY2tlcikge1xuICAgICAgdmFyIHVuYmxvY2sgPSBibG9ja2Vycy5wdXNoKGJsb2NrZXIpO1xuXG4gICAgICBpZiAoYmxvY2tlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEJlZm9yZVVubG9hZEV2ZW50VHlwZSwgcHJvbXB0QmVmb3JlVW5sb2FkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdW5ibG9jaygpOyAvLyBSZW1vdmUgdGhlIGJlZm9yZXVubG9hZCBsaXN0ZW5lciBzbyB0aGUgZG9jdW1lbnQgbWF5XG4gICAgICAgIC8vIHN0aWxsIGJlIHNhbHZhZ2VhYmxlIGluIHRoZSBwYWdlaGlkZSBldmVudC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3VubG9hZGluZy1kb2N1bWVudHNcblxuICAgICAgICBpZiAoIWJsb2NrZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEJlZm9yZVVubG9hZEV2ZW50VHlwZSwgcHJvbXB0QmVmb3JlVW5sb2FkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuLyoqXHJcbiAqIEhhc2ggaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHdpbmRvdy5sb2NhdGlvbi5oYXNoLiBUaGlzIG1ha2VzIGl0IGlkZWFsXHJcbiAqIGZvciBzaXR1YXRpb25zIHdoZXJlIHlvdSBkb24ndCB3YW50IHRvIHNlbmQgdGhlIGxvY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgZm9yXHJcbiAqIHNvbWUgcmVhc29uLCBlaXRoZXIgYmVjYXVzZSB5b3UgZG8gY2Fubm90IGNvbmZpZ3VyZSBpdCBvciB0aGUgVVJMIHNwYWNlIGlzXHJcbiAqIHJlc2VydmVkIGZvciBzb21ldGhpbmcgZWxzZS5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVoYXNoaGlzdG9yeVxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zMiA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9uczIkd2luZG93ID0gX29wdGlvbnMyLndpbmRvdyxcbiAgICAgIHdpbmRvdyA9IF9vcHRpb25zMiR3aW5kb3cgPT09IHZvaWQgMCA/IGRvY3VtZW50LmRlZmF1bHRWaWV3IDogX29wdGlvbnMyJHdpbmRvdztcbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcblxuICBmdW5jdGlvbiBnZXRJbmRleEFuZExvY2F0aW9uKCkge1xuICAgIHZhciBfcGFyc2VQYXRoID0gcGFyc2VQYXRoKHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKSksXG4gICAgICAgIF9wYXJzZVBhdGgkcGF0aG5hbWUgPSBfcGFyc2VQYXRoLnBhdGhuYW1lLFxuICAgICAgICBwYXRobmFtZSA9IF9wYXJzZVBhdGgkcGF0aG5hbWUgPT09IHZvaWQgMCA/ICcvJyA6IF9wYXJzZVBhdGgkcGF0aG5hbWUsXG4gICAgICAgIF9wYXJzZVBhdGgkc2VhcmNoID0gX3BhcnNlUGF0aC5zZWFyY2gsXG4gICAgICAgIHNlYXJjaCA9IF9wYXJzZVBhdGgkc2VhcmNoID09PSB2b2lkIDAgPyAnJyA6IF9wYXJzZVBhdGgkc2VhcmNoLFxuICAgICAgICBfcGFyc2VQYXRoJGhhc2ggPSBfcGFyc2VQYXRoLmhhc2gsXG4gICAgICAgIGhhc2ggPSBfcGFyc2VQYXRoJGhhc2ggPT09IHZvaWQgMCA/ICcnIDogX3BhcnNlUGF0aCRoYXNoO1xuXG4gICAgdmFyIHN0YXRlID0gZ2xvYmFsSGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgICByZXR1cm4gW3N0YXRlLmlkeCwgcmVhZE9ubHkoe1xuICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgICBoYXNoOiBoYXNoLFxuICAgICAgc3RhdGU6IHN0YXRlLnVzciB8fCBudWxsLFxuICAgICAga2V5OiBzdGF0ZS5rZXkgfHwgJ2RlZmF1bHQnXG4gICAgfSldO1xuICB9XG5cbiAgdmFyIGJsb2NrZWRQb3BUeCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGlmIChibG9ja2VkUG9wVHgpIHtcbiAgICAgIGJsb2NrZXJzLmNhbGwoYmxvY2tlZFBvcFR4KTtcbiAgICAgIGJsb2NrZWRQb3BUeCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlBvcDtcblxuICAgICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uNCA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgICAgICBuZXh0SW5kZXggPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjRbMF0sXG4gICAgICAgICAgbmV4dExvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb240WzFdO1xuXG4gICAgICBpZiAoYmxvY2tlcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChuZXh0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBkZWx0YSA9IGluZGV4IC0gbmV4dEluZGV4O1xuXG4gICAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBSZXZlcnQgdGhlIFBPUFxuICAgICAgICAgICAgYmxvY2tlZFBvcFR4ID0ge1xuICAgICAgICAgICAgICBhY3Rpb246IG5leHRBY3Rpb24sXG4gICAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgICAgICAgIHJldHJ5OiBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgICAgICAgICAgICBnbyhkZWx0YSAqIC0xKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdvKGRlbHRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVHJ5aW5nIHRvIFBPUCB0byBhIGxvY2F0aW9uIHdpdGggbm8gaW5kZXguIFdlIGRpZCBub3QgY3JlYXRlXG4gICAgICAgICAgLy8gdGhpcyBsb2NhdGlvbiwgc28gd2UgY2FuJ3QgZWZmZWN0aXZlbHkgYmxvY2sgdGhlIG5hdmlnYXRpb24uXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgLy8gVE9ETzogV3JpdGUgdXAgYSBkb2MgdGhhdCBleHBsYWlucyBvdXIgYmxvY2tpbmcgc3RyYXRlZ3kgaW5cbiAgICAgICAgICAvLyBkZXRhaWwgYW5kIGxpbmsgdG8gaXQgaGVyZSBzbyBwZW9wbGUgY2FuIHVuZGVyc3RhbmQgYmV0dGVyXG4gICAgICAgICAgLy8gd2hhdCBpcyBnb2luZyBvbiBhbmQgaG93IHRvIGF2b2lkIGl0LlxuICAgICAgICAgIFwiWW91IGFyZSB0cnlpbmcgdG8gYmxvY2sgYSBQT1AgbmF2aWdhdGlvbiB0byBhIGxvY2F0aW9uIHRoYXQgd2FzIG5vdCBcIiArIFwiY3JlYXRlZCBieSB0aGUgaGlzdG9yeSBsaWJyYXJ5LiBUaGUgYmxvY2sgd2lsbCBmYWlsIHNpbGVudGx5IGluIFwiICsgXCJwcm9kdWN0aW9uLCBidXQgaW4gZ2VuZXJhbCB5b3Ugc2hvdWxkIGRvIGFsbCBuYXZpZ2F0aW9uIHdpdGggdGhlIFwiICsgXCJoaXN0b3J5IGxpYnJhcnkgKGluc3RlYWQgb2YgdXNpbmcgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlIGRpcmVjdGx5KSBcIiArIFwidG8gYXZvaWQgdGhpcyBzaXR1YXRpb24uXCIpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBseVR4KG5leHRBY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApOyAvLyBwb3BzdGF0ZSBkb2VzIG5vdCBmaXJlIG9uIGhhc2hjaGFuZ2UgaW4gSUUgMTEgYW5kIG9sZCAodHJpZGVudCkgRWRnZVxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kZS9kb2NzL1dlYi9BUEkvV2luZG93L3BvcHN0YXRlX2V2ZW50XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoSGFzaENoYW5nZUV2ZW50VHlwZSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjUgPSBnZXRJbmRleEFuZExvY2F0aW9uKCksXG4gICAgICAgIG5leHRMb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uNVsxXTsgLy8gSWdub3JlIGV4dHJhbmVvdXMgaGFzaGNoYW5nZSBldmVudHMuXG5cblxuICAgIGlmIChjcmVhdGVQYXRoKG5leHRMb2NhdGlvbikgIT09IGNyZWF0ZVBhdGgobG9jYXRpb24pKSB7XG4gICAgICBoYW5kbGVQb3AoKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgYWN0aW9uID0gQWN0aW9uLlBvcDtcblxuICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb242ID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpLFxuICAgICAgaW5kZXggPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjZbMF0sXG4gICAgICBsb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uNlsxXTtcblxuICB2YXIgbGlzdGVuZXJzID0gY3JlYXRlRXZlbnRzKCk7XG4gIHZhciBibG9ja2VycyA9IGNyZWF0ZUV2ZW50cygpO1xuXG4gIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgaW5kZXggPSAwO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LCBnbG9iYWxIaXN0b3J5LnN0YXRlLCB7XG4gICAgICBpZHg6IGluZGV4XG4gICAgfSksICcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJhc2VIcmVmKCkge1xuICAgIHZhciBiYXNlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgIHZhciBocmVmID0gJyc7XG5cbiAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB7XG4gICAgICB2YXIgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICB2YXIgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICAgIGhyZWYgPSBoYXNoSW5kZXggPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWY7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gICAgcmV0dXJuIGdldEJhc2VIcmVmKCkgKyAnIycgKyAodHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWRPbmx5KF9leHRlbmRzKHtcbiAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIGhhc2g6ICcnLFxuICAgICAgc2VhcmNoOiAnJ1xuICAgIH0sIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgodG8pIDogdG8sIHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGtleTogY3JlYXRlS2V5KClcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCkge1xuICAgIHJldHVybiBbe1xuICAgICAgdXNyOiBuZXh0TG9jYXRpb24uc3RhdGUsXG4gICAgICBrZXk6IG5leHRMb2NhdGlvbi5rZXksXG4gICAgICBpZHg6IGluZGV4XG4gICAgfSwgY3JlYXRlSHJlZihuZXh0TG9jYXRpb24pXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG93VHgoYWN0aW9uLCBsb2NhdGlvbiwgcmV0cnkpIHtcbiAgICByZXR1cm4gIWJsb2NrZXJzLmxlbmd0aCB8fCAoYmxvY2tlcnMuY2FsbCh7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHJldHJ5OiByZXRyeVxuICAgIH0pLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVR4KG5leHRBY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBuZXh0QWN0aW9uO1xuXG4gICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uNyA9IGdldEluZGV4QW5kTG9jYXRpb24oKTtcblxuICAgIGluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb243WzBdO1xuICAgIGxvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb243WzFdO1xuICAgIGxpc3RlbmVycy5jYWxsKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICBwdXNoKHRvLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhuZXh0TG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5wdXNoKFwiICsgSlNPTi5zdHJpbmdpZnkodG8pICsgXCIpXCIpIDogdm9pZCAwO1xuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIHZhciBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIzID0gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXggKyAxKSxcbiAgICAgICAgICBoaXN0b3J5U3RhdGUgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIzWzBdLFxuICAgICAgICAgIHVybCA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjNbMV07IC8vIFRPRE86IFN1cHBvcnQgZm9yY2VkIHJlbG9hZGluZ1xuICAgICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cblxuXG4gICAgICB0cnkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCB1cmwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gVGhleSBhcmUgZ29pbmcgdG8gbG9zZSBzdGF0ZSBoZXJlLCBidXQgdGhlcmUgaXMgbm8gcmVhbFxuICAgICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICB9XG5cbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgcmVwbGFjZSh0bywgc3RhdGUpO1xuICAgIH1cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcobmV4dExvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLCBcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucmVwbGFjZShcIiArIEpTT04uc3RyaW5naWZ5KHRvKSArIFwiKVwiKSA6IHZvaWQgMDtcblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICB2YXIgX2dldEhpc3RvcnlTdGF0ZUFuZFVyNCA9IGdldEhpc3RvcnlTdGF0ZUFuZFVybChuZXh0TG9jYXRpb24sIGluZGV4KSxcbiAgICAgICAgICBoaXN0b3J5U3RhdGUgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXI0WzBdLFxuICAgICAgICAgIHVybCA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjRbMV07IC8vIFRPRE86IFN1cHBvcnQgZm9yY2VkIHJlbG9hZGluZ1xuXG5cbiAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIHVybCk7XG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKGRlbHRhKSB7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhkZWx0YSk7XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgYmFjazogZnVuY3Rpb24gYmFjaygpIHtcbiAgICAgIGdvKC0xKTtcbiAgICB9LFxuICAgIGZvcndhcmQ6IGZ1bmN0aW9uIGZvcndhcmQoKSB7XG4gICAgICBnbygxKTtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH0sXG4gICAgYmxvY2s6IGZ1bmN0aW9uIGJsb2NrKGJsb2NrZXIpIHtcbiAgICAgIHZhciB1bmJsb2NrID0gYmxvY2tlcnMucHVzaChibG9ja2VyKTtcblxuICAgICAgaWYgKGJsb2NrZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihCZWZvcmVVbmxvYWRFdmVudFR5cGUsIHByb21wdEJlZm9yZVVubG9hZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHVuYmxvY2soKTsgLy8gUmVtb3ZlIHRoZSBiZWZvcmV1bmxvYWQgbGlzdGVuZXIgc28gdGhlIGRvY3VtZW50IG1heVxuICAgICAgICAvLyBzdGlsbCBiZSBzYWx2YWdlYWJsZSBpbiB0aGUgcGFnZWhpZGUgZXZlbnQuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyN1bmxvYWRpbmctZG9jdW1lbnRzXG5cbiAgICAgICAgaWYgKCFibG9ja2Vycy5sZW5ndGgpIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihCZWZvcmVVbmxvYWRFdmVudFR5cGUsIHByb21wdEJlZm9yZVVubG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8qKlxyXG4gKiBNZW1vcnkgaGlzdG9yeSBzdG9yZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gbWVtb3J5LiBJdCBpcyBkZXNpZ25lZCBmb3IgdXNlXHJcbiAqIGluIHN0YXRlZnVsIG5vbi1icm93c2VyIGVudmlyb25tZW50cyBsaWtlIHRlc3RzIGFuZCBSZWFjdCBOYXRpdmUuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlbWVtb3J5aGlzdG9yeVxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMzID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zMyRpbml0aWFsRW50ciA9IF9vcHRpb25zMy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxFbnRyaWVzID0gX29wdGlvbnMzJGluaXRpYWxFbnRyID09PSB2b2lkIDAgPyBbJy8nXSA6IF9vcHRpb25zMyRpbml0aWFsRW50cixcbiAgICAgIGluaXRpYWxJbmRleCA9IF9vcHRpb25zMy5pbml0aWFsSW5kZXg7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHZhciBsb2NhdGlvbiA9IHJlYWRPbmx5KF9leHRlbmRzKHtcbiAgICAgIHBhdGhuYW1lOiAnLycsXG4gICAgICBzZWFyY2g6ICcnLFxuICAgICAgaGFzaDogJycsXG4gICAgICBzdGF0ZTogbnVsbCxcbiAgICAgIGtleTogY3JlYXRlS2V5KClcbiAgICB9LCB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKGVudHJ5KSA6IGVudHJ5KSk7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJywgXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY3JlYXRlTWVtb3J5SGlzdG9yeSh7IGluaXRpYWxFbnRyaWVzIH0pIChpbnZhbGlkIGVudHJ5OiBcIiArIEpTT04uc3RyaW5naWZ5KGVudHJ5KSArIFwiKVwiKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH0pO1xuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXggPT0gbnVsbCA/IGVudHJpZXMubGVuZ3RoIC0gMSA6IGluaXRpYWxJbmRleCwgMCwgZW50cmllcy5sZW5ndGggLSAxKTtcbiAgdmFyIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIHZhciBsb2NhdGlvbiA9IGVudHJpZXNbaW5kZXhdO1xuICB2YXIgbGlzdGVuZXJzID0gY3JlYXRlRXZlbnRzKCk7XG4gIHZhciBibG9ja2VycyA9IGNyZWF0ZUV2ZW50cygpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYodG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVhZE9ubHkoX2V4dGVuZHMoe1xuICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoOiAnJyxcbiAgICAgIGhhc2g6ICcnXG4gICAgfSwgdHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAga2V5OiBjcmVhdGVLZXkoKVxuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG93VHgoYWN0aW9uLCBsb2NhdGlvbiwgcmV0cnkpIHtcbiAgICByZXR1cm4gIWJsb2NrZXJzLmxlbmd0aCB8fCAoYmxvY2tlcnMuY2FsbCh7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHJldHJ5OiByZXRyeVxuICAgIH0pLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVR4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbikge1xuICAgIGFjdGlvbiA9IG5leHRBY3Rpb247XG4gICAgbG9jYXRpb24gPSBuZXh0TG9jYXRpb247XG4gICAgbGlzdGVuZXJzLmNhbGwoe1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2godG8sIHN0YXRlKSB7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIHB1c2godG8sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLCBcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeS5wdXNoKFwiICsgSlNPTi5zdHJpbmdpZnkodG8pICsgXCIpXCIpIDogdm9pZCAwO1xuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgcmVwbGFjZSh0bywgc3RhdGUpO1xuICAgIH1cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5LnJlcGxhY2UoXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIikgOiB2b2lkIDA7XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgZW50cmllc1tpbmRleF0gPSBuZXh0TG9jYXRpb247XG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ28oZGVsdGEpIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaW5kZXggKyBkZWx0YSwgMCwgZW50cmllcy5sZW5ndGggLSAxKTtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICBpbmRleCA9IG5leHRJbmRleDtcbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG5cbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfSxcblxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xuICAgICAgZ28oLTEpO1xuICAgIH0sXG4gICAgZm9yd2FyZDogZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgICAgIGdvKDEpO1xuICAgIH0sXG4gICAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBibG9jazogZnVuY3Rpb24gYmxvY2soYmxvY2tlcikge1xuICAgICAgcmV0dXJuIGJsb2NrZXJzLnB1c2goYmxvY2tlcik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59XG5cbmZ1bmN0aW9uIHByb21wdEJlZm9yZVVubG9hZChldmVudCkge1xuICAvLyBDYW5jZWwgdGhlIGV2ZW50LlxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBDaHJvbWUgKGFuZCBsZWdhY3kgSUUpIHJlcXVpcmVzIHJldHVyblZhbHVlIHRvIGJlIHNldC5cblxuICBldmVudC5yZXR1cm5WYWx1ZSA9ICcnO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudHMoKSB7XG4gIHZhciBoYW5kbGVycyA9IFtdO1xuICByZXR1cm4ge1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKGZuKSB7XG4gICAgICBoYW5kbGVycy5wdXNoKGZuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXIgIT09IGZuO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBjYWxsOiBmdW5jdGlvbiBjYWxsKGFyZykge1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuICYmIGZuKGFyZyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA4KTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgc3RyaW5nIFVSTCBwYXRoIGZyb20gdGhlIGdpdmVuIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlcGF0aFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVQYXRoKF9yZWYpIHtcbiAgdmFyIF9yZWYkcGF0aG5hbWUgPSBfcmVmLnBhdGhuYW1lLFxuICAgICAgcGF0aG5hbWUgPSBfcmVmJHBhdGhuYW1lID09PSB2b2lkIDAgPyAnLycgOiBfcmVmJHBhdGhuYW1lLFxuICAgICAgX3JlZiRzZWFyY2ggPSBfcmVmLnNlYXJjaCxcbiAgICAgIHNlYXJjaCA9IF9yZWYkc2VhcmNoID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkc2VhcmNoLFxuICAgICAgX3JlZiRoYXNoID0gX3JlZi5oYXNoLFxuICAgICAgaGFzaCA9IF9yZWYkaGFzaCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGhuYW1lICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09ICc/JyA/IHNlYXJjaCA6ICc/JyArIHNlYXJjaDtcbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRobmFtZSArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6ICcjJyArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cbi8qKlxyXG4gKiBQYXJzZXMgYSBzdHJpbmcgVVJMIHBhdGggaW50byBpdHMgc2VwYXJhdGUgcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNwYXJzZXBhdGhcclxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXJzZWRQYXRoID0ge307XG5cbiAgaWYgKHBhdGgpIHtcbiAgICB2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG5cbiAgICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguaGFzaCA9IHBhdGguc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICB2YXIgc2VhcmNoSW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcblxuICAgIGlmIChzZWFyY2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLnNlYXJjaCA9IHBhdGguc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJzZWRQYXRoO1xufVxuXG5leHBvcnQgeyBBY3Rpb24sIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlUGF0aCwgcGFyc2VQYXRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIkFjdGlvbiIsInJlYWRPbmx5IiwicHJvY2VzcyIsIm9iaiIsIk9iamVjdCIsImZyZWV6ZSIsIndhcm5pbmciLCJjb25kIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiRXJyb3IiLCJlIiwiQmVmb3JlVW5sb2FkRXZlbnRUeXBlIiwiSGFzaENoYW5nZUV2ZW50VHlwZSIsIlBvcFN0YXRlRXZlbnRUeXBlIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJvcHRpb25zIiwiX29wdGlvbnMiLCJfb3B0aW9ucyR3aW5kb3ciLCJ3aW5kb3ciLCJkb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiZ2xvYmFsSGlzdG9yeSIsImhpc3RvcnkiLCJnZXRJbmRleEFuZExvY2F0aW9uIiwiX3dpbmRvdyRsb2NhdGlvbiIsImxvY2F0aW9uIiwicGF0aG5hbWUiLCJzZWFyY2giLCJoYXNoIiwic3RhdGUiLCJpZHgiLCJ1c3IiLCJrZXkiLCJibG9ja2VkUG9wVHgiLCJoYW5kbGVQb3AiLCJibG9ja2VycyIsImNhbGwiLCJuZXh0QWN0aW9uIiwiUG9wIiwiX2dldEluZGV4QW5kTG9jYXRpb24iLCJuZXh0SW5kZXgiLCJuZXh0TG9jYXRpb24iLCJsZW5ndGgiLCJkZWx0YSIsImluZGV4IiwiYWN0aW9uIiwicmV0cnkiLCJnbyIsImFwcGx5VHgiLCJhZGRFdmVudExpc3RlbmVyIiwiX2dldEluZGV4QW5kTG9jYXRpb24yIiwibGlzdGVuZXJzIiwiY3JlYXRlRXZlbnRzIiwicmVwbGFjZVN0YXRlIiwiY3JlYXRlSHJlZiIsInRvIiwiY3JlYXRlUGF0aCIsImdldE5leHRMb2NhdGlvbiIsInBhcnNlUGF0aCIsImNyZWF0ZUtleSIsImdldEhpc3RvcnlTdGF0ZUFuZFVybCIsImFsbG93VHgiLCJfZ2V0SW5kZXhBbmRMb2NhdGlvbjMiLCJwdXNoIiwiUHVzaCIsIl9nZXRIaXN0b3J5U3RhdGVBbmRVciIsImhpc3RvcnlTdGF0ZSIsInVybCIsInB1c2hTdGF0ZSIsImVycm9yIiwiYXNzaWduIiwicmVwbGFjZSIsIlJlcGxhY2UiLCJfZ2V0SGlzdG9yeVN0YXRlQW5kVXIyIiwiYmFjayIsImZvcndhcmQiLCJsaXN0ZW4iLCJsaXN0ZW5lciIsImJsb2NrIiwiYmxvY2tlciIsInVuYmxvY2siLCJwcm9tcHRCZWZvcmVVbmxvYWQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJfb3B0aW9uczIiLCJfb3B0aW9uczIkd2luZG93IiwiX3BhcnNlUGF0aCIsInN1YnN0ciIsIl9wYXJzZVBhdGgkcGF0aG5hbWUiLCJfcGFyc2VQYXRoJHNlYXJjaCIsIl9wYXJzZVBhdGgkaGFzaCIsIl9nZXRJbmRleEFuZExvY2F0aW9uNCIsIl9nZXRJbmRleEFuZExvY2F0aW9uNSIsIl9nZXRJbmRleEFuZExvY2F0aW9uNiIsImdldEJhc2VIcmVmIiwiYmFzZSIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwiX2dldEluZGV4QW5kTG9jYXRpb243IiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsIl9nZXRIaXN0b3J5U3RhdGVBbmRVcjMiLCJfZ2V0SGlzdG9yeVN0YXRlQW5kVXI0IiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIl9vcHRpb25zMyIsIl9vcHRpb25zMyRpbml0aWFsRW50ciIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwiZW50cmllcyIsIm1hcCIsImVudHJ5IiwiY2xhbXAiLCJzcGxpY2UiLCJuIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJNYXRoIiwibWluIiwibWF4IiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInJldHVyblZhbHVlIiwiaGFuZGxlcnMiLCJmbiIsImZpbHRlciIsImhhbmRsZXIiLCJhcmciLCJmb3JFYWNoIiwicmFuZG9tIiwidG9TdHJpbmciLCJfcmVmIiwiX3JlZiRwYXRobmFtZSIsIl9yZWYkc2VhcmNoIiwiX3JlZiRoYXNoIiwicGF0aCIsInBhcnNlZFBhdGgiLCJzZWFyY2hJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/history/index.js\n");

/***/ })

};
;